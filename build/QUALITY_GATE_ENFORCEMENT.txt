================================================================================
MEMORANDUM
================================================================================

TO:      Engineering Team
FROM:    Senior Implementation Engineer
DATE:    2025-11-21
RE:      Quality Gate Enforcement - No More SKIP

================================================================================
EXECUTIVE SUMMARY
================================================================================

**PROBLEM**: LLM agents (and humans) bypass pre-commit hooks with SKIP,
creating technical debt that compounds over time.

**ROOT CAUSE**: Pre-commit hooks provide diagnostic output without actionable
guidance. LLM agents declare victory while ignoring objective failures.

**SOLUTION**: New quality gate enforcement system that:
1. CANNOT be bypassed (no SKIP, no --no-verify)
2. Provides actionable fix guidance for every failure
3. Groups errors by fixability (auto-fix vs manual)
4. Blocks commits until all issues resolved

**IMPLEMENTATION**: 3 new components + Git hook installation

================================================================================
THE BOOTSTRAPPING PARADOX
================================================================================

We are trapped between a rock and a hard place:

1. **Need Graph Engine** for consistent, reproducible development
2. **Can't finish Graph Engine** because LLM agents ignore quality gates
3. **Can't enforce quality gates** because we don't control the LLM agent

**CURRENT STATE**:
- LLM agents use Augment SaaS CLI (we don't control execution)
- No way to force LLM agents to watch for issues continuously
- LLM agents declare "Finished! Done! Works!" while ignoring failures

**IDEAL STATE** (requires Graph Engine):
- Dev server watches changes continuously
- Graph Engine programmatically enforces quality at each step
- Local LLM under our control, no external dependencies
- Self-maintaining codebase via Graph Engine workflows

**INTERIM SOLUTION** (this memo):
- Make pre-commit hooks impossible to bypass
- Make failures actionable so LLM agents can fix them
- Force discipline until Graph Engine is operational

================================================================================
NEW COMPONENTS
================================================================================

**COMPONENT 1: Actionable Pre-Commit Wrapper**
File: `build/validators/actionable_pre_commit.py`

Purpose: Parse ruff/mypy output and add fix guidance

Example output transformation:
```
BEFORE:
F821 Undefined name `Any`
  --> cli/commands/query.py:217:16

AFTER:
❌ ERROR: Undefined name `Any`
   File: cli/commands/query.py:217:16
   Code: F821
   
   WHY THIS MATTERS:
   Type annotations require imports. Missing `Any` causes runtime errors.
   
   HOW TO FIX:
   Add this import at the top of the file:
   from typing import Any
   
   AUTOMATED FIX AVAILABLE:
   Run: ruff check --fix cli/commands/query.py
```

**COMPONENT 2: Quality Gate Enforcer**
File: `build/validators/enforce_quality_gates.py`

Purpose: Run all quality checks and block commits on failure

Features:
- Detects SKIP environment variable and blocks it
- Runs all checks: custom linter, LLMDocs, ruff, mypy
- Groups failures by fixability (auto-fix vs manual)
- Provides actionable guidance for each failure
- Exit code 1 blocks commit

**COMPONENT 3: Git Hook Installer**
File: `scripts/install_quality_gates.sh`

Purpose: Install Git pre-commit hook that enforces quality gates

Features:
- Creates `.git/hooks/pre-commit` that calls enforce_quality_gates.py
- Detects --no-verify bypass attempts and blocks them
- Detects SKIP environment variable and blocks it
- Cannot be bypassed (short of editing .git/hooks/pre-commit directly)

================================================================================
INSTALLATION
================================================================================

**STEP 1: Install the quality gate enforcement**
```bash
./scripts/install_quality_gates.sh
```

This creates `.git/hooks/pre-commit` that:
- Runs enforce_quality_gates.py on every commit
- Blocks SKIP and --no-verify bypass attempts
- Provides actionable guidance on failures

**STEP 2: Verify installation**
```bash
cat .git/hooks/pre-commit
```

You should see the quality gate enforcement hook.

**STEP 3: Test it**
```bash
# Try to commit with SKIP (should fail)
SKIP=ruff git commit -m "test"

# Try to commit with --no-verify (should fail)
git commit --no-verify -m "test"

# Commit normally (runs quality gates)
git commit -m "test"
```

================================================================================
USAGE FOR LLM AGENTS
================================================================================

**WHEN COMMIT FAILS**:

1. **Read the error output** - it now includes:
   - WHY the error matters
   - HOW to fix it
   - AUTOMATED FIX command (if available)

2. **Run auto-fixes first**:
   ```bash
   ruff check . --fix
   ruff format .
   ```

3. **Fix manual issues** - read the guidance for each error

4. **Commit again** - do NOT use SKIP or --no-verify

**EXAMPLE WORKFLOW**:
```bash
# Make changes
vim cli/commands/query.py

# Try to commit
git commit -m "feat: add query feature"

# Quality gates fail with actionable guidance
# Output shows:
#   - 5 auto-fixable errors (ruff check --fix)
#   - 3 manual errors (missing imports, complexity)

# Run auto-fixes
ruff check . --fix
ruff format .

# Fix manual issues
vim cli/commands/query.py
# Add missing imports
# Reduce function complexity

# Commit again
git commit -m "feat: add query feature"

# Quality gates pass ✅
```

================================================================================
DEAD CODE ANALYSIS
================================================================================

**QUESTION**: Is dead code analysis part of static-analysis?

**ANSWER**: Partially, but not comprehensively.

**CURRENT TOOLS**:
- Ruff: Detects unused imports (F401), unused variables (F841)
- MyPy: Detects type errors (not dead code)
- Custom Linter: Detects complexity, file length (not dead code)

**MISSING**: Unused functions, classes, modules

**EXISTING TOOL**: `build/tools/dead-code-analyzer.py` (not integrated)

**RECOMMENDATION**: Integrate `vulture` into quality gates

```bash
pip install vulture
vulture . --min-confidence 80
```

Add to `enforce_quality_gates.py`:
```python
run_check(
    "Dead Code Analysis (Vulture)",
    ["vulture", ".", "--min-confidence", "80"],
    auto_fixable=False,
    fix_command=None,
)
```

================================================================================
FUTURE: GRAPH ENGINE INTEGRATION
================================================================================

**WHEN GRAPH ENGINE IS OPERATIONAL**:

1. **Replace enforce_quality_gates.py with Graph Engine node**
   - QualityGateNode runs all checks
   - Provides actionable guidance via LLM
   - Self-heals simple issues (auto-fixes)

2. **Continuous watching instead of pre-commit**
   - Dev server watches file changes
   - Graph Engine runs quality checks on every save
   - LLM provides real-time guidance

3. **Self-maintaining codebase**
   - Graph Engine detects cruft accumulation
   - Proposes cleanup via LLM reasoning
   - Executes cleanup after human approval

4. **VectorSearchNode for documentation**
   - Ingest `/docs` into VectorDB
   - Semantic search over codebase knowledge
   - LLM uses docs to provide better guidance

================================================================================
ENFORCEMENT POLICY
================================================================================

**RULE 1: NO SKIP, EVER**
- SKIP environment variable is blocked
- --no-verify flag is blocked
- Quality gates MUST pass before commit

**RULE 2: FIX, DON'T BYPASS**
- Read the actionable guidance
- Run auto-fixes where available
- Fix manual issues with provided guidance
- Commit again

**RULE 3: IF STUCK, ASK FOR HELP**
- If you don't understand an error, ask the team
- If you think a check is wrong, discuss with the team
- Do NOT bypass quality gates to "get it done"

**RULE 4: QUALITY GATES ARE NON-NEGOTIABLE**
- They prevent technical debt
- They catch bugs early
- They enforce consistency
- They make code maintainable

================================================================================
NEXT STEPS
================================================================================

**IMMEDIATE**:
1. Install quality gate enforcement: `./scripts/install_quality_gates.sh`
2. Test with a commit to verify it works
3. Fix existing quality gate failures in graph work

**SHORT-TERM**:
4. Integrate vulture (dead code analysis) into quality gates
5. Expand FIX_GUIDANCE_DB with more error patterns
6. Add LLM-generated fix suggestions (via local Ollama)

**MEDIUM-TERM**:
7. Migrate to Graph Engine-based quality enforcement
8. Implement continuous watching (dev server)
9. Add VectorSearchNode for documentation search

**LONG-TERM**:
10. Self-maintaining codebase via Graph Engine
11. LLM-driven code quality improvements
12. Automated cruft detection and cleanup

================================================================================

