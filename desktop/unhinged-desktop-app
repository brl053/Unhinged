#!/usr/bin/env python3
"""
@llm-doc Unhinged Desktop Application for Ubuntu GNOME
@llm-version 1.0.0
@llm-date 2025-01-26
@llm-author Unhinged Team

## Overview
Native Ubuntu GNOME desktop application that provides the same functionality
as 'make start' through a graphical interface. Users can launch by double-clicking
an icon or from the application menu.

## Features
- GTK4-based native Ubuntu GNOME interface
- Visual representation of 'make start' functionality
- Real-time status updates and progress indication
- Integration with existing Makefile system and VM communication
- User-friendly error handling and feedback

## Design Principles
- **Native Integration**: Uses GTK4 for authentic Ubuntu GNOME experience
- **Functionality Mapping**: Executes same operations as 'make start'
- **Visual Appeal**: Modern, clean interface following GNOME HIG
- **Accessibility**: Keyboard navigation and screen reader support

@llm-principle Native desktop integration with existing backend
@llm-culture Independence through accessible graphical interface
"""

import gi
gi.require_version('Gtk', '4.0')
gi.require_version('Adw', '1')

from gi.repository import Gtk, Adw, GLib, Gio, Pango
import subprocess
import threading
import sys
import os
from pathlib import Path

# Import auto-updater
try:
    from auto_updater import AutoUpdater, UpdateStatus
    AUTO_UPDATE_AVAILABLE = True
except ImportError as e:
    print(f"‚ö†Ô∏è Auto-updater not available: {e}")
    AUTO_UPDATE_AVAILABLE = False
import time
import json

# Import session logging from event framework
sys.path.append(str(Path(__file__).parent.parent / "libs" / "event-framework" / "python" / "src"))
try:
    from unhinged_events import create_gui_session_logger, GUIOutputCapture
    SESSION_LOGGING_AVAILABLE = True
except ImportError as e:
    print(f"‚ö†Ô∏è Session logging not available: {e}")
    SESSION_LOGGING_AVAILABLE = False

# Simple approach: Use control modules as scripts (academic exercise)
CONTROL_MODULES_AVAILABLE = True
print("‚úÖ Control modules available as scripts")

class UnhingedDesktopApp(Adw.Application):
    """
    @llm-doc Main Desktop Application Class

    GTK4/Libadwaita application that provides graphical interface
    for Unhinged platform functionality.
    """

    def __init__(self):
        super().__init__(application_id='com.unhinged.platform')
        self.project_root = Path(__file__).parent.parent
        self.window = None
        self.status_label = None
        self.progress_bar = None
        self.log_textview = None
        self.start_button = None
        self.stop_button = None
        self.process = None
        self.running = False

        # Initialize session logging
        self.session_logger = None
        self.output_capture = None
        if SESSION_LOGGING_AVAILABLE:
            try:
                self.session_logger = create_gui_session_logger(self.project_root)
                self.output_capture = GUIOutputCapture(
                    self.session_logger,
                    self._gui_log_callback
                )
                self.session_logger.log_session_event("APP_INIT", "Desktop application initialized")
            except Exception as e:
                print(f"‚ö†Ô∏è Session logging initialization failed: {e}")
                self.session_logger = None
                self.output_capture = None

        # Initialize auto-updater
        self.auto_updater = None
        self.update_info = None
        if AUTO_UPDATE_AVAILABLE:
            try:
                self.auto_updater = AutoUpdater(self.project_root)
                if self.session_logger:
                    self.session_logger.log_gui_event("AUTO_UPDATE_INIT", "Auto-updater initialized")
            except Exception as e:
                print(f"‚ö†Ô∏è Auto-updater initialization failed: {e}")
                if self.session_logger:
                    self.session_logger.log_gui_event("AUTO_UPDATE_INIT_ERROR", f"Auto-updater failed: {e}")
        
    def do_activate(self):
        """Application activation - create and show main window"""
        if not self.window:
            self.window = self.create_main_window()

        # Log application activation
        if self.session_logger:
            self.session_logger.log_gui_event("APP_ACTIVATE", "Main window created and presented")

        self.window.present()

        # Check for updates after window is shown
        if self.auto_updater:
            GLib.timeout_add_seconds(3, self._check_for_updates_async)
    
    def create_main_window(self):
        """
        @llm-doc Create Main Application Window
        
        Creates the main GTK4 window with modern Ubuntu GNOME styling
        using Libadwaita for native look and feel.
        """
        # Create main window
        window = Adw.ApplicationWindow(application=self)
        window.set_title("Unhinged - Native Graphics Platform")
        window.set_default_size(800, 600)
        window.set_icon_name("applications-graphics")

        # Add actions (AdwApplicationWindow has built-in header bar)
        self.setup_actions()
        
        # Create toast overlay for notifications
        self.toast_overlay = Adw.ToastOverlay()

        # Create main content
        main_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=12)
        main_box.set_margin_top(24)
        main_box.set_margin_bottom(24)
        main_box.set_margin_start(24)
        main_box.set_margin_end(24)
        
        # Welcome section
        welcome_group = self.create_welcome_section()
        main_box.append(welcome_group)
        
        # Control section
        control_group = self.create_control_section()
        main_box.append(control_group)

        # Conversation section
        conversation_group = self.create_conversation_section()
        main_box.append(conversation_group)

        # Update section (if auto-updater available)
        if AUTO_UPDATE_AVAILABLE:
            update_group = self.create_update_section()
            main_box.append(update_group)

        # Status section
        status_group = self.create_status_section()
        main_box.append(status_group)
        
        # Log section
        log_group = self.create_log_section()
        main_box.append(log_group)
        
        # Create scrolled window for content
        scrolled = Gtk.ScrolledWindow()
        scrolled.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC)
        scrolled.set_child(main_box)

        # Set up toast overlay
        self.toast_overlay.set_child(scrolled)
        window.set_content(self.toast_overlay)
        return window

    def setup_actions(self):
        """Setup application actions for menu"""
        # About action
        about_action = Gio.SimpleAction.new("about", None)
        about_action.connect("activate", self.on_about_action)
        self.add_action(about_action)

        # Preferences action
        preferences_action = Gio.SimpleAction.new("preferences", None)
        preferences_action.connect("activate", self.on_preferences_action)
        self.add_action(preferences_action)

        # Quit action
        quit_action = Gio.SimpleAction.new("quit", None)
        quit_action.connect("activate", self.on_quit_action)
        self.add_action(quit_action)

        # Keyboard shortcuts
        self.set_accels_for_action("app.quit", ["<Ctrl>Q"])

        # Create application menu
        menu = Gio.Menu()
        menu.append("About Unhinged", "app.about")
        menu.append("Preferences", "app.preferences")
        menu.append("Quit", "app.quit")
        self.set_menubar(menu)

    def on_about_action(self, action, param):
        """Show about dialog"""
        about = Adw.AboutWindow(transient_for=self.window)
        about.set_application_name("Unhinged")
        about.set_application_icon("applications-graphics")
        about.set_developer_name("Unhinged Team")
        about.set_version("1.0.0")
        about.set_website("https://github.com/unhinged/platform")
        about.set_issue_url("https://github.com/unhinged/platform/issues")
        about.set_copyright("¬© 2025 Unhinged Team")
        about.set_license_type(Gtk.License.MIT_X11)
        about.set_comments("Native Graphics Platform with VM Communication\n\nIndependent graphics rendering with reliable communication pipeline.")
        about.present()

    def on_preferences_action(self, action, param):
        """Show preferences dialog"""
        # Create preferences window
        prefs = Adw.PreferencesWindow(transient_for=self.window)
        prefs.set_title("Preferences")

        # General page
        general_page = Adw.PreferencesPage()
        general_page.set_title("General")
        general_page.set_icon_name("preferences-system-symbolic")

        # Launch settings group
        launch_group = Adw.PreferencesGroup()
        launch_group.set_title("Launch Settings")
        launch_group.set_description("Configure how Unhinged starts")

        # Auto-start row
        autostart_row = Adw.SwitchRow()
        autostart_row.set_title("Auto-start on login")
        autostart_row.set_subtitle("Automatically start Unhinged when you log in")
        launch_group.add(autostart_row)

        general_page.add(launch_group)
        prefs.add(general_page)
        prefs.present()

    def on_quit_action(self, action, param):
        """Quit application"""
        if self.running:
            self.on_stop_clicked(None)

        # Close session logging
        if self.session_logger:
            self.session_logger.log_session_event("APP_QUIT", "Application quit requested")
            self.session_logger.close_session()

        self.quit()
    
    def create_welcome_section(self):
        """Create welcome section with app info"""
        group = Adw.PreferencesGroup()
        group.set_title("Unhinged Native Graphics Platform")
        group.set_description("Independent graphics rendering with VM communication")

        # Status row
        status_row = Adw.ActionRow()
        status_row.set_title("Platform Status")
        status_row.set_subtitle("Ready to launch")

        # Status icon
        status_icon = Gtk.Image.new_from_icon_name("emblem-default-symbolic")
        status_icon.set_icon_size(Gtk.IconSize.LARGE)
        status_row.add_prefix(status_icon)

        group.add(status_row)

        # Features row
        features_row = Adw.ActionRow()
        features_row.set_title("Features")
        features_row.set_subtitle("VM Communication ‚Ä¢ Native Graphics ‚Ä¢ Independence")

        features_icon = Gtk.Image.new_from_icon_name("applications-graphics-symbolic")
        features_icon.set_icon_size(Gtk.IconSize.LARGE)
        features_row.add_prefix(features_icon)

        group.add(features_row)

        return group
    
    def create_control_section(self):
        """Create control section with start/stop buttons"""
        group = Adw.PreferencesGroup()
        group.set_title("Platform Control")
        group.set_description("Launch and manage the Unhinged graphics platform")

        # Control row
        control_row = Adw.ActionRow()
        control_row.set_title("Platform Launcher")
        control_row.set_subtitle("Execute 'make start' functionality")

        # Button box
        button_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=6)

        # Start button
        self.start_button = Gtk.Button.new_with_label("Start Platform")
        self.start_button.add_css_class("suggested-action")
        self.start_button.connect("clicked", self.on_start_clicked)
        button_box.append(self.start_button)

        # Stop button
        self.stop_button = Gtk.Button.new_with_label("Stop")
        self.stop_button.add_css_class("destructive-action")
        self.stop_button.set_sensitive(False)
        self.stop_button.connect("clicked", self.on_stop_clicked)
        button_box.append(self.stop_button)

        control_row.add_suffix(button_box)
        group.add(control_row)

        # Launch mode row
        mode_row = Adw.ActionRow()
        mode_row.set_title("Launch Mode")
        mode_row.set_subtitle("Choose how to start the platform")

        # Mode dropdown
        self.mode_dropdown = Gtk.DropDown.new_from_strings([
            "Enhanced (Recommended)",
            "Simple Communication",
            "Quality of Life",
            "Custom ISO"
        ])
        self.mode_dropdown.set_selected(0)  # Default to Enhanced
        mode_row.add_suffix(self.mode_dropdown)

        group.add(mode_row)

        return group

    def create_conversation_section(self):
        """Create conversation interface section"""
        group = Adw.PreferencesGroup()
        group.set_title("üéôÔ∏è Conversation Interface")
        group.set_description("Voice-first conversation interface for dual-system architecture")

        # GTK4 Control Plane Conversation
        gtk4_row = Adw.ActionRow()
        gtk4_row.set_title("GTK4 Control Plane Conversation")
        gtk4_row.set_subtitle("Start conversation interface in GTK4 control plane context")

        gtk4_button = Gtk.Button(label="üéôÔ∏è Start GTK4 Conversation")
        gtk4_button.add_css_class("suggested-action")
        gtk4_button.connect("clicked", self.on_gtk4_conversation_clicked)
        gtk4_row.add_suffix(gtk4_button)
        group.add(gtk4_row)

        # Alpine VM Conversation
        alpine_row = Adw.ActionRow()
        alpine_row.set_title("Alpine VM Conversation")
        alpine_row.set_subtitle("Start conversation interface in Alpine native context")

        alpine_button = Gtk.Button(label="üèîÔ∏è Start Alpine Conversation")
        alpine_button.add_css_class("accent")
        alpine_button.connect("clicked", self.on_alpine_conversation_clicked)
        alpine_row.add_suffix(alpine_button)
        group.add(alpine_row)

        # Text-Only Mode
        text_row = Adw.ActionRow()
        text_row.set_title("Text-Only Conversation")
        text_row.set_subtitle("Start conversation interface in text-only mode")

        text_button = Gtk.Button(label="‚å®Ô∏è Start Text Conversation")
        text_button.connect("clicked", self.on_text_conversation_clicked)
        text_row.add_suffix(text_button)
        group.add(text_row)

        return group

    def create_update_section(self):
        """Create auto-update section"""
        group = Adw.PreferencesGroup()
        group.set_title("üîÑ Application Updates")
        group.set_description("Automatic update checking and installation")

        # Update status row
        self.update_status_row = Adw.ActionRow()
        self.update_status_row.set_title("Update Status")
        self.update_status_row.set_subtitle("Checking for updates...")

        # Update button
        self.update_button = Gtk.Button(label="Check for Updates")
        self.update_button.connect("clicked", self.on_check_updates_clicked)
        self.update_status_row.add_suffix(self.update_button)
        group.add(self.update_status_row)

        # Version info row
        self.version_info_row = Adw.ActionRow()
        self.version_info_row.set_title("Current Version")
        self.version_info_row.set_subtitle("Loading version information...")
        group.add(self.version_info_row)

        return group

    def create_status_section(self):
        """Create status section with progress indication"""
        group = Adw.PreferencesGroup()
        group.set_title("Status")

        # Status row with icon
        status_row = Adw.ActionRow()
        status_row.set_title("Platform Status")

        # Status icon
        self.status_icon = Gtk.Image.new_from_icon_name("emblem-default-symbolic")
        self.status_icon.set_icon_size(Gtk.IconSize.LARGE)
        status_row.add_prefix(self.status_icon)

        # Status label
        self.status_label = Gtk.Label()
        self.status_label.set_text("Ready to start")
        self.status_label.set_halign(Gtk.Align.START)
        self.status_label.add_css_class("title-4")
        status_row.add_suffix(self.status_label)

        group.add(status_row)

        # Progress bar
        self.progress_bar = Gtk.ProgressBar()
        self.progress_bar.set_show_text(True)
        self.progress_bar.set_text("Idle")
        self.progress_bar.set_margin_top(6)
        self.progress_bar.set_margin_bottom(6)
        self.progress_bar.set_margin_start(12)
        self.progress_bar.set_margin_end(12)

        group.add(self.progress_bar)
        return group
    
    def create_log_section(self):
        """Create log section for output display"""
        group = Adw.PreferencesGroup()
        group.set_title("Output Log")
        group.set_description("Real-time output from platform operations")
        
        # Create text view for logs
        self.log_textview = Gtk.TextView()
        self.log_textview.set_editable(False)
        self.log_textview.set_cursor_visible(False)
        self.log_textview.set_monospace(True)
        self.log_textview.set_wrap_mode(Gtk.WrapMode.WORD)
        
        # Set up text buffer
        buffer = self.log_textview.get_buffer()
        buffer.set_text("Unhinged Desktop Application Ready\n")
        buffer.set_text(buffer.get_text(buffer.get_start_iter(), buffer.get_end_iter(), False) + 
                       f"Project root: {self.project_root}\n")
        buffer.set_text(buffer.get_text(buffer.get_start_iter(), buffer.get_end_iter(), False) + 
                       "Click 'Start Platform' to begin...\n\n")
        
        # Create scrolled window for text view
        scrolled_log = Gtk.ScrolledWindow()
        scrolled_log.set_policy(Gtk.PolicyType.AUTOMATIC, Gtk.PolicyType.AUTOMATIC)
        scrolled_log.set_min_content_height(200)
        scrolled_log.set_child(self.log_textview)
        
        group.add(scrolled_log)
        return group
    
    def update_status(self, message, progress=None):
        """Update status label and progress bar"""
        GLib.idle_add(self._update_status_ui, message, progress)
    
    def _update_status_ui(self, message, progress):
        """Update UI elements from main thread"""
        # Get previous status for logging
        old_status = self.status_label.get_text() if hasattr(self, 'status_label') and self.status_label else "Unknown"

        self.status_label.set_text(message)

        # Log status change
        if self.session_logger and old_status != message:
            self.session_logger.log_status_change(old_status, message)

        # Update status icon based on message
        if "Error" in message or "Failed" in message:
            self.status_icon.set_from_icon_name("dialog-error-symbolic")
        elif "Complete" in message or "Success" in message:
            self.status_icon.set_from_icon_name("emblem-ok-symbolic")
        elif "Starting" in message or "Running" in message:
            self.status_icon.set_from_icon_name("media-playback-start-symbolic")
        elif "Stopped" in message:
            self.status_icon.set_from_icon_name("media-playback-stop-symbolic")
        else:
            self.status_icon.set_from_icon_name("emblem-default-symbolic")

        if progress is not None:
            self.progress_bar.set_fraction(progress)
            if progress == 0:
                self.progress_bar.set_text("Starting...")
            elif progress == 1:
                self.progress_bar.set_text("Complete")
            else:
                self.progress_bar.set_text(f"{int(progress * 100)}%")
        return False
    
    def append_log(self, message):
        """Append message to log text view"""
        GLib.idle_add(self._append_log_ui, message)

    def _append_log_ui(self, message):
        """Append to log from main thread with enhanced session logging"""
        buffer = self.log_textview.get_buffer()
        end_iter = buffer.get_end_iter()
        buffer.insert(end_iter, f"{message}\n")

        # Auto-scroll to bottom
        mark = buffer.get_insert()
        self.log_textview.scroll_mark_onscreen(mark)

        # Log to session file with noise reduction
        if self.session_logger:
            self.session_logger.log_platform_output(message)

            # Check for platform status claims and verify accuracy
            if "Platform started successfully" in message:
                self.session_logger.log_platform_status_update(message)

        return False

    def _gui_log_callback(self, message):
        """Callback for GUI output capture - this is called by the session logger"""
        # This method is called by the output capture system
        # The message is already being logged to file, just display in GUI
        pass
    
    def on_start_clicked(self, button):
        """Handle start button click"""
        if self.running:
            return

        self.running = True
        self.start_button.set_sensitive(False)
        self.stop_button.set_sensitive(True)

        # Get selected mode
        mode_names = ["Enhanced", "Simple", "QoL", "Custom ISO"]
        selected_mode = self.mode_dropdown.get_selected()
        mode_name = mode_names[selected_mode] if selected_mode < len(mode_names) else "Enhanced"

        # Log GUI events
        if self.session_logger:
            self.session_logger.log_gui_event("START_BUTTON_CLICKED", f"User clicked start button")
            self.session_logger.log_mode_selection(mode_name)

        # Show toast notification
        self.show_toast(f"Starting Unhinged in {mode_name} mode...")

        # Start platform in background thread
        thread = threading.Thread(target=self.start_platform, daemon=True)
        thread.start()
    
    def on_stop_clicked(self, button):
        """Handle stop button click"""
        if not self.running:
            return

        self.running = False
        self.start_button.set_sensitive(True)
        self.stop_button.set_sensitive(False)

        # Log GUI event
        if self.session_logger:
            self.session_logger.log_gui_event("STOP_BUTTON_CLICKED", "User clicked stop button")

        # Stop platform
        if self.process:
            try:
                self.process.terminate()
                self.append_log("üõë Platform stop requested")
            except:
                pass

        self.update_status("Stopped", 0)

    def on_gtk4_conversation_clicked(self, button):
        """Handle GTK4 conversation button click"""
        self.append_log("üéôÔ∏è Starting GTK4 control plane conversation...")
        try:
            import subprocess
            conversation_script = self.project_root / "control" / "conversation_cli.py"
            subprocess.Popen([
                "python3", str(conversation_script),
                "--mode", "voice_first",
                "--context", "gtk4_control_plane"
            ])
            self.append_log("‚úÖ GTK4 conversation interface launched")

            # Log GUI event
            if self.session_logger:
                self.session_logger.log_gui_event("GTK4_CONVERSATION_STARTED", "GTK4 conversation interface launched")

        except Exception as e:
            self.append_log(f"‚ùå Failed to start GTK4 conversation: {e}")

    def on_alpine_conversation_clicked(self, button):
        """Handle Alpine conversation button click"""
        self.append_log("üèîÔ∏è Starting Alpine VM conversation...")
        try:
            import subprocess
            conversation_script = self.project_root / "control" / "conversation_cli.py"
            subprocess.Popen([
                "python3", str(conversation_script),
                "--mode", "voice_first",
                "--context", "alpine_native"
            ])
            self.append_log("‚úÖ Alpine conversation interface launched")

            # Log GUI event
            if self.session_logger:
                self.session_logger.log_gui_event("ALPINE_CONVERSATION_STARTED", "Alpine conversation interface launched")

        except Exception as e:
            self.append_log(f"‚ùå Failed to start Alpine conversation: {e}")

    def on_text_conversation_clicked(self, button):
        """Handle text conversation button click"""
        self.append_log("‚å®Ô∏è Starting text-only conversation...")
        try:
            import subprocess
            conversation_script = self.project_root / "control" / "conversation_cli.py"
            subprocess.Popen([
                "python3", str(conversation_script),
                "--mode", "text_only"
            ])
            self.append_log("‚úÖ Text conversation interface launched")

            # Log GUI event
            if self.session_logger:
                self.session_logger.log_gui_event("TEXT_CONVERSATION_STARTED", "Text conversation interface launched")

        except Exception as e:
            self.append_log(f"‚ùå Failed to start text conversation: {e}")

    def on_check_updates_clicked(self, button):
        """Handle check for updates button click"""
        if not self.auto_updater:
            return

        self.append_log("üîÑ Checking for updates...")
        self.update_button.set_sensitive(False)
        self.update_button.set_label("Checking...")

        # Check for updates in background thread
        thread = threading.Thread(target=self._check_for_updates_thread, daemon=True)
        thread.start()

    def _check_for_updates_async(self):
        """Check for updates asynchronously (called on startup)"""
        if not self.auto_updater:
            return False

        # Check for updates in background thread
        thread = threading.Thread(target=self._check_for_updates_thread, daemon=True)
        thread.start()
        return False  # Don't repeat the timeout

    def _check_for_updates_thread(self):
        """Check for updates in background thread"""
        try:
            self.update_info = self.auto_updater.check_for_updates()

            # Update UI on main thread
            GLib.idle_add(self._update_ui_with_update_info)

        except Exception as e:
            if self.session_logger:
                self.session_logger.log_gui_event("UPDATE_CHECK_ERROR", f"Update check failed: {e}")
            GLib.idle_add(self._update_ui_with_error, str(e))

    def _update_ui_with_update_info(self):
        """Update UI with update information (called on main thread)"""
        if not self.update_info:
            return

        # Update version info
        current_version = self.update_info.current_version
        if hasattr(self, 'version_info_row'):
            self.version_info_row.set_subtitle(f"v{current_version.version} ({current_version.build_date})")

        # Update status based on update availability
        if self.update_info.status == UpdateStatus.UP_TO_DATE:
            if hasattr(self, 'update_status_row'):
                self.update_status_row.set_subtitle("‚úÖ Application is up to date")
            if hasattr(self, 'update_button'):
                self.update_button.set_label("Check for Updates")
                self.update_button.set_sensitive(True)

        elif self.update_info.status == UpdateStatus.UPDATE_AVAILABLE:
            if hasattr(self, 'update_status_row'):
                self.update_status_row.set_subtitle(f"üÜï Update available: v{self.update_info.latest_version.version}")
            if hasattr(self, 'update_button'):
                self.update_button.set_label("Install Update")
                self.update_button.set_sensitive(True)
                # Reconnect to install handler
                self.update_button.disconnect_by_func(self.on_check_updates_clicked)
                self.update_button.connect("clicked", self.on_install_update_clicked)

            self.append_log(f"üÜï Update available: v{self.update_info.latest_version.version}")

        elif self.update_info.status == UpdateStatus.UPDATE_REQUIRED:
            if hasattr(self, 'update_status_row'):
                self.update_status_row.set_subtitle(f"‚ö†Ô∏è Critical update required: v{self.update_info.latest_version.version}")
            if hasattr(self, 'update_button'):
                self.update_button.set_label("Install Critical Update")
                self.update_button.set_sensitive(True)
                self.update_button.add_css_class("destructive-action")
                # Reconnect to install handler
                self.update_button.disconnect_by_func(self.on_check_updates_clicked)
                self.update_button.connect("clicked", self.on_install_update_clicked)

            self.append_log(f"‚ö†Ô∏è Critical update required: v{self.update_info.latest_version.version}")

            # Show critical update dialog
            self._show_critical_update_dialog()

    def _update_ui_with_error(self, error_message):
        """Update UI with error information"""
        if hasattr(self, 'update_status_row'):
            self.update_status_row.set_subtitle(f"‚ùå Update check failed")
        if hasattr(self, 'update_button'):
            self.update_button.set_label("Retry")
            self.update_button.set_sensitive(True)

        self.append_log(f"‚ùå Update check failed: {error_message}")

    def on_install_update_clicked(self, button):
        """Handle install update button click"""
        if not self.auto_updater or not self.update_info:
            return

        self.append_log(f"üì• Installing update: v{self.update_info.latest_version.version}")
        self.update_button.set_sensitive(False)
        self.update_button.set_label("Installing...")

        # Install update in background thread
        thread = threading.Thread(target=self._install_update_thread, daemon=True)
        thread.start()

    def _install_update_thread(self):
        """Install update in background thread"""
        try:
            # Download update
            if self.auto_updater.download_update(self.update_info):
                # Install update
                if self.auto_updater.install_update(self.update_info):
                    GLib.idle_add(self._update_installation_success)
                else:
                    GLib.idle_add(self._update_installation_failed, "Installation failed")
            else:
                GLib.idle_add(self._update_installation_failed, "Download failed")

        except Exception as e:
            GLib.idle_add(self._update_installation_failed, str(e))

    def _update_installation_success(self):
        """Handle successful update installation"""
        self.append_log("‚úÖ Update installed successfully!")

        if hasattr(self, 'update_status_row'):
            self.update_status_row.set_subtitle("‚úÖ Update installed - restart recommended")
        if hasattr(self, 'update_button'):
            self.update_button.set_label("Restart Application")
            self.update_button.set_sensitive(True)
            self.update_button.add_css_class("suggested-action")
            # Reconnect to restart handler
            try:
                self.update_button.disconnect_by_func(self.on_install_update_clicked)
            except:
                pass
            self.update_button.connect("clicked", self.on_restart_application_clicked)

        # Show restart dialog
        self._show_restart_dialog()

    def _update_installation_failed(self, error_message):
        """Handle failed update installation"""
        self.append_log(f"‚ùå Update installation failed: {error_message}")

        if hasattr(self, 'update_status_row'):
            self.update_status_row.set_subtitle("‚ùå Update installation failed")
        if hasattr(self, 'update_button'):
            self.update_button.set_label("Retry Update")
            self.update_button.set_sensitive(True)

    def _show_critical_update_dialog(self):
        """Show critical update dialog"""
        dialog = Adw.MessageDialog.new(self.window)
        dialog.set_heading("Critical Update Available")
        dialog.set_body(f"A critical update (v{self.update_info.latest_version.version}) is available. "
                       "This update includes important security fixes and improvements.")

        dialog.add_response("cancel", "Later")
        dialog.add_response("install", "Install Now")
        dialog.set_response_appearance("install", Adw.ResponseAppearance.SUGGESTED)

        dialog.connect("response", self._on_critical_update_dialog_response)
        dialog.present()

    def _on_critical_update_dialog_response(self, dialog, response):
        """Handle critical update dialog response"""
        if response == "install":
            self.on_install_update_clicked(None)
        dialog.destroy()

    def _show_restart_dialog(self):
        """Show restart application dialog"""
        dialog = Adw.MessageDialog.new(self.window)
        dialog.set_heading("Update Installed Successfully")
        dialog.set_body("The application has been updated. You can restart now to use the new version, or restart manually later.")

        dialog.add_response("later", "Restart Later")
        dialog.add_response("restart", "Restart Now")
        dialog.add_response("manual", "Close & Restart Manually")
        dialog.set_response_appearance("restart", Adw.ResponseAppearance.SUGGESTED)

        dialog.connect("response", self._on_restart_dialog_response)
        dialog.present()

    def _on_restart_dialog_response(self, dialog, response):
        """Handle restart dialog response"""
        if response == "restart":
            self.on_restart_application_clicked(None)
        elif response == "manual":
            self.append_log("üí° Please restart the application manually to use the new version")
            self.append_log("üí° Run: python3 desktop/unhinged-desktop-app")
            # Just close the application
            GLib.timeout_add(2000, lambda: self.quit())
        dialog.destroy()

    def on_restart_application_clicked(self, button):
        """Handle restart application button click"""
        self.append_log("üîÑ Preparing to restart application...")

        if self.session_logger:
            self.session_logger.log_gui_event("APP_RESTART", "Application restart requested after update")

        # Show instructions and close gracefully
        self.append_log("üí° Update complete! Please restart the application manually:")
        self.append_log("üí° Method 1: Run 'python3 desktop/unhinged-desktop-app'")
        self.append_log("üí° Method 2: Launch 'Unhinged' from your application menu")
        self.append_log("üí° Method 3: Run 'gtk-launch unhinged'")

        # Update the restart button to show it's ready to close
        if hasattr(self, 'update_button'):
            self.update_button.set_label("Close Application")
            self.update_button.remove_css_class("suggested-action")
            self.update_button.add_css_class("destructive-action")
            # Reconnect to close handler
            try:
                self.update_button.disconnect_by_func(self.on_restart_application_clicked)
            except:
                pass
            self.update_button.connect("clicked", self._close_application)

        # Auto-close after 10 seconds
        self.append_log("üïê Application will close automatically in 10 seconds...")
        GLib.timeout_add_seconds(10, self._close_application)

    def _close_application(self, button=None):
        """Close the application gracefully"""
        self.append_log("üëã Closing application...")

        if self.session_logger:
            self.session_logger.close_session()

        # Close window and quit
        if self.window:
            self.window.close()

        GLib.timeout_add(500, lambda: self.quit())
        return False



    def start_platform(self):
        """
        @llm-doc Start Platform Backend

        Executes the same functionality as 'make start' but with
        GUI feedback and progress indication.
        """
        try:
            # Get selected mode
            selected_mode = self.mode_dropdown.get_selected()
            mode_commands = {
                0: "start",           # Enhanced (Recommended)
                1: "start-simple",    # Simple Communication
                2: "start-qol",       # Quality of Life
                3: "start-custom-iso" # Custom ISO
            }

            command = mode_commands.get(selected_mode, "start")
            mode_names = ["Enhanced", "Simple", "QoL", "Custom ISO"]
            mode_name = mode_names[selected_mode] if selected_mode < len(mode_names) else "Enhanced"

            self.update_status("Starting Unhinged Platform...", 0.1)
            self.append_log("üöÄ Starting Unhinged Platform")
            self.append_log(f"üìÅ Working directory: {self.project_root}")
            self.append_log(f"üéØ Launch mode: {mode_name}")

            # Execute make command
            self.update_status(f"Executing make {command}...", 0.3)
            self.append_log(f"‚öôÔ∏è Executing: make {command}")

            self.process = subprocess.Popen(
                ['make', command],
                cwd=self.project_root,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                universal_newlines=True,
                bufsize=1
            )

            self.update_status("Platform running...", 0.8)
            self.append_log("‚úÖ Platform started successfully")

            # Stream output
            while self.running and self.process:
                line = self.process.stdout.readline()
                if line:
                    clean_line = line.rstrip()
                    if clean_line:
                        # Enhanced output formatting
                        if "ERROR" in clean_line.upper():
                            self.append_log(f"‚ùå {clean_line}")
                        elif "SUCCESS" in clean_line.upper():
                            self.append_log(f"‚úÖ {clean_line}")
                        elif "WARNING" in clean_line.upper():
                            self.append_log(f"‚ö†Ô∏è {clean_line}")
                        elif "UNHINGED" in clean_line.upper():
                            self.append_log(f"üî• {clean_line}")
                        else:
                            self.append_log(f"OUT: {clean_line}")

                if self.process.poll() is not None:
                    break

            self.update_status("Platform completed", 1.0)
            self.append_log("üéâ Platform session completed")
            self.show_toast("Platform session completed successfully!", 5)

        except FileNotFoundError:
            self.update_status("Error: Makefile not found", 0)
            self.append_log("‚ùå Error: Makefile not found in project directory")
            self.append_log("üí° Make sure you're running from the Unhinged project root")
            self.show_error_dialog("Makefile Not Found",
                                 "Could not find Makefile in the project directory.\n\n"
                                 "Please ensure you're running from the Unhinged project root.")
        except subprocess.CalledProcessError as e:
            self.update_status(f"Error: Command failed (exit {e.returncode})", 0)
            self.append_log(f"‚ùå Error: make {command} failed with exit code {e.returncode}")
            self.show_error_dialog("Command Failed",
                                 f"The command 'make {command}' failed.\n\n"
                                 f"Exit code: {e.returncode}\n"
                                 f"Check the output log for details.")
        except Exception as e:
            self.update_status(f"Error: {e}", 0)
            self.append_log(f"‚ùå Unexpected error: {e}")
            self.show_error_dialog("Unexpected Error",
                                 f"An unexpected error occurred:\n\n{e}\n\n"
                                 f"Please check the output log for more details.")
        finally:
            self.running = False
            GLib.idle_add(self._reset_buttons)

    def show_error_dialog(self, title, message):
        """Show error dialog to user"""
        def show_dialog():
            dialog = Adw.MessageDialog(transient_for=self.window)
            dialog.set_heading(title)
            dialog.set_body(message)
            dialog.add_response("ok", "OK")
            dialog.set_default_response("ok")
            dialog.present()

        GLib.idle_add(show_dialog)

    def show_toast(self, message, timeout=3):
        """Show toast notification"""
        def show_toast_ui():
            toast = Adw.Toast.new(message)
            toast.set_timeout(timeout)
            self.toast_overlay.add_toast(toast)

        GLib.idle_add(show_toast_ui)
    
    def _reset_buttons(self):
        """Reset button states"""
        self.start_button.set_sensitive(True)
        self.stop_button.set_sensitive(False)
        return False

def main():
    """Main function"""
    app = UnhingedDesktopApp()
    return app.run(sys.argv)

if __name__ == "__main__":
    sys.exit(main())
