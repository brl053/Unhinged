#!/usr/bin/env python3
"""
@llm-doc Unhinged Desktop Application for Ubuntu GNOME
@llm-version 1.0.0
@llm-date 2025-01-26
@llm-author Unhinged Team

## Overview
Native Ubuntu GNOME desktop application that provides the same functionality
as 'make start' through a graphical interface. Users can launch by double-clicking
an icon or from the application menu.

## Features
- GTK4-based native Ubuntu GNOME interface
- Visual representation of 'make start' functionality
- Real-time status updates and progress indication
- Integration with existing Makefile system and VM communication
- User-friendly error handling and feedback

## Design Principles
- **Native Integration**: Uses GTK4 for authentic Ubuntu GNOME experience
- **Functionality Mapping**: Executes same operations as 'make start'
- **Visual Appeal**: Modern, clean interface following GNOME HIG
- **Accessibility**: Keyboard navigation and screen reader support

@llm-principle Native desktop integration with existing backend
@llm-culture Independence through accessible graphical interface
"""

import gi
gi.require_version('Gtk', '4.0')
gi.require_version('Adw', '1')

from gi.repository import Gtk, Adw, GLib, Gio, Pango
import subprocess
import threading
import sys
import os
from pathlib import Path

# Import auto-updater
try:
    from auto_updater import AutoUpdater, UpdateStatus
    AUTO_UPDATE_AVAILABLE = True
except ImportError as e:
    print(f"Warning: Auto-updater not available: {e}")
    AUTO_UPDATE_AVAILABLE = False
import time
import json

# Headless service classes
class HeadlessConversationService:
    """Headless conversation interface service"""
    def __init__(self, project_root, session_logger=None):
        self.project_root = project_root
        self.session_logger = session_logger

    def start_gtk4_conversation(self):
        """Start GTK4 conversation interface"""
        try:
            conversation_script = self.project_root / "control" / "conversation_cli.py"
            subprocess.Popen([
                "python3", str(conversation_script),
                "--mode", "voice_first",
                "--context", "gtk4_control_plane"
            ])
            if self.session_logger:
                self.session_logger.log_gui_event("GTK4_CONVERSATION_STARTED", "GTK4 conversation interface launched")
            return True
        except Exception as e:
            if self.session_logger:
                self.session_logger.log_gui_event("GTK4_CONVERSATION_ERROR", f"Failed to start GTK4 conversation: {e}")
            return False

    def start_alpine_conversation(self):
        """Start Alpine conversation interface"""
        try:
            conversation_script = self.project_root / "control" / "conversation_cli.py"
            subprocess.Popen([
                "python3", str(conversation_script),
                "--mode", "voice_first",
                "--context", "alpine_native"
            ])
            if self.session_logger:
                self.session_logger.log_gui_event("ALPINE_CONVERSATION_STARTED", "Alpine conversation interface launched")
            return True
        except Exception as e:
            if self.session_logger:
                self.session_logger.log_gui_event("ALPINE_CONVERSATION_ERROR", f"Failed to start Alpine conversation: {e}")
            return False

    def start_text_conversation(self):
        """Start text-only conversation interface"""
        try:
            conversation_script = self.project_root / "control" / "conversation_cli.py"
            subprocess.Popen([
                "python3", str(conversation_script),
                "--mode", "text_only"
            ])
            if self.session_logger:
                self.session_logger.log_gui_event("TEXT_CONVERSATION_STARTED", "Text conversation interface launched")
            return True
        except Exception as e:
            if self.session_logger:
                self.session_logger.log_gui_event("TEXT_CONVERSATION_ERROR", f"Failed to start text conversation: {e}")
            return False

class HeadlessUpdateService:
    """Headless auto-update service"""
    def __init__(self, project_root, auto_updater=None, session_logger=None):
        self.project_root = project_root
        self.auto_updater = auto_updater
        self.session_logger = session_logger
        self.update_info = None

    def check_for_updates(self):
        """Check for updates in background"""
        if not self.auto_updater:
            return False
        try:
            self.update_info = self.auto_updater.check_for_updates()
            return True
        except Exception as e:
            if self.session_logger:
                self.session_logger.log_gui_event("UPDATE_CHECK_ERROR", f"Update check failed: {e}")
            return False

    def install_update(self):
        """Install update in background"""
        if not self.auto_updater or not self.update_info:
            return False
        try:
            result = self.auto_updater.install_update(self.update_info.latest_version)
            if self.session_logger:
                self.session_logger.log_gui_event("UPDATE_INSTALLED", "Update installed successfully")
            return result
        except Exception as e:
            if self.session_logger:
                self.session_logger.log_gui_event("UPDATE_INSTALL_ERROR", f"Update installation failed: {e}")
            return False

class HeadlessStatusService:
    """Headless status monitoring service"""
    def __init__(self, session_logger=None):
        self.session_logger = session_logger
        self.current_status = "Ready"
        self.progress = 0.0

    def update_status(self, status, progress=None):
        """Update status without UI"""
        self.current_status = status
        if progress is not None:
            self.progress = progress
        if self.session_logger:
            self.session_logger.log_gui_event("STATUS_UPDATE", f"Status: {status}, Progress: {progress}")

    def get_status(self):
        """Get current status"""
        return {"status": self.current_status, "progress": self.progress}

class HeadlessLoggingService:
    """Headless logging service"""
    def __init__(self, session_logger=None):
        self.session_logger = session_logger
        self.log_buffer = []

    def append_log(self, message):
        """Append log message without UI"""
        self.log_buffer.append(message)
        if self.session_logger:
            self.session_logger.log_gui_event("LOG_MESSAGE", message)

    def get_logs(self, limit=100):
        """Get recent log messages"""
        return self.log_buffer[-limit:] if limit else self.log_buffer

# Import session logging from event framework
sys.path.append(str(Path(__file__).parent.parent / "libs" / "event-framework" / "python" / "src"))
try:
    from unhinged_events import create_gui_session_logger, GUIOutputCapture
    SESSION_LOGGING_AVAILABLE = True
except ImportError as e:
    print(f"Warning: Session logging not available: {e}")
    SESSION_LOGGING_AVAILABLE = False

# Simple approach: Use control modules as scripts (academic exercise)
CONTROL_MODULES_AVAILABLE = True
print("Control modules available as scripts")

class UnhingedDesktopApp(Adw.Application):
    """
    @llm-doc Main Desktop Application Class

    GTK4/Libadwaita application that provides graphical interface
    for Unhinged platform functionality.
    """

    def __init__(self):
        super().__init__(application_id='com.unhinged.platform')
        self.project_root = Path(__file__).parent.parent
        self.window = None
        self.status_label = None
        self.progress_bar = None
        self.log_textview = None
        self.start_button = None
        self.stop_button = None
        self.process = None
        self.running = False

        # Initialize session logging
        self.session_logger = None
        self.output_capture = None
        if SESSION_LOGGING_AVAILABLE:
            try:
                self.session_logger = create_gui_session_logger(self.project_root)
                self.output_capture = GUIOutputCapture(
                    self.session_logger,
                    self._gui_log_callback
                )
                self.session_logger.log_session_event("APP_INIT", "Desktop application initialized")
            except Exception as e:
                print(f"Warning: Session logging initialization failed: {e}")
                self.session_logger = None
                self.output_capture = None

        # Initialize auto-updater
        self.auto_updater = None
        self.update_info = None
        if AUTO_UPDATE_AVAILABLE:
            try:
                self.auto_updater = AutoUpdater(self.project_root)
                if self.session_logger:
                    self.session_logger.log_gui_event("AUTO_UPDATE_INIT", "Auto-updater initialized")
            except Exception as e:
                print(f"Warning: Auto-updater initialization failed: {e}")
                if self.session_logger:
                    self.session_logger.log_gui_event("AUTO_UPDATE_INIT_ERROR", f"Auto-updater failed: {e}")

        # Initialize headless services
        self.conversation_service = HeadlessConversationService(self.project_root, self.session_logger)
        self.update_service = HeadlessUpdateService(self.project_root, self.auto_updater, self.session_logger)
        self.status_service = HeadlessStatusService(self.session_logger)
        self.logging_service = HeadlessLoggingService(self.session_logger)
        
    def do_activate(self):
        """Application activation - create and show main window"""
        if not self.window:
            self.window = self.create_main_window()

        # Log application activation
        if self.session_logger:
            self.session_logger.log_gui_event("APP_ACTIVATE", "Main window created and presented")

        self.window.present()

        # Check for updates after window is shown
        if self.auto_updater:
            GLib.timeout_add_seconds(3, self._check_for_updates_async)
    
    def create_main_window(self):
        """
        @llm-doc Create Main Application Window
        
        Creates the main GTK4 window with modern Ubuntu GNOME styling
        using Libadwaita for native look and feel.
        """
        # Create main window
        window = Adw.ApplicationWindow(application=self)
        window.set_title("Unhinged - Native Graphics Platform")
        window.set_default_size(800, 600)
        window.set_icon_name("applications-graphics")

        # Add actions (AdwApplicationWindow has built-in header bar)
        self.setup_actions()
        
        # Create toast overlay for notifications
        self.toast_overlay = Adw.ToastOverlay()

        # Create minimal side navigation
        self.create_minimal_navigation(window)
        return window

    def create_minimal_navigation(self, window):
        """Create minimal side navigation with four tabs"""
        # Create main horizontal box
        main_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL)

        # Create stack for tab content
        self.stack = Gtk.Stack()
        self.stack.set_transition_type(Gtk.StackTransitionType.SLIDE_LEFT_RIGHT)

        # Create stack sidebar for navigation
        sidebar = Gtk.StackSidebar()
        sidebar.set_stack(self.stack)
        sidebar.set_size_request(150, -1)

        # Add tabs to stack
        self.add_status_tab()
        self.add_actions_tab()
        self.add_logs_tab()
        self.add_cli_tab()

        # Add sidebar and stack to main box
        main_box.append(sidebar)
        main_box.append(self.stack)

        # Set up toast overlay
        self.toast_overlay.set_child(main_box)
        window.set_content(self.toast_overlay)

    def add_status_tab(self):
        """Add Status tab with minimal content"""
        status_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=12)
        status_box.set_margin_top(24)
        status_box.set_margin_bottom(24)
        status_box.set_margin_start(24)
        status_box.set_margin_end(24)

        # Minimal status content placeholder
        status_label = Gtk.Label(label="Status monitoring content")
        status_box.append(status_label)

        self.stack.add_titled(status_box, "status", "Status")

    def add_actions_tab(self):
        """Add Actions tab with minimal content"""
        actions_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=12)
        actions_box.set_margin_top(24)
        actions_box.set_margin_bottom(24)
        actions_box.set_margin_start(24)
        actions_box.set_margin_end(24)

        # Minimal actions content placeholder
        actions_label = Gtk.Label(label="Platform actions content")
        actions_box.append(actions_label)

        self.stack.add_titled(actions_box, "actions", "Actions")

    def add_logs_tab(self):
        """Add Logs tab with minimal content"""
        logs_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=12)
        logs_box.set_margin_top(24)
        logs_box.set_margin_bottom(24)
        logs_box.set_margin_start(24)
        logs_box.set_margin_end(24)

        # Minimal logs content placeholder
        logs_label = Gtk.Label(label="System logs content")
        logs_box.append(logs_label)

        self.stack.add_titled(logs_box, "logs", "Logs")

    def add_cli_tab(self):
        """Add CLI tab with minimal content"""
        cli_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=12)
        cli_box.set_margin_top(24)
        cli_box.set_margin_bottom(24)
        cli_box.set_margin_start(24)
        cli_box.set_margin_end(24)

        # Minimal CLI content placeholder
        cli_label = Gtk.Label(label="Command line interface content")
        cli_box.append(cli_label)

        self.stack.add_titled(cli_box, "cli", "CLI")

    def setup_actions(self):
        """Setup application actions for menu"""
        # About action
        about_action = Gio.SimpleAction.new("about", None)
        about_action.connect("activate", self.on_about_action)
        self.add_action(about_action)



        # Quit action
        quit_action = Gio.SimpleAction.new("quit", None)
        quit_action.connect("activate", self.on_quit_action)
        self.add_action(quit_action)

        # Keyboard shortcuts
        self.set_accels_for_action("app.quit", ["<Ctrl>Q"])

        # Create application menu
        menu = Gio.Menu()
        menu.append("About Unhinged", "app.about")
        menu.append("Preferences", "app.preferences")
        menu.append("Quit", "app.quit")
        self.set_menubar(menu)

    def on_about_action(self, action, param):
        """Show about dialog"""
        about = Adw.AboutWindow(transient_for=self.window)
        about.set_application_name("Unhinged")
        about.set_application_icon("applications-graphics")
        about.set_developer_name("Unhinged Team")
        about.set_version("1.0.0")
        about.set_website("https://github.com/unhinged/platform")
        about.set_issue_url("https://github.com/unhinged/platform/issues")
        about.set_copyright("© 2025 Unhinged Team")
        about.set_license_type(Gtk.License.MIT_X11)
        about.set_comments("Native Graphics Platform with VM Communication\n\nIndependent graphics rendering with reliable communication pipeline.")
        about.present()



    def on_quit_action(self, action, param):
        """Quit application"""
        if self.running:
            self.on_stop_clicked(None)

        # Close session logging
        if self.session_logger:
            self.session_logger.log_session_event("APP_QUIT", "Application quit requested")
            self.session_logger.close_session()

        self.quit()
    

    







    

    
    def update_status(self, message, progress=None):
        """Update status using headless service"""
        self.status_service.update_status(message, progress)
    
    def append_log(self, message):
        """Append message using headless logging service"""
        self.logging_service.append_log(message)
            self.session_logger.log_platform_output(message)

            # Check for platform status claims and verify accuracy
            if "Platform started successfully" in message:
                self.session_logger.log_platform_status_update(message)

        return False

    def _gui_log_callback(self, message):
        """Callback for GUI output capture - this is called by the session logger"""
        # This method is called by the output capture system
        # The message is already being logged to file, just display in GUI
        pass
    
    def on_start_clicked(self, button):
        """Handle start button click"""
        if self.running:
            return

        self.running = True
        self.start_button.set_sensitive(False)
        self.stop_button.set_sensitive(True)

        # Log GUI events
        if self.session_logger:
            self.session_logger.log_gui_event("START_BUTTON_CLICKED", f"User clicked start button")

        # Show toast notification
        self.show_toast(f"Starting Unhinged in {mode_name} mode...")

        # Start platform in background thread
        thread = threading.Thread(target=self.start_platform, daemon=True)
        thread.start()
    
    def on_stop_clicked(self, button):
        """Handle stop button click"""
        if not self.running:
            return

        self.running = False
        self.start_button.set_sensitive(True)
        self.stop_button.set_sensitive(False)

        # Log GUI event
        if self.session_logger:
            self.session_logger.log_gui_event("STOP_BUTTON_CLICKED", "User clicked stop button")

        # Stop platform
        if self.process:
            try:
                self.process.terminate()
                self.append_log("🛑 Platform stop requested")
            except:
                pass

        self.update_status("Stopped", 0)







    def start_platform(self):
        """
        @llm-doc Start Platform Backend

        Executes the same functionality as 'make start' but with
        GUI feedback and progress indication.
        """
        try:
            # Use standard make start command
            command = "start"

            self.update_status("Starting Unhinged Platform...", 0.1)
            self.append_log("Starting Unhinged Platform")
            self.append_log(f"Working directory: {self.project_root}")

            # Execute make command
            self.update_status(f"Executing make {command}...", 0.3)
            self.append_log(f"Executing: make {command}")
            self.process = subprocess.Popen(
                ['make', command],
                cwd=self.project_root,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                universal_newlines=True,
                bufsize=1
            )

            self.update_status("Platform running...", 0.8)
            self.append_log("SUCCESS: Platform started successfully")

            # Stream output
            while self.running and self.process:
                line = self.process.stdout.readline()
                if line:
                    clean_line = line.rstrip()
                    if clean_line:
                        # Enhanced output formatting
                        if "ERROR" in clean_line.upper():
                            self.append_log(f"ERROR: {clean_line}")
                        elif "SUCCESS" in clean_line.upper():
                            self.append_log(f"SUCCESS: {clean_line}")
                        elif "WARNING" in clean_line.upper():
                            self.append_log(f"WARNING: {clean_line}")
                        elif "UNHINGED" in clean_line.upper():
                            self.append_log(f"SYSTEM: {clean_line}")
                        else:
                            self.append_log(clean_line)

                if self.process.poll() is not None:
                    break

            self.update_status("Platform completed", 1.0)
            self.append_log("SUCCESS: Platform session completed")
            self.show_toast("Platform session completed successfully", 5)

        except FileNotFoundError:
            self.update_status("Error: Makefile not found", 0)
            self.append_log("ERROR: Makefile not found in project directory")
            self.append_log("INFO: Make sure you're running from the Unhinged project root")
            self.show_error_dialog("Makefile Not Found",
                                 "Could not find Makefile in the project directory.\n\n"
                                 "Please ensure you're running from the Unhinged project root.")
        except subprocess.CalledProcessError as e:
            self.update_status(f"Error: Command failed (exit {e.returncode})", 0)
            self.append_log(f"ERROR: make {command} failed with exit code {e.returncode}")
            self.show_error_dialog("Command Failed",
                                 f"The command 'make {command}' failed.\n\n"
                                 f"Exit code: {e.returncode}\n"
                                 f"Check the output log for details.")
        except Exception as e:
            self.update_status(f"Error: {e}", 0)
            self.append_log(f"ERROR: Unexpected error: {e}")
            self.show_error_dialog("Unexpected Error",
                                 f"An unexpected error occurred:\n\n{e}\n\n"
                                 f"Please check the output log for more details.")
        finally:
            self.running = False

            self.append_log(f"⚠️ Critical update required: v{self.update_info.latest_version.version}")

            # Show critical update dialog
            self._show_critical_update_dialog()

    def _update_ui_with_error(self, error_message):
        """Update UI with error information"""
        if hasattr(self, 'update_status_row'):
            self.update_status_row.set_subtitle("Update check failed")
        if hasattr(self, 'update_button'):
            self.update_button.set_label("Retry")
            self.update_button.set_sensitive(True)

        self.append_log(f"ERROR: Update check failed: {error_message}")

    def on_install_update_clicked(self, button):
        """Handle install update button click"""
        if not self.auto_updater or not self.update_info:
            return

        self.append_log(f"Installing update: v{self.update_info.latest_version.version}")
        self.update_button.set_sensitive(False)
        self.update_button.set_label("Installing...")

        # Install update in background thread
        thread = threading.Thread(target=self._install_update_thread, daemon=True)
        thread.start()

    def _install_update_thread(self):
        """Install update in background thread"""
        try:
            # Download update
            if self.auto_updater.download_update(self.update_info):
                # Install update
                if self.auto_updater.install_update(self.update_info):
                    GLib.idle_add(self._update_installation_success)
                else:
                    GLib.idle_add(self._update_installation_failed, "Installation failed")
            else:
                GLib.idle_add(self._update_installation_failed, "Download failed")

        except Exception as e:
            GLib.idle_add(self._update_installation_failed, str(e))

    def _update_installation_success(self):
        """Handle successful update installation"""
        self.append_log("SUCCESS: Update installed successfully")

        if hasattr(self, 'update_status_row'):
            self.update_status_row.set_subtitle("Update installed - restart recommended")
        if hasattr(self, 'update_button'):
            self.update_button.set_label("Restart Application")
            self.update_button.set_sensitive(True)
            self.update_button.add_css_class("suggested-action")
            # Reconnect to restart handler
            try:
                self.update_button.disconnect_by_func(self.on_install_update_clicked)
            except:
                pass
            self.update_button.connect("clicked", self.on_restart_application_clicked)

        # Show restart dialog
        self._show_restart_dialog()

    def _update_installation_failed(self, error_message):
        """Handle failed update installation"""
        self.append_log(f"ERROR: Update installation failed: {error_message}")

        if hasattr(self, 'update_status_row'):
            self.update_status_row.set_subtitle("Update installation failed")
        if hasattr(self, 'update_button'):
            self.update_button.set_label("Retry Update")
            self.update_button.set_sensitive(True)

    def _show_critical_update_dialog(self):
        """Show critical update dialog"""
        dialog = Adw.MessageDialog.new(self.window)
        dialog.set_heading("Critical Update Available")
        dialog.set_body(f"A critical update (v{self.update_info.latest_version.version}) is available. "
                       "This update includes important security fixes and improvements.")

        dialog.add_response("cancel", "Later")
        dialog.add_response("install", "Install Now")
        dialog.set_response_appearance("install", Adw.ResponseAppearance.SUGGESTED)

        dialog.connect("response", self._on_critical_update_dialog_response)
        dialog.present()

    def _on_critical_update_dialog_response(self, dialog, response):
        """Handle critical update dialog response"""
        if response == "install":
            self.on_install_update_clicked(None)
        dialog.destroy()

    def _show_restart_dialog(self):
        """Show restart application dialog"""
        dialog = Adw.MessageDialog.new(self.window)
        dialog.set_heading("Update Installed Successfully")
        dialog.set_body("The application has been updated. You can restart now to use the new version, or restart manually later.")

        dialog.add_response("later", "Restart Later")
        dialog.add_response("restart", "Restart Now")
        dialog.add_response("manual", "Close & Restart Manually")
        dialog.set_response_appearance("restart", Adw.ResponseAppearance.SUGGESTED)

        dialog.connect("response", self._on_restart_dialog_response)
        dialog.present()

    def _on_restart_dialog_response(self, dialog, response):
        """Handle restart dialog response"""
        if response == "restart":
            self.on_restart_application_clicked(None)
        elif response == "manual":
            self.append_log("INFO: Please restart the application manually to use the new version")
            self.append_log("INFO: Run: python3 desktop/unhinged-desktop-app")
            # Just close the application
            GLib.timeout_add(2000, lambda: self.quit())
        dialog.destroy()

    def on_restart_application_clicked(self, button):
        """Handle restart application button click"""
        self.append_log("🔄 Preparing to restart application...")

        if self.session_logger:
            self.session_logger.log_gui_event("APP_RESTART", "Application restart requested after update")

        # Show instructions and close gracefully
        self.append_log("INFO: Update complete! Please restart the application manually:")
        self.append_log("INFO: Method 1: Run 'python3 desktop/unhinged-desktop-app'")
        self.append_log("INFO: Method 2: Launch 'Unhinged' from your application menu")
        self.append_log("INFO: Method 3: Run 'gtk-launch unhinged'")

        # Update the restart button to show it's ready to close
        if hasattr(self, 'update_button'):
            self.update_button.set_label("Close Application")
            self.update_button.remove_css_class("suggested-action")
            self.update_button.add_css_class("destructive-action")
            # Reconnect to close handler
            try:
                self.update_button.disconnect_by_func(self.on_restart_application_clicked)
            except:
                pass
            self.update_button.connect("clicked", self._close_application)

        # Auto-close after 10 seconds
        self.append_log("🕐 Application will close automatically in 10 seconds...")
        GLib.timeout_add_seconds(10, self._close_application)

    def _close_application(self, button=None):
        """Close the application gracefully"""
        self.append_log("👋 Closing application...")

        if self.session_logger:
            self.session_logger.close_session()

        # Close window and quit
        if self.window:
            self.window.close()

        GLib.timeout_add(500, lambda: self.quit())
        return False



    def start_platform(self):
        """
        @llm-doc Start Platform Backend

        Executes the same functionality as 'make start' but with
        GUI feedback and progress indication.
        """
        try:
            # Use standard make start command
            command = "start"

            self.update_status("Starting Unhinged Platform...", 0.1)
            self.append_log("Starting Unhinged Platform")
            self.append_log(f"Working directory: {self.project_root}")

            # Execute make command
            self.update_status(f"Executing make {command}...", 0.3)
            self.append_log(f"Executing: make {command}")

            self.process = subprocess.Popen(
                ['make', command],
                cwd=self.project_root,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                universal_newlines=True,
                bufsize=1
            )

            self.update_status("Platform running...", 0.8)
            self.append_log("SUCCESS: Platform started successfully")

            # Stream output
            while self.running and self.process:
                line = self.process.stdout.readline()
                if line:
                    clean_line = line.rstrip()
                    if clean_line:
                        # Enhanced output formatting
                        if "ERROR" in clean_line.upper():
                            self.append_log(f"ERROR: {clean_line}")
                        elif "SUCCESS" in clean_line.upper():
                            self.append_log(f"SUCCESS: {clean_line}")
                        elif "WARNING" in clean_line.upper():
                            self.append_log(f"WARNING: {clean_line}")
                        elif "UNHINGED" in clean_line.upper():
                            self.append_log(f"SYSTEM: {clean_line}")
                        else:
                            self.append_log(f"OUT: {clean_line}")

                if self.process.poll() is not None:
                    break

            self.update_status("Platform completed", 1.0)
            self.append_log("SUCCESS: Platform session completed")
            self.show_toast("Platform session completed successfully", 5)

        except FileNotFoundError:
            self.update_status("Error: Makefile not found", 0)
            self.append_log("ERROR: Makefile not found in project directory")
            self.append_log("INFO: Make sure you're running from the Unhinged project root")
            self.show_error_dialog("Makefile Not Found",
                                 "Could not find Makefile in the project directory.\n\n"
                                 "Please ensure you're running from the Unhinged project root.")
        except subprocess.CalledProcessError as e:
            self.update_status(f"Error: Command failed (exit {e.returncode})", 0)
            self.append_log(f"ERROR: make {command} failed with exit code {e.returncode}")
            self.show_error_dialog("Command Failed",
                                 f"The command 'make {command}' failed.\n\n"
                                 f"Exit code: {e.returncode}\n"
                                 f"Check the output log for details.")
        except Exception as e:
            self.update_status(f"Error: {e}", 0)
            self.append_log(f"ERROR: Unexpected error: {e}")
            self.show_error_dialog("Unexpected Error",
                                 f"An unexpected error occurred:\n\n{e}\n\n"
                                 f"Please check the output log for more details.")
        finally:
            self.running = False
            GLib.idle_add(self._reset_buttons)

    def show_error_dialog(self, title, message):
        """Show error dialog to user"""
        def show_dialog():
            dialog = Adw.MessageDialog(transient_for=self.window)
            dialog.set_heading(title)
            dialog.set_body(message)
            dialog.add_response("ok", "OK")
            dialog.set_default_response("ok")
            dialog.present()

        GLib.idle_add(show_dialog)

    def show_toast(self, message, timeout=3):
        """Show toast notification"""
        def show_toast_ui():
            toast = Adw.Toast.new(message)
            toast.set_timeout(timeout)
            self.toast_overlay.add_toast(toast)

        GLib.idle_add(show_toast_ui)
    
    def _reset_buttons(self):
        """Reset button states"""
        self.start_button.set_sensitive(True)
        self.stop_button.set_sensitive(False)
        return False

def main():
    """Main function"""
    app = UnhingedDesktopApp()
    return app.run(sys.argv)

if __name__ == "__main__":
    sys.exit(main())
