// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v3.21.12
// source: document_store.proto

/* eslint-disable */
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import _m0 from "protobufjs/minimal";
import { Struct } from "./google/protobuf/struct";
import { Timestamp } from "./google/protobuf/timestamp";

/** Core document message */
export interface Document {
  documentUuid: string;
  type: string;
  name: string;
  namespace: string;
  version: number;
  bodyJson: string;
  metadata?: { [key: string]: any } | undefined;
  tags: string[];
  createdAt?: Date | undefined;
  createdBy: string;
  createdByType: string;
  sessionId: string;
}

/** Document stub for listing without body */
export interface DocumentStub {
  documentUuid: string;
  type: string;
  name: string;
  namespace: string;
  version: number;
  metadata?: { [key: string]: any } | undefined;
  tags: string[];
  createdAt?: Date | undefined;
  createdBy: string;
  createdByType: string;
  sessionId: string;
}

/** Active tag information */
export interface ActiveTag {
  documentUuid: string;
  documentVersion: number;
  tag: string;
  updatedAt?: Date | undefined;
  updatedBy: string;
  updatedByType: string;
  sessionId: string;
}

/** Tag event for audit trail */
export interface TagEvent {
  tagEventUuid: string;
  documentUuid: string;
  documentVersion: number;
  tag: string;
  operation: string;
  createdAt?: Date | undefined;
  createdBy: string;
  createdByType: string;
  sessionId: string;
}

/** Create/Update document request */
export interface PutDocumentRequest {
  document?: Document | undefined;
}

export interface PutDocumentResponse {
  success: boolean;
  message: string;
  documentUuid: string;
  version: number;
}

/** Batch create/update documents */
export interface PutDocumentsRequest {
  documents: Document[];
}

export interface PutDocumentReceipt {
  documentUuid: string;
  version: number;
  success: boolean;
  errorMessage: string;
}

export interface PutDocumentsResponse {
  success: boolean;
  message: string;
  receipts: PutDocumentReceipt[];
}

/** Get single document */
export interface GetDocumentRequest {
  documentUuid: string;
  version?: number | undefined;
  tag?: string | undefined;
  includeBody: boolean;
}

export interface GetDocumentResponse {
  success: boolean;
  message: string;
  document?: Document | undefined;
}

/** List documents with filtering */
export interface ListDocumentsRequest {
  namespace?: string | undefined;
  type?: string | undefined;
  tag?: string | undefined;
  sessionId?: string | undefined;
  paginationToken?: Date | undefined;
  pageSize: number;
  includeBody: boolean;
  latestVersionsOnly: boolean;
}

export interface ListDocumentsResponse {
  success: boolean;
  message: string;
  documents: Document[];
  nextPaginationToken?: Date | undefined;
  totalCount: number;
}

/** List document versions */
export interface ListDocumentVersionsRequest {
  documentUuid: string;
  paginationToken?: Date | undefined;
  pageSize: number;
  includeBody: boolean;
}

export interface ListDocumentVersionsResponse {
  success: boolean;
  message: string;
  documents: Document[];
  nextPaginationToken?: Date | undefined;
  totalCount: number;
}

/** Tag operations */
export interface TagDocumentRequest {
  documentUuid: string;
  version: number;
  tag: string;
  taggedBy: string;
  taggedByType: string;
  sessionId: string;
}

export interface TagDocumentResponse {
  success: boolean;
  message: string;
}

/** List active tags for a document */
export interface ListActiveTagsRequest {
  documentUuid: string;
  documentVersion?: number | undefined;
  paginationToken?: Date | undefined;
  pageSize: number;
}

export interface ListActiveTagsResponse {
  success: boolean;
  message: string;
  tags: ActiveTag[];
  nextPaginationToken?: Date | undefined;
  totalCount: number;
}

/** List tag events (audit trail) */
export interface ListTagEventsRequest {
  documentUuid: string;
  tag: string;
  paginationToken?: Date | undefined;
  pageSize: number;
}

export interface ListTagEventsResponse {
  success: boolean;
  message: string;
  events: TagEvent[];
  nextPaginationToken?: Date | undefined;
  totalCount: number;
}

/** Session context queries */
export interface GetSessionContextRequest {
  sessionId: string;
  documentTypes: string[];
  since?: Date | undefined;
  limit: number;
  includeBody: boolean;
}

export interface GetSessionContextResponse {
  success: boolean;
  message: string;
  documents: Document[];
  totalCount: number;
}

/** Delete operations */
export interface DeleteDocumentRequest {
  documentUuid: string;
  /** If not specified, deletes all versions */
  version?: number | undefined;
  deletedBy: string;
  deletedByType: string;
  sessionId: string;
}

export interface DeleteDocumentResponse {
  success: boolean;
  message: string;
  versionsDeleted: number;
}

/** Health check */
export interface HealthCheckRequest {
}

export interface HealthCheckResponse {
  healthy: boolean;
  status: string;
  timestamp?: Date | undefined;
}

function createBaseDocument(): Document {
  return {
    documentUuid: "",
    type: "",
    name: "",
    namespace: "",
    version: 0,
    bodyJson: "",
    metadata: undefined,
    tags: [],
    createdAt: undefined,
    createdBy: "",
    createdByType: "",
    sessionId: "",
  };
}

export const Document = {
  encode(message: Document, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.documentUuid !== "") {
      writer.uint32(10).string(message.documentUuid);
    }
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.namespace !== "") {
      writer.uint32(34).string(message.namespace);
    }
    if (message.version !== 0) {
      writer.uint32(40).int32(message.version);
    }
    if (message.bodyJson !== "") {
      writer.uint32(50).string(message.bodyJson);
    }
    if (message.metadata !== undefined) {
      Struct.encode(Struct.wrap(message.metadata), writer.uint32(58).fork()).ldelim();
    }
    for (const v of message.tags) {
      writer.uint32(66).string(v!);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(74).fork()).ldelim();
    }
    if (message.createdBy !== "") {
      writer.uint32(82).string(message.createdBy);
    }
    if (message.createdByType !== "") {
      writer.uint32(90).string(message.createdByType);
    }
    if (message.sessionId !== "") {
      writer.uint32(98).string(message.sessionId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Document {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.documentUuid = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.namespace = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.version = reader.int32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.bodyJson = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.metadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.createdBy = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.createdByType = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.sessionId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document {
    return {
      documentUuid: isSet(object.documentUuid) ? globalThis.String(object.documentUuid) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      namespace: isSet(object.namespace) ? globalThis.String(object.namespace) : "",
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      bodyJson: isSet(object.bodyJson) ? globalThis.String(object.bodyJson) : "",
      metadata: isObject(object.metadata) ? object.metadata : undefined,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      createdBy: isSet(object.createdBy) ? globalThis.String(object.createdBy) : "",
      createdByType: isSet(object.createdByType) ? globalThis.String(object.createdByType) : "",
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
    };
  },

  toJSON(message: Document): unknown {
    const obj: any = {};
    if (message.documentUuid !== "") {
      obj.documentUuid = message.documentUuid;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.namespace !== "") {
      obj.namespace = message.namespace;
    }
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.bodyJson !== "") {
      obj.bodyJson = message.bodyJson;
    }
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.createdBy !== "") {
      obj.createdBy = message.createdBy;
    }
    if (message.createdByType !== "") {
      obj.createdByType = message.createdByType;
    }
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Document>, I>>(base?: I): Document {
    return Document.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Document>, I>>(object: I): Document {
    const message = createBaseDocument();
    message.documentUuid = object.documentUuid ?? "";
    message.type = object.type ?? "";
    message.name = object.name ?? "";
    message.namespace = object.namespace ?? "";
    message.version = object.version ?? 0;
    message.bodyJson = object.bodyJson ?? "";
    message.metadata = object.metadata ?? undefined;
    message.tags = object.tags?.map((e) => e) || [];
    message.createdAt = object.createdAt ?? undefined;
    message.createdBy = object.createdBy ?? "";
    message.createdByType = object.createdByType ?? "";
    message.sessionId = object.sessionId ?? "";
    return message;
  },
};

function createBaseDocumentStub(): DocumentStub {
  return {
    documentUuid: "",
    type: "",
    name: "",
    namespace: "",
    version: 0,
    metadata: undefined,
    tags: [],
    createdAt: undefined,
    createdBy: "",
    createdByType: "",
    sessionId: "",
  };
}

export const DocumentStub = {
  encode(message: DocumentStub, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.documentUuid !== "") {
      writer.uint32(10).string(message.documentUuid);
    }
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.namespace !== "") {
      writer.uint32(34).string(message.namespace);
    }
    if (message.version !== 0) {
      writer.uint32(40).int32(message.version);
    }
    if (message.metadata !== undefined) {
      Struct.encode(Struct.wrap(message.metadata), writer.uint32(50).fork()).ldelim();
    }
    for (const v of message.tags) {
      writer.uint32(58).string(v!);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(66).fork()).ldelim();
    }
    if (message.createdBy !== "") {
      writer.uint32(74).string(message.createdBy);
    }
    if (message.createdByType !== "") {
      writer.uint32(82).string(message.createdByType);
    }
    if (message.sessionId !== "") {
      writer.uint32(90).string(message.sessionId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DocumentStub {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocumentStub();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.documentUuid = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.namespace = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.version = reader.int32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.metadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.createdBy = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.createdByType = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.sessionId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DocumentStub {
    return {
      documentUuid: isSet(object.documentUuid) ? globalThis.String(object.documentUuid) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      namespace: isSet(object.namespace) ? globalThis.String(object.namespace) : "",
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      metadata: isObject(object.metadata) ? object.metadata : undefined,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      createdBy: isSet(object.createdBy) ? globalThis.String(object.createdBy) : "",
      createdByType: isSet(object.createdByType) ? globalThis.String(object.createdByType) : "",
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
    };
  },

  toJSON(message: DocumentStub): unknown {
    const obj: any = {};
    if (message.documentUuid !== "") {
      obj.documentUuid = message.documentUuid;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.namespace !== "") {
      obj.namespace = message.namespace;
    }
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.createdBy !== "") {
      obj.createdBy = message.createdBy;
    }
    if (message.createdByType !== "") {
      obj.createdByType = message.createdByType;
    }
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DocumentStub>, I>>(base?: I): DocumentStub {
    return DocumentStub.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DocumentStub>, I>>(object: I): DocumentStub {
    const message = createBaseDocumentStub();
    message.documentUuid = object.documentUuid ?? "";
    message.type = object.type ?? "";
    message.name = object.name ?? "";
    message.namespace = object.namespace ?? "";
    message.version = object.version ?? 0;
    message.metadata = object.metadata ?? undefined;
    message.tags = object.tags?.map((e) => e) || [];
    message.createdAt = object.createdAt ?? undefined;
    message.createdBy = object.createdBy ?? "";
    message.createdByType = object.createdByType ?? "";
    message.sessionId = object.sessionId ?? "";
    return message;
  },
};

function createBaseActiveTag(): ActiveTag {
  return {
    documentUuid: "",
    documentVersion: 0,
    tag: "",
    updatedAt: undefined,
    updatedBy: "",
    updatedByType: "",
    sessionId: "",
  };
}

export const ActiveTag = {
  encode(message: ActiveTag, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.documentUuid !== "") {
      writer.uint32(10).string(message.documentUuid);
    }
    if (message.documentVersion !== 0) {
      writer.uint32(16).int32(message.documentVersion);
    }
    if (message.tag !== "") {
      writer.uint32(26).string(message.tag);
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(34).fork()).ldelim();
    }
    if (message.updatedBy !== "") {
      writer.uint32(42).string(message.updatedBy);
    }
    if (message.updatedByType !== "") {
      writer.uint32(50).string(message.updatedByType);
    }
    if (message.sessionId !== "") {
      writer.uint32(58).string(message.sessionId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ActiveTag {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActiveTag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.documentUuid = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.documentVersion = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.tag = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.updatedBy = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.updatedByType = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.sessionId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ActiveTag {
    return {
      documentUuid: isSet(object.documentUuid) ? globalThis.String(object.documentUuid) : "",
      documentVersion: isSet(object.documentVersion) ? globalThis.Number(object.documentVersion) : 0,
      tag: isSet(object.tag) ? globalThis.String(object.tag) : "",
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      updatedBy: isSet(object.updatedBy) ? globalThis.String(object.updatedBy) : "",
      updatedByType: isSet(object.updatedByType) ? globalThis.String(object.updatedByType) : "",
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
    };
  },

  toJSON(message: ActiveTag): unknown {
    const obj: any = {};
    if (message.documentUuid !== "") {
      obj.documentUuid = message.documentUuid;
    }
    if (message.documentVersion !== 0) {
      obj.documentVersion = Math.round(message.documentVersion);
    }
    if (message.tag !== "") {
      obj.tag = message.tag;
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    if (message.updatedBy !== "") {
      obj.updatedBy = message.updatedBy;
    }
    if (message.updatedByType !== "") {
      obj.updatedByType = message.updatedByType;
    }
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ActiveTag>, I>>(base?: I): ActiveTag {
    return ActiveTag.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ActiveTag>, I>>(object: I): ActiveTag {
    const message = createBaseActiveTag();
    message.documentUuid = object.documentUuid ?? "";
    message.documentVersion = object.documentVersion ?? 0;
    message.tag = object.tag ?? "";
    message.updatedAt = object.updatedAt ?? undefined;
    message.updatedBy = object.updatedBy ?? "";
    message.updatedByType = object.updatedByType ?? "";
    message.sessionId = object.sessionId ?? "";
    return message;
  },
};

function createBaseTagEvent(): TagEvent {
  return {
    tagEventUuid: "",
    documentUuid: "",
    documentVersion: 0,
    tag: "",
    operation: "",
    createdAt: undefined,
    createdBy: "",
    createdByType: "",
    sessionId: "",
  };
}

export const TagEvent = {
  encode(message: TagEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tagEventUuid !== "") {
      writer.uint32(10).string(message.tagEventUuid);
    }
    if (message.documentUuid !== "") {
      writer.uint32(18).string(message.documentUuid);
    }
    if (message.documentVersion !== 0) {
      writer.uint32(24).int32(message.documentVersion);
    }
    if (message.tag !== "") {
      writer.uint32(34).string(message.tag);
    }
    if (message.operation !== "") {
      writer.uint32(42).string(message.operation);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(50).fork()).ldelim();
    }
    if (message.createdBy !== "") {
      writer.uint32(58).string(message.createdBy);
    }
    if (message.createdByType !== "") {
      writer.uint32(66).string(message.createdByType);
    }
    if (message.sessionId !== "") {
      writer.uint32(74).string(message.sessionId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TagEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTagEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tagEventUuid = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.documentUuid = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.documentVersion = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.tag = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.operation = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.createdBy = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.createdByType = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.sessionId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TagEvent {
    return {
      tagEventUuid: isSet(object.tagEventUuid) ? globalThis.String(object.tagEventUuid) : "",
      documentUuid: isSet(object.documentUuid) ? globalThis.String(object.documentUuid) : "",
      documentVersion: isSet(object.documentVersion) ? globalThis.Number(object.documentVersion) : 0,
      tag: isSet(object.tag) ? globalThis.String(object.tag) : "",
      operation: isSet(object.operation) ? globalThis.String(object.operation) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      createdBy: isSet(object.createdBy) ? globalThis.String(object.createdBy) : "",
      createdByType: isSet(object.createdByType) ? globalThis.String(object.createdByType) : "",
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
    };
  },

  toJSON(message: TagEvent): unknown {
    const obj: any = {};
    if (message.tagEventUuid !== "") {
      obj.tagEventUuid = message.tagEventUuid;
    }
    if (message.documentUuid !== "") {
      obj.documentUuid = message.documentUuid;
    }
    if (message.documentVersion !== 0) {
      obj.documentVersion = Math.round(message.documentVersion);
    }
    if (message.tag !== "") {
      obj.tag = message.tag;
    }
    if (message.operation !== "") {
      obj.operation = message.operation;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.createdBy !== "") {
      obj.createdBy = message.createdBy;
    }
    if (message.createdByType !== "") {
      obj.createdByType = message.createdByType;
    }
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TagEvent>, I>>(base?: I): TagEvent {
    return TagEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TagEvent>, I>>(object: I): TagEvent {
    const message = createBaseTagEvent();
    message.tagEventUuid = object.tagEventUuid ?? "";
    message.documentUuid = object.documentUuid ?? "";
    message.documentVersion = object.documentVersion ?? 0;
    message.tag = object.tag ?? "";
    message.operation = object.operation ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.createdBy = object.createdBy ?? "";
    message.createdByType = object.createdByType ?? "";
    message.sessionId = object.sessionId ?? "";
    return message;
  },
};

function createBasePutDocumentRequest(): PutDocumentRequest {
  return { document: undefined };
}

export const PutDocumentRequest = {
  encode(message: PutDocumentRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.document !== undefined) {
      Document.encode(message.document, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PutDocumentRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePutDocumentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.document = Document.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PutDocumentRequest {
    return { document: isSet(object.document) ? Document.fromJSON(object.document) : undefined };
  },

  toJSON(message: PutDocumentRequest): unknown {
    const obj: any = {};
    if (message.document !== undefined) {
      obj.document = Document.toJSON(message.document);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PutDocumentRequest>, I>>(base?: I): PutDocumentRequest {
    return PutDocumentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PutDocumentRequest>, I>>(object: I): PutDocumentRequest {
    const message = createBasePutDocumentRequest();
    message.document = (object.document !== undefined && object.document !== null)
      ? Document.fromPartial(object.document)
      : undefined;
    return message;
  },
};

function createBasePutDocumentResponse(): PutDocumentResponse {
  return { success: false, message: "", documentUuid: "", version: 0 };
}

export const PutDocumentResponse = {
  encode(message: PutDocumentResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.documentUuid !== "") {
      writer.uint32(26).string(message.documentUuid);
    }
    if (message.version !== 0) {
      writer.uint32(32).int32(message.version);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PutDocumentResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePutDocumentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.documentUuid = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.version = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PutDocumentResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      documentUuid: isSet(object.documentUuid) ? globalThis.String(object.documentUuid) : "",
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
    };
  },

  toJSON(message: PutDocumentResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.documentUuid !== "") {
      obj.documentUuid = message.documentUuid;
    }
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PutDocumentResponse>, I>>(base?: I): PutDocumentResponse {
    return PutDocumentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PutDocumentResponse>, I>>(object: I): PutDocumentResponse {
    const message = createBasePutDocumentResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.documentUuid = object.documentUuid ?? "";
    message.version = object.version ?? 0;
    return message;
  },
};

function createBasePutDocumentsRequest(): PutDocumentsRequest {
  return { documents: [] };
}

export const PutDocumentsRequest = {
  encode(message: PutDocumentsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.documents) {
      Document.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PutDocumentsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePutDocumentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.documents.push(Document.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PutDocumentsRequest {
    return {
      documents: globalThis.Array.isArray(object?.documents)
        ? object.documents.map((e: any) => Document.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PutDocumentsRequest): unknown {
    const obj: any = {};
    if (message.documents?.length) {
      obj.documents = message.documents.map((e) => Document.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PutDocumentsRequest>, I>>(base?: I): PutDocumentsRequest {
    return PutDocumentsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PutDocumentsRequest>, I>>(object: I): PutDocumentsRequest {
    const message = createBasePutDocumentsRequest();
    message.documents = object.documents?.map((e) => Document.fromPartial(e)) || [];
    return message;
  },
};

function createBasePutDocumentReceipt(): PutDocumentReceipt {
  return { documentUuid: "", version: 0, success: false, errorMessage: "" };
}

export const PutDocumentReceipt = {
  encode(message: PutDocumentReceipt, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.documentUuid !== "") {
      writer.uint32(10).string(message.documentUuid);
    }
    if (message.version !== 0) {
      writer.uint32(16).int32(message.version);
    }
    if (message.success !== false) {
      writer.uint32(24).bool(message.success);
    }
    if (message.errorMessage !== "") {
      writer.uint32(34).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PutDocumentReceipt {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePutDocumentReceipt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.documentUuid = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.version = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PutDocumentReceipt {
    return {
      documentUuid: isSet(object.documentUuid) ? globalThis.String(object.documentUuid) : "",
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
    };
  },

  toJSON(message: PutDocumentReceipt): unknown {
    const obj: any = {};
    if (message.documentUuid !== "") {
      obj.documentUuid = message.documentUuid;
    }
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PutDocumentReceipt>, I>>(base?: I): PutDocumentReceipt {
    return PutDocumentReceipt.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PutDocumentReceipt>, I>>(object: I): PutDocumentReceipt {
    const message = createBasePutDocumentReceipt();
    message.documentUuid = object.documentUuid ?? "";
    message.version = object.version ?? 0;
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? "";
    return message;
  },
};

function createBasePutDocumentsResponse(): PutDocumentsResponse {
  return { success: false, message: "", receipts: [] };
}

export const PutDocumentsResponse = {
  encode(message: PutDocumentsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.receipts) {
      PutDocumentReceipt.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PutDocumentsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePutDocumentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.receipts.push(PutDocumentReceipt.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PutDocumentsResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      receipts: globalThis.Array.isArray(object?.receipts)
        ? object.receipts.map((e: any) => PutDocumentReceipt.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PutDocumentsResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.receipts?.length) {
      obj.receipts = message.receipts.map((e) => PutDocumentReceipt.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PutDocumentsResponse>, I>>(base?: I): PutDocumentsResponse {
    return PutDocumentsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PutDocumentsResponse>, I>>(object: I): PutDocumentsResponse {
    const message = createBasePutDocumentsResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.receipts = object.receipts?.map((e) => PutDocumentReceipt.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetDocumentRequest(): GetDocumentRequest {
  return { documentUuid: "", version: undefined, tag: undefined, includeBody: false };
}

export const GetDocumentRequest = {
  encode(message: GetDocumentRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.documentUuid !== "") {
      writer.uint32(10).string(message.documentUuid);
    }
    if (message.version !== undefined) {
      writer.uint32(16).int32(message.version);
    }
    if (message.tag !== undefined) {
      writer.uint32(26).string(message.tag);
    }
    if (message.includeBody !== false) {
      writer.uint32(32).bool(message.includeBody);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetDocumentRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDocumentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.documentUuid = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.version = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.tag = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.includeBody = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDocumentRequest {
    return {
      documentUuid: isSet(object.documentUuid) ? globalThis.String(object.documentUuid) : "",
      version: isSet(object.version) ? globalThis.Number(object.version) : undefined,
      tag: isSet(object.tag) ? globalThis.String(object.tag) : undefined,
      includeBody: isSet(object.includeBody) ? globalThis.Boolean(object.includeBody) : false,
    };
  },

  toJSON(message: GetDocumentRequest): unknown {
    const obj: any = {};
    if (message.documentUuid !== "") {
      obj.documentUuid = message.documentUuid;
    }
    if (message.version !== undefined) {
      obj.version = Math.round(message.version);
    }
    if (message.tag !== undefined) {
      obj.tag = message.tag;
    }
    if (message.includeBody !== false) {
      obj.includeBody = message.includeBody;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetDocumentRequest>, I>>(base?: I): GetDocumentRequest {
    return GetDocumentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetDocumentRequest>, I>>(object: I): GetDocumentRequest {
    const message = createBaseGetDocumentRequest();
    message.documentUuid = object.documentUuid ?? "";
    message.version = object.version ?? undefined;
    message.tag = object.tag ?? undefined;
    message.includeBody = object.includeBody ?? false;
    return message;
  },
};

function createBaseGetDocumentResponse(): GetDocumentResponse {
  return { success: false, message: "", document: undefined };
}

export const GetDocumentResponse = {
  encode(message: GetDocumentResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.document !== undefined) {
      Document.encode(message.document, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetDocumentResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDocumentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.document = Document.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDocumentResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      document: isSet(object.document) ? Document.fromJSON(object.document) : undefined,
    };
  },

  toJSON(message: GetDocumentResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.document !== undefined) {
      obj.document = Document.toJSON(message.document);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetDocumentResponse>, I>>(base?: I): GetDocumentResponse {
    return GetDocumentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetDocumentResponse>, I>>(object: I): GetDocumentResponse {
    const message = createBaseGetDocumentResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.document = (object.document !== undefined && object.document !== null)
      ? Document.fromPartial(object.document)
      : undefined;
    return message;
  },
};

function createBaseListDocumentsRequest(): ListDocumentsRequest {
  return {
    namespace: undefined,
    type: undefined,
    tag: undefined,
    sessionId: undefined,
    paginationToken: undefined,
    pageSize: 0,
    includeBody: false,
    latestVersionsOnly: false,
  };
}

export const ListDocumentsRequest = {
  encode(message: ListDocumentsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.namespace !== undefined) {
      writer.uint32(10).string(message.namespace);
    }
    if (message.type !== undefined) {
      writer.uint32(18).string(message.type);
    }
    if (message.tag !== undefined) {
      writer.uint32(26).string(message.tag);
    }
    if (message.sessionId !== undefined) {
      writer.uint32(34).string(message.sessionId);
    }
    if (message.paginationToken !== undefined) {
      Timestamp.encode(toTimestamp(message.paginationToken), writer.uint32(42).fork()).ldelim();
    }
    if (message.pageSize !== 0) {
      writer.uint32(48).int32(message.pageSize);
    }
    if (message.includeBody !== false) {
      writer.uint32(56).bool(message.includeBody);
    }
    if (message.latestVersionsOnly !== false) {
      writer.uint32(64).bool(message.latestVersionsOnly);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListDocumentsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDocumentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.namespace = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.tag = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.paginationToken = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.includeBody = reader.bool();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.latestVersionsOnly = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDocumentsRequest {
    return {
      namespace: isSet(object.namespace) ? globalThis.String(object.namespace) : undefined,
      type: isSet(object.type) ? globalThis.String(object.type) : undefined,
      tag: isSet(object.tag) ? globalThis.String(object.tag) : undefined,
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : undefined,
      paginationToken: isSet(object.paginationToken) ? fromJsonTimestamp(object.paginationToken) : undefined,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      includeBody: isSet(object.includeBody) ? globalThis.Boolean(object.includeBody) : false,
      latestVersionsOnly: isSet(object.latestVersionsOnly) ? globalThis.Boolean(object.latestVersionsOnly) : false,
    };
  },

  toJSON(message: ListDocumentsRequest): unknown {
    const obj: any = {};
    if (message.namespace !== undefined) {
      obj.namespace = message.namespace;
    }
    if (message.type !== undefined) {
      obj.type = message.type;
    }
    if (message.tag !== undefined) {
      obj.tag = message.tag;
    }
    if (message.sessionId !== undefined) {
      obj.sessionId = message.sessionId;
    }
    if (message.paginationToken !== undefined) {
      obj.paginationToken = message.paginationToken.toISOString();
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.includeBody !== false) {
      obj.includeBody = message.includeBody;
    }
    if (message.latestVersionsOnly !== false) {
      obj.latestVersionsOnly = message.latestVersionsOnly;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListDocumentsRequest>, I>>(base?: I): ListDocumentsRequest {
    return ListDocumentsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListDocumentsRequest>, I>>(object: I): ListDocumentsRequest {
    const message = createBaseListDocumentsRequest();
    message.namespace = object.namespace ?? undefined;
    message.type = object.type ?? undefined;
    message.tag = object.tag ?? undefined;
    message.sessionId = object.sessionId ?? undefined;
    message.paginationToken = object.paginationToken ?? undefined;
    message.pageSize = object.pageSize ?? 0;
    message.includeBody = object.includeBody ?? false;
    message.latestVersionsOnly = object.latestVersionsOnly ?? false;
    return message;
  },
};

function createBaseListDocumentsResponse(): ListDocumentsResponse {
  return { success: false, message: "", documents: [], nextPaginationToken: undefined, totalCount: 0 };
}

export const ListDocumentsResponse = {
  encode(message: ListDocumentsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.documents) {
      Document.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.nextPaginationToken !== undefined) {
      Timestamp.encode(toTimestamp(message.nextPaginationToken), writer.uint32(34).fork()).ldelim();
    }
    if (message.totalCount !== 0) {
      writer.uint32(40).int32(message.totalCount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListDocumentsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDocumentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.documents.push(Document.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.nextPaginationToken = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.totalCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDocumentsResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      documents: globalThis.Array.isArray(object?.documents)
        ? object.documents.map((e: any) => Document.fromJSON(e))
        : [],
      nextPaginationToken: isSet(object.nextPaginationToken)
        ? fromJsonTimestamp(object.nextPaginationToken)
        : undefined,
      totalCount: isSet(object.totalCount) ? globalThis.Number(object.totalCount) : 0,
    };
  },

  toJSON(message: ListDocumentsResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.documents?.length) {
      obj.documents = message.documents.map((e) => Document.toJSON(e));
    }
    if (message.nextPaginationToken !== undefined) {
      obj.nextPaginationToken = message.nextPaginationToken.toISOString();
    }
    if (message.totalCount !== 0) {
      obj.totalCount = Math.round(message.totalCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListDocumentsResponse>, I>>(base?: I): ListDocumentsResponse {
    return ListDocumentsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListDocumentsResponse>, I>>(object: I): ListDocumentsResponse {
    const message = createBaseListDocumentsResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.documents = object.documents?.map((e) => Document.fromPartial(e)) || [];
    message.nextPaginationToken = object.nextPaginationToken ?? undefined;
    message.totalCount = object.totalCount ?? 0;
    return message;
  },
};

function createBaseListDocumentVersionsRequest(): ListDocumentVersionsRequest {
  return { documentUuid: "", paginationToken: undefined, pageSize: 0, includeBody: false };
}

export const ListDocumentVersionsRequest = {
  encode(message: ListDocumentVersionsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.documentUuid !== "") {
      writer.uint32(10).string(message.documentUuid);
    }
    if (message.paginationToken !== undefined) {
      Timestamp.encode(toTimestamp(message.paginationToken), writer.uint32(18).fork()).ldelim();
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.includeBody !== false) {
      writer.uint32(32).bool(message.includeBody);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListDocumentVersionsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDocumentVersionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.documentUuid = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.paginationToken = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.includeBody = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDocumentVersionsRequest {
    return {
      documentUuid: isSet(object.documentUuid) ? globalThis.String(object.documentUuid) : "",
      paginationToken: isSet(object.paginationToken) ? fromJsonTimestamp(object.paginationToken) : undefined,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      includeBody: isSet(object.includeBody) ? globalThis.Boolean(object.includeBody) : false,
    };
  },

  toJSON(message: ListDocumentVersionsRequest): unknown {
    const obj: any = {};
    if (message.documentUuid !== "") {
      obj.documentUuid = message.documentUuid;
    }
    if (message.paginationToken !== undefined) {
      obj.paginationToken = message.paginationToken.toISOString();
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.includeBody !== false) {
      obj.includeBody = message.includeBody;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListDocumentVersionsRequest>, I>>(base?: I): ListDocumentVersionsRequest {
    return ListDocumentVersionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListDocumentVersionsRequest>, I>>(object: I): ListDocumentVersionsRequest {
    const message = createBaseListDocumentVersionsRequest();
    message.documentUuid = object.documentUuid ?? "";
    message.paginationToken = object.paginationToken ?? undefined;
    message.pageSize = object.pageSize ?? 0;
    message.includeBody = object.includeBody ?? false;
    return message;
  },
};

function createBaseListDocumentVersionsResponse(): ListDocumentVersionsResponse {
  return { success: false, message: "", documents: [], nextPaginationToken: undefined, totalCount: 0 };
}

export const ListDocumentVersionsResponse = {
  encode(message: ListDocumentVersionsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.documents) {
      Document.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.nextPaginationToken !== undefined) {
      Timestamp.encode(toTimestamp(message.nextPaginationToken), writer.uint32(34).fork()).ldelim();
    }
    if (message.totalCount !== 0) {
      writer.uint32(40).int32(message.totalCount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListDocumentVersionsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDocumentVersionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.documents.push(Document.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.nextPaginationToken = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.totalCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDocumentVersionsResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      documents: globalThis.Array.isArray(object?.documents)
        ? object.documents.map((e: any) => Document.fromJSON(e))
        : [],
      nextPaginationToken: isSet(object.nextPaginationToken)
        ? fromJsonTimestamp(object.nextPaginationToken)
        : undefined,
      totalCount: isSet(object.totalCount) ? globalThis.Number(object.totalCount) : 0,
    };
  },

  toJSON(message: ListDocumentVersionsResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.documents?.length) {
      obj.documents = message.documents.map((e) => Document.toJSON(e));
    }
    if (message.nextPaginationToken !== undefined) {
      obj.nextPaginationToken = message.nextPaginationToken.toISOString();
    }
    if (message.totalCount !== 0) {
      obj.totalCount = Math.round(message.totalCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListDocumentVersionsResponse>, I>>(base?: I): ListDocumentVersionsResponse {
    return ListDocumentVersionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListDocumentVersionsResponse>, I>>(object: I): ListDocumentVersionsResponse {
    const message = createBaseListDocumentVersionsResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.documents = object.documents?.map((e) => Document.fromPartial(e)) || [];
    message.nextPaginationToken = object.nextPaginationToken ?? undefined;
    message.totalCount = object.totalCount ?? 0;
    return message;
  },
};

function createBaseTagDocumentRequest(): TagDocumentRequest {
  return { documentUuid: "", version: 0, tag: "", taggedBy: "", taggedByType: "", sessionId: "" };
}

export const TagDocumentRequest = {
  encode(message: TagDocumentRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.documentUuid !== "") {
      writer.uint32(10).string(message.documentUuid);
    }
    if (message.version !== 0) {
      writer.uint32(16).int32(message.version);
    }
    if (message.tag !== "") {
      writer.uint32(26).string(message.tag);
    }
    if (message.taggedBy !== "") {
      writer.uint32(34).string(message.taggedBy);
    }
    if (message.taggedByType !== "") {
      writer.uint32(42).string(message.taggedByType);
    }
    if (message.sessionId !== "") {
      writer.uint32(50).string(message.sessionId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TagDocumentRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTagDocumentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.documentUuid = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.version = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.tag = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.taggedBy = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.taggedByType = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.sessionId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TagDocumentRequest {
    return {
      documentUuid: isSet(object.documentUuid) ? globalThis.String(object.documentUuid) : "",
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      tag: isSet(object.tag) ? globalThis.String(object.tag) : "",
      taggedBy: isSet(object.taggedBy) ? globalThis.String(object.taggedBy) : "",
      taggedByType: isSet(object.taggedByType) ? globalThis.String(object.taggedByType) : "",
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
    };
  },

  toJSON(message: TagDocumentRequest): unknown {
    const obj: any = {};
    if (message.documentUuid !== "") {
      obj.documentUuid = message.documentUuid;
    }
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.tag !== "") {
      obj.tag = message.tag;
    }
    if (message.taggedBy !== "") {
      obj.taggedBy = message.taggedBy;
    }
    if (message.taggedByType !== "") {
      obj.taggedByType = message.taggedByType;
    }
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TagDocumentRequest>, I>>(base?: I): TagDocumentRequest {
    return TagDocumentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TagDocumentRequest>, I>>(object: I): TagDocumentRequest {
    const message = createBaseTagDocumentRequest();
    message.documentUuid = object.documentUuid ?? "";
    message.version = object.version ?? 0;
    message.tag = object.tag ?? "";
    message.taggedBy = object.taggedBy ?? "";
    message.taggedByType = object.taggedByType ?? "";
    message.sessionId = object.sessionId ?? "";
    return message;
  },
};

function createBaseTagDocumentResponse(): TagDocumentResponse {
  return { success: false, message: "" };
}

export const TagDocumentResponse = {
  encode(message: TagDocumentResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TagDocumentResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTagDocumentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TagDocumentResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: TagDocumentResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TagDocumentResponse>, I>>(base?: I): TagDocumentResponse {
    return TagDocumentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TagDocumentResponse>, I>>(object: I): TagDocumentResponse {
    const message = createBaseTagDocumentResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseListActiveTagsRequest(): ListActiveTagsRequest {
  return { documentUuid: "", documentVersion: undefined, paginationToken: undefined, pageSize: 0 };
}

export const ListActiveTagsRequest = {
  encode(message: ListActiveTagsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.documentUuid !== "") {
      writer.uint32(10).string(message.documentUuid);
    }
    if (message.documentVersion !== undefined) {
      writer.uint32(16).int32(message.documentVersion);
    }
    if (message.paginationToken !== undefined) {
      Timestamp.encode(toTimestamp(message.paginationToken), writer.uint32(26).fork()).ldelim();
    }
    if (message.pageSize !== 0) {
      writer.uint32(32).int32(message.pageSize);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListActiveTagsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListActiveTagsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.documentUuid = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.documentVersion = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.paginationToken = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListActiveTagsRequest {
    return {
      documentUuid: isSet(object.documentUuid) ? globalThis.String(object.documentUuid) : "",
      documentVersion: isSet(object.documentVersion) ? globalThis.Number(object.documentVersion) : undefined,
      paginationToken: isSet(object.paginationToken) ? fromJsonTimestamp(object.paginationToken) : undefined,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
    };
  },

  toJSON(message: ListActiveTagsRequest): unknown {
    const obj: any = {};
    if (message.documentUuid !== "") {
      obj.documentUuid = message.documentUuid;
    }
    if (message.documentVersion !== undefined) {
      obj.documentVersion = Math.round(message.documentVersion);
    }
    if (message.paginationToken !== undefined) {
      obj.paginationToken = message.paginationToken.toISOString();
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListActiveTagsRequest>, I>>(base?: I): ListActiveTagsRequest {
    return ListActiveTagsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListActiveTagsRequest>, I>>(object: I): ListActiveTagsRequest {
    const message = createBaseListActiveTagsRequest();
    message.documentUuid = object.documentUuid ?? "";
    message.documentVersion = object.documentVersion ?? undefined;
    message.paginationToken = object.paginationToken ?? undefined;
    message.pageSize = object.pageSize ?? 0;
    return message;
  },
};

function createBaseListActiveTagsResponse(): ListActiveTagsResponse {
  return { success: false, message: "", tags: [], nextPaginationToken: undefined, totalCount: 0 };
}

export const ListActiveTagsResponse = {
  encode(message: ListActiveTagsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.tags) {
      ActiveTag.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.nextPaginationToken !== undefined) {
      Timestamp.encode(toTimestamp(message.nextPaginationToken), writer.uint32(34).fork()).ldelim();
    }
    if (message.totalCount !== 0) {
      writer.uint32(40).int32(message.totalCount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListActiveTagsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListActiveTagsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.tags.push(ActiveTag.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.nextPaginationToken = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.totalCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListActiveTagsResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => ActiveTag.fromJSON(e)) : [],
      nextPaginationToken: isSet(object.nextPaginationToken)
        ? fromJsonTimestamp(object.nextPaginationToken)
        : undefined,
      totalCount: isSet(object.totalCount) ? globalThis.Number(object.totalCount) : 0,
    };
  },

  toJSON(message: ListActiveTagsResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.tags?.length) {
      obj.tags = message.tags.map((e) => ActiveTag.toJSON(e));
    }
    if (message.nextPaginationToken !== undefined) {
      obj.nextPaginationToken = message.nextPaginationToken.toISOString();
    }
    if (message.totalCount !== 0) {
      obj.totalCount = Math.round(message.totalCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListActiveTagsResponse>, I>>(base?: I): ListActiveTagsResponse {
    return ListActiveTagsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListActiveTagsResponse>, I>>(object: I): ListActiveTagsResponse {
    const message = createBaseListActiveTagsResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.tags = object.tags?.map((e) => ActiveTag.fromPartial(e)) || [];
    message.nextPaginationToken = object.nextPaginationToken ?? undefined;
    message.totalCount = object.totalCount ?? 0;
    return message;
  },
};

function createBaseListTagEventsRequest(): ListTagEventsRequest {
  return { documentUuid: "", tag: "", paginationToken: undefined, pageSize: 0 };
}

export const ListTagEventsRequest = {
  encode(message: ListTagEventsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.documentUuid !== "") {
      writer.uint32(10).string(message.documentUuid);
    }
    if (message.tag !== "") {
      writer.uint32(18).string(message.tag);
    }
    if (message.paginationToken !== undefined) {
      Timestamp.encode(toTimestamp(message.paginationToken), writer.uint32(26).fork()).ldelim();
    }
    if (message.pageSize !== 0) {
      writer.uint32(32).int32(message.pageSize);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListTagEventsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTagEventsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.documentUuid = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tag = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.paginationToken = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTagEventsRequest {
    return {
      documentUuid: isSet(object.documentUuid) ? globalThis.String(object.documentUuid) : "",
      tag: isSet(object.tag) ? globalThis.String(object.tag) : "",
      paginationToken: isSet(object.paginationToken) ? fromJsonTimestamp(object.paginationToken) : undefined,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
    };
  },

  toJSON(message: ListTagEventsRequest): unknown {
    const obj: any = {};
    if (message.documentUuid !== "") {
      obj.documentUuid = message.documentUuid;
    }
    if (message.tag !== "") {
      obj.tag = message.tag;
    }
    if (message.paginationToken !== undefined) {
      obj.paginationToken = message.paginationToken.toISOString();
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListTagEventsRequest>, I>>(base?: I): ListTagEventsRequest {
    return ListTagEventsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListTagEventsRequest>, I>>(object: I): ListTagEventsRequest {
    const message = createBaseListTagEventsRequest();
    message.documentUuid = object.documentUuid ?? "";
    message.tag = object.tag ?? "";
    message.paginationToken = object.paginationToken ?? undefined;
    message.pageSize = object.pageSize ?? 0;
    return message;
  },
};

function createBaseListTagEventsResponse(): ListTagEventsResponse {
  return { success: false, message: "", events: [], nextPaginationToken: undefined, totalCount: 0 };
}

export const ListTagEventsResponse = {
  encode(message: ListTagEventsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.events) {
      TagEvent.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.nextPaginationToken !== undefined) {
      Timestamp.encode(toTimestamp(message.nextPaginationToken), writer.uint32(34).fork()).ldelim();
    }
    if (message.totalCount !== 0) {
      writer.uint32(40).int32(message.totalCount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListTagEventsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTagEventsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.events.push(TagEvent.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.nextPaginationToken = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.totalCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTagEventsResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      events: globalThis.Array.isArray(object?.events) ? object.events.map((e: any) => TagEvent.fromJSON(e)) : [],
      nextPaginationToken: isSet(object.nextPaginationToken)
        ? fromJsonTimestamp(object.nextPaginationToken)
        : undefined,
      totalCount: isSet(object.totalCount) ? globalThis.Number(object.totalCount) : 0,
    };
  },

  toJSON(message: ListTagEventsResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.events?.length) {
      obj.events = message.events.map((e) => TagEvent.toJSON(e));
    }
    if (message.nextPaginationToken !== undefined) {
      obj.nextPaginationToken = message.nextPaginationToken.toISOString();
    }
    if (message.totalCount !== 0) {
      obj.totalCount = Math.round(message.totalCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListTagEventsResponse>, I>>(base?: I): ListTagEventsResponse {
    return ListTagEventsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListTagEventsResponse>, I>>(object: I): ListTagEventsResponse {
    const message = createBaseListTagEventsResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.events = object.events?.map((e) => TagEvent.fromPartial(e)) || [];
    message.nextPaginationToken = object.nextPaginationToken ?? undefined;
    message.totalCount = object.totalCount ?? 0;
    return message;
  },
};

function createBaseGetSessionContextRequest(): GetSessionContextRequest {
  return { sessionId: "", documentTypes: [], since: undefined, limit: 0, includeBody: false };
}

export const GetSessionContextRequest = {
  encode(message: GetSessionContextRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    for (const v of message.documentTypes) {
      writer.uint32(18).string(v!);
    }
    if (message.since !== undefined) {
      Timestamp.encode(toTimestamp(message.since), writer.uint32(26).fork()).ldelim();
    }
    if (message.limit !== 0) {
      writer.uint32(32).int32(message.limit);
    }
    if (message.includeBody !== false) {
      writer.uint32(40).bool(message.includeBody);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetSessionContextRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSessionContextRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.documentTypes.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.since = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.limit = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.includeBody = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSessionContextRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      documentTypes: globalThis.Array.isArray(object?.documentTypes)
        ? object.documentTypes.map((e: any) => globalThis.String(e))
        : [],
      since: isSet(object.since) ? fromJsonTimestamp(object.since) : undefined,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      includeBody: isSet(object.includeBody) ? globalThis.Boolean(object.includeBody) : false,
    };
  },

  toJSON(message: GetSessionContextRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.documentTypes?.length) {
      obj.documentTypes = message.documentTypes;
    }
    if (message.since !== undefined) {
      obj.since = message.since.toISOString();
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.includeBody !== false) {
      obj.includeBody = message.includeBody;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSessionContextRequest>, I>>(base?: I): GetSessionContextRequest {
    return GetSessionContextRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSessionContextRequest>, I>>(object: I): GetSessionContextRequest {
    const message = createBaseGetSessionContextRequest();
    message.sessionId = object.sessionId ?? "";
    message.documentTypes = object.documentTypes?.map((e) => e) || [];
    message.since = object.since ?? undefined;
    message.limit = object.limit ?? 0;
    message.includeBody = object.includeBody ?? false;
    return message;
  },
};

function createBaseGetSessionContextResponse(): GetSessionContextResponse {
  return { success: false, message: "", documents: [], totalCount: 0 };
}

export const GetSessionContextResponse = {
  encode(message: GetSessionContextResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.documents) {
      Document.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.totalCount !== 0) {
      writer.uint32(32).int32(message.totalCount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetSessionContextResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSessionContextResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.documents.push(Document.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.totalCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSessionContextResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      documents: globalThis.Array.isArray(object?.documents)
        ? object.documents.map((e: any) => Document.fromJSON(e))
        : [],
      totalCount: isSet(object.totalCount) ? globalThis.Number(object.totalCount) : 0,
    };
  },

  toJSON(message: GetSessionContextResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.documents?.length) {
      obj.documents = message.documents.map((e) => Document.toJSON(e));
    }
    if (message.totalCount !== 0) {
      obj.totalCount = Math.round(message.totalCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSessionContextResponse>, I>>(base?: I): GetSessionContextResponse {
    return GetSessionContextResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSessionContextResponse>, I>>(object: I): GetSessionContextResponse {
    const message = createBaseGetSessionContextResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.documents = object.documents?.map((e) => Document.fromPartial(e)) || [];
    message.totalCount = object.totalCount ?? 0;
    return message;
  },
};

function createBaseDeleteDocumentRequest(): DeleteDocumentRequest {
  return { documentUuid: "", version: undefined, deletedBy: "", deletedByType: "", sessionId: "" };
}

export const DeleteDocumentRequest = {
  encode(message: DeleteDocumentRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.documentUuid !== "") {
      writer.uint32(10).string(message.documentUuid);
    }
    if (message.version !== undefined) {
      writer.uint32(16).int32(message.version);
    }
    if (message.deletedBy !== "") {
      writer.uint32(26).string(message.deletedBy);
    }
    if (message.deletedByType !== "") {
      writer.uint32(34).string(message.deletedByType);
    }
    if (message.sessionId !== "") {
      writer.uint32(42).string(message.sessionId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteDocumentRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteDocumentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.documentUuid = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.version = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.deletedBy = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.deletedByType = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.sessionId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteDocumentRequest {
    return {
      documentUuid: isSet(object.documentUuid) ? globalThis.String(object.documentUuid) : "",
      version: isSet(object.version) ? globalThis.Number(object.version) : undefined,
      deletedBy: isSet(object.deletedBy) ? globalThis.String(object.deletedBy) : "",
      deletedByType: isSet(object.deletedByType) ? globalThis.String(object.deletedByType) : "",
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
    };
  },

  toJSON(message: DeleteDocumentRequest): unknown {
    const obj: any = {};
    if (message.documentUuid !== "") {
      obj.documentUuid = message.documentUuid;
    }
    if (message.version !== undefined) {
      obj.version = Math.round(message.version);
    }
    if (message.deletedBy !== "") {
      obj.deletedBy = message.deletedBy;
    }
    if (message.deletedByType !== "") {
      obj.deletedByType = message.deletedByType;
    }
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteDocumentRequest>, I>>(base?: I): DeleteDocumentRequest {
    return DeleteDocumentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteDocumentRequest>, I>>(object: I): DeleteDocumentRequest {
    const message = createBaseDeleteDocumentRequest();
    message.documentUuid = object.documentUuid ?? "";
    message.version = object.version ?? undefined;
    message.deletedBy = object.deletedBy ?? "";
    message.deletedByType = object.deletedByType ?? "";
    message.sessionId = object.sessionId ?? "";
    return message;
  },
};

function createBaseDeleteDocumentResponse(): DeleteDocumentResponse {
  return { success: false, message: "", versionsDeleted: 0 };
}

export const DeleteDocumentResponse = {
  encode(message: DeleteDocumentResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.versionsDeleted !== 0) {
      writer.uint32(24).int32(message.versionsDeleted);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteDocumentResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteDocumentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.versionsDeleted = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteDocumentResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      versionsDeleted: isSet(object.versionsDeleted) ? globalThis.Number(object.versionsDeleted) : 0,
    };
  },

  toJSON(message: DeleteDocumentResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.versionsDeleted !== 0) {
      obj.versionsDeleted = Math.round(message.versionsDeleted);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteDocumentResponse>, I>>(base?: I): DeleteDocumentResponse {
    return DeleteDocumentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteDocumentResponse>, I>>(object: I): DeleteDocumentResponse {
    const message = createBaseDeleteDocumentResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.versionsDeleted = object.versionsDeleted ?? 0;
    return message;
  },
};

function createBaseHealthCheckRequest(): HealthCheckRequest {
  return {};
}

export const HealthCheckRequest = {
  encode(_: HealthCheckRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HealthCheckRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheckRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): HealthCheckRequest {
    return {};
  },

  toJSON(_: HealthCheckRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthCheckRequest>, I>>(base?: I): HealthCheckRequest {
    return HealthCheckRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthCheckRequest>, I>>(_: I): HealthCheckRequest {
    const message = createBaseHealthCheckRequest();
    return message;
  },
};

function createBaseHealthCheckResponse(): HealthCheckResponse {
  return { healthy: false, status: "", timestamp: undefined };
}

export const HealthCheckResponse = {
  encode(message: HealthCheckResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.healthy !== false) {
      writer.uint32(8).bool(message.healthy);
    }
    if (message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HealthCheckResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheckResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.healthy = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthCheckResponse {
    return {
      healthy: isSet(object.healthy) ? globalThis.Boolean(object.healthy) : false,
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
    };
  },

  toJSON(message: HealthCheckResponse): unknown {
    const obj: any = {};
    if (message.healthy !== false) {
      obj.healthy = message.healthy;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthCheckResponse>, I>>(base?: I): HealthCheckResponse {
    return HealthCheckResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthCheckResponse>, I>>(object: I): HealthCheckResponse {
    const message = createBaseHealthCheckResponse();
    message.healthy = object.healthy ?? false;
    message.status = object.status ?? "";
    message.timestamp = object.timestamp ?? undefined;
    return message;
  },
};

/** Service definition */
export type DocumentStoreServiceService = typeof DocumentStoreServiceService;
export const DocumentStoreServiceService = {
  /** Document CRUD operations */
  putDocument: {
    path: "/unhinged.document_store.DocumentStoreService/PutDocument",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PutDocumentRequest) => Buffer.from(PutDocumentRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => PutDocumentRequest.decode(value),
    responseSerialize: (value: PutDocumentResponse) => Buffer.from(PutDocumentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => PutDocumentResponse.decode(value),
  },
  putDocuments: {
    path: "/unhinged.document_store.DocumentStoreService/PutDocuments",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PutDocumentsRequest) => Buffer.from(PutDocumentsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => PutDocumentsRequest.decode(value),
    responseSerialize: (value: PutDocumentsResponse) => Buffer.from(PutDocumentsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => PutDocumentsResponse.decode(value),
  },
  getDocument: {
    path: "/unhinged.document_store.DocumentStoreService/GetDocument",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetDocumentRequest) => Buffer.from(GetDocumentRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetDocumentRequest.decode(value),
    responseSerialize: (value: GetDocumentResponse) => Buffer.from(GetDocumentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetDocumentResponse.decode(value),
  },
  listDocuments: {
    path: "/unhinged.document_store.DocumentStoreService/ListDocuments",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListDocumentsRequest) => Buffer.from(ListDocumentsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ListDocumentsRequest.decode(value),
    responseSerialize: (value: ListDocumentsResponse) => Buffer.from(ListDocumentsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ListDocumentsResponse.decode(value),
  },
  listDocumentVersions: {
    path: "/unhinged.document_store.DocumentStoreService/ListDocumentVersions",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListDocumentVersionsRequest) =>
      Buffer.from(ListDocumentVersionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ListDocumentVersionsRequest.decode(value),
    responseSerialize: (value: ListDocumentVersionsResponse) =>
      Buffer.from(ListDocumentVersionsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ListDocumentVersionsResponse.decode(value),
  },
  deleteDocument: {
    path: "/unhinged.document_store.DocumentStoreService/DeleteDocument",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteDocumentRequest) => Buffer.from(DeleteDocumentRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DeleteDocumentRequest.decode(value),
    responseSerialize: (value: DeleteDocumentResponse) => Buffer.from(DeleteDocumentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DeleteDocumentResponse.decode(value),
  },
  /** Tag operations */
  tagDocument: {
    path: "/unhinged.document_store.DocumentStoreService/TagDocument",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: TagDocumentRequest) => Buffer.from(TagDocumentRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => TagDocumentRequest.decode(value),
    responseSerialize: (value: TagDocumentResponse) => Buffer.from(TagDocumentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TagDocumentResponse.decode(value),
  },
  listActiveTags: {
    path: "/unhinged.document_store.DocumentStoreService/ListActiveTags",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListActiveTagsRequest) => Buffer.from(ListActiveTagsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ListActiveTagsRequest.decode(value),
    responseSerialize: (value: ListActiveTagsResponse) => Buffer.from(ListActiveTagsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ListActiveTagsResponse.decode(value),
  },
  listTagEvents: {
    path: "/unhinged.document_store.DocumentStoreService/ListTagEvents",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListTagEventsRequest) => Buffer.from(ListTagEventsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ListTagEventsRequest.decode(value),
    responseSerialize: (value: ListTagEventsResponse) => Buffer.from(ListTagEventsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ListTagEventsResponse.decode(value),
  },
  /** Session context */
  getSessionContext: {
    path: "/unhinged.document_store.DocumentStoreService/GetSessionContext",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetSessionContextRequest) => Buffer.from(GetSessionContextRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetSessionContextRequest.decode(value),
    responseSerialize: (value: GetSessionContextResponse) =>
      Buffer.from(GetSessionContextResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetSessionContextResponse.decode(value),
  },
  /** Health check */
  healthCheck: {
    path: "/unhinged.document_store.DocumentStoreService/HealthCheck",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: HealthCheckRequest) => Buffer.from(HealthCheckRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => HealthCheckRequest.decode(value),
    responseSerialize: (value: HealthCheckResponse) => Buffer.from(HealthCheckResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => HealthCheckResponse.decode(value),
  },
} as const;

export interface DocumentStoreServiceServer extends UntypedServiceImplementation {
  /** Document CRUD operations */
  putDocument: handleUnaryCall<PutDocumentRequest, PutDocumentResponse>;
  putDocuments: handleUnaryCall<PutDocumentsRequest, PutDocumentsResponse>;
  getDocument: handleUnaryCall<GetDocumentRequest, GetDocumentResponse>;
  listDocuments: handleUnaryCall<ListDocumentsRequest, ListDocumentsResponse>;
  listDocumentVersions: handleUnaryCall<ListDocumentVersionsRequest, ListDocumentVersionsResponse>;
  deleteDocument: handleUnaryCall<DeleteDocumentRequest, DeleteDocumentResponse>;
  /** Tag operations */
  tagDocument: handleUnaryCall<TagDocumentRequest, TagDocumentResponse>;
  listActiveTags: handleUnaryCall<ListActiveTagsRequest, ListActiveTagsResponse>;
  listTagEvents: handleUnaryCall<ListTagEventsRequest, ListTagEventsResponse>;
  /** Session context */
  getSessionContext: handleUnaryCall<GetSessionContextRequest, GetSessionContextResponse>;
  /** Health check */
  healthCheck: handleUnaryCall<HealthCheckRequest, HealthCheckResponse>;
}

export interface DocumentStoreServiceClient extends Client {
  /** Document CRUD operations */
  putDocument(
    request: PutDocumentRequest,
    callback: (error: ServiceError | null, response: PutDocumentResponse) => void,
  ): ClientUnaryCall;
  putDocument(
    request: PutDocumentRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PutDocumentResponse) => void,
  ): ClientUnaryCall;
  putDocument(
    request: PutDocumentRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PutDocumentResponse) => void,
  ): ClientUnaryCall;
  putDocuments(
    request: PutDocumentsRequest,
    callback: (error: ServiceError | null, response: PutDocumentsResponse) => void,
  ): ClientUnaryCall;
  putDocuments(
    request: PutDocumentsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PutDocumentsResponse) => void,
  ): ClientUnaryCall;
  putDocuments(
    request: PutDocumentsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PutDocumentsResponse) => void,
  ): ClientUnaryCall;
  getDocument(
    request: GetDocumentRequest,
    callback: (error: ServiceError | null, response: GetDocumentResponse) => void,
  ): ClientUnaryCall;
  getDocument(
    request: GetDocumentRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetDocumentResponse) => void,
  ): ClientUnaryCall;
  getDocument(
    request: GetDocumentRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetDocumentResponse) => void,
  ): ClientUnaryCall;
  listDocuments(
    request: ListDocumentsRequest,
    callback: (error: ServiceError | null, response: ListDocumentsResponse) => void,
  ): ClientUnaryCall;
  listDocuments(
    request: ListDocumentsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListDocumentsResponse) => void,
  ): ClientUnaryCall;
  listDocuments(
    request: ListDocumentsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListDocumentsResponse) => void,
  ): ClientUnaryCall;
  listDocumentVersions(
    request: ListDocumentVersionsRequest,
    callback: (error: ServiceError | null, response: ListDocumentVersionsResponse) => void,
  ): ClientUnaryCall;
  listDocumentVersions(
    request: ListDocumentVersionsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListDocumentVersionsResponse) => void,
  ): ClientUnaryCall;
  listDocumentVersions(
    request: ListDocumentVersionsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListDocumentVersionsResponse) => void,
  ): ClientUnaryCall;
  deleteDocument(
    request: DeleteDocumentRequest,
    callback: (error: ServiceError | null, response: DeleteDocumentResponse) => void,
  ): ClientUnaryCall;
  deleteDocument(
    request: DeleteDocumentRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DeleteDocumentResponse) => void,
  ): ClientUnaryCall;
  deleteDocument(
    request: DeleteDocumentRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DeleteDocumentResponse) => void,
  ): ClientUnaryCall;
  /** Tag operations */
  tagDocument(
    request: TagDocumentRequest,
    callback: (error: ServiceError | null, response: TagDocumentResponse) => void,
  ): ClientUnaryCall;
  tagDocument(
    request: TagDocumentRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TagDocumentResponse) => void,
  ): ClientUnaryCall;
  tagDocument(
    request: TagDocumentRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TagDocumentResponse) => void,
  ): ClientUnaryCall;
  listActiveTags(
    request: ListActiveTagsRequest,
    callback: (error: ServiceError | null, response: ListActiveTagsResponse) => void,
  ): ClientUnaryCall;
  listActiveTags(
    request: ListActiveTagsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListActiveTagsResponse) => void,
  ): ClientUnaryCall;
  listActiveTags(
    request: ListActiveTagsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListActiveTagsResponse) => void,
  ): ClientUnaryCall;
  listTagEvents(
    request: ListTagEventsRequest,
    callback: (error: ServiceError | null, response: ListTagEventsResponse) => void,
  ): ClientUnaryCall;
  listTagEvents(
    request: ListTagEventsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListTagEventsResponse) => void,
  ): ClientUnaryCall;
  listTagEvents(
    request: ListTagEventsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListTagEventsResponse) => void,
  ): ClientUnaryCall;
  /** Session context */
  getSessionContext(
    request: GetSessionContextRequest,
    callback: (error: ServiceError | null, response: GetSessionContextResponse) => void,
  ): ClientUnaryCall;
  getSessionContext(
    request: GetSessionContextRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetSessionContextResponse) => void,
  ): ClientUnaryCall;
  getSessionContext(
    request: GetSessionContextRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetSessionContextResponse) => void,
  ): ClientUnaryCall;
  /** Health check */
  healthCheck(
    request: HealthCheckRequest,
    callback: (error: ServiceError | null, response: HealthCheckResponse) => void,
  ): ClientUnaryCall;
  healthCheck(
    request: HealthCheckRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: HealthCheckResponse) => void,
  ): ClientUnaryCall;
  healthCheck(
    request: HealthCheckRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: HealthCheckResponse) => void,
  ): ClientUnaryCall;
}

export const DocumentStoreServiceClient = makeGenericClientConstructor(
  DocumentStoreServiceService,
  "unhinged.document_store.DocumentStoreService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): DocumentStoreServiceClient;
  service: typeof DocumentStoreServiceService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000).toString();
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (globalThis.Number(t.seconds) || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
