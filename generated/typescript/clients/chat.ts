// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v3.21.12
// source: chat.proto

/* eslint-disable */
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  ClientReadableStream,
  type ClientUnaryCall,
  handleServerStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import _m0 from "protobufjs/minimal";
import {
  Attachment,
  Filter,
  HealthCheckRequest,
  HealthCheckResponse,
  PaginationRequest,
  PaginationResponse,
  ResourceMetadata,
  StandardResponse,
  StreamChunk,
  UsageMetrics,
} from "./common";

/** Conversation status for lifecycle management */
export enum ConversationStatus {
  CONVERSATION_STATUS_UNSPECIFIED = 0,
  CONVERSATION_STATUS_ACTIVE = 1,
  CONVERSATION_STATUS_ARCHIVED = 2,
  CONVERSATION_STATUS_DELETED = 3,
  CONVERSATION_STATUS_LOCKED = 4,
  UNRECOGNIZED = -1,
}

export function conversationStatusFromJSON(object: any): ConversationStatus {
  switch (object) {
    case 0:
    case "CONVERSATION_STATUS_UNSPECIFIED":
      return ConversationStatus.CONVERSATION_STATUS_UNSPECIFIED;
    case 1:
    case "CONVERSATION_STATUS_ACTIVE":
      return ConversationStatus.CONVERSATION_STATUS_ACTIVE;
    case 2:
    case "CONVERSATION_STATUS_ARCHIVED":
      return ConversationStatus.CONVERSATION_STATUS_ARCHIVED;
    case 3:
    case "CONVERSATION_STATUS_DELETED":
      return ConversationStatus.CONVERSATION_STATUS_DELETED;
    case 4:
    case "CONVERSATION_STATUS_LOCKED":
      return ConversationStatus.CONVERSATION_STATUS_LOCKED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ConversationStatus.UNRECOGNIZED;
  }
}

export function conversationStatusToJSON(object: ConversationStatus): string {
  switch (object) {
    case ConversationStatus.CONVERSATION_STATUS_UNSPECIFIED:
      return "CONVERSATION_STATUS_UNSPECIFIED";
    case ConversationStatus.CONVERSATION_STATUS_ACTIVE:
      return "CONVERSATION_STATUS_ACTIVE";
    case ConversationStatus.CONVERSATION_STATUS_ARCHIVED:
      return "CONVERSATION_STATUS_ARCHIVED";
    case ConversationStatus.CONVERSATION_STATUS_DELETED:
      return "CONVERSATION_STATUS_DELETED";
    case ConversationStatus.CONVERSATION_STATUS_LOCKED:
      return "CONVERSATION_STATUS_LOCKED";
    case ConversationStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Message role in conversation */
export enum MessageRole {
  MESSAGE_ROLE_UNSPECIFIED = 0,
  MESSAGE_ROLE_USER = 1,
  MESSAGE_ROLE_ASSISTANT = 2,
  MESSAGE_ROLE_SYSTEM = 3,
  MESSAGE_ROLE_TOOL = 4,
  UNRECOGNIZED = -1,
}

export function messageRoleFromJSON(object: any): MessageRole {
  switch (object) {
    case 0:
    case "MESSAGE_ROLE_UNSPECIFIED":
      return MessageRole.MESSAGE_ROLE_UNSPECIFIED;
    case 1:
    case "MESSAGE_ROLE_USER":
      return MessageRole.MESSAGE_ROLE_USER;
    case 2:
    case "MESSAGE_ROLE_ASSISTANT":
      return MessageRole.MESSAGE_ROLE_ASSISTANT;
    case 3:
    case "MESSAGE_ROLE_SYSTEM":
      return MessageRole.MESSAGE_ROLE_SYSTEM;
    case 4:
    case "MESSAGE_ROLE_TOOL":
      return MessageRole.MESSAGE_ROLE_TOOL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MessageRole.UNRECOGNIZED;
  }
}

export function messageRoleToJSON(object: MessageRole): string {
  switch (object) {
    case MessageRole.MESSAGE_ROLE_UNSPECIFIED:
      return "MESSAGE_ROLE_UNSPECIFIED";
    case MessageRole.MESSAGE_ROLE_USER:
      return "MESSAGE_ROLE_USER";
    case MessageRole.MESSAGE_ROLE_ASSISTANT:
      return "MESSAGE_ROLE_ASSISTANT";
    case MessageRole.MESSAGE_ROLE_SYSTEM:
      return "MESSAGE_ROLE_SYSTEM";
    case MessageRole.MESSAGE_ROLE_TOOL:
      return "MESSAGE_ROLE_TOOL";
    case MessageRole.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Message processing status */
export enum MessageStatus {
  MESSAGE_STATUS_UNSPECIFIED = 0,
  MESSAGE_STATUS_SENT = 1,
  MESSAGE_STATUS_PROCESSING = 2,
  MESSAGE_STATUS_COMPLETED = 3,
  MESSAGE_STATUS_FAILED = 4,
  MESSAGE_STATUS_EDITED = 5,
  MESSAGE_STATUS_DELETED = 6,
  UNRECOGNIZED = -1,
}

export function messageStatusFromJSON(object: any): MessageStatus {
  switch (object) {
    case 0:
    case "MESSAGE_STATUS_UNSPECIFIED":
      return MessageStatus.MESSAGE_STATUS_UNSPECIFIED;
    case 1:
    case "MESSAGE_STATUS_SENT":
      return MessageStatus.MESSAGE_STATUS_SENT;
    case 2:
    case "MESSAGE_STATUS_PROCESSING":
      return MessageStatus.MESSAGE_STATUS_PROCESSING;
    case 3:
    case "MESSAGE_STATUS_COMPLETED":
      return MessageStatus.MESSAGE_STATUS_COMPLETED;
    case 4:
    case "MESSAGE_STATUS_FAILED":
      return MessageStatus.MESSAGE_STATUS_FAILED;
    case 5:
    case "MESSAGE_STATUS_EDITED":
      return MessageStatus.MESSAGE_STATUS_EDITED;
    case 6:
    case "MESSAGE_STATUS_DELETED":
      return MessageStatus.MESSAGE_STATUS_DELETED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MessageStatus.UNRECOGNIZED;
  }
}

export function messageStatusToJSON(object: MessageStatus): string {
  switch (object) {
    case MessageStatus.MESSAGE_STATUS_UNSPECIFIED:
      return "MESSAGE_STATUS_UNSPECIFIED";
    case MessageStatus.MESSAGE_STATUS_SENT:
      return "MESSAGE_STATUS_SENT";
    case MessageStatus.MESSAGE_STATUS_PROCESSING:
      return "MESSAGE_STATUS_PROCESSING";
    case MessageStatus.MESSAGE_STATUS_COMPLETED:
      return "MESSAGE_STATUS_COMPLETED";
    case MessageStatus.MESSAGE_STATUS_FAILED:
      return "MESSAGE_STATUS_FAILED";
    case MessageStatus.MESSAGE_STATUS_EDITED:
      return "MESSAGE_STATUS_EDITED";
    case MessageStatus.MESSAGE_STATUS_DELETED:
      return "MESSAGE_STATUS_DELETED";
    case MessageStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Tool call execution status */
export enum ToolCallStatus {
  TOOL_CALL_STATUS_UNSPECIFIED = 0,
  TOOL_CALL_STATUS_PENDING = 1,
  TOOL_CALL_STATUS_EXECUTING = 2,
  TOOL_CALL_STATUS_COMPLETED = 3,
  TOOL_CALL_STATUS_FAILED = 4,
  UNRECOGNIZED = -1,
}

export function toolCallStatusFromJSON(object: any): ToolCallStatus {
  switch (object) {
    case 0:
    case "TOOL_CALL_STATUS_UNSPECIFIED":
      return ToolCallStatus.TOOL_CALL_STATUS_UNSPECIFIED;
    case 1:
    case "TOOL_CALL_STATUS_PENDING":
      return ToolCallStatus.TOOL_CALL_STATUS_PENDING;
    case 2:
    case "TOOL_CALL_STATUS_EXECUTING":
      return ToolCallStatus.TOOL_CALL_STATUS_EXECUTING;
    case 3:
    case "TOOL_CALL_STATUS_COMPLETED":
      return ToolCallStatus.TOOL_CALL_STATUS_COMPLETED;
    case 4:
    case "TOOL_CALL_STATUS_FAILED":
      return ToolCallStatus.TOOL_CALL_STATUS_FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ToolCallStatus.UNRECOGNIZED;
  }
}

export function toolCallStatusToJSON(object: ToolCallStatus): string {
  switch (object) {
    case ToolCallStatus.TOOL_CALL_STATUS_UNSPECIFIED:
      return "TOOL_CALL_STATUS_UNSPECIFIED";
    case ToolCallStatus.TOOL_CALL_STATUS_PENDING:
      return "TOOL_CALL_STATUS_PENDING";
    case ToolCallStatus.TOOL_CALL_STATUS_EXECUTING:
      return "TOOL_CALL_STATUS_EXECUTING";
    case ToolCallStatus.TOOL_CALL_STATUS_COMPLETED:
      return "TOOL_CALL_STATUS_COMPLETED";
    case ToolCallStatus.TOOL_CALL_STATUS_FAILED:
      return "TOOL_CALL_STATUS_FAILED";
    case ToolCallStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum UpdateType {
  UPDATE_TYPE_UNSPECIFIED = 0,
  UPDATE_TYPE_MESSAGE_SENT = 1,
  UPDATE_TYPE_MESSAGE_UPDATED = 2,
  UPDATE_TYPE_MESSAGE_DELETED = 3,
  UPDATE_TYPE_TYPING_STARTED = 4,
  UPDATE_TYPE_TYPING_STOPPED = 5,
  UPDATE_TYPE_PARTICIPANT_JOINED = 6,
  UPDATE_TYPE_PARTICIPANT_LEFT = 7,
  UNRECOGNIZED = -1,
}

export function updateTypeFromJSON(object: any): UpdateType {
  switch (object) {
    case 0:
    case "UPDATE_TYPE_UNSPECIFIED":
      return UpdateType.UPDATE_TYPE_UNSPECIFIED;
    case 1:
    case "UPDATE_TYPE_MESSAGE_SENT":
      return UpdateType.UPDATE_TYPE_MESSAGE_SENT;
    case 2:
    case "UPDATE_TYPE_MESSAGE_UPDATED":
      return UpdateType.UPDATE_TYPE_MESSAGE_UPDATED;
    case 3:
    case "UPDATE_TYPE_MESSAGE_DELETED":
      return UpdateType.UPDATE_TYPE_MESSAGE_DELETED;
    case 4:
    case "UPDATE_TYPE_TYPING_STARTED":
      return UpdateType.UPDATE_TYPE_TYPING_STARTED;
    case 5:
    case "UPDATE_TYPE_TYPING_STOPPED":
      return UpdateType.UPDATE_TYPE_TYPING_STOPPED;
    case 6:
    case "UPDATE_TYPE_PARTICIPANT_JOINED":
      return UpdateType.UPDATE_TYPE_PARTICIPANT_JOINED;
    case 7:
    case "UPDATE_TYPE_PARTICIPANT_LEFT":
      return UpdateType.UPDATE_TYPE_PARTICIPANT_LEFT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return UpdateType.UNRECOGNIZED;
  }
}

export function updateTypeToJSON(object: UpdateType): string {
  switch (object) {
    case UpdateType.UPDATE_TYPE_UNSPECIFIED:
      return "UPDATE_TYPE_UNSPECIFIED";
    case UpdateType.UPDATE_TYPE_MESSAGE_SENT:
      return "UPDATE_TYPE_MESSAGE_SENT";
    case UpdateType.UPDATE_TYPE_MESSAGE_UPDATED:
      return "UPDATE_TYPE_MESSAGE_UPDATED";
    case UpdateType.UPDATE_TYPE_MESSAGE_DELETED:
      return "UPDATE_TYPE_MESSAGE_DELETED";
    case UpdateType.UPDATE_TYPE_TYPING_STARTED:
      return "UPDATE_TYPE_TYPING_STARTED";
    case UpdateType.UPDATE_TYPE_TYPING_STOPPED:
      return "UPDATE_TYPE_TYPING_STOPPED";
    case UpdateType.UPDATE_TYPE_PARTICIPANT_JOINED:
      return "UPDATE_TYPE_PARTICIPANT_JOINED";
    case UpdateType.UPDATE_TYPE_PARTICIPANT_LEFT:
      return "UPDATE_TYPE_PARTICIPANT_LEFT";
    case UpdateType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Conversation entity using common resource metadata pattern */
export interface Conversation {
  /** ← DRY! (id, team_id, timestamps, etc.) */
  metadata?: ResourceMetadata | undefined;
  title: string;
  description: string;
  settings?: ConversationSettings | undefined;
  messageCount: number;
  status: ConversationStatus;
  participantIds: string[];
}

/** Conversation configuration for LLM interactions */
export interface ConversationSettings {
  /** LLM model to use */
  model: string;
  temperature: number;
  maxTokens: number;
  stopSequences: string[];
  /** Pull from DocumentStore */
  includeContext: boolean;
  contextWindowSize: number;
  enableTools: boolean;
  availableTools: string[];
}

/** Chat message using common patterns */
export interface ChatMessage {
  /** ← DRY! (id, timestamps, etc.) */
  metadata?: ResourceMetadata | undefined;
  conversationId: string;
  role: MessageRole;
  content: string;
  /** ← DRY! (universal attachments) */
  attachments: Attachment[];
  status: MessageStatus;
  /** For threading */
  parentMessageId: string;
  /** LLM-specific fields */
  usage?: UsageMetrics | undefined;
  toolCalls: ToolCall[];
}

/** Tool call for function execution */
export interface ToolCall {
  toolCallId: string;
  toolName: string;
  /** JSON string */
  arguments: string;
  /** JSON string */
  result: string;
  status: ToolCallStatus;
}

export interface CreateConversationRequest {
  teamId: string;
  namespaceId: string;
  title: string;
  description: string;
  settings?: ConversationSettings | undefined;
}

export interface CreateConversationResponse {
  /** ← DRY! (success, message, error) */
  response?: StandardResponse | undefined;
  conversation?: Conversation | undefined;
}

export interface GetConversationRequest {
  conversationId: string;
  includeMessages: boolean;
  messageLimit: number;
}

export interface GetConversationResponse {
  /** ← DRY! */
  response?: StandardResponse | undefined;
  conversation?: Conversation | undefined;
  messages: ChatMessage[];
}

export interface ListConversationsRequest {
  teamId: string;
  namespaceId: string;
  status: ConversationStatus;
  /** ← DRY! */
  pagination?:
    | PaginationRequest
    | undefined;
  /** ← DRY! */
  filters: Filter[];
}

export interface ListConversationsResponse {
  /** ← DRY! */
  response?: StandardResponse | undefined;
  conversations: Conversation[];
  /** ← DRY! */
  pagination?: PaginationResponse | undefined;
}

export interface SendMessageRequest {
  conversationId: string;
  role: MessageRole;
  content: string;
  /** ← DRY! */
  attachments: Attachment[];
  parentMessageId: string;
}

export interface SendMessageResponse {
  /** ← DRY! */
  response?: StandardResponse | undefined;
  message?: ChatMessage | undefined;
}

export interface StreamChatRequest {
  conversationId: string;
  content: string;
  /** ← DRY! */
  attachments: Attachment[];
  options?: StreamOptions | undefined;
}

export interface StreamOptions {
  model: string;
  maxTokens: number;
  temperature: number;
  includeContext: boolean;
  enableTools: boolean;
}

/** Stream chunks use common.v1.StreamChunk with typed payload */
export interface ChatChunkPayload {
  messageId: string;
  conversationId: string;
  role: MessageRole;
  content: string;
  toolCalls: ToolCall[];
}

export interface SubscribeRequest {
  conversationId: string;
  eventTypes: UpdateType[];
}

export interface GetMessagesRequest {
  conversationId: string;
  /** ← DRY! */
  pagination?: PaginationRequest | undefined;
  roleFilter: MessageRole;
  /** ← DRY! */
  filters: Filter[];
}

export interface GetMessagesResponse {
  /** ← DRY! */
  response?: StandardResponse | undefined;
  messages: ChatMessage[];
  /** ← DRY! */
  pagination?: PaginationResponse | undefined;
}

export interface UpdateConversationRequest {
  conversationId: string;
  title: string;
  description: string;
  settings?: ConversationSettings | undefined;
}

export interface UpdateConversationResponse {
  /** ← DRY! */
  response?: StandardResponse | undefined;
  conversation?: Conversation | undefined;
}

export interface UpdateMessageRequest {
  messageId: string;
  content: string;
}

export interface UpdateMessageResponse {
  /** ← DRY! */
  response?: StandardResponse | undefined;
  message?: ChatMessage | undefined;
}

export interface DeleteConversationRequest {
  conversationId: string;
  /** true = permanent, false = soft delete */
  hardDelete: boolean;
}

export interface DeleteConversationResponse {
  /** ← DRY! */
  response?: StandardResponse | undefined;
}

export interface DeleteMessageRequest {
  messageId: string;
  hardDelete: boolean;
}

export interface DeleteMessageResponse {
  /** ← DRY! */
  response?: StandardResponse | undefined;
}

function createBaseConversation(): Conversation {
  return {
    metadata: undefined,
    title: "",
    description: "",
    settings: undefined,
    messageCount: 0,
    status: 0,
    participantIds: [],
  };
}

export const Conversation = {
  encode(message: Conversation, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.metadata !== undefined) {
      ResourceMetadata.encode(message.metadata, writer.uint32(10).fork()).ldelim();
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.settings !== undefined) {
      ConversationSettings.encode(message.settings, writer.uint32(34).fork()).ldelim();
    }
    if (message.messageCount !== 0) {
      writer.uint32(40).int32(message.messageCount);
    }
    if (message.status !== 0) {
      writer.uint32(48).int32(message.status);
    }
    for (const v of message.participantIds) {
      writer.uint32(58).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Conversation {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metadata = ResourceMetadata.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.settings = ConversationSettings.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.messageCount = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.participantIds.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Conversation {
    return {
      metadata: isSet(object.metadata) ? ResourceMetadata.fromJSON(object.metadata) : undefined,
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      settings: isSet(object.settings) ? ConversationSettings.fromJSON(object.settings) : undefined,
      messageCount: isSet(object.messageCount) ? globalThis.Number(object.messageCount) : 0,
      status: isSet(object.status) ? conversationStatusFromJSON(object.status) : 0,
      participantIds: globalThis.Array.isArray(object?.participantIds)
        ? object.participantIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: Conversation): unknown {
    const obj: any = {};
    if (message.metadata !== undefined) {
      obj.metadata = ResourceMetadata.toJSON(message.metadata);
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.settings !== undefined) {
      obj.settings = ConversationSettings.toJSON(message.settings);
    }
    if (message.messageCount !== 0) {
      obj.messageCount = Math.round(message.messageCount);
    }
    if (message.status !== 0) {
      obj.status = conversationStatusToJSON(message.status);
    }
    if (message.participantIds?.length) {
      obj.participantIds = message.participantIds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Conversation>, I>>(base?: I): Conversation {
    return Conversation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Conversation>, I>>(object: I): Conversation {
    const message = createBaseConversation();
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? ResourceMetadata.fromPartial(object.metadata)
      : undefined;
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.settings = (object.settings !== undefined && object.settings !== null)
      ? ConversationSettings.fromPartial(object.settings)
      : undefined;
    message.messageCount = object.messageCount ?? 0;
    message.status = object.status ?? 0;
    message.participantIds = object.participantIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseConversationSettings(): ConversationSettings {
  return {
    model: "",
    temperature: 0,
    maxTokens: 0,
    stopSequences: [],
    includeContext: false,
    contextWindowSize: 0,
    enableTools: false,
    availableTools: [],
  };
}

export const ConversationSettings = {
  encode(message: ConversationSettings, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.model !== "") {
      writer.uint32(10).string(message.model);
    }
    if (message.temperature !== 0) {
      writer.uint32(21).float(message.temperature);
    }
    if (message.maxTokens !== 0) {
      writer.uint32(24).int32(message.maxTokens);
    }
    for (const v of message.stopSequences) {
      writer.uint32(34).string(v!);
    }
    if (message.includeContext !== false) {
      writer.uint32(40).bool(message.includeContext);
    }
    if (message.contextWindowSize !== 0) {
      writer.uint32(48).int32(message.contextWindowSize);
    }
    if (message.enableTools !== false) {
      writer.uint32(56).bool(message.enableTools);
    }
    for (const v of message.availableTools) {
      writer.uint32(66).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ConversationSettings {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversationSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.model = reader.string();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.temperature = reader.float();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.maxTokens = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.stopSequences.push(reader.string());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.includeContext = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.contextWindowSize = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.enableTools = reader.bool();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.availableTools.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConversationSettings {
    return {
      model: isSet(object.model) ? globalThis.String(object.model) : "",
      temperature: isSet(object.temperature) ? globalThis.Number(object.temperature) : 0,
      maxTokens: isSet(object.maxTokens) ? globalThis.Number(object.maxTokens) : 0,
      stopSequences: globalThis.Array.isArray(object?.stopSequences)
        ? object.stopSequences.map((e: any) => globalThis.String(e))
        : [],
      includeContext: isSet(object.includeContext) ? globalThis.Boolean(object.includeContext) : false,
      contextWindowSize: isSet(object.contextWindowSize) ? globalThis.Number(object.contextWindowSize) : 0,
      enableTools: isSet(object.enableTools) ? globalThis.Boolean(object.enableTools) : false,
      availableTools: globalThis.Array.isArray(object?.availableTools)
        ? object.availableTools.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ConversationSettings): unknown {
    const obj: any = {};
    if (message.model !== "") {
      obj.model = message.model;
    }
    if (message.temperature !== 0) {
      obj.temperature = message.temperature;
    }
    if (message.maxTokens !== 0) {
      obj.maxTokens = Math.round(message.maxTokens);
    }
    if (message.stopSequences?.length) {
      obj.stopSequences = message.stopSequences;
    }
    if (message.includeContext !== false) {
      obj.includeContext = message.includeContext;
    }
    if (message.contextWindowSize !== 0) {
      obj.contextWindowSize = Math.round(message.contextWindowSize);
    }
    if (message.enableTools !== false) {
      obj.enableTools = message.enableTools;
    }
    if (message.availableTools?.length) {
      obj.availableTools = message.availableTools;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConversationSettings>, I>>(base?: I): ConversationSettings {
    return ConversationSettings.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConversationSettings>, I>>(object: I): ConversationSettings {
    const message = createBaseConversationSettings();
    message.model = object.model ?? "";
    message.temperature = object.temperature ?? 0;
    message.maxTokens = object.maxTokens ?? 0;
    message.stopSequences = object.stopSequences?.map((e) => e) || [];
    message.includeContext = object.includeContext ?? false;
    message.contextWindowSize = object.contextWindowSize ?? 0;
    message.enableTools = object.enableTools ?? false;
    message.availableTools = object.availableTools?.map((e) => e) || [];
    return message;
  },
};

function createBaseChatMessage(): ChatMessage {
  return {
    metadata: undefined,
    conversationId: "",
    role: 0,
    content: "",
    attachments: [],
    status: 0,
    parentMessageId: "",
    usage: undefined,
    toolCalls: [],
  };
}

export const ChatMessage = {
  encode(message: ChatMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.metadata !== undefined) {
      ResourceMetadata.encode(message.metadata, writer.uint32(10).fork()).ldelim();
    }
    if (message.conversationId !== "") {
      writer.uint32(18).string(message.conversationId);
    }
    if (message.role !== 0) {
      writer.uint32(24).int32(message.role);
    }
    if (message.content !== "") {
      writer.uint32(34).string(message.content);
    }
    for (const v of message.attachments) {
      Attachment.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    if (message.status !== 0) {
      writer.uint32(48).int32(message.status);
    }
    if (message.parentMessageId !== "") {
      writer.uint32(58).string(message.parentMessageId);
    }
    if (message.usage !== undefined) {
      UsageMetrics.encode(message.usage, writer.uint32(66).fork()).ldelim();
    }
    for (const v of message.toolCalls) {
      ToolCall.encode(v!, writer.uint32(74).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChatMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChatMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metadata = ResourceMetadata.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.conversationId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.role = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.content = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.attachments.push(Attachment.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.parentMessageId = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.usage = UsageMetrics.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.toolCalls.push(ToolCall.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChatMessage {
    return {
      metadata: isSet(object.metadata) ? ResourceMetadata.fromJSON(object.metadata) : undefined,
      conversationId: isSet(object.conversationId) ? globalThis.String(object.conversationId) : "",
      role: isSet(object.role) ? messageRoleFromJSON(object.role) : 0,
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      attachments: globalThis.Array.isArray(object?.attachments)
        ? object.attachments.map((e: any) => Attachment.fromJSON(e))
        : [],
      status: isSet(object.status) ? messageStatusFromJSON(object.status) : 0,
      parentMessageId: isSet(object.parentMessageId) ? globalThis.String(object.parentMessageId) : "",
      usage: isSet(object.usage) ? UsageMetrics.fromJSON(object.usage) : undefined,
      toolCalls: globalThis.Array.isArray(object?.toolCalls)
        ? object.toolCalls.map((e: any) => ToolCall.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ChatMessage): unknown {
    const obj: any = {};
    if (message.metadata !== undefined) {
      obj.metadata = ResourceMetadata.toJSON(message.metadata);
    }
    if (message.conversationId !== "") {
      obj.conversationId = message.conversationId;
    }
    if (message.role !== 0) {
      obj.role = messageRoleToJSON(message.role);
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.attachments?.length) {
      obj.attachments = message.attachments.map((e) => Attachment.toJSON(e));
    }
    if (message.status !== 0) {
      obj.status = messageStatusToJSON(message.status);
    }
    if (message.parentMessageId !== "") {
      obj.parentMessageId = message.parentMessageId;
    }
    if (message.usage !== undefined) {
      obj.usage = UsageMetrics.toJSON(message.usage);
    }
    if (message.toolCalls?.length) {
      obj.toolCalls = message.toolCalls.map((e) => ToolCall.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChatMessage>, I>>(base?: I): ChatMessage {
    return ChatMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChatMessage>, I>>(object: I): ChatMessage {
    const message = createBaseChatMessage();
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? ResourceMetadata.fromPartial(object.metadata)
      : undefined;
    message.conversationId = object.conversationId ?? "";
    message.role = object.role ?? 0;
    message.content = object.content ?? "";
    message.attachments = object.attachments?.map((e) => Attachment.fromPartial(e)) || [];
    message.status = object.status ?? 0;
    message.parentMessageId = object.parentMessageId ?? "";
    message.usage = (object.usage !== undefined && object.usage !== null)
      ? UsageMetrics.fromPartial(object.usage)
      : undefined;
    message.toolCalls = object.toolCalls?.map((e) => ToolCall.fromPartial(e)) || [];
    return message;
  },
};

function createBaseToolCall(): ToolCall {
  return { toolCallId: "", toolName: "", arguments: "", result: "", status: 0 };
}

export const ToolCall = {
  encode(message: ToolCall, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.toolCallId !== "") {
      writer.uint32(10).string(message.toolCallId);
    }
    if (message.toolName !== "") {
      writer.uint32(18).string(message.toolName);
    }
    if (message.arguments !== "") {
      writer.uint32(26).string(message.arguments);
    }
    if (message.result !== "") {
      writer.uint32(34).string(message.result);
    }
    if (message.status !== 0) {
      writer.uint32(40).int32(message.status);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ToolCall {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToolCall();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.toolCallId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.toolName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.arguments = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.result = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ToolCall {
    return {
      toolCallId: isSet(object.toolCallId) ? globalThis.String(object.toolCallId) : "",
      toolName: isSet(object.toolName) ? globalThis.String(object.toolName) : "",
      arguments: isSet(object.arguments) ? globalThis.String(object.arguments) : "",
      result: isSet(object.result) ? globalThis.String(object.result) : "",
      status: isSet(object.status) ? toolCallStatusFromJSON(object.status) : 0,
    };
  },

  toJSON(message: ToolCall): unknown {
    const obj: any = {};
    if (message.toolCallId !== "") {
      obj.toolCallId = message.toolCallId;
    }
    if (message.toolName !== "") {
      obj.toolName = message.toolName;
    }
    if (message.arguments !== "") {
      obj.arguments = message.arguments;
    }
    if (message.result !== "") {
      obj.result = message.result;
    }
    if (message.status !== 0) {
      obj.status = toolCallStatusToJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ToolCall>, I>>(base?: I): ToolCall {
    return ToolCall.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ToolCall>, I>>(object: I): ToolCall {
    const message = createBaseToolCall();
    message.toolCallId = object.toolCallId ?? "";
    message.toolName = object.toolName ?? "";
    message.arguments = object.arguments ?? "";
    message.result = object.result ?? "";
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseCreateConversationRequest(): CreateConversationRequest {
  return { teamId: "", namespaceId: "", title: "", description: "", settings: undefined };
}

export const CreateConversationRequest = {
  encode(message: CreateConversationRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.teamId !== "") {
      writer.uint32(10).string(message.teamId);
    }
    if (message.namespaceId !== "") {
      writer.uint32(18).string(message.namespaceId);
    }
    if (message.title !== "") {
      writer.uint32(26).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.settings !== undefined) {
      ConversationSettings.encode(message.settings, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateConversationRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateConversationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.teamId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.namespaceId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.title = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.settings = ConversationSettings.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateConversationRequest {
    return {
      teamId: isSet(object.teamId) ? globalThis.String(object.teamId) : "",
      namespaceId: isSet(object.namespaceId) ? globalThis.String(object.namespaceId) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      settings: isSet(object.settings) ? ConversationSettings.fromJSON(object.settings) : undefined,
    };
  },

  toJSON(message: CreateConversationRequest): unknown {
    const obj: any = {};
    if (message.teamId !== "") {
      obj.teamId = message.teamId;
    }
    if (message.namespaceId !== "") {
      obj.namespaceId = message.namespaceId;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.settings !== undefined) {
      obj.settings = ConversationSettings.toJSON(message.settings);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateConversationRequest>, I>>(base?: I): CreateConversationRequest {
    return CreateConversationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateConversationRequest>, I>>(object: I): CreateConversationRequest {
    const message = createBaseCreateConversationRequest();
    message.teamId = object.teamId ?? "";
    message.namespaceId = object.namespaceId ?? "";
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.settings = (object.settings !== undefined && object.settings !== null)
      ? ConversationSettings.fromPartial(object.settings)
      : undefined;
    return message;
  },
};

function createBaseCreateConversationResponse(): CreateConversationResponse {
  return { response: undefined, conversation: undefined };
}

export const CreateConversationResponse = {
  encode(message: CreateConversationResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.response !== undefined) {
      StandardResponse.encode(message.response, writer.uint32(10).fork()).ldelim();
    }
    if (message.conversation !== undefined) {
      Conversation.encode(message.conversation, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateConversationResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateConversationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.response = StandardResponse.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.conversation = Conversation.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateConversationResponse {
    return {
      response: isSet(object.response) ? StandardResponse.fromJSON(object.response) : undefined,
      conversation: isSet(object.conversation) ? Conversation.fromJSON(object.conversation) : undefined,
    };
  },

  toJSON(message: CreateConversationResponse): unknown {
    const obj: any = {};
    if (message.response !== undefined) {
      obj.response = StandardResponse.toJSON(message.response);
    }
    if (message.conversation !== undefined) {
      obj.conversation = Conversation.toJSON(message.conversation);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateConversationResponse>, I>>(base?: I): CreateConversationResponse {
    return CreateConversationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateConversationResponse>, I>>(object: I): CreateConversationResponse {
    const message = createBaseCreateConversationResponse();
    message.response = (object.response !== undefined && object.response !== null)
      ? StandardResponse.fromPartial(object.response)
      : undefined;
    message.conversation = (object.conversation !== undefined && object.conversation !== null)
      ? Conversation.fromPartial(object.conversation)
      : undefined;
    return message;
  },
};

function createBaseGetConversationRequest(): GetConversationRequest {
  return { conversationId: "", includeMessages: false, messageLimit: 0 };
}

export const GetConversationRequest = {
  encode(message: GetConversationRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.conversationId !== "") {
      writer.uint32(10).string(message.conversationId);
    }
    if (message.includeMessages !== false) {
      writer.uint32(16).bool(message.includeMessages);
    }
    if (message.messageLimit !== 0) {
      writer.uint32(24).int32(message.messageLimit);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetConversationRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConversationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.conversationId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.includeMessages = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.messageLimit = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetConversationRequest {
    return {
      conversationId: isSet(object.conversationId) ? globalThis.String(object.conversationId) : "",
      includeMessages: isSet(object.includeMessages) ? globalThis.Boolean(object.includeMessages) : false,
      messageLimit: isSet(object.messageLimit) ? globalThis.Number(object.messageLimit) : 0,
    };
  },

  toJSON(message: GetConversationRequest): unknown {
    const obj: any = {};
    if (message.conversationId !== "") {
      obj.conversationId = message.conversationId;
    }
    if (message.includeMessages !== false) {
      obj.includeMessages = message.includeMessages;
    }
    if (message.messageLimit !== 0) {
      obj.messageLimit = Math.round(message.messageLimit);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetConversationRequest>, I>>(base?: I): GetConversationRequest {
    return GetConversationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetConversationRequest>, I>>(object: I): GetConversationRequest {
    const message = createBaseGetConversationRequest();
    message.conversationId = object.conversationId ?? "";
    message.includeMessages = object.includeMessages ?? false;
    message.messageLimit = object.messageLimit ?? 0;
    return message;
  },
};

function createBaseGetConversationResponse(): GetConversationResponse {
  return { response: undefined, conversation: undefined, messages: [] };
}

export const GetConversationResponse = {
  encode(message: GetConversationResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.response !== undefined) {
      StandardResponse.encode(message.response, writer.uint32(10).fork()).ldelim();
    }
    if (message.conversation !== undefined) {
      Conversation.encode(message.conversation, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.messages) {
      ChatMessage.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetConversationResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConversationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.response = StandardResponse.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.conversation = Conversation.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.messages.push(ChatMessage.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetConversationResponse {
    return {
      response: isSet(object.response) ? StandardResponse.fromJSON(object.response) : undefined,
      conversation: isSet(object.conversation) ? Conversation.fromJSON(object.conversation) : undefined,
      messages: globalThis.Array.isArray(object?.messages)
        ? object.messages.map((e: any) => ChatMessage.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetConversationResponse): unknown {
    const obj: any = {};
    if (message.response !== undefined) {
      obj.response = StandardResponse.toJSON(message.response);
    }
    if (message.conversation !== undefined) {
      obj.conversation = Conversation.toJSON(message.conversation);
    }
    if (message.messages?.length) {
      obj.messages = message.messages.map((e) => ChatMessage.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetConversationResponse>, I>>(base?: I): GetConversationResponse {
    return GetConversationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetConversationResponse>, I>>(object: I): GetConversationResponse {
    const message = createBaseGetConversationResponse();
    message.response = (object.response !== undefined && object.response !== null)
      ? StandardResponse.fromPartial(object.response)
      : undefined;
    message.conversation = (object.conversation !== undefined && object.conversation !== null)
      ? Conversation.fromPartial(object.conversation)
      : undefined;
    message.messages = object.messages?.map((e) => ChatMessage.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListConversationsRequest(): ListConversationsRequest {
  return { teamId: "", namespaceId: "", status: 0, pagination: undefined, filters: [] };
}

export const ListConversationsRequest = {
  encode(message: ListConversationsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.teamId !== "") {
      writer.uint32(10).string(message.teamId);
    }
    if (message.namespaceId !== "") {
      writer.uint32(18).string(message.namespaceId);
    }
    if (message.status !== 0) {
      writer.uint32(24).int32(message.status);
    }
    if (message.pagination !== undefined) {
      PaginationRequest.encode(message.pagination, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.filters) {
      Filter.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListConversationsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListConversationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.teamId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.namespaceId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pagination = PaginationRequest.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.filters.push(Filter.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListConversationsRequest {
    return {
      teamId: isSet(object.teamId) ? globalThis.String(object.teamId) : "",
      namespaceId: isSet(object.namespaceId) ? globalThis.String(object.namespaceId) : "",
      status: isSet(object.status) ? conversationStatusFromJSON(object.status) : 0,
      pagination: isSet(object.pagination) ? PaginationRequest.fromJSON(object.pagination) : undefined,
      filters: globalThis.Array.isArray(object?.filters) ? object.filters.map((e: any) => Filter.fromJSON(e)) : [],
    };
  },

  toJSON(message: ListConversationsRequest): unknown {
    const obj: any = {};
    if (message.teamId !== "") {
      obj.teamId = message.teamId;
    }
    if (message.namespaceId !== "") {
      obj.namespaceId = message.namespaceId;
    }
    if (message.status !== 0) {
      obj.status = conversationStatusToJSON(message.status);
    }
    if (message.pagination !== undefined) {
      obj.pagination = PaginationRequest.toJSON(message.pagination);
    }
    if (message.filters?.length) {
      obj.filters = message.filters.map((e) => Filter.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListConversationsRequest>, I>>(base?: I): ListConversationsRequest {
    return ListConversationsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListConversationsRequest>, I>>(object: I): ListConversationsRequest {
    const message = createBaseListConversationsRequest();
    message.teamId = object.teamId ?? "";
    message.namespaceId = object.namespaceId ?? "";
    message.status = object.status ?? 0;
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PaginationRequest.fromPartial(object.pagination)
      : undefined;
    message.filters = object.filters?.map((e) => Filter.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListConversationsResponse(): ListConversationsResponse {
  return { response: undefined, conversations: [], pagination: undefined };
}

export const ListConversationsResponse = {
  encode(message: ListConversationsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.response !== undefined) {
      StandardResponse.encode(message.response, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.conversations) {
      Conversation.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.pagination !== undefined) {
      PaginationResponse.encode(message.pagination, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListConversationsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListConversationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.response = StandardResponse.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.conversations.push(Conversation.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pagination = PaginationResponse.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListConversationsResponse {
    return {
      response: isSet(object.response) ? StandardResponse.fromJSON(object.response) : undefined,
      conversations: globalThis.Array.isArray(object?.conversations)
        ? object.conversations.map((e: any) => Conversation.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PaginationResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListConversationsResponse): unknown {
    const obj: any = {};
    if (message.response !== undefined) {
      obj.response = StandardResponse.toJSON(message.response);
    }
    if (message.conversations?.length) {
      obj.conversations = message.conversations.map((e) => Conversation.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PaginationResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListConversationsResponse>, I>>(base?: I): ListConversationsResponse {
    return ListConversationsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListConversationsResponse>, I>>(object: I): ListConversationsResponse {
    const message = createBaseListConversationsResponse();
    message.response = (object.response !== undefined && object.response !== null)
      ? StandardResponse.fromPartial(object.response)
      : undefined;
    message.conversations = object.conversations?.map((e) => Conversation.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PaginationResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseSendMessageRequest(): SendMessageRequest {
  return { conversationId: "", role: 0, content: "", attachments: [], parentMessageId: "" };
}

export const SendMessageRequest = {
  encode(message: SendMessageRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.conversationId !== "") {
      writer.uint32(10).string(message.conversationId);
    }
    if (message.role !== 0) {
      writer.uint32(16).int32(message.role);
    }
    if (message.content !== "") {
      writer.uint32(26).string(message.content);
    }
    for (const v of message.attachments) {
      Attachment.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    if (message.parentMessageId !== "") {
      writer.uint32(42).string(message.parentMessageId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SendMessageRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendMessageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.conversationId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.role = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.content = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.attachments.push(Attachment.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.parentMessageId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendMessageRequest {
    return {
      conversationId: isSet(object.conversationId) ? globalThis.String(object.conversationId) : "",
      role: isSet(object.role) ? messageRoleFromJSON(object.role) : 0,
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      attachments: globalThis.Array.isArray(object?.attachments)
        ? object.attachments.map((e: any) => Attachment.fromJSON(e))
        : [],
      parentMessageId: isSet(object.parentMessageId) ? globalThis.String(object.parentMessageId) : "",
    };
  },

  toJSON(message: SendMessageRequest): unknown {
    const obj: any = {};
    if (message.conversationId !== "") {
      obj.conversationId = message.conversationId;
    }
    if (message.role !== 0) {
      obj.role = messageRoleToJSON(message.role);
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.attachments?.length) {
      obj.attachments = message.attachments.map((e) => Attachment.toJSON(e));
    }
    if (message.parentMessageId !== "") {
      obj.parentMessageId = message.parentMessageId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendMessageRequest>, I>>(base?: I): SendMessageRequest {
    return SendMessageRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendMessageRequest>, I>>(object: I): SendMessageRequest {
    const message = createBaseSendMessageRequest();
    message.conversationId = object.conversationId ?? "";
    message.role = object.role ?? 0;
    message.content = object.content ?? "";
    message.attachments = object.attachments?.map((e) => Attachment.fromPartial(e)) || [];
    message.parentMessageId = object.parentMessageId ?? "";
    return message;
  },
};

function createBaseSendMessageResponse(): SendMessageResponse {
  return { response: undefined, message: undefined };
}

export const SendMessageResponse = {
  encode(message: SendMessageResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.response !== undefined) {
      StandardResponse.encode(message.response, writer.uint32(10).fork()).ldelim();
    }
    if (message.message !== undefined) {
      ChatMessage.encode(message.message, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SendMessageResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendMessageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.response = StandardResponse.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = ChatMessage.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendMessageResponse {
    return {
      response: isSet(object.response) ? StandardResponse.fromJSON(object.response) : undefined,
      message: isSet(object.message) ? ChatMessage.fromJSON(object.message) : undefined,
    };
  },

  toJSON(message: SendMessageResponse): unknown {
    const obj: any = {};
    if (message.response !== undefined) {
      obj.response = StandardResponse.toJSON(message.response);
    }
    if (message.message !== undefined) {
      obj.message = ChatMessage.toJSON(message.message);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendMessageResponse>, I>>(base?: I): SendMessageResponse {
    return SendMessageResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendMessageResponse>, I>>(object: I): SendMessageResponse {
    const message = createBaseSendMessageResponse();
    message.response = (object.response !== undefined && object.response !== null)
      ? StandardResponse.fromPartial(object.response)
      : undefined;
    message.message = (object.message !== undefined && object.message !== null)
      ? ChatMessage.fromPartial(object.message)
      : undefined;
    return message;
  },
};

function createBaseStreamChatRequest(): StreamChatRequest {
  return { conversationId: "", content: "", attachments: [], options: undefined };
}

export const StreamChatRequest = {
  encode(message: StreamChatRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.conversationId !== "") {
      writer.uint32(10).string(message.conversationId);
    }
    if (message.content !== "") {
      writer.uint32(18).string(message.content);
    }
    for (const v of message.attachments) {
      Attachment.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.options !== undefined) {
      StreamOptions.encode(message.options, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamChatRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamChatRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.conversationId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.content = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.attachments.push(Attachment.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.options = StreamOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamChatRequest {
    return {
      conversationId: isSet(object.conversationId) ? globalThis.String(object.conversationId) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      attachments: globalThis.Array.isArray(object?.attachments)
        ? object.attachments.map((e: any) => Attachment.fromJSON(e))
        : [],
      options: isSet(object.options) ? StreamOptions.fromJSON(object.options) : undefined,
    };
  },

  toJSON(message: StreamChatRequest): unknown {
    const obj: any = {};
    if (message.conversationId !== "") {
      obj.conversationId = message.conversationId;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.attachments?.length) {
      obj.attachments = message.attachments.map((e) => Attachment.toJSON(e));
    }
    if (message.options !== undefined) {
      obj.options = StreamOptions.toJSON(message.options);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamChatRequest>, I>>(base?: I): StreamChatRequest {
    return StreamChatRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamChatRequest>, I>>(object: I): StreamChatRequest {
    const message = createBaseStreamChatRequest();
    message.conversationId = object.conversationId ?? "";
    message.content = object.content ?? "";
    message.attachments = object.attachments?.map((e) => Attachment.fromPartial(e)) || [];
    message.options = (object.options !== undefined && object.options !== null)
      ? StreamOptions.fromPartial(object.options)
      : undefined;
    return message;
  },
};

function createBaseStreamOptions(): StreamOptions {
  return { model: "", maxTokens: 0, temperature: 0, includeContext: false, enableTools: false };
}

export const StreamOptions = {
  encode(message: StreamOptions, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.model !== "") {
      writer.uint32(10).string(message.model);
    }
    if (message.maxTokens !== 0) {
      writer.uint32(16).int32(message.maxTokens);
    }
    if (message.temperature !== 0) {
      writer.uint32(29).float(message.temperature);
    }
    if (message.includeContext !== false) {
      writer.uint32(32).bool(message.includeContext);
    }
    if (message.enableTools !== false) {
      writer.uint32(40).bool(message.enableTools);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamOptions {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.model = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.maxTokens = reader.int32();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.temperature = reader.float();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.includeContext = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.enableTools = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamOptions {
    return {
      model: isSet(object.model) ? globalThis.String(object.model) : "",
      maxTokens: isSet(object.maxTokens) ? globalThis.Number(object.maxTokens) : 0,
      temperature: isSet(object.temperature) ? globalThis.Number(object.temperature) : 0,
      includeContext: isSet(object.includeContext) ? globalThis.Boolean(object.includeContext) : false,
      enableTools: isSet(object.enableTools) ? globalThis.Boolean(object.enableTools) : false,
    };
  },

  toJSON(message: StreamOptions): unknown {
    const obj: any = {};
    if (message.model !== "") {
      obj.model = message.model;
    }
    if (message.maxTokens !== 0) {
      obj.maxTokens = Math.round(message.maxTokens);
    }
    if (message.temperature !== 0) {
      obj.temperature = message.temperature;
    }
    if (message.includeContext !== false) {
      obj.includeContext = message.includeContext;
    }
    if (message.enableTools !== false) {
      obj.enableTools = message.enableTools;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamOptions>, I>>(base?: I): StreamOptions {
    return StreamOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamOptions>, I>>(object: I): StreamOptions {
    const message = createBaseStreamOptions();
    message.model = object.model ?? "";
    message.maxTokens = object.maxTokens ?? 0;
    message.temperature = object.temperature ?? 0;
    message.includeContext = object.includeContext ?? false;
    message.enableTools = object.enableTools ?? false;
    return message;
  },
};

function createBaseChatChunkPayload(): ChatChunkPayload {
  return { messageId: "", conversationId: "", role: 0, content: "", toolCalls: [] };
}

export const ChatChunkPayload = {
  encode(message: ChatChunkPayload, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.messageId !== "") {
      writer.uint32(10).string(message.messageId);
    }
    if (message.conversationId !== "") {
      writer.uint32(18).string(message.conversationId);
    }
    if (message.role !== 0) {
      writer.uint32(24).int32(message.role);
    }
    if (message.content !== "") {
      writer.uint32(34).string(message.content);
    }
    for (const v of message.toolCalls) {
      ToolCall.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChatChunkPayload {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChatChunkPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.messageId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.conversationId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.role = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.content = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.toolCalls.push(ToolCall.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChatChunkPayload {
    return {
      messageId: isSet(object.messageId) ? globalThis.String(object.messageId) : "",
      conversationId: isSet(object.conversationId) ? globalThis.String(object.conversationId) : "",
      role: isSet(object.role) ? messageRoleFromJSON(object.role) : 0,
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      toolCalls: globalThis.Array.isArray(object?.toolCalls)
        ? object.toolCalls.map((e: any) => ToolCall.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ChatChunkPayload): unknown {
    const obj: any = {};
    if (message.messageId !== "") {
      obj.messageId = message.messageId;
    }
    if (message.conversationId !== "") {
      obj.conversationId = message.conversationId;
    }
    if (message.role !== 0) {
      obj.role = messageRoleToJSON(message.role);
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.toolCalls?.length) {
      obj.toolCalls = message.toolCalls.map((e) => ToolCall.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChatChunkPayload>, I>>(base?: I): ChatChunkPayload {
    return ChatChunkPayload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChatChunkPayload>, I>>(object: I): ChatChunkPayload {
    const message = createBaseChatChunkPayload();
    message.messageId = object.messageId ?? "";
    message.conversationId = object.conversationId ?? "";
    message.role = object.role ?? 0;
    message.content = object.content ?? "";
    message.toolCalls = object.toolCalls?.map((e) => ToolCall.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSubscribeRequest(): SubscribeRequest {
  return { conversationId: "", eventTypes: [] };
}

export const SubscribeRequest = {
  encode(message: SubscribeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.conversationId !== "") {
      writer.uint32(10).string(message.conversationId);
    }
    writer.uint32(18).fork();
    for (const v of message.eventTypes) {
      writer.int32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubscribeRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscribeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.conversationId = reader.string();
          continue;
        case 2:
          if (tag === 16) {
            message.eventTypes.push(reader.int32() as any);

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.eventTypes.push(reader.int32() as any);
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscribeRequest {
    return {
      conversationId: isSet(object.conversationId) ? globalThis.String(object.conversationId) : "",
      eventTypes: globalThis.Array.isArray(object?.eventTypes)
        ? object.eventTypes.map((e: any) => updateTypeFromJSON(e))
        : [],
    };
  },

  toJSON(message: SubscribeRequest): unknown {
    const obj: any = {};
    if (message.conversationId !== "") {
      obj.conversationId = message.conversationId;
    }
    if (message.eventTypes?.length) {
      obj.eventTypes = message.eventTypes.map((e) => updateTypeToJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubscribeRequest>, I>>(base?: I): SubscribeRequest {
    return SubscribeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubscribeRequest>, I>>(object: I): SubscribeRequest {
    const message = createBaseSubscribeRequest();
    message.conversationId = object.conversationId ?? "";
    message.eventTypes = object.eventTypes?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetMessagesRequest(): GetMessagesRequest {
  return { conversationId: "", pagination: undefined, roleFilter: 0, filters: [] };
}

export const GetMessagesRequest = {
  encode(message: GetMessagesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.conversationId !== "") {
      writer.uint32(10).string(message.conversationId);
    }
    if (message.pagination !== undefined) {
      PaginationRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
    }
    if (message.roleFilter !== 0) {
      writer.uint32(24).int32(message.roleFilter);
    }
    for (const v of message.filters) {
      Filter.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetMessagesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMessagesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.conversationId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationRequest.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.roleFilter = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filters.push(Filter.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetMessagesRequest {
    return {
      conversationId: isSet(object.conversationId) ? globalThis.String(object.conversationId) : "",
      pagination: isSet(object.pagination) ? PaginationRequest.fromJSON(object.pagination) : undefined,
      roleFilter: isSet(object.roleFilter) ? messageRoleFromJSON(object.roleFilter) : 0,
      filters: globalThis.Array.isArray(object?.filters) ? object.filters.map((e: any) => Filter.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetMessagesRequest): unknown {
    const obj: any = {};
    if (message.conversationId !== "") {
      obj.conversationId = message.conversationId;
    }
    if (message.pagination !== undefined) {
      obj.pagination = PaginationRequest.toJSON(message.pagination);
    }
    if (message.roleFilter !== 0) {
      obj.roleFilter = messageRoleToJSON(message.roleFilter);
    }
    if (message.filters?.length) {
      obj.filters = message.filters.map((e) => Filter.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetMessagesRequest>, I>>(base?: I): GetMessagesRequest {
    return GetMessagesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetMessagesRequest>, I>>(object: I): GetMessagesRequest {
    const message = createBaseGetMessagesRequest();
    message.conversationId = object.conversationId ?? "";
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PaginationRequest.fromPartial(object.pagination)
      : undefined;
    message.roleFilter = object.roleFilter ?? 0;
    message.filters = object.filters?.map((e) => Filter.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetMessagesResponse(): GetMessagesResponse {
  return { response: undefined, messages: [], pagination: undefined };
}

export const GetMessagesResponse = {
  encode(message: GetMessagesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.response !== undefined) {
      StandardResponse.encode(message.response, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.messages) {
      ChatMessage.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.pagination !== undefined) {
      PaginationResponse.encode(message.pagination, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetMessagesResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMessagesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.response = StandardResponse.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.messages.push(ChatMessage.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pagination = PaginationResponse.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetMessagesResponse {
    return {
      response: isSet(object.response) ? StandardResponse.fromJSON(object.response) : undefined,
      messages: globalThis.Array.isArray(object?.messages)
        ? object.messages.map((e: any) => ChatMessage.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PaginationResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: GetMessagesResponse): unknown {
    const obj: any = {};
    if (message.response !== undefined) {
      obj.response = StandardResponse.toJSON(message.response);
    }
    if (message.messages?.length) {
      obj.messages = message.messages.map((e) => ChatMessage.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PaginationResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetMessagesResponse>, I>>(base?: I): GetMessagesResponse {
    return GetMessagesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetMessagesResponse>, I>>(object: I): GetMessagesResponse {
    const message = createBaseGetMessagesResponse();
    message.response = (object.response !== undefined && object.response !== null)
      ? StandardResponse.fromPartial(object.response)
      : undefined;
    message.messages = object.messages?.map((e) => ChatMessage.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PaginationResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseUpdateConversationRequest(): UpdateConversationRequest {
  return { conversationId: "", title: "", description: "", settings: undefined };
}

export const UpdateConversationRequest = {
  encode(message: UpdateConversationRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.conversationId !== "") {
      writer.uint32(10).string(message.conversationId);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.settings !== undefined) {
      ConversationSettings.encode(message.settings, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateConversationRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateConversationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.conversationId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.settings = ConversationSettings.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateConversationRequest {
    return {
      conversationId: isSet(object.conversationId) ? globalThis.String(object.conversationId) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      settings: isSet(object.settings) ? ConversationSettings.fromJSON(object.settings) : undefined,
    };
  },

  toJSON(message: UpdateConversationRequest): unknown {
    const obj: any = {};
    if (message.conversationId !== "") {
      obj.conversationId = message.conversationId;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.settings !== undefined) {
      obj.settings = ConversationSettings.toJSON(message.settings);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateConversationRequest>, I>>(base?: I): UpdateConversationRequest {
    return UpdateConversationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateConversationRequest>, I>>(object: I): UpdateConversationRequest {
    const message = createBaseUpdateConversationRequest();
    message.conversationId = object.conversationId ?? "";
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.settings = (object.settings !== undefined && object.settings !== null)
      ? ConversationSettings.fromPartial(object.settings)
      : undefined;
    return message;
  },
};

function createBaseUpdateConversationResponse(): UpdateConversationResponse {
  return { response: undefined, conversation: undefined };
}

export const UpdateConversationResponse = {
  encode(message: UpdateConversationResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.response !== undefined) {
      StandardResponse.encode(message.response, writer.uint32(10).fork()).ldelim();
    }
    if (message.conversation !== undefined) {
      Conversation.encode(message.conversation, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateConversationResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateConversationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.response = StandardResponse.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.conversation = Conversation.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateConversationResponse {
    return {
      response: isSet(object.response) ? StandardResponse.fromJSON(object.response) : undefined,
      conversation: isSet(object.conversation) ? Conversation.fromJSON(object.conversation) : undefined,
    };
  },

  toJSON(message: UpdateConversationResponse): unknown {
    const obj: any = {};
    if (message.response !== undefined) {
      obj.response = StandardResponse.toJSON(message.response);
    }
    if (message.conversation !== undefined) {
      obj.conversation = Conversation.toJSON(message.conversation);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateConversationResponse>, I>>(base?: I): UpdateConversationResponse {
    return UpdateConversationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateConversationResponse>, I>>(object: I): UpdateConversationResponse {
    const message = createBaseUpdateConversationResponse();
    message.response = (object.response !== undefined && object.response !== null)
      ? StandardResponse.fromPartial(object.response)
      : undefined;
    message.conversation = (object.conversation !== undefined && object.conversation !== null)
      ? Conversation.fromPartial(object.conversation)
      : undefined;
    return message;
  },
};

function createBaseUpdateMessageRequest(): UpdateMessageRequest {
  return { messageId: "", content: "" };
}

export const UpdateMessageRequest = {
  encode(message: UpdateMessageRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.messageId !== "") {
      writer.uint32(10).string(message.messageId);
    }
    if (message.content !== "") {
      writer.uint32(18).string(message.content);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateMessageRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateMessageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.messageId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.content = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateMessageRequest {
    return {
      messageId: isSet(object.messageId) ? globalThis.String(object.messageId) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
    };
  },

  toJSON(message: UpdateMessageRequest): unknown {
    const obj: any = {};
    if (message.messageId !== "") {
      obj.messageId = message.messageId;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateMessageRequest>, I>>(base?: I): UpdateMessageRequest {
    return UpdateMessageRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateMessageRequest>, I>>(object: I): UpdateMessageRequest {
    const message = createBaseUpdateMessageRequest();
    message.messageId = object.messageId ?? "";
    message.content = object.content ?? "";
    return message;
  },
};

function createBaseUpdateMessageResponse(): UpdateMessageResponse {
  return { response: undefined, message: undefined };
}

export const UpdateMessageResponse = {
  encode(message: UpdateMessageResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.response !== undefined) {
      StandardResponse.encode(message.response, writer.uint32(10).fork()).ldelim();
    }
    if (message.message !== undefined) {
      ChatMessage.encode(message.message, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateMessageResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateMessageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.response = StandardResponse.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = ChatMessage.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateMessageResponse {
    return {
      response: isSet(object.response) ? StandardResponse.fromJSON(object.response) : undefined,
      message: isSet(object.message) ? ChatMessage.fromJSON(object.message) : undefined,
    };
  },

  toJSON(message: UpdateMessageResponse): unknown {
    const obj: any = {};
    if (message.response !== undefined) {
      obj.response = StandardResponse.toJSON(message.response);
    }
    if (message.message !== undefined) {
      obj.message = ChatMessage.toJSON(message.message);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateMessageResponse>, I>>(base?: I): UpdateMessageResponse {
    return UpdateMessageResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateMessageResponse>, I>>(object: I): UpdateMessageResponse {
    const message = createBaseUpdateMessageResponse();
    message.response = (object.response !== undefined && object.response !== null)
      ? StandardResponse.fromPartial(object.response)
      : undefined;
    message.message = (object.message !== undefined && object.message !== null)
      ? ChatMessage.fromPartial(object.message)
      : undefined;
    return message;
  },
};

function createBaseDeleteConversationRequest(): DeleteConversationRequest {
  return { conversationId: "", hardDelete: false };
}

export const DeleteConversationRequest = {
  encode(message: DeleteConversationRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.conversationId !== "") {
      writer.uint32(10).string(message.conversationId);
    }
    if (message.hardDelete !== false) {
      writer.uint32(16).bool(message.hardDelete);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteConversationRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteConversationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.conversationId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.hardDelete = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteConversationRequest {
    return {
      conversationId: isSet(object.conversationId) ? globalThis.String(object.conversationId) : "",
      hardDelete: isSet(object.hardDelete) ? globalThis.Boolean(object.hardDelete) : false,
    };
  },

  toJSON(message: DeleteConversationRequest): unknown {
    const obj: any = {};
    if (message.conversationId !== "") {
      obj.conversationId = message.conversationId;
    }
    if (message.hardDelete !== false) {
      obj.hardDelete = message.hardDelete;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteConversationRequest>, I>>(base?: I): DeleteConversationRequest {
    return DeleteConversationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteConversationRequest>, I>>(object: I): DeleteConversationRequest {
    const message = createBaseDeleteConversationRequest();
    message.conversationId = object.conversationId ?? "";
    message.hardDelete = object.hardDelete ?? false;
    return message;
  },
};

function createBaseDeleteConversationResponse(): DeleteConversationResponse {
  return { response: undefined };
}

export const DeleteConversationResponse = {
  encode(message: DeleteConversationResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.response !== undefined) {
      StandardResponse.encode(message.response, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteConversationResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteConversationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.response = StandardResponse.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteConversationResponse {
    return { response: isSet(object.response) ? StandardResponse.fromJSON(object.response) : undefined };
  },

  toJSON(message: DeleteConversationResponse): unknown {
    const obj: any = {};
    if (message.response !== undefined) {
      obj.response = StandardResponse.toJSON(message.response);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteConversationResponse>, I>>(base?: I): DeleteConversationResponse {
    return DeleteConversationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteConversationResponse>, I>>(object: I): DeleteConversationResponse {
    const message = createBaseDeleteConversationResponse();
    message.response = (object.response !== undefined && object.response !== null)
      ? StandardResponse.fromPartial(object.response)
      : undefined;
    return message;
  },
};

function createBaseDeleteMessageRequest(): DeleteMessageRequest {
  return { messageId: "", hardDelete: false };
}

export const DeleteMessageRequest = {
  encode(message: DeleteMessageRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.messageId !== "") {
      writer.uint32(10).string(message.messageId);
    }
    if (message.hardDelete !== false) {
      writer.uint32(16).bool(message.hardDelete);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteMessageRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteMessageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.messageId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.hardDelete = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteMessageRequest {
    return {
      messageId: isSet(object.messageId) ? globalThis.String(object.messageId) : "",
      hardDelete: isSet(object.hardDelete) ? globalThis.Boolean(object.hardDelete) : false,
    };
  },

  toJSON(message: DeleteMessageRequest): unknown {
    const obj: any = {};
    if (message.messageId !== "") {
      obj.messageId = message.messageId;
    }
    if (message.hardDelete !== false) {
      obj.hardDelete = message.hardDelete;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteMessageRequest>, I>>(base?: I): DeleteMessageRequest {
    return DeleteMessageRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteMessageRequest>, I>>(object: I): DeleteMessageRequest {
    const message = createBaseDeleteMessageRequest();
    message.messageId = object.messageId ?? "";
    message.hardDelete = object.hardDelete ?? false;
    return message;
  },
};

function createBaseDeleteMessageResponse(): DeleteMessageResponse {
  return { response: undefined };
}

export const DeleteMessageResponse = {
  encode(message: DeleteMessageResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.response !== undefined) {
      StandardResponse.encode(message.response, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteMessageResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteMessageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.response = StandardResponse.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteMessageResponse {
    return { response: isSet(object.response) ? StandardResponse.fromJSON(object.response) : undefined };
  },

  toJSON(message: DeleteMessageResponse): unknown {
    const obj: any = {};
    if (message.response !== undefined) {
      obj.response = StandardResponse.toJSON(message.response);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteMessageResponse>, I>>(base?: I): DeleteMessageResponse {
    return DeleteMessageResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteMessageResponse>, I>>(object: I): DeleteMessageResponse {
    const message = createBaseDeleteMessageResponse();
    message.response = (object.response !== undefined && object.response !== null)
      ? StandardResponse.fromPartial(object.response)
      : undefined;
    return message;
  },
};

/**
 * Chat service for conversation and message management
 *
 * Uses common patterns for consistent API behavior across services
 */
export type ChatServiceService = typeof ChatServiceService;
export const ChatServiceService = {
  /** Conversation management */
  createConversation: {
    path: "/unhinged.chat.v1.ChatService/CreateConversation",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateConversationRequest) =>
      Buffer.from(CreateConversationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreateConversationRequest.decode(value),
    responseSerialize: (value: CreateConversationResponse) =>
      Buffer.from(CreateConversationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CreateConversationResponse.decode(value),
  },
  getConversation: {
    path: "/unhinged.chat.v1.ChatService/GetConversation",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetConversationRequest) => Buffer.from(GetConversationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetConversationRequest.decode(value),
    responseSerialize: (value: GetConversationResponse) => Buffer.from(GetConversationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetConversationResponse.decode(value),
  },
  listConversations: {
    path: "/unhinged.chat.v1.ChatService/ListConversations",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListConversationsRequest) => Buffer.from(ListConversationsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ListConversationsRequest.decode(value),
    responseSerialize: (value: ListConversationsResponse) =>
      Buffer.from(ListConversationsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ListConversationsResponse.decode(value),
  },
  updateConversation: {
    path: "/unhinged.chat.v1.ChatService/UpdateConversation",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateConversationRequest) =>
      Buffer.from(UpdateConversationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UpdateConversationRequest.decode(value),
    responseSerialize: (value: UpdateConversationResponse) =>
      Buffer.from(UpdateConversationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => UpdateConversationResponse.decode(value),
  },
  deleteConversation: {
    path: "/unhinged.chat.v1.ChatService/DeleteConversation",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteConversationRequest) =>
      Buffer.from(DeleteConversationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DeleteConversationRequest.decode(value),
    responseSerialize: (value: DeleteConversationResponse) =>
      Buffer.from(DeleteConversationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DeleteConversationResponse.decode(value),
  },
  /** Message management */
  sendMessage: {
    path: "/unhinged.chat.v1.ChatService/SendMessage",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SendMessageRequest) => Buffer.from(SendMessageRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SendMessageRequest.decode(value),
    responseSerialize: (value: SendMessageResponse) => Buffer.from(SendMessageResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SendMessageResponse.decode(value),
  },
  getMessages: {
    path: "/unhinged.chat.v1.ChatService/GetMessages",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetMessagesRequest) => Buffer.from(GetMessagesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetMessagesRequest.decode(value),
    responseSerialize: (value: GetMessagesResponse) => Buffer.from(GetMessagesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetMessagesResponse.decode(value),
  },
  updateMessage: {
    path: "/unhinged.chat.v1.ChatService/UpdateMessage",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateMessageRequest) => Buffer.from(UpdateMessageRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UpdateMessageRequest.decode(value),
    responseSerialize: (value: UpdateMessageResponse) => Buffer.from(UpdateMessageResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => UpdateMessageResponse.decode(value),
  },
  deleteMessage: {
    path: "/unhinged.chat.v1.ChatService/DeleteMessage",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteMessageRequest) => Buffer.from(DeleteMessageRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DeleteMessageRequest.decode(value),
    responseSerialize: (value: DeleteMessageResponse) => Buffer.from(DeleteMessageResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DeleteMessageResponse.decode(value),
  },
  /** Real-time streaming (uses common StreamChunk pattern) */
  streamChat: {
    path: "/unhinged.chat.v1.ChatService/StreamChat",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: StreamChatRequest) => Buffer.from(StreamChatRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => StreamChatRequest.decode(value),
    responseSerialize: (value: StreamChunk) => Buffer.from(StreamChunk.encode(value).finish()),
    responseDeserialize: (value: Buffer) => StreamChunk.decode(value),
  },
  subscribeToConversation: {
    path: "/unhinged.chat.v1.ChatService/SubscribeToConversation",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: SubscribeRequest) => Buffer.from(SubscribeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SubscribeRequest.decode(value),
    responseSerialize: (value: StreamChunk) => Buffer.from(StreamChunk.encode(value).finish()),
    responseDeserialize: (value: Buffer) => StreamChunk.decode(value),
  },
  /** Standard health check */
  healthCheck: {
    path: "/unhinged.chat.v1.ChatService/HealthCheck",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: HealthCheckRequest) => Buffer.from(HealthCheckRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => HealthCheckRequest.decode(value),
    responseSerialize: (value: HealthCheckResponse) => Buffer.from(HealthCheckResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => HealthCheckResponse.decode(value),
  },
} as const;

export interface ChatServiceServer extends UntypedServiceImplementation {
  /** Conversation management */
  createConversation: handleUnaryCall<CreateConversationRequest, CreateConversationResponse>;
  getConversation: handleUnaryCall<GetConversationRequest, GetConversationResponse>;
  listConversations: handleUnaryCall<ListConversationsRequest, ListConversationsResponse>;
  updateConversation: handleUnaryCall<UpdateConversationRequest, UpdateConversationResponse>;
  deleteConversation: handleUnaryCall<DeleteConversationRequest, DeleteConversationResponse>;
  /** Message management */
  sendMessage: handleUnaryCall<SendMessageRequest, SendMessageResponse>;
  getMessages: handleUnaryCall<GetMessagesRequest, GetMessagesResponse>;
  updateMessage: handleUnaryCall<UpdateMessageRequest, UpdateMessageResponse>;
  deleteMessage: handleUnaryCall<DeleteMessageRequest, DeleteMessageResponse>;
  /** Real-time streaming (uses common StreamChunk pattern) */
  streamChat: handleServerStreamingCall<StreamChatRequest, StreamChunk>;
  subscribeToConversation: handleServerStreamingCall<SubscribeRequest, StreamChunk>;
  /** Standard health check */
  healthCheck: handleUnaryCall<HealthCheckRequest, HealthCheckResponse>;
}

export interface ChatServiceClient extends Client {
  /** Conversation management */
  createConversation(
    request: CreateConversationRequest,
    callback: (error: ServiceError | null, response: CreateConversationResponse) => void,
  ): ClientUnaryCall;
  createConversation(
    request: CreateConversationRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CreateConversationResponse) => void,
  ): ClientUnaryCall;
  createConversation(
    request: CreateConversationRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CreateConversationResponse) => void,
  ): ClientUnaryCall;
  getConversation(
    request: GetConversationRequest,
    callback: (error: ServiceError | null, response: GetConversationResponse) => void,
  ): ClientUnaryCall;
  getConversation(
    request: GetConversationRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetConversationResponse) => void,
  ): ClientUnaryCall;
  getConversation(
    request: GetConversationRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetConversationResponse) => void,
  ): ClientUnaryCall;
  listConversations(
    request: ListConversationsRequest,
    callback: (error: ServiceError | null, response: ListConversationsResponse) => void,
  ): ClientUnaryCall;
  listConversations(
    request: ListConversationsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListConversationsResponse) => void,
  ): ClientUnaryCall;
  listConversations(
    request: ListConversationsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListConversationsResponse) => void,
  ): ClientUnaryCall;
  updateConversation(
    request: UpdateConversationRequest,
    callback: (error: ServiceError | null, response: UpdateConversationResponse) => void,
  ): ClientUnaryCall;
  updateConversation(
    request: UpdateConversationRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: UpdateConversationResponse) => void,
  ): ClientUnaryCall;
  updateConversation(
    request: UpdateConversationRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: UpdateConversationResponse) => void,
  ): ClientUnaryCall;
  deleteConversation(
    request: DeleteConversationRequest,
    callback: (error: ServiceError | null, response: DeleteConversationResponse) => void,
  ): ClientUnaryCall;
  deleteConversation(
    request: DeleteConversationRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DeleteConversationResponse) => void,
  ): ClientUnaryCall;
  deleteConversation(
    request: DeleteConversationRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DeleteConversationResponse) => void,
  ): ClientUnaryCall;
  /** Message management */
  sendMessage(
    request: SendMessageRequest,
    callback: (error: ServiceError | null, response: SendMessageResponse) => void,
  ): ClientUnaryCall;
  sendMessage(
    request: SendMessageRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SendMessageResponse) => void,
  ): ClientUnaryCall;
  sendMessage(
    request: SendMessageRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SendMessageResponse) => void,
  ): ClientUnaryCall;
  getMessages(
    request: GetMessagesRequest,
    callback: (error: ServiceError | null, response: GetMessagesResponse) => void,
  ): ClientUnaryCall;
  getMessages(
    request: GetMessagesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetMessagesResponse) => void,
  ): ClientUnaryCall;
  getMessages(
    request: GetMessagesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetMessagesResponse) => void,
  ): ClientUnaryCall;
  updateMessage(
    request: UpdateMessageRequest,
    callback: (error: ServiceError | null, response: UpdateMessageResponse) => void,
  ): ClientUnaryCall;
  updateMessage(
    request: UpdateMessageRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: UpdateMessageResponse) => void,
  ): ClientUnaryCall;
  updateMessage(
    request: UpdateMessageRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: UpdateMessageResponse) => void,
  ): ClientUnaryCall;
  deleteMessage(
    request: DeleteMessageRequest,
    callback: (error: ServiceError | null, response: DeleteMessageResponse) => void,
  ): ClientUnaryCall;
  deleteMessage(
    request: DeleteMessageRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DeleteMessageResponse) => void,
  ): ClientUnaryCall;
  deleteMessage(
    request: DeleteMessageRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DeleteMessageResponse) => void,
  ): ClientUnaryCall;
  /** Real-time streaming (uses common StreamChunk pattern) */
  streamChat(request: StreamChatRequest, options?: Partial<CallOptions>): ClientReadableStream<StreamChunk>;
  streamChat(
    request: StreamChatRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<StreamChunk>;
  subscribeToConversation(request: SubscribeRequest, options?: Partial<CallOptions>): ClientReadableStream<StreamChunk>;
  subscribeToConversation(
    request: SubscribeRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<StreamChunk>;
  /** Standard health check */
  healthCheck(
    request: HealthCheckRequest,
    callback: (error: ServiceError | null, response: HealthCheckResponse) => void,
  ): ClientUnaryCall;
  healthCheck(
    request: HealthCheckRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: HealthCheckResponse) => void,
  ): ClientUnaryCall;
  healthCheck(
    request: HealthCheckRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: HealthCheckResponse) => void,
  ): ClientUnaryCall;
}

export const ChatServiceClient = makeGenericClientConstructor(
  ChatServiceService,
  "unhinged.chat.v1.ChatService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): ChatServiceClient;
  service: typeof ChatServiceService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
