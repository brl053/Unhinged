// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v3.21.12
// source: common.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Duration } from "./google/protobuf/duration";
import { Struct } from "./google/protobuf/struct";
import { Timestamp } from "./google/protobuf/timestamp";

/** Chunk type classification */
export enum ChunkType {
  CHUNK_TYPE_UNSPECIFIED = 0,
  /** CHUNK_TYPE_DATA - Primary content */
  CHUNK_TYPE_DATA = 1,
  /** CHUNK_TYPE_METADATA - Metadata update */
  CHUNK_TYPE_METADATA = 2,
  /** CHUNK_TYPE_ERROR - Error information */
  CHUNK_TYPE_ERROR = 3,
  /** CHUNK_TYPE_HEARTBEAT - Keep-alive signal */
  CHUNK_TYPE_HEARTBEAT = 4,
  /** CHUNK_TYPE_PROGRESS - Progress update */
  CHUNK_TYPE_PROGRESS = 5,
  UNRECOGNIZED = -1,
}

export function chunkTypeFromJSON(object: any): ChunkType {
  switch (object) {
    case 0:
    case "CHUNK_TYPE_UNSPECIFIED":
      return ChunkType.CHUNK_TYPE_UNSPECIFIED;
    case 1:
    case "CHUNK_TYPE_DATA":
      return ChunkType.CHUNK_TYPE_DATA;
    case 2:
    case "CHUNK_TYPE_METADATA":
      return ChunkType.CHUNK_TYPE_METADATA;
    case 3:
    case "CHUNK_TYPE_ERROR":
      return ChunkType.CHUNK_TYPE_ERROR;
    case 4:
    case "CHUNK_TYPE_HEARTBEAT":
      return ChunkType.CHUNK_TYPE_HEARTBEAT;
    case 5:
    case "CHUNK_TYPE_PROGRESS":
      return ChunkType.CHUNK_TYPE_PROGRESS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ChunkType.UNRECOGNIZED;
  }
}

export function chunkTypeToJSON(object: ChunkType): string {
  switch (object) {
    case ChunkType.CHUNK_TYPE_UNSPECIFIED:
      return "CHUNK_TYPE_UNSPECIFIED";
    case ChunkType.CHUNK_TYPE_DATA:
      return "CHUNK_TYPE_DATA";
    case ChunkType.CHUNK_TYPE_METADATA:
      return "CHUNK_TYPE_METADATA";
    case ChunkType.CHUNK_TYPE_ERROR:
      return "CHUNK_TYPE_ERROR";
    case ChunkType.CHUNK_TYPE_HEARTBEAT:
      return "CHUNK_TYPE_HEARTBEAT";
    case ChunkType.CHUNK_TYPE_PROGRESS:
      return "CHUNK_TYPE_PROGRESS";
    case ChunkType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Chunk processing status */
export enum ChunkStatus {
  CHUNK_STATUS_UNSPECIFIED = 0,
  /** CHUNK_STATUS_PROCESSING - Still being processed */
  CHUNK_STATUS_PROCESSING = 1,
  /** CHUNK_STATUS_COMPLETE - Successfully processed */
  CHUNK_STATUS_COMPLETE = 2,
  /** CHUNK_STATUS_ERROR - Processing failed */
  CHUNK_STATUS_ERROR = 3,
  /** CHUNK_STATUS_CANCELLED - Processing cancelled */
  CHUNK_STATUS_CANCELLED = 4,
  UNRECOGNIZED = -1,
}

export function chunkStatusFromJSON(object: any): ChunkStatus {
  switch (object) {
    case 0:
    case "CHUNK_STATUS_UNSPECIFIED":
      return ChunkStatus.CHUNK_STATUS_UNSPECIFIED;
    case 1:
    case "CHUNK_STATUS_PROCESSING":
      return ChunkStatus.CHUNK_STATUS_PROCESSING;
    case 2:
    case "CHUNK_STATUS_COMPLETE":
      return ChunkStatus.CHUNK_STATUS_COMPLETE;
    case 3:
    case "CHUNK_STATUS_ERROR":
      return ChunkStatus.CHUNK_STATUS_ERROR;
    case 4:
    case "CHUNK_STATUS_CANCELLED":
      return ChunkStatus.CHUNK_STATUS_CANCELLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ChunkStatus.UNRECOGNIZED;
  }
}

export function chunkStatusToJSON(object: ChunkStatus): string {
  switch (object) {
    case ChunkStatus.CHUNK_STATUS_UNSPECIFIED:
      return "CHUNK_STATUS_UNSPECIFIED";
    case ChunkStatus.CHUNK_STATUS_PROCESSING:
      return "CHUNK_STATUS_PROCESSING";
    case ChunkStatus.CHUNK_STATUS_COMPLETE:
      return "CHUNK_STATUS_COMPLETE";
    case ChunkStatus.CHUNK_STATUS_ERROR:
      return "CHUNK_STATUS_ERROR";
    case ChunkStatus.CHUNK_STATUS_CANCELLED:
      return "CHUNK_STATUS_CANCELLED";
    case ChunkStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Attachment type classification */
export enum AttachmentType {
  ATTACHMENT_TYPE_UNSPECIFIED = 0,
  /** ATTACHMENT_TYPE_IMAGE - Images (jpg, png, gif, etc.) */
  ATTACHMENT_TYPE_IMAGE = 1,
  /** ATTACHMENT_TYPE_DOCUMENT - Documents (pdf, docx, txt, etc.) */
  ATTACHMENT_TYPE_DOCUMENT = 2,
  /** ATTACHMENT_TYPE_AUDIO - Audio files (mp3, wav, etc.) */
  ATTACHMENT_TYPE_AUDIO = 3,
  /** ATTACHMENT_TYPE_VIDEO - Video files (mp4, avi, etc.) */
  ATTACHMENT_TYPE_VIDEO = 4,
  /** ATTACHMENT_TYPE_ARCHIVE - Archives (zip, tar, etc.) */
  ATTACHMENT_TYPE_ARCHIVE = 5,
  /** ATTACHMENT_TYPE_CODE - Source code files */
  ATTACHMENT_TYPE_CODE = 6,
  /** ATTACHMENT_TYPE_SPREADSHEET - Excel, CSV, etc. */
  ATTACHMENT_TYPE_SPREADSHEET = 7,
  /** ATTACHMENT_TYPE_PRESENTATION - PowerPoint, etc. */
  ATTACHMENT_TYPE_PRESENTATION = 8,
  UNRECOGNIZED = -1,
}

export function attachmentTypeFromJSON(object: any): AttachmentType {
  switch (object) {
    case 0:
    case "ATTACHMENT_TYPE_UNSPECIFIED":
      return AttachmentType.ATTACHMENT_TYPE_UNSPECIFIED;
    case 1:
    case "ATTACHMENT_TYPE_IMAGE":
      return AttachmentType.ATTACHMENT_TYPE_IMAGE;
    case 2:
    case "ATTACHMENT_TYPE_DOCUMENT":
      return AttachmentType.ATTACHMENT_TYPE_DOCUMENT;
    case 3:
    case "ATTACHMENT_TYPE_AUDIO":
      return AttachmentType.ATTACHMENT_TYPE_AUDIO;
    case 4:
    case "ATTACHMENT_TYPE_VIDEO":
      return AttachmentType.ATTACHMENT_TYPE_VIDEO;
    case 5:
    case "ATTACHMENT_TYPE_ARCHIVE":
      return AttachmentType.ATTACHMENT_TYPE_ARCHIVE;
    case 6:
    case "ATTACHMENT_TYPE_CODE":
      return AttachmentType.ATTACHMENT_TYPE_CODE;
    case 7:
    case "ATTACHMENT_TYPE_SPREADSHEET":
      return AttachmentType.ATTACHMENT_TYPE_SPREADSHEET;
    case 8:
    case "ATTACHMENT_TYPE_PRESENTATION":
      return AttachmentType.ATTACHMENT_TYPE_PRESENTATION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AttachmentType.UNRECOGNIZED;
  }
}

export function attachmentTypeToJSON(object: AttachmentType): string {
  switch (object) {
    case AttachmentType.ATTACHMENT_TYPE_UNSPECIFIED:
      return "ATTACHMENT_TYPE_UNSPECIFIED";
    case AttachmentType.ATTACHMENT_TYPE_IMAGE:
      return "ATTACHMENT_TYPE_IMAGE";
    case AttachmentType.ATTACHMENT_TYPE_DOCUMENT:
      return "ATTACHMENT_TYPE_DOCUMENT";
    case AttachmentType.ATTACHMENT_TYPE_AUDIO:
      return "ATTACHMENT_TYPE_AUDIO";
    case AttachmentType.ATTACHMENT_TYPE_VIDEO:
      return "ATTACHMENT_TYPE_VIDEO";
    case AttachmentType.ATTACHMENT_TYPE_ARCHIVE:
      return "ATTACHMENT_TYPE_ARCHIVE";
    case AttachmentType.ATTACHMENT_TYPE_CODE:
      return "ATTACHMENT_TYPE_CODE";
    case AttachmentType.ATTACHMENT_TYPE_SPREADSHEET:
      return "ATTACHMENT_TYPE_SPREADSHEET";
    case AttachmentType.ATTACHMENT_TYPE_PRESENTATION:
      return "ATTACHMENT_TYPE_PRESENTATION";
    case AttachmentType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Standard error codes aligned with gRPC status codes */
export enum ErrorCode {
  ERROR_CODE_UNSPECIFIED = 0,
  /** ERROR_CODE_INVALID_ARGUMENT - Invalid request parameters */
  ERROR_CODE_INVALID_ARGUMENT = 1,
  /** ERROR_CODE_NOT_FOUND - Resource not found */
  ERROR_CODE_NOT_FOUND = 2,
  /** ERROR_CODE_PERMISSION_DENIED - Access denied */
  ERROR_CODE_PERMISSION_DENIED = 3,
  /** ERROR_CODE_UNAUTHENTICATED - Authentication required */
  ERROR_CODE_UNAUTHENTICATED = 4,
  /** ERROR_CODE_RESOURCE_EXHAUSTED - Rate limit or quota exceeded */
  ERROR_CODE_RESOURCE_EXHAUSTED = 5,
  /** ERROR_CODE_INTERNAL - Internal server error */
  ERROR_CODE_INTERNAL = 6,
  /** ERROR_CODE_UNAVAILABLE - Service temporarily unavailable */
  ERROR_CODE_UNAVAILABLE = 7,
  /** ERROR_CODE_DEADLINE_EXCEEDED - Request timeout */
  ERROR_CODE_DEADLINE_EXCEEDED = 8,
  /** ERROR_CODE_ALREADY_EXISTS - Resource already exists */
  ERROR_CODE_ALREADY_EXISTS = 9,
  /** ERROR_CODE_CANCELLED - Request cancelled */
  ERROR_CODE_CANCELLED = 10,
  UNRECOGNIZED = -1,
}

export function errorCodeFromJSON(object: any): ErrorCode {
  switch (object) {
    case 0:
    case "ERROR_CODE_UNSPECIFIED":
      return ErrorCode.ERROR_CODE_UNSPECIFIED;
    case 1:
    case "ERROR_CODE_INVALID_ARGUMENT":
      return ErrorCode.ERROR_CODE_INVALID_ARGUMENT;
    case 2:
    case "ERROR_CODE_NOT_FOUND":
      return ErrorCode.ERROR_CODE_NOT_FOUND;
    case 3:
    case "ERROR_CODE_PERMISSION_DENIED":
      return ErrorCode.ERROR_CODE_PERMISSION_DENIED;
    case 4:
    case "ERROR_CODE_UNAUTHENTICATED":
      return ErrorCode.ERROR_CODE_UNAUTHENTICATED;
    case 5:
    case "ERROR_CODE_RESOURCE_EXHAUSTED":
      return ErrorCode.ERROR_CODE_RESOURCE_EXHAUSTED;
    case 6:
    case "ERROR_CODE_INTERNAL":
      return ErrorCode.ERROR_CODE_INTERNAL;
    case 7:
    case "ERROR_CODE_UNAVAILABLE":
      return ErrorCode.ERROR_CODE_UNAVAILABLE;
    case 8:
    case "ERROR_CODE_DEADLINE_EXCEEDED":
      return ErrorCode.ERROR_CODE_DEADLINE_EXCEEDED;
    case 9:
    case "ERROR_CODE_ALREADY_EXISTS":
      return ErrorCode.ERROR_CODE_ALREADY_EXISTS;
    case 10:
    case "ERROR_CODE_CANCELLED":
      return ErrorCode.ERROR_CODE_CANCELLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ErrorCode.UNRECOGNIZED;
  }
}

export function errorCodeToJSON(object: ErrorCode): string {
  switch (object) {
    case ErrorCode.ERROR_CODE_UNSPECIFIED:
      return "ERROR_CODE_UNSPECIFIED";
    case ErrorCode.ERROR_CODE_INVALID_ARGUMENT:
      return "ERROR_CODE_INVALID_ARGUMENT";
    case ErrorCode.ERROR_CODE_NOT_FOUND:
      return "ERROR_CODE_NOT_FOUND";
    case ErrorCode.ERROR_CODE_PERMISSION_DENIED:
      return "ERROR_CODE_PERMISSION_DENIED";
    case ErrorCode.ERROR_CODE_UNAUTHENTICATED:
      return "ERROR_CODE_UNAUTHENTICATED";
    case ErrorCode.ERROR_CODE_RESOURCE_EXHAUSTED:
      return "ERROR_CODE_RESOURCE_EXHAUSTED";
    case ErrorCode.ERROR_CODE_INTERNAL:
      return "ERROR_CODE_INTERNAL";
    case ErrorCode.ERROR_CODE_UNAVAILABLE:
      return "ERROR_CODE_UNAVAILABLE";
    case ErrorCode.ERROR_CODE_DEADLINE_EXCEEDED:
      return "ERROR_CODE_DEADLINE_EXCEEDED";
    case ErrorCode.ERROR_CODE_ALREADY_EXISTS:
      return "ERROR_CODE_ALREADY_EXISTS";
    case ErrorCode.ERROR_CODE_CANCELLED:
      return "ERROR_CODE_CANCELLED";
    case ErrorCode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Filter operators */
export enum FilterOperator {
  FILTER_OPERATOR_UNSPECIFIED = 0,
  /** FILTER_OPERATOR_EQUALS - field = value */
  FILTER_OPERATOR_EQUALS = 1,
  /** FILTER_OPERATOR_NOT_EQUALS - field != value */
  FILTER_OPERATOR_NOT_EQUALS = 2,
  /** FILTER_OPERATOR_GREATER_THAN - field > value */
  FILTER_OPERATOR_GREATER_THAN = 3,
  /** FILTER_OPERATOR_LESS_THAN - field < value */
  FILTER_OPERATOR_LESS_THAN = 4,
  /** FILTER_OPERATOR_CONTAINS - field LIKE %value% */
  FILTER_OPERATOR_CONTAINS = 5,
  /** FILTER_OPERATOR_IN - field IN (values) */
  FILTER_OPERATOR_IN = 6,
  /** FILTER_OPERATOR_NOT_IN - field NOT IN (values) */
  FILTER_OPERATOR_NOT_IN = 7,
  /** FILTER_OPERATOR_IS_NULL - field IS NULL */
  FILTER_OPERATOR_IS_NULL = 8,
  /** FILTER_OPERATOR_IS_NOT_NULL - field IS NOT NULL */
  FILTER_OPERATOR_IS_NOT_NULL = 9,
  UNRECOGNIZED = -1,
}

export function filterOperatorFromJSON(object: any): FilterOperator {
  switch (object) {
    case 0:
    case "FILTER_OPERATOR_UNSPECIFIED":
      return FilterOperator.FILTER_OPERATOR_UNSPECIFIED;
    case 1:
    case "FILTER_OPERATOR_EQUALS":
      return FilterOperator.FILTER_OPERATOR_EQUALS;
    case 2:
    case "FILTER_OPERATOR_NOT_EQUALS":
      return FilterOperator.FILTER_OPERATOR_NOT_EQUALS;
    case 3:
    case "FILTER_OPERATOR_GREATER_THAN":
      return FilterOperator.FILTER_OPERATOR_GREATER_THAN;
    case 4:
    case "FILTER_OPERATOR_LESS_THAN":
      return FilterOperator.FILTER_OPERATOR_LESS_THAN;
    case 5:
    case "FILTER_OPERATOR_CONTAINS":
      return FilterOperator.FILTER_OPERATOR_CONTAINS;
    case 6:
    case "FILTER_OPERATOR_IN":
      return FilterOperator.FILTER_OPERATOR_IN;
    case 7:
    case "FILTER_OPERATOR_NOT_IN":
      return FilterOperator.FILTER_OPERATOR_NOT_IN;
    case 8:
    case "FILTER_OPERATOR_IS_NULL":
      return FilterOperator.FILTER_OPERATOR_IS_NULL;
    case 9:
    case "FILTER_OPERATOR_IS_NOT_NULL":
      return FilterOperator.FILTER_OPERATOR_IS_NOT_NULL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FilterOperator.UNRECOGNIZED;
  }
}

export function filterOperatorToJSON(object: FilterOperator): string {
  switch (object) {
    case FilterOperator.FILTER_OPERATOR_UNSPECIFIED:
      return "FILTER_OPERATOR_UNSPECIFIED";
    case FilterOperator.FILTER_OPERATOR_EQUALS:
      return "FILTER_OPERATOR_EQUALS";
    case FilterOperator.FILTER_OPERATOR_NOT_EQUALS:
      return "FILTER_OPERATOR_NOT_EQUALS";
    case FilterOperator.FILTER_OPERATOR_GREATER_THAN:
      return "FILTER_OPERATOR_GREATER_THAN";
    case FilterOperator.FILTER_OPERATOR_LESS_THAN:
      return "FILTER_OPERATOR_LESS_THAN";
    case FilterOperator.FILTER_OPERATOR_CONTAINS:
      return "FILTER_OPERATOR_CONTAINS";
    case FilterOperator.FILTER_OPERATOR_IN:
      return "FILTER_OPERATOR_IN";
    case FilterOperator.FILTER_OPERATOR_NOT_IN:
      return "FILTER_OPERATOR_NOT_IN";
    case FilterOperator.FILTER_OPERATOR_IS_NULL:
      return "FILTER_OPERATOR_IS_NULL";
    case FilterOperator.FILTER_OPERATOR_IS_NOT_NULL:
      return "FILTER_OPERATOR_IS_NOT_NULL";
    case FilterOperator.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Health status levels */
export enum HealthStatus {
  HEALTH_STATUS_UNSPECIFIED = 0,
  /** HEALTH_STATUS_HEALTHY - All systems operational */
  HEALTH_STATUS_HEALTHY = 1,
  /** HEALTH_STATUS_DEGRADED - Functional but with issues */
  HEALTH_STATUS_DEGRADED = 2,
  /** HEALTH_STATUS_UNHEALTHY - Not functioning properly */
  HEALTH_STATUS_UNHEALTHY = 3,
  /** HEALTH_STATUS_UNKNOWN - Cannot determine status */
  HEALTH_STATUS_UNKNOWN = 4,
  UNRECOGNIZED = -1,
}

export function healthStatusFromJSON(object: any): HealthStatus {
  switch (object) {
    case 0:
    case "HEALTH_STATUS_UNSPECIFIED":
      return HealthStatus.HEALTH_STATUS_UNSPECIFIED;
    case 1:
    case "HEALTH_STATUS_HEALTHY":
      return HealthStatus.HEALTH_STATUS_HEALTHY;
    case 2:
    case "HEALTH_STATUS_DEGRADED":
      return HealthStatus.HEALTH_STATUS_DEGRADED;
    case 3:
    case "HEALTH_STATUS_UNHEALTHY":
      return HealthStatus.HEALTH_STATUS_UNHEALTHY;
    case 4:
    case "HEALTH_STATUS_UNKNOWN":
      return HealthStatus.HEALTH_STATUS_UNKNOWN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return HealthStatus.UNRECOGNIZED;
  }
}

export function healthStatusToJSON(object: HealthStatus): string {
  switch (object) {
    case HealthStatus.HEALTH_STATUS_UNSPECIFIED:
      return "HEALTH_STATUS_UNSPECIFIED";
    case HealthStatus.HEALTH_STATUS_HEALTHY:
      return "HEALTH_STATUS_HEALTHY";
    case HealthStatus.HEALTH_STATUS_DEGRADED:
      return "HEALTH_STATUS_DEGRADED";
    case HealthStatus.HEALTH_STATUS_UNHEALTHY:
      return "HEALTH_STATUS_UNHEALTHY";
    case HealthStatus.HEALTH_STATUS_UNKNOWN:
      return "HEALTH_STATUS_UNKNOWN";
    case HealthStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Standard resource metadata for all entities
 *
 * Every resource in the system (conversations, documents, audio, etc.)
 * should include this metadata for consistent ownership, auditing,
 * and lifecycle management.
 */
export interface ResourceMetadata {
  /** UUID of the resource */
  resourceId: string;
  /** Team ownership for multi-tenancy */
  teamId: string;
  /** Environment isolation */
  namespaceId: string;
  /** User who created the resource */
  createdBy: string;
  createdAt?: Date | undefined;
  updatedAt?:
    | Date
    | undefined;
  /** Service-specific metadata */
  customMetadata?:
    | { [key: string]: any }
    | undefined;
  /** Optimistic locking version */
  version: number;
  /** User-defined tags */
  tags: string[];
}

/**
 * Lightweight reference to any resource
 *
 * Used for linking between resources without full object embedding
 */
export interface ResourceReference {
  /** "conversation", "document", "audio" */
  resourceType: string;
  /** UUID of the referenced resource */
  resourceId: string;
  /** Human-readable identifier */
  displayName: string;
  /** Optional: direct access URL */
  url: string;
}

/**
 * Universal pagination request
 *
 * Supports cursor-based pagination for consistent performance
 * across large datasets.
 */
export interface PaginationRequest {
  /** Default: 50, Max: 1000 */
  pageSize: number;
  /** Opaque cursor for next page */
  pageToken: string;
  /** "created_at DESC", "name ASC" */
  orderBy: string;
}

/**
 * Universal pagination response
 *
 * Provides consistent pagination metadata across all list operations
 */
export interface PaginationResponse {
  /** Cursor for next page (empty if last page) */
  nextPageToken: string;
  /** Optional: expensive to compute */
  totalCount: number;
  /** Whether more results exist */
  hasMore: boolean;
  /** Actual page size returned */
  pageSize: number;
}

/**
 * Universal streaming chunk
 *
 * Used for all streaming operations (chat, audio, LLM completions)
 * to provide consistent streaming behavior across services.
 */
export interface StreamChunk {
  /** Unique identifier for this stream */
  streamId: string;
  /** Ordering within stream */
  sequenceNumber: number;
  /** Type of chunk content */
  type: ChunkType;
  /** Payload (use one of these) */
  data: Uint8Array;
  /** Text payload */
  text: string;
  /** Structured data payload */
  structured?:
    | { [key: string]: any }
    | undefined;
  /** Chunk-specific metadata */
  metadata?:
    | { [key: string]: any }
    | undefined;
  /** Last chunk in stream */
  isFinal: boolean;
  /** Processing status */
  status: ChunkStatus;
  timestamp?: Date | undefined;
}

/**
 * Universal usage metrics
 *
 * Tracks resource consumption across different service types
 * for billing, monitoring, and optimization.
 */
export interface UsageMetrics {
  /** LLM token consumption */
  tokens?:
    | TokenUsage
    | undefined;
  /** Audio processing metrics */
  audio?:
    | AudioUsage
    | undefined;
  /** Data transfer metrics */
  data?:
    | DataUsage
    | undefined;
  /** Compute resource usage */
  compute?: ComputeUsage | undefined;
  processingTime?: Duration | undefined;
  recordedAt?:
    | Date
    | undefined;
  /** Estimated cost in USD */
  costUsd: number;
}

/** Token usage for LLM operations */
export interface TokenUsage {
  /** Input tokens */
  promptTokens: number;
  /** Output tokens */
  completionTokens: number;
  /** Total tokens used */
  totalTokens: number;
  /** Tokens served from cache */
  cachedTokens: number;
  /** Model used for token counting */
  model: string;
}

/** Audio processing usage */
export interface AudioUsage {
  /** Audio duration processed */
  duration?:
    | Duration
    | undefined;
  /** Audio data size */
  bytesProcessed: string;
  /** Audio sample rate */
  sampleRate: number;
  /** Number of audio channels */
  channels: number;
  /** Audio format (wav, mp3, etc.) */
  format: string;
}

/** Data transfer usage */
export interface DataUsage {
  /** Data read from storage */
  bytesRead: string;
  /** Data written to storage */
  bytesWritten: string;
  /** Number of records processed */
  recordsProcessed: number;
  /** Number of API calls made */
  apiCalls: number;
}

/** Compute resource usage */
export interface ComputeUsage {
  /** CPU time consumed */
  cpuTime?:
    | Duration
    | undefined;
  /** Peak memory usage */
  memoryBytes: string;
  /** Storage space used */
  storageBytes: string;
  /** GPU time (if applicable) */
  gpuSeconds: number;
}

/**
 * Universal file attachment
 *
 * Used across all services for file uploads, media, documents
 */
export interface Attachment {
  /** UUID of the attachment */
  attachmentId: string;
  /** Classification of attachment */
  type: AttachmentType;
  /** Storage URL (internal or external) */
  url: string;
  /** Original filename */
  filename: string;
  /** File size in bytes */
  sizeBytes: string;
  /** MIME type */
  mimeType: string;
  /** Optional: thumbnail for images/videos */
  thumbnailUrl: string;
  /** File-specific metadata */
  metadata?: { [key: string]: any } | undefined;
  uploadedAt?:
    | Date
    | undefined;
  /** User who uploaded the file */
  uploadedBy: string;
}

/**
 * Standardized error response
 *
 * Provides consistent error handling across all services
 * with detailed field-level validation errors.
 */
export interface Error {
  /** Standard error code */
  code: ErrorCode;
  /** Human-readable error message */
  message: string;
  /** Additional error details */
  details: string;
  /** Field-specific validation errors */
  fieldErrors: ErrorField[];
  /** Debug info (dev/staging only) */
  debugInfo?:
    | { [key: string]: any }
    | undefined;
  /** Request ID for tracing */
  requestId: string;
}

/** Field-specific validation error */
export interface ErrorField {
  /** Field name (dot notation for nested) */
  field: string;
  /** Field-specific error message */
  message: string;
  /** Field error code (optional) */
  code: string;
}

/**
 * Universal filtering for list operations
 *
 * Provides consistent filtering capabilities across all services
 */
export interface Filter {
  /** Field to filter on (dot notation) */
  field: string;
  /** Comparison operator */
  operator: FilterOperator;
  /** Filter value */
  value: string;
  /** Multiple values for IN operator */
  values: string[];
}

/** Universal health check request */
export interface HealthCheckRequest {
  /** Optional: specific service component */
  service: string;
  /** Check dependent services too */
  includeDependencies: boolean;
}

/** Universal health check response */
export interface HealthCheckResponse {
  /** Overall health status */
  status: HealthStatus;
  /** Human-readable status message */
  message: string;
  /** Component-specific health details */
  details: { [key: string]: string };
  checkedAt?: Date | undefined;
  responseTime?: Duration | undefined;
}

export interface HealthCheckResponse_DetailsEntry {
  key: string;
  value: string;
}

/**
 * Standard response wrapper for all operations
 *
 * Provides consistent success/error handling across all services
 */
export interface StandardResponse {
  /** Operation success indicator */
  success: boolean;
  /** Human-readable result message */
  message: string;
  /** Error details (if success = false) */
  error?:
    | Error
    | undefined;
  /** Operation-specific metadata */
  metadata?:
    | { [key: string]: any }
    | undefined;
  /** Request ID for tracing */
  requestId: string;
}

/**
 * Audit information for all operations
 *
 * Tracks who did what when for compliance and debugging
 */
export interface AuditInfo {
  /** User who performed the action */
  userId: string;
  /** Session identifier */
  sessionId: string;
  /** Client IP address */
  ipAddress: string;
  /** Client user agent */
  userAgent: string;
  timestamp?:
    | Date
    | undefined;
  /** Action performed */
  action: string;
  /** Additional context */
  context?: { [key: string]: any } | undefined;
}

function createBaseResourceMetadata(): ResourceMetadata {
  return {
    resourceId: "",
    teamId: "",
    namespaceId: "",
    createdBy: "",
    createdAt: undefined,
    updatedAt: undefined,
    customMetadata: undefined,
    version: 0,
    tags: [],
  };
}

export const ResourceMetadata = {
  encode(message: ResourceMetadata, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.resourceId !== "") {
      writer.uint32(10).string(message.resourceId);
    }
    if (message.teamId !== "") {
      writer.uint32(18).string(message.teamId);
    }
    if (message.namespaceId !== "") {
      writer.uint32(26).string(message.namespaceId);
    }
    if (message.createdBy !== "") {
      writer.uint32(34).string(message.createdBy);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(42).fork()).ldelim();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(50).fork()).ldelim();
    }
    if (message.customMetadata !== undefined) {
      Struct.encode(Struct.wrap(message.customMetadata), writer.uint32(58).fork()).ldelim();
    }
    if (message.version !== 0) {
      writer.uint32(64).int32(message.version);
    }
    for (const v of message.tags) {
      writer.uint32(74).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ResourceMetadata {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourceMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.resourceId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.teamId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.namespaceId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.createdBy = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.customMetadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.version = reader.int32();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.tags.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResourceMetadata {
    return {
      resourceId: isSet(object.resourceId) ? globalThis.String(object.resourceId) : "",
      teamId: isSet(object.teamId) ? globalThis.String(object.teamId) : "",
      namespaceId: isSet(object.namespaceId) ? globalThis.String(object.namespaceId) : "",
      createdBy: isSet(object.createdBy) ? globalThis.String(object.createdBy) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      customMetadata: isObject(object.customMetadata) ? object.customMetadata : undefined,
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: ResourceMetadata): unknown {
    const obj: any = {};
    if (message.resourceId !== "") {
      obj.resourceId = message.resourceId;
    }
    if (message.teamId !== "") {
      obj.teamId = message.teamId;
    }
    if (message.namespaceId !== "") {
      obj.namespaceId = message.namespaceId;
    }
    if (message.createdBy !== "") {
      obj.createdBy = message.createdBy;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    if (message.customMetadata !== undefined) {
      obj.customMetadata = message.customMetadata;
    }
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResourceMetadata>, I>>(base?: I): ResourceMetadata {
    return ResourceMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResourceMetadata>, I>>(object: I): ResourceMetadata {
    const message = createBaseResourceMetadata();
    message.resourceId = object.resourceId ?? "";
    message.teamId = object.teamId ?? "";
    message.namespaceId = object.namespaceId ?? "";
    message.createdBy = object.createdBy ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    message.customMetadata = object.customMetadata ?? undefined;
    message.version = object.version ?? 0;
    message.tags = object.tags?.map((e) => e) || [];
    return message;
  },
};

function createBaseResourceReference(): ResourceReference {
  return { resourceType: "", resourceId: "", displayName: "", url: "" };
}

export const ResourceReference = {
  encode(message: ResourceReference, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.resourceType !== "") {
      writer.uint32(10).string(message.resourceType);
    }
    if (message.resourceId !== "") {
      writer.uint32(18).string(message.resourceId);
    }
    if (message.displayName !== "") {
      writer.uint32(26).string(message.displayName);
    }
    if (message.url !== "") {
      writer.uint32(34).string(message.url);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ResourceReference {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourceReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.resourceType = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.resourceId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.url = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResourceReference {
    return {
      resourceType: isSet(object.resourceType) ? globalThis.String(object.resourceType) : "",
      resourceId: isSet(object.resourceId) ? globalThis.String(object.resourceId) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
    };
  },

  toJSON(message: ResourceReference): unknown {
    const obj: any = {};
    if (message.resourceType !== "") {
      obj.resourceType = message.resourceType;
    }
    if (message.resourceId !== "") {
      obj.resourceId = message.resourceId;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResourceReference>, I>>(base?: I): ResourceReference {
    return ResourceReference.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResourceReference>, I>>(object: I): ResourceReference {
    const message = createBaseResourceReference();
    message.resourceType = object.resourceType ?? "";
    message.resourceId = object.resourceId ?? "";
    message.displayName = object.displayName ?? "";
    message.url = object.url ?? "";
    return message;
  },
};

function createBasePaginationRequest(): PaginationRequest {
  return { pageSize: 0, pageToken: "", orderBy: "" };
}

export const PaginationRequest = {
  encode(message: PaginationRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pageSize !== 0) {
      writer.uint32(8).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(18).string(message.pageToken);
    }
    if (message.orderBy !== "") {
      writer.uint32(26).string(message.orderBy);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PaginationRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaginationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaginationRequest {
    return {
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: PaginationRequest): unknown {
    const obj: any = {};
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaginationRequest>, I>>(base?: I): PaginationRequest {
    return PaginationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaginationRequest>, I>>(object: I): PaginationRequest {
    const message = createBasePaginationRequest();
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBasePaginationResponse(): PaginationResponse {
  return { nextPageToken: "", totalCount: 0, hasMore: false, pageSize: 0 };
}

export const PaginationResponse = {
  encode(message: PaginationResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.nextPageToken !== "") {
      writer.uint32(10).string(message.nextPageToken);
    }
    if (message.totalCount !== 0) {
      writer.uint32(16).int32(message.totalCount);
    }
    if (message.hasMore !== false) {
      writer.uint32(24).bool(message.hasMore);
    }
    if (message.pageSize !== 0) {
      writer.uint32(32).int32(message.pageSize);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PaginationResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaginationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.totalCount = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.hasMore = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaginationResponse {
    return {
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      totalCount: isSet(object.totalCount) ? globalThis.Number(object.totalCount) : 0,
      hasMore: isSet(object.hasMore) ? globalThis.Boolean(object.hasMore) : false,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
    };
  },

  toJSON(message: PaginationResponse): unknown {
    const obj: any = {};
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.totalCount !== 0) {
      obj.totalCount = Math.round(message.totalCount);
    }
    if (message.hasMore !== false) {
      obj.hasMore = message.hasMore;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaginationResponse>, I>>(base?: I): PaginationResponse {
    return PaginationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaginationResponse>, I>>(object: I): PaginationResponse {
    const message = createBasePaginationResponse();
    message.nextPageToken = object.nextPageToken ?? "";
    message.totalCount = object.totalCount ?? 0;
    message.hasMore = object.hasMore ?? false;
    message.pageSize = object.pageSize ?? 0;
    return message;
  },
};

function createBaseStreamChunk(): StreamChunk {
  return {
    streamId: "",
    sequenceNumber: 0,
    type: 0,
    data: new Uint8Array(0),
    text: "",
    structured: undefined,
    metadata: undefined,
    isFinal: false,
    status: 0,
    timestamp: undefined,
  };
}

export const StreamChunk = {
  encode(message: StreamChunk, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.streamId !== "") {
      writer.uint32(10).string(message.streamId);
    }
    if (message.sequenceNumber !== 0) {
      writer.uint32(16).int32(message.sequenceNumber);
    }
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    if (message.data.length !== 0) {
      writer.uint32(34).bytes(message.data);
    }
    if (message.text !== "") {
      writer.uint32(42).string(message.text);
    }
    if (message.structured !== undefined) {
      Struct.encode(Struct.wrap(message.structured), writer.uint32(50).fork()).ldelim();
    }
    if (message.metadata !== undefined) {
      Struct.encode(Struct.wrap(message.metadata), writer.uint32(58).fork()).ldelim();
    }
    if (message.isFinal !== false) {
      writer.uint32(64).bool(message.isFinal);
    }
    if (message.status !== 0) {
      writer.uint32(72).int32(message.status);
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(82).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamChunk {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamChunk();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.streamId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.sequenceNumber = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.data = reader.bytes();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.text = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.structured = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.metadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.isFinal = reader.bool();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamChunk {
    return {
      streamId: isSet(object.streamId) ? globalThis.String(object.streamId) : "",
      sequenceNumber: isSet(object.sequenceNumber) ? globalThis.Number(object.sequenceNumber) : 0,
      type: isSet(object.type) ? chunkTypeFromJSON(object.type) : 0,
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      structured: isObject(object.structured) ? object.structured : undefined,
      metadata: isObject(object.metadata) ? object.metadata : undefined,
      isFinal: isSet(object.isFinal) ? globalThis.Boolean(object.isFinal) : false,
      status: isSet(object.status) ? chunkStatusFromJSON(object.status) : 0,
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
    };
  },

  toJSON(message: StreamChunk): unknown {
    const obj: any = {};
    if (message.streamId !== "") {
      obj.streamId = message.streamId;
    }
    if (message.sequenceNumber !== 0) {
      obj.sequenceNumber = Math.round(message.sequenceNumber);
    }
    if (message.type !== 0) {
      obj.type = chunkTypeToJSON(message.type);
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.structured !== undefined) {
      obj.structured = message.structured;
    }
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    if (message.isFinal !== false) {
      obj.isFinal = message.isFinal;
    }
    if (message.status !== 0) {
      obj.status = chunkStatusToJSON(message.status);
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamChunk>, I>>(base?: I): StreamChunk {
    return StreamChunk.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamChunk>, I>>(object: I): StreamChunk {
    const message = createBaseStreamChunk();
    message.streamId = object.streamId ?? "";
    message.sequenceNumber = object.sequenceNumber ?? 0;
    message.type = object.type ?? 0;
    message.data = object.data ?? new Uint8Array(0);
    message.text = object.text ?? "";
    message.structured = object.structured ?? undefined;
    message.metadata = object.metadata ?? undefined;
    message.isFinal = object.isFinal ?? false;
    message.status = object.status ?? 0;
    message.timestamp = object.timestamp ?? undefined;
    return message;
  },
};

function createBaseUsageMetrics(): UsageMetrics {
  return {
    tokens: undefined,
    audio: undefined,
    data: undefined,
    compute: undefined,
    processingTime: undefined,
    recordedAt: undefined,
    costUsd: 0,
  };
}

export const UsageMetrics = {
  encode(message: UsageMetrics, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tokens !== undefined) {
      TokenUsage.encode(message.tokens, writer.uint32(10).fork()).ldelim();
    }
    if (message.audio !== undefined) {
      AudioUsage.encode(message.audio, writer.uint32(18).fork()).ldelim();
    }
    if (message.data !== undefined) {
      DataUsage.encode(message.data, writer.uint32(26).fork()).ldelim();
    }
    if (message.compute !== undefined) {
      ComputeUsage.encode(message.compute, writer.uint32(34).fork()).ldelim();
    }
    if (message.processingTime !== undefined) {
      Duration.encode(message.processingTime, writer.uint32(42).fork()).ldelim();
    }
    if (message.recordedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.recordedAt), writer.uint32(50).fork()).ldelim();
    }
    if (message.costUsd !== 0) {
      writer.uint32(61).float(message.costUsd);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UsageMetrics {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUsageMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tokens = TokenUsage.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.audio = AudioUsage.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.data = DataUsage.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.compute = ComputeUsage.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.processingTime = Duration.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.recordedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 61) {
            break;
          }

          message.costUsd = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UsageMetrics {
    return {
      tokens: isSet(object.tokens) ? TokenUsage.fromJSON(object.tokens) : undefined,
      audio: isSet(object.audio) ? AudioUsage.fromJSON(object.audio) : undefined,
      data: isSet(object.data) ? DataUsage.fromJSON(object.data) : undefined,
      compute: isSet(object.compute) ? ComputeUsage.fromJSON(object.compute) : undefined,
      processingTime: isSet(object.processingTime) ? Duration.fromJSON(object.processingTime) : undefined,
      recordedAt: isSet(object.recordedAt) ? fromJsonTimestamp(object.recordedAt) : undefined,
      costUsd: isSet(object.costUsd) ? globalThis.Number(object.costUsd) : 0,
    };
  },

  toJSON(message: UsageMetrics): unknown {
    const obj: any = {};
    if (message.tokens !== undefined) {
      obj.tokens = TokenUsage.toJSON(message.tokens);
    }
    if (message.audio !== undefined) {
      obj.audio = AudioUsage.toJSON(message.audio);
    }
    if (message.data !== undefined) {
      obj.data = DataUsage.toJSON(message.data);
    }
    if (message.compute !== undefined) {
      obj.compute = ComputeUsage.toJSON(message.compute);
    }
    if (message.processingTime !== undefined) {
      obj.processingTime = Duration.toJSON(message.processingTime);
    }
    if (message.recordedAt !== undefined) {
      obj.recordedAt = message.recordedAt.toISOString();
    }
    if (message.costUsd !== 0) {
      obj.costUsd = message.costUsd;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UsageMetrics>, I>>(base?: I): UsageMetrics {
    return UsageMetrics.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UsageMetrics>, I>>(object: I): UsageMetrics {
    const message = createBaseUsageMetrics();
    message.tokens = (object.tokens !== undefined && object.tokens !== null)
      ? TokenUsage.fromPartial(object.tokens)
      : undefined;
    message.audio = (object.audio !== undefined && object.audio !== null)
      ? AudioUsage.fromPartial(object.audio)
      : undefined;
    message.data = (object.data !== undefined && object.data !== null) ? DataUsage.fromPartial(object.data) : undefined;
    message.compute = (object.compute !== undefined && object.compute !== null)
      ? ComputeUsage.fromPartial(object.compute)
      : undefined;
    message.processingTime = (object.processingTime !== undefined && object.processingTime !== null)
      ? Duration.fromPartial(object.processingTime)
      : undefined;
    message.recordedAt = object.recordedAt ?? undefined;
    message.costUsd = object.costUsd ?? 0;
    return message;
  },
};

function createBaseTokenUsage(): TokenUsage {
  return { promptTokens: 0, completionTokens: 0, totalTokens: 0, cachedTokens: 0, model: "" };
}

export const TokenUsage = {
  encode(message: TokenUsage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.promptTokens !== 0) {
      writer.uint32(8).int32(message.promptTokens);
    }
    if (message.completionTokens !== 0) {
      writer.uint32(16).int32(message.completionTokens);
    }
    if (message.totalTokens !== 0) {
      writer.uint32(24).int32(message.totalTokens);
    }
    if (message.cachedTokens !== 0) {
      writer.uint32(32).int32(message.cachedTokens);
    }
    if (message.model !== "") {
      writer.uint32(42).string(message.model);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TokenUsage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenUsage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.promptTokens = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.completionTokens = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.totalTokens = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.cachedTokens = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.model = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenUsage {
    return {
      promptTokens: isSet(object.promptTokens) ? globalThis.Number(object.promptTokens) : 0,
      completionTokens: isSet(object.completionTokens) ? globalThis.Number(object.completionTokens) : 0,
      totalTokens: isSet(object.totalTokens) ? globalThis.Number(object.totalTokens) : 0,
      cachedTokens: isSet(object.cachedTokens) ? globalThis.Number(object.cachedTokens) : 0,
      model: isSet(object.model) ? globalThis.String(object.model) : "",
    };
  },

  toJSON(message: TokenUsage): unknown {
    const obj: any = {};
    if (message.promptTokens !== 0) {
      obj.promptTokens = Math.round(message.promptTokens);
    }
    if (message.completionTokens !== 0) {
      obj.completionTokens = Math.round(message.completionTokens);
    }
    if (message.totalTokens !== 0) {
      obj.totalTokens = Math.round(message.totalTokens);
    }
    if (message.cachedTokens !== 0) {
      obj.cachedTokens = Math.round(message.cachedTokens);
    }
    if (message.model !== "") {
      obj.model = message.model;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TokenUsage>, I>>(base?: I): TokenUsage {
    return TokenUsage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TokenUsage>, I>>(object: I): TokenUsage {
    const message = createBaseTokenUsage();
    message.promptTokens = object.promptTokens ?? 0;
    message.completionTokens = object.completionTokens ?? 0;
    message.totalTokens = object.totalTokens ?? 0;
    message.cachedTokens = object.cachedTokens ?? 0;
    message.model = object.model ?? "";
    return message;
  },
};

function createBaseAudioUsage(): AudioUsage {
  return { duration: undefined, bytesProcessed: "0", sampleRate: 0, channels: 0, format: "" };
}

export const AudioUsage = {
  encode(message: AudioUsage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.duration !== undefined) {
      Duration.encode(message.duration, writer.uint32(10).fork()).ldelim();
    }
    if (message.bytesProcessed !== "0") {
      writer.uint32(16).int64(message.bytesProcessed);
    }
    if (message.sampleRate !== 0) {
      writer.uint32(24).int32(message.sampleRate);
    }
    if (message.channels !== 0) {
      writer.uint32(32).int32(message.channels);
    }
    if (message.format !== "") {
      writer.uint32(42).string(message.format);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AudioUsage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudioUsage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.duration = Duration.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.bytesProcessed = longToString(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.sampleRate = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.channels = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.format = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudioUsage {
    return {
      duration: isSet(object.duration) ? Duration.fromJSON(object.duration) : undefined,
      bytesProcessed: isSet(object.bytesProcessed) ? globalThis.String(object.bytesProcessed) : "0",
      sampleRate: isSet(object.sampleRate) ? globalThis.Number(object.sampleRate) : 0,
      channels: isSet(object.channels) ? globalThis.Number(object.channels) : 0,
      format: isSet(object.format) ? globalThis.String(object.format) : "",
    };
  },

  toJSON(message: AudioUsage): unknown {
    const obj: any = {};
    if (message.duration !== undefined) {
      obj.duration = Duration.toJSON(message.duration);
    }
    if (message.bytesProcessed !== "0") {
      obj.bytesProcessed = message.bytesProcessed;
    }
    if (message.sampleRate !== 0) {
      obj.sampleRate = Math.round(message.sampleRate);
    }
    if (message.channels !== 0) {
      obj.channels = Math.round(message.channels);
    }
    if (message.format !== "") {
      obj.format = message.format;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AudioUsage>, I>>(base?: I): AudioUsage {
    return AudioUsage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AudioUsage>, I>>(object: I): AudioUsage {
    const message = createBaseAudioUsage();
    message.duration = (object.duration !== undefined && object.duration !== null)
      ? Duration.fromPartial(object.duration)
      : undefined;
    message.bytesProcessed = object.bytesProcessed ?? "0";
    message.sampleRate = object.sampleRate ?? 0;
    message.channels = object.channels ?? 0;
    message.format = object.format ?? "";
    return message;
  },
};

function createBaseDataUsage(): DataUsage {
  return { bytesRead: "0", bytesWritten: "0", recordsProcessed: 0, apiCalls: 0 };
}

export const DataUsage = {
  encode(message: DataUsage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.bytesRead !== "0") {
      writer.uint32(8).int64(message.bytesRead);
    }
    if (message.bytesWritten !== "0") {
      writer.uint32(16).int64(message.bytesWritten);
    }
    if (message.recordsProcessed !== 0) {
      writer.uint32(24).int32(message.recordsProcessed);
    }
    if (message.apiCalls !== 0) {
      writer.uint32(32).int32(message.apiCalls);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DataUsage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataUsage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.bytesRead = longToString(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.bytesWritten = longToString(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.recordsProcessed = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.apiCalls = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataUsage {
    return {
      bytesRead: isSet(object.bytesRead) ? globalThis.String(object.bytesRead) : "0",
      bytesWritten: isSet(object.bytesWritten) ? globalThis.String(object.bytesWritten) : "0",
      recordsProcessed: isSet(object.recordsProcessed) ? globalThis.Number(object.recordsProcessed) : 0,
      apiCalls: isSet(object.apiCalls) ? globalThis.Number(object.apiCalls) : 0,
    };
  },

  toJSON(message: DataUsage): unknown {
    const obj: any = {};
    if (message.bytesRead !== "0") {
      obj.bytesRead = message.bytesRead;
    }
    if (message.bytesWritten !== "0") {
      obj.bytesWritten = message.bytesWritten;
    }
    if (message.recordsProcessed !== 0) {
      obj.recordsProcessed = Math.round(message.recordsProcessed);
    }
    if (message.apiCalls !== 0) {
      obj.apiCalls = Math.round(message.apiCalls);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DataUsage>, I>>(base?: I): DataUsage {
    return DataUsage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DataUsage>, I>>(object: I): DataUsage {
    const message = createBaseDataUsage();
    message.bytesRead = object.bytesRead ?? "0";
    message.bytesWritten = object.bytesWritten ?? "0";
    message.recordsProcessed = object.recordsProcessed ?? 0;
    message.apiCalls = object.apiCalls ?? 0;
    return message;
  },
};

function createBaseComputeUsage(): ComputeUsage {
  return { cpuTime: undefined, memoryBytes: "0", storageBytes: "0", gpuSeconds: 0 };
}

export const ComputeUsage = {
  encode(message: ComputeUsage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.cpuTime !== undefined) {
      Duration.encode(message.cpuTime, writer.uint32(10).fork()).ldelim();
    }
    if (message.memoryBytes !== "0") {
      writer.uint32(16).int64(message.memoryBytes);
    }
    if (message.storageBytes !== "0") {
      writer.uint32(24).int64(message.storageBytes);
    }
    if (message.gpuSeconds !== 0) {
      writer.uint32(32).int32(message.gpuSeconds);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ComputeUsage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComputeUsage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cpuTime = Duration.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.memoryBytes = longToString(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.storageBytes = longToString(reader.int64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.gpuSeconds = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComputeUsage {
    return {
      cpuTime: isSet(object.cpuTime) ? Duration.fromJSON(object.cpuTime) : undefined,
      memoryBytes: isSet(object.memoryBytes) ? globalThis.String(object.memoryBytes) : "0",
      storageBytes: isSet(object.storageBytes) ? globalThis.String(object.storageBytes) : "0",
      gpuSeconds: isSet(object.gpuSeconds) ? globalThis.Number(object.gpuSeconds) : 0,
    };
  },

  toJSON(message: ComputeUsage): unknown {
    const obj: any = {};
    if (message.cpuTime !== undefined) {
      obj.cpuTime = Duration.toJSON(message.cpuTime);
    }
    if (message.memoryBytes !== "0") {
      obj.memoryBytes = message.memoryBytes;
    }
    if (message.storageBytes !== "0") {
      obj.storageBytes = message.storageBytes;
    }
    if (message.gpuSeconds !== 0) {
      obj.gpuSeconds = Math.round(message.gpuSeconds);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ComputeUsage>, I>>(base?: I): ComputeUsage {
    return ComputeUsage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ComputeUsage>, I>>(object: I): ComputeUsage {
    const message = createBaseComputeUsage();
    message.cpuTime = (object.cpuTime !== undefined && object.cpuTime !== null)
      ? Duration.fromPartial(object.cpuTime)
      : undefined;
    message.memoryBytes = object.memoryBytes ?? "0";
    message.storageBytes = object.storageBytes ?? "0";
    message.gpuSeconds = object.gpuSeconds ?? 0;
    return message;
  },
};

function createBaseAttachment(): Attachment {
  return {
    attachmentId: "",
    type: 0,
    url: "",
    filename: "",
    sizeBytes: "0",
    mimeType: "",
    thumbnailUrl: "",
    metadata: undefined,
    uploadedAt: undefined,
    uploadedBy: "",
  };
}

export const Attachment = {
  encode(message: Attachment, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.attachmentId !== "") {
      writer.uint32(10).string(message.attachmentId);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.url !== "") {
      writer.uint32(26).string(message.url);
    }
    if (message.filename !== "") {
      writer.uint32(34).string(message.filename);
    }
    if (message.sizeBytes !== "0") {
      writer.uint32(40).int64(message.sizeBytes);
    }
    if (message.mimeType !== "") {
      writer.uint32(50).string(message.mimeType);
    }
    if (message.thumbnailUrl !== "") {
      writer.uint32(58).string(message.thumbnailUrl);
    }
    if (message.metadata !== undefined) {
      Struct.encode(Struct.wrap(message.metadata), writer.uint32(66).fork()).ldelim();
    }
    if (message.uploadedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.uploadedAt), writer.uint32(74).fork()).ldelim();
    }
    if (message.uploadedBy !== "") {
      writer.uint32(82).string(message.uploadedBy);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Attachment {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttachment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.attachmentId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.url = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filename = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.sizeBytes = longToString(reader.int64() as Long);
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.mimeType = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.thumbnailUrl = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.metadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.uploadedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.uploadedBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Attachment {
    return {
      attachmentId: isSet(object.attachmentId) ? globalThis.String(object.attachmentId) : "",
      type: isSet(object.type) ? attachmentTypeFromJSON(object.type) : 0,
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      filename: isSet(object.filename) ? globalThis.String(object.filename) : "",
      sizeBytes: isSet(object.sizeBytes) ? globalThis.String(object.sizeBytes) : "0",
      mimeType: isSet(object.mimeType) ? globalThis.String(object.mimeType) : "",
      thumbnailUrl: isSet(object.thumbnailUrl) ? globalThis.String(object.thumbnailUrl) : "",
      metadata: isObject(object.metadata) ? object.metadata : undefined,
      uploadedAt: isSet(object.uploadedAt) ? fromJsonTimestamp(object.uploadedAt) : undefined,
      uploadedBy: isSet(object.uploadedBy) ? globalThis.String(object.uploadedBy) : "",
    };
  },

  toJSON(message: Attachment): unknown {
    const obj: any = {};
    if (message.attachmentId !== "") {
      obj.attachmentId = message.attachmentId;
    }
    if (message.type !== 0) {
      obj.type = attachmentTypeToJSON(message.type);
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.filename !== "") {
      obj.filename = message.filename;
    }
    if (message.sizeBytes !== "0") {
      obj.sizeBytes = message.sizeBytes;
    }
    if (message.mimeType !== "") {
      obj.mimeType = message.mimeType;
    }
    if (message.thumbnailUrl !== "") {
      obj.thumbnailUrl = message.thumbnailUrl;
    }
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    if (message.uploadedAt !== undefined) {
      obj.uploadedAt = message.uploadedAt.toISOString();
    }
    if (message.uploadedBy !== "") {
      obj.uploadedBy = message.uploadedBy;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Attachment>, I>>(base?: I): Attachment {
    return Attachment.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Attachment>, I>>(object: I): Attachment {
    const message = createBaseAttachment();
    message.attachmentId = object.attachmentId ?? "";
    message.type = object.type ?? 0;
    message.url = object.url ?? "";
    message.filename = object.filename ?? "";
    message.sizeBytes = object.sizeBytes ?? "0";
    message.mimeType = object.mimeType ?? "";
    message.thumbnailUrl = object.thumbnailUrl ?? "";
    message.metadata = object.metadata ?? undefined;
    message.uploadedAt = object.uploadedAt ?? undefined;
    message.uploadedBy = object.uploadedBy ?? "";
    return message;
  },
};

function createBaseError(): Error {
  return { code: 0, message: "", details: "", fieldErrors: [], debugInfo: undefined, requestId: "" };
}

export const Error = {
  encode(message: Error, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.code !== 0) {
      writer.uint32(8).int32(message.code);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.details !== "") {
      writer.uint32(26).string(message.details);
    }
    for (const v of message.fieldErrors) {
      ErrorField.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    if (message.debugInfo !== undefined) {
      Struct.encode(Struct.wrap(message.debugInfo), writer.uint32(42).fork()).ldelim();
    }
    if (message.requestId !== "") {
      writer.uint32(50).string(message.requestId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Error {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.code = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.details = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.fieldErrors.push(ErrorField.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.debugInfo = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Error {
    return {
      code: isSet(object.code) ? errorCodeFromJSON(object.code) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      details: isSet(object.details) ? globalThis.String(object.details) : "",
      fieldErrors: globalThis.Array.isArray(object?.fieldErrors)
        ? object.fieldErrors.map((e: any) => ErrorField.fromJSON(e))
        : [],
      debugInfo: isObject(object.debugInfo) ? object.debugInfo : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: Error): unknown {
    const obj: any = {};
    if (message.code !== 0) {
      obj.code = errorCodeToJSON(message.code);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.details !== "") {
      obj.details = message.details;
    }
    if (message.fieldErrors?.length) {
      obj.fieldErrors = message.fieldErrors.map((e) => ErrorField.toJSON(e));
    }
    if (message.debugInfo !== undefined) {
      obj.debugInfo = message.debugInfo;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Error>, I>>(base?: I): Error {
    return Error.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Error>, I>>(object: I): Error {
    const message = createBaseError();
    message.code = object.code ?? 0;
    message.message = object.message ?? "";
    message.details = object.details ?? "";
    message.fieldErrors = object.fieldErrors?.map((e) => ErrorField.fromPartial(e)) || [];
    message.debugInfo = object.debugInfo ?? undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseErrorField(): ErrorField {
  return { field: "", message: "", code: "" };
}

export const ErrorField = {
  encode(message: ErrorField, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.field !== "") {
      writer.uint32(10).string(message.field);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.code !== "") {
      writer.uint32(26).string(message.code);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ErrorField {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseErrorField();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.field = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.code = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ErrorField {
    return {
      field: isSet(object.field) ? globalThis.String(object.field) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      code: isSet(object.code) ? globalThis.String(object.code) : "",
    };
  },

  toJSON(message: ErrorField): unknown {
    const obj: any = {};
    if (message.field !== "") {
      obj.field = message.field;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.code !== "") {
      obj.code = message.code;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ErrorField>, I>>(base?: I): ErrorField {
    return ErrorField.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ErrorField>, I>>(object: I): ErrorField {
    const message = createBaseErrorField();
    message.field = object.field ?? "";
    message.message = object.message ?? "";
    message.code = object.code ?? "";
    return message;
  },
};

function createBaseFilter(): Filter {
  return { field: "", operator: 0, value: "", values: [] };
}

export const Filter = {
  encode(message: Filter, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.field !== "") {
      writer.uint32(10).string(message.field);
    }
    if (message.operator !== 0) {
      writer.uint32(16).int32(message.operator);
    }
    if (message.value !== "") {
      writer.uint32(26).string(message.value);
    }
    for (const v of message.values) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Filter {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.field = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.operator = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.value = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.values.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Filter {
    return {
      field: isSet(object.field) ? globalThis.String(object.field) : "",
      operator: isSet(object.operator) ? filterOperatorFromJSON(object.operator) : 0,
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: Filter): unknown {
    const obj: any = {};
    if (message.field !== "") {
      obj.field = message.field;
    }
    if (message.operator !== 0) {
      obj.operator = filterOperatorToJSON(message.operator);
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.values?.length) {
      obj.values = message.values;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Filter>, I>>(base?: I): Filter {
    return Filter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Filter>, I>>(object: I): Filter {
    const message = createBaseFilter();
    message.field = object.field ?? "";
    message.operator = object.operator ?? 0;
    message.value = object.value ?? "";
    message.values = object.values?.map((e) => e) || [];
    return message;
  },
};

function createBaseHealthCheckRequest(): HealthCheckRequest {
  return { service: "", includeDependencies: false };
}

export const HealthCheckRequest = {
  encode(message: HealthCheckRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.service !== "") {
      writer.uint32(10).string(message.service);
    }
    if (message.includeDependencies !== false) {
      writer.uint32(16).bool(message.includeDependencies);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HealthCheckRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheckRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.service = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.includeDependencies = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthCheckRequest {
    return {
      service: isSet(object.service) ? globalThis.String(object.service) : "",
      includeDependencies: isSet(object.includeDependencies) ? globalThis.Boolean(object.includeDependencies) : false,
    };
  },

  toJSON(message: HealthCheckRequest): unknown {
    const obj: any = {};
    if (message.service !== "") {
      obj.service = message.service;
    }
    if (message.includeDependencies !== false) {
      obj.includeDependencies = message.includeDependencies;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthCheckRequest>, I>>(base?: I): HealthCheckRequest {
    return HealthCheckRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthCheckRequest>, I>>(object: I): HealthCheckRequest {
    const message = createBaseHealthCheckRequest();
    message.service = object.service ?? "";
    message.includeDependencies = object.includeDependencies ?? false;
    return message;
  },
};

function createBaseHealthCheckResponse(): HealthCheckResponse {
  return { status: 0, message: "", details: {}, checkedAt: undefined, responseTime: undefined };
}

export const HealthCheckResponse = {
  encode(message: HealthCheckResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    Object.entries(message.details).forEach(([key, value]) => {
      HealthCheckResponse_DetailsEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).ldelim();
    });
    if (message.checkedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.checkedAt), writer.uint32(34).fork()).ldelim();
    }
    if (message.responseTime !== undefined) {
      Duration.encode(message.responseTime, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HealthCheckResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheckResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = HealthCheckResponse_DetailsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.details[entry3.key] = entry3.value;
          }
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.checkedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.responseTime = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthCheckResponse {
    return {
      status: isSet(object.status) ? healthStatusFromJSON(object.status) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      details: isObject(object.details)
        ? Object.entries(object.details).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      checkedAt: isSet(object.checkedAt) ? fromJsonTimestamp(object.checkedAt) : undefined,
      responseTime: isSet(object.responseTime) ? Duration.fromJSON(object.responseTime) : undefined,
    };
  },

  toJSON(message: HealthCheckResponse): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = healthStatusToJSON(message.status);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.details) {
      const entries = Object.entries(message.details);
      if (entries.length > 0) {
        obj.details = {};
        entries.forEach(([k, v]) => {
          obj.details[k] = v;
        });
      }
    }
    if (message.checkedAt !== undefined) {
      obj.checkedAt = message.checkedAt.toISOString();
    }
    if (message.responseTime !== undefined) {
      obj.responseTime = Duration.toJSON(message.responseTime);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthCheckResponse>, I>>(base?: I): HealthCheckResponse {
    return HealthCheckResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthCheckResponse>, I>>(object: I): HealthCheckResponse {
    const message = createBaseHealthCheckResponse();
    message.status = object.status ?? 0;
    message.message = object.message ?? "";
    message.details = Object.entries(object.details ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.checkedAt = object.checkedAt ?? undefined;
    message.responseTime = (object.responseTime !== undefined && object.responseTime !== null)
      ? Duration.fromPartial(object.responseTime)
      : undefined;
    return message;
  },
};

function createBaseHealthCheckResponse_DetailsEntry(): HealthCheckResponse_DetailsEntry {
  return { key: "", value: "" };
}

export const HealthCheckResponse_DetailsEntry = {
  encode(message: HealthCheckResponse_DetailsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HealthCheckResponse_DetailsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheckResponse_DetailsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthCheckResponse_DetailsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: HealthCheckResponse_DetailsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthCheckResponse_DetailsEntry>, I>>(
    base?: I,
  ): HealthCheckResponse_DetailsEntry {
    return HealthCheckResponse_DetailsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthCheckResponse_DetailsEntry>, I>>(
    object: I,
  ): HealthCheckResponse_DetailsEntry {
    const message = createBaseHealthCheckResponse_DetailsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseStandardResponse(): StandardResponse {
  return { success: false, message: "", error: undefined, metadata: undefined, requestId: "" };
}

export const StandardResponse = {
  encode(message: StandardResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(26).fork()).ldelim();
    }
    if (message.metadata !== undefined) {
      Struct.encode(Struct.wrap(message.metadata), writer.uint32(34).fork()).ldelim();
    }
    if (message.requestId !== "") {
      writer.uint32(42).string(message.requestId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StandardResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStandardResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.metadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StandardResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      metadata: isObject(object.metadata) ? object.metadata : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: StandardResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StandardResponse>, I>>(base?: I): StandardResponse {
    return StandardResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StandardResponse>, I>>(object: I): StandardResponse {
    const message = createBaseStandardResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    message.metadata = object.metadata ?? undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseAuditInfo(): AuditInfo {
  return {
    userId: "",
    sessionId: "",
    ipAddress: "",
    userAgent: "",
    timestamp: undefined,
    action: "",
    context: undefined,
  };
}

export const AuditInfo = {
  encode(message: AuditInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.sessionId !== "") {
      writer.uint32(18).string(message.sessionId);
    }
    if (message.ipAddress !== "") {
      writer.uint32(26).string(message.ipAddress);
    }
    if (message.userAgent !== "") {
      writer.uint32(34).string(message.userAgent);
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(42).fork()).ldelim();
    }
    if (message.action !== "") {
      writer.uint32(50).string(message.action);
    }
    if (message.context !== undefined) {
      Struct.encode(Struct.wrap(message.context), writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AuditInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuditInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.ipAddress = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.userAgent = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.action = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.context = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuditInfo {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      ipAddress: isSet(object.ipAddress) ? globalThis.String(object.ipAddress) : "",
      userAgent: isSet(object.userAgent) ? globalThis.String(object.userAgent) : "",
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      action: isSet(object.action) ? globalThis.String(object.action) : "",
      context: isObject(object.context) ? object.context : undefined,
    };
  },

  toJSON(message: AuditInfo): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.ipAddress !== "") {
      obj.ipAddress = message.ipAddress;
    }
    if (message.userAgent !== "") {
      obj.userAgent = message.userAgent;
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    if (message.context !== undefined) {
      obj.context = message.context;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuditInfo>, I>>(base?: I): AuditInfo {
    return AuditInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuditInfo>, I>>(object: I): AuditInfo {
    const message = createBaseAuditInfo();
    message.userId = object.userId ?? "";
    message.sessionId = object.sessionId ?? "";
    message.ipAddress = object.ipAddress ?? "";
    message.userAgent = object.userAgent ?? "";
    message.timestamp = object.timestamp ?? undefined;
    message.action = object.action ?? "";
    message.context = object.context ?? undefined;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000).toString();
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (globalThis.Number(t.seconds) || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToString(long: Long) {
  return long.toString();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
