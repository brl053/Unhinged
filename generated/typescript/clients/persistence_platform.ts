// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v3.21.12
// source: persistence_platform.proto

/* eslint-disable */
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Any } from "./google/protobuf/any";
import { Struct } from "./google/protobuf/struct";
import { Timestamp } from "./google/protobuf/timestamp";

export enum QueryType {
  POINT_LOOKUP = 0,
  RANGE_SCAN = 1,
  FULL_TEXT_SEARCH = 2,
  VECTOR_SIMILARITY = 3,
  GRAPH_TRAVERSAL = 4,
  AGGREGATION = 5,
  TIME_SERIES = 6,
  GEOSPATIAL = 7,
  DOCUMENT_QUERY = 8,
  UNRECOGNIZED = -1,
}

export function queryTypeFromJSON(object: any): QueryType {
  switch (object) {
    case 0:
    case "POINT_LOOKUP":
      return QueryType.POINT_LOOKUP;
    case 1:
    case "RANGE_SCAN":
      return QueryType.RANGE_SCAN;
    case 2:
    case "FULL_TEXT_SEARCH":
      return QueryType.FULL_TEXT_SEARCH;
    case 3:
    case "VECTOR_SIMILARITY":
      return QueryType.VECTOR_SIMILARITY;
    case 4:
    case "GRAPH_TRAVERSAL":
      return QueryType.GRAPH_TRAVERSAL;
    case 5:
    case "AGGREGATION":
      return QueryType.AGGREGATION;
    case 6:
    case "TIME_SERIES":
      return QueryType.TIME_SERIES;
    case 7:
    case "GEOSPATIAL":
      return QueryType.GEOSPATIAL;
    case 8:
    case "DOCUMENT_QUERY":
      return QueryType.DOCUMENT_QUERY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return QueryType.UNRECOGNIZED;
  }
}

export function queryTypeToJSON(object: QueryType): string {
  switch (object) {
    case QueryType.POINT_LOOKUP:
      return "POINT_LOOKUP";
    case QueryType.RANGE_SCAN:
      return "RANGE_SCAN";
    case QueryType.FULL_TEXT_SEARCH:
      return "FULL_TEXT_SEARCH";
    case QueryType.VECTOR_SIMILARITY:
      return "VECTOR_SIMILARITY";
    case QueryType.GRAPH_TRAVERSAL:
      return "GRAPH_TRAVERSAL";
    case QueryType.AGGREGATION:
      return "AGGREGATION";
    case QueryType.TIME_SERIES:
      return "TIME_SERIES";
    case QueryType.GEOSPATIAL:
      return "GEOSPATIAL";
    case QueryType.DOCUMENT_QUERY:
      return "DOCUMENT_QUERY";
    case QueryType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum GraphTraversalType {
  BREADTH_FIRST = 0,
  DEPTH_FIRST = 1,
  SHORTEST_PATH = 2,
  ALL_PATHS = 3,
  UNRECOGNIZED = -1,
}

export function graphTraversalTypeFromJSON(object: any): GraphTraversalType {
  switch (object) {
    case 0:
    case "BREADTH_FIRST":
      return GraphTraversalType.BREADTH_FIRST;
    case 1:
    case "DEPTH_FIRST":
      return GraphTraversalType.DEPTH_FIRST;
    case 2:
    case "SHORTEST_PATH":
      return GraphTraversalType.SHORTEST_PATH;
    case 3:
    case "ALL_PATHS":
      return GraphTraversalType.ALL_PATHS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GraphTraversalType.UNRECOGNIZED;
  }
}

export function graphTraversalTypeToJSON(object: GraphTraversalType): string {
  switch (object) {
    case GraphTraversalType.BREADTH_FIRST:
      return "BREADTH_FIRST";
    case GraphTraversalType.DEPTH_FIRST:
      return "DEPTH_FIRST";
    case GraphTraversalType.SHORTEST_PATH:
      return "SHORTEST_PATH";
    case GraphTraversalType.ALL_PATHS:
      return "ALL_PATHS";
    case GraphTraversalType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Core execution context for all operations */
export interface ExecutionContext {
  requestId: string;
  userId: string;
  sessionId: string;
  traceId: string;
  spanId: string;
  timestamp?: Date | undefined;
  metadata?: { [key: string]: any } | undefined;
}

/** Generic record structure */
export interface Record {
  id: string;
  data?: { [key: string]: any } | undefined;
  createdAt?: Date | undefined;
  updatedAt?: Date | undefined;
  version: string;
}

/** Query criteria */
export interface QueryCriteria {
  equals?: EqualsFilter | undefined;
  greaterThan?: GreaterThanFilter | undefined;
  lessThan?: LessThanFilter | undefined;
  inFilter?: InFilter | undefined;
  range?: RangeFilter | undefined;
  textSearch?: TextSearchFilter | undefined;
  vectorSearch?: VectorSearchFilter | undefined;
  andFilter?: AndFilter | undefined;
  orFilter?: OrFilter | undefined;
}

export interface EqualsFilter {
  field: string;
  value?: Any | undefined;
}

export interface GreaterThanFilter {
  field: string;
  value?: Any | undefined;
}

export interface LessThanFilter {
  field: string;
  value?: Any | undefined;
}

export interface InFilter {
  field: string;
  values: Any[];
}

export interface RangeFilter {
  field: string;
  minValue?: Any | undefined;
  maxValue?: Any | undefined;
}

export interface TextSearchFilter {
  fields: string[];
  query: string;
  analyzer: string;
}

export interface VectorSearchFilter {
  field: string;
  queryVector: number[];
  limit: number;
  threshold: number;
  distanceMetric: string;
}

export interface AndFilter {
  filters: QueryCriteria[];
}

export interface OrFilter {
  filters: QueryCriteria[];
}

/** Order by specification */
export interface OrderBy {
  field: string;
  ascending: boolean;
}

/** Query specification */
export interface QuerySpec {
  tableName: string;
  queryType: QueryType;
  criteria?: QueryCriteria | undefined;
  projections: string[];
  orderBy: OrderBy[];
  limit: number;
  offset: number;
}

/** CRUD Operations */
export interface InsertRequest {
  tableName: string;
  record?: Record | undefined;
  context?: ExecutionContext | undefined;
}

export interface InsertResponse {
  success: boolean;
  record?: Record | undefined;
  errorMessage: string;
  executionTimeMs: string;
}

export interface InsertBatchRequest {
  tableName: string;
  records: Record[];
  context?: ExecutionContext | undefined;
}

export interface InsertBatchResponse {
  success: boolean;
  records: Record[];
  insertedCount: number;
  errorMessage: string;
  executionTimeMs: string;
}

export interface UpdateRequest {
  tableName: string;
  id: string;
  updates?: { [key: string]: any } | undefined;
  context?: ExecutionContext | undefined;
}

export interface UpdateResponse {
  success: boolean;
  record?: Record | undefined;
  errorMessage: string;
  executionTimeMs: string;
}

export interface DeleteRequest {
  tableName: string;
  criteria?: QueryCriteria | undefined;
  context?: ExecutionContext | undefined;
}

export interface DeleteResponse {
  success: boolean;
  deletedCount: string;
  errorMessage: string;
  executionTimeMs: string;
}

/** Query Operations */
export interface ExecuteQueryRequest {
  queryName: string;
  parameters?: { [key: string]: any } | undefined;
  context?: ExecutionContext | undefined;
}

export interface ExecuteQueryResponse {
  success: boolean;
  results: Record[];
  count: number;
  errorMessage: string;
  executionTimeMs: string;
  fromCache: boolean;
}

export interface ExecuteRawQueryRequest {
  querySpec?: QuerySpec | undefined;
  context?: ExecutionContext | undefined;
}

export interface ExecuteRawQueryResponse {
  success: boolean;
  results: Record[];
  count: number;
  errorMessage: string;
  executionTimeMs: string;
}

/** Vector Operations */
export interface VectorSearchRequest {
  tableName: string;
  queryVector: number[];
  limit: number;
  threshold: number;
  distanceMetric: string;
  context?: ExecutionContext | undefined;
}

export interface VectorSearchResponse {
  success: boolean;
  results: VectorSearchResult[];
  errorMessage: string;
  executionTimeMs: string;
}

export interface VectorSearchResult {
  record?: Record | undefined;
  similarityScore: number;
  distance: number;
}

/** Graph Operations */
export interface GraphTraverseRequest {
  tableName: string;
  startNode: string;
  traversalSpec?: GraphTraversalSpec | undefined;
  context?: ExecutionContext | undefined;
}

export interface GraphTraverseResponse {
  success: boolean;
  nodes: GraphNode[];
  edges: GraphEdge[];
  errorMessage: string;
  executionTimeMs: string;
}

export interface GraphTraversalSpec {
  traversalType: GraphTraversalType;
  maxDepth: number;
  relationshipTypes: string[];
  nodeFilter?: QueryCriteria | undefined;
  edgeFilter?: QueryCriteria | undefined;
}

export interface GraphNode {
  id: string;
  label: string;
  properties?: { [key: string]: any } | undefined;
}

export interface GraphEdge {
  id: string;
  sourceId: string;
  targetId: string;
  relationshipType: string;
  properties?: { [key: string]: any } | undefined;
}

/** Complex Operations */
export interface ExecuteOperationRequest {
  operationName: string;
  parameters?: { [key: string]: any } | undefined;
  context?: ExecutionContext | undefined;
}

export interface ExecuteOperationResponse {
  success: boolean;
  result?: Any | undefined;
  errorMessage: string;
  executionTimeMs: string;
  affectedTables: string[];
}

/** Health and Status */
export interface HealthCheckRequest {
  includeDetails: boolean;
}

export interface HealthCheckResponse {
  healthy: boolean;
  version: string;
  uptimeSeconds: string;
  technologyHealth: TechnologyHealth[];
}

export interface TechnologyHealth {
  technology: string;
  healthy: boolean;
  status: string;
  responseTimeMs: string;
  errorMessage: string;
}

/** Platform Information */
export interface GetPlatformInfoRequest {
}

export interface GetPlatformInfoResponse {
  platformName: string;
  version: string;
  supportedTechnologies: string[];
  supportedFeatures: string[];
  configuration?: { [key: string]: any } | undefined;
}

/** Metrics */
export interface GetMetricsRequest {
  /** "prometheus", "json" */
  format: string;
}

export interface GetMetricsResponse {
  format: string;
  metricsData: string;
  collectedAt?: Date | undefined;
}

function createBaseExecutionContext(): ExecutionContext {
  return {
    requestId: "",
    userId: "",
    sessionId: "",
    traceId: "",
    spanId: "",
    timestamp: undefined,
    metadata: undefined,
  };
}

export const ExecutionContext = {
  encode(message: ExecutionContext, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.sessionId !== "") {
      writer.uint32(26).string(message.sessionId);
    }
    if (message.traceId !== "") {
      writer.uint32(34).string(message.traceId);
    }
    if (message.spanId !== "") {
      writer.uint32(42).string(message.spanId);
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(50).fork()).ldelim();
    }
    if (message.metadata !== undefined) {
      Struct.encode(Struct.wrap(message.metadata), writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExecutionContext {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecutionContext();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.traceId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.spanId = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.metadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecutionContext {
    return {
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      traceId: isSet(object.traceId) ? globalThis.String(object.traceId) : "",
      spanId: isSet(object.spanId) ? globalThis.String(object.spanId) : "",
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      metadata: isObject(object.metadata) ? object.metadata : undefined,
    };
  },

  toJSON(message: ExecutionContext): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.traceId !== "") {
      obj.traceId = message.traceId;
    }
    if (message.spanId !== "") {
      obj.spanId = message.spanId;
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExecutionContext>, I>>(base?: I): ExecutionContext {
    return ExecutionContext.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExecutionContext>, I>>(object: I): ExecutionContext {
    const message = createBaseExecutionContext();
    message.requestId = object.requestId ?? "";
    message.userId = object.userId ?? "";
    message.sessionId = object.sessionId ?? "";
    message.traceId = object.traceId ?? "";
    message.spanId = object.spanId ?? "";
    message.timestamp = object.timestamp ?? undefined;
    message.metadata = object.metadata ?? undefined;
    return message;
  },
};

function createBaseRecord(): Record {
  return { id: "", data: undefined, createdAt: undefined, updatedAt: undefined, version: "" };
}

export const Record = {
  encode(message: Record, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.data !== undefined) {
      Struct.encode(Struct.wrap(message.data), writer.uint32(18).fork()).ldelim();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(26).fork()).ldelim();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(34).fork()).ldelim();
    }
    if (message.version !== "") {
      writer.uint32(42).string(message.version);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Record {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.data = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.version = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Record {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      data: isObject(object.data) ? object.data : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      version: isSet(object.version) ? globalThis.String(object.version) : "",
    };
  },

  toJSON(message: Record): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.data !== undefined) {
      obj.data = message.data;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Record>, I>>(base?: I): Record {
    return Record.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Record>, I>>(object: I): Record {
    const message = createBaseRecord();
    message.id = object.id ?? "";
    message.data = object.data ?? undefined;
    message.createdAt = object.createdAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    message.version = object.version ?? "";
    return message;
  },
};

function createBaseQueryCriteria(): QueryCriteria {
  return {
    equals: undefined,
    greaterThan: undefined,
    lessThan: undefined,
    inFilter: undefined,
    range: undefined,
    textSearch: undefined,
    vectorSearch: undefined,
    andFilter: undefined,
    orFilter: undefined,
  };
}

export const QueryCriteria = {
  encode(message: QueryCriteria, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.equals !== undefined) {
      EqualsFilter.encode(message.equals, writer.uint32(10).fork()).ldelim();
    }
    if (message.greaterThan !== undefined) {
      GreaterThanFilter.encode(message.greaterThan, writer.uint32(18).fork()).ldelim();
    }
    if (message.lessThan !== undefined) {
      LessThanFilter.encode(message.lessThan, writer.uint32(26).fork()).ldelim();
    }
    if (message.inFilter !== undefined) {
      InFilter.encode(message.inFilter, writer.uint32(34).fork()).ldelim();
    }
    if (message.range !== undefined) {
      RangeFilter.encode(message.range, writer.uint32(42).fork()).ldelim();
    }
    if (message.textSearch !== undefined) {
      TextSearchFilter.encode(message.textSearch, writer.uint32(50).fork()).ldelim();
    }
    if (message.vectorSearch !== undefined) {
      VectorSearchFilter.encode(message.vectorSearch, writer.uint32(58).fork()).ldelim();
    }
    if (message.andFilter !== undefined) {
      AndFilter.encode(message.andFilter, writer.uint32(66).fork()).ldelim();
    }
    if (message.orFilter !== undefined) {
      OrFilter.encode(message.orFilter, writer.uint32(74).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryCriteria {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryCriteria();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.equals = EqualsFilter.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.greaterThan = GreaterThanFilter.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.lessThan = LessThanFilter.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.inFilter = InFilter.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.range = RangeFilter.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.textSearch = TextSearchFilter.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.vectorSearch = VectorSearchFilter.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.andFilter = AndFilter.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.orFilter = OrFilter.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryCriteria {
    return {
      equals: isSet(object.equals) ? EqualsFilter.fromJSON(object.equals) : undefined,
      greaterThan: isSet(object.greaterThan) ? GreaterThanFilter.fromJSON(object.greaterThan) : undefined,
      lessThan: isSet(object.lessThan) ? LessThanFilter.fromJSON(object.lessThan) : undefined,
      inFilter: isSet(object.inFilter) ? InFilter.fromJSON(object.inFilter) : undefined,
      range: isSet(object.range) ? RangeFilter.fromJSON(object.range) : undefined,
      textSearch: isSet(object.textSearch) ? TextSearchFilter.fromJSON(object.textSearch) : undefined,
      vectorSearch: isSet(object.vectorSearch) ? VectorSearchFilter.fromJSON(object.vectorSearch) : undefined,
      andFilter: isSet(object.andFilter) ? AndFilter.fromJSON(object.andFilter) : undefined,
      orFilter: isSet(object.orFilter) ? OrFilter.fromJSON(object.orFilter) : undefined,
    };
  },

  toJSON(message: QueryCriteria): unknown {
    const obj: any = {};
    if (message.equals !== undefined) {
      obj.equals = EqualsFilter.toJSON(message.equals);
    }
    if (message.greaterThan !== undefined) {
      obj.greaterThan = GreaterThanFilter.toJSON(message.greaterThan);
    }
    if (message.lessThan !== undefined) {
      obj.lessThan = LessThanFilter.toJSON(message.lessThan);
    }
    if (message.inFilter !== undefined) {
      obj.inFilter = InFilter.toJSON(message.inFilter);
    }
    if (message.range !== undefined) {
      obj.range = RangeFilter.toJSON(message.range);
    }
    if (message.textSearch !== undefined) {
      obj.textSearch = TextSearchFilter.toJSON(message.textSearch);
    }
    if (message.vectorSearch !== undefined) {
      obj.vectorSearch = VectorSearchFilter.toJSON(message.vectorSearch);
    }
    if (message.andFilter !== undefined) {
      obj.andFilter = AndFilter.toJSON(message.andFilter);
    }
    if (message.orFilter !== undefined) {
      obj.orFilter = OrFilter.toJSON(message.orFilter);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryCriteria>, I>>(base?: I): QueryCriteria {
    return QueryCriteria.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryCriteria>, I>>(object: I): QueryCriteria {
    const message = createBaseQueryCriteria();
    message.equals = (object.equals !== undefined && object.equals !== null)
      ? EqualsFilter.fromPartial(object.equals)
      : undefined;
    message.greaterThan = (object.greaterThan !== undefined && object.greaterThan !== null)
      ? GreaterThanFilter.fromPartial(object.greaterThan)
      : undefined;
    message.lessThan = (object.lessThan !== undefined && object.lessThan !== null)
      ? LessThanFilter.fromPartial(object.lessThan)
      : undefined;
    message.inFilter = (object.inFilter !== undefined && object.inFilter !== null)
      ? InFilter.fromPartial(object.inFilter)
      : undefined;
    message.range = (object.range !== undefined && object.range !== null)
      ? RangeFilter.fromPartial(object.range)
      : undefined;
    message.textSearch = (object.textSearch !== undefined && object.textSearch !== null)
      ? TextSearchFilter.fromPartial(object.textSearch)
      : undefined;
    message.vectorSearch = (object.vectorSearch !== undefined && object.vectorSearch !== null)
      ? VectorSearchFilter.fromPartial(object.vectorSearch)
      : undefined;
    message.andFilter = (object.andFilter !== undefined && object.andFilter !== null)
      ? AndFilter.fromPartial(object.andFilter)
      : undefined;
    message.orFilter = (object.orFilter !== undefined && object.orFilter !== null)
      ? OrFilter.fromPartial(object.orFilter)
      : undefined;
    return message;
  },
};

function createBaseEqualsFilter(): EqualsFilter {
  return { field: "", value: undefined };
}

export const EqualsFilter = {
  encode(message: EqualsFilter, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.field !== "") {
      writer.uint32(10).string(message.field);
    }
    if (message.value !== undefined) {
      Any.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EqualsFilter {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEqualsFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.field = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Any.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EqualsFilter {
    return {
      field: isSet(object.field) ? globalThis.String(object.field) : "",
      value: isSet(object.value) ? Any.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: EqualsFilter): unknown {
    const obj: any = {};
    if (message.field !== "") {
      obj.field = message.field;
    }
    if (message.value !== undefined) {
      obj.value = Any.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EqualsFilter>, I>>(base?: I): EqualsFilter {
    return EqualsFilter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EqualsFilter>, I>>(object: I): EqualsFilter {
    const message = createBaseEqualsFilter();
    message.field = object.field ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Any.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseGreaterThanFilter(): GreaterThanFilter {
  return { field: "", value: undefined };
}

export const GreaterThanFilter = {
  encode(message: GreaterThanFilter, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.field !== "") {
      writer.uint32(10).string(message.field);
    }
    if (message.value !== undefined) {
      Any.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GreaterThanFilter {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGreaterThanFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.field = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Any.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GreaterThanFilter {
    return {
      field: isSet(object.field) ? globalThis.String(object.field) : "",
      value: isSet(object.value) ? Any.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: GreaterThanFilter): unknown {
    const obj: any = {};
    if (message.field !== "") {
      obj.field = message.field;
    }
    if (message.value !== undefined) {
      obj.value = Any.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GreaterThanFilter>, I>>(base?: I): GreaterThanFilter {
    return GreaterThanFilter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GreaterThanFilter>, I>>(object: I): GreaterThanFilter {
    const message = createBaseGreaterThanFilter();
    message.field = object.field ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Any.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseLessThanFilter(): LessThanFilter {
  return { field: "", value: undefined };
}

export const LessThanFilter = {
  encode(message: LessThanFilter, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.field !== "") {
      writer.uint32(10).string(message.field);
    }
    if (message.value !== undefined) {
      Any.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LessThanFilter {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLessThanFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.field = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Any.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LessThanFilter {
    return {
      field: isSet(object.field) ? globalThis.String(object.field) : "",
      value: isSet(object.value) ? Any.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: LessThanFilter): unknown {
    const obj: any = {};
    if (message.field !== "") {
      obj.field = message.field;
    }
    if (message.value !== undefined) {
      obj.value = Any.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LessThanFilter>, I>>(base?: I): LessThanFilter {
    return LessThanFilter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LessThanFilter>, I>>(object: I): LessThanFilter {
    const message = createBaseLessThanFilter();
    message.field = object.field ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Any.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseInFilter(): InFilter {
  return { field: "", values: [] };
}

export const InFilter = {
  encode(message: InFilter, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.field !== "") {
      writer.uint32(10).string(message.field);
    }
    for (const v of message.values) {
      Any.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InFilter {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.field = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.values.push(Any.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InFilter {
    return {
      field: isSet(object.field) ? globalThis.String(object.field) : "",
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => Any.fromJSON(e)) : [],
    };
  },

  toJSON(message: InFilter): unknown {
    const obj: any = {};
    if (message.field !== "") {
      obj.field = message.field;
    }
    if (message.values?.length) {
      obj.values = message.values.map((e) => Any.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InFilter>, I>>(base?: I): InFilter {
    return InFilter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InFilter>, I>>(object: I): InFilter {
    const message = createBaseInFilter();
    message.field = object.field ?? "";
    message.values = object.values?.map((e) => Any.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRangeFilter(): RangeFilter {
  return { field: "", minValue: undefined, maxValue: undefined };
}

export const RangeFilter = {
  encode(message: RangeFilter, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.field !== "") {
      writer.uint32(10).string(message.field);
    }
    if (message.minValue !== undefined) {
      Any.encode(message.minValue, writer.uint32(18).fork()).ldelim();
    }
    if (message.maxValue !== undefined) {
      Any.encode(message.maxValue, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RangeFilter {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRangeFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.field = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.minValue = Any.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.maxValue = Any.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RangeFilter {
    return {
      field: isSet(object.field) ? globalThis.String(object.field) : "",
      minValue: isSet(object.minValue) ? Any.fromJSON(object.minValue) : undefined,
      maxValue: isSet(object.maxValue) ? Any.fromJSON(object.maxValue) : undefined,
    };
  },

  toJSON(message: RangeFilter): unknown {
    const obj: any = {};
    if (message.field !== "") {
      obj.field = message.field;
    }
    if (message.minValue !== undefined) {
      obj.minValue = Any.toJSON(message.minValue);
    }
    if (message.maxValue !== undefined) {
      obj.maxValue = Any.toJSON(message.maxValue);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RangeFilter>, I>>(base?: I): RangeFilter {
    return RangeFilter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RangeFilter>, I>>(object: I): RangeFilter {
    const message = createBaseRangeFilter();
    message.field = object.field ?? "";
    message.minValue = (object.minValue !== undefined && object.minValue !== null)
      ? Any.fromPartial(object.minValue)
      : undefined;
    message.maxValue = (object.maxValue !== undefined && object.maxValue !== null)
      ? Any.fromPartial(object.maxValue)
      : undefined;
    return message;
  },
};

function createBaseTextSearchFilter(): TextSearchFilter {
  return { fields: [], query: "", analyzer: "" };
}

export const TextSearchFilter = {
  encode(message: TextSearchFilter, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.fields) {
      writer.uint32(10).string(v!);
    }
    if (message.query !== "") {
      writer.uint32(18).string(message.query);
    }
    if (message.analyzer !== "") {
      writer.uint32(26).string(message.analyzer);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TextSearchFilter {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTextSearchFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fields.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.query = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.analyzer = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TextSearchFilter {
    return {
      fields: globalThis.Array.isArray(object?.fields) ? object.fields.map((e: any) => globalThis.String(e)) : [],
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      analyzer: isSet(object.analyzer) ? globalThis.String(object.analyzer) : "",
    };
  },

  toJSON(message: TextSearchFilter): unknown {
    const obj: any = {};
    if (message.fields?.length) {
      obj.fields = message.fields;
    }
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.analyzer !== "") {
      obj.analyzer = message.analyzer;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TextSearchFilter>, I>>(base?: I): TextSearchFilter {
    return TextSearchFilter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TextSearchFilter>, I>>(object: I): TextSearchFilter {
    const message = createBaseTextSearchFilter();
    message.fields = object.fields?.map((e) => e) || [];
    message.query = object.query ?? "";
    message.analyzer = object.analyzer ?? "";
    return message;
  },
};

function createBaseVectorSearchFilter(): VectorSearchFilter {
  return { field: "", queryVector: [], limit: 0, threshold: 0, distanceMetric: "" };
}

export const VectorSearchFilter = {
  encode(message: VectorSearchFilter, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.field !== "") {
      writer.uint32(10).string(message.field);
    }
    writer.uint32(18).fork();
    for (const v of message.queryVector) {
      writer.float(v);
    }
    writer.ldelim();
    if (message.limit !== 0) {
      writer.uint32(24).int32(message.limit);
    }
    if (message.threshold !== 0) {
      writer.uint32(33).double(message.threshold);
    }
    if (message.distanceMetric !== "") {
      writer.uint32(42).string(message.distanceMetric);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): VectorSearchFilter {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVectorSearchFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.field = reader.string();
          continue;
        case 2:
          if (tag === 21) {
            message.queryVector.push(reader.float());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.queryVector.push(reader.float());
            }

            continue;
          }

          break;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.limit = reader.int32();
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.threshold = reader.double();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.distanceMetric = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VectorSearchFilter {
    return {
      field: isSet(object.field) ? globalThis.String(object.field) : "",
      queryVector: globalThis.Array.isArray(object?.queryVector)
        ? object.queryVector.map((e: any) => globalThis.Number(e))
        : [],
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      threshold: isSet(object.threshold) ? globalThis.Number(object.threshold) : 0,
      distanceMetric: isSet(object.distanceMetric) ? globalThis.String(object.distanceMetric) : "",
    };
  },

  toJSON(message: VectorSearchFilter): unknown {
    const obj: any = {};
    if (message.field !== "") {
      obj.field = message.field;
    }
    if (message.queryVector?.length) {
      obj.queryVector = message.queryVector;
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.threshold !== 0) {
      obj.threshold = message.threshold;
    }
    if (message.distanceMetric !== "") {
      obj.distanceMetric = message.distanceMetric;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VectorSearchFilter>, I>>(base?: I): VectorSearchFilter {
    return VectorSearchFilter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VectorSearchFilter>, I>>(object: I): VectorSearchFilter {
    const message = createBaseVectorSearchFilter();
    message.field = object.field ?? "";
    message.queryVector = object.queryVector?.map((e) => e) || [];
    message.limit = object.limit ?? 0;
    message.threshold = object.threshold ?? 0;
    message.distanceMetric = object.distanceMetric ?? "";
    return message;
  },
};

function createBaseAndFilter(): AndFilter {
  return { filters: [] };
}

export const AndFilter = {
  encode(message: AndFilter, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.filters) {
      QueryCriteria.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AndFilter {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAndFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.filters.push(QueryCriteria.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AndFilter {
    return {
      filters: globalThis.Array.isArray(object?.filters)
        ? object.filters.map((e: any) => QueryCriteria.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AndFilter): unknown {
    const obj: any = {};
    if (message.filters?.length) {
      obj.filters = message.filters.map((e) => QueryCriteria.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AndFilter>, I>>(base?: I): AndFilter {
    return AndFilter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AndFilter>, I>>(object: I): AndFilter {
    const message = createBaseAndFilter();
    message.filters = object.filters?.map((e) => QueryCriteria.fromPartial(e)) || [];
    return message;
  },
};

function createBaseOrFilter(): OrFilter {
  return { filters: [] };
}

export const OrFilter = {
  encode(message: OrFilter, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.filters) {
      QueryCriteria.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OrFilter {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.filters.push(QueryCriteria.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrFilter {
    return {
      filters: globalThis.Array.isArray(object?.filters)
        ? object.filters.map((e: any) => QueryCriteria.fromJSON(e))
        : [],
    };
  },

  toJSON(message: OrFilter): unknown {
    const obj: any = {};
    if (message.filters?.length) {
      obj.filters = message.filters.map((e) => QueryCriteria.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrFilter>, I>>(base?: I): OrFilter {
    return OrFilter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrFilter>, I>>(object: I): OrFilter {
    const message = createBaseOrFilter();
    message.filters = object.filters?.map((e) => QueryCriteria.fromPartial(e)) || [];
    return message;
  },
};

function createBaseOrderBy(): OrderBy {
  return { field: "", ascending: false };
}

export const OrderBy = {
  encode(message: OrderBy, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.field !== "") {
      writer.uint32(10).string(message.field);
    }
    if (message.ascending !== false) {
      writer.uint32(16).bool(message.ascending);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OrderBy {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderBy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.field = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.ascending = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrderBy {
    return {
      field: isSet(object.field) ? globalThis.String(object.field) : "",
      ascending: isSet(object.ascending) ? globalThis.Boolean(object.ascending) : false,
    };
  },

  toJSON(message: OrderBy): unknown {
    const obj: any = {};
    if (message.field !== "") {
      obj.field = message.field;
    }
    if (message.ascending !== false) {
      obj.ascending = message.ascending;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrderBy>, I>>(base?: I): OrderBy {
    return OrderBy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrderBy>, I>>(object: I): OrderBy {
    const message = createBaseOrderBy();
    message.field = object.field ?? "";
    message.ascending = object.ascending ?? false;
    return message;
  },
};

function createBaseQuerySpec(): QuerySpec {
  return { tableName: "", queryType: 0, criteria: undefined, projections: [], orderBy: [], limit: 0, offset: 0 };
}

export const QuerySpec = {
  encode(message: QuerySpec, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tableName !== "") {
      writer.uint32(10).string(message.tableName);
    }
    if (message.queryType !== 0) {
      writer.uint32(16).int32(message.queryType);
    }
    if (message.criteria !== undefined) {
      QueryCriteria.encode(message.criteria, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.projections) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.orderBy) {
      OrderBy.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    if (message.limit !== 0) {
      writer.uint32(48).int32(message.limit);
    }
    if (message.offset !== 0) {
      writer.uint32(56).int32(message.offset);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QuerySpec {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tableName = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.queryType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.criteria = QueryCriteria.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.projections.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy.push(OrderBy.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.limit = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.offset = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuerySpec {
    return {
      tableName: isSet(object.tableName) ? globalThis.String(object.tableName) : "",
      queryType: isSet(object.queryType) ? queryTypeFromJSON(object.queryType) : 0,
      criteria: isSet(object.criteria) ? QueryCriteria.fromJSON(object.criteria) : undefined,
      projections: globalThis.Array.isArray(object?.projections)
        ? object.projections.map((e: any) => globalThis.String(e))
        : [],
      orderBy: globalThis.Array.isArray(object?.orderBy) ? object.orderBy.map((e: any) => OrderBy.fromJSON(e)) : [],
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
    };
  },

  toJSON(message: QuerySpec): unknown {
    const obj: any = {};
    if (message.tableName !== "") {
      obj.tableName = message.tableName;
    }
    if (message.queryType !== 0) {
      obj.queryType = queryTypeToJSON(message.queryType);
    }
    if (message.criteria !== undefined) {
      obj.criteria = QueryCriteria.toJSON(message.criteria);
    }
    if (message.projections?.length) {
      obj.projections = message.projections;
    }
    if (message.orderBy?.length) {
      obj.orderBy = message.orderBy.map((e) => OrderBy.toJSON(e));
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QuerySpec>, I>>(base?: I): QuerySpec {
    return QuerySpec.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuerySpec>, I>>(object: I): QuerySpec {
    const message = createBaseQuerySpec();
    message.tableName = object.tableName ?? "";
    message.queryType = object.queryType ?? 0;
    message.criteria = (object.criteria !== undefined && object.criteria !== null)
      ? QueryCriteria.fromPartial(object.criteria)
      : undefined;
    message.projections = object.projections?.map((e) => e) || [];
    message.orderBy = object.orderBy?.map((e) => OrderBy.fromPartial(e)) || [];
    message.limit = object.limit ?? 0;
    message.offset = object.offset ?? 0;
    return message;
  },
};

function createBaseInsertRequest(): InsertRequest {
  return { tableName: "", record: undefined, context: undefined };
}

export const InsertRequest = {
  encode(message: InsertRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tableName !== "") {
      writer.uint32(10).string(message.tableName);
    }
    if (message.record !== undefined) {
      Record.encode(message.record, writer.uint32(18).fork()).ldelim();
    }
    if (message.context !== undefined) {
      ExecutionContext.encode(message.context, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InsertRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInsertRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tableName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.record = Record.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.context = ExecutionContext.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InsertRequest {
    return {
      tableName: isSet(object.tableName) ? globalThis.String(object.tableName) : "",
      record: isSet(object.record) ? Record.fromJSON(object.record) : undefined,
      context: isSet(object.context) ? ExecutionContext.fromJSON(object.context) : undefined,
    };
  },

  toJSON(message: InsertRequest): unknown {
    const obj: any = {};
    if (message.tableName !== "") {
      obj.tableName = message.tableName;
    }
    if (message.record !== undefined) {
      obj.record = Record.toJSON(message.record);
    }
    if (message.context !== undefined) {
      obj.context = ExecutionContext.toJSON(message.context);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InsertRequest>, I>>(base?: I): InsertRequest {
    return InsertRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InsertRequest>, I>>(object: I): InsertRequest {
    const message = createBaseInsertRequest();
    message.tableName = object.tableName ?? "";
    message.record = (object.record !== undefined && object.record !== null)
      ? Record.fromPartial(object.record)
      : undefined;
    message.context = (object.context !== undefined && object.context !== null)
      ? ExecutionContext.fromPartial(object.context)
      : undefined;
    return message;
  },
};

function createBaseInsertResponse(): InsertResponse {
  return { success: false, record: undefined, errorMessage: "", executionTimeMs: "0" };
}

export const InsertResponse = {
  encode(message: InsertResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.record !== undefined) {
      Record.encode(message.record, writer.uint32(18).fork()).ldelim();
    }
    if (message.errorMessage !== "") {
      writer.uint32(26).string(message.errorMessage);
    }
    if (message.executionTimeMs !== "0") {
      writer.uint32(32).int64(message.executionTimeMs);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InsertResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInsertResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.record = Record.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.executionTimeMs = longToString(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InsertResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      record: isSet(object.record) ? Record.fromJSON(object.record) : undefined,
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
      executionTimeMs: isSet(object.executionTimeMs) ? globalThis.String(object.executionTimeMs) : "0",
    };
  },

  toJSON(message: InsertResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.record !== undefined) {
      obj.record = Record.toJSON(message.record);
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    if (message.executionTimeMs !== "0") {
      obj.executionTimeMs = message.executionTimeMs;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InsertResponse>, I>>(base?: I): InsertResponse {
    return InsertResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InsertResponse>, I>>(object: I): InsertResponse {
    const message = createBaseInsertResponse();
    message.success = object.success ?? false;
    message.record = (object.record !== undefined && object.record !== null)
      ? Record.fromPartial(object.record)
      : undefined;
    message.errorMessage = object.errorMessage ?? "";
    message.executionTimeMs = object.executionTimeMs ?? "0";
    return message;
  },
};

function createBaseInsertBatchRequest(): InsertBatchRequest {
  return { tableName: "", records: [], context: undefined };
}

export const InsertBatchRequest = {
  encode(message: InsertBatchRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tableName !== "") {
      writer.uint32(10).string(message.tableName);
    }
    for (const v of message.records) {
      Record.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.context !== undefined) {
      ExecutionContext.encode(message.context, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InsertBatchRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInsertBatchRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tableName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.records.push(Record.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.context = ExecutionContext.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InsertBatchRequest {
    return {
      tableName: isSet(object.tableName) ? globalThis.String(object.tableName) : "",
      records: globalThis.Array.isArray(object?.records) ? object.records.map((e: any) => Record.fromJSON(e)) : [],
      context: isSet(object.context) ? ExecutionContext.fromJSON(object.context) : undefined,
    };
  },

  toJSON(message: InsertBatchRequest): unknown {
    const obj: any = {};
    if (message.tableName !== "") {
      obj.tableName = message.tableName;
    }
    if (message.records?.length) {
      obj.records = message.records.map((e) => Record.toJSON(e));
    }
    if (message.context !== undefined) {
      obj.context = ExecutionContext.toJSON(message.context);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InsertBatchRequest>, I>>(base?: I): InsertBatchRequest {
    return InsertBatchRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InsertBatchRequest>, I>>(object: I): InsertBatchRequest {
    const message = createBaseInsertBatchRequest();
    message.tableName = object.tableName ?? "";
    message.records = object.records?.map((e) => Record.fromPartial(e)) || [];
    message.context = (object.context !== undefined && object.context !== null)
      ? ExecutionContext.fromPartial(object.context)
      : undefined;
    return message;
  },
};

function createBaseInsertBatchResponse(): InsertBatchResponse {
  return { success: false, records: [], insertedCount: 0, errorMessage: "", executionTimeMs: "0" };
}

export const InsertBatchResponse = {
  encode(message: InsertBatchResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    for (const v of message.records) {
      Record.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.insertedCount !== 0) {
      writer.uint32(24).int32(message.insertedCount);
    }
    if (message.errorMessage !== "") {
      writer.uint32(34).string(message.errorMessage);
    }
    if (message.executionTimeMs !== "0") {
      writer.uint32(40).int64(message.executionTimeMs);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InsertBatchResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInsertBatchResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.records.push(Record.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.insertedCount = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.executionTimeMs = longToString(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InsertBatchResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      records: globalThis.Array.isArray(object?.records) ? object.records.map((e: any) => Record.fromJSON(e)) : [],
      insertedCount: isSet(object.insertedCount) ? globalThis.Number(object.insertedCount) : 0,
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
      executionTimeMs: isSet(object.executionTimeMs) ? globalThis.String(object.executionTimeMs) : "0",
    };
  },

  toJSON(message: InsertBatchResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.records?.length) {
      obj.records = message.records.map((e) => Record.toJSON(e));
    }
    if (message.insertedCount !== 0) {
      obj.insertedCount = Math.round(message.insertedCount);
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    if (message.executionTimeMs !== "0") {
      obj.executionTimeMs = message.executionTimeMs;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InsertBatchResponse>, I>>(base?: I): InsertBatchResponse {
    return InsertBatchResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InsertBatchResponse>, I>>(object: I): InsertBatchResponse {
    const message = createBaseInsertBatchResponse();
    message.success = object.success ?? false;
    message.records = object.records?.map((e) => Record.fromPartial(e)) || [];
    message.insertedCount = object.insertedCount ?? 0;
    message.errorMessage = object.errorMessage ?? "";
    message.executionTimeMs = object.executionTimeMs ?? "0";
    return message;
  },
};

function createBaseUpdateRequest(): UpdateRequest {
  return { tableName: "", id: "", updates: undefined, context: undefined };
}

export const UpdateRequest = {
  encode(message: UpdateRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tableName !== "") {
      writer.uint32(10).string(message.tableName);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.updates !== undefined) {
      Struct.encode(Struct.wrap(message.updates), writer.uint32(26).fork()).ldelim();
    }
    if (message.context !== undefined) {
      ExecutionContext.encode(message.context, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tableName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updates = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.context = ExecutionContext.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateRequest {
    return {
      tableName: isSet(object.tableName) ? globalThis.String(object.tableName) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      updates: isObject(object.updates) ? object.updates : undefined,
      context: isSet(object.context) ? ExecutionContext.fromJSON(object.context) : undefined,
    };
  },

  toJSON(message: UpdateRequest): unknown {
    const obj: any = {};
    if (message.tableName !== "") {
      obj.tableName = message.tableName;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.updates !== undefined) {
      obj.updates = message.updates;
    }
    if (message.context !== undefined) {
      obj.context = ExecutionContext.toJSON(message.context);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateRequest>, I>>(base?: I): UpdateRequest {
    return UpdateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateRequest>, I>>(object: I): UpdateRequest {
    const message = createBaseUpdateRequest();
    message.tableName = object.tableName ?? "";
    message.id = object.id ?? "";
    message.updates = object.updates ?? undefined;
    message.context = (object.context !== undefined && object.context !== null)
      ? ExecutionContext.fromPartial(object.context)
      : undefined;
    return message;
  },
};

function createBaseUpdateResponse(): UpdateResponse {
  return { success: false, record: undefined, errorMessage: "", executionTimeMs: "0" };
}

export const UpdateResponse = {
  encode(message: UpdateResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.record !== undefined) {
      Record.encode(message.record, writer.uint32(18).fork()).ldelim();
    }
    if (message.errorMessage !== "") {
      writer.uint32(26).string(message.errorMessage);
    }
    if (message.executionTimeMs !== "0") {
      writer.uint32(32).int64(message.executionTimeMs);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.record = Record.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.executionTimeMs = longToString(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      record: isSet(object.record) ? Record.fromJSON(object.record) : undefined,
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
      executionTimeMs: isSet(object.executionTimeMs) ? globalThis.String(object.executionTimeMs) : "0",
    };
  },

  toJSON(message: UpdateResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.record !== undefined) {
      obj.record = Record.toJSON(message.record);
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    if (message.executionTimeMs !== "0") {
      obj.executionTimeMs = message.executionTimeMs;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateResponse>, I>>(base?: I): UpdateResponse {
    return UpdateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateResponse>, I>>(object: I): UpdateResponse {
    const message = createBaseUpdateResponse();
    message.success = object.success ?? false;
    message.record = (object.record !== undefined && object.record !== null)
      ? Record.fromPartial(object.record)
      : undefined;
    message.errorMessage = object.errorMessage ?? "";
    message.executionTimeMs = object.executionTimeMs ?? "0";
    return message;
  },
};

function createBaseDeleteRequest(): DeleteRequest {
  return { tableName: "", criteria: undefined, context: undefined };
}

export const DeleteRequest = {
  encode(message: DeleteRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tableName !== "") {
      writer.uint32(10).string(message.tableName);
    }
    if (message.criteria !== undefined) {
      QueryCriteria.encode(message.criteria, writer.uint32(18).fork()).ldelim();
    }
    if (message.context !== undefined) {
      ExecutionContext.encode(message.context, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tableName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.criteria = QueryCriteria.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.context = ExecutionContext.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteRequest {
    return {
      tableName: isSet(object.tableName) ? globalThis.String(object.tableName) : "",
      criteria: isSet(object.criteria) ? QueryCriteria.fromJSON(object.criteria) : undefined,
      context: isSet(object.context) ? ExecutionContext.fromJSON(object.context) : undefined,
    };
  },

  toJSON(message: DeleteRequest): unknown {
    const obj: any = {};
    if (message.tableName !== "") {
      obj.tableName = message.tableName;
    }
    if (message.criteria !== undefined) {
      obj.criteria = QueryCriteria.toJSON(message.criteria);
    }
    if (message.context !== undefined) {
      obj.context = ExecutionContext.toJSON(message.context);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteRequest>, I>>(base?: I): DeleteRequest {
    return DeleteRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteRequest>, I>>(object: I): DeleteRequest {
    const message = createBaseDeleteRequest();
    message.tableName = object.tableName ?? "";
    message.criteria = (object.criteria !== undefined && object.criteria !== null)
      ? QueryCriteria.fromPartial(object.criteria)
      : undefined;
    message.context = (object.context !== undefined && object.context !== null)
      ? ExecutionContext.fromPartial(object.context)
      : undefined;
    return message;
  },
};

function createBaseDeleteResponse(): DeleteResponse {
  return { success: false, deletedCount: "0", errorMessage: "", executionTimeMs: "0" };
}

export const DeleteResponse = {
  encode(message: DeleteResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.deletedCount !== "0") {
      writer.uint32(16).int64(message.deletedCount);
    }
    if (message.errorMessage !== "") {
      writer.uint32(26).string(message.errorMessage);
    }
    if (message.executionTimeMs !== "0") {
      writer.uint32(32).int64(message.executionTimeMs);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.deletedCount = longToString(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.executionTimeMs = longToString(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      deletedCount: isSet(object.deletedCount) ? globalThis.String(object.deletedCount) : "0",
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
      executionTimeMs: isSet(object.executionTimeMs) ? globalThis.String(object.executionTimeMs) : "0",
    };
  },

  toJSON(message: DeleteResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.deletedCount !== "0") {
      obj.deletedCount = message.deletedCount;
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    if (message.executionTimeMs !== "0") {
      obj.executionTimeMs = message.executionTimeMs;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteResponse>, I>>(base?: I): DeleteResponse {
    return DeleteResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteResponse>, I>>(object: I): DeleteResponse {
    const message = createBaseDeleteResponse();
    message.success = object.success ?? false;
    message.deletedCount = object.deletedCount ?? "0";
    message.errorMessage = object.errorMessage ?? "";
    message.executionTimeMs = object.executionTimeMs ?? "0";
    return message;
  },
};

function createBaseExecuteQueryRequest(): ExecuteQueryRequest {
  return { queryName: "", parameters: undefined, context: undefined };
}

export const ExecuteQueryRequest = {
  encode(message: ExecuteQueryRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.queryName !== "") {
      writer.uint32(10).string(message.queryName);
    }
    if (message.parameters !== undefined) {
      Struct.encode(Struct.wrap(message.parameters), writer.uint32(18).fork()).ldelim();
    }
    if (message.context !== undefined) {
      ExecutionContext.encode(message.context, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExecuteQueryRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecuteQueryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.queryName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.parameters = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.context = ExecutionContext.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecuteQueryRequest {
    return {
      queryName: isSet(object.queryName) ? globalThis.String(object.queryName) : "",
      parameters: isObject(object.parameters) ? object.parameters : undefined,
      context: isSet(object.context) ? ExecutionContext.fromJSON(object.context) : undefined,
    };
  },

  toJSON(message: ExecuteQueryRequest): unknown {
    const obj: any = {};
    if (message.queryName !== "") {
      obj.queryName = message.queryName;
    }
    if (message.parameters !== undefined) {
      obj.parameters = message.parameters;
    }
    if (message.context !== undefined) {
      obj.context = ExecutionContext.toJSON(message.context);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExecuteQueryRequest>, I>>(base?: I): ExecuteQueryRequest {
    return ExecuteQueryRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExecuteQueryRequest>, I>>(object: I): ExecuteQueryRequest {
    const message = createBaseExecuteQueryRequest();
    message.queryName = object.queryName ?? "";
    message.parameters = object.parameters ?? undefined;
    message.context = (object.context !== undefined && object.context !== null)
      ? ExecutionContext.fromPartial(object.context)
      : undefined;
    return message;
  },
};

function createBaseExecuteQueryResponse(): ExecuteQueryResponse {
  return { success: false, results: [], count: 0, errorMessage: "", executionTimeMs: "0", fromCache: false };
}

export const ExecuteQueryResponse = {
  encode(message: ExecuteQueryResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    for (const v of message.results) {
      Record.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.count !== 0) {
      writer.uint32(24).int32(message.count);
    }
    if (message.errorMessage !== "") {
      writer.uint32(34).string(message.errorMessage);
    }
    if (message.executionTimeMs !== "0") {
      writer.uint32(40).int64(message.executionTimeMs);
    }
    if (message.fromCache !== false) {
      writer.uint32(48).bool(message.fromCache);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExecuteQueryResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecuteQueryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.results.push(Record.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.count = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.executionTimeMs = longToString(reader.int64() as Long);
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.fromCache = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecuteQueryResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      results: globalThis.Array.isArray(object?.results) ? object.results.map((e: any) => Record.fromJSON(e)) : [],
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
      executionTimeMs: isSet(object.executionTimeMs) ? globalThis.String(object.executionTimeMs) : "0",
      fromCache: isSet(object.fromCache) ? globalThis.Boolean(object.fromCache) : false,
    };
  },

  toJSON(message: ExecuteQueryResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.results?.length) {
      obj.results = message.results.map((e) => Record.toJSON(e));
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    if (message.executionTimeMs !== "0") {
      obj.executionTimeMs = message.executionTimeMs;
    }
    if (message.fromCache !== false) {
      obj.fromCache = message.fromCache;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExecuteQueryResponse>, I>>(base?: I): ExecuteQueryResponse {
    return ExecuteQueryResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExecuteQueryResponse>, I>>(object: I): ExecuteQueryResponse {
    const message = createBaseExecuteQueryResponse();
    message.success = object.success ?? false;
    message.results = object.results?.map((e) => Record.fromPartial(e)) || [];
    message.count = object.count ?? 0;
    message.errorMessage = object.errorMessage ?? "";
    message.executionTimeMs = object.executionTimeMs ?? "0";
    message.fromCache = object.fromCache ?? false;
    return message;
  },
};

function createBaseExecuteRawQueryRequest(): ExecuteRawQueryRequest {
  return { querySpec: undefined, context: undefined };
}

export const ExecuteRawQueryRequest = {
  encode(message: ExecuteRawQueryRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.querySpec !== undefined) {
      QuerySpec.encode(message.querySpec, writer.uint32(10).fork()).ldelim();
    }
    if (message.context !== undefined) {
      ExecutionContext.encode(message.context, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExecuteRawQueryRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecuteRawQueryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.querySpec = QuerySpec.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.context = ExecutionContext.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecuteRawQueryRequest {
    return {
      querySpec: isSet(object.querySpec) ? QuerySpec.fromJSON(object.querySpec) : undefined,
      context: isSet(object.context) ? ExecutionContext.fromJSON(object.context) : undefined,
    };
  },

  toJSON(message: ExecuteRawQueryRequest): unknown {
    const obj: any = {};
    if (message.querySpec !== undefined) {
      obj.querySpec = QuerySpec.toJSON(message.querySpec);
    }
    if (message.context !== undefined) {
      obj.context = ExecutionContext.toJSON(message.context);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExecuteRawQueryRequest>, I>>(base?: I): ExecuteRawQueryRequest {
    return ExecuteRawQueryRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExecuteRawQueryRequest>, I>>(object: I): ExecuteRawQueryRequest {
    const message = createBaseExecuteRawQueryRequest();
    message.querySpec = (object.querySpec !== undefined && object.querySpec !== null)
      ? QuerySpec.fromPartial(object.querySpec)
      : undefined;
    message.context = (object.context !== undefined && object.context !== null)
      ? ExecutionContext.fromPartial(object.context)
      : undefined;
    return message;
  },
};

function createBaseExecuteRawQueryResponse(): ExecuteRawQueryResponse {
  return { success: false, results: [], count: 0, errorMessage: "", executionTimeMs: "0" };
}

export const ExecuteRawQueryResponse = {
  encode(message: ExecuteRawQueryResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    for (const v of message.results) {
      Record.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.count !== 0) {
      writer.uint32(24).int32(message.count);
    }
    if (message.errorMessage !== "") {
      writer.uint32(34).string(message.errorMessage);
    }
    if (message.executionTimeMs !== "0") {
      writer.uint32(40).int64(message.executionTimeMs);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExecuteRawQueryResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecuteRawQueryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.results.push(Record.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.count = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.executionTimeMs = longToString(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecuteRawQueryResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      results: globalThis.Array.isArray(object?.results) ? object.results.map((e: any) => Record.fromJSON(e)) : [],
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
      executionTimeMs: isSet(object.executionTimeMs) ? globalThis.String(object.executionTimeMs) : "0",
    };
  },

  toJSON(message: ExecuteRawQueryResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.results?.length) {
      obj.results = message.results.map((e) => Record.toJSON(e));
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    if (message.executionTimeMs !== "0") {
      obj.executionTimeMs = message.executionTimeMs;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExecuteRawQueryResponse>, I>>(base?: I): ExecuteRawQueryResponse {
    return ExecuteRawQueryResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExecuteRawQueryResponse>, I>>(object: I): ExecuteRawQueryResponse {
    const message = createBaseExecuteRawQueryResponse();
    message.success = object.success ?? false;
    message.results = object.results?.map((e) => Record.fromPartial(e)) || [];
    message.count = object.count ?? 0;
    message.errorMessage = object.errorMessage ?? "";
    message.executionTimeMs = object.executionTimeMs ?? "0";
    return message;
  },
};

function createBaseVectorSearchRequest(): VectorSearchRequest {
  return { tableName: "", queryVector: [], limit: 0, threshold: 0, distanceMetric: "", context: undefined };
}

export const VectorSearchRequest = {
  encode(message: VectorSearchRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tableName !== "") {
      writer.uint32(10).string(message.tableName);
    }
    writer.uint32(18).fork();
    for (const v of message.queryVector) {
      writer.float(v);
    }
    writer.ldelim();
    if (message.limit !== 0) {
      writer.uint32(24).int32(message.limit);
    }
    if (message.threshold !== 0) {
      writer.uint32(33).double(message.threshold);
    }
    if (message.distanceMetric !== "") {
      writer.uint32(42).string(message.distanceMetric);
    }
    if (message.context !== undefined) {
      ExecutionContext.encode(message.context, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): VectorSearchRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVectorSearchRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tableName = reader.string();
          continue;
        case 2:
          if (tag === 21) {
            message.queryVector.push(reader.float());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.queryVector.push(reader.float());
            }

            continue;
          }

          break;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.limit = reader.int32();
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.threshold = reader.double();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.distanceMetric = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.context = ExecutionContext.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VectorSearchRequest {
    return {
      tableName: isSet(object.tableName) ? globalThis.String(object.tableName) : "",
      queryVector: globalThis.Array.isArray(object?.queryVector)
        ? object.queryVector.map((e: any) => globalThis.Number(e))
        : [],
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      threshold: isSet(object.threshold) ? globalThis.Number(object.threshold) : 0,
      distanceMetric: isSet(object.distanceMetric) ? globalThis.String(object.distanceMetric) : "",
      context: isSet(object.context) ? ExecutionContext.fromJSON(object.context) : undefined,
    };
  },

  toJSON(message: VectorSearchRequest): unknown {
    const obj: any = {};
    if (message.tableName !== "") {
      obj.tableName = message.tableName;
    }
    if (message.queryVector?.length) {
      obj.queryVector = message.queryVector;
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.threshold !== 0) {
      obj.threshold = message.threshold;
    }
    if (message.distanceMetric !== "") {
      obj.distanceMetric = message.distanceMetric;
    }
    if (message.context !== undefined) {
      obj.context = ExecutionContext.toJSON(message.context);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VectorSearchRequest>, I>>(base?: I): VectorSearchRequest {
    return VectorSearchRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VectorSearchRequest>, I>>(object: I): VectorSearchRequest {
    const message = createBaseVectorSearchRequest();
    message.tableName = object.tableName ?? "";
    message.queryVector = object.queryVector?.map((e) => e) || [];
    message.limit = object.limit ?? 0;
    message.threshold = object.threshold ?? 0;
    message.distanceMetric = object.distanceMetric ?? "";
    message.context = (object.context !== undefined && object.context !== null)
      ? ExecutionContext.fromPartial(object.context)
      : undefined;
    return message;
  },
};

function createBaseVectorSearchResponse(): VectorSearchResponse {
  return { success: false, results: [], errorMessage: "", executionTimeMs: "0" };
}

export const VectorSearchResponse = {
  encode(message: VectorSearchResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    for (const v of message.results) {
      VectorSearchResult.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.errorMessage !== "") {
      writer.uint32(26).string(message.errorMessage);
    }
    if (message.executionTimeMs !== "0") {
      writer.uint32(32).int64(message.executionTimeMs);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): VectorSearchResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVectorSearchResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.results.push(VectorSearchResult.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.executionTimeMs = longToString(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VectorSearchResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      results: globalThis.Array.isArray(object?.results)
        ? object.results.map((e: any) => VectorSearchResult.fromJSON(e))
        : [],
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
      executionTimeMs: isSet(object.executionTimeMs) ? globalThis.String(object.executionTimeMs) : "0",
    };
  },

  toJSON(message: VectorSearchResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.results?.length) {
      obj.results = message.results.map((e) => VectorSearchResult.toJSON(e));
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    if (message.executionTimeMs !== "0") {
      obj.executionTimeMs = message.executionTimeMs;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VectorSearchResponse>, I>>(base?: I): VectorSearchResponse {
    return VectorSearchResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VectorSearchResponse>, I>>(object: I): VectorSearchResponse {
    const message = createBaseVectorSearchResponse();
    message.success = object.success ?? false;
    message.results = object.results?.map((e) => VectorSearchResult.fromPartial(e)) || [];
    message.errorMessage = object.errorMessage ?? "";
    message.executionTimeMs = object.executionTimeMs ?? "0";
    return message;
  },
};

function createBaseVectorSearchResult(): VectorSearchResult {
  return { record: undefined, similarityScore: 0, distance: 0 };
}

export const VectorSearchResult = {
  encode(message: VectorSearchResult, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.record !== undefined) {
      Record.encode(message.record, writer.uint32(10).fork()).ldelim();
    }
    if (message.similarityScore !== 0) {
      writer.uint32(17).double(message.similarityScore);
    }
    if (message.distance !== 0) {
      writer.uint32(25).double(message.distance);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): VectorSearchResult {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVectorSearchResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.record = Record.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.similarityScore = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.distance = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VectorSearchResult {
    return {
      record: isSet(object.record) ? Record.fromJSON(object.record) : undefined,
      similarityScore: isSet(object.similarityScore) ? globalThis.Number(object.similarityScore) : 0,
      distance: isSet(object.distance) ? globalThis.Number(object.distance) : 0,
    };
  },

  toJSON(message: VectorSearchResult): unknown {
    const obj: any = {};
    if (message.record !== undefined) {
      obj.record = Record.toJSON(message.record);
    }
    if (message.similarityScore !== 0) {
      obj.similarityScore = message.similarityScore;
    }
    if (message.distance !== 0) {
      obj.distance = message.distance;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VectorSearchResult>, I>>(base?: I): VectorSearchResult {
    return VectorSearchResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VectorSearchResult>, I>>(object: I): VectorSearchResult {
    const message = createBaseVectorSearchResult();
    message.record = (object.record !== undefined && object.record !== null)
      ? Record.fromPartial(object.record)
      : undefined;
    message.similarityScore = object.similarityScore ?? 0;
    message.distance = object.distance ?? 0;
    return message;
  },
};

function createBaseGraphTraverseRequest(): GraphTraverseRequest {
  return { tableName: "", startNode: "", traversalSpec: undefined, context: undefined };
}

export const GraphTraverseRequest = {
  encode(message: GraphTraverseRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tableName !== "") {
      writer.uint32(10).string(message.tableName);
    }
    if (message.startNode !== "") {
      writer.uint32(18).string(message.startNode);
    }
    if (message.traversalSpec !== undefined) {
      GraphTraversalSpec.encode(message.traversalSpec, writer.uint32(26).fork()).ldelim();
    }
    if (message.context !== undefined) {
      ExecutionContext.encode(message.context, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GraphTraverseRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGraphTraverseRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tableName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.startNode = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.traversalSpec = GraphTraversalSpec.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.context = ExecutionContext.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GraphTraverseRequest {
    return {
      tableName: isSet(object.tableName) ? globalThis.String(object.tableName) : "",
      startNode: isSet(object.startNode) ? globalThis.String(object.startNode) : "",
      traversalSpec: isSet(object.traversalSpec) ? GraphTraversalSpec.fromJSON(object.traversalSpec) : undefined,
      context: isSet(object.context) ? ExecutionContext.fromJSON(object.context) : undefined,
    };
  },

  toJSON(message: GraphTraverseRequest): unknown {
    const obj: any = {};
    if (message.tableName !== "") {
      obj.tableName = message.tableName;
    }
    if (message.startNode !== "") {
      obj.startNode = message.startNode;
    }
    if (message.traversalSpec !== undefined) {
      obj.traversalSpec = GraphTraversalSpec.toJSON(message.traversalSpec);
    }
    if (message.context !== undefined) {
      obj.context = ExecutionContext.toJSON(message.context);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GraphTraverseRequest>, I>>(base?: I): GraphTraverseRequest {
    return GraphTraverseRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GraphTraverseRequest>, I>>(object: I): GraphTraverseRequest {
    const message = createBaseGraphTraverseRequest();
    message.tableName = object.tableName ?? "";
    message.startNode = object.startNode ?? "";
    message.traversalSpec = (object.traversalSpec !== undefined && object.traversalSpec !== null)
      ? GraphTraversalSpec.fromPartial(object.traversalSpec)
      : undefined;
    message.context = (object.context !== undefined && object.context !== null)
      ? ExecutionContext.fromPartial(object.context)
      : undefined;
    return message;
  },
};

function createBaseGraphTraverseResponse(): GraphTraverseResponse {
  return { success: false, nodes: [], edges: [], errorMessage: "", executionTimeMs: "0" };
}

export const GraphTraverseResponse = {
  encode(message: GraphTraverseResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    for (const v of message.nodes) {
      GraphNode.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.edges) {
      GraphEdge.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.errorMessage !== "") {
      writer.uint32(34).string(message.errorMessage);
    }
    if (message.executionTimeMs !== "0") {
      writer.uint32(40).int64(message.executionTimeMs);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GraphTraverseResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGraphTraverseResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nodes.push(GraphNode.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.edges.push(GraphEdge.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.executionTimeMs = longToString(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GraphTraverseResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      nodes: globalThis.Array.isArray(object?.nodes) ? object.nodes.map((e: any) => GraphNode.fromJSON(e)) : [],
      edges: globalThis.Array.isArray(object?.edges) ? object.edges.map((e: any) => GraphEdge.fromJSON(e)) : [],
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
      executionTimeMs: isSet(object.executionTimeMs) ? globalThis.String(object.executionTimeMs) : "0",
    };
  },

  toJSON(message: GraphTraverseResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.nodes?.length) {
      obj.nodes = message.nodes.map((e) => GraphNode.toJSON(e));
    }
    if (message.edges?.length) {
      obj.edges = message.edges.map((e) => GraphEdge.toJSON(e));
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    if (message.executionTimeMs !== "0") {
      obj.executionTimeMs = message.executionTimeMs;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GraphTraverseResponse>, I>>(base?: I): GraphTraverseResponse {
    return GraphTraverseResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GraphTraverseResponse>, I>>(object: I): GraphTraverseResponse {
    const message = createBaseGraphTraverseResponse();
    message.success = object.success ?? false;
    message.nodes = object.nodes?.map((e) => GraphNode.fromPartial(e)) || [];
    message.edges = object.edges?.map((e) => GraphEdge.fromPartial(e)) || [];
    message.errorMessage = object.errorMessage ?? "";
    message.executionTimeMs = object.executionTimeMs ?? "0";
    return message;
  },
};

function createBaseGraphTraversalSpec(): GraphTraversalSpec {
  return { traversalType: 0, maxDepth: 0, relationshipTypes: [], nodeFilter: undefined, edgeFilter: undefined };
}

export const GraphTraversalSpec = {
  encode(message: GraphTraversalSpec, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.traversalType !== 0) {
      writer.uint32(8).int32(message.traversalType);
    }
    if (message.maxDepth !== 0) {
      writer.uint32(16).int32(message.maxDepth);
    }
    for (const v of message.relationshipTypes) {
      writer.uint32(26).string(v!);
    }
    if (message.nodeFilter !== undefined) {
      QueryCriteria.encode(message.nodeFilter, writer.uint32(34).fork()).ldelim();
    }
    if (message.edgeFilter !== undefined) {
      QueryCriteria.encode(message.edgeFilter, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GraphTraversalSpec {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGraphTraversalSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.traversalType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.maxDepth = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.relationshipTypes.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.nodeFilter = QueryCriteria.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.edgeFilter = QueryCriteria.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GraphTraversalSpec {
    return {
      traversalType: isSet(object.traversalType) ? graphTraversalTypeFromJSON(object.traversalType) : 0,
      maxDepth: isSet(object.maxDepth) ? globalThis.Number(object.maxDepth) : 0,
      relationshipTypes: globalThis.Array.isArray(object?.relationshipTypes)
        ? object.relationshipTypes.map((e: any) => globalThis.String(e))
        : [],
      nodeFilter: isSet(object.nodeFilter) ? QueryCriteria.fromJSON(object.nodeFilter) : undefined,
      edgeFilter: isSet(object.edgeFilter) ? QueryCriteria.fromJSON(object.edgeFilter) : undefined,
    };
  },

  toJSON(message: GraphTraversalSpec): unknown {
    const obj: any = {};
    if (message.traversalType !== 0) {
      obj.traversalType = graphTraversalTypeToJSON(message.traversalType);
    }
    if (message.maxDepth !== 0) {
      obj.maxDepth = Math.round(message.maxDepth);
    }
    if (message.relationshipTypes?.length) {
      obj.relationshipTypes = message.relationshipTypes;
    }
    if (message.nodeFilter !== undefined) {
      obj.nodeFilter = QueryCriteria.toJSON(message.nodeFilter);
    }
    if (message.edgeFilter !== undefined) {
      obj.edgeFilter = QueryCriteria.toJSON(message.edgeFilter);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GraphTraversalSpec>, I>>(base?: I): GraphTraversalSpec {
    return GraphTraversalSpec.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GraphTraversalSpec>, I>>(object: I): GraphTraversalSpec {
    const message = createBaseGraphTraversalSpec();
    message.traversalType = object.traversalType ?? 0;
    message.maxDepth = object.maxDepth ?? 0;
    message.relationshipTypes = object.relationshipTypes?.map((e) => e) || [];
    message.nodeFilter = (object.nodeFilter !== undefined && object.nodeFilter !== null)
      ? QueryCriteria.fromPartial(object.nodeFilter)
      : undefined;
    message.edgeFilter = (object.edgeFilter !== undefined && object.edgeFilter !== null)
      ? QueryCriteria.fromPartial(object.edgeFilter)
      : undefined;
    return message;
  },
};

function createBaseGraphNode(): GraphNode {
  return { id: "", label: "", properties: undefined };
}

export const GraphNode = {
  encode(message: GraphNode, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.label !== "") {
      writer.uint32(18).string(message.label);
    }
    if (message.properties !== undefined) {
      Struct.encode(Struct.wrap(message.properties), writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GraphNode {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGraphNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.label = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.properties = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GraphNode {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      properties: isObject(object.properties) ? object.properties : undefined,
    };
  },

  toJSON(message: GraphNode): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.properties !== undefined) {
      obj.properties = message.properties;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GraphNode>, I>>(base?: I): GraphNode {
    return GraphNode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GraphNode>, I>>(object: I): GraphNode {
    const message = createBaseGraphNode();
    message.id = object.id ?? "";
    message.label = object.label ?? "";
    message.properties = object.properties ?? undefined;
    return message;
  },
};

function createBaseGraphEdge(): GraphEdge {
  return { id: "", sourceId: "", targetId: "", relationshipType: "", properties: undefined };
}

export const GraphEdge = {
  encode(message: GraphEdge, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.sourceId !== "") {
      writer.uint32(18).string(message.sourceId);
    }
    if (message.targetId !== "") {
      writer.uint32(26).string(message.targetId);
    }
    if (message.relationshipType !== "") {
      writer.uint32(34).string(message.relationshipType);
    }
    if (message.properties !== undefined) {
      Struct.encode(Struct.wrap(message.properties), writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GraphEdge {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGraphEdge();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sourceId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.targetId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.relationshipType = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.properties = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GraphEdge {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      sourceId: isSet(object.sourceId) ? globalThis.String(object.sourceId) : "",
      targetId: isSet(object.targetId) ? globalThis.String(object.targetId) : "",
      relationshipType: isSet(object.relationshipType) ? globalThis.String(object.relationshipType) : "",
      properties: isObject(object.properties) ? object.properties : undefined,
    };
  },

  toJSON(message: GraphEdge): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.sourceId !== "") {
      obj.sourceId = message.sourceId;
    }
    if (message.targetId !== "") {
      obj.targetId = message.targetId;
    }
    if (message.relationshipType !== "") {
      obj.relationshipType = message.relationshipType;
    }
    if (message.properties !== undefined) {
      obj.properties = message.properties;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GraphEdge>, I>>(base?: I): GraphEdge {
    return GraphEdge.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GraphEdge>, I>>(object: I): GraphEdge {
    const message = createBaseGraphEdge();
    message.id = object.id ?? "";
    message.sourceId = object.sourceId ?? "";
    message.targetId = object.targetId ?? "";
    message.relationshipType = object.relationshipType ?? "";
    message.properties = object.properties ?? undefined;
    return message;
  },
};

function createBaseExecuteOperationRequest(): ExecuteOperationRequest {
  return { operationName: "", parameters: undefined, context: undefined };
}

export const ExecuteOperationRequest = {
  encode(message: ExecuteOperationRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.operationName !== "") {
      writer.uint32(10).string(message.operationName);
    }
    if (message.parameters !== undefined) {
      Struct.encode(Struct.wrap(message.parameters), writer.uint32(18).fork()).ldelim();
    }
    if (message.context !== undefined) {
      ExecutionContext.encode(message.context, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExecuteOperationRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecuteOperationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.operationName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.parameters = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.context = ExecutionContext.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecuteOperationRequest {
    return {
      operationName: isSet(object.operationName) ? globalThis.String(object.operationName) : "",
      parameters: isObject(object.parameters) ? object.parameters : undefined,
      context: isSet(object.context) ? ExecutionContext.fromJSON(object.context) : undefined,
    };
  },

  toJSON(message: ExecuteOperationRequest): unknown {
    const obj: any = {};
    if (message.operationName !== "") {
      obj.operationName = message.operationName;
    }
    if (message.parameters !== undefined) {
      obj.parameters = message.parameters;
    }
    if (message.context !== undefined) {
      obj.context = ExecutionContext.toJSON(message.context);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExecuteOperationRequest>, I>>(base?: I): ExecuteOperationRequest {
    return ExecuteOperationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExecuteOperationRequest>, I>>(object: I): ExecuteOperationRequest {
    const message = createBaseExecuteOperationRequest();
    message.operationName = object.operationName ?? "";
    message.parameters = object.parameters ?? undefined;
    message.context = (object.context !== undefined && object.context !== null)
      ? ExecutionContext.fromPartial(object.context)
      : undefined;
    return message;
  },
};

function createBaseExecuteOperationResponse(): ExecuteOperationResponse {
  return { success: false, result: undefined, errorMessage: "", executionTimeMs: "0", affectedTables: [] };
}

export const ExecuteOperationResponse = {
  encode(message: ExecuteOperationResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.result !== undefined) {
      Any.encode(message.result, writer.uint32(18).fork()).ldelim();
    }
    if (message.errorMessage !== "") {
      writer.uint32(26).string(message.errorMessage);
    }
    if (message.executionTimeMs !== "0") {
      writer.uint32(32).int64(message.executionTimeMs);
    }
    for (const v of message.affectedTables) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExecuteOperationResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecuteOperationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.result = Any.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.executionTimeMs = longToString(reader.int64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.affectedTables.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecuteOperationResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      result: isSet(object.result) ? Any.fromJSON(object.result) : undefined,
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
      executionTimeMs: isSet(object.executionTimeMs) ? globalThis.String(object.executionTimeMs) : "0",
      affectedTables: globalThis.Array.isArray(object?.affectedTables)
        ? object.affectedTables.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ExecuteOperationResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.result !== undefined) {
      obj.result = Any.toJSON(message.result);
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    if (message.executionTimeMs !== "0") {
      obj.executionTimeMs = message.executionTimeMs;
    }
    if (message.affectedTables?.length) {
      obj.affectedTables = message.affectedTables;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExecuteOperationResponse>, I>>(base?: I): ExecuteOperationResponse {
    return ExecuteOperationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExecuteOperationResponse>, I>>(object: I): ExecuteOperationResponse {
    const message = createBaseExecuteOperationResponse();
    message.success = object.success ?? false;
    message.result = (object.result !== undefined && object.result !== null)
      ? Any.fromPartial(object.result)
      : undefined;
    message.errorMessage = object.errorMessage ?? "";
    message.executionTimeMs = object.executionTimeMs ?? "0";
    message.affectedTables = object.affectedTables?.map((e) => e) || [];
    return message;
  },
};

function createBaseHealthCheckRequest(): HealthCheckRequest {
  return { includeDetails: false };
}

export const HealthCheckRequest = {
  encode(message: HealthCheckRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.includeDetails !== false) {
      writer.uint32(8).bool(message.includeDetails);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HealthCheckRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheckRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.includeDetails = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthCheckRequest {
    return { includeDetails: isSet(object.includeDetails) ? globalThis.Boolean(object.includeDetails) : false };
  },

  toJSON(message: HealthCheckRequest): unknown {
    const obj: any = {};
    if (message.includeDetails !== false) {
      obj.includeDetails = message.includeDetails;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthCheckRequest>, I>>(base?: I): HealthCheckRequest {
    return HealthCheckRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthCheckRequest>, I>>(object: I): HealthCheckRequest {
    const message = createBaseHealthCheckRequest();
    message.includeDetails = object.includeDetails ?? false;
    return message;
  },
};

function createBaseHealthCheckResponse(): HealthCheckResponse {
  return { healthy: false, version: "", uptimeSeconds: "0", technologyHealth: [] };
}

export const HealthCheckResponse = {
  encode(message: HealthCheckResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.healthy !== false) {
      writer.uint32(8).bool(message.healthy);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    if (message.uptimeSeconds !== "0") {
      writer.uint32(24).int64(message.uptimeSeconds);
    }
    for (const v of message.technologyHealth) {
      TechnologyHealth.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HealthCheckResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheckResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.healthy = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.version = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.uptimeSeconds = longToString(reader.int64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.technologyHealth.push(TechnologyHealth.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthCheckResponse {
    return {
      healthy: isSet(object.healthy) ? globalThis.Boolean(object.healthy) : false,
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      uptimeSeconds: isSet(object.uptimeSeconds) ? globalThis.String(object.uptimeSeconds) : "0",
      technologyHealth: globalThis.Array.isArray(object?.technologyHealth)
        ? object.technologyHealth.map((e: any) => TechnologyHealth.fromJSON(e))
        : [],
    };
  },

  toJSON(message: HealthCheckResponse): unknown {
    const obj: any = {};
    if (message.healthy !== false) {
      obj.healthy = message.healthy;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.uptimeSeconds !== "0") {
      obj.uptimeSeconds = message.uptimeSeconds;
    }
    if (message.technologyHealth?.length) {
      obj.technologyHealth = message.technologyHealth.map((e) => TechnologyHealth.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthCheckResponse>, I>>(base?: I): HealthCheckResponse {
    return HealthCheckResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthCheckResponse>, I>>(object: I): HealthCheckResponse {
    const message = createBaseHealthCheckResponse();
    message.healthy = object.healthy ?? false;
    message.version = object.version ?? "";
    message.uptimeSeconds = object.uptimeSeconds ?? "0";
    message.technologyHealth = object.technologyHealth?.map((e) => TechnologyHealth.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTechnologyHealth(): TechnologyHealth {
  return { technology: "", healthy: false, status: "", responseTimeMs: "0", errorMessage: "" };
}

export const TechnologyHealth = {
  encode(message: TechnologyHealth, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.technology !== "") {
      writer.uint32(10).string(message.technology);
    }
    if (message.healthy !== false) {
      writer.uint32(16).bool(message.healthy);
    }
    if (message.status !== "") {
      writer.uint32(26).string(message.status);
    }
    if (message.responseTimeMs !== "0") {
      writer.uint32(32).int64(message.responseTimeMs);
    }
    if (message.errorMessage !== "") {
      writer.uint32(42).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TechnologyHealth {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTechnologyHealth();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.technology = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.healthy = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.status = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.responseTimeMs = longToString(reader.int64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TechnologyHealth {
    return {
      technology: isSet(object.technology) ? globalThis.String(object.technology) : "",
      healthy: isSet(object.healthy) ? globalThis.Boolean(object.healthy) : false,
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      responseTimeMs: isSet(object.responseTimeMs) ? globalThis.String(object.responseTimeMs) : "0",
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
    };
  },

  toJSON(message: TechnologyHealth): unknown {
    const obj: any = {};
    if (message.technology !== "") {
      obj.technology = message.technology;
    }
    if (message.healthy !== false) {
      obj.healthy = message.healthy;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.responseTimeMs !== "0") {
      obj.responseTimeMs = message.responseTimeMs;
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TechnologyHealth>, I>>(base?: I): TechnologyHealth {
    return TechnologyHealth.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TechnologyHealth>, I>>(object: I): TechnologyHealth {
    const message = createBaseTechnologyHealth();
    message.technology = object.technology ?? "";
    message.healthy = object.healthy ?? false;
    message.status = object.status ?? "";
    message.responseTimeMs = object.responseTimeMs ?? "0";
    message.errorMessage = object.errorMessage ?? "";
    return message;
  },
};

function createBaseGetPlatformInfoRequest(): GetPlatformInfoRequest {
  return {};
}

export const GetPlatformInfoRequest = {
  encode(_: GetPlatformInfoRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetPlatformInfoRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPlatformInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetPlatformInfoRequest {
    return {};
  },

  toJSON(_: GetPlatformInfoRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPlatformInfoRequest>, I>>(base?: I): GetPlatformInfoRequest {
    return GetPlatformInfoRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPlatformInfoRequest>, I>>(_: I): GetPlatformInfoRequest {
    const message = createBaseGetPlatformInfoRequest();
    return message;
  },
};

function createBaseGetPlatformInfoResponse(): GetPlatformInfoResponse {
  return { platformName: "", version: "", supportedTechnologies: [], supportedFeatures: [], configuration: undefined };
}

export const GetPlatformInfoResponse = {
  encode(message: GetPlatformInfoResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.platformName !== "") {
      writer.uint32(10).string(message.platformName);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    for (const v of message.supportedTechnologies) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.supportedFeatures) {
      writer.uint32(34).string(v!);
    }
    if (message.configuration !== undefined) {
      Struct.encode(Struct.wrap(message.configuration), writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetPlatformInfoResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPlatformInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.platformName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.version = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.supportedTechnologies.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.supportedFeatures.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.configuration = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPlatformInfoResponse {
    return {
      platformName: isSet(object.platformName) ? globalThis.String(object.platformName) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      supportedTechnologies: globalThis.Array.isArray(object?.supportedTechnologies)
        ? object.supportedTechnologies.map((e: any) => globalThis.String(e))
        : [],
      supportedFeatures: globalThis.Array.isArray(object?.supportedFeatures)
        ? object.supportedFeatures.map((e: any) => globalThis.String(e))
        : [],
      configuration: isObject(object.configuration) ? object.configuration : undefined,
    };
  },

  toJSON(message: GetPlatformInfoResponse): unknown {
    const obj: any = {};
    if (message.platformName !== "") {
      obj.platformName = message.platformName;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.supportedTechnologies?.length) {
      obj.supportedTechnologies = message.supportedTechnologies;
    }
    if (message.supportedFeatures?.length) {
      obj.supportedFeatures = message.supportedFeatures;
    }
    if (message.configuration !== undefined) {
      obj.configuration = message.configuration;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPlatformInfoResponse>, I>>(base?: I): GetPlatformInfoResponse {
    return GetPlatformInfoResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPlatformInfoResponse>, I>>(object: I): GetPlatformInfoResponse {
    const message = createBaseGetPlatformInfoResponse();
    message.platformName = object.platformName ?? "";
    message.version = object.version ?? "";
    message.supportedTechnologies = object.supportedTechnologies?.map((e) => e) || [];
    message.supportedFeatures = object.supportedFeatures?.map((e) => e) || [];
    message.configuration = object.configuration ?? undefined;
    return message;
  },
};

function createBaseGetMetricsRequest(): GetMetricsRequest {
  return { format: "" };
}

export const GetMetricsRequest = {
  encode(message: GetMetricsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.format !== "") {
      writer.uint32(10).string(message.format);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetMetricsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMetricsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.format = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetMetricsRequest {
    return { format: isSet(object.format) ? globalThis.String(object.format) : "" };
  },

  toJSON(message: GetMetricsRequest): unknown {
    const obj: any = {};
    if (message.format !== "") {
      obj.format = message.format;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetMetricsRequest>, I>>(base?: I): GetMetricsRequest {
    return GetMetricsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetMetricsRequest>, I>>(object: I): GetMetricsRequest {
    const message = createBaseGetMetricsRequest();
    message.format = object.format ?? "";
    return message;
  },
};

function createBaseGetMetricsResponse(): GetMetricsResponse {
  return { format: "", metricsData: "", collectedAt: undefined };
}

export const GetMetricsResponse = {
  encode(message: GetMetricsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.format !== "") {
      writer.uint32(10).string(message.format);
    }
    if (message.metricsData !== "") {
      writer.uint32(18).string(message.metricsData);
    }
    if (message.collectedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.collectedAt), writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetMetricsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMetricsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.format = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.metricsData = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.collectedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetMetricsResponse {
    return {
      format: isSet(object.format) ? globalThis.String(object.format) : "",
      metricsData: isSet(object.metricsData) ? globalThis.String(object.metricsData) : "",
      collectedAt: isSet(object.collectedAt) ? fromJsonTimestamp(object.collectedAt) : undefined,
    };
  },

  toJSON(message: GetMetricsResponse): unknown {
    const obj: any = {};
    if (message.format !== "") {
      obj.format = message.format;
    }
    if (message.metricsData !== "") {
      obj.metricsData = message.metricsData;
    }
    if (message.collectedAt !== undefined) {
      obj.collectedAt = message.collectedAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetMetricsResponse>, I>>(base?: I): GetMetricsResponse {
    return GetMetricsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetMetricsResponse>, I>>(object: I): GetMetricsResponse {
    const message = createBaseGetMetricsResponse();
    message.format = object.format ?? "";
    message.metricsData = object.metricsData ?? "";
    message.collectedAt = object.collectedAt ?? undefined;
    return message;
  },
};

export type PersistencePlatformServiceService = typeof PersistencePlatformServiceService;
export const PersistencePlatformServiceService = {
  /** CRUD Operations */
  insert: {
    path: "/unhinged.persistence.PersistencePlatformService/Insert",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: InsertRequest) => Buffer.from(InsertRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => InsertRequest.decode(value),
    responseSerialize: (value: InsertResponse) => Buffer.from(InsertResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => InsertResponse.decode(value),
  },
  insertBatch: {
    path: "/unhinged.persistence.PersistencePlatformService/InsertBatch",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: InsertBatchRequest) => Buffer.from(InsertBatchRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => InsertBatchRequest.decode(value),
    responseSerialize: (value: InsertBatchResponse) => Buffer.from(InsertBatchResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => InsertBatchResponse.decode(value),
  },
  update: {
    path: "/unhinged.persistence.PersistencePlatformService/Update",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateRequest) => Buffer.from(UpdateRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UpdateRequest.decode(value),
    responseSerialize: (value: UpdateResponse) => Buffer.from(UpdateResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => UpdateResponse.decode(value),
  },
  delete: {
    path: "/unhinged.persistence.PersistencePlatformService/Delete",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteRequest) => Buffer.from(DeleteRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DeleteRequest.decode(value),
    responseSerialize: (value: DeleteResponse) => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DeleteResponse.decode(value),
  },
  /** Query Operations */
  executeQuery: {
    path: "/unhinged.persistence.PersistencePlatformService/ExecuteQuery",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ExecuteQueryRequest) => Buffer.from(ExecuteQueryRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ExecuteQueryRequest.decode(value),
    responseSerialize: (value: ExecuteQueryResponse) => Buffer.from(ExecuteQueryResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ExecuteQueryResponse.decode(value),
  },
  executeRawQuery: {
    path: "/unhinged.persistence.PersistencePlatformService/ExecuteRawQuery",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ExecuteRawQueryRequest) => Buffer.from(ExecuteRawQueryRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ExecuteRawQueryRequest.decode(value),
    responseSerialize: (value: ExecuteRawQueryResponse) => Buffer.from(ExecuteRawQueryResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ExecuteRawQueryResponse.decode(value),
  },
  /** Vector Operations */
  vectorSearch: {
    path: "/unhinged.persistence.PersistencePlatformService/VectorSearch",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: VectorSearchRequest) => Buffer.from(VectorSearchRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => VectorSearchRequest.decode(value),
    responseSerialize: (value: VectorSearchResponse) => Buffer.from(VectorSearchResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => VectorSearchResponse.decode(value),
  },
  /** Graph Operations */
  graphTraverse: {
    path: "/unhinged.persistence.PersistencePlatformService/GraphTraverse",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GraphTraverseRequest) => Buffer.from(GraphTraverseRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GraphTraverseRequest.decode(value),
    responseSerialize: (value: GraphTraverseResponse) => Buffer.from(GraphTraverseResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GraphTraverseResponse.decode(value),
  },
  /** Complex Operations */
  executeOperation: {
    path: "/unhinged.persistence.PersistencePlatformService/ExecuteOperation",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ExecuteOperationRequest) => Buffer.from(ExecuteOperationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ExecuteOperationRequest.decode(value),
    responseSerialize: (value: ExecuteOperationResponse) =>
      Buffer.from(ExecuteOperationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ExecuteOperationResponse.decode(value),
  },
  /** Platform Management */
  healthCheck: {
    path: "/unhinged.persistence.PersistencePlatformService/HealthCheck",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: HealthCheckRequest) => Buffer.from(HealthCheckRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => HealthCheckRequest.decode(value),
    responseSerialize: (value: HealthCheckResponse) => Buffer.from(HealthCheckResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => HealthCheckResponse.decode(value),
  },
  getPlatformInfo: {
    path: "/unhinged.persistence.PersistencePlatformService/GetPlatformInfo",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetPlatformInfoRequest) => Buffer.from(GetPlatformInfoRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetPlatformInfoRequest.decode(value),
    responseSerialize: (value: GetPlatformInfoResponse) => Buffer.from(GetPlatformInfoResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetPlatformInfoResponse.decode(value),
  },
  getMetrics: {
    path: "/unhinged.persistence.PersistencePlatformService/GetMetrics",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetMetricsRequest) => Buffer.from(GetMetricsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetMetricsRequest.decode(value),
    responseSerialize: (value: GetMetricsResponse) => Buffer.from(GetMetricsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetMetricsResponse.decode(value),
  },
} as const;

export interface PersistencePlatformServiceServer extends UntypedServiceImplementation {
  /** CRUD Operations */
  insert: handleUnaryCall<InsertRequest, InsertResponse>;
  insertBatch: handleUnaryCall<InsertBatchRequest, InsertBatchResponse>;
  update: handleUnaryCall<UpdateRequest, UpdateResponse>;
  delete: handleUnaryCall<DeleteRequest, DeleteResponse>;
  /** Query Operations */
  executeQuery: handleUnaryCall<ExecuteQueryRequest, ExecuteQueryResponse>;
  executeRawQuery: handleUnaryCall<ExecuteRawQueryRequest, ExecuteRawQueryResponse>;
  /** Vector Operations */
  vectorSearch: handleUnaryCall<VectorSearchRequest, VectorSearchResponse>;
  /** Graph Operations */
  graphTraverse: handleUnaryCall<GraphTraverseRequest, GraphTraverseResponse>;
  /** Complex Operations */
  executeOperation: handleUnaryCall<ExecuteOperationRequest, ExecuteOperationResponse>;
  /** Platform Management */
  healthCheck: handleUnaryCall<HealthCheckRequest, HealthCheckResponse>;
  getPlatformInfo: handleUnaryCall<GetPlatformInfoRequest, GetPlatformInfoResponse>;
  getMetrics: handleUnaryCall<GetMetricsRequest, GetMetricsResponse>;
}

export interface PersistencePlatformServiceClient extends Client {
  /** CRUD Operations */
  insert(
    request: InsertRequest,
    callback: (error: ServiceError | null, response: InsertResponse) => void,
  ): ClientUnaryCall;
  insert(
    request: InsertRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: InsertResponse) => void,
  ): ClientUnaryCall;
  insert(
    request: InsertRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: InsertResponse) => void,
  ): ClientUnaryCall;
  insertBatch(
    request: InsertBatchRequest,
    callback: (error: ServiceError | null, response: InsertBatchResponse) => void,
  ): ClientUnaryCall;
  insertBatch(
    request: InsertBatchRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: InsertBatchResponse) => void,
  ): ClientUnaryCall;
  insertBatch(
    request: InsertBatchRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: InsertBatchResponse) => void,
  ): ClientUnaryCall;
  update(
    request: UpdateRequest,
    callback: (error: ServiceError | null, response: UpdateResponse) => void,
  ): ClientUnaryCall;
  update(
    request: UpdateRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: UpdateResponse) => void,
  ): ClientUnaryCall;
  update(
    request: UpdateRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: UpdateResponse) => void,
  ): ClientUnaryCall;
  delete(
    request: DeleteRequest,
    callback: (error: ServiceError | null, response: DeleteResponse) => void,
  ): ClientUnaryCall;
  delete(
    request: DeleteRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DeleteResponse) => void,
  ): ClientUnaryCall;
  delete(
    request: DeleteRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DeleteResponse) => void,
  ): ClientUnaryCall;
  /** Query Operations */
  executeQuery(
    request: ExecuteQueryRequest,
    callback: (error: ServiceError | null, response: ExecuteQueryResponse) => void,
  ): ClientUnaryCall;
  executeQuery(
    request: ExecuteQueryRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ExecuteQueryResponse) => void,
  ): ClientUnaryCall;
  executeQuery(
    request: ExecuteQueryRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ExecuteQueryResponse) => void,
  ): ClientUnaryCall;
  executeRawQuery(
    request: ExecuteRawQueryRequest,
    callback: (error: ServiceError | null, response: ExecuteRawQueryResponse) => void,
  ): ClientUnaryCall;
  executeRawQuery(
    request: ExecuteRawQueryRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ExecuteRawQueryResponse) => void,
  ): ClientUnaryCall;
  executeRawQuery(
    request: ExecuteRawQueryRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ExecuteRawQueryResponse) => void,
  ): ClientUnaryCall;
  /** Vector Operations */
  vectorSearch(
    request: VectorSearchRequest,
    callback: (error: ServiceError | null, response: VectorSearchResponse) => void,
  ): ClientUnaryCall;
  vectorSearch(
    request: VectorSearchRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: VectorSearchResponse) => void,
  ): ClientUnaryCall;
  vectorSearch(
    request: VectorSearchRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: VectorSearchResponse) => void,
  ): ClientUnaryCall;
  /** Graph Operations */
  graphTraverse(
    request: GraphTraverseRequest,
    callback: (error: ServiceError | null, response: GraphTraverseResponse) => void,
  ): ClientUnaryCall;
  graphTraverse(
    request: GraphTraverseRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GraphTraverseResponse) => void,
  ): ClientUnaryCall;
  graphTraverse(
    request: GraphTraverseRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GraphTraverseResponse) => void,
  ): ClientUnaryCall;
  /** Complex Operations */
  executeOperation(
    request: ExecuteOperationRequest,
    callback: (error: ServiceError | null, response: ExecuteOperationResponse) => void,
  ): ClientUnaryCall;
  executeOperation(
    request: ExecuteOperationRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ExecuteOperationResponse) => void,
  ): ClientUnaryCall;
  executeOperation(
    request: ExecuteOperationRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ExecuteOperationResponse) => void,
  ): ClientUnaryCall;
  /** Platform Management */
  healthCheck(
    request: HealthCheckRequest,
    callback: (error: ServiceError | null, response: HealthCheckResponse) => void,
  ): ClientUnaryCall;
  healthCheck(
    request: HealthCheckRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: HealthCheckResponse) => void,
  ): ClientUnaryCall;
  healthCheck(
    request: HealthCheckRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: HealthCheckResponse) => void,
  ): ClientUnaryCall;
  getPlatformInfo(
    request: GetPlatformInfoRequest,
    callback: (error: ServiceError | null, response: GetPlatformInfoResponse) => void,
  ): ClientUnaryCall;
  getPlatformInfo(
    request: GetPlatformInfoRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetPlatformInfoResponse) => void,
  ): ClientUnaryCall;
  getPlatformInfo(
    request: GetPlatformInfoRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetPlatformInfoResponse) => void,
  ): ClientUnaryCall;
  getMetrics(
    request: GetMetricsRequest,
    callback: (error: ServiceError | null, response: GetMetricsResponse) => void,
  ): ClientUnaryCall;
  getMetrics(
    request: GetMetricsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetMetricsResponse) => void,
  ): ClientUnaryCall;
  getMetrics(
    request: GetMetricsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetMetricsResponse) => void,
  ): ClientUnaryCall;
}

export const PersistencePlatformServiceClient = makeGenericClientConstructor(
  PersistencePlatformServiceService,
  "unhinged.persistence.PersistencePlatformService",
) as unknown as {
  new (
    address: string,
    credentials: ChannelCredentials,
    options?: Partial<ClientOptions>,
  ): PersistencePlatformServiceClient;
  service: typeof PersistencePlatformServiceService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000).toString();
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (globalThis.Number(t.seconds) || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToString(long: Long) {
  return long.toString();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
