// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v3.21.12
// source: gateway_annotations.proto

/* eslint-disable */
import _m0 from "protobufjs/minimal";

/**
 * HTTP endpoint configuration for gRPC methods
 * Generates REST endpoints with automatic request/response translation
 */
export interface HttpRule {
  /** HTTP method and path */
  method: string;
  /** "/api/v1/conversations/{id}" */
  path: string;
  /** Request body handling */
  body: string;
  /** Fields to extract from query parameters */
  queryParams: string[];
  /** Response configuration */
  streamResponse: boolean;
  /** Wrap response in specific field */
  responseWrapper: string;
  /** Authentication and authorization */
  authRequired: boolean;
  requiredScopes: string[];
  /** "bearer", "api_key", "session" */
  authType: string;
  /** Rate limiting */
  rateLimit?:
    | RateLimitRule
    | undefined;
  /** Caching */
  cache?:
    | CacheRule
    | undefined;
  /** CORS configuration */
  cors?:
    | CorsRule
    | undefined;
  /** Documentation */
  summary: string;
  description: string;
  tags: string[];
}

/** Rate limiting configuration */
export interface RateLimitRule {
  requestsPerMinute: number;
  requestsPerHour: number;
  requestsPerDay: number;
  /** "ip", "user", "api_key", "custom" */
  keyStrategy: string;
  /** Field to use for custom key strategy */
  customKeyField: string;
}

/** Caching configuration */
export interface CacheRule {
  ttlSeconds: number;
  /** Fields to use as cache keys */
  cacheKeys: string[];
  /** User-specific caching */
  privateCache: boolean;
  /** Headers that affect cache */
  varyHeaders: string[];
}

/** CORS configuration */
export interface CorsRule {
  allowedOrigins: string[];
  allowedMethods: string[];
  allowedHeaders: string[];
  allowCredentials: boolean;
  maxAgeSeconds: number;
}

/**
 * WebSocket configuration for bidirectional streaming
 * Generates WebSocket handlers with automatic message routing
 */
export interface WebSocketRule {
  /** "/ws/chat/{conversation_id}" */
  path: string;
  /** Message type identifier */
  eventType: string;
  /** Connection management */
  authRequired: boolean;
  requiredScopes: string[];
  maxConnectionsPerUser: number;
  idleTimeoutSeconds: number;
  /** Message handling */
  requestField: string;
  /** Field to wrap response in */
  responseField: string;
  /** Broadcast to all connections */
  broadcast: boolean;
  /** Filter expression for broadcast */
  broadcastFilter: string;
  /** Rate limiting */
  rateLimit?:
    | RateLimitRule
    | undefined;
  /** Documentation */
  summary: string;
  description: string;
  tags: string[];
}

/**
 * Server-Sent Events configuration for server streaming
 * Generates SSE endpoints with automatic stream management
 */
export interface ServerSentEventsRule {
  /** "/api/v1/events/{stream_id}" */
  path: string;
  /** SSE event type */
  eventType: string;
  /** Stream configuration */
  authRequired: boolean;
  requiredScopes: string[];
  keepaliveIntervalSeconds: number;
  maxStreamDurationSeconds: number;
  /** Message formatting */
  dataField: string;
  /** Field for event ID */
  idField: string;
  /** JSON encode the data field */
  jsonEncode: boolean;
  /** Filtering and routing */
  filterParams: string[];
  /** Field for message routing */
  routingKey: string;
  /** Documentation */
  summary: string;
  description: string;
  tags: string[];
}

/**
 * Long polling configuration for legacy client support
 * Generates long polling endpoints with timeout handling
 */
export interface LongPollingRule {
  /** "/api/v1/poll/{resource_id}" */
  path: string;
  /** Maximum wait time */
  timeoutSeconds: number;
  /** Maximum events per response */
  maxEvents: number;
  /** Authentication */
  authRequired: boolean;
  requiredScopes: string[];
  /** Response configuration */
  eventsField: string;
  /** Field for pagination cursor */
  cursorField: string;
  /** Include timing metadata */
  includeMetadata: boolean;
  /** Documentation */
  summary: string;
  description: string;
  tags: string[];
}

/**
 * Service-level gateway configuration
 * Applied to entire gRPC services
 */
export interface ServiceRule {
  /** "/api/v1/chat" */
  basePath: string;
  /** "v1", "v2", etc. */
  version: string;
  /** Default authentication */
  defaultAuthRequired: boolean;
  defaultScopes: string[];
  /** "jwt", "oauth2", "api_key" */
  authProvider: string;
  /** Default rate limiting */
  defaultRateLimit?:
    | RateLimitRule
    | undefined;
  /** Default CORS */
  defaultCors?:
    | CorsRule
    | undefined;
  /** OpenAPI documentation */
  title: string;
  description: string;
  tags: string[];
  contactEmail: string;
  license: string;
}

function createBaseHttpRule(): HttpRule {
  return {
    method: "",
    path: "",
    body: "",
    queryParams: [],
    streamResponse: false,
    responseWrapper: "",
    authRequired: false,
    requiredScopes: [],
    authType: "",
    rateLimit: undefined,
    cache: undefined,
    cors: undefined,
    summary: "",
    description: "",
    tags: [],
  };
}

export const HttpRule = {
  encode(message: HttpRule, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.method !== "") {
      writer.uint32(10).string(message.method);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    if (message.body !== "") {
      writer.uint32(26).string(message.body);
    }
    for (const v of message.queryParams) {
      writer.uint32(34).string(v!);
    }
    if (message.streamResponse !== false) {
      writer.uint32(40).bool(message.streamResponse);
    }
    if (message.responseWrapper !== "") {
      writer.uint32(50).string(message.responseWrapper);
    }
    if (message.authRequired !== false) {
      writer.uint32(80).bool(message.authRequired);
    }
    for (const v of message.requiredScopes) {
      writer.uint32(90).string(v!);
    }
    if (message.authType !== "") {
      writer.uint32(98).string(message.authType);
    }
    if (message.rateLimit !== undefined) {
      RateLimitRule.encode(message.rateLimit, writer.uint32(122).fork()).ldelim();
    }
    if (message.cache !== undefined) {
      CacheRule.encode(message.cache, writer.uint32(130).fork()).ldelim();
    }
    if (message.cors !== undefined) {
      CorsRule.encode(message.cors, writer.uint32(138).fork()).ldelim();
    }
    if (message.summary !== "") {
      writer.uint32(162).string(message.summary);
    }
    if (message.description !== "") {
      writer.uint32(170).string(message.description);
    }
    for (const v of message.tags) {
      writer.uint32(178).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HttpRule {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.method = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.path = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.body = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.queryParams.push(reader.string());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.streamResponse = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.responseWrapper = reader.string();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.authRequired = reader.bool();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.requiredScopes.push(reader.string());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.authType = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.rateLimit = RateLimitRule.decode(reader, reader.uint32());
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.cache = CacheRule.decode(reader, reader.uint32());
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.cors = CorsRule.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.summary = reader.string();
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.description = reader.string();
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.tags.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpRule {
    return {
      method: isSet(object.method) ? globalThis.String(object.method) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      body: isSet(object.body) ? globalThis.String(object.body) : "",
      queryParams: globalThis.Array.isArray(object?.queryParams)
        ? object.queryParams.map((e: any) => globalThis.String(e))
        : [],
      streamResponse: isSet(object.streamResponse) ? globalThis.Boolean(object.streamResponse) : false,
      responseWrapper: isSet(object.responseWrapper) ? globalThis.String(object.responseWrapper) : "",
      authRequired: isSet(object.authRequired) ? globalThis.Boolean(object.authRequired) : false,
      requiredScopes: globalThis.Array.isArray(object?.requiredScopes)
        ? object.requiredScopes.map((e: any) => globalThis.String(e))
        : [],
      authType: isSet(object.authType) ? globalThis.String(object.authType) : "",
      rateLimit: isSet(object.rateLimit) ? RateLimitRule.fromJSON(object.rateLimit) : undefined,
      cache: isSet(object.cache) ? CacheRule.fromJSON(object.cache) : undefined,
      cors: isSet(object.cors) ? CorsRule.fromJSON(object.cors) : undefined,
      summary: isSet(object.summary) ? globalThis.String(object.summary) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: HttpRule): unknown {
    const obj: any = {};
    if (message.method !== "") {
      obj.method = message.method;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.body !== "") {
      obj.body = message.body;
    }
    if (message.queryParams?.length) {
      obj.queryParams = message.queryParams;
    }
    if (message.streamResponse !== false) {
      obj.streamResponse = message.streamResponse;
    }
    if (message.responseWrapper !== "") {
      obj.responseWrapper = message.responseWrapper;
    }
    if (message.authRequired !== false) {
      obj.authRequired = message.authRequired;
    }
    if (message.requiredScopes?.length) {
      obj.requiredScopes = message.requiredScopes;
    }
    if (message.authType !== "") {
      obj.authType = message.authType;
    }
    if (message.rateLimit !== undefined) {
      obj.rateLimit = RateLimitRule.toJSON(message.rateLimit);
    }
    if (message.cache !== undefined) {
      obj.cache = CacheRule.toJSON(message.cache);
    }
    if (message.cors !== undefined) {
      obj.cors = CorsRule.toJSON(message.cors);
    }
    if (message.summary !== "") {
      obj.summary = message.summary;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HttpRule>, I>>(base?: I): HttpRule {
    return HttpRule.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HttpRule>, I>>(object: I): HttpRule {
    const message = createBaseHttpRule();
    message.method = object.method ?? "";
    message.path = object.path ?? "";
    message.body = object.body ?? "";
    message.queryParams = object.queryParams?.map((e) => e) || [];
    message.streamResponse = object.streamResponse ?? false;
    message.responseWrapper = object.responseWrapper ?? "";
    message.authRequired = object.authRequired ?? false;
    message.requiredScopes = object.requiredScopes?.map((e) => e) || [];
    message.authType = object.authType ?? "";
    message.rateLimit = (object.rateLimit !== undefined && object.rateLimit !== null)
      ? RateLimitRule.fromPartial(object.rateLimit)
      : undefined;
    message.cache = (object.cache !== undefined && object.cache !== null)
      ? CacheRule.fromPartial(object.cache)
      : undefined;
    message.cors = (object.cors !== undefined && object.cors !== null) ? CorsRule.fromPartial(object.cors) : undefined;
    message.summary = object.summary ?? "";
    message.description = object.description ?? "";
    message.tags = object.tags?.map((e) => e) || [];
    return message;
  },
};

function createBaseRateLimitRule(): RateLimitRule {
  return { requestsPerMinute: 0, requestsPerHour: 0, requestsPerDay: 0, keyStrategy: "", customKeyField: "" };
}

export const RateLimitRule = {
  encode(message: RateLimitRule, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.requestsPerMinute !== 0) {
      writer.uint32(8).int32(message.requestsPerMinute);
    }
    if (message.requestsPerHour !== 0) {
      writer.uint32(16).int32(message.requestsPerHour);
    }
    if (message.requestsPerDay !== 0) {
      writer.uint32(24).int32(message.requestsPerDay);
    }
    if (message.keyStrategy !== "") {
      writer.uint32(34).string(message.keyStrategy);
    }
    if (message.customKeyField !== "") {
      writer.uint32(42).string(message.customKeyField);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RateLimitRule {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimitRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.requestsPerMinute = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.requestsPerHour = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.requestsPerDay = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.keyStrategy = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.customKeyField = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RateLimitRule {
    return {
      requestsPerMinute: isSet(object.requestsPerMinute) ? globalThis.Number(object.requestsPerMinute) : 0,
      requestsPerHour: isSet(object.requestsPerHour) ? globalThis.Number(object.requestsPerHour) : 0,
      requestsPerDay: isSet(object.requestsPerDay) ? globalThis.Number(object.requestsPerDay) : 0,
      keyStrategy: isSet(object.keyStrategy) ? globalThis.String(object.keyStrategy) : "",
      customKeyField: isSet(object.customKeyField) ? globalThis.String(object.customKeyField) : "",
    };
  },

  toJSON(message: RateLimitRule): unknown {
    const obj: any = {};
    if (message.requestsPerMinute !== 0) {
      obj.requestsPerMinute = Math.round(message.requestsPerMinute);
    }
    if (message.requestsPerHour !== 0) {
      obj.requestsPerHour = Math.round(message.requestsPerHour);
    }
    if (message.requestsPerDay !== 0) {
      obj.requestsPerDay = Math.round(message.requestsPerDay);
    }
    if (message.keyStrategy !== "") {
      obj.keyStrategy = message.keyStrategy;
    }
    if (message.customKeyField !== "") {
      obj.customKeyField = message.customKeyField;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RateLimitRule>, I>>(base?: I): RateLimitRule {
    return RateLimitRule.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RateLimitRule>, I>>(object: I): RateLimitRule {
    const message = createBaseRateLimitRule();
    message.requestsPerMinute = object.requestsPerMinute ?? 0;
    message.requestsPerHour = object.requestsPerHour ?? 0;
    message.requestsPerDay = object.requestsPerDay ?? 0;
    message.keyStrategy = object.keyStrategy ?? "";
    message.customKeyField = object.customKeyField ?? "";
    return message;
  },
};

function createBaseCacheRule(): CacheRule {
  return { ttlSeconds: 0, cacheKeys: [], privateCache: false, varyHeaders: [] };
}

export const CacheRule = {
  encode(message: CacheRule, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ttlSeconds !== 0) {
      writer.uint32(8).int32(message.ttlSeconds);
    }
    for (const v of message.cacheKeys) {
      writer.uint32(18).string(v!);
    }
    if (message.privateCache !== false) {
      writer.uint32(24).bool(message.privateCache);
    }
    for (const v of message.varyHeaders) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CacheRule {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCacheRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.ttlSeconds = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cacheKeys.push(reader.string());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.privateCache = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.varyHeaders.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CacheRule {
    return {
      ttlSeconds: isSet(object.ttlSeconds) ? globalThis.Number(object.ttlSeconds) : 0,
      cacheKeys: globalThis.Array.isArray(object?.cacheKeys)
        ? object.cacheKeys.map((e: any) => globalThis.String(e))
        : [],
      privateCache: isSet(object.privateCache) ? globalThis.Boolean(object.privateCache) : false,
      varyHeaders: globalThis.Array.isArray(object?.varyHeaders)
        ? object.varyHeaders.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: CacheRule): unknown {
    const obj: any = {};
    if (message.ttlSeconds !== 0) {
      obj.ttlSeconds = Math.round(message.ttlSeconds);
    }
    if (message.cacheKeys?.length) {
      obj.cacheKeys = message.cacheKeys;
    }
    if (message.privateCache !== false) {
      obj.privateCache = message.privateCache;
    }
    if (message.varyHeaders?.length) {
      obj.varyHeaders = message.varyHeaders;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CacheRule>, I>>(base?: I): CacheRule {
    return CacheRule.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CacheRule>, I>>(object: I): CacheRule {
    const message = createBaseCacheRule();
    message.ttlSeconds = object.ttlSeconds ?? 0;
    message.cacheKeys = object.cacheKeys?.map((e) => e) || [];
    message.privateCache = object.privateCache ?? false;
    message.varyHeaders = object.varyHeaders?.map((e) => e) || [];
    return message;
  },
};

function createBaseCorsRule(): CorsRule {
  return { allowedOrigins: [], allowedMethods: [], allowedHeaders: [], allowCredentials: false, maxAgeSeconds: 0 };
}

export const CorsRule = {
  encode(message: CorsRule, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.allowedOrigins) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.allowedMethods) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.allowedHeaders) {
      writer.uint32(26).string(v!);
    }
    if (message.allowCredentials !== false) {
      writer.uint32(32).bool(message.allowCredentials);
    }
    if (message.maxAgeSeconds !== 0) {
      writer.uint32(40).int32(message.maxAgeSeconds);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CorsRule {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCorsRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.allowedOrigins.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.allowedMethods.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.allowedHeaders.push(reader.string());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.allowCredentials = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.maxAgeSeconds = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CorsRule {
    return {
      allowedOrigins: globalThis.Array.isArray(object?.allowedOrigins)
        ? object.allowedOrigins.map((e: any) => globalThis.String(e))
        : [],
      allowedMethods: globalThis.Array.isArray(object?.allowedMethods)
        ? object.allowedMethods.map((e: any) => globalThis.String(e))
        : [],
      allowedHeaders: globalThis.Array.isArray(object?.allowedHeaders)
        ? object.allowedHeaders.map((e: any) => globalThis.String(e))
        : [],
      allowCredentials: isSet(object.allowCredentials) ? globalThis.Boolean(object.allowCredentials) : false,
      maxAgeSeconds: isSet(object.maxAgeSeconds) ? globalThis.Number(object.maxAgeSeconds) : 0,
    };
  },

  toJSON(message: CorsRule): unknown {
    const obj: any = {};
    if (message.allowedOrigins?.length) {
      obj.allowedOrigins = message.allowedOrigins;
    }
    if (message.allowedMethods?.length) {
      obj.allowedMethods = message.allowedMethods;
    }
    if (message.allowedHeaders?.length) {
      obj.allowedHeaders = message.allowedHeaders;
    }
    if (message.allowCredentials !== false) {
      obj.allowCredentials = message.allowCredentials;
    }
    if (message.maxAgeSeconds !== 0) {
      obj.maxAgeSeconds = Math.round(message.maxAgeSeconds);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CorsRule>, I>>(base?: I): CorsRule {
    return CorsRule.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CorsRule>, I>>(object: I): CorsRule {
    const message = createBaseCorsRule();
    message.allowedOrigins = object.allowedOrigins?.map((e) => e) || [];
    message.allowedMethods = object.allowedMethods?.map((e) => e) || [];
    message.allowedHeaders = object.allowedHeaders?.map((e) => e) || [];
    message.allowCredentials = object.allowCredentials ?? false;
    message.maxAgeSeconds = object.maxAgeSeconds ?? 0;
    return message;
  },
};

function createBaseWebSocketRule(): WebSocketRule {
  return {
    path: "",
    eventType: "",
    authRequired: false,
    requiredScopes: [],
    maxConnectionsPerUser: 0,
    idleTimeoutSeconds: 0,
    requestField: "",
    responseField: "",
    broadcast: false,
    broadcastFilter: "",
    rateLimit: undefined,
    summary: "",
    description: "",
    tags: [],
  };
}

export const WebSocketRule = {
  encode(message: WebSocketRule, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.eventType !== "") {
      writer.uint32(18).string(message.eventType);
    }
    if (message.authRequired !== false) {
      writer.uint32(80).bool(message.authRequired);
    }
    for (const v of message.requiredScopes) {
      writer.uint32(90).string(v!);
    }
    if (message.maxConnectionsPerUser !== 0) {
      writer.uint32(96).int32(message.maxConnectionsPerUser);
    }
    if (message.idleTimeoutSeconds !== 0) {
      writer.uint32(104).int32(message.idleTimeoutSeconds);
    }
    if (message.requestField !== "") {
      writer.uint32(122).string(message.requestField);
    }
    if (message.responseField !== "") {
      writer.uint32(130).string(message.responseField);
    }
    if (message.broadcast !== false) {
      writer.uint32(136).bool(message.broadcast);
    }
    if (message.broadcastFilter !== "") {
      writer.uint32(146).string(message.broadcastFilter);
    }
    if (message.rateLimit !== undefined) {
      RateLimitRule.encode(message.rateLimit, writer.uint32(162).fork()).ldelim();
    }
    if (message.summary !== "") {
      writer.uint32(202).string(message.summary);
    }
    if (message.description !== "") {
      writer.uint32(210).string(message.description);
    }
    for (const v of message.tags) {
      writer.uint32(218).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WebSocketRule {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebSocketRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.eventType = reader.string();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.authRequired = reader.bool();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.requiredScopes.push(reader.string());
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.maxConnectionsPerUser = reader.int32();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.idleTimeoutSeconds = reader.int32();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.requestField = reader.string();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.responseField = reader.string();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.broadcast = reader.bool();
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.broadcastFilter = reader.string();
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.rateLimit = RateLimitRule.decode(reader, reader.uint32());
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.summary = reader.string();
          continue;
        case 26:
          if (tag !== 210) {
            break;
          }

          message.description = reader.string();
          continue;
        case 27:
          if (tag !== 218) {
            break;
          }

          message.tags.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebSocketRule {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      eventType: isSet(object.eventType) ? globalThis.String(object.eventType) : "",
      authRequired: isSet(object.authRequired) ? globalThis.Boolean(object.authRequired) : false,
      requiredScopes: globalThis.Array.isArray(object?.requiredScopes)
        ? object.requiredScopes.map((e: any) => globalThis.String(e))
        : [],
      maxConnectionsPerUser: isSet(object.maxConnectionsPerUser) ? globalThis.Number(object.maxConnectionsPerUser) : 0,
      idleTimeoutSeconds: isSet(object.idleTimeoutSeconds) ? globalThis.Number(object.idleTimeoutSeconds) : 0,
      requestField: isSet(object.requestField) ? globalThis.String(object.requestField) : "",
      responseField: isSet(object.responseField) ? globalThis.String(object.responseField) : "",
      broadcast: isSet(object.broadcast) ? globalThis.Boolean(object.broadcast) : false,
      broadcastFilter: isSet(object.broadcastFilter) ? globalThis.String(object.broadcastFilter) : "",
      rateLimit: isSet(object.rateLimit) ? RateLimitRule.fromJSON(object.rateLimit) : undefined,
      summary: isSet(object.summary) ? globalThis.String(object.summary) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: WebSocketRule): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.eventType !== "") {
      obj.eventType = message.eventType;
    }
    if (message.authRequired !== false) {
      obj.authRequired = message.authRequired;
    }
    if (message.requiredScopes?.length) {
      obj.requiredScopes = message.requiredScopes;
    }
    if (message.maxConnectionsPerUser !== 0) {
      obj.maxConnectionsPerUser = Math.round(message.maxConnectionsPerUser);
    }
    if (message.idleTimeoutSeconds !== 0) {
      obj.idleTimeoutSeconds = Math.round(message.idleTimeoutSeconds);
    }
    if (message.requestField !== "") {
      obj.requestField = message.requestField;
    }
    if (message.responseField !== "") {
      obj.responseField = message.responseField;
    }
    if (message.broadcast !== false) {
      obj.broadcast = message.broadcast;
    }
    if (message.broadcastFilter !== "") {
      obj.broadcastFilter = message.broadcastFilter;
    }
    if (message.rateLimit !== undefined) {
      obj.rateLimit = RateLimitRule.toJSON(message.rateLimit);
    }
    if (message.summary !== "") {
      obj.summary = message.summary;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebSocketRule>, I>>(base?: I): WebSocketRule {
    return WebSocketRule.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebSocketRule>, I>>(object: I): WebSocketRule {
    const message = createBaseWebSocketRule();
    message.path = object.path ?? "";
    message.eventType = object.eventType ?? "";
    message.authRequired = object.authRequired ?? false;
    message.requiredScopes = object.requiredScopes?.map((e) => e) || [];
    message.maxConnectionsPerUser = object.maxConnectionsPerUser ?? 0;
    message.idleTimeoutSeconds = object.idleTimeoutSeconds ?? 0;
    message.requestField = object.requestField ?? "";
    message.responseField = object.responseField ?? "";
    message.broadcast = object.broadcast ?? false;
    message.broadcastFilter = object.broadcastFilter ?? "";
    message.rateLimit = (object.rateLimit !== undefined && object.rateLimit !== null)
      ? RateLimitRule.fromPartial(object.rateLimit)
      : undefined;
    message.summary = object.summary ?? "";
    message.description = object.description ?? "";
    message.tags = object.tags?.map((e) => e) || [];
    return message;
  },
};

function createBaseServerSentEventsRule(): ServerSentEventsRule {
  return {
    path: "",
    eventType: "",
    authRequired: false,
    requiredScopes: [],
    keepaliveIntervalSeconds: 0,
    maxStreamDurationSeconds: 0,
    dataField: "",
    idField: "",
    jsonEncode: false,
    filterParams: [],
    routingKey: "",
    summary: "",
    description: "",
    tags: [],
  };
}

export const ServerSentEventsRule = {
  encode(message: ServerSentEventsRule, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.eventType !== "") {
      writer.uint32(18).string(message.eventType);
    }
    if (message.authRequired !== false) {
      writer.uint32(80).bool(message.authRequired);
    }
    for (const v of message.requiredScopes) {
      writer.uint32(90).string(v!);
    }
    if (message.keepaliveIntervalSeconds !== 0) {
      writer.uint32(96).int32(message.keepaliveIntervalSeconds);
    }
    if (message.maxStreamDurationSeconds !== 0) {
      writer.uint32(104).int32(message.maxStreamDurationSeconds);
    }
    if (message.dataField !== "") {
      writer.uint32(122).string(message.dataField);
    }
    if (message.idField !== "") {
      writer.uint32(130).string(message.idField);
    }
    if (message.jsonEncode !== false) {
      writer.uint32(136).bool(message.jsonEncode);
    }
    for (const v of message.filterParams) {
      writer.uint32(162).string(v!);
    }
    if (message.routingKey !== "") {
      writer.uint32(170).string(message.routingKey);
    }
    if (message.summary !== "") {
      writer.uint32(202).string(message.summary);
    }
    if (message.description !== "") {
      writer.uint32(210).string(message.description);
    }
    for (const v of message.tags) {
      writer.uint32(218).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ServerSentEventsRule {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServerSentEventsRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.eventType = reader.string();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.authRequired = reader.bool();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.requiredScopes.push(reader.string());
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.keepaliveIntervalSeconds = reader.int32();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.maxStreamDurationSeconds = reader.int32();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.dataField = reader.string();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.idField = reader.string();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.jsonEncode = reader.bool();
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.filterParams.push(reader.string());
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.routingKey = reader.string();
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.summary = reader.string();
          continue;
        case 26:
          if (tag !== 210) {
            break;
          }

          message.description = reader.string();
          continue;
        case 27:
          if (tag !== 218) {
            break;
          }

          message.tags.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServerSentEventsRule {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      eventType: isSet(object.eventType) ? globalThis.String(object.eventType) : "",
      authRequired: isSet(object.authRequired) ? globalThis.Boolean(object.authRequired) : false,
      requiredScopes: globalThis.Array.isArray(object?.requiredScopes)
        ? object.requiredScopes.map((e: any) => globalThis.String(e))
        : [],
      keepaliveIntervalSeconds: isSet(object.keepaliveIntervalSeconds)
        ? globalThis.Number(object.keepaliveIntervalSeconds)
        : 0,
      maxStreamDurationSeconds: isSet(object.maxStreamDurationSeconds)
        ? globalThis.Number(object.maxStreamDurationSeconds)
        : 0,
      dataField: isSet(object.dataField) ? globalThis.String(object.dataField) : "",
      idField: isSet(object.idField) ? globalThis.String(object.idField) : "",
      jsonEncode: isSet(object.jsonEncode) ? globalThis.Boolean(object.jsonEncode) : false,
      filterParams: globalThis.Array.isArray(object?.filterParams)
        ? object.filterParams.map((e: any) => globalThis.String(e))
        : [],
      routingKey: isSet(object.routingKey) ? globalThis.String(object.routingKey) : "",
      summary: isSet(object.summary) ? globalThis.String(object.summary) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      tags: globalThis.Array.isArray(object?.tags)
        ? object.tags.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ServerSentEventsRule): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.eventType !== "") {
      obj.eventType = message.eventType;
    }
    if (message.authRequired !== false) {
      obj.authRequired = message.authRequired;
    }
    if (message.requiredScopes?.length) {
      obj.requiredScopes = message.requiredScopes;
    }
    if (message.keepaliveIntervalSeconds !== 0) {
      obj.keepaliveIntervalSeconds = Math.round(message.keepaliveIntervalSeconds);
    }
    if (message.maxStreamDurationSeconds !== 0) {
      obj.maxStreamDurationSeconds = Math.round(message.maxStreamDurationSeconds);
    }
    if (message.dataField !== "") {
      obj.dataField = message.dataField;
    }
    if (message.idField !== "") {
      obj.idField = message.idField;
    }
    if (message.jsonEncode !== false) {
      obj.jsonEncode = message.jsonEncode;
    }
    if (message.filterParams?.length) {
      obj.filterParams = message.filterParams;
    }
    if (message.routingKey !== "") {
      obj.routingKey = message.routingKey;
    }
    if (message.summary !== "") {
      obj.summary = message.summary;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServerSentEventsRule>, I>>(base?: I): ServerSentEventsRule {
    return ServerSentEventsRule.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServerSentEventsRule>, I>>(object: I): ServerSentEventsRule {
    const message = createBaseServerSentEventsRule();
    message.path = object.path ?? "";
    message.eventType = object.eventType ?? "";
    message.authRequired = object.authRequired ?? false;
    message.requiredScopes = object.requiredScopes?.map((e) => e) || [];
    message.keepaliveIntervalSeconds = object.keepaliveIntervalSeconds ?? 0;
    message.maxStreamDurationSeconds = object.maxStreamDurationSeconds ?? 0;
    message.dataField = object.dataField ?? "";
    message.idField = object.idField ?? "";
    message.jsonEncode = object.jsonEncode ?? false;
    message.filterParams = object.filterParams?.map((e) => e) || [];
    message.routingKey = object.routingKey ?? "";
    message.summary = object.summary ?? "";
    message.description = object.description ?? "";
    message.tags = object.tags?.map((e) => e) || [];
    return message;
  },
};

function createBaseLongPollingRule(): LongPollingRule {
  return {
    path: "",
    timeoutSeconds: 0,
    maxEvents: 0,
    authRequired: false,
    requiredScopes: [],
    eventsField: "",
    cursorField: "",
    includeMetadata: false,
    summary: "",
    description: "",
    tags: [],
  };
}

export const LongPollingRule = {
  encode(message: LongPollingRule, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.timeoutSeconds !== 0) {
      writer.uint32(16).int32(message.timeoutSeconds);
    }
    if (message.maxEvents !== 0) {
      writer.uint32(24).int32(message.maxEvents);
    }
    if (message.authRequired !== false) {
      writer.uint32(80).bool(message.authRequired);
    }
    for (const v of message.requiredScopes) {
      writer.uint32(90).string(v!);
    }
    if (message.eventsField !== "") {
      writer.uint32(122).string(message.eventsField);
    }
    if (message.cursorField !== "") {
      writer.uint32(130).string(message.cursorField);
    }
    if (message.includeMetadata !== false) {
      writer.uint32(136).bool(message.includeMetadata);
    }
    if (message.summary !== "") {
      writer.uint32(162).string(message.summary);
    }
    if (message.description !== "") {
      writer.uint32(170).string(message.description);
    }
    for (const v of message.tags) {
      writer.uint32(178).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LongPollingRule {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLongPollingRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.timeoutSeconds = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.maxEvents = reader.int32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.authRequired = reader.bool();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.requiredScopes.push(reader.string());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.eventsField = reader.string();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.cursorField = reader.string();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.includeMetadata = reader.bool();
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.summary = reader.string();
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.description = reader.string();
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.tags.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LongPollingRule {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      timeoutSeconds: isSet(object.timeoutSeconds) ? globalThis.Number(object.timeoutSeconds) : 0,
      maxEvents: isSet(object.maxEvents) ? globalThis.Number(object.maxEvents) : 0,
      authRequired: isSet(object.authRequired) ? globalThis.Boolean(object.authRequired) : false,
      requiredScopes: globalThis.Array.isArray(object?.requiredScopes)
        ? object.requiredScopes.map((e: any) => globalThis.String(e))
        : [],
      eventsField: isSet(object.eventsField) ? globalThis.String(object.eventsField) : "",
      cursorField: isSet(object.cursorField) ? globalThis.String(object.cursorField) : "",
      includeMetadata: isSet(object.includeMetadata) ? globalThis.Boolean(object.includeMetadata) : false,
      summary: isSet(object.summary) ? globalThis.String(object.summary) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: LongPollingRule): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.timeoutSeconds !== 0) {
      obj.timeoutSeconds = Math.round(message.timeoutSeconds);
    }
    if (message.maxEvents !== 0) {
      obj.maxEvents = Math.round(message.maxEvents);
    }
    if (message.authRequired !== false) {
      obj.authRequired = message.authRequired;
    }
    if (message.requiredScopes?.length) {
      obj.requiredScopes = message.requiredScopes;
    }
    if (message.eventsField !== "") {
      obj.eventsField = message.eventsField;
    }
    if (message.cursorField !== "") {
      obj.cursorField = message.cursorField;
    }
    if (message.includeMetadata !== false) {
      obj.includeMetadata = message.includeMetadata;
    }
    if (message.summary !== "") {
      obj.summary = message.summary;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LongPollingRule>, I>>(base?: I): LongPollingRule {
    return LongPollingRule.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LongPollingRule>, I>>(object: I): LongPollingRule {
    const message = createBaseLongPollingRule();
    message.path = object.path ?? "";
    message.timeoutSeconds = object.timeoutSeconds ?? 0;
    message.maxEvents = object.maxEvents ?? 0;
    message.authRequired = object.authRequired ?? false;
    message.requiredScopes = object.requiredScopes?.map((e) => e) || [];
    message.eventsField = object.eventsField ?? "";
    message.cursorField = object.cursorField ?? "";
    message.includeMetadata = object.includeMetadata ?? false;
    message.summary = object.summary ?? "";
    message.description = object.description ?? "";
    message.tags = object.tags?.map((e) => e) || [];
    return message;
  },
};

function createBaseServiceRule(): ServiceRule {
  return {
    basePath: "",
    version: "",
    defaultAuthRequired: false,
    defaultScopes: [],
    authProvider: "",
    defaultRateLimit: undefined,
    defaultCors: undefined,
    title: "",
    description: "",
    tags: [],
    contactEmail: "",
    license: "",
  };
}

export const ServiceRule = {
  encode(message: ServiceRule, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.basePath !== "") {
      writer.uint32(10).string(message.basePath);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    if (message.defaultAuthRequired !== false) {
      writer.uint32(80).bool(message.defaultAuthRequired);
    }
    for (const v of message.defaultScopes) {
      writer.uint32(90).string(v!);
    }
    if (message.authProvider !== "") {
      writer.uint32(98).string(message.authProvider);
    }
    if (message.defaultRateLimit !== undefined) {
      RateLimitRule.encode(message.defaultRateLimit, writer.uint32(122).fork()).ldelim();
    }
    if (message.defaultCors !== undefined) {
      CorsRule.encode(message.defaultCors, writer.uint32(130).fork()).ldelim();
    }
    if (message.title !== "") {
      writer.uint32(162).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(170).string(message.description);
    }
    for (const v of message.tags) {
      writer.uint32(178).string(v!);
    }
    if (message.contactEmail !== "") {
      writer.uint32(186).string(message.contactEmail);
    }
    if (message.license !== "") {
      writer.uint32(194).string(message.license);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ServiceRule {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.basePath = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.version = reader.string();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.defaultAuthRequired = reader.bool();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.defaultScopes.push(reader.string());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.authProvider = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.defaultRateLimit = RateLimitRule.decode(reader, reader.uint32());
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.defaultCors = CorsRule.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.title = reader.string();
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.description = reader.string();
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.contactEmail = reader.string();
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.license = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceRule {
    return {
      basePath: isSet(object.basePath) ? globalThis.String(object.basePath) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      defaultAuthRequired: isSet(object.defaultAuthRequired) ? globalThis.Boolean(object.defaultAuthRequired) : false,
      defaultScopes: globalThis.Array.isArray(object?.defaultScopes)
        ? object.defaultScopes.map((e: any) => globalThis.String(e))
        : [],
      authProvider: isSet(object.authProvider) ? globalThis.String(object.authProvider) : "",
      defaultRateLimit: isSet(object.defaultRateLimit) ? RateLimitRule.fromJSON(object.defaultRateLimit) : undefined,
      defaultCors: isSet(object.defaultCors) ? CorsRule.fromJSON(object.defaultCors) : undefined,
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      contactEmail: isSet(object.contactEmail) ? globalThis.String(object.contactEmail) : "",
      license: isSet(object.license) ? globalThis.String(object.license) : "",
    };
  },

  toJSON(message: ServiceRule): unknown {
    const obj: any = {};
    if (message.basePath !== "") {
      obj.basePath = message.basePath;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.defaultAuthRequired !== false) {
      obj.defaultAuthRequired = message.defaultAuthRequired;
    }
    if (message.defaultScopes?.length) {
      obj.defaultScopes = message.defaultScopes;
    }
    if (message.authProvider !== "") {
      obj.authProvider = message.authProvider;
    }
    if (message.defaultRateLimit !== undefined) {
      obj.defaultRateLimit = RateLimitRule.toJSON(message.defaultRateLimit);
    }
    if (message.defaultCors !== undefined) {
      obj.defaultCors = CorsRule.toJSON(message.defaultCors);
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.contactEmail !== "") {
      obj.contactEmail = message.contactEmail;
    }
    if (message.license !== "") {
      obj.license = message.license;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServiceRule>, I>>(base?: I): ServiceRule {
    return ServiceRule.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServiceRule>, I>>(object: I): ServiceRule {
    const message = createBaseServiceRule();
    message.basePath = object.basePath ?? "";
    message.version = object.version ?? "";
    message.defaultAuthRequired = object.defaultAuthRequired ?? false;
    message.defaultScopes = object.defaultScopes?.map((e) => e) || [];
    message.authProvider = object.authProvider ?? "";
    message.defaultRateLimit = (object.defaultRateLimit !== undefined && object.defaultRateLimit !== null)
      ? RateLimitRule.fromPartial(object.defaultRateLimit)
      : undefined;
    message.defaultCors = (object.defaultCors !== undefined && object.defaultCors !== null)
      ? CorsRule.fromPartial(object.defaultCors)
      : undefined;
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.tags = object.tags?.map((e) => e) || [];
    message.contactEmail = object.contactEmail ?? "";
    message.license = object.license ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
