// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v3.21.12
// source: cdc_service.proto

/* eslint-disable */
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  ClientReadableStream,
  type ClientUnaryCall,
  handleServerStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import Long from "long";
import _m0 from "protobufjs/minimal";
import { UniversalEvent } from "./cdc_events";
import { Struct } from "./google/protobuf/struct";
import { Timestamp } from "./google/protobuf/timestamp";

/** Publish a single event */
export interface PublishEventRequest {
  event?:
    | UniversalEvent
    | undefined;
  /** Publishing options */
  ensureDelivery: boolean;
  retryAttempts: number;
  deliveryDeadline?:
    | Date
    | undefined;
  /** Routing options */
  targetSubscribers: string[];
  /** "broadcast", "round_robin", "sticky" */
  routingStrategy: string;
}

export interface PublishEventResponse {
  success: boolean;
  message: string;
  eventId: string;
  sequenceNumber: string;
  publishedAt?: Date | undefined;
}

/** Publish multiple events in batch */
export interface PublishEventsRequest {
  events: UniversalEvent[];
  /** Batch options */
  atomic: boolean;
  ensureDelivery: boolean;
  retryAttempts: number;
}

export interface PublishEventResult {
  eventId: string;
  success: boolean;
  errorMessage: string;
  sequenceNumber: string;
}

export interface PublishEventsResponse {
  success: boolean;
  message: string;
  results: PublishEventResult[];
  successfulCount: number;
  failedCount: number;
}

/** Subscribe to event stream */
export interface SubscribeRequest {
  subscriberId: string;
  subscriberName: string;
  /** Subscription filters */
  filter?:
    | EventFilter
    | undefined;
  /** Subscription options */
  options?: SubscriptionOptions | undefined;
}

export interface EventFilter {
  /** Event type filters */
  eventTypes: string[];
  sourceServices: string[];
  userIds: string[];
  sessionIds: string[];
  tags: string[];
  /** Time range filters */
  startTime?: Date | undefined;
  endTime?:
    | Date
    | undefined;
  /** Advanced filters */
  jqFilter: string;
  metadataFilter?: { [key: string]: any } | undefined;
}

export interface SubscriptionOptions {
  /** Delivery options */
  deliveryMode: string;
  batchSize: number;
  batchTimeoutMs: number;
  /** Replay options */
  replayFromBeginning: boolean;
  replayFromSequence: string;
  replayFromTime?:
    | Date
    | undefined;
  /** Error handling */
  maxRetryAttempts: number;
  retryBackoffMs: number;
  sendToDlqOnFailure: boolean;
}

/** Streaming response for subscriptions */
export interface EventStreamResponse {
  eventBatch?: EventBatch | undefined;
  status?: SubscriptionStatus | undefined;
  error?: SubscriptionError | undefined;
  heartbeat?: Heartbeat | undefined;
}

export interface EventBatch {
  events: UniversalEvent[];
  batchSequence: string;
  batchTime?: Date | undefined;
  checkpointToken: string;
}

export interface SubscriptionStatus {
  /** "active", "paused", "stopped" */
  status: string;
  lastProcessedSequence: string;
  eventsProcessed: number;
  eventsFailed: number;
}

export interface SubscriptionError {
  errorCode: string;
  errorMessage: string;
  isRecoverable: boolean;
  retryCount: number;
}

export interface Heartbeat {
  timestamp?: Date | undefined;
  currentSequence: string;
}

export interface AcknowledgeEventsRequest {
  subscriberId: string;
  eventIds: string[];
  checkpointToken: string;
}

export interface AcknowledgeEventsResponse {
  success: boolean;
  message: string;
  acknowledgedCount: number;
}

export interface ReplayEventsRequest {
  subscriberId: string;
  timeRange?: TimeRange | undefined;
  sequenceRange?: SequenceRange | undefined;
  checkpointToken?:
    | string
    | undefined;
  /** Replay options */
  filter?: EventFilter | undefined;
  batchSize: number;
  includeFailedEvents: boolean;
}

export interface TimeRange {
  startTime?: Date | undefined;
  endTime?: Date | undefined;
}

export interface SequenceRange {
  startSequence: string;
  endSequence: string;
}

export interface ListDeadLetterEventsRequest {
  subscriberId: string;
  since?: Date | undefined;
  pageSize: number;
  pageToken: string;
}

export interface ListDeadLetterEventsResponse {
  events: DeadLetterEvent[];
  nextPageToken: string;
  totalCount: number;
}

export interface DeadLetterEvent {
  originalEvent?: UniversalEvent | undefined;
  failureReason: string;
  retryCount: number;
  failedAt?: Date | undefined;
  lastRetryAt?: Date | undefined;
}

export interface ReprocessDeadLetterEventsRequest {
  subscriberId: string;
  eventIds: string[];
  resetRetryCount: boolean;
}

export interface ReprocessDeadLetterEventsResponse {
  success: boolean;
  message: string;
  reprocessedCount: number;
}

export interface GetEventStatsRequest {
  startTime?: Date | undefined;
  endTime?: Date | undefined;
  eventTypes: string[];
  sourceServices: string[];
  /** "1m", "5m", "1h", "1d" */
  aggregationInterval: string;
}

export interface GetEventStatsResponse {
  stats: EventStats[];
}

export interface EventStats {
  timestamp?: Date | undefined;
  eventType: string;
  sourceService: string;
  eventCount: string;
  eventsPerSecond: number;
  avgProcessingTimeMs: number;
  failedCount: string;
}

export interface ListSubscriptionsRequest {
  subscriberId: string;
  includeInactive: boolean;
}

export interface ListSubscriptionsResponse {
  subscriptions: SubscriptionInfo[];
}

export interface SubscriptionInfo {
  subscriberId: string;
  subscriberName: string;
  filter?: EventFilter | undefined;
  options?: SubscriptionOptions | undefined;
  status: string;
  createdAt?: Date | undefined;
  lastActiveAt?: Date | undefined;
  eventsProcessed: string;
  eventsFailed: string;
}

export interface UpdateSubscriptionRequest {
  subscriberId: string;
  filter?: EventFilter | undefined;
  options?: SubscriptionOptions | undefined;
}

export interface UpdateSubscriptionResponse {
  success: boolean;
  message: string;
}

export interface DeleteSubscriptionRequest {
  subscriberId: string;
}

export interface DeleteSubscriptionResponse {
  success: boolean;
  message: string;
}

export interface GetServiceStatusRequest {
}

export interface GetServiceStatusResponse {
  healthy: boolean;
  status: string;
  timestamp?: Date | undefined;
  metrics?: ServiceMetrics | undefined;
}

export interface ServiceMetrics {
  totalEventsPublished: string;
  totalEventsDelivered: string;
  activeSubscriptions: string;
  eventsInDlq: string;
  avgPublishLatencyMs: number;
  avgDeliveryLatencyMs: number;
}

function createBasePublishEventRequest(): PublishEventRequest {
  return {
    event: undefined,
    ensureDelivery: false,
    retryAttempts: 0,
    deliveryDeadline: undefined,
    targetSubscribers: [],
    routingStrategy: "",
  };
}

export const PublishEventRequest = {
  encode(message: PublishEventRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.event !== undefined) {
      UniversalEvent.encode(message.event, writer.uint32(10).fork()).ldelim();
    }
    if (message.ensureDelivery !== false) {
      writer.uint32(16).bool(message.ensureDelivery);
    }
    if (message.retryAttempts !== 0) {
      writer.uint32(24).int32(message.retryAttempts);
    }
    if (message.deliveryDeadline !== undefined) {
      Timestamp.encode(toTimestamp(message.deliveryDeadline), writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.targetSubscribers) {
      writer.uint32(42).string(v!);
    }
    if (message.routingStrategy !== "") {
      writer.uint32(50).string(message.routingStrategy);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PublishEventRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublishEventRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.event = UniversalEvent.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.ensureDelivery = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.retryAttempts = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.deliveryDeadline = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.targetSubscribers.push(reader.string());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.routingStrategy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PublishEventRequest {
    return {
      event: isSet(object.event) ? UniversalEvent.fromJSON(object.event) : undefined,
      ensureDelivery: isSet(object.ensureDelivery) ? globalThis.Boolean(object.ensureDelivery) : false,
      retryAttempts: isSet(object.retryAttempts) ? globalThis.Number(object.retryAttempts) : 0,
      deliveryDeadline: isSet(object.deliveryDeadline) ? fromJsonTimestamp(object.deliveryDeadline) : undefined,
      targetSubscribers: globalThis.Array.isArray(object?.targetSubscribers)
        ? object.targetSubscribers.map((e: any) => globalThis.String(e))
        : [],
      routingStrategy: isSet(object.routingStrategy) ? globalThis.String(object.routingStrategy) : "",
    };
  },

  toJSON(message: PublishEventRequest): unknown {
    const obj: any = {};
    if (message.event !== undefined) {
      obj.event = UniversalEvent.toJSON(message.event);
    }
    if (message.ensureDelivery !== false) {
      obj.ensureDelivery = message.ensureDelivery;
    }
    if (message.retryAttempts !== 0) {
      obj.retryAttempts = Math.round(message.retryAttempts);
    }
    if (message.deliveryDeadline !== undefined) {
      obj.deliveryDeadline = message.deliveryDeadline.toISOString();
    }
    if (message.targetSubscribers?.length) {
      obj.targetSubscribers = message.targetSubscribers;
    }
    if (message.routingStrategy !== "") {
      obj.routingStrategy = message.routingStrategy;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PublishEventRequest>, I>>(base?: I): PublishEventRequest {
    return PublishEventRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PublishEventRequest>, I>>(object: I): PublishEventRequest {
    const message = createBasePublishEventRequest();
    message.event = (object.event !== undefined && object.event !== null)
      ? UniversalEvent.fromPartial(object.event)
      : undefined;
    message.ensureDelivery = object.ensureDelivery ?? false;
    message.retryAttempts = object.retryAttempts ?? 0;
    message.deliveryDeadline = object.deliveryDeadline ?? undefined;
    message.targetSubscribers = object.targetSubscribers?.map((e) => e) || [];
    message.routingStrategy = object.routingStrategy ?? "";
    return message;
  },
};

function createBasePublishEventResponse(): PublishEventResponse {
  return { success: false, message: "", eventId: "", sequenceNumber: "0", publishedAt: undefined };
}

export const PublishEventResponse = {
  encode(message: PublishEventResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.eventId !== "") {
      writer.uint32(26).string(message.eventId);
    }
    if (message.sequenceNumber !== "0") {
      writer.uint32(32).int64(message.sequenceNumber);
    }
    if (message.publishedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.publishedAt), writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PublishEventResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublishEventResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.eventId = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.sequenceNumber = longToString(reader.int64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.publishedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PublishEventResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      eventId: isSet(object.eventId) ? globalThis.String(object.eventId) : "",
      sequenceNumber: isSet(object.sequenceNumber) ? globalThis.String(object.sequenceNumber) : "0",
      publishedAt: isSet(object.publishedAt) ? fromJsonTimestamp(object.publishedAt) : undefined,
    };
  },

  toJSON(message: PublishEventResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.eventId !== "") {
      obj.eventId = message.eventId;
    }
    if (message.sequenceNumber !== "0") {
      obj.sequenceNumber = message.sequenceNumber;
    }
    if (message.publishedAt !== undefined) {
      obj.publishedAt = message.publishedAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PublishEventResponse>, I>>(base?: I): PublishEventResponse {
    return PublishEventResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PublishEventResponse>, I>>(object: I): PublishEventResponse {
    const message = createBasePublishEventResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.eventId = object.eventId ?? "";
    message.sequenceNumber = object.sequenceNumber ?? "0";
    message.publishedAt = object.publishedAt ?? undefined;
    return message;
  },
};

function createBasePublishEventsRequest(): PublishEventsRequest {
  return { events: [], atomic: false, ensureDelivery: false, retryAttempts: 0 };
}

export const PublishEventsRequest = {
  encode(message: PublishEventsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.events) {
      UniversalEvent.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.atomic !== false) {
      writer.uint32(16).bool(message.atomic);
    }
    if (message.ensureDelivery !== false) {
      writer.uint32(24).bool(message.ensureDelivery);
    }
    if (message.retryAttempts !== 0) {
      writer.uint32(32).int32(message.retryAttempts);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PublishEventsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublishEventsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.events.push(UniversalEvent.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.atomic = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.ensureDelivery = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.retryAttempts = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PublishEventsRequest {
    return {
      events: globalThis.Array.isArray(object?.events) ? object.events.map((e: any) => UniversalEvent.fromJSON(e)) : [],
      atomic: isSet(object.atomic) ? globalThis.Boolean(object.atomic) : false,
      ensureDelivery: isSet(object.ensureDelivery) ? globalThis.Boolean(object.ensureDelivery) : false,
      retryAttempts: isSet(object.retryAttempts) ? globalThis.Number(object.retryAttempts) : 0,
    };
  },

  toJSON(message: PublishEventsRequest): unknown {
    const obj: any = {};
    if (message.events?.length) {
      obj.events = message.events.map((e) => UniversalEvent.toJSON(e));
    }
    if (message.atomic !== false) {
      obj.atomic = message.atomic;
    }
    if (message.ensureDelivery !== false) {
      obj.ensureDelivery = message.ensureDelivery;
    }
    if (message.retryAttempts !== 0) {
      obj.retryAttempts = Math.round(message.retryAttempts);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PublishEventsRequest>, I>>(base?: I): PublishEventsRequest {
    return PublishEventsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PublishEventsRequest>, I>>(object: I): PublishEventsRequest {
    const message = createBasePublishEventsRequest();
    message.events = object.events?.map((e) => UniversalEvent.fromPartial(e)) || [];
    message.atomic = object.atomic ?? false;
    message.ensureDelivery = object.ensureDelivery ?? false;
    message.retryAttempts = object.retryAttempts ?? 0;
    return message;
  },
};

function createBasePublishEventResult(): PublishEventResult {
  return { eventId: "", success: false, errorMessage: "", sequenceNumber: "0" };
}

export const PublishEventResult = {
  encode(message: PublishEventResult, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== "") {
      writer.uint32(10).string(message.eventId);
    }
    if (message.success !== false) {
      writer.uint32(16).bool(message.success);
    }
    if (message.errorMessage !== "") {
      writer.uint32(26).string(message.errorMessage);
    }
    if (message.sequenceNumber !== "0") {
      writer.uint32(32).int64(message.sequenceNumber);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PublishEventResult {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublishEventResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.eventId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.sequenceNumber = longToString(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PublishEventResult {
    return {
      eventId: isSet(object.eventId) ? globalThis.String(object.eventId) : "",
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
      sequenceNumber: isSet(object.sequenceNumber) ? globalThis.String(object.sequenceNumber) : "0",
    };
  },

  toJSON(message: PublishEventResult): unknown {
    const obj: any = {};
    if (message.eventId !== "") {
      obj.eventId = message.eventId;
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    if (message.sequenceNumber !== "0") {
      obj.sequenceNumber = message.sequenceNumber;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PublishEventResult>, I>>(base?: I): PublishEventResult {
    return PublishEventResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PublishEventResult>, I>>(object: I): PublishEventResult {
    const message = createBasePublishEventResult();
    message.eventId = object.eventId ?? "";
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? "";
    message.sequenceNumber = object.sequenceNumber ?? "0";
    return message;
  },
};

function createBasePublishEventsResponse(): PublishEventsResponse {
  return { success: false, message: "", results: [], successfulCount: 0, failedCount: 0 };
}

export const PublishEventsResponse = {
  encode(message: PublishEventsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.results) {
      PublishEventResult.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.successfulCount !== 0) {
      writer.uint32(32).int32(message.successfulCount);
    }
    if (message.failedCount !== 0) {
      writer.uint32(40).int32(message.failedCount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PublishEventsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublishEventsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.results.push(PublishEventResult.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.successfulCount = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.failedCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PublishEventsResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      results: globalThis.Array.isArray(object?.results)
        ? object.results.map((e: any) => PublishEventResult.fromJSON(e))
        : [],
      successfulCount: isSet(object.successfulCount) ? globalThis.Number(object.successfulCount) : 0,
      failedCount: isSet(object.failedCount) ? globalThis.Number(object.failedCount) : 0,
    };
  },

  toJSON(message: PublishEventsResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.results?.length) {
      obj.results = message.results.map((e) => PublishEventResult.toJSON(e));
    }
    if (message.successfulCount !== 0) {
      obj.successfulCount = Math.round(message.successfulCount);
    }
    if (message.failedCount !== 0) {
      obj.failedCount = Math.round(message.failedCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PublishEventsResponse>, I>>(base?: I): PublishEventsResponse {
    return PublishEventsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PublishEventsResponse>, I>>(object: I): PublishEventsResponse {
    const message = createBasePublishEventsResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.results = object.results?.map((e) => PublishEventResult.fromPartial(e)) || [];
    message.successfulCount = object.successfulCount ?? 0;
    message.failedCount = object.failedCount ?? 0;
    return message;
  },
};

function createBaseSubscribeRequest(): SubscribeRequest {
  return { subscriberId: "", subscriberName: "", filter: undefined, options: undefined };
}

export const SubscribeRequest = {
  encode(message: SubscribeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.subscriberId !== "") {
      writer.uint32(10).string(message.subscriberId);
    }
    if (message.subscriberName !== "") {
      writer.uint32(18).string(message.subscriberName);
    }
    if (message.filter !== undefined) {
      EventFilter.encode(message.filter, writer.uint32(26).fork()).ldelim();
    }
    if (message.options !== undefined) {
      SubscriptionOptions.encode(message.options, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubscribeRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscribeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.subscriberId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.subscriberName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.filter = EventFilter.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.options = SubscriptionOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscribeRequest {
    return {
      subscriberId: isSet(object.subscriberId) ? globalThis.String(object.subscriberId) : "",
      subscriberName: isSet(object.subscriberName) ? globalThis.String(object.subscriberName) : "",
      filter: isSet(object.filter) ? EventFilter.fromJSON(object.filter) : undefined,
      options: isSet(object.options) ? SubscriptionOptions.fromJSON(object.options) : undefined,
    };
  },

  toJSON(message: SubscribeRequest): unknown {
    const obj: any = {};
    if (message.subscriberId !== "") {
      obj.subscriberId = message.subscriberId;
    }
    if (message.subscriberName !== "") {
      obj.subscriberName = message.subscriberName;
    }
    if (message.filter !== undefined) {
      obj.filter = EventFilter.toJSON(message.filter);
    }
    if (message.options !== undefined) {
      obj.options = SubscriptionOptions.toJSON(message.options);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubscribeRequest>, I>>(base?: I): SubscribeRequest {
    return SubscribeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubscribeRequest>, I>>(object: I): SubscribeRequest {
    const message = createBaseSubscribeRequest();
    message.subscriberId = object.subscriberId ?? "";
    message.subscriberName = object.subscriberName ?? "";
    message.filter = (object.filter !== undefined && object.filter !== null)
      ? EventFilter.fromPartial(object.filter)
      : undefined;
    message.options = (object.options !== undefined && object.options !== null)
      ? SubscriptionOptions.fromPartial(object.options)
      : undefined;
    return message;
  },
};

function createBaseEventFilter(): EventFilter {
  return {
    eventTypes: [],
    sourceServices: [],
    userIds: [],
    sessionIds: [],
    tags: [],
    startTime: undefined,
    endTime: undefined,
    jqFilter: "",
    metadataFilter: undefined,
  };
}

export const EventFilter = {
  encode(message: EventFilter, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.eventTypes) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.sourceServices) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.userIds) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.sessionIds) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.tags) {
      writer.uint32(42).string(v!);
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(50).fork()).ldelim();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(58).fork()).ldelim();
    }
    if (message.jqFilter !== "") {
      writer.uint32(66).string(message.jqFilter);
    }
    if (message.metadataFilter !== undefined) {
      Struct.encode(Struct.wrap(message.metadataFilter), writer.uint32(74).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EventFilter {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.eventTypes.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sourceServices.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.userIds.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.sessionIds.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.jqFilter = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.metadataFilter = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventFilter {
    return {
      eventTypes: globalThis.Array.isArray(object?.eventTypes)
        ? object.eventTypes.map((e: any) => globalThis.String(e))
        : [],
      sourceServices: globalThis.Array.isArray(object?.sourceServices)
        ? object.sourceServices.map((e: any) => globalThis.String(e))
        : [],
      userIds: globalThis.Array.isArray(object?.userIds) ? object.userIds.map((e: any) => globalThis.String(e)) : [],
      sessionIds: globalThis.Array.isArray(object?.sessionIds)
        ? object.sessionIds.map((e: any) => globalThis.String(e))
        : [],
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      jqFilter: isSet(object.jqFilter) ? globalThis.String(object.jqFilter) : "",
      metadataFilter: isObject(object.metadataFilter) ? object.metadataFilter : undefined,
    };
  },

  toJSON(message: EventFilter): unknown {
    const obj: any = {};
    if (message.eventTypes?.length) {
      obj.eventTypes = message.eventTypes;
    }
    if (message.sourceServices?.length) {
      obj.sourceServices = message.sourceServices;
    }
    if (message.userIds?.length) {
      obj.userIds = message.userIds;
    }
    if (message.sessionIds?.length) {
      obj.sessionIds = message.sessionIds;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    if (message.jqFilter !== "") {
      obj.jqFilter = message.jqFilter;
    }
    if (message.metadataFilter !== undefined) {
      obj.metadataFilter = message.metadataFilter;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventFilter>, I>>(base?: I): EventFilter {
    return EventFilter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventFilter>, I>>(object: I): EventFilter {
    const message = createBaseEventFilter();
    message.eventTypes = object.eventTypes?.map((e) => e) || [];
    message.sourceServices = object.sourceServices?.map((e) => e) || [];
    message.userIds = object.userIds?.map((e) => e) || [];
    message.sessionIds = object.sessionIds?.map((e) => e) || [];
    message.tags = object.tags?.map((e) => e) || [];
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.jqFilter = object.jqFilter ?? "";
    message.metadataFilter = object.metadataFilter ?? undefined;
    return message;
  },
};

function createBaseSubscriptionOptions(): SubscriptionOptions {
  return {
    deliveryMode: "",
    batchSize: 0,
    batchTimeoutMs: 0,
    replayFromBeginning: false,
    replayFromSequence: "0",
    replayFromTime: undefined,
    maxRetryAttempts: 0,
    retryBackoffMs: 0,
    sendToDlqOnFailure: false,
  };
}

export const SubscriptionOptions = {
  encode(message: SubscriptionOptions, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.deliveryMode !== "") {
      writer.uint32(10).string(message.deliveryMode);
    }
    if (message.batchSize !== 0) {
      writer.uint32(16).int32(message.batchSize);
    }
    if (message.batchTimeoutMs !== 0) {
      writer.uint32(24).int32(message.batchTimeoutMs);
    }
    if (message.replayFromBeginning !== false) {
      writer.uint32(32).bool(message.replayFromBeginning);
    }
    if (message.replayFromSequence !== "0") {
      writer.uint32(40).int64(message.replayFromSequence);
    }
    if (message.replayFromTime !== undefined) {
      Timestamp.encode(toTimestamp(message.replayFromTime), writer.uint32(50).fork()).ldelim();
    }
    if (message.maxRetryAttempts !== 0) {
      writer.uint32(56).int32(message.maxRetryAttempts);
    }
    if (message.retryBackoffMs !== 0) {
      writer.uint32(64).int32(message.retryBackoffMs);
    }
    if (message.sendToDlqOnFailure !== false) {
      writer.uint32(72).bool(message.sendToDlqOnFailure);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubscriptionOptions {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscriptionOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.deliveryMode = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.batchSize = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.batchTimeoutMs = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.replayFromBeginning = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.replayFromSequence = longToString(reader.int64() as Long);
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.replayFromTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.maxRetryAttempts = reader.int32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.retryBackoffMs = reader.int32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.sendToDlqOnFailure = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscriptionOptions {
    return {
      deliveryMode: isSet(object.deliveryMode) ? globalThis.String(object.deliveryMode) : "",
      batchSize: isSet(object.batchSize) ? globalThis.Number(object.batchSize) : 0,
      batchTimeoutMs: isSet(object.batchTimeoutMs) ? globalThis.Number(object.batchTimeoutMs) : 0,
      replayFromBeginning: isSet(object.replayFromBeginning) ? globalThis.Boolean(object.replayFromBeginning) : false,
      replayFromSequence: isSet(object.replayFromSequence) ? globalThis.String(object.replayFromSequence) : "0",
      replayFromTime: isSet(object.replayFromTime) ? fromJsonTimestamp(object.replayFromTime) : undefined,
      maxRetryAttempts: isSet(object.maxRetryAttempts) ? globalThis.Number(object.maxRetryAttempts) : 0,
      retryBackoffMs: isSet(object.retryBackoffMs) ? globalThis.Number(object.retryBackoffMs) : 0,
      sendToDlqOnFailure: isSet(object.sendToDlqOnFailure) ? globalThis.Boolean(object.sendToDlqOnFailure) : false,
    };
  },

  toJSON(message: SubscriptionOptions): unknown {
    const obj: any = {};
    if (message.deliveryMode !== "") {
      obj.deliveryMode = message.deliveryMode;
    }
    if (message.batchSize !== 0) {
      obj.batchSize = Math.round(message.batchSize);
    }
    if (message.batchTimeoutMs !== 0) {
      obj.batchTimeoutMs = Math.round(message.batchTimeoutMs);
    }
    if (message.replayFromBeginning !== false) {
      obj.replayFromBeginning = message.replayFromBeginning;
    }
    if (message.replayFromSequence !== "0") {
      obj.replayFromSequence = message.replayFromSequence;
    }
    if (message.replayFromTime !== undefined) {
      obj.replayFromTime = message.replayFromTime.toISOString();
    }
    if (message.maxRetryAttempts !== 0) {
      obj.maxRetryAttempts = Math.round(message.maxRetryAttempts);
    }
    if (message.retryBackoffMs !== 0) {
      obj.retryBackoffMs = Math.round(message.retryBackoffMs);
    }
    if (message.sendToDlqOnFailure !== false) {
      obj.sendToDlqOnFailure = message.sendToDlqOnFailure;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubscriptionOptions>, I>>(base?: I): SubscriptionOptions {
    return SubscriptionOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubscriptionOptions>, I>>(object: I): SubscriptionOptions {
    const message = createBaseSubscriptionOptions();
    message.deliveryMode = object.deliveryMode ?? "";
    message.batchSize = object.batchSize ?? 0;
    message.batchTimeoutMs = object.batchTimeoutMs ?? 0;
    message.replayFromBeginning = object.replayFromBeginning ?? false;
    message.replayFromSequence = object.replayFromSequence ?? "0";
    message.replayFromTime = object.replayFromTime ?? undefined;
    message.maxRetryAttempts = object.maxRetryAttempts ?? 0;
    message.retryBackoffMs = object.retryBackoffMs ?? 0;
    message.sendToDlqOnFailure = object.sendToDlqOnFailure ?? false;
    return message;
  },
};

function createBaseEventStreamResponse(): EventStreamResponse {
  return { eventBatch: undefined, status: undefined, error: undefined, heartbeat: undefined };
}

export const EventStreamResponse = {
  encode(message: EventStreamResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventBatch !== undefined) {
      EventBatch.encode(message.eventBatch, writer.uint32(10).fork()).ldelim();
    }
    if (message.status !== undefined) {
      SubscriptionStatus.encode(message.status, writer.uint32(18).fork()).ldelim();
    }
    if (message.error !== undefined) {
      SubscriptionError.encode(message.error, writer.uint32(26).fork()).ldelim();
    }
    if (message.heartbeat !== undefined) {
      Heartbeat.encode(message.heartbeat, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EventStreamResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventStreamResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.eventBatch = EventBatch.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.status = SubscriptionStatus.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.error = SubscriptionError.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.heartbeat = Heartbeat.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventStreamResponse {
    return {
      eventBatch: isSet(object.eventBatch) ? EventBatch.fromJSON(object.eventBatch) : undefined,
      status: isSet(object.status) ? SubscriptionStatus.fromJSON(object.status) : undefined,
      error: isSet(object.error) ? SubscriptionError.fromJSON(object.error) : undefined,
      heartbeat: isSet(object.heartbeat) ? Heartbeat.fromJSON(object.heartbeat) : undefined,
    };
  },

  toJSON(message: EventStreamResponse): unknown {
    const obj: any = {};
    if (message.eventBatch !== undefined) {
      obj.eventBatch = EventBatch.toJSON(message.eventBatch);
    }
    if (message.status !== undefined) {
      obj.status = SubscriptionStatus.toJSON(message.status);
    }
    if (message.error !== undefined) {
      obj.error = SubscriptionError.toJSON(message.error);
    }
    if (message.heartbeat !== undefined) {
      obj.heartbeat = Heartbeat.toJSON(message.heartbeat);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventStreamResponse>, I>>(base?: I): EventStreamResponse {
    return EventStreamResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventStreamResponse>, I>>(object: I): EventStreamResponse {
    const message = createBaseEventStreamResponse();
    message.eventBatch = (object.eventBatch !== undefined && object.eventBatch !== null)
      ? EventBatch.fromPartial(object.eventBatch)
      : undefined;
    message.status = (object.status !== undefined && object.status !== null)
      ? SubscriptionStatus.fromPartial(object.status)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null)
      ? SubscriptionError.fromPartial(object.error)
      : undefined;
    message.heartbeat = (object.heartbeat !== undefined && object.heartbeat !== null)
      ? Heartbeat.fromPartial(object.heartbeat)
      : undefined;
    return message;
  },
};

function createBaseEventBatch(): EventBatch {
  return { events: [], batchSequence: "0", batchTime: undefined, checkpointToken: "" };
}

export const EventBatch = {
  encode(message: EventBatch, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.events) {
      UniversalEvent.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.batchSequence !== "0") {
      writer.uint32(16).int64(message.batchSequence);
    }
    if (message.batchTime !== undefined) {
      Timestamp.encode(toTimestamp(message.batchTime), writer.uint32(26).fork()).ldelim();
    }
    if (message.checkpointToken !== "") {
      writer.uint32(34).string(message.checkpointToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EventBatch {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventBatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.events.push(UniversalEvent.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.batchSequence = longToString(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.batchTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.checkpointToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventBatch {
    return {
      events: globalThis.Array.isArray(object?.events) ? object.events.map((e: any) => UniversalEvent.fromJSON(e)) : [],
      batchSequence: isSet(object.batchSequence) ? globalThis.String(object.batchSequence) : "0",
      batchTime: isSet(object.batchTime) ? fromJsonTimestamp(object.batchTime) : undefined,
      checkpointToken: isSet(object.checkpointToken) ? globalThis.String(object.checkpointToken) : "",
    };
  },

  toJSON(message: EventBatch): unknown {
    const obj: any = {};
    if (message.events?.length) {
      obj.events = message.events.map((e) => UniversalEvent.toJSON(e));
    }
    if (message.batchSequence !== "0") {
      obj.batchSequence = message.batchSequence;
    }
    if (message.batchTime !== undefined) {
      obj.batchTime = message.batchTime.toISOString();
    }
    if (message.checkpointToken !== "") {
      obj.checkpointToken = message.checkpointToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventBatch>, I>>(base?: I): EventBatch {
    return EventBatch.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventBatch>, I>>(object: I): EventBatch {
    const message = createBaseEventBatch();
    message.events = object.events?.map((e) => UniversalEvent.fromPartial(e)) || [];
    message.batchSequence = object.batchSequence ?? "0";
    message.batchTime = object.batchTime ?? undefined;
    message.checkpointToken = object.checkpointToken ?? "";
    return message;
  },
};

function createBaseSubscriptionStatus(): SubscriptionStatus {
  return { status: "", lastProcessedSequence: "0", eventsProcessed: 0, eventsFailed: 0 };
}

export const SubscriptionStatus = {
  encode(message: SubscriptionStatus, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.status !== "") {
      writer.uint32(10).string(message.status);
    }
    if (message.lastProcessedSequence !== "0") {
      writer.uint32(16).int64(message.lastProcessedSequence);
    }
    if (message.eventsProcessed !== 0) {
      writer.uint32(24).int32(message.eventsProcessed);
    }
    if (message.eventsFailed !== 0) {
      writer.uint32(32).int32(message.eventsFailed);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubscriptionStatus {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscriptionStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.status = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.lastProcessedSequence = longToString(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.eventsProcessed = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.eventsFailed = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscriptionStatus {
    return {
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      lastProcessedSequence: isSet(object.lastProcessedSequence)
        ? globalThis.String(object.lastProcessedSequence)
        : "0",
      eventsProcessed: isSet(object.eventsProcessed) ? globalThis.Number(object.eventsProcessed) : 0,
      eventsFailed: isSet(object.eventsFailed) ? globalThis.Number(object.eventsFailed) : 0,
    };
  },

  toJSON(message: SubscriptionStatus): unknown {
    const obj: any = {};
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.lastProcessedSequence !== "0") {
      obj.lastProcessedSequence = message.lastProcessedSequence;
    }
    if (message.eventsProcessed !== 0) {
      obj.eventsProcessed = Math.round(message.eventsProcessed);
    }
    if (message.eventsFailed !== 0) {
      obj.eventsFailed = Math.round(message.eventsFailed);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubscriptionStatus>, I>>(base?: I): SubscriptionStatus {
    return SubscriptionStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubscriptionStatus>, I>>(object: I): SubscriptionStatus {
    const message = createBaseSubscriptionStatus();
    message.status = object.status ?? "";
    message.lastProcessedSequence = object.lastProcessedSequence ?? "0";
    message.eventsProcessed = object.eventsProcessed ?? 0;
    message.eventsFailed = object.eventsFailed ?? 0;
    return message;
  },
};

function createBaseSubscriptionError(): SubscriptionError {
  return { errorCode: "", errorMessage: "", isRecoverable: false, retryCount: 0 };
}

export const SubscriptionError = {
  encode(message: SubscriptionError, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.errorCode !== "") {
      writer.uint32(10).string(message.errorCode);
    }
    if (message.errorMessage !== "") {
      writer.uint32(18).string(message.errorMessage);
    }
    if (message.isRecoverable !== false) {
      writer.uint32(24).bool(message.isRecoverable);
    }
    if (message.retryCount !== 0) {
      writer.uint32(32).int32(message.retryCount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubscriptionError {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscriptionError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.errorCode = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.isRecoverable = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.retryCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscriptionError {
    return {
      errorCode: isSet(object.errorCode) ? globalThis.String(object.errorCode) : "",
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
      isRecoverable: isSet(object.isRecoverable) ? globalThis.Boolean(object.isRecoverable) : false,
      retryCount: isSet(object.retryCount) ? globalThis.Number(object.retryCount) : 0,
    };
  },

  toJSON(message: SubscriptionError): unknown {
    const obj: any = {};
    if (message.errorCode !== "") {
      obj.errorCode = message.errorCode;
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    if (message.isRecoverable !== false) {
      obj.isRecoverable = message.isRecoverable;
    }
    if (message.retryCount !== 0) {
      obj.retryCount = Math.round(message.retryCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubscriptionError>, I>>(base?: I): SubscriptionError {
    return SubscriptionError.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubscriptionError>, I>>(object: I): SubscriptionError {
    const message = createBaseSubscriptionError();
    message.errorCode = object.errorCode ?? "";
    message.errorMessage = object.errorMessage ?? "";
    message.isRecoverable = object.isRecoverable ?? false;
    message.retryCount = object.retryCount ?? 0;
    return message;
  },
};

function createBaseHeartbeat(): Heartbeat {
  return { timestamp: undefined, currentSequence: "0" };
}

export const Heartbeat = {
  encode(message: Heartbeat, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(10).fork()).ldelim();
    }
    if (message.currentSequence !== "0") {
      writer.uint32(16).int64(message.currentSequence);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Heartbeat {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeartbeat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.currentSequence = longToString(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Heartbeat {
    return {
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      currentSequence: isSet(object.currentSequence) ? globalThis.String(object.currentSequence) : "0",
    };
  },

  toJSON(message: Heartbeat): unknown {
    const obj: any = {};
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.currentSequence !== "0") {
      obj.currentSequence = message.currentSequence;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Heartbeat>, I>>(base?: I): Heartbeat {
    return Heartbeat.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Heartbeat>, I>>(object: I): Heartbeat {
    const message = createBaseHeartbeat();
    message.timestamp = object.timestamp ?? undefined;
    message.currentSequence = object.currentSequence ?? "0";
    return message;
  },
};

function createBaseAcknowledgeEventsRequest(): AcknowledgeEventsRequest {
  return { subscriberId: "", eventIds: [], checkpointToken: "" };
}

export const AcknowledgeEventsRequest = {
  encode(message: AcknowledgeEventsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.subscriberId !== "") {
      writer.uint32(10).string(message.subscriberId);
    }
    for (const v of message.eventIds) {
      writer.uint32(18).string(v!);
    }
    if (message.checkpointToken !== "") {
      writer.uint32(26).string(message.checkpointToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AcknowledgeEventsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAcknowledgeEventsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.subscriberId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.eventIds.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.checkpointToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AcknowledgeEventsRequest {
    return {
      subscriberId: isSet(object.subscriberId) ? globalThis.String(object.subscriberId) : "",
      eventIds: globalThis.Array.isArray(object?.eventIds) ? object.eventIds.map((e: any) => globalThis.String(e)) : [],
      checkpointToken: isSet(object.checkpointToken) ? globalThis.String(object.checkpointToken) : "",
    };
  },

  toJSON(message: AcknowledgeEventsRequest): unknown {
    const obj: any = {};
    if (message.subscriberId !== "") {
      obj.subscriberId = message.subscriberId;
    }
    if (message.eventIds?.length) {
      obj.eventIds = message.eventIds;
    }
    if (message.checkpointToken !== "") {
      obj.checkpointToken = message.checkpointToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AcknowledgeEventsRequest>, I>>(base?: I): AcknowledgeEventsRequest {
    return AcknowledgeEventsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AcknowledgeEventsRequest>, I>>(object: I): AcknowledgeEventsRequest {
    const message = createBaseAcknowledgeEventsRequest();
    message.subscriberId = object.subscriberId ?? "";
    message.eventIds = object.eventIds?.map((e) => e) || [];
    message.checkpointToken = object.checkpointToken ?? "";
    return message;
  },
};

function createBaseAcknowledgeEventsResponse(): AcknowledgeEventsResponse {
  return { success: false, message: "", acknowledgedCount: 0 };
}

export const AcknowledgeEventsResponse = {
  encode(message: AcknowledgeEventsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.acknowledgedCount !== 0) {
      writer.uint32(24).int32(message.acknowledgedCount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AcknowledgeEventsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAcknowledgeEventsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.acknowledgedCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AcknowledgeEventsResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      acknowledgedCount: isSet(object.acknowledgedCount) ? globalThis.Number(object.acknowledgedCount) : 0,
    };
  },

  toJSON(message: AcknowledgeEventsResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.acknowledgedCount !== 0) {
      obj.acknowledgedCount = Math.round(message.acknowledgedCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AcknowledgeEventsResponse>, I>>(base?: I): AcknowledgeEventsResponse {
    return AcknowledgeEventsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AcknowledgeEventsResponse>, I>>(object: I): AcknowledgeEventsResponse {
    const message = createBaseAcknowledgeEventsResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.acknowledgedCount = object.acknowledgedCount ?? 0;
    return message;
  },
};

function createBaseReplayEventsRequest(): ReplayEventsRequest {
  return {
    subscriberId: "",
    timeRange: undefined,
    sequenceRange: undefined,
    checkpointToken: undefined,
    filter: undefined,
    batchSize: 0,
    includeFailedEvents: false,
  };
}

export const ReplayEventsRequest = {
  encode(message: ReplayEventsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.subscriberId !== "") {
      writer.uint32(10).string(message.subscriberId);
    }
    if (message.timeRange !== undefined) {
      TimeRange.encode(message.timeRange, writer.uint32(18).fork()).ldelim();
    }
    if (message.sequenceRange !== undefined) {
      SequenceRange.encode(message.sequenceRange, writer.uint32(26).fork()).ldelim();
    }
    if (message.checkpointToken !== undefined) {
      writer.uint32(34).string(message.checkpointToken);
    }
    if (message.filter !== undefined) {
      EventFilter.encode(message.filter, writer.uint32(42).fork()).ldelim();
    }
    if (message.batchSize !== 0) {
      writer.uint32(48).int32(message.batchSize);
    }
    if (message.includeFailedEvents !== false) {
      writer.uint32(56).bool(message.includeFailedEvents);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ReplayEventsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReplayEventsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.subscriberId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.timeRange = TimeRange.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sequenceRange = SequenceRange.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.checkpointToken = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.filter = EventFilter.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.batchSize = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.includeFailedEvents = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReplayEventsRequest {
    return {
      subscriberId: isSet(object.subscriberId) ? globalThis.String(object.subscriberId) : "",
      timeRange: isSet(object.timeRange) ? TimeRange.fromJSON(object.timeRange) : undefined,
      sequenceRange: isSet(object.sequenceRange) ? SequenceRange.fromJSON(object.sequenceRange) : undefined,
      checkpointToken: isSet(object.checkpointToken) ? globalThis.String(object.checkpointToken) : undefined,
      filter: isSet(object.filter) ? EventFilter.fromJSON(object.filter) : undefined,
      batchSize: isSet(object.batchSize) ? globalThis.Number(object.batchSize) : 0,
      includeFailedEvents: isSet(object.includeFailedEvents) ? globalThis.Boolean(object.includeFailedEvents) : false,
    };
  },

  toJSON(message: ReplayEventsRequest): unknown {
    const obj: any = {};
    if (message.subscriberId !== "") {
      obj.subscriberId = message.subscriberId;
    }
    if (message.timeRange !== undefined) {
      obj.timeRange = TimeRange.toJSON(message.timeRange);
    }
    if (message.sequenceRange !== undefined) {
      obj.sequenceRange = SequenceRange.toJSON(message.sequenceRange);
    }
    if (message.checkpointToken !== undefined) {
      obj.checkpointToken = message.checkpointToken;
    }
    if (message.filter !== undefined) {
      obj.filter = EventFilter.toJSON(message.filter);
    }
    if (message.batchSize !== 0) {
      obj.batchSize = Math.round(message.batchSize);
    }
    if (message.includeFailedEvents !== false) {
      obj.includeFailedEvents = message.includeFailedEvents;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReplayEventsRequest>, I>>(base?: I): ReplayEventsRequest {
    return ReplayEventsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReplayEventsRequest>, I>>(object: I): ReplayEventsRequest {
    const message = createBaseReplayEventsRequest();
    message.subscriberId = object.subscriberId ?? "";
    message.timeRange = (object.timeRange !== undefined && object.timeRange !== null)
      ? TimeRange.fromPartial(object.timeRange)
      : undefined;
    message.sequenceRange = (object.sequenceRange !== undefined && object.sequenceRange !== null)
      ? SequenceRange.fromPartial(object.sequenceRange)
      : undefined;
    message.checkpointToken = object.checkpointToken ?? undefined;
    message.filter = (object.filter !== undefined && object.filter !== null)
      ? EventFilter.fromPartial(object.filter)
      : undefined;
    message.batchSize = object.batchSize ?? 0;
    message.includeFailedEvents = object.includeFailedEvents ?? false;
    return message;
  },
};

function createBaseTimeRange(): TimeRange {
  return { startTime: undefined, endTime: undefined };
}

export const TimeRange = {
  encode(message: TimeRange, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(10).fork()).ldelim();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TimeRange {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimeRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TimeRange {
    return {
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
    };
  },

  toJSON(message: TimeRange): unknown {
    const obj: any = {};
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TimeRange>, I>>(base?: I): TimeRange {
    return TimeRange.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TimeRange>, I>>(object: I): TimeRange {
    const message = createBaseTimeRange();
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    return message;
  },
};

function createBaseSequenceRange(): SequenceRange {
  return { startSequence: "0", endSequence: "0" };
}

export const SequenceRange = {
  encode(message: SequenceRange, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.startSequence !== "0") {
      writer.uint32(8).int64(message.startSequence);
    }
    if (message.endSequence !== "0") {
      writer.uint32(16).int64(message.endSequence);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SequenceRange {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSequenceRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.startSequence = longToString(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.endSequence = longToString(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SequenceRange {
    return {
      startSequence: isSet(object.startSequence) ? globalThis.String(object.startSequence) : "0",
      endSequence: isSet(object.endSequence) ? globalThis.String(object.endSequence) : "0",
    };
  },

  toJSON(message: SequenceRange): unknown {
    const obj: any = {};
    if (message.startSequence !== "0") {
      obj.startSequence = message.startSequence;
    }
    if (message.endSequence !== "0") {
      obj.endSequence = message.endSequence;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SequenceRange>, I>>(base?: I): SequenceRange {
    return SequenceRange.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SequenceRange>, I>>(object: I): SequenceRange {
    const message = createBaseSequenceRange();
    message.startSequence = object.startSequence ?? "0";
    message.endSequence = object.endSequence ?? "0";
    return message;
  },
};

function createBaseListDeadLetterEventsRequest(): ListDeadLetterEventsRequest {
  return { subscriberId: "", since: undefined, pageSize: 0, pageToken: "" };
}

export const ListDeadLetterEventsRequest = {
  encode(message: ListDeadLetterEventsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.subscriberId !== "") {
      writer.uint32(10).string(message.subscriberId);
    }
    if (message.since !== undefined) {
      Timestamp.encode(toTimestamp(message.since), writer.uint32(18).fork()).ldelim();
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(34).string(message.pageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListDeadLetterEventsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDeadLetterEventsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.subscriberId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.since = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDeadLetterEventsRequest {
    return {
      subscriberId: isSet(object.subscriberId) ? globalThis.String(object.subscriberId) : "",
      since: isSet(object.since) ? fromJsonTimestamp(object.since) : undefined,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListDeadLetterEventsRequest): unknown {
    const obj: any = {};
    if (message.subscriberId !== "") {
      obj.subscriberId = message.subscriberId;
    }
    if (message.since !== undefined) {
      obj.since = message.since.toISOString();
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListDeadLetterEventsRequest>, I>>(base?: I): ListDeadLetterEventsRequest {
    return ListDeadLetterEventsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListDeadLetterEventsRequest>, I>>(object: I): ListDeadLetterEventsRequest {
    const message = createBaseListDeadLetterEventsRequest();
    message.subscriberId = object.subscriberId ?? "";
    message.since = object.since ?? undefined;
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListDeadLetterEventsResponse(): ListDeadLetterEventsResponse {
  return { events: [], nextPageToken: "", totalCount: 0 };
}

export const ListDeadLetterEventsResponse = {
  encode(message: ListDeadLetterEventsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.events) {
      DeadLetterEvent.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    if (message.totalCount !== 0) {
      writer.uint32(24).int32(message.totalCount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListDeadLetterEventsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDeadLetterEventsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.events.push(DeadLetterEvent.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.totalCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDeadLetterEventsResponse {
    return {
      events: globalThis.Array.isArray(object?.events)
        ? object.events.map((e: any) => DeadLetterEvent.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      totalCount: isSet(object.totalCount) ? globalThis.Number(object.totalCount) : 0,
    };
  },

  toJSON(message: ListDeadLetterEventsResponse): unknown {
    const obj: any = {};
    if (message.events?.length) {
      obj.events = message.events.map((e) => DeadLetterEvent.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.totalCount !== 0) {
      obj.totalCount = Math.round(message.totalCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListDeadLetterEventsResponse>, I>>(base?: I): ListDeadLetterEventsResponse {
    return ListDeadLetterEventsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListDeadLetterEventsResponse>, I>>(object: I): ListDeadLetterEventsResponse {
    const message = createBaseListDeadLetterEventsResponse();
    message.events = object.events?.map((e) => DeadLetterEvent.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.totalCount = object.totalCount ?? 0;
    return message;
  },
};

function createBaseDeadLetterEvent(): DeadLetterEvent {
  return { originalEvent: undefined, failureReason: "", retryCount: 0, failedAt: undefined, lastRetryAt: undefined };
}

export const DeadLetterEvent = {
  encode(message: DeadLetterEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.originalEvent !== undefined) {
      UniversalEvent.encode(message.originalEvent, writer.uint32(10).fork()).ldelim();
    }
    if (message.failureReason !== "") {
      writer.uint32(18).string(message.failureReason);
    }
    if (message.retryCount !== 0) {
      writer.uint32(24).int32(message.retryCount);
    }
    if (message.failedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.failedAt), writer.uint32(34).fork()).ldelim();
    }
    if (message.lastRetryAt !== undefined) {
      Timestamp.encode(toTimestamp(message.lastRetryAt), writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeadLetterEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeadLetterEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.originalEvent = UniversalEvent.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.failureReason = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.retryCount = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.failedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.lastRetryAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeadLetterEvent {
    return {
      originalEvent: isSet(object.originalEvent) ? UniversalEvent.fromJSON(object.originalEvent) : undefined,
      failureReason: isSet(object.failureReason) ? globalThis.String(object.failureReason) : "",
      retryCount: isSet(object.retryCount) ? globalThis.Number(object.retryCount) : 0,
      failedAt: isSet(object.failedAt) ? fromJsonTimestamp(object.failedAt) : undefined,
      lastRetryAt: isSet(object.lastRetryAt) ? fromJsonTimestamp(object.lastRetryAt) : undefined,
    };
  },

  toJSON(message: DeadLetterEvent): unknown {
    const obj: any = {};
    if (message.originalEvent !== undefined) {
      obj.originalEvent = UniversalEvent.toJSON(message.originalEvent);
    }
    if (message.failureReason !== "") {
      obj.failureReason = message.failureReason;
    }
    if (message.retryCount !== 0) {
      obj.retryCount = Math.round(message.retryCount);
    }
    if (message.failedAt !== undefined) {
      obj.failedAt = message.failedAt.toISOString();
    }
    if (message.lastRetryAt !== undefined) {
      obj.lastRetryAt = message.lastRetryAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeadLetterEvent>, I>>(base?: I): DeadLetterEvent {
    return DeadLetterEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeadLetterEvent>, I>>(object: I): DeadLetterEvent {
    const message = createBaseDeadLetterEvent();
    message.originalEvent = (object.originalEvent !== undefined && object.originalEvent !== null)
      ? UniversalEvent.fromPartial(object.originalEvent)
      : undefined;
    message.failureReason = object.failureReason ?? "";
    message.retryCount = object.retryCount ?? 0;
    message.failedAt = object.failedAt ?? undefined;
    message.lastRetryAt = object.lastRetryAt ?? undefined;
    return message;
  },
};

function createBaseReprocessDeadLetterEventsRequest(): ReprocessDeadLetterEventsRequest {
  return { subscriberId: "", eventIds: [], resetRetryCount: false };
}

export const ReprocessDeadLetterEventsRequest = {
  encode(message: ReprocessDeadLetterEventsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.subscriberId !== "") {
      writer.uint32(10).string(message.subscriberId);
    }
    for (const v of message.eventIds) {
      writer.uint32(18).string(v!);
    }
    if (message.resetRetryCount !== false) {
      writer.uint32(24).bool(message.resetRetryCount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ReprocessDeadLetterEventsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReprocessDeadLetterEventsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.subscriberId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.eventIds.push(reader.string());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.resetRetryCount = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReprocessDeadLetterEventsRequest {
    return {
      subscriberId: isSet(object.subscriberId) ? globalThis.String(object.subscriberId) : "",
      eventIds: globalThis.Array.isArray(object?.eventIds) ? object.eventIds.map((e: any) => globalThis.String(e)) : [],
      resetRetryCount: isSet(object.resetRetryCount) ? globalThis.Boolean(object.resetRetryCount) : false,
    };
  },

  toJSON(message: ReprocessDeadLetterEventsRequest): unknown {
    const obj: any = {};
    if (message.subscriberId !== "") {
      obj.subscriberId = message.subscriberId;
    }
    if (message.eventIds?.length) {
      obj.eventIds = message.eventIds;
    }
    if (message.resetRetryCount !== false) {
      obj.resetRetryCount = message.resetRetryCount;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReprocessDeadLetterEventsRequest>, I>>(
    base?: I,
  ): ReprocessDeadLetterEventsRequest {
    return ReprocessDeadLetterEventsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReprocessDeadLetterEventsRequest>, I>>(
    object: I,
  ): ReprocessDeadLetterEventsRequest {
    const message = createBaseReprocessDeadLetterEventsRequest();
    message.subscriberId = object.subscriberId ?? "";
    message.eventIds = object.eventIds?.map((e) => e) || [];
    message.resetRetryCount = object.resetRetryCount ?? false;
    return message;
  },
};

function createBaseReprocessDeadLetterEventsResponse(): ReprocessDeadLetterEventsResponse {
  return { success: false, message: "", reprocessedCount: 0 };
}

export const ReprocessDeadLetterEventsResponse = {
  encode(message: ReprocessDeadLetterEventsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.reprocessedCount !== 0) {
      writer.uint32(24).int32(message.reprocessedCount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ReprocessDeadLetterEventsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReprocessDeadLetterEventsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.reprocessedCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReprocessDeadLetterEventsResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      reprocessedCount: isSet(object.reprocessedCount) ? globalThis.Number(object.reprocessedCount) : 0,
    };
  },

  toJSON(message: ReprocessDeadLetterEventsResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.reprocessedCount !== 0) {
      obj.reprocessedCount = Math.round(message.reprocessedCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReprocessDeadLetterEventsResponse>, I>>(
    base?: I,
  ): ReprocessDeadLetterEventsResponse {
    return ReprocessDeadLetterEventsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReprocessDeadLetterEventsResponse>, I>>(
    object: I,
  ): ReprocessDeadLetterEventsResponse {
    const message = createBaseReprocessDeadLetterEventsResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.reprocessedCount = object.reprocessedCount ?? 0;
    return message;
  },
};

function createBaseGetEventStatsRequest(): GetEventStatsRequest {
  return { startTime: undefined, endTime: undefined, eventTypes: [], sourceServices: [], aggregationInterval: "" };
}

export const GetEventStatsRequest = {
  encode(message: GetEventStatsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(10).fork()).ldelim();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.eventTypes) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.sourceServices) {
      writer.uint32(34).string(v!);
    }
    if (message.aggregationInterval !== "") {
      writer.uint32(42).string(message.aggregationInterval);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetEventStatsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetEventStatsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.eventTypes.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.sourceServices.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.aggregationInterval = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetEventStatsRequest {
    return {
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      eventTypes: globalThis.Array.isArray(object?.eventTypes)
        ? object.eventTypes.map((e: any) => globalThis.String(e))
        : [],
      sourceServices: globalThis.Array.isArray(object?.sourceServices)
        ? object.sourceServices.map((e: any) => globalThis.String(e))
        : [],
      aggregationInterval: isSet(object.aggregationInterval) ? globalThis.String(object.aggregationInterval) : "",
    };
  },

  toJSON(message: GetEventStatsRequest): unknown {
    const obj: any = {};
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    if (message.eventTypes?.length) {
      obj.eventTypes = message.eventTypes;
    }
    if (message.sourceServices?.length) {
      obj.sourceServices = message.sourceServices;
    }
    if (message.aggregationInterval !== "") {
      obj.aggregationInterval = message.aggregationInterval;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetEventStatsRequest>, I>>(base?: I): GetEventStatsRequest {
    return GetEventStatsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetEventStatsRequest>, I>>(object: I): GetEventStatsRequest {
    const message = createBaseGetEventStatsRequest();
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.eventTypes = object.eventTypes?.map((e) => e) || [];
    message.sourceServices = object.sourceServices?.map((e) => e) || [];
    message.aggregationInterval = object.aggregationInterval ?? "";
    return message;
  },
};

function createBaseGetEventStatsResponse(): GetEventStatsResponse {
  return { stats: [] };
}

export const GetEventStatsResponse = {
  encode(message: GetEventStatsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.stats) {
      EventStats.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetEventStatsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetEventStatsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.stats.push(EventStats.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetEventStatsResponse {
    return {
      stats: globalThis.Array.isArray(object?.stats) ? object.stats.map((e: any) => EventStats.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetEventStatsResponse): unknown {
    const obj: any = {};
    if (message.stats?.length) {
      obj.stats = message.stats.map((e) => EventStats.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetEventStatsResponse>, I>>(base?: I): GetEventStatsResponse {
    return GetEventStatsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetEventStatsResponse>, I>>(object: I): GetEventStatsResponse {
    const message = createBaseGetEventStatsResponse();
    message.stats = object.stats?.map((e) => EventStats.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEventStats(): EventStats {
  return {
    timestamp: undefined,
    eventType: "",
    sourceService: "",
    eventCount: "0",
    eventsPerSecond: 0,
    avgProcessingTimeMs: 0,
    failedCount: "0",
  };
}

export const EventStats = {
  encode(message: EventStats, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(10).fork()).ldelim();
    }
    if (message.eventType !== "") {
      writer.uint32(18).string(message.eventType);
    }
    if (message.sourceService !== "") {
      writer.uint32(26).string(message.sourceService);
    }
    if (message.eventCount !== "0") {
      writer.uint32(32).int64(message.eventCount);
    }
    if (message.eventsPerSecond !== 0) {
      writer.uint32(41).double(message.eventsPerSecond);
    }
    if (message.avgProcessingTimeMs !== 0) {
      writer.uint32(49).double(message.avgProcessingTimeMs);
    }
    if (message.failedCount !== "0") {
      writer.uint32(56).int64(message.failedCount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EventStats {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.eventType = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sourceService = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.eventCount = longToString(reader.int64() as Long);
          continue;
        case 5:
          if (tag !== 41) {
            break;
          }

          message.eventsPerSecond = reader.double();
          continue;
        case 6:
          if (tag !== 49) {
            break;
          }

          message.avgProcessingTimeMs = reader.double();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.failedCount = longToString(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventStats {
    return {
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      eventType: isSet(object.eventType) ? globalThis.String(object.eventType) : "",
      sourceService: isSet(object.sourceService) ? globalThis.String(object.sourceService) : "",
      eventCount: isSet(object.eventCount) ? globalThis.String(object.eventCount) : "0",
      eventsPerSecond: isSet(object.eventsPerSecond) ? globalThis.Number(object.eventsPerSecond) : 0,
      avgProcessingTimeMs: isSet(object.avgProcessingTimeMs) ? globalThis.Number(object.avgProcessingTimeMs) : 0,
      failedCount: isSet(object.failedCount) ? globalThis.String(object.failedCount) : "0",
    };
  },

  toJSON(message: EventStats): unknown {
    const obj: any = {};
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.eventType !== "") {
      obj.eventType = message.eventType;
    }
    if (message.sourceService !== "") {
      obj.sourceService = message.sourceService;
    }
    if (message.eventCount !== "0") {
      obj.eventCount = message.eventCount;
    }
    if (message.eventsPerSecond !== 0) {
      obj.eventsPerSecond = message.eventsPerSecond;
    }
    if (message.avgProcessingTimeMs !== 0) {
      obj.avgProcessingTimeMs = message.avgProcessingTimeMs;
    }
    if (message.failedCount !== "0") {
      obj.failedCount = message.failedCount;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventStats>, I>>(base?: I): EventStats {
    return EventStats.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventStats>, I>>(object: I): EventStats {
    const message = createBaseEventStats();
    message.timestamp = object.timestamp ?? undefined;
    message.eventType = object.eventType ?? "";
    message.sourceService = object.sourceService ?? "";
    message.eventCount = object.eventCount ?? "0";
    message.eventsPerSecond = object.eventsPerSecond ?? 0;
    message.avgProcessingTimeMs = object.avgProcessingTimeMs ?? 0;
    message.failedCount = object.failedCount ?? "0";
    return message;
  },
};

function createBaseListSubscriptionsRequest(): ListSubscriptionsRequest {
  return { subscriberId: "", includeInactive: false };
}

export const ListSubscriptionsRequest = {
  encode(message: ListSubscriptionsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.subscriberId !== "") {
      writer.uint32(10).string(message.subscriberId);
    }
    if (message.includeInactive !== false) {
      writer.uint32(16).bool(message.includeInactive);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListSubscriptionsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSubscriptionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.subscriberId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.includeInactive = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSubscriptionsRequest {
    return {
      subscriberId: isSet(object.subscriberId) ? globalThis.String(object.subscriberId) : "",
      includeInactive: isSet(object.includeInactive) ? globalThis.Boolean(object.includeInactive) : false,
    };
  },

  toJSON(message: ListSubscriptionsRequest): unknown {
    const obj: any = {};
    if (message.subscriberId !== "") {
      obj.subscriberId = message.subscriberId;
    }
    if (message.includeInactive !== false) {
      obj.includeInactive = message.includeInactive;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListSubscriptionsRequest>, I>>(base?: I): ListSubscriptionsRequest {
    return ListSubscriptionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListSubscriptionsRequest>, I>>(object: I): ListSubscriptionsRequest {
    const message = createBaseListSubscriptionsRequest();
    message.subscriberId = object.subscriberId ?? "";
    message.includeInactive = object.includeInactive ?? false;
    return message;
  },
};

function createBaseListSubscriptionsResponse(): ListSubscriptionsResponse {
  return { subscriptions: [] };
}

export const ListSubscriptionsResponse = {
  encode(message: ListSubscriptionsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.subscriptions) {
      SubscriptionInfo.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListSubscriptionsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSubscriptionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.subscriptions.push(SubscriptionInfo.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSubscriptionsResponse {
    return {
      subscriptions: globalThis.Array.isArray(object?.subscriptions)
        ? object.subscriptions.map((e: any) => SubscriptionInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListSubscriptionsResponse): unknown {
    const obj: any = {};
    if (message.subscriptions?.length) {
      obj.subscriptions = message.subscriptions.map((e) => SubscriptionInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListSubscriptionsResponse>, I>>(base?: I): ListSubscriptionsResponse {
    return ListSubscriptionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListSubscriptionsResponse>, I>>(object: I): ListSubscriptionsResponse {
    const message = createBaseListSubscriptionsResponse();
    message.subscriptions = object.subscriptions?.map((e) => SubscriptionInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSubscriptionInfo(): SubscriptionInfo {
  return {
    subscriberId: "",
    subscriberName: "",
    filter: undefined,
    options: undefined,
    status: "",
    createdAt: undefined,
    lastActiveAt: undefined,
    eventsProcessed: "0",
    eventsFailed: "0",
  };
}

export const SubscriptionInfo = {
  encode(message: SubscriptionInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.subscriberId !== "") {
      writer.uint32(10).string(message.subscriberId);
    }
    if (message.subscriberName !== "") {
      writer.uint32(18).string(message.subscriberName);
    }
    if (message.filter !== undefined) {
      EventFilter.encode(message.filter, writer.uint32(26).fork()).ldelim();
    }
    if (message.options !== undefined) {
      SubscriptionOptions.encode(message.options, writer.uint32(34).fork()).ldelim();
    }
    if (message.status !== "") {
      writer.uint32(42).string(message.status);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(50).fork()).ldelim();
    }
    if (message.lastActiveAt !== undefined) {
      Timestamp.encode(toTimestamp(message.lastActiveAt), writer.uint32(58).fork()).ldelim();
    }
    if (message.eventsProcessed !== "0") {
      writer.uint32(64).int64(message.eventsProcessed);
    }
    if (message.eventsFailed !== "0") {
      writer.uint32(72).int64(message.eventsFailed);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubscriptionInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscriptionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.subscriberId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.subscriberName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.filter = EventFilter.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.options = SubscriptionOptions.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.status = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.lastActiveAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.eventsProcessed = longToString(reader.int64() as Long);
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.eventsFailed = longToString(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscriptionInfo {
    return {
      subscriberId: isSet(object.subscriberId) ? globalThis.String(object.subscriberId) : "",
      subscriberName: isSet(object.subscriberName) ? globalThis.String(object.subscriberName) : "",
      filter: isSet(object.filter) ? EventFilter.fromJSON(object.filter) : undefined,
      options: isSet(object.options) ? SubscriptionOptions.fromJSON(object.options) : undefined,
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      lastActiveAt: isSet(object.lastActiveAt) ? fromJsonTimestamp(object.lastActiveAt) : undefined,
      eventsProcessed: isSet(object.eventsProcessed) ? globalThis.String(object.eventsProcessed) : "0",
      eventsFailed: isSet(object.eventsFailed) ? globalThis.String(object.eventsFailed) : "0",
    };
  },

  toJSON(message: SubscriptionInfo): unknown {
    const obj: any = {};
    if (message.subscriberId !== "") {
      obj.subscriberId = message.subscriberId;
    }
    if (message.subscriberName !== "") {
      obj.subscriberName = message.subscriberName;
    }
    if (message.filter !== undefined) {
      obj.filter = EventFilter.toJSON(message.filter);
    }
    if (message.options !== undefined) {
      obj.options = SubscriptionOptions.toJSON(message.options);
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.lastActiveAt !== undefined) {
      obj.lastActiveAt = message.lastActiveAt.toISOString();
    }
    if (message.eventsProcessed !== "0") {
      obj.eventsProcessed = message.eventsProcessed;
    }
    if (message.eventsFailed !== "0") {
      obj.eventsFailed = message.eventsFailed;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubscriptionInfo>, I>>(base?: I): SubscriptionInfo {
    return SubscriptionInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubscriptionInfo>, I>>(object: I): SubscriptionInfo {
    const message = createBaseSubscriptionInfo();
    message.subscriberId = object.subscriberId ?? "";
    message.subscriberName = object.subscriberName ?? "";
    message.filter = (object.filter !== undefined && object.filter !== null)
      ? EventFilter.fromPartial(object.filter)
      : undefined;
    message.options = (object.options !== undefined && object.options !== null)
      ? SubscriptionOptions.fromPartial(object.options)
      : undefined;
    message.status = object.status ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.lastActiveAt = object.lastActiveAt ?? undefined;
    message.eventsProcessed = object.eventsProcessed ?? "0";
    message.eventsFailed = object.eventsFailed ?? "0";
    return message;
  },
};

function createBaseUpdateSubscriptionRequest(): UpdateSubscriptionRequest {
  return { subscriberId: "", filter: undefined, options: undefined };
}

export const UpdateSubscriptionRequest = {
  encode(message: UpdateSubscriptionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.subscriberId !== "") {
      writer.uint32(10).string(message.subscriberId);
    }
    if (message.filter !== undefined) {
      EventFilter.encode(message.filter, writer.uint32(18).fork()).ldelim();
    }
    if (message.options !== undefined) {
      SubscriptionOptions.encode(message.options, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateSubscriptionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSubscriptionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.subscriberId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.filter = EventFilter.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.options = SubscriptionOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSubscriptionRequest {
    return {
      subscriberId: isSet(object.subscriberId) ? globalThis.String(object.subscriberId) : "",
      filter: isSet(object.filter) ? EventFilter.fromJSON(object.filter) : undefined,
      options: isSet(object.options) ? SubscriptionOptions.fromJSON(object.options) : undefined,
    };
  },

  toJSON(message: UpdateSubscriptionRequest): unknown {
    const obj: any = {};
    if (message.subscriberId !== "") {
      obj.subscriberId = message.subscriberId;
    }
    if (message.filter !== undefined) {
      obj.filter = EventFilter.toJSON(message.filter);
    }
    if (message.options !== undefined) {
      obj.options = SubscriptionOptions.toJSON(message.options);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateSubscriptionRequest>, I>>(base?: I): UpdateSubscriptionRequest {
    return UpdateSubscriptionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateSubscriptionRequest>, I>>(object: I): UpdateSubscriptionRequest {
    const message = createBaseUpdateSubscriptionRequest();
    message.subscriberId = object.subscriberId ?? "";
    message.filter = (object.filter !== undefined && object.filter !== null)
      ? EventFilter.fromPartial(object.filter)
      : undefined;
    message.options = (object.options !== undefined && object.options !== null)
      ? SubscriptionOptions.fromPartial(object.options)
      : undefined;
    return message;
  },
};

function createBaseUpdateSubscriptionResponse(): UpdateSubscriptionResponse {
  return { success: false, message: "" };
}

export const UpdateSubscriptionResponse = {
  encode(message: UpdateSubscriptionResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateSubscriptionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSubscriptionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSubscriptionResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: UpdateSubscriptionResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateSubscriptionResponse>, I>>(base?: I): UpdateSubscriptionResponse {
    return UpdateSubscriptionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateSubscriptionResponse>, I>>(object: I): UpdateSubscriptionResponse {
    const message = createBaseUpdateSubscriptionResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseDeleteSubscriptionRequest(): DeleteSubscriptionRequest {
  return { subscriberId: "" };
}

export const DeleteSubscriptionRequest = {
  encode(message: DeleteSubscriptionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.subscriberId !== "") {
      writer.uint32(10).string(message.subscriberId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteSubscriptionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteSubscriptionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.subscriberId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteSubscriptionRequest {
    return { subscriberId: isSet(object.subscriberId) ? globalThis.String(object.subscriberId) : "" };
  },

  toJSON(message: DeleteSubscriptionRequest): unknown {
    const obj: any = {};
    if (message.subscriberId !== "") {
      obj.subscriberId = message.subscriberId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteSubscriptionRequest>, I>>(base?: I): DeleteSubscriptionRequest {
    return DeleteSubscriptionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteSubscriptionRequest>, I>>(object: I): DeleteSubscriptionRequest {
    const message = createBaseDeleteSubscriptionRequest();
    message.subscriberId = object.subscriberId ?? "";
    return message;
  },
};

function createBaseDeleteSubscriptionResponse(): DeleteSubscriptionResponse {
  return { success: false, message: "" };
}

export const DeleteSubscriptionResponse = {
  encode(message: DeleteSubscriptionResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteSubscriptionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteSubscriptionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteSubscriptionResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: DeleteSubscriptionResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteSubscriptionResponse>, I>>(base?: I): DeleteSubscriptionResponse {
    return DeleteSubscriptionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteSubscriptionResponse>, I>>(object: I): DeleteSubscriptionResponse {
    const message = createBaseDeleteSubscriptionResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseGetServiceStatusRequest(): GetServiceStatusRequest {
  return {};
}

export const GetServiceStatusRequest = {
  encode(_: GetServiceStatusRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetServiceStatusRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetServiceStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetServiceStatusRequest {
    return {};
  },

  toJSON(_: GetServiceStatusRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetServiceStatusRequest>, I>>(base?: I): GetServiceStatusRequest {
    return GetServiceStatusRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetServiceStatusRequest>, I>>(_: I): GetServiceStatusRequest {
    const message = createBaseGetServiceStatusRequest();
    return message;
  },
};

function createBaseGetServiceStatusResponse(): GetServiceStatusResponse {
  return { healthy: false, status: "", timestamp: undefined, metrics: undefined };
}

export const GetServiceStatusResponse = {
  encode(message: GetServiceStatusResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.healthy !== false) {
      writer.uint32(8).bool(message.healthy);
    }
    if (message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(26).fork()).ldelim();
    }
    if (message.metrics !== undefined) {
      ServiceMetrics.encode(message.metrics, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetServiceStatusResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetServiceStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.healthy = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.metrics = ServiceMetrics.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetServiceStatusResponse {
    return {
      healthy: isSet(object.healthy) ? globalThis.Boolean(object.healthy) : false,
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      metrics: isSet(object.metrics) ? ServiceMetrics.fromJSON(object.metrics) : undefined,
    };
  },

  toJSON(message: GetServiceStatusResponse): unknown {
    const obj: any = {};
    if (message.healthy !== false) {
      obj.healthy = message.healthy;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.metrics !== undefined) {
      obj.metrics = ServiceMetrics.toJSON(message.metrics);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetServiceStatusResponse>, I>>(base?: I): GetServiceStatusResponse {
    return GetServiceStatusResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetServiceStatusResponse>, I>>(object: I): GetServiceStatusResponse {
    const message = createBaseGetServiceStatusResponse();
    message.healthy = object.healthy ?? false;
    message.status = object.status ?? "";
    message.timestamp = object.timestamp ?? undefined;
    message.metrics = (object.metrics !== undefined && object.metrics !== null)
      ? ServiceMetrics.fromPartial(object.metrics)
      : undefined;
    return message;
  },
};

function createBaseServiceMetrics(): ServiceMetrics {
  return {
    totalEventsPublished: "0",
    totalEventsDelivered: "0",
    activeSubscriptions: "0",
    eventsInDlq: "0",
    avgPublishLatencyMs: 0,
    avgDeliveryLatencyMs: 0,
  };
}

export const ServiceMetrics = {
  encode(message: ServiceMetrics, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.totalEventsPublished !== "0") {
      writer.uint32(8).int64(message.totalEventsPublished);
    }
    if (message.totalEventsDelivered !== "0") {
      writer.uint32(16).int64(message.totalEventsDelivered);
    }
    if (message.activeSubscriptions !== "0") {
      writer.uint32(24).int64(message.activeSubscriptions);
    }
    if (message.eventsInDlq !== "0") {
      writer.uint32(32).int64(message.eventsInDlq);
    }
    if (message.avgPublishLatencyMs !== 0) {
      writer.uint32(41).double(message.avgPublishLatencyMs);
    }
    if (message.avgDeliveryLatencyMs !== 0) {
      writer.uint32(49).double(message.avgDeliveryLatencyMs);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ServiceMetrics {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.totalEventsPublished = longToString(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.totalEventsDelivered = longToString(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.activeSubscriptions = longToString(reader.int64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.eventsInDlq = longToString(reader.int64() as Long);
          continue;
        case 5:
          if (tag !== 41) {
            break;
          }

          message.avgPublishLatencyMs = reader.double();
          continue;
        case 6:
          if (tag !== 49) {
            break;
          }

          message.avgDeliveryLatencyMs = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceMetrics {
    return {
      totalEventsPublished: isSet(object.totalEventsPublished) ? globalThis.String(object.totalEventsPublished) : "0",
      totalEventsDelivered: isSet(object.totalEventsDelivered) ? globalThis.String(object.totalEventsDelivered) : "0",
      activeSubscriptions: isSet(object.activeSubscriptions) ? globalThis.String(object.activeSubscriptions) : "0",
      eventsInDlq: isSet(object.eventsInDlq) ? globalThis.String(object.eventsInDlq) : "0",
      avgPublishLatencyMs: isSet(object.avgPublishLatencyMs) ? globalThis.Number(object.avgPublishLatencyMs) : 0,
      avgDeliveryLatencyMs: isSet(object.avgDeliveryLatencyMs) ? globalThis.Number(object.avgDeliveryLatencyMs) : 0,
    };
  },

  toJSON(message: ServiceMetrics): unknown {
    const obj: any = {};
    if (message.totalEventsPublished !== "0") {
      obj.totalEventsPublished = message.totalEventsPublished;
    }
    if (message.totalEventsDelivered !== "0") {
      obj.totalEventsDelivered = message.totalEventsDelivered;
    }
    if (message.activeSubscriptions !== "0") {
      obj.activeSubscriptions = message.activeSubscriptions;
    }
    if (message.eventsInDlq !== "0") {
      obj.eventsInDlq = message.eventsInDlq;
    }
    if (message.avgPublishLatencyMs !== 0) {
      obj.avgPublishLatencyMs = message.avgPublishLatencyMs;
    }
    if (message.avgDeliveryLatencyMs !== 0) {
      obj.avgDeliveryLatencyMs = message.avgDeliveryLatencyMs;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServiceMetrics>, I>>(base?: I): ServiceMetrics {
    return ServiceMetrics.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServiceMetrics>, I>>(object: I): ServiceMetrics {
    const message = createBaseServiceMetrics();
    message.totalEventsPublished = object.totalEventsPublished ?? "0";
    message.totalEventsDelivered = object.totalEventsDelivered ?? "0";
    message.activeSubscriptions = object.activeSubscriptions ?? "0";
    message.eventsInDlq = object.eventsInDlq ?? "0";
    message.avgPublishLatencyMs = object.avgPublishLatencyMs ?? 0;
    message.avgDeliveryLatencyMs = object.avgDeliveryLatencyMs ?? 0;
    return message;
  },
};

export type CDCServiceService = typeof CDCServiceService;
export const CDCServiceService = {
  /** Event publishing */
  publishEvent: {
    path: "/unhinged.cdc.CDCService/PublishEvent",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PublishEventRequest) => Buffer.from(PublishEventRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => PublishEventRequest.decode(value),
    responseSerialize: (value: PublishEventResponse) => Buffer.from(PublishEventResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => PublishEventResponse.decode(value),
  },
  publishEvents: {
    path: "/unhinged.cdc.CDCService/PublishEvents",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PublishEventsRequest) => Buffer.from(PublishEventsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => PublishEventsRequest.decode(value),
    responseSerialize: (value: PublishEventsResponse) => Buffer.from(PublishEventsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => PublishEventsResponse.decode(value),
  },
  /** Event subscription (streaming) */
  subscribe: {
    path: "/unhinged.cdc.CDCService/Subscribe",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: SubscribeRequest) => Buffer.from(SubscribeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SubscribeRequest.decode(value),
    responseSerialize: (value: EventStreamResponse) => Buffer.from(EventStreamResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => EventStreamResponse.decode(value),
  },
  acknowledgeEvents: {
    path: "/unhinged.cdc.CDCService/AcknowledgeEvents",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AcknowledgeEventsRequest) => Buffer.from(AcknowledgeEventsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => AcknowledgeEventsRequest.decode(value),
    responseSerialize: (value: AcknowledgeEventsResponse) =>
      Buffer.from(AcknowledgeEventsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AcknowledgeEventsResponse.decode(value),
  },
  /** Event replay */
  replayEvents: {
    path: "/unhinged.cdc.CDCService/ReplayEvents",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: ReplayEventsRequest) => Buffer.from(ReplayEventsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ReplayEventsRequest.decode(value),
    responseSerialize: (value: EventStreamResponse) => Buffer.from(EventStreamResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => EventStreamResponse.decode(value),
  },
  /** Dead letter queue */
  listDeadLetterEvents: {
    path: "/unhinged.cdc.CDCService/ListDeadLetterEvents",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListDeadLetterEventsRequest) =>
      Buffer.from(ListDeadLetterEventsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ListDeadLetterEventsRequest.decode(value),
    responseSerialize: (value: ListDeadLetterEventsResponse) =>
      Buffer.from(ListDeadLetterEventsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ListDeadLetterEventsResponse.decode(value),
  },
  reprocessDeadLetterEvents: {
    path: "/unhinged.cdc.CDCService/ReprocessDeadLetterEvents",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ReprocessDeadLetterEventsRequest) =>
      Buffer.from(ReprocessDeadLetterEventsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ReprocessDeadLetterEventsRequest.decode(value),
    responseSerialize: (value: ReprocessDeadLetterEventsResponse) =>
      Buffer.from(ReprocessDeadLetterEventsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ReprocessDeadLetterEventsResponse.decode(value),
  },
  /** Analytics */
  getEventStats: {
    path: "/unhinged.cdc.CDCService/GetEventStats",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetEventStatsRequest) => Buffer.from(GetEventStatsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetEventStatsRequest.decode(value),
    responseSerialize: (value: GetEventStatsResponse) => Buffer.from(GetEventStatsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetEventStatsResponse.decode(value),
  },
  /** Subscription management */
  listSubscriptions: {
    path: "/unhinged.cdc.CDCService/ListSubscriptions",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListSubscriptionsRequest) => Buffer.from(ListSubscriptionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ListSubscriptionsRequest.decode(value),
    responseSerialize: (value: ListSubscriptionsResponse) =>
      Buffer.from(ListSubscriptionsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ListSubscriptionsResponse.decode(value),
  },
  updateSubscription: {
    path: "/unhinged.cdc.CDCService/UpdateSubscription",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateSubscriptionRequest) =>
      Buffer.from(UpdateSubscriptionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UpdateSubscriptionRequest.decode(value),
    responseSerialize: (value: UpdateSubscriptionResponse) =>
      Buffer.from(UpdateSubscriptionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => UpdateSubscriptionResponse.decode(value),
  },
  deleteSubscription: {
    path: "/unhinged.cdc.CDCService/DeleteSubscription",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteSubscriptionRequest) =>
      Buffer.from(DeleteSubscriptionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DeleteSubscriptionRequest.decode(value),
    responseSerialize: (value: DeleteSubscriptionResponse) =>
      Buffer.from(DeleteSubscriptionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DeleteSubscriptionResponse.decode(value),
  },
  /** Health and status */
  getServiceStatus: {
    path: "/unhinged.cdc.CDCService/GetServiceStatus",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetServiceStatusRequest) => Buffer.from(GetServiceStatusRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetServiceStatusRequest.decode(value),
    responseSerialize: (value: GetServiceStatusResponse) =>
      Buffer.from(GetServiceStatusResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetServiceStatusResponse.decode(value),
  },
} as const;

export interface CDCServiceServer extends UntypedServiceImplementation {
  /** Event publishing */
  publishEvent: handleUnaryCall<PublishEventRequest, PublishEventResponse>;
  publishEvents: handleUnaryCall<PublishEventsRequest, PublishEventsResponse>;
  /** Event subscription (streaming) */
  subscribe: handleServerStreamingCall<SubscribeRequest, EventStreamResponse>;
  acknowledgeEvents: handleUnaryCall<AcknowledgeEventsRequest, AcknowledgeEventsResponse>;
  /** Event replay */
  replayEvents: handleServerStreamingCall<ReplayEventsRequest, EventStreamResponse>;
  /** Dead letter queue */
  listDeadLetterEvents: handleUnaryCall<ListDeadLetterEventsRequest, ListDeadLetterEventsResponse>;
  reprocessDeadLetterEvents: handleUnaryCall<ReprocessDeadLetterEventsRequest, ReprocessDeadLetterEventsResponse>;
  /** Analytics */
  getEventStats: handleUnaryCall<GetEventStatsRequest, GetEventStatsResponse>;
  /** Subscription management */
  listSubscriptions: handleUnaryCall<ListSubscriptionsRequest, ListSubscriptionsResponse>;
  updateSubscription: handleUnaryCall<UpdateSubscriptionRequest, UpdateSubscriptionResponse>;
  deleteSubscription: handleUnaryCall<DeleteSubscriptionRequest, DeleteSubscriptionResponse>;
  /** Health and status */
  getServiceStatus: handleUnaryCall<GetServiceStatusRequest, GetServiceStatusResponse>;
}

export interface CDCServiceClient extends Client {
  /** Event publishing */
  publishEvent(
    request: PublishEventRequest,
    callback: (error: ServiceError | null, response: PublishEventResponse) => void,
  ): ClientUnaryCall;
  publishEvent(
    request: PublishEventRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PublishEventResponse) => void,
  ): ClientUnaryCall;
  publishEvent(
    request: PublishEventRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PublishEventResponse) => void,
  ): ClientUnaryCall;
  publishEvents(
    request: PublishEventsRequest,
    callback: (error: ServiceError | null, response: PublishEventsResponse) => void,
  ): ClientUnaryCall;
  publishEvents(
    request: PublishEventsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PublishEventsResponse) => void,
  ): ClientUnaryCall;
  publishEvents(
    request: PublishEventsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PublishEventsResponse) => void,
  ): ClientUnaryCall;
  /** Event subscription (streaming) */
  subscribe(request: SubscribeRequest, options?: Partial<CallOptions>): ClientReadableStream<EventStreamResponse>;
  subscribe(
    request: SubscribeRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<EventStreamResponse>;
  acknowledgeEvents(
    request: AcknowledgeEventsRequest,
    callback: (error: ServiceError | null, response: AcknowledgeEventsResponse) => void,
  ): ClientUnaryCall;
  acknowledgeEvents(
    request: AcknowledgeEventsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: AcknowledgeEventsResponse) => void,
  ): ClientUnaryCall;
  acknowledgeEvents(
    request: AcknowledgeEventsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: AcknowledgeEventsResponse) => void,
  ): ClientUnaryCall;
  /** Event replay */
  replayEvents(request: ReplayEventsRequest, options?: Partial<CallOptions>): ClientReadableStream<EventStreamResponse>;
  replayEvents(
    request: ReplayEventsRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<EventStreamResponse>;
  /** Dead letter queue */
  listDeadLetterEvents(
    request: ListDeadLetterEventsRequest,
    callback: (error: ServiceError | null, response: ListDeadLetterEventsResponse) => void,
  ): ClientUnaryCall;
  listDeadLetterEvents(
    request: ListDeadLetterEventsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListDeadLetterEventsResponse) => void,
  ): ClientUnaryCall;
  listDeadLetterEvents(
    request: ListDeadLetterEventsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListDeadLetterEventsResponse) => void,
  ): ClientUnaryCall;
  reprocessDeadLetterEvents(
    request: ReprocessDeadLetterEventsRequest,
    callback: (error: ServiceError | null, response: ReprocessDeadLetterEventsResponse) => void,
  ): ClientUnaryCall;
  reprocessDeadLetterEvents(
    request: ReprocessDeadLetterEventsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ReprocessDeadLetterEventsResponse) => void,
  ): ClientUnaryCall;
  reprocessDeadLetterEvents(
    request: ReprocessDeadLetterEventsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ReprocessDeadLetterEventsResponse) => void,
  ): ClientUnaryCall;
  /** Analytics */
  getEventStats(
    request: GetEventStatsRequest,
    callback: (error: ServiceError | null, response: GetEventStatsResponse) => void,
  ): ClientUnaryCall;
  getEventStats(
    request: GetEventStatsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetEventStatsResponse) => void,
  ): ClientUnaryCall;
  getEventStats(
    request: GetEventStatsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetEventStatsResponse) => void,
  ): ClientUnaryCall;
  /** Subscription management */
  listSubscriptions(
    request: ListSubscriptionsRequest,
    callback: (error: ServiceError | null, response: ListSubscriptionsResponse) => void,
  ): ClientUnaryCall;
  listSubscriptions(
    request: ListSubscriptionsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListSubscriptionsResponse) => void,
  ): ClientUnaryCall;
  listSubscriptions(
    request: ListSubscriptionsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListSubscriptionsResponse) => void,
  ): ClientUnaryCall;
  updateSubscription(
    request: UpdateSubscriptionRequest,
    callback: (error: ServiceError | null, response: UpdateSubscriptionResponse) => void,
  ): ClientUnaryCall;
  updateSubscription(
    request: UpdateSubscriptionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: UpdateSubscriptionResponse) => void,
  ): ClientUnaryCall;
  updateSubscription(
    request: UpdateSubscriptionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: UpdateSubscriptionResponse) => void,
  ): ClientUnaryCall;
  deleteSubscription(
    request: DeleteSubscriptionRequest,
    callback: (error: ServiceError | null, response: DeleteSubscriptionResponse) => void,
  ): ClientUnaryCall;
  deleteSubscription(
    request: DeleteSubscriptionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DeleteSubscriptionResponse) => void,
  ): ClientUnaryCall;
  deleteSubscription(
    request: DeleteSubscriptionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DeleteSubscriptionResponse) => void,
  ): ClientUnaryCall;
  /** Health and status */
  getServiceStatus(
    request: GetServiceStatusRequest,
    callback: (error: ServiceError | null, response: GetServiceStatusResponse) => void,
  ): ClientUnaryCall;
  getServiceStatus(
    request: GetServiceStatusRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetServiceStatusResponse) => void,
  ): ClientUnaryCall;
  getServiceStatus(
    request: GetServiceStatusRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetServiceStatusResponse) => void,
  ): ClientUnaryCall;
}

export const CDCServiceClient = makeGenericClientConstructor(
  CDCServiceService,
  "unhinged.cdc.CDCService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): CDCServiceClient;
  service: typeof CDCServiceService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000).toString();
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (globalThis.Number(t.seconds) || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToString(long: Long) {
  return long.toString();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
