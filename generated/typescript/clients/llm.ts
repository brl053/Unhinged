// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v3.21.12
// source: llm.proto

/* eslint-disable */
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  ClientReadableStream,
  type ClientUnaryCall,
  handleServerStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import _m0 from "protobufjs/minimal";
import { ChatMessage, ToolCall } from "./chat";
import {
  Filter,
  HealthCheckRequest,
  HealthCheckResponse,
  PaginationRequest,
  PaginationResponse,
  ResourceMetadata,
  StandardResponse,
  StreamChunk,
  TokenUsage,
  UsageMetrics,
} from "./common";

/** Streaming chunk types */
export enum CompletionChunkType {
  COMPLETION_CHUNK_TYPE_UNSPECIFIED = 0,
  /** COMPLETION_CHUNK_TYPE_CONTENT - Text content */
  COMPLETION_CHUNK_TYPE_CONTENT = 1,
  /** COMPLETION_CHUNK_TYPE_TOOL_CALL - Function call */
  COMPLETION_CHUNK_TYPE_TOOL_CALL = 2,
  /** COMPLETION_CHUNK_TYPE_TOOL_RESULT - Function result */
  COMPLETION_CHUNK_TYPE_TOOL_RESULT = 3,
  /** COMPLETION_CHUNK_TYPE_THINKING - Model reasoning (if supported) */
  COMPLETION_CHUNK_TYPE_THINKING = 4,
  /** COMPLETION_CHUNK_TYPE_METADATA - Additional metadata */
  COMPLETION_CHUNK_TYPE_METADATA = 5,
  UNRECOGNIZED = -1,
}

export function completionChunkTypeFromJSON(object: any): CompletionChunkType {
  switch (object) {
    case 0:
    case "COMPLETION_CHUNK_TYPE_UNSPECIFIED":
      return CompletionChunkType.COMPLETION_CHUNK_TYPE_UNSPECIFIED;
    case 1:
    case "COMPLETION_CHUNK_TYPE_CONTENT":
      return CompletionChunkType.COMPLETION_CHUNK_TYPE_CONTENT;
    case 2:
    case "COMPLETION_CHUNK_TYPE_TOOL_CALL":
      return CompletionChunkType.COMPLETION_CHUNK_TYPE_TOOL_CALL;
    case 3:
    case "COMPLETION_CHUNK_TYPE_TOOL_RESULT":
      return CompletionChunkType.COMPLETION_CHUNK_TYPE_TOOL_RESULT;
    case 4:
    case "COMPLETION_CHUNK_TYPE_THINKING":
      return CompletionChunkType.COMPLETION_CHUNK_TYPE_THINKING;
    case 5:
    case "COMPLETION_CHUNK_TYPE_METADATA":
      return CompletionChunkType.COMPLETION_CHUNK_TYPE_METADATA;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CompletionChunkType.UNRECOGNIZED;
  }
}

export function completionChunkTypeToJSON(object: CompletionChunkType): string {
  switch (object) {
    case CompletionChunkType.COMPLETION_CHUNK_TYPE_UNSPECIFIED:
      return "COMPLETION_CHUNK_TYPE_UNSPECIFIED";
    case CompletionChunkType.COMPLETION_CHUNK_TYPE_CONTENT:
      return "COMPLETION_CHUNK_TYPE_CONTENT";
    case CompletionChunkType.COMPLETION_CHUNK_TYPE_TOOL_CALL:
      return "COMPLETION_CHUNK_TYPE_TOOL_CALL";
    case CompletionChunkType.COMPLETION_CHUNK_TYPE_TOOL_RESULT:
      return "COMPLETION_CHUNK_TYPE_TOOL_RESULT";
    case CompletionChunkType.COMPLETION_CHUNK_TYPE_THINKING:
      return "COMPLETION_CHUNK_TYPE_THINKING";
    case CompletionChunkType.COMPLETION_CHUNK_TYPE_METADATA:
      return "COMPLETION_CHUNK_TYPE_METADATA";
    case CompletionChunkType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** LLM completion request with context integration */
export interface CompletionRequest {
  model: string;
  /** ← DRY! (reuse chat messages) */
  messages: ChatMessage[];
  options?:
    | CompletionOptions
    | undefined;
  /** For DocumentStore context integration */
  sessionId: string;
  /** Pull relevant documents from DocumentStore */
  includeContext: boolean;
  contextOptions?: ContextOptions | undefined;
}

/** Completion configuration options */
export interface CompletionOptions {
  maxTokens: number;
  temperature: number;
  topP: number;
  frequencyPenalty: number;
  presencePenalty: number;
  stopSequences: string[];
  /** Enable streaming response */
  stream: boolean;
  /** Include token usage in response */
  includeUsage: boolean;
  /** Number of completions to generate */
  n: number;
  /** Tool calling */
  enableTools: boolean;
  tools: ToolDefinition[];
  /** "auto", "none", or specific tool name */
  toolChoice: string;
}

/** Context integration options for DocumentStore */
export interface ContextOptions {
  /** Maximum tokens to use for context */
  maxContextTokens: number;
  /** Minimum relevance score for documents */
  relevanceThreshold: number;
  /** Filter by document types */
  documentTypes: string[];
  /** Include document metadata in context */
  includeMetadata: boolean;
}

/** Tool definition for function calling */
export interface ToolDefinition {
  name: string;
  description: string;
  /** JSON schema for parameters */
  parametersSchema: string;
  required: boolean;
}

/** LLM completion response */
export interface CompletionResponse {
  /** ← DRY! (success, error handling) */
  response?: StandardResponse | undefined;
  completionId: string;
  choices: CompletionChoice[];
  /** ← DRY! (token usage) */
  usage?: UsageMetrics | undefined;
  metadata?: CompletionMetadata | undefined;
}

/** Individual completion choice */
export interface CompletionChoice {
  index: number;
  /** ← DRY! (reuse chat message) */
  message?:
    | ChatMessage
    | undefined;
  /** "stop", "length", "tool_calls", etc. */
  finishReason: string;
  /** Log probability (if requested) */
  logprobs: number;
}

/** Completion metadata and diagnostics */
export interface CompletionMetadata {
  model: string;
  /** "openai", "anthropic", "local", etc. */
  provider: string;
  processingTimeMs: number;
  /** Number of DocumentStore docs included */
  contextDocumentsUsed: number;
  contextDocumentIds: string[];
}

/** LLM model information */
export interface Model {
  /** ← DRY! (id, timestamps, etc.) */
  metadata?: ResourceMetadata | undefined;
  name: string;
  provider: string;
  description: string;
  capabilities?: ModelCapabilities | undefined;
  pricing?: ModelPricing | undefined;
  limits?: ModelLimits | undefined;
  isAvailable: boolean;
  /** "active", "deprecated", "beta" */
  status: string;
}

/** Model capabilities and features */
export interface ModelCapabilities {
  supportsStreaming: boolean;
  supportsVision: boolean;
  supportsFunctionCalling: boolean;
  supportsJsonMode: boolean;
  supportsSystemMessages: boolean;
  supportedLanguages: string[];
  /** "text", "image", "audio" */
  inputModalities: string[];
  outputModalities: string[];
}

/** Model pricing information */
export interface ModelPricing {
  inputCostPer1kTokens: number;
  outputCostPer1kTokens: number;
  /** "USD" */
  currency: string;
  hasFreeTier: boolean;
  /** Tokens per month */
  freeTierLimit: number;
}

/** Model limits and constraints */
export interface ModelLimits {
  maxContextTokens: number;
  maxOutputTokens: number;
  maxRequestsPerMinute: number;
  maxTokensPerMinute: number;
}

/**
 * Streaming completion chunk payload
 * Used with common.v1.StreamChunk.structured field
 */
export interface CompletionChunkPayload {
  completionId: string;
  choiceIndex: number;
  type: CompletionChunkType;
  content: string;
  /** ← DRY! (reuse from chat) */
  toolCalls: ToolCall[];
  finishReason: string;
  /** ← DRY! (only in final chunk) */
  usage?: UsageMetrics | undefined;
}

export interface ListModelsRequest {
  /** Filter by provider */
  provider: string;
  /** Only show available models */
  availableOnly: boolean;
  /** ← DRY! */
  pagination?:
    | PaginationRequest
    | undefined;
  /** ← DRY! */
  filters: Filter[];
}

export interface ListModelsResponse {
  /** ← DRY! */
  response?: StandardResponse | undefined;
  models: Model[];
  /** ← DRY! */
  pagination?: PaginationResponse | undefined;
}

export interface GetModelRequest {
  modelId: string;
  includePricing: boolean;
  includeCapabilities: boolean;
}

export interface GetModelResponse {
  /** ← DRY! */
  response?: StandardResponse | undefined;
  model?: Model | undefined;
}

export interface TokenEstimationRequest {
  model: string;
  text?:
    | string
    | undefined;
  /** ← DRY! */
  messages?:
    | ChatMessageList
    | undefined;
  /** Estimate with DocumentStore context */
  includeContext: boolean;
  /** For context estimation */
  sessionId: string;
}

/** Helper message for repeated chat messages in oneof */
export interface ChatMessageList {
  messages: ChatMessage[];
}

export interface TokenEstimationResponse {
  /** ← DRY! */
  response?:
    | StandardResponse
    | undefined;
  /** ← DRY! */
  usage?: TokenUsage | undefined;
  breakdown?: TokenBreakdown | undefined;
}

/** Detailed token count breakdown */
export interface TokenBreakdown {
  systemTokens: number;
  userTokens: number;
  assistantTokens: number;
  /** From DocumentStore */
  contextTokens: number;
  /** Function definitions */
  toolTokens: number;
  contextDocuments: DocumentTokens[];
}

/** Token count per context document */
export interface DocumentTokens {
  documentId: string;
  documentType: string;
  tokenCount: number;
  relevanceScore: number;
}

export interface TokenCountRequest {
  model: string;
  text: string;
}

export interface TokenCountResponse {
  /** ← DRY! */
  response?: StandardResponse | undefined;
  tokenCount: number;
  /** Detailed token information (optional) */
  tokens: TokenInfo[];
}

/** Individual token information for debugging */
export interface TokenInfo {
  token: string;
  tokenId: number;
  probability: number;
}

function createBaseCompletionRequest(): CompletionRequest {
  return {
    model: "",
    messages: [],
    options: undefined,
    sessionId: "",
    includeContext: false,
    contextOptions: undefined,
  };
}

export const CompletionRequest = {
  encode(message: CompletionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.model !== "") {
      writer.uint32(10).string(message.model);
    }
    for (const v of message.messages) {
      ChatMessage.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.options !== undefined) {
      CompletionOptions.encode(message.options, writer.uint32(26).fork()).ldelim();
    }
    if (message.sessionId !== "") {
      writer.uint32(34).string(message.sessionId);
    }
    if (message.includeContext !== false) {
      writer.uint32(40).bool(message.includeContext);
    }
    if (message.contextOptions !== undefined) {
      ContextOptions.encode(message.contextOptions, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CompletionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompletionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.model = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.messages.push(ChatMessage.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.options = CompletionOptions.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.includeContext = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.contextOptions = ContextOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CompletionRequest {
    return {
      model: isSet(object.model) ? globalThis.String(object.model) : "",
      messages: globalThis.Array.isArray(object?.messages)
        ? object.messages.map((e: any) => ChatMessage.fromJSON(e))
        : [],
      options: isSet(object.options) ? CompletionOptions.fromJSON(object.options) : undefined,
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      includeContext: isSet(object.includeContext) ? globalThis.Boolean(object.includeContext) : false,
      contextOptions: isSet(object.contextOptions) ? ContextOptions.fromJSON(object.contextOptions) : undefined,
    };
  },

  toJSON(message: CompletionRequest): unknown {
    const obj: any = {};
    if (message.model !== "") {
      obj.model = message.model;
    }
    if (message.messages?.length) {
      obj.messages = message.messages.map((e) => ChatMessage.toJSON(e));
    }
    if (message.options !== undefined) {
      obj.options = CompletionOptions.toJSON(message.options);
    }
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.includeContext !== false) {
      obj.includeContext = message.includeContext;
    }
    if (message.contextOptions !== undefined) {
      obj.contextOptions = ContextOptions.toJSON(message.contextOptions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CompletionRequest>, I>>(base?: I): CompletionRequest {
    return CompletionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CompletionRequest>, I>>(object: I): CompletionRequest {
    const message = createBaseCompletionRequest();
    message.model = object.model ?? "";
    message.messages = object.messages?.map((e) => ChatMessage.fromPartial(e)) || [];
    message.options = (object.options !== undefined && object.options !== null)
      ? CompletionOptions.fromPartial(object.options)
      : undefined;
    message.sessionId = object.sessionId ?? "";
    message.includeContext = object.includeContext ?? false;
    message.contextOptions = (object.contextOptions !== undefined && object.contextOptions !== null)
      ? ContextOptions.fromPartial(object.contextOptions)
      : undefined;
    return message;
  },
};

function createBaseCompletionOptions(): CompletionOptions {
  return {
    maxTokens: 0,
    temperature: 0,
    topP: 0,
    frequencyPenalty: 0,
    presencePenalty: 0,
    stopSequences: [],
    stream: false,
    includeUsage: false,
    n: 0,
    enableTools: false,
    tools: [],
    toolChoice: "",
  };
}

export const CompletionOptions = {
  encode(message: CompletionOptions, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.maxTokens !== 0) {
      writer.uint32(8).int32(message.maxTokens);
    }
    if (message.temperature !== 0) {
      writer.uint32(21).float(message.temperature);
    }
    if (message.topP !== 0) {
      writer.uint32(29).float(message.topP);
    }
    if (message.frequencyPenalty !== 0) {
      writer.uint32(37).float(message.frequencyPenalty);
    }
    if (message.presencePenalty !== 0) {
      writer.uint32(45).float(message.presencePenalty);
    }
    for (const v of message.stopSequences) {
      writer.uint32(50).string(v!);
    }
    if (message.stream !== false) {
      writer.uint32(56).bool(message.stream);
    }
    if (message.includeUsage !== false) {
      writer.uint32(64).bool(message.includeUsage);
    }
    if (message.n !== 0) {
      writer.uint32(72).int32(message.n);
    }
    if (message.enableTools !== false) {
      writer.uint32(80).bool(message.enableTools);
    }
    for (const v of message.tools) {
      ToolDefinition.encode(v!, writer.uint32(90).fork()).ldelim();
    }
    if (message.toolChoice !== "") {
      writer.uint32(98).string(message.toolChoice);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CompletionOptions {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompletionOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.maxTokens = reader.int32();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.temperature = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.topP = reader.float();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.frequencyPenalty = reader.float();
          continue;
        case 5:
          if (tag !== 45) {
            break;
          }

          message.presencePenalty = reader.float();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.stopSequences.push(reader.string());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.stream = reader.bool();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.includeUsage = reader.bool();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.n = reader.int32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.enableTools = reader.bool();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.tools.push(ToolDefinition.decode(reader, reader.uint32()));
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.toolChoice = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CompletionOptions {
    return {
      maxTokens: isSet(object.maxTokens) ? globalThis.Number(object.maxTokens) : 0,
      temperature: isSet(object.temperature) ? globalThis.Number(object.temperature) : 0,
      topP: isSet(object.topP) ? globalThis.Number(object.topP) : 0,
      frequencyPenalty: isSet(object.frequencyPenalty) ? globalThis.Number(object.frequencyPenalty) : 0,
      presencePenalty: isSet(object.presencePenalty) ? globalThis.Number(object.presencePenalty) : 0,
      stopSequences: globalThis.Array.isArray(object?.stopSequences)
        ? object.stopSequences.map((e: any) => globalThis.String(e))
        : [],
      stream: isSet(object.stream) ? globalThis.Boolean(object.stream) : false,
      includeUsage: isSet(object.includeUsage) ? globalThis.Boolean(object.includeUsage) : false,
      n: isSet(object.n) ? globalThis.Number(object.n) : 0,
      enableTools: isSet(object.enableTools) ? globalThis.Boolean(object.enableTools) : false,
      tools: globalThis.Array.isArray(object?.tools) ? object.tools.map((e: any) => ToolDefinition.fromJSON(e)) : [],
      toolChoice: isSet(object.toolChoice) ? globalThis.String(object.toolChoice) : "",
    };
  },

  toJSON(message: CompletionOptions): unknown {
    const obj: any = {};
    if (message.maxTokens !== 0) {
      obj.maxTokens = Math.round(message.maxTokens);
    }
    if (message.temperature !== 0) {
      obj.temperature = message.temperature;
    }
    if (message.topP !== 0) {
      obj.topP = message.topP;
    }
    if (message.frequencyPenalty !== 0) {
      obj.frequencyPenalty = message.frequencyPenalty;
    }
    if (message.presencePenalty !== 0) {
      obj.presencePenalty = message.presencePenalty;
    }
    if (message.stopSequences?.length) {
      obj.stopSequences = message.stopSequences;
    }
    if (message.stream !== false) {
      obj.stream = message.stream;
    }
    if (message.includeUsage !== false) {
      obj.includeUsage = message.includeUsage;
    }
    if (message.n !== 0) {
      obj.n = Math.round(message.n);
    }
    if (message.enableTools !== false) {
      obj.enableTools = message.enableTools;
    }
    if (message.tools?.length) {
      obj.tools = message.tools.map((e) => ToolDefinition.toJSON(e));
    }
    if (message.toolChoice !== "") {
      obj.toolChoice = message.toolChoice;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CompletionOptions>, I>>(base?: I): CompletionOptions {
    return CompletionOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CompletionOptions>, I>>(object: I): CompletionOptions {
    const message = createBaseCompletionOptions();
    message.maxTokens = object.maxTokens ?? 0;
    message.temperature = object.temperature ?? 0;
    message.topP = object.topP ?? 0;
    message.frequencyPenalty = object.frequencyPenalty ?? 0;
    message.presencePenalty = object.presencePenalty ?? 0;
    message.stopSequences = object.stopSequences?.map((e) => e) || [];
    message.stream = object.stream ?? false;
    message.includeUsage = object.includeUsage ?? false;
    message.n = object.n ?? 0;
    message.enableTools = object.enableTools ?? false;
    message.tools = object.tools?.map((e) => ToolDefinition.fromPartial(e)) || [];
    message.toolChoice = object.toolChoice ?? "";
    return message;
  },
};

function createBaseContextOptions(): ContextOptions {
  return { maxContextTokens: 0, relevanceThreshold: 0, documentTypes: [], includeMetadata: false };
}

export const ContextOptions = {
  encode(message: ContextOptions, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.maxContextTokens !== 0) {
      writer.uint32(8).int32(message.maxContextTokens);
    }
    if (message.relevanceThreshold !== 0) {
      writer.uint32(21).float(message.relevanceThreshold);
    }
    for (const v of message.documentTypes) {
      writer.uint32(26).string(v!);
    }
    if (message.includeMetadata !== false) {
      writer.uint32(32).bool(message.includeMetadata);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ContextOptions {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContextOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.maxContextTokens = reader.int32();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.relevanceThreshold = reader.float();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.documentTypes.push(reader.string());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.includeMetadata = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContextOptions {
    return {
      maxContextTokens: isSet(object.maxContextTokens) ? globalThis.Number(object.maxContextTokens) : 0,
      relevanceThreshold: isSet(object.relevanceThreshold) ? globalThis.Number(object.relevanceThreshold) : 0,
      documentTypes: globalThis.Array.isArray(object?.documentTypes)
        ? object.documentTypes.map((e: any) => globalThis.String(e))
        : [],
      includeMetadata: isSet(object.includeMetadata) ? globalThis.Boolean(object.includeMetadata) : false,
    };
  },

  toJSON(message: ContextOptions): unknown {
    const obj: any = {};
    if (message.maxContextTokens !== 0) {
      obj.maxContextTokens = Math.round(message.maxContextTokens);
    }
    if (message.relevanceThreshold !== 0) {
      obj.relevanceThreshold = message.relevanceThreshold;
    }
    if (message.documentTypes?.length) {
      obj.documentTypes = message.documentTypes;
    }
    if (message.includeMetadata !== false) {
      obj.includeMetadata = message.includeMetadata;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ContextOptions>, I>>(base?: I): ContextOptions {
    return ContextOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ContextOptions>, I>>(object: I): ContextOptions {
    const message = createBaseContextOptions();
    message.maxContextTokens = object.maxContextTokens ?? 0;
    message.relevanceThreshold = object.relevanceThreshold ?? 0;
    message.documentTypes = object.documentTypes?.map((e) => e) || [];
    message.includeMetadata = object.includeMetadata ?? false;
    return message;
  },
};

function createBaseToolDefinition(): ToolDefinition {
  return { name: "", description: "", parametersSchema: "", required: false };
}

export const ToolDefinition = {
  encode(message: ToolDefinition, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.parametersSchema !== "") {
      writer.uint32(26).string(message.parametersSchema);
    }
    if (message.required !== false) {
      writer.uint32(32).bool(message.required);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ToolDefinition {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToolDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.parametersSchema = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.required = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ToolDefinition {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      parametersSchema: isSet(object.parametersSchema) ? globalThis.String(object.parametersSchema) : "",
      required: isSet(object.required) ? globalThis.Boolean(object.required) : false,
    };
  },

  toJSON(message: ToolDefinition): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.parametersSchema !== "") {
      obj.parametersSchema = message.parametersSchema;
    }
    if (message.required !== false) {
      obj.required = message.required;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ToolDefinition>, I>>(base?: I): ToolDefinition {
    return ToolDefinition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ToolDefinition>, I>>(object: I): ToolDefinition {
    const message = createBaseToolDefinition();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.parametersSchema = object.parametersSchema ?? "";
    message.required = object.required ?? false;
    return message;
  },
};

function createBaseCompletionResponse(): CompletionResponse {
  return { response: undefined, completionId: "", choices: [], usage: undefined, metadata: undefined };
}

export const CompletionResponse = {
  encode(message: CompletionResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.response !== undefined) {
      StandardResponse.encode(message.response, writer.uint32(10).fork()).ldelim();
    }
    if (message.completionId !== "") {
      writer.uint32(18).string(message.completionId);
    }
    for (const v of message.choices) {
      CompletionChoice.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.usage !== undefined) {
      UsageMetrics.encode(message.usage, writer.uint32(34).fork()).ldelim();
    }
    if (message.metadata !== undefined) {
      CompletionMetadata.encode(message.metadata, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CompletionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompletionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.response = StandardResponse.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.completionId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.choices.push(CompletionChoice.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.usage = UsageMetrics.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.metadata = CompletionMetadata.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CompletionResponse {
    return {
      response: isSet(object.response) ? StandardResponse.fromJSON(object.response) : undefined,
      completionId: isSet(object.completionId) ? globalThis.String(object.completionId) : "",
      choices: globalThis.Array.isArray(object?.choices)
        ? object.choices.map((e: any) => CompletionChoice.fromJSON(e))
        : [],
      usage: isSet(object.usage) ? UsageMetrics.fromJSON(object.usage) : undefined,
      metadata: isSet(object.metadata) ? CompletionMetadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: CompletionResponse): unknown {
    const obj: any = {};
    if (message.response !== undefined) {
      obj.response = StandardResponse.toJSON(message.response);
    }
    if (message.completionId !== "") {
      obj.completionId = message.completionId;
    }
    if (message.choices?.length) {
      obj.choices = message.choices.map((e) => CompletionChoice.toJSON(e));
    }
    if (message.usage !== undefined) {
      obj.usage = UsageMetrics.toJSON(message.usage);
    }
    if (message.metadata !== undefined) {
      obj.metadata = CompletionMetadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CompletionResponse>, I>>(base?: I): CompletionResponse {
    return CompletionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CompletionResponse>, I>>(object: I): CompletionResponse {
    const message = createBaseCompletionResponse();
    message.response = (object.response !== undefined && object.response !== null)
      ? StandardResponse.fromPartial(object.response)
      : undefined;
    message.completionId = object.completionId ?? "";
    message.choices = object.choices?.map((e) => CompletionChoice.fromPartial(e)) || [];
    message.usage = (object.usage !== undefined && object.usage !== null)
      ? UsageMetrics.fromPartial(object.usage)
      : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? CompletionMetadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseCompletionChoice(): CompletionChoice {
  return { index: 0, message: undefined, finishReason: "", logprobs: 0 };
}

export const CompletionChoice = {
  encode(message: CompletionChoice, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.index !== 0) {
      writer.uint32(8).int32(message.index);
    }
    if (message.message !== undefined) {
      ChatMessage.encode(message.message, writer.uint32(18).fork()).ldelim();
    }
    if (message.finishReason !== "") {
      writer.uint32(26).string(message.finishReason);
    }
    if (message.logprobs !== 0) {
      writer.uint32(37).float(message.logprobs);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CompletionChoice {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompletionChoice();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.index = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = ChatMessage.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.finishReason = reader.string();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.logprobs = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CompletionChoice {
    return {
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      message: isSet(object.message) ? ChatMessage.fromJSON(object.message) : undefined,
      finishReason: isSet(object.finishReason) ? globalThis.String(object.finishReason) : "",
      logprobs: isSet(object.logprobs) ? globalThis.Number(object.logprobs) : 0,
    };
  },

  toJSON(message: CompletionChoice): unknown {
    const obj: any = {};
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.message !== undefined) {
      obj.message = ChatMessage.toJSON(message.message);
    }
    if (message.finishReason !== "") {
      obj.finishReason = message.finishReason;
    }
    if (message.logprobs !== 0) {
      obj.logprobs = message.logprobs;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CompletionChoice>, I>>(base?: I): CompletionChoice {
    return CompletionChoice.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CompletionChoice>, I>>(object: I): CompletionChoice {
    const message = createBaseCompletionChoice();
    message.index = object.index ?? 0;
    message.message = (object.message !== undefined && object.message !== null)
      ? ChatMessage.fromPartial(object.message)
      : undefined;
    message.finishReason = object.finishReason ?? "";
    message.logprobs = object.logprobs ?? 0;
    return message;
  },
};

function createBaseCompletionMetadata(): CompletionMetadata {
  return { model: "", provider: "", processingTimeMs: 0, contextDocumentsUsed: 0, contextDocumentIds: [] };
}

export const CompletionMetadata = {
  encode(message: CompletionMetadata, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.model !== "") {
      writer.uint32(10).string(message.model);
    }
    if (message.provider !== "") {
      writer.uint32(18).string(message.provider);
    }
    if (message.processingTimeMs !== 0) {
      writer.uint32(29).float(message.processingTimeMs);
    }
    if (message.contextDocumentsUsed !== 0) {
      writer.uint32(32).int32(message.contextDocumentsUsed);
    }
    for (const v of message.contextDocumentIds) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CompletionMetadata {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompletionMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.model = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.provider = reader.string();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.processingTimeMs = reader.float();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.contextDocumentsUsed = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.contextDocumentIds.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CompletionMetadata {
    return {
      model: isSet(object.model) ? globalThis.String(object.model) : "",
      provider: isSet(object.provider) ? globalThis.String(object.provider) : "",
      processingTimeMs: isSet(object.processingTimeMs) ? globalThis.Number(object.processingTimeMs) : 0,
      contextDocumentsUsed: isSet(object.contextDocumentsUsed) ? globalThis.Number(object.contextDocumentsUsed) : 0,
      contextDocumentIds: globalThis.Array.isArray(object?.contextDocumentIds)
        ? object.contextDocumentIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: CompletionMetadata): unknown {
    const obj: any = {};
    if (message.model !== "") {
      obj.model = message.model;
    }
    if (message.provider !== "") {
      obj.provider = message.provider;
    }
    if (message.processingTimeMs !== 0) {
      obj.processingTimeMs = message.processingTimeMs;
    }
    if (message.contextDocumentsUsed !== 0) {
      obj.contextDocumentsUsed = Math.round(message.contextDocumentsUsed);
    }
    if (message.contextDocumentIds?.length) {
      obj.contextDocumentIds = message.contextDocumentIds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CompletionMetadata>, I>>(base?: I): CompletionMetadata {
    return CompletionMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CompletionMetadata>, I>>(object: I): CompletionMetadata {
    const message = createBaseCompletionMetadata();
    message.model = object.model ?? "";
    message.provider = object.provider ?? "";
    message.processingTimeMs = object.processingTimeMs ?? 0;
    message.contextDocumentsUsed = object.contextDocumentsUsed ?? 0;
    message.contextDocumentIds = object.contextDocumentIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseModel(): Model {
  return {
    metadata: undefined,
    name: "",
    provider: "",
    description: "",
    capabilities: undefined,
    pricing: undefined,
    limits: undefined,
    isAvailable: false,
    status: "",
  };
}

export const Model = {
  encode(message: Model, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.metadata !== undefined) {
      ResourceMetadata.encode(message.metadata, writer.uint32(10).fork()).ldelim();
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.provider !== "") {
      writer.uint32(26).string(message.provider);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.capabilities !== undefined) {
      ModelCapabilities.encode(message.capabilities, writer.uint32(42).fork()).ldelim();
    }
    if (message.pricing !== undefined) {
      ModelPricing.encode(message.pricing, writer.uint32(50).fork()).ldelim();
    }
    if (message.limits !== undefined) {
      ModelLimits.encode(message.limits, writer.uint32(58).fork()).ldelim();
    }
    if (message.isAvailable !== false) {
      writer.uint32(64).bool(message.isAvailable);
    }
    if (message.status !== "") {
      writer.uint32(74).string(message.status);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Model {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metadata = ResourceMetadata.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.provider = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.capabilities = ModelCapabilities.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.pricing = ModelPricing.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.limits = ModelLimits.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.isAvailable = reader.bool();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.status = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Model {
    return {
      metadata: isSet(object.metadata) ? ResourceMetadata.fromJSON(object.metadata) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      provider: isSet(object.provider) ? globalThis.String(object.provider) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      capabilities: isSet(object.capabilities) ? ModelCapabilities.fromJSON(object.capabilities) : undefined,
      pricing: isSet(object.pricing) ? ModelPricing.fromJSON(object.pricing) : undefined,
      limits: isSet(object.limits) ? ModelLimits.fromJSON(object.limits) : undefined,
      isAvailable: isSet(object.isAvailable) ? globalThis.Boolean(object.isAvailable) : false,
      status: isSet(object.status) ? globalThis.String(object.status) : "",
    };
  },

  toJSON(message: Model): unknown {
    const obj: any = {};
    if (message.metadata !== undefined) {
      obj.metadata = ResourceMetadata.toJSON(message.metadata);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.provider !== "") {
      obj.provider = message.provider;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.capabilities !== undefined) {
      obj.capabilities = ModelCapabilities.toJSON(message.capabilities);
    }
    if (message.pricing !== undefined) {
      obj.pricing = ModelPricing.toJSON(message.pricing);
    }
    if (message.limits !== undefined) {
      obj.limits = ModelLimits.toJSON(message.limits);
    }
    if (message.isAvailable !== false) {
      obj.isAvailable = message.isAvailable;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Model>, I>>(base?: I): Model {
    return Model.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Model>, I>>(object: I): Model {
    const message = createBaseModel();
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? ResourceMetadata.fromPartial(object.metadata)
      : undefined;
    message.name = object.name ?? "";
    message.provider = object.provider ?? "";
    message.description = object.description ?? "";
    message.capabilities = (object.capabilities !== undefined && object.capabilities !== null)
      ? ModelCapabilities.fromPartial(object.capabilities)
      : undefined;
    message.pricing = (object.pricing !== undefined && object.pricing !== null)
      ? ModelPricing.fromPartial(object.pricing)
      : undefined;
    message.limits = (object.limits !== undefined && object.limits !== null)
      ? ModelLimits.fromPartial(object.limits)
      : undefined;
    message.isAvailable = object.isAvailable ?? false;
    message.status = object.status ?? "";
    return message;
  },
};

function createBaseModelCapabilities(): ModelCapabilities {
  return {
    supportsStreaming: false,
    supportsVision: false,
    supportsFunctionCalling: false,
    supportsJsonMode: false,
    supportsSystemMessages: false,
    supportedLanguages: [],
    inputModalities: [],
    outputModalities: [],
  };
}

export const ModelCapabilities = {
  encode(message: ModelCapabilities, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.supportsStreaming !== false) {
      writer.uint32(8).bool(message.supportsStreaming);
    }
    if (message.supportsVision !== false) {
      writer.uint32(16).bool(message.supportsVision);
    }
    if (message.supportsFunctionCalling !== false) {
      writer.uint32(24).bool(message.supportsFunctionCalling);
    }
    if (message.supportsJsonMode !== false) {
      writer.uint32(32).bool(message.supportsJsonMode);
    }
    if (message.supportsSystemMessages !== false) {
      writer.uint32(40).bool(message.supportsSystemMessages);
    }
    for (const v of message.supportedLanguages) {
      writer.uint32(50).string(v!);
    }
    for (const v of message.inputModalities) {
      writer.uint32(58).string(v!);
    }
    for (const v of message.outputModalities) {
      writer.uint32(66).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ModelCapabilities {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelCapabilities();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.supportsStreaming = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.supportsVision = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.supportsFunctionCalling = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.supportsJsonMode = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.supportsSystemMessages = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.supportedLanguages.push(reader.string());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.inputModalities.push(reader.string());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.outputModalities.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelCapabilities {
    return {
      supportsStreaming: isSet(object.supportsStreaming) ? globalThis.Boolean(object.supportsStreaming) : false,
      supportsVision: isSet(object.supportsVision) ? globalThis.Boolean(object.supportsVision) : false,
      supportsFunctionCalling: isSet(object.supportsFunctionCalling)
        ? globalThis.Boolean(object.supportsFunctionCalling)
        : false,
      supportsJsonMode: isSet(object.supportsJsonMode) ? globalThis.Boolean(object.supportsJsonMode) : false,
      supportsSystemMessages: isSet(object.supportsSystemMessages)
        ? globalThis.Boolean(object.supportsSystemMessages)
        : false,
      supportedLanguages: globalThis.Array.isArray(object?.supportedLanguages)
        ? object.supportedLanguages.map((e: any) => globalThis.String(e))
        : [],
      inputModalities: globalThis.Array.isArray(object?.inputModalities)
        ? object.inputModalities.map((e: any) => globalThis.String(e))
        : [],
      outputModalities: globalThis.Array.isArray(object?.outputModalities)
        ? object.outputModalities.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ModelCapabilities): unknown {
    const obj: any = {};
    if (message.supportsStreaming !== false) {
      obj.supportsStreaming = message.supportsStreaming;
    }
    if (message.supportsVision !== false) {
      obj.supportsVision = message.supportsVision;
    }
    if (message.supportsFunctionCalling !== false) {
      obj.supportsFunctionCalling = message.supportsFunctionCalling;
    }
    if (message.supportsJsonMode !== false) {
      obj.supportsJsonMode = message.supportsJsonMode;
    }
    if (message.supportsSystemMessages !== false) {
      obj.supportsSystemMessages = message.supportsSystemMessages;
    }
    if (message.supportedLanguages?.length) {
      obj.supportedLanguages = message.supportedLanguages;
    }
    if (message.inputModalities?.length) {
      obj.inputModalities = message.inputModalities;
    }
    if (message.outputModalities?.length) {
      obj.outputModalities = message.outputModalities;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ModelCapabilities>, I>>(base?: I): ModelCapabilities {
    return ModelCapabilities.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ModelCapabilities>, I>>(object: I): ModelCapabilities {
    const message = createBaseModelCapabilities();
    message.supportsStreaming = object.supportsStreaming ?? false;
    message.supportsVision = object.supportsVision ?? false;
    message.supportsFunctionCalling = object.supportsFunctionCalling ?? false;
    message.supportsJsonMode = object.supportsJsonMode ?? false;
    message.supportsSystemMessages = object.supportsSystemMessages ?? false;
    message.supportedLanguages = object.supportedLanguages?.map((e) => e) || [];
    message.inputModalities = object.inputModalities?.map((e) => e) || [];
    message.outputModalities = object.outputModalities?.map((e) => e) || [];
    return message;
  },
};

function createBaseModelPricing(): ModelPricing {
  return { inputCostPer1kTokens: 0, outputCostPer1kTokens: 0, currency: "", hasFreeTier: false, freeTierLimit: 0 };
}

export const ModelPricing = {
  encode(message: ModelPricing, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.inputCostPer1kTokens !== 0) {
      writer.uint32(13).float(message.inputCostPer1kTokens);
    }
    if (message.outputCostPer1kTokens !== 0) {
      writer.uint32(21).float(message.outputCostPer1kTokens);
    }
    if (message.currency !== "") {
      writer.uint32(26).string(message.currency);
    }
    if (message.hasFreeTier !== false) {
      writer.uint32(32).bool(message.hasFreeTier);
    }
    if (message.freeTierLimit !== 0) {
      writer.uint32(40).int32(message.freeTierLimit);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ModelPricing {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelPricing();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.inputCostPer1kTokens = reader.float();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.outputCostPer1kTokens = reader.float();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.currency = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.hasFreeTier = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.freeTierLimit = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelPricing {
    return {
      inputCostPer1kTokens: isSet(object.inputCostPer1kTokens) ? globalThis.Number(object.inputCostPer1kTokens) : 0,
      outputCostPer1kTokens: isSet(object.outputCostPer1kTokens) ? globalThis.Number(object.outputCostPer1kTokens) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      hasFreeTier: isSet(object.hasFreeTier) ? globalThis.Boolean(object.hasFreeTier) : false,
      freeTierLimit: isSet(object.freeTierLimit) ? globalThis.Number(object.freeTierLimit) : 0,
    };
  },

  toJSON(message: ModelPricing): unknown {
    const obj: any = {};
    if (message.inputCostPer1kTokens !== 0) {
      obj.inputCostPer1kTokens = message.inputCostPer1kTokens;
    }
    if (message.outputCostPer1kTokens !== 0) {
      obj.outputCostPer1kTokens = message.outputCostPer1kTokens;
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.hasFreeTier !== false) {
      obj.hasFreeTier = message.hasFreeTier;
    }
    if (message.freeTierLimit !== 0) {
      obj.freeTierLimit = Math.round(message.freeTierLimit);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ModelPricing>, I>>(base?: I): ModelPricing {
    return ModelPricing.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ModelPricing>, I>>(object: I): ModelPricing {
    const message = createBaseModelPricing();
    message.inputCostPer1kTokens = object.inputCostPer1kTokens ?? 0;
    message.outputCostPer1kTokens = object.outputCostPer1kTokens ?? 0;
    message.currency = object.currency ?? "";
    message.hasFreeTier = object.hasFreeTier ?? false;
    message.freeTierLimit = object.freeTierLimit ?? 0;
    return message;
  },
};

function createBaseModelLimits(): ModelLimits {
  return { maxContextTokens: 0, maxOutputTokens: 0, maxRequestsPerMinute: 0, maxTokensPerMinute: 0 };
}

export const ModelLimits = {
  encode(message: ModelLimits, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.maxContextTokens !== 0) {
      writer.uint32(8).int32(message.maxContextTokens);
    }
    if (message.maxOutputTokens !== 0) {
      writer.uint32(16).int32(message.maxOutputTokens);
    }
    if (message.maxRequestsPerMinute !== 0) {
      writer.uint32(24).int32(message.maxRequestsPerMinute);
    }
    if (message.maxTokensPerMinute !== 0) {
      writer.uint32(32).int32(message.maxTokensPerMinute);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ModelLimits {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelLimits();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.maxContextTokens = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.maxOutputTokens = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.maxRequestsPerMinute = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.maxTokensPerMinute = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelLimits {
    return {
      maxContextTokens: isSet(object.maxContextTokens) ? globalThis.Number(object.maxContextTokens) : 0,
      maxOutputTokens: isSet(object.maxOutputTokens) ? globalThis.Number(object.maxOutputTokens) : 0,
      maxRequestsPerMinute: isSet(object.maxRequestsPerMinute) ? globalThis.Number(object.maxRequestsPerMinute) : 0,
      maxTokensPerMinute: isSet(object.maxTokensPerMinute) ? globalThis.Number(object.maxTokensPerMinute) : 0,
    };
  },

  toJSON(message: ModelLimits): unknown {
    const obj: any = {};
    if (message.maxContextTokens !== 0) {
      obj.maxContextTokens = Math.round(message.maxContextTokens);
    }
    if (message.maxOutputTokens !== 0) {
      obj.maxOutputTokens = Math.round(message.maxOutputTokens);
    }
    if (message.maxRequestsPerMinute !== 0) {
      obj.maxRequestsPerMinute = Math.round(message.maxRequestsPerMinute);
    }
    if (message.maxTokensPerMinute !== 0) {
      obj.maxTokensPerMinute = Math.round(message.maxTokensPerMinute);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ModelLimits>, I>>(base?: I): ModelLimits {
    return ModelLimits.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ModelLimits>, I>>(object: I): ModelLimits {
    const message = createBaseModelLimits();
    message.maxContextTokens = object.maxContextTokens ?? 0;
    message.maxOutputTokens = object.maxOutputTokens ?? 0;
    message.maxRequestsPerMinute = object.maxRequestsPerMinute ?? 0;
    message.maxTokensPerMinute = object.maxTokensPerMinute ?? 0;
    return message;
  },
};

function createBaseCompletionChunkPayload(): CompletionChunkPayload {
  return { completionId: "", choiceIndex: 0, type: 0, content: "", toolCalls: [], finishReason: "", usage: undefined };
}

export const CompletionChunkPayload = {
  encode(message: CompletionChunkPayload, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.completionId !== "") {
      writer.uint32(10).string(message.completionId);
    }
    if (message.choiceIndex !== 0) {
      writer.uint32(16).int32(message.choiceIndex);
    }
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    if (message.content !== "") {
      writer.uint32(34).string(message.content);
    }
    for (const v of message.toolCalls) {
      ToolCall.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    if (message.finishReason !== "") {
      writer.uint32(50).string(message.finishReason);
    }
    if (message.usage !== undefined) {
      UsageMetrics.encode(message.usage, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CompletionChunkPayload {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompletionChunkPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.completionId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.choiceIndex = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.content = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.toolCalls.push(ToolCall.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.finishReason = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.usage = UsageMetrics.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CompletionChunkPayload {
    return {
      completionId: isSet(object.completionId) ? globalThis.String(object.completionId) : "",
      choiceIndex: isSet(object.choiceIndex) ? globalThis.Number(object.choiceIndex) : 0,
      type: isSet(object.type) ? completionChunkTypeFromJSON(object.type) : 0,
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      toolCalls: globalThis.Array.isArray(object?.toolCalls)
        ? object.toolCalls.map((e: any) => ToolCall.fromJSON(e))
        : [],
      finishReason: isSet(object.finishReason) ? globalThis.String(object.finishReason) : "",
      usage: isSet(object.usage) ? UsageMetrics.fromJSON(object.usage) : undefined,
    };
  },

  toJSON(message: CompletionChunkPayload): unknown {
    const obj: any = {};
    if (message.completionId !== "") {
      obj.completionId = message.completionId;
    }
    if (message.choiceIndex !== 0) {
      obj.choiceIndex = Math.round(message.choiceIndex);
    }
    if (message.type !== 0) {
      obj.type = completionChunkTypeToJSON(message.type);
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.toolCalls?.length) {
      obj.toolCalls = message.toolCalls.map((e) => ToolCall.toJSON(e));
    }
    if (message.finishReason !== "") {
      obj.finishReason = message.finishReason;
    }
    if (message.usage !== undefined) {
      obj.usage = UsageMetrics.toJSON(message.usage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CompletionChunkPayload>, I>>(base?: I): CompletionChunkPayload {
    return CompletionChunkPayload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CompletionChunkPayload>, I>>(object: I): CompletionChunkPayload {
    const message = createBaseCompletionChunkPayload();
    message.completionId = object.completionId ?? "";
    message.choiceIndex = object.choiceIndex ?? 0;
    message.type = object.type ?? 0;
    message.content = object.content ?? "";
    message.toolCalls = object.toolCalls?.map((e) => ToolCall.fromPartial(e)) || [];
    message.finishReason = object.finishReason ?? "";
    message.usage = (object.usage !== undefined && object.usage !== null)
      ? UsageMetrics.fromPartial(object.usage)
      : undefined;
    return message;
  },
};

function createBaseListModelsRequest(): ListModelsRequest {
  return { provider: "", availableOnly: false, pagination: undefined, filters: [] };
}

export const ListModelsRequest = {
  encode(message: ListModelsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.provider !== "") {
      writer.uint32(10).string(message.provider);
    }
    if (message.availableOnly !== false) {
      writer.uint32(16).bool(message.availableOnly);
    }
    if (message.pagination !== undefined) {
      PaginationRequest.encode(message.pagination, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.filters) {
      Filter.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListModelsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListModelsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.provider = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.availableOnly = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pagination = PaginationRequest.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filters.push(Filter.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListModelsRequest {
    return {
      provider: isSet(object.provider) ? globalThis.String(object.provider) : "",
      availableOnly: isSet(object.availableOnly) ? globalThis.Boolean(object.availableOnly) : false,
      pagination: isSet(object.pagination) ? PaginationRequest.fromJSON(object.pagination) : undefined,
      filters: globalThis.Array.isArray(object?.filters) ? object.filters.map((e: any) => Filter.fromJSON(e)) : [],
    };
  },

  toJSON(message: ListModelsRequest): unknown {
    const obj: any = {};
    if (message.provider !== "") {
      obj.provider = message.provider;
    }
    if (message.availableOnly !== false) {
      obj.availableOnly = message.availableOnly;
    }
    if (message.pagination !== undefined) {
      obj.pagination = PaginationRequest.toJSON(message.pagination);
    }
    if (message.filters?.length) {
      obj.filters = message.filters.map((e) => Filter.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListModelsRequest>, I>>(base?: I): ListModelsRequest {
    return ListModelsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListModelsRequest>, I>>(object: I): ListModelsRequest {
    const message = createBaseListModelsRequest();
    message.provider = object.provider ?? "";
    message.availableOnly = object.availableOnly ?? false;
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PaginationRequest.fromPartial(object.pagination)
      : undefined;
    message.filters = object.filters?.map((e) => Filter.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListModelsResponse(): ListModelsResponse {
  return { response: undefined, models: [], pagination: undefined };
}

export const ListModelsResponse = {
  encode(message: ListModelsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.response !== undefined) {
      StandardResponse.encode(message.response, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.models) {
      Model.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.pagination !== undefined) {
      PaginationResponse.encode(message.pagination, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListModelsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListModelsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.response = StandardResponse.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.models.push(Model.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pagination = PaginationResponse.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListModelsResponse {
    return {
      response: isSet(object.response) ? StandardResponse.fromJSON(object.response) : undefined,
      models: globalThis.Array.isArray(object?.models) ? object.models.map((e: any) => Model.fromJSON(e)) : [],
      pagination: isSet(object.pagination) ? PaginationResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListModelsResponse): unknown {
    const obj: any = {};
    if (message.response !== undefined) {
      obj.response = StandardResponse.toJSON(message.response);
    }
    if (message.models?.length) {
      obj.models = message.models.map((e) => Model.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PaginationResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListModelsResponse>, I>>(base?: I): ListModelsResponse {
    return ListModelsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListModelsResponse>, I>>(object: I): ListModelsResponse {
    const message = createBaseListModelsResponse();
    message.response = (object.response !== undefined && object.response !== null)
      ? StandardResponse.fromPartial(object.response)
      : undefined;
    message.models = object.models?.map((e) => Model.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PaginationResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseGetModelRequest(): GetModelRequest {
  return { modelId: "", includePricing: false, includeCapabilities: false };
}

export const GetModelRequest = {
  encode(message: GetModelRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.modelId !== "") {
      writer.uint32(10).string(message.modelId);
    }
    if (message.includePricing !== false) {
      writer.uint32(16).bool(message.includePricing);
    }
    if (message.includeCapabilities !== false) {
      writer.uint32(24).bool(message.includeCapabilities);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetModelRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetModelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.modelId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.includePricing = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.includeCapabilities = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetModelRequest {
    return {
      modelId: isSet(object.modelId) ? globalThis.String(object.modelId) : "",
      includePricing: isSet(object.includePricing) ? globalThis.Boolean(object.includePricing) : false,
      includeCapabilities: isSet(object.includeCapabilities) ? globalThis.Boolean(object.includeCapabilities) : false,
    };
  },

  toJSON(message: GetModelRequest): unknown {
    const obj: any = {};
    if (message.modelId !== "") {
      obj.modelId = message.modelId;
    }
    if (message.includePricing !== false) {
      obj.includePricing = message.includePricing;
    }
    if (message.includeCapabilities !== false) {
      obj.includeCapabilities = message.includeCapabilities;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetModelRequest>, I>>(base?: I): GetModelRequest {
    return GetModelRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetModelRequest>, I>>(object: I): GetModelRequest {
    const message = createBaseGetModelRequest();
    message.modelId = object.modelId ?? "";
    message.includePricing = object.includePricing ?? false;
    message.includeCapabilities = object.includeCapabilities ?? false;
    return message;
  },
};

function createBaseGetModelResponse(): GetModelResponse {
  return { response: undefined, model: undefined };
}

export const GetModelResponse = {
  encode(message: GetModelResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.response !== undefined) {
      StandardResponse.encode(message.response, writer.uint32(10).fork()).ldelim();
    }
    if (message.model !== undefined) {
      Model.encode(message.model, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetModelResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetModelResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.response = StandardResponse.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.model = Model.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetModelResponse {
    return {
      response: isSet(object.response) ? StandardResponse.fromJSON(object.response) : undefined,
      model: isSet(object.model) ? Model.fromJSON(object.model) : undefined,
    };
  },

  toJSON(message: GetModelResponse): unknown {
    const obj: any = {};
    if (message.response !== undefined) {
      obj.response = StandardResponse.toJSON(message.response);
    }
    if (message.model !== undefined) {
      obj.model = Model.toJSON(message.model);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetModelResponse>, I>>(base?: I): GetModelResponse {
    return GetModelResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetModelResponse>, I>>(object: I): GetModelResponse {
    const message = createBaseGetModelResponse();
    message.response = (object.response !== undefined && object.response !== null)
      ? StandardResponse.fromPartial(object.response)
      : undefined;
    message.model = (object.model !== undefined && object.model !== null) ? Model.fromPartial(object.model) : undefined;
    return message;
  },
};

function createBaseTokenEstimationRequest(): TokenEstimationRequest {
  return { model: "", text: undefined, messages: undefined, includeContext: false, sessionId: "" };
}

export const TokenEstimationRequest = {
  encode(message: TokenEstimationRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.model !== "") {
      writer.uint32(10).string(message.model);
    }
    if (message.text !== undefined) {
      writer.uint32(18).string(message.text);
    }
    if (message.messages !== undefined) {
      ChatMessageList.encode(message.messages, writer.uint32(26).fork()).ldelim();
    }
    if (message.includeContext !== false) {
      writer.uint32(32).bool(message.includeContext);
    }
    if (message.sessionId !== "") {
      writer.uint32(42).string(message.sessionId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TokenEstimationRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenEstimationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.model = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.text = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.messages = ChatMessageList.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.includeContext = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.sessionId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenEstimationRequest {
    return {
      model: isSet(object.model) ? globalThis.String(object.model) : "",
      text: isSet(object.text) ? globalThis.String(object.text) : undefined,
      messages: isSet(object.messages) ? ChatMessageList.fromJSON(object.messages) : undefined,
      includeContext: isSet(object.includeContext) ? globalThis.Boolean(object.includeContext) : false,
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
    };
  },

  toJSON(message: TokenEstimationRequest): unknown {
    const obj: any = {};
    if (message.model !== "") {
      obj.model = message.model;
    }
    if (message.text !== undefined) {
      obj.text = message.text;
    }
    if (message.messages !== undefined) {
      obj.messages = ChatMessageList.toJSON(message.messages);
    }
    if (message.includeContext !== false) {
      obj.includeContext = message.includeContext;
    }
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TokenEstimationRequest>, I>>(base?: I): TokenEstimationRequest {
    return TokenEstimationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TokenEstimationRequest>, I>>(object: I): TokenEstimationRequest {
    const message = createBaseTokenEstimationRequest();
    message.model = object.model ?? "";
    message.text = object.text ?? undefined;
    message.messages = (object.messages !== undefined && object.messages !== null)
      ? ChatMessageList.fromPartial(object.messages)
      : undefined;
    message.includeContext = object.includeContext ?? false;
    message.sessionId = object.sessionId ?? "";
    return message;
  },
};

function createBaseChatMessageList(): ChatMessageList {
  return { messages: [] };
}

export const ChatMessageList = {
  encode(message: ChatMessageList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.messages) {
      ChatMessage.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChatMessageList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChatMessageList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.messages.push(ChatMessage.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChatMessageList {
    return {
      messages: globalThis.Array.isArray(object?.messages)
        ? object.messages.map((e: any) => ChatMessage.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ChatMessageList): unknown {
    const obj: any = {};
    if (message.messages?.length) {
      obj.messages = message.messages.map((e) => ChatMessage.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChatMessageList>, I>>(base?: I): ChatMessageList {
    return ChatMessageList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChatMessageList>, I>>(object: I): ChatMessageList {
    const message = createBaseChatMessageList();
    message.messages = object.messages?.map((e) => ChatMessage.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTokenEstimationResponse(): TokenEstimationResponse {
  return { response: undefined, usage: undefined, breakdown: undefined };
}

export const TokenEstimationResponse = {
  encode(message: TokenEstimationResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.response !== undefined) {
      StandardResponse.encode(message.response, writer.uint32(10).fork()).ldelim();
    }
    if (message.usage !== undefined) {
      TokenUsage.encode(message.usage, writer.uint32(18).fork()).ldelim();
    }
    if (message.breakdown !== undefined) {
      TokenBreakdown.encode(message.breakdown, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TokenEstimationResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenEstimationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.response = StandardResponse.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.usage = TokenUsage.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.breakdown = TokenBreakdown.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenEstimationResponse {
    return {
      response: isSet(object.response) ? StandardResponse.fromJSON(object.response) : undefined,
      usage: isSet(object.usage) ? TokenUsage.fromJSON(object.usage) : undefined,
      breakdown: isSet(object.breakdown) ? TokenBreakdown.fromJSON(object.breakdown) : undefined,
    };
  },

  toJSON(message: TokenEstimationResponse): unknown {
    const obj: any = {};
    if (message.response !== undefined) {
      obj.response = StandardResponse.toJSON(message.response);
    }
    if (message.usage !== undefined) {
      obj.usage = TokenUsage.toJSON(message.usage);
    }
    if (message.breakdown !== undefined) {
      obj.breakdown = TokenBreakdown.toJSON(message.breakdown);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TokenEstimationResponse>, I>>(base?: I): TokenEstimationResponse {
    return TokenEstimationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TokenEstimationResponse>, I>>(object: I): TokenEstimationResponse {
    const message = createBaseTokenEstimationResponse();
    message.response = (object.response !== undefined && object.response !== null)
      ? StandardResponse.fromPartial(object.response)
      : undefined;
    message.usage = (object.usage !== undefined && object.usage !== null)
      ? TokenUsage.fromPartial(object.usage)
      : undefined;
    message.breakdown = (object.breakdown !== undefined && object.breakdown !== null)
      ? TokenBreakdown.fromPartial(object.breakdown)
      : undefined;
    return message;
  },
};

function createBaseTokenBreakdown(): TokenBreakdown {
  return { systemTokens: 0, userTokens: 0, assistantTokens: 0, contextTokens: 0, toolTokens: 0, contextDocuments: [] };
}

export const TokenBreakdown = {
  encode(message: TokenBreakdown, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.systemTokens !== 0) {
      writer.uint32(8).int32(message.systemTokens);
    }
    if (message.userTokens !== 0) {
      writer.uint32(16).int32(message.userTokens);
    }
    if (message.assistantTokens !== 0) {
      writer.uint32(24).int32(message.assistantTokens);
    }
    if (message.contextTokens !== 0) {
      writer.uint32(32).int32(message.contextTokens);
    }
    if (message.toolTokens !== 0) {
      writer.uint32(40).int32(message.toolTokens);
    }
    for (const v of message.contextDocuments) {
      DocumentTokens.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TokenBreakdown {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenBreakdown();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.systemTokens = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.userTokens = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.assistantTokens = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.contextTokens = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.toolTokens = reader.int32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.contextDocuments.push(DocumentTokens.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenBreakdown {
    return {
      systemTokens: isSet(object.systemTokens) ? globalThis.Number(object.systemTokens) : 0,
      userTokens: isSet(object.userTokens) ? globalThis.Number(object.userTokens) : 0,
      assistantTokens: isSet(object.assistantTokens) ? globalThis.Number(object.assistantTokens) : 0,
      contextTokens: isSet(object.contextTokens) ? globalThis.Number(object.contextTokens) : 0,
      toolTokens: isSet(object.toolTokens) ? globalThis.Number(object.toolTokens) : 0,
      contextDocuments: globalThis.Array.isArray(object?.contextDocuments)
        ? object.contextDocuments.map((e: any) => DocumentTokens.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TokenBreakdown): unknown {
    const obj: any = {};
    if (message.systemTokens !== 0) {
      obj.systemTokens = Math.round(message.systemTokens);
    }
    if (message.userTokens !== 0) {
      obj.userTokens = Math.round(message.userTokens);
    }
    if (message.assistantTokens !== 0) {
      obj.assistantTokens = Math.round(message.assistantTokens);
    }
    if (message.contextTokens !== 0) {
      obj.contextTokens = Math.round(message.contextTokens);
    }
    if (message.toolTokens !== 0) {
      obj.toolTokens = Math.round(message.toolTokens);
    }
    if (message.contextDocuments?.length) {
      obj.contextDocuments = message.contextDocuments.map((e) => DocumentTokens.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TokenBreakdown>, I>>(base?: I): TokenBreakdown {
    return TokenBreakdown.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TokenBreakdown>, I>>(object: I): TokenBreakdown {
    const message = createBaseTokenBreakdown();
    message.systemTokens = object.systemTokens ?? 0;
    message.userTokens = object.userTokens ?? 0;
    message.assistantTokens = object.assistantTokens ?? 0;
    message.contextTokens = object.contextTokens ?? 0;
    message.toolTokens = object.toolTokens ?? 0;
    message.contextDocuments = object.contextDocuments?.map((e) => DocumentTokens.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDocumentTokens(): DocumentTokens {
  return { documentId: "", documentType: "", tokenCount: 0, relevanceScore: 0 };
}

export const DocumentTokens = {
  encode(message: DocumentTokens, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.documentId !== "") {
      writer.uint32(10).string(message.documentId);
    }
    if (message.documentType !== "") {
      writer.uint32(18).string(message.documentType);
    }
    if (message.tokenCount !== 0) {
      writer.uint32(24).int32(message.tokenCount);
    }
    if (message.relevanceScore !== 0) {
      writer.uint32(37).float(message.relevanceScore);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DocumentTokens {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocumentTokens();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.documentId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.documentType = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.tokenCount = reader.int32();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.relevanceScore = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DocumentTokens {
    return {
      documentId: isSet(object.documentId) ? globalThis.String(object.documentId) : "",
      documentType: isSet(object.documentType) ? globalThis.String(object.documentType) : "",
      tokenCount: isSet(object.tokenCount) ? globalThis.Number(object.tokenCount) : 0,
      relevanceScore: isSet(object.relevanceScore) ? globalThis.Number(object.relevanceScore) : 0,
    };
  },

  toJSON(message: DocumentTokens): unknown {
    const obj: any = {};
    if (message.documentId !== "") {
      obj.documentId = message.documentId;
    }
    if (message.documentType !== "") {
      obj.documentType = message.documentType;
    }
    if (message.tokenCount !== 0) {
      obj.tokenCount = Math.round(message.tokenCount);
    }
    if (message.relevanceScore !== 0) {
      obj.relevanceScore = message.relevanceScore;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DocumentTokens>, I>>(base?: I): DocumentTokens {
    return DocumentTokens.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DocumentTokens>, I>>(object: I): DocumentTokens {
    const message = createBaseDocumentTokens();
    message.documentId = object.documentId ?? "";
    message.documentType = object.documentType ?? "";
    message.tokenCount = object.tokenCount ?? 0;
    message.relevanceScore = object.relevanceScore ?? 0;
    return message;
  },
};

function createBaseTokenCountRequest(): TokenCountRequest {
  return { model: "", text: "" };
}

export const TokenCountRequest = {
  encode(message: TokenCountRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.model !== "") {
      writer.uint32(10).string(message.model);
    }
    if (message.text !== "") {
      writer.uint32(18).string(message.text);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TokenCountRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenCountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.model = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.text = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenCountRequest {
    return {
      model: isSet(object.model) ? globalThis.String(object.model) : "",
      text: isSet(object.text) ? globalThis.String(object.text) : "",
    };
  },

  toJSON(message: TokenCountRequest): unknown {
    const obj: any = {};
    if (message.model !== "") {
      obj.model = message.model;
    }
    if (message.text !== "") {
      obj.text = message.text;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TokenCountRequest>, I>>(base?: I): TokenCountRequest {
    return TokenCountRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TokenCountRequest>, I>>(object: I): TokenCountRequest {
    const message = createBaseTokenCountRequest();
    message.model = object.model ?? "";
    message.text = object.text ?? "";
    return message;
  },
};

function createBaseTokenCountResponse(): TokenCountResponse {
  return { response: undefined, tokenCount: 0, tokens: [] };
}

export const TokenCountResponse = {
  encode(message: TokenCountResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.response !== undefined) {
      StandardResponse.encode(message.response, writer.uint32(10).fork()).ldelim();
    }
    if (message.tokenCount !== 0) {
      writer.uint32(16).int32(message.tokenCount);
    }
    for (const v of message.tokens) {
      TokenInfo.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TokenCountResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenCountResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.response = StandardResponse.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.tokenCount = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.tokens.push(TokenInfo.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenCountResponse {
    return {
      response: isSet(object.response) ? StandardResponse.fromJSON(object.response) : undefined,
      tokenCount: isSet(object.tokenCount) ? globalThis.Number(object.tokenCount) : 0,
      tokens: globalThis.Array.isArray(object?.tokens) ? object.tokens.map((e: any) => TokenInfo.fromJSON(e)) : [],
    };
  },

  toJSON(message: TokenCountResponse): unknown {
    const obj: any = {};
    if (message.response !== undefined) {
      obj.response = StandardResponse.toJSON(message.response);
    }
    if (message.tokenCount !== 0) {
      obj.tokenCount = Math.round(message.tokenCount);
    }
    if (message.tokens?.length) {
      obj.tokens = message.tokens.map((e) => TokenInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TokenCountResponse>, I>>(base?: I): TokenCountResponse {
    return TokenCountResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TokenCountResponse>, I>>(object: I): TokenCountResponse {
    const message = createBaseTokenCountResponse();
    message.response = (object.response !== undefined && object.response !== null)
      ? StandardResponse.fromPartial(object.response)
      : undefined;
    message.tokenCount = object.tokenCount ?? 0;
    message.tokens = object.tokens?.map((e) => TokenInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTokenInfo(): TokenInfo {
  return { token: "", tokenId: 0, probability: 0 };
}

export const TokenInfo = {
  encode(message: TokenInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    if (message.tokenId !== 0) {
      writer.uint32(16).int32(message.tokenId);
    }
    if (message.probability !== 0) {
      writer.uint32(29).float(message.probability);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TokenInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.tokenId = reader.int32();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.probability = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenInfo {
    return {
      token: isSet(object.token) ? globalThis.String(object.token) : "",
      tokenId: isSet(object.tokenId) ? globalThis.Number(object.tokenId) : 0,
      probability: isSet(object.probability) ? globalThis.Number(object.probability) : 0,
    };
  },

  toJSON(message: TokenInfo): unknown {
    const obj: any = {};
    if (message.token !== "") {
      obj.token = message.token;
    }
    if (message.tokenId !== 0) {
      obj.tokenId = Math.round(message.tokenId);
    }
    if (message.probability !== 0) {
      obj.probability = message.probability;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TokenInfo>, I>>(base?: I): TokenInfo {
    return TokenInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TokenInfo>, I>>(object: I): TokenInfo {
    const message = createBaseTokenInfo();
    message.token = object.token ?? "";
    message.tokenId = object.tokenId ?? 0;
    message.probability = object.probability ?? 0;
    return message;
  },
};

/**
 * LLM service for completion and model management
 *
 * Integrates with chat service for conversation context
 * and uses common patterns for consistency
 */
export type LLMServiceService = typeof LLMServiceService;
export const LLMServiceService = {
  /** Completion operations */
  generateCompletion: {
    path: "/unhinged.llm.v1.LLMService/GenerateCompletion",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CompletionRequest) => Buffer.from(CompletionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CompletionRequest.decode(value),
    responseSerialize: (value: CompletionResponse) => Buffer.from(CompletionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CompletionResponse.decode(value),
  },
  /** ← DRY! */
  streamCompletion: {
    path: "/unhinged.llm.v1.LLMService/StreamCompletion",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: CompletionRequest) => Buffer.from(CompletionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CompletionRequest.decode(value),
    responseSerialize: (value: StreamChunk) => Buffer.from(StreamChunk.encode(value).finish()),
    responseDeserialize: (value: Buffer) => StreamChunk.decode(value),
  },
  /** Model management */
  listModels: {
    path: "/unhinged.llm.v1.LLMService/ListModels",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListModelsRequest) => Buffer.from(ListModelsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ListModelsRequest.decode(value),
    responseSerialize: (value: ListModelsResponse) => Buffer.from(ListModelsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ListModelsResponse.decode(value),
  },
  getModel: {
    path: "/unhinged.llm.v1.LLMService/GetModel",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetModelRequest) => Buffer.from(GetModelRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetModelRequest.decode(value),
    responseSerialize: (value: GetModelResponse) => Buffer.from(GetModelResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetModelResponse.decode(value),
  },
  /** Token operations */
  estimateTokens: {
    path: "/unhinged.llm.v1.LLMService/EstimateTokens",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: TokenEstimationRequest) => Buffer.from(TokenEstimationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => TokenEstimationRequest.decode(value),
    responseSerialize: (value: TokenEstimationResponse) => Buffer.from(TokenEstimationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TokenEstimationResponse.decode(value),
  },
  countTokens: {
    path: "/unhinged.llm.v1.LLMService/CountTokens",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: TokenCountRequest) => Buffer.from(TokenCountRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => TokenCountRequest.decode(value),
    responseSerialize: (value: TokenCountResponse) => Buffer.from(TokenCountResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TokenCountResponse.decode(value),
  },
  /** Standard health check */
  healthCheck: {
    path: "/unhinged.llm.v1.LLMService/HealthCheck",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: HealthCheckRequest) => Buffer.from(HealthCheckRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => HealthCheckRequest.decode(value),
    responseSerialize: (value: HealthCheckResponse) => Buffer.from(HealthCheckResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => HealthCheckResponse.decode(value),
  },
} as const;

export interface LLMServiceServer extends UntypedServiceImplementation {
  /** Completion operations */
  generateCompletion: handleUnaryCall<CompletionRequest, CompletionResponse>;
  /** ← DRY! */
  streamCompletion: handleServerStreamingCall<CompletionRequest, StreamChunk>;
  /** Model management */
  listModels: handleUnaryCall<ListModelsRequest, ListModelsResponse>;
  getModel: handleUnaryCall<GetModelRequest, GetModelResponse>;
  /** Token operations */
  estimateTokens: handleUnaryCall<TokenEstimationRequest, TokenEstimationResponse>;
  countTokens: handleUnaryCall<TokenCountRequest, TokenCountResponse>;
  /** Standard health check */
  healthCheck: handleUnaryCall<HealthCheckRequest, HealthCheckResponse>;
}

export interface LLMServiceClient extends Client {
  /** Completion operations */
  generateCompletion(
    request: CompletionRequest,
    callback: (error: ServiceError | null, response: CompletionResponse) => void,
  ): ClientUnaryCall;
  generateCompletion(
    request: CompletionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CompletionResponse) => void,
  ): ClientUnaryCall;
  generateCompletion(
    request: CompletionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CompletionResponse) => void,
  ): ClientUnaryCall;
  /** ← DRY! */
  streamCompletion(request: CompletionRequest, options?: Partial<CallOptions>): ClientReadableStream<StreamChunk>;
  streamCompletion(
    request: CompletionRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<StreamChunk>;
  /** Model management */
  listModels(
    request: ListModelsRequest,
    callback: (error: ServiceError | null, response: ListModelsResponse) => void,
  ): ClientUnaryCall;
  listModels(
    request: ListModelsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListModelsResponse) => void,
  ): ClientUnaryCall;
  listModels(
    request: ListModelsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListModelsResponse) => void,
  ): ClientUnaryCall;
  getModel(
    request: GetModelRequest,
    callback: (error: ServiceError | null, response: GetModelResponse) => void,
  ): ClientUnaryCall;
  getModel(
    request: GetModelRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetModelResponse) => void,
  ): ClientUnaryCall;
  getModel(
    request: GetModelRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetModelResponse) => void,
  ): ClientUnaryCall;
  /** Token operations */
  estimateTokens(
    request: TokenEstimationRequest,
    callback: (error: ServiceError | null, response: TokenEstimationResponse) => void,
  ): ClientUnaryCall;
  estimateTokens(
    request: TokenEstimationRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TokenEstimationResponse) => void,
  ): ClientUnaryCall;
  estimateTokens(
    request: TokenEstimationRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TokenEstimationResponse) => void,
  ): ClientUnaryCall;
  countTokens(
    request: TokenCountRequest,
    callback: (error: ServiceError | null, response: TokenCountResponse) => void,
  ): ClientUnaryCall;
  countTokens(
    request: TokenCountRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TokenCountResponse) => void,
  ): ClientUnaryCall;
  countTokens(
    request: TokenCountRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TokenCountResponse) => void,
  ): ClientUnaryCall;
  /** Standard health check */
  healthCheck(
    request: HealthCheckRequest,
    callback: (error: ServiceError | null, response: HealthCheckResponse) => void,
  ): ClientUnaryCall;
  healthCheck(
    request: HealthCheckRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: HealthCheckResponse) => void,
  ): ClientUnaryCall;
  healthCheck(
    request: HealthCheckRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: HealthCheckResponse) => void,
  ): ClientUnaryCall;
}

export const LLMServiceClient = makeGenericClientConstructor(
  LLMServiceService,
  "unhinged.llm.v1.LLMService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): LLMServiceClient;
  service: typeof LLMServiceService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
