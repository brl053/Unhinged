// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v3.21.12
// source: messaging.proto

/* eslint-disable */
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  ClientReadableStream,
  type ClientUnaryCall,
  handleServerStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import _m0 from "protobufjs/minimal";
import { Any } from "./google/protobuf/any";
import { Struct } from "./google/protobuf/struct";
import { Timestamp } from "./google/protobuf/timestamp";

export enum LLMMessageType {
  LLM_PROMPT_REQUEST = 0,
  LLM_PROMPT_RESPONSE = 1,
  LLM_STREAM_CHUNK = 2,
  LLM_ERROR = 3,
  LLM_CANCEL = 4,
  UNRECOGNIZED = -1,
}

export function lLMMessageTypeFromJSON(object: any): LLMMessageType {
  switch (object) {
    case 0:
    case "LLM_PROMPT_REQUEST":
      return LLMMessageType.LLM_PROMPT_REQUEST;
    case 1:
    case "LLM_PROMPT_RESPONSE":
      return LLMMessageType.LLM_PROMPT_RESPONSE;
    case 2:
    case "LLM_STREAM_CHUNK":
      return LLMMessageType.LLM_STREAM_CHUNK;
    case 3:
    case "LLM_ERROR":
      return LLMMessageType.LLM_ERROR;
    case 4:
    case "LLM_CANCEL":
      return LLMMessageType.LLM_CANCEL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LLMMessageType.UNRECOGNIZED;
  }
}

export function lLMMessageTypeToJSON(object: LLMMessageType): string {
  switch (object) {
    case LLMMessageType.LLM_PROMPT_REQUEST:
      return "LLM_PROMPT_REQUEST";
    case LLMMessageType.LLM_PROMPT_RESPONSE:
      return "LLM_PROMPT_RESPONSE";
    case LLMMessageType.LLM_STREAM_CHUNK:
      return "LLM_STREAM_CHUNK";
    case LLMMessageType.LLM_ERROR:
      return "LLM_ERROR";
    case LLMMessageType.LLM_CANCEL:
      return "LLM_CANCEL";
    case LLMMessageType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum AgentMessageType {
  AGENT_TASK_REQUEST = 0,
  AGENT_TASK_RESPONSE = 1,
  AGENT_STEP_UPDATE = 2,
  AGENT_COLLABORATION = 3,
  AGENT_ERROR = 4,
  UNRECOGNIZED = -1,
}

export function agentMessageTypeFromJSON(object: any): AgentMessageType {
  switch (object) {
    case 0:
    case "AGENT_TASK_REQUEST":
      return AgentMessageType.AGENT_TASK_REQUEST;
    case 1:
    case "AGENT_TASK_RESPONSE":
      return AgentMessageType.AGENT_TASK_RESPONSE;
    case 2:
    case "AGENT_STEP_UPDATE":
      return AgentMessageType.AGENT_STEP_UPDATE;
    case 3:
    case "AGENT_COLLABORATION":
      return AgentMessageType.AGENT_COLLABORATION;
    case 4:
    case "AGENT_ERROR":
      return AgentMessageType.AGENT_ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AgentMessageType.UNRECOGNIZED;
  }
}

export function agentMessageTypeToJSON(object: AgentMessageType): string {
  switch (object) {
    case AgentMessageType.AGENT_TASK_REQUEST:
      return "AGENT_TASK_REQUEST";
    case AgentMessageType.AGENT_TASK_RESPONSE:
      return "AGENT_TASK_RESPONSE";
    case AgentMessageType.AGENT_STEP_UPDATE:
      return "AGENT_STEP_UPDATE";
    case AgentMessageType.AGENT_COLLABORATION:
      return "AGENT_COLLABORATION";
    case AgentMessageType.AGENT_ERROR:
      return "AGENT_ERROR";
    case AgentMessageType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ToolMessageType {
  TOOL_INVOCATION = 0,
  TOOL_RESULT = 1,
  TOOL_ERROR = 2,
  TOOL_REGISTRATION = 3,
  UNRECOGNIZED = -1,
}

export function toolMessageTypeFromJSON(object: any): ToolMessageType {
  switch (object) {
    case 0:
    case "TOOL_INVOCATION":
      return ToolMessageType.TOOL_INVOCATION;
    case 1:
    case "TOOL_RESULT":
      return ToolMessageType.TOOL_RESULT;
    case 2:
    case "TOOL_ERROR":
      return ToolMessageType.TOOL_ERROR;
    case 3:
    case "TOOL_REGISTRATION":
      return ToolMessageType.TOOL_REGISTRATION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ToolMessageType.UNRECOGNIZED;
  }
}

export function toolMessageTypeToJSON(object: ToolMessageType): string {
  switch (object) {
    case ToolMessageType.TOOL_INVOCATION:
      return "TOOL_INVOCATION";
    case ToolMessageType.TOOL_RESULT:
      return "TOOL_RESULT";
    case ToolMessageType.TOOL_ERROR:
      return "TOOL_ERROR";
    case ToolMessageType.TOOL_REGISTRATION:
      return "TOOL_REGISTRATION";
    case ToolMessageType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum WorkflowMessageType {
  WORKFLOW_TRIGGER = 0,
  WORKFLOW_STEP_EXECUTION = 1,
  WORKFLOW_COMPLETION = 2,
  WORKFLOW_CONTROL = 3,
  UNRECOGNIZED = -1,
}

export function workflowMessageTypeFromJSON(object: any): WorkflowMessageType {
  switch (object) {
    case 0:
    case "WORKFLOW_TRIGGER":
      return WorkflowMessageType.WORKFLOW_TRIGGER;
    case 1:
    case "WORKFLOW_STEP_EXECUTION":
      return WorkflowMessageType.WORKFLOW_STEP_EXECUTION;
    case 2:
    case "WORKFLOW_COMPLETION":
      return WorkflowMessageType.WORKFLOW_COMPLETION;
    case 3:
    case "WORKFLOW_CONTROL":
      return WorkflowMessageType.WORKFLOW_CONTROL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WorkflowMessageType.UNRECOGNIZED;
  }
}

export function workflowMessageTypeToJSON(object: WorkflowMessageType): string {
  switch (object) {
    case WorkflowMessageType.WORKFLOW_TRIGGER:
      return "WORKFLOW_TRIGGER";
    case WorkflowMessageType.WORKFLOW_STEP_EXECUTION:
      return "WORKFLOW_STEP_EXECUTION";
    case WorkflowMessageType.WORKFLOW_COMPLETION:
      return "WORKFLOW_COMPLETION";
    case WorkflowMessageType.WORKFLOW_CONTROL:
      return "WORKFLOW_CONTROL";
    case WorkflowMessageType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum UIMessageType {
  UI_UPDATE = 0,
  UI_NOTIFICATION = 1,
  UI_COMMAND = 2,
  UNRECOGNIZED = -1,
}

export function uIMessageTypeFromJSON(object: any): UIMessageType {
  switch (object) {
    case 0:
    case "UI_UPDATE":
      return UIMessageType.UI_UPDATE;
    case 1:
    case "UI_NOTIFICATION":
      return UIMessageType.UI_NOTIFICATION;
    case 2:
    case "UI_COMMAND":
      return UIMessageType.UI_COMMAND;
    case -1:
    case "UNRECOGNIZED":
    default:
      return UIMessageType.UNRECOGNIZED;
  }
}

export function uIMessageTypeToJSON(object: UIMessageType): string {
  switch (object) {
    case UIMessageType.UI_UPDATE:
      return "UI_UPDATE";
    case UIMessageType.UI_NOTIFICATION:
      return "UI_NOTIFICATION";
    case UIMessageType.UI_COMMAND:
      return "UI_COMMAND";
    case UIMessageType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum SystemMessageType {
  SERVICE_DISCOVERY = 0,
  HEALTH_CHECK = 1,
  CONFIG_UPDATE = 2,
  SHUTDOWN_NOTICE = 3,
  UNRECOGNIZED = -1,
}

export function systemMessageTypeFromJSON(object: any): SystemMessageType {
  switch (object) {
    case 0:
    case "SERVICE_DISCOVERY":
      return SystemMessageType.SERVICE_DISCOVERY;
    case 1:
    case "HEALTH_CHECK":
      return SystemMessageType.HEALTH_CHECK;
    case 2:
    case "CONFIG_UPDATE":
      return SystemMessageType.CONFIG_UPDATE;
    case 3:
    case "SHUTDOWN_NOTICE":
      return SystemMessageType.SHUTDOWN_NOTICE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SystemMessageType.UNRECOGNIZED;
  }
}

export function systemMessageTypeToJSON(object: SystemMessageType): string {
  switch (object) {
    case SystemMessageType.SERVICE_DISCOVERY:
      return "SERVICE_DISCOVERY";
    case SystemMessageType.HEALTH_CHECK:
      return "HEALTH_CHECK";
    case SystemMessageType.CONFIG_UPDATE:
      return "CONFIG_UPDATE";
    case SystemMessageType.SHUTDOWN_NOTICE:
      return "SHUTDOWN_NOTICE";
    case SystemMessageType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Universal message envelope for all inter-service communication */
export interface Message {
  /** Message identification */
  messageId: string;
  messageType: string;
  messageVersion: string;
  /** Routing and delivery */
  fromService: string;
  toService: string;
  routingKey: string;
  /** Timing and correlation */
  createdAt?: Date | undefined;
  expiresAt?: Date | undefined;
  correlationId: string;
  replyTo: string;
  /** Context */
  userId: string;
  sessionId: string;
  traceId: string;
  llmMessage?: LLMMessage | undefined;
  agentMessage?: AgentMessage | undefined;
  toolMessage?: ToolMessage | undefined;
  workflowMessage?: WorkflowMessage | undefined;
  uiMessage?: UIMessage | undefined;
  systemMessage?:
    | SystemMessage
    | undefined;
  /** Delivery options */
  options?: MessageOptions | undefined;
  metadata?: { [key: string]: any } | undefined;
}

export interface MessageOptions {
  /** Delivery guarantees */
  deliveryMode: string;
  retryAttempts: number;
  retryDelayMs: number;
  /** Priority and ordering */
  priority: number;
  preserveOrder: boolean;
  /** Response handling */
  expectReply: boolean;
  replyTimeoutMs: number;
}

export interface LLMMessage {
  interactionId: string;
  messageType: LLMMessageType;
  promptRequest?: LLMPromptRequest | undefined;
  promptResponse?: LLMPromptResponse | undefined;
  streamChunk?: LLMStreamChunk | undefined;
  llmError?: LLMError | undefined;
  cancelRequest?: LLMCancel | undefined;
}

export interface LLMPromptRequest {
  /** Model configuration */
  modelName: string;
  /** "openai", "anthropic", "local" */
  provider: string;
  /** Prompt content */
  systemPrompt: string;
  userPrompt: string;
  contextDocuments: ContextDocument[];
  /** Generation parameters */
  maxTokens: number;
  temperature: number;
  topP: number;
  stopSequences: string[];
  /** Streaming options */
  streamResponse: boolean;
  streamCallbackUrl: string;
  /** Context and metadata */
  promptMetadata?: { [key: string]: any } | undefined;
  toolsAvailable: string[];
}

export interface ContextDocument {
  documentId: string;
  documentType: string;
  content: string;
  metadata?: { [key: string]: any } | undefined;
  relevanceScore: number;
}

export interface LLMPromptResponse {
  /** Response content */
  responseText: string;
  /** "stop", "length", "content_filter", "tool_calls" */
  finishReason: string;
  /** Token usage */
  promptTokens: number;
  completionTokens: number;
  totalTokens: number;
  /** Timing and performance */
  responseTimeMs: number;
  tokensPerSecond: number;
  /** Tool calls (if any) */
  toolCalls: ToolCall[];
  /** Response metadata */
  responseMetadata?: { [key: string]: any } | undefined;
}

export interface LLMStreamChunk {
  chunkText: string;
  chunkIndex: number;
  isFinal: boolean;
  partialToolCalls: ToolCall[];
}

export interface LLMError {
  errorCode: string;
  errorMessage: string;
  /** "rate_limit", "context_length", "content_filter", "model_error" */
  errorType: string;
  isRetryable: boolean;
  retryAfterSeconds: number;
}

export interface LLMCancel {
  reason: string;
}

export interface ToolCall {
  toolId: string;
  toolName: string;
  toolArguments?: { [key: string]: any } | undefined;
}

export interface AgentMessage {
  agentId: string;
  executionId: string;
  messageType: AgentMessageType;
  taskRequest?: AgentTaskRequest | undefined;
  taskResponse?: AgentTaskResponse | undefined;
  stepUpdate?: AgentStepUpdate | undefined;
  collaboration?: AgentCollaboration | undefined;
  agentError?: AgentError | undefined;
}

export interface AgentTaskRequest {
  taskDescription: string;
  taskType: string;
  taskParameters?: { [key: string]: any } | undefined;
  requiredCapabilities: string[];
  context?: { [key: string]: any } | undefined;
  priority: number;
  deadline?: Date | undefined;
}

export interface AgentTaskResponse {
  /** "accepted", "rejected", "completed", "failed" */
  status: string;
  result?: { [key: string]: any } | undefined;
  completionMessage: string;
  artifactsCreated: string[];
  executionTimeMs: number;
}

export interface AgentStepUpdate {
  stepNumber: number;
  stepDescription: string;
  /** "started", "in_progress", "completed", "failed" */
  stepStatus: string;
  stepData?: { [key: string]: any } | undefined;
  progressPercentage: number;
}

export interface AgentCollaboration {
  /** "request_help", "offer_help", "share_context", "delegate_task" */
  collaborationType: string;
  targetAgentId: string;
  collaborationData?: { [key: string]: any } | undefined;
}

export interface AgentError {
  errorCode: string;
  errorMessage: string;
  errorContext: string;
  isRecoverable: boolean;
}

export interface ToolMessage {
  toolId: string;
  toolName: string;
  toolVersion: string;
  messageType: ToolMessageType;
  invocation?: ToolInvocation | undefined;
  result?: ToolResult | undefined;
  toolError?: ToolError | undefined;
  registration?: ToolRegistration | undefined;
}

export interface ToolInvocation {
  invocationId: string;
  arguments?: { [key: string]: any } | undefined;
  context?: { [key: string]: any } | undefined;
  timeoutSeconds: number;
}

export interface ToolResult {
  invocationId: string;
  success: boolean;
  resultData?: Any | undefined;
  resultText: string;
  artifacts: string[];
  executionTimeMs: number;
}

export interface ToolError {
  invocationId: string;
  errorCode: string;
  errorMessage: string;
  isRetryable: boolean;
}

export interface ToolRegistration {
  toolName: string;
  toolVersion: string;
  description: string;
  schema?: { [key: string]: any } | undefined;
  capabilities: string[];
  endpointUrl: string;
}

export interface WorkflowMessage {
  workflowId: string;
  executionId: string;
  messageType: WorkflowMessageType;
  trigger?: WorkflowTrigger | undefined;
  stepExecution?: WorkflowStepExecution | undefined;
  completion?: WorkflowCompletion | undefined;
  control?: WorkflowControl | undefined;
}

export interface WorkflowTrigger {
  triggerType: string;
  triggerSource: string;
  triggerData?: { [key: string]: any } | undefined;
  initialContext?: { [key: string]: any } | undefined;
}

export interface WorkflowStepExecution {
  stepId: string;
  stepType: string;
  stepStatus: string;
  stepInput?: { [key: string]: any } | undefined;
  stepOutput?: { [key: string]: any } | undefined;
  nextStepId: string;
}

export interface WorkflowCompletion {
  /** "success", "failure", "cancelled" */
  completionStatus: string;
  finalOutput?: { [key: string]: any } | undefined;
  completionMessage: string;
  totalStepsExecuted: number;
}

export interface WorkflowControl {
  /** "pause", "resume", "cancel", "retry" */
  controlAction: string;
  controlReason: string;
  controlParameters?: { [key: string]: any } | undefined;
}

export interface UIMessage {
  componentId: string;
  messageType: UIMessageType;
  update?: UIUpdate | undefined;
  notification?: UINotification | undefined;
  command?: UICommand | undefined;
}

export interface UIUpdate {
  /** "data", "state", "progress", "error" */
  updateType: string;
  updateData?: { [key: string]: any } | undefined;
  forceRefresh: boolean;
}

export interface UINotification {
  /** "info", "success", "warning", "error" */
  notificationType: string;
  title: string;
  message: string;
  durationMs: number;
  dismissible: boolean;
}

export interface UICommand {
  /** "navigate", "refresh", "focus", "scroll" */
  command: string;
  commandParameters?: { [key: string]: any } | undefined;
}

export interface SystemMessage {
  messageType: SystemMessageType;
  serviceDiscovery?: ServiceDiscovery | undefined;
  healthCheck?: HealthCheck | undefined;
  configUpdate?: ConfigUpdate | undefined;
  shutdownNotice?: ShutdownNotice | undefined;
}

export interface ServiceDiscovery {
  serviceName: string;
  serviceVersion: string;
  endpointUrl: string;
  capabilities: string[];
  /** "starting", "ready", "stopping" */
  status: string;
}

export interface HealthCheck {
  serviceName: string;
  isHealthy: boolean;
  statusMessage: string;
  healthDetails?: { [key: string]: any } | undefined;
}

export interface ConfigUpdate {
  configKey: string;
  configValue?: Any | undefined;
  updateReason: string;
}

export interface ShutdownNotice {
  serviceName: string;
  shutdownReason: string;
  gracefulShutdownSeconds: number;
}

/** Send a message */
export interface SendMessageRequest {
  message?: Message | undefined;
}

export interface SendMessageResponse {
  success: boolean;
  messageId: string;
  status: string;
  errorMessage: string;
}

/** Send multiple messages */
export interface SendMessagesRequest {
  messages: Message[];
  /** All or nothing */
  atomic: boolean;
}

export interface SendMessageResult {
  messageId: string;
  success: boolean;
  errorMessage: string;
}

export interface SendMessagesResponse {
  success: boolean;
  results: SendMessageResult[];
  successfulCount: number;
  failedCount: number;
}

/** Receive messages (polling) */
export interface ReceiveMessagesRequest {
  serviceName: string;
  messageTypes: string[];
  maxMessages: number;
  waitTimeSeconds: number;
}

export interface ReceiveMessagesResponse {
  messages: Message[];
  receiptHandle: string;
}

/** Acknowledge message processing */
export interface AcknowledgeMessageRequest {
  messageId: string;
  receiptHandle: string;
  success: boolean;
  errorMessage: string;
}

export interface AcknowledgeMessageResponse {
  success: boolean;
  message: string;
}

/** Subscribe to message stream */
export interface SubscribeToMessagesRequest {
  serviceName: string;
  messageTypes: string[];
  filter?: MessageFilter | undefined;
}

export interface MessageFilter {
  fromServices: string[];
  userIds: string[];
  sessionIds: string[];
  metadataFilter?: { [key: string]: any } | undefined;
}

/** Streaming response for message subscriptions */
export interface MessageStreamResponse {
  message?: Message | undefined;
  status?: StreamStatus | undefined;
  error?: StreamError | undefined;
}

export interface StreamStatus {
  /** "connected", "disconnected", "error" */
  status: string;
  messagesReceived: number;
}

export interface StreamError {
  errorCode: string;
  errorMessage: string;
  isRecoverable: boolean;
}

function createBaseMessage(): Message {
  return {
    messageId: "",
    messageType: "",
    messageVersion: "",
    fromService: "",
    toService: "",
    routingKey: "",
    createdAt: undefined,
    expiresAt: undefined,
    correlationId: "",
    replyTo: "",
    userId: "",
    sessionId: "",
    traceId: "",
    llmMessage: undefined,
    agentMessage: undefined,
    toolMessage: undefined,
    workflowMessage: undefined,
    uiMessage: undefined,
    systemMessage: undefined,
    options: undefined,
    metadata: undefined,
  };
}

export const Message = {
  encode(message: Message, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.messageId !== "") {
      writer.uint32(10).string(message.messageId);
    }
    if (message.messageType !== "") {
      writer.uint32(18).string(message.messageType);
    }
    if (message.messageVersion !== "") {
      writer.uint32(26).string(message.messageVersion);
    }
    if (message.fromService !== "") {
      writer.uint32(34).string(message.fromService);
    }
    if (message.toService !== "") {
      writer.uint32(42).string(message.toService);
    }
    if (message.routingKey !== "") {
      writer.uint32(50).string(message.routingKey);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(58).fork()).ldelim();
    }
    if (message.expiresAt !== undefined) {
      Timestamp.encode(toTimestamp(message.expiresAt), writer.uint32(66).fork()).ldelim();
    }
    if (message.correlationId !== "") {
      writer.uint32(74).string(message.correlationId);
    }
    if (message.replyTo !== "") {
      writer.uint32(82).string(message.replyTo);
    }
    if (message.userId !== "") {
      writer.uint32(90).string(message.userId);
    }
    if (message.sessionId !== "") {
      writer.uint32(98).string(message.sessionId);
    }
    if (message.traceId !== "") {
      writer.uint32(106).string(message.traceId);
    }
    if (message.llmMessage !== undefined) {
      LLMMessage.encode(message.llmMessage, writer.uint32(162).fork()).ldelim();
    }
    if (message.agentMessage !== undefined) {
      AgentMessage.encode(message.agentMessage, writer.uint32(170).fork()).ldelim();
    }
    if (message.toolMessage !== undefined) {
      ToolMessage.encode(message.toolMessage, writer.uint32(178).fork()).ldelim();
    }
    if (message.workflowMessage !== undefined) {
      WorkflowMessage.encode(message.workflowMessage, writer.uint32(186).fork()).ldelim();
    }
    if (message.uiMessage !== undefined) {
      UIMessage.encode(message.uiMessage, writer.uint32(194).fork()).ldelim();
    }
    if (message.systemMessage !== undefined) {
      SystemMessage.encode(message.systemMessage, writer.uint32(202).fork()).ldelim();
    }
    if (message.options !== undefined) {
      MessageOptions.encode(message.options, writer.uint32(242).fork()).ldelim();
    }
    if (message.metadata !== undefined) {
      Struct.encode(Struct.wrap(message.metadata), writer.uint32(250).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Message {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.messageId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.messageType = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.messageVersion = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.fromService = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.toService = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.routingKey = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.expiresAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.correlationId = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.replyTo = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.traceId = reader.string();
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.llmMessage = LLMMessage.decode(reader, reader.uint32());
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.agentMessage = AgentMessage.decode(reader, reader.uint32());
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.toolMessage = ToolMessage.decode(reader, reader.uint32());
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.workflowMessage = WorkflowMessage.decode(reader, reader.uint32());
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.uiMessage = UIMessage.decode(reader, reader.uint32());
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.systemMessage = SystemMessage.decode(reader, reader.uint32());
          continue;
        case 30:
          if (tag !== 242) {
            break;
          }

          message.options = MessageOptions.decode(reader, reader.uint32());
          continue;
        case 31:
          if (tag !== 250) {
            break;
          }

          message.metadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Message {
    return {
      messageId: isSet(object.messageId) ? globalThis.String(object.messageId) : "",
      messageType: isSet(object.messageType) ? globalThis.String(object.messageType) : "",
      messageVersion: isSet(object.messageVersion) ? globalThis.String(object.messageVersion) : "",
      fromService: isSet(object.fromService) ? globalThis.String(object.fromService) : "",
      toService: isSet(object.toService) ? globalThis.String(object.toService) : "",
      routingKey: isSet(object.routingKey) ? globalThis.String(object.routingKey) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      expiresAt: isSet(object.expiresAt) ? fromJsonTimestamp(object.expiresAt) : undefined,
      correlationId: isSet(object.correlationId) ? globalThis.String(object.correlationId) : "",
      replyTo: isSet(object.replyTo) ? globalThis.String(object.replyTo) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      traceId: isSet(object.traceId) ? globalThis.String(object.traceId) : "",
      llmMessage: isSet(object.llmMessage) ? LLMMessage.fromJSON(object.llmMessage) : undefined,
      agentMessage: isSet(object.agentMessage) ? AgentMessage.fromJSON(object.agentMessage) : undefined,
      toolMessage: isSet(object.toolMessage) ? ToolMessage.fromJSON(object.toolMessage) : undefined,
      workflowMessage: isSet(object.workflowMessage) ? WorkflowMessage.fromJSON(object.workflowMessage) : undefined,
      uiMessage: isSet(object.uiMessage) ? UIMessage.fromJSON(object.uiMessage) : undefined,
      systemMessage: isSet(object.systemMessage) ? SystemMessage.fromJSON(object.systemMessage) : undefined,
      options: isSet(object.options) ? MessageOptions.fromJSON(object.options) : undefined,
      metadata: isObject(object.metadata) ? object.metadata : undefined,
    };
  },

  toJSON(message: Message): unknown {
    const obj: any = {};
    if (message.messageId !== "") {
      obj.messageId = message.messageId;
    }
    if (message.messageType !== "") {
      obj.messageType = message.messageType;
    }
    if (message.messageVersion !== "") {
      obj.messageVersion = message.messageVersion;
    }
    if (message.fromService !== "") {
      obj.fromService = message.fromService;
    }
    if (message.toService !== "") {
      obj.toService = message.toService;
    }
    if (message.routingKey !== "") {
      obj.routingKey = message.routingKey;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.expiresAt !== undefined) {
      obj.expiresAt = message.expiresAt.toISOString();
    }
    if (message.correlationId !== "") {
      obj.correlationId = message.correlationId;
    }
    if (message.replyTo !== "") {
      obj.replyTo = message.replyTo;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.traceId !== "") {
      obj.traceId = message.traceId;
    }
    if (message.llmMessage !== undefined) {
      obj.llmMessage = LLMMessage.toJSON(message.llmMessage);
    }
    if (message.agentMessage !== undefined) {
      obj.agentMessage = AgentMessage.toJSON(message.agentMessage);
    }
    if (message.toolMessage !== undefined) {
      obj.toolMessage = ToolMessage.toJSON(message.toolMessage);
    }
    if (message.workflowMessage !== undefined) {
      obj.workflowMessage = WorkflowMessage.toJSON(message.workflowMessage);
    }
    if (message.uiMessage !== undefined) {
      obj.uiMessage = UIMessage.toJSON(message.uiMessage);
    }
    if (message.systemMessage !== undefined) {
      obj.systemMessage = SystemMessage.toJSON(message.systemMessage);
    }
    if (message.options !== undefined) {
      obj.options = MessageOptions.toJSON(message.options);
    }
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Message>, I>>(base?: I): Message {
    return Message.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Message>, I>>(object: I): Message {
    const message = createBaseMessage();
    message.messageId = object.messageId ?? "";
    message.messageType = object.messageType ?? "";
    message.messageVersion = object.messageVersion ?? "";
    message.fromService = object.fromService ?? "";
    message.toService = object.toService ?? "";
    message.routingKey = object.routingKey ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.expiresAt = object.expiresAt ?? undefined;
    message.correlationId = object.correlationId ?? "";
    message.replyTo = object.replyTo ?? "";
    message.userId = object.userId ?? "";
    message.sessionId = object.sessionId ?? "";
    message.traceId = object.traceId ?? "";
    message.llmMessage = (object.llmMessage !== undefined && object.llmMessage !== null)
      ? LLMMessage.fromPartial(object.llmMessage)
      : undefined;
    message.agentMessage = (object.agentMessage !== undefined && object.agentMessage !== null)
      ? AgentMessage.fromPartial(object.agentMessage)
      : undefined;
    message.toolMessage = (object.toolMessage !== undefined && object.toolMessage !== null)
      ? ToolMessage.fromPartial(object.toolMessage)
      : undefined;
    message.workflowMessage = (object.workflowMessage !== undefined && object.workflowMessage !== null)
      ? WorkflowMessage.fromPartial(object.workflowMessage)
      : undefined;
    message.uiMessage = (object.uiMessage !== undefined && object.uiMessage !== null)
      ? UIMessage.fromPartial(object.uiMessage)
      : undefined;
    message.systemMessage = (object.systemMessage !== undefined && object.systemMessage !== null)
      ? SystemMessage.fromPartial(object.systemMessage)
      : undefined;
    message.options = (object.options !== undefined && object.options !== null)
      ? MessageOptions.fromPartial(object.options)
      : undefined;
    message.metadata = object.metadata ?? undefined;
    return message;
  },
};

function createBaseMessageOptions(): MessageOptions {
  return {
    deliveryMode: "",
    retryAttempts: 0,
    retryDelayMs: 0,
    priority: 0,
    preserveOrder: false,
    expectReply: false,
    replyTimeoutMs: 0,
  };
}

export const MessageOptions = {
  encode(message: MessageOptions, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.deliveryMode !== "") {
      writer.uint32(10).string(message.deliveryMode);
    }
    if (message.retryAttempts !== 0) {
      writer.uint32(16).int32(message.retryAttempts);
    }
    if (message.retryDelayMs !== 0) {
      writer.uint32(24).int32(message.retryDelayMs);
    }
    if (message.priority !== 0) {
      writer.uint32(32).int32(message.priority);
    }
    if (message.preserveOrder !== false) {
      writer.uint32(40).bool(message.preserveOrder);
    }
    if (message.expectReply !== false) {
      writer.uint32(48).bool(message.expectReply);
    }
    if (message.replyTimeoutMs !== 0) {
      writer.uint32(56).int32(message.replyTimeoutMs);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MessageOptions {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.deliveryMode = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.retryAttempts = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.retryDelayMs = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.priority = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.preserveOrder = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.expectReply = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.replyTimeoutMs = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageOptions {
    return {
      deliveryMode: isSet(object.deliveryMode) ? globalThis.String(object.deliveryMode) : "",
      retryAttempts: isSet(object.retryAttempts) ? globalThis.Number(object.retryAttempts) : 0,
      retryDelayMs: isSet(object.retryDelayMs) ? globalThis.Number(object.retryDelayMs) : 0,
      priority: isSet(object.priority) ? globalThis.Number(object.priority) : 0,
      preserveOrder: isSet(object.preserveOrder) ? globalThis.Boolean(object.preserveOrder) : false,
      expectReply: isSet(object.expectReply) ? globalThis.Boolean(object.expectReply) : false,
      replyTimeoutMs: isSet(object.replyTimeoutMs) ? globalThis.Number(object.replyTimeoutMs) : 0,
    };
  },

  toJSON(message: MessageOptions): unknown {
    const obj: any = {};
    if (message.deliveryMode !== "") {
      obj.deliveryMode = message.deliveryMode;
    }
    if (message.retryAttempts !== 0) {
      obj.retryAttempts = Math.round(message.retryAttempts);
    }
    if (message.retryDelayMs !== 0) {
      obj.retryDelayMs = Math.round(message.retryDelayMs);
    }
    if (message.priority !== 0) {
      obj.priority = Math.round(message.priority);
    }
    if (message.preserveOrder !== false) {
      obj.preserveOrder = message.preserveOrder;
    }
    if (message.expectReply !== false) {
      obj.expectReply = message.expectReply;
    }
    if (message.replyTimeoutMs !== 0) {
      obj.replyTimeoutMs = Math.round(message.replyTimeoutMs);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MessageOptions>, I>>(base?: I): MessageOptions {
    return MessageOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MessageOptions>, I>>(object: I): MessageOptions {
    const message = createBaseMessageOptions();
    message.deliveryMode = object.deliveryMode ?? "";
    message.retryAttempts = object.retryAttempts ?? 0;
    message.retryDelayMs = object.retryDelayMs ?? 0;
    message.priority = object.priority ?? 0;
    message.preserveOrder = object.preserveOrder ?? false;
    message.expectReply = object.expectReply ?? false;
    message.replyTimeoutMs = object.replyTimeoutMs ?? 0;
    return message;
  },
};

function createBaseLLMMessage(): LLMMessage {
  return {
    interactionId: "",
    messageType: 0,
    promptRequest: undefined,
    promptResponse: undefined,
    streamChunk: undefined,
    llmError: undefined,
    cancelRequest: undefined,
  };
}

export const LLMMessage = {
  encode(message: LLMMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.interactionId !== "") {
      writer.uint32(10).string(message.interactionId);
    }
    if (message.messageType !== 0) {
      writer.uint32(16).int32(message.messageType);
    }
    if (message.promptRequest !== undefined) {
      LLMPromptRequest.encode(message.promptRequest, writer.uint32(82).fork()).ldelim();
    }
    if (message.promptResponse !== undefined) {
      LLMPromptResponse.encode(message.promptResponse, writer.uint32(90).fork()).ldelim();
    }
    if (message.streamChunk !== undefined) {
      LLMStreamChunk.encode(message.streamChunk, writer.uint32(98).fork()).ldelim();
    }
    if (message.llmError !== undefined) {
      LLMError.encode(message.llmError, writer.uint32(106).fork()).ldelim();
    }
    if (message.cancelRequest !== undefined) {
      LLMCancel.encode(message.cancelRequest, writer.uint32(114).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LLMMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLLMMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.interactionId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.messageType = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.promptRequest = LLMPromptRequest.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.promptResponse = LLMPromptResponse.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.streamChunk = LLMStreamChunk.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.llmError = LLMError.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.cancelRequest = LLMCancel.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LLMMessage {
    return {
      interactionId: isSet(object.interactionId) ? globalThis.String(object.interactionId) : "",
      messageType: isSet(object.messageType) ? lLMMessageTypeFromJSON(object.messageType) : 0,
      promptRequest: isSet(object.promptRequest) ? LLMPromptRequest.fromJSON(object.promptRequest) : undefined,
      promptResponse: isSet(object.promptResponse) ? LLMPromptResponse.fromJSON(object.promptResponse) : undefined,
      streamChunk: isSet(object.streamChunk) ? LLMStreamChunk.fromJSON(object.streamChunk) : undefined,
      llmError: isSet(object.llmError) ? LLMError.fromJSON(object.llmError) : undefined,
      cancelRequest: isSet(object.cancelRequest) ? LLMCancel.fromJSON(object.cancelRequest) : undefined,
    };
  },

  toJSON(message: LLMMessage): unknown {
    const obj: any = {};
    if (message.interactionId !== "") {
      obj.interactionId = message.interactionId;
    }
    if (message.messageType !== 0) {
      obj.messageType = lLMMessageTypeToJSON(message.messageType);
    }
    if (message.promptRequest !== undefined) {
      obj.promptRequest = LLMPromptRequest.toJSON(message.promptRequest);
    }
    if (message.promptResponse !== undefined) {
      obj.promptResponse = LLMPromptResponse.toJSON(message.promptResponse);
    }
    if (message.streamChunk !== undefined) {
      obj.streamChunk = LLMStreamChunk.toJSON(message.streamChunk);
    }
    if (message.llmError !== undefined) {
      obj.llmError = LLMError.toJSON(message.llmError);
    }
    if (message.cancelRequest !== undefined) {
      obj.cancelRequest = LLMCancel.toJSON(message.cancelRequest);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LLMMessage>, I>>(base?: I): LLMMessage {
    return LLMMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LLMMessage>, I>>(object: I): LLMMessage {
    const message = createBaseLLMMessage();
    message.interactionId = object.interactionId ?? "";
    message.messageType = object.messageType ?? 0;
    message.promptRequest = (object.promptRequest !== undefined && object.promptRequest !== null)
      ? LLMPromptRequest.fromPartial(object.promptRequest)
      : undefined;
    message.promptResponse = (object.promptResponse !== undefined && object.promptResponse !== null)
      ? LLMPromptResponse.fromPartial(object.promptResponse)
      : undefined;
    message.streamChunk = (object.streamChunk !== undefined && object.streamChunk !== null)
      ? LLMStreamChunk.fromPartial(object.streamChunk)
      : undefined;
    message.llmError = (object.llmError !== undefined && object.llmError !== null)
      ? LLMError.fromPartial(object.llmError)
      : undefined;
    message.cancelRequest = (object.cancelRequest !== undefined && object.cancelRequest !== null)
      ? LLMCancel.fromPartial(object.cancelRequest)
      : undefined;
    return message;
  },
};

function createBaseLLMPromptRequest(): LLMPromptRequest {
  return {
    modelName: "",
    provider: "",
    systemPrompt: "",
    userPrompt: "",
    contextDocuments: [],
    maxTokens: 0,
    temperature: 0,
    topP: 0,
    stopSequences: [],
    streamResponse: false,
    streamCallbackUrl: "",
    promptMetadata: undefined,
    toolsAvailable: [],
  };
}

export const LLMPromptRequest = {
  encode(message: LLMPromptRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.modelName !== "") {
      writer.uint32(10).string(message.modelName);
    }
    if (message.provider !== "") {
      writer.uint32(18).string(message.provider);
    }
    if (message.systemPrompt !== "") {
      writer.uint32(26).string(message.systemPrompt);
    }
    if (message.userPrompt !== "") {
      writer.uint32(34).string(message.userPrompt);
    }
    for (const v of message.contextDocuments) {
      ContextDocument.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    if (message.maxTokens !== 0) {
      writer.uint32(48).int32(message.maxTokens);
    }
    if (message.temperature !== 0) {
      writer.uint32(61).float(message.temperature);
    }
    if (message.topP !== 0) {
      writer.uint32(69).float(message.topP);
    }
    for (const v of message.stopSequences) {
      writer.uint32(74).string(v!);
    }
    if (message.streamResponse !== false) {
      writer.uint32(80).bool(message.streamResponse);
    }
    if (message.streamCallbackUrl !== "") {
      writer.uint32(90).string(message.streamCallbackUrl);
    }
    if (message.promptMetadata !== undefined) {
      Struct.encode(Struct.wrap(message.promptMetadata), writer.uint32(98).fork()).ldelim();
    }
    for (const v of message.toolsAvailable) {
      writer.uint32(106).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LLMPromptRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLLMPromptRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.modelName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.provider = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.systemPrompt = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.userPrompt = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.contextDocuments.push(ContextDocument.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.maxTokens = reader.int32();
          continue;
        case 7:
          if (tag !== 61) {
            break;
          }

          message.temperature = reader.float();
          continue;
        case 8:
          if (tag !== 69) {
            break;
          }

          message.topP = reader.float();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.stopSequences.push(reader.string());
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.streamResponse = reader.bool();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.streamCallbackUrl = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.promptMetadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.toolsAvailable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LLMPromptRequest {
    return {
      modelName: isSet(object.modelName) ? globalThis.String(object.modelName) : "",
      provider: isSet(object.provider) ? globalThis.String(object.provider) : "",
      systemPrompt: isSet(object.systemPrompt) ? globalThis.String(object.systemPrompt) : "",
      userPrompt: isSet(object.userPrompt) ? globalThis.String(object.userPrompt) : "",
      contextDocuments: globalThis.Array.isArray(object?.contextDocuments)
        ? object.contextDocuments.map((e: any) => ContextDocument.fromJSON(e))
        : [],
      maxTokens: isSet(object.maxTokens) ? globalThis.Number(object.maxTokens) : 0,
      temperature: isSet(object.temperature) ? globalThis.Number(object.temperature) : 0,
      topP: isSet(object.topP) ? globalThis.Number(object.topP) : 0,
      stopSequences: globalThis.Array.isArray(object?.stopSequences)
        ? object.stopSequences.map((e: any) => globalThis.String(e))
        : [],
      streamResponse: isSet(object.streamResponse) ? globalThis.Boolean(object.streamResponse) : false,
      streamCallbackUrl: isSet(object.streamCallbackUrl) ? globalThis.String(object.streamCallbackUrl) : "",
      promptMetadata: isObject(object.promptMetadata) ? object.promptMetadata : undefined,
      toolsAvailable: globalThis.Array.isArray(object?.toolsAvailable)
        ? object.toolsAvailable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: LLMPromptRequest): unknown {
    const obj: any = {};
    if (message.modelName !== "") {
      obj.modelName = message.modelName;
    }
    if (message.provider !== "") {
      obj.provider = message.provider;
    }
    if (message.systemPrompt !== "") {
      obj.systemPrompt = message.systemPrompt;
    }
    if (message.userPrompt !== "") {
      obj.userPrompt = message.userPrompt;
    }
    if (message.contextDocuments?.length) {
      obj.contextDocuments = message.contextDocuments.map((e) => ContextDocument.toJSON(e));
    }
    if (message.maxTokens !== 0) {
      obj.maxTokens = Math.round(message.maxTokens);
    }
    if (message.temperature !== 0) {
      obj.temperature = message.temperature;
    }
    if (message.topP !== 0) {
      obj.topP = message.topP;
    }
    if (message.stopSequences?.length) {
      obj.stopSequences = message.stopSequences;
    }
    if (message.streamResponse !== false) {
      obj.streamResponse = message.streamResponse;
    }
    if (message.streamCallbackUrl !== "") {
      obj.streamCallbackUrl = message.streamCallbackUrl;
    }
    if (message.promptMetadata !== undefined) {
      obj.promptMetadata = message.promptMetadata;
    }
    if (message.toolsAvailable?.length) {
      obj.toolsAvailable = message.toolsAvailable;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LLMPromptRequest>, I>>(base?: I): LLMPromptRequest {
    return LLMPromptRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LLMPromptRequest>, I>>(object: I): LLMPromptRequest {
    const message = createBaseLLMPromptRequest();
    message.modelName = object.modelName ?? "";
    message.provider = object.provider ?? "";
    message.systemPrompt = object.systemPrompt ?? "";
    message.userPrompt = object.userPrompt ?? "";
    message.contextDocuments = object.contextDocuments?.map((e) => ContextDocument.fromPartial(e)) || [];
    message.maxTokens = object.maxTokens ?? 0;
    message.temperature = object.temperature ?? 0;
    message.topP = object.topP ?? 0;
    message.stopSequences = object.stopSequences?.map((e) => e) || [];
    message.streamResponse = object.streamResponse ?? false;
    message.streamCallbackUrl = object.streamCallbackUrl ?? "";
    message.promptMetadata = object.promptMetadata ?? undefined;
    message.toolsAvailable = object.toolsAvailable?.map((e) => e) || [];
    return message;
  },
};

function createBaseContextDocument(): ContextDocument {
  return { documentId: "", documentType: "", content: "", metadata: undefined, relevanceScore: 0 };
}

export const ContextDocument = {
  encode(message: ContextDocument, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.documentId !== "") {
      writer.uint32(10).string(message.documentId);
    }
    if (message.documentType !== "") {
      writer.uint32(18).string(message.documentType);
    }
    if (message.content !== "") {
      writer.uint32(26).string(message.content);
    }
    if (message.metadata !== undefined) {
      Struct.encode(Struct.wrap(message.metadata), writer.uint32(34).fork()).ldelim();
    }
    if (message.relevanceScore !== 0) {
      writer.uint32(45).float(message.relevanceScore);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ContextDocument {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContextDocument();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.documentId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.documentType = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.content = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.metadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 45) {
            break;
          }

          message.relevanceScore = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContextDocument {
    return {
      documentId: isSet(object.documentId) ? globalThis.String(object.documentId) : "",
      documentType: isSet(object.documentType) ? globalThis.String(object.documentType) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      metadata: isObject(object.metadata) ? object.metadata : undefined,
      relevanceScore: isSet(object.relevanceScore) ? globalThis.Number(object.relevanceScore) : 0,
    };
  },

  toJSON(message: ContextDocument): unknown {
    const obj: any = {};
    if (message.documentId !== "") {
      obj.documentId = message.documentId;
    }
    if (message.documentType !== "") {
      obj.documentType = message.documentType;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    if (message.relevanceScore !== 0) {
      obj.relevanceScore = message.relevanceScore;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ContextDocument>, I>>(base?: I): ContextDocument {
    return ContextDocument.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ContextDocument>, I>>(object: I): ContextDocument {
    const message = createBaseContextDocument();
    message.documentId = object.documentId ?? "";
    message.documentType = object.documentType ?? "";
    message.content = object.content ?? "";
    message.metadata = object.metadata ?? undefined;
    message.relevanceScore = object.relevanceScore ?? 0;
    return message;
  },
};

function createBaseLLMPromptResponse(): LLMPromptResponse {
  return {
    responseText: "",
    finishReason: "",
    promptTokens: 0,
    completionTokens: 0,
    totalTokens: 0,
    responseTimeMs: 0,
    tokensPerSecond: 0,
    toolCalls: [],
    responseMetadata: undefined,
  };
}

export const LLMPromptResponse = {
  encode(message: LLMPromptResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.responseText !== "") {
      writer.uint32(10).string(message.responseText);
    }
    if (message.finishReason !== "") {
      writer.uint32(18).string(message.finishReason);
    }
    if (message.promptTokens !== 0) {
      writer.uint32(24).int32(message.promptTokens);
    }
    if (message.completionTokens !== 0) {
      writer.uint32(32).int32(message.completionTokens);
    }
    if (message.totalTokens !== 0) {
      writer.uint32(40).int32(message.totalTokens);
    }
    if (message.responseTimeMs !== 0) {
      writer.uint32(53).float(message.responseTimeMs);
    }
    if (message.tokensPerSecond !== 0) {
      writer.uint32(61).float(message.tokensPerSecond);
    }
    for (const v of message.toolCalls) {
      ToolCall.encode(v!, writer.uint32(66).fork()).ldelim();
    }
    if (message.responseMetadata !== undefined) {
      Struct.encode(Struct.wrap(message.responseMetadata), writer.uint32(74).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LLMPromptResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLLMPromptResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.responseText = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.finishReason = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.promptTokens = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.completionTokens = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.totalTokens = reader.int32();
          continue;
        case 6:
          if (tag !== 53) {
            break;
          }

          message.responseTimeMs = reader.float();
          continue;
        case 7:
          if (tag !== 61) {
            break;
          }

          message.tokensPerSecond = reader.float();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.toolCalls.push(ToolCall.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.responseMetadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LLMPromptResponse {
    return {
      responseText: isSet(object.responseText) ? globalThis.String(object.responseText) : "",
      finishReason: isSet(object.finishReason) ? globalThis.String(object.finishReason) : "",
      promptTokens: isSet(object.promptTokens) ? globalThis.Number(object.promptTokens) : 0,
      completionTokens: isSet(object.completionTokens) ? globalThis.Number(object.completionTokens) : 0,
      totalTokens: isSet(object.totalTokens) ? globalThis.Number(object.totalTokens) : 0,
      responseTimeMs: isSet(object.responseTimeMs) ? globalThis.Number(object.responseTimeMs) : 0,
      tokensPerSecond: isSet(object.tokensPerSecond) ? globalThis.Number(object.tokensPerSecond) : 0,
      toolCalls: globalThis.Array.isArray(object?.toolCalls)
        ? object.toolCalls.map((e: any) => ToolCall.fromJSON(e))
        : [],
      responseMetadata: isObject(object.responseMetadata) ? object.responseMetadata : undefined,
    };
  },

  toJSON(message: LLMPromptResponse): unknown {
    const obj: any = {};
    if (message.responseText !== "") {
      obj.responseText = message.responseText;
    }
    if (message.finishReason !== "") {
      obj.finishReason = message.finishReason;
    }
    if (message.promptTokens !== 0) {
      obj.promptTokens = Math.round(message.promptTokens);
    }
    if (message.completionTokens !== 0) {
      obj.completionTokens = Math.round(message.completionTokens);
    }
    if (message.totalTokens !== 0) {
      obj.totalTokens = Math.round(message.totalTokens);
    }
    if (message.responseTimeMs !== 0) {
      obj.responseTimeMs = message.responseTimeMs;
    }
    if (message.tokensPerSecond !== 0) {
      obj.tokensPerSecond = message.tokensPerSecond;
    }
    if (message.toolCalls?.length) {
      obj.toolCalls = message.toolCalls.map((e) => ToolCall.toJSON(e));
    }
    if (message.responseMetadata !== undefined) {
      obj.responseMetadata = message.responseMetadata;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LLMPromptResponse>, I>>(base?: I): LLMPromptResponse {
    return LLMPromptResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LLMPromptResponse>, I>>(object: I): LLMPromptResponse {
    const message = createBaseLLMPromptResponse();
    message.responseText = object.responseText ?? "";
    message.finishReason = object.finishReason ?? "";
    message.promptTokens = object.promptTokens ?? 0;
    message.completionTokens = object.completionTokens ?? 0;
    message.totalTokens = object.totalTokens ?? 0;
    message.responseTimeMs = object.responseTimeMs ?? 0;
    message.tokensPerSecond = object.tokensPerSecond ?? 0;
    message.toolCalls = object.toolCalls?.map((e) => ToolCall.fromPartial(e)) || [];
    message.responseMetadata = object.responseMetadata ?? undefined;
    return message;
  },
};

function createBaseLLMStreamChunk(): LLMStreamChunk {
  return { chunkText: "", chunkIndex: 0, isFinal: false, partialToolCalls: [] };
}

export const LLMStreamChunk = {
  encode(message: LLMStreamChunk, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.chunkText !== "") {
      writer.uint32(10).string(message.chunkText);
    }
    if (message.chunkIndex !== 0) {
      writer.uint32(16).int32(message.chunkIndex);
    }
    if (message.isFinal !== false) {
      writer.uint32(24).bool(message.isFinal);
    }
    for (const v of message.partialToolCalls) {
      ToolCall.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LLMStreamChunk {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLLMStreamChunk();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.chunkText = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.chunkIndex = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.isFinal = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.partialToolCalls.push(ToolCall.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LLMStreamChunk {
    return {
      chunkText: isSet(object.chunkText) ? globalThis.String(object.chunkText) : "",
      chunkIndex: isSet(object.chunkIndex) ? globalThis.Number(object.chunkIndex) : 0,
      isFinal: isSet(object.isFinal) ? globalThis.Boolean(object.isFinal) : false,
      partialToolCalls: globalThis.Array.isArray(object?.partialToolCalls)
        ? object.partialToolCalls.map((e: any) => ToolCall.fromJSON(e))
        : [],
    };
  },

  toJSON(message: LLMStreamChunk): unknown {
    const obj: any = {};
    if (message.chunkText !== "") {
      obj.chunkText = message.chunkText;
    }
    if (message.chunkIndex !== 0) {
      obj.chunkIndex = Math.round(message.chunkIndex);
    }
    if (message.isFinal !== false) {
      obj.isFinal = message.isFinal;
    }
    if (message.partialToolCalls?.length) {
      obj.partialToolCalls = message.partialToolCalls.map((e) => ToolCall.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LLMStreamChunk>, I>>(base?: I): LLMStreamChunk {
    return LLMStreamChunk.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LLMStreamChunk>, I>>(object: I): LLMStreamChunk {
    const message = createBaseLLMStreamChunk();
    message.chunkText = object.chunkText ?? "";
    message.chunkIndex = object.chunkIndex ?? 0;
    message.isFinal = object.isFinal ?? false;
    message.partialToolCalls = object.partialToolCalls?.map((e) => ToolCall.fromPartial(e)) || [];
    return message;
  },
};

function createBaseLLMError(): LLMError {
  return { errorCode: "", errorMessage: "", errorType: "", isRetryable: false, retryAfterSeconds: 0 };
}

export const LLMError = {
  encode(message: LLMError, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.errorCode !== "") {
      writer.uint32(10).string(message.errorCode);
    }
    if (message.errorMessage !== "") {
      writer.uint32(18).string(message.errorMessage);
    }
    if (message.errorType !== "") {
      writer.uint32(26).string(message.errorType);
    }
    if (message.isRetryable !== false) {
      writer.uint32(32).bool(message.isRetryable);
    }
    if (message.retryAfterSeconds !== 0) {
      writer.uint32(40).int32(message.retryAfterSeconds);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LLMError {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLLMError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.errorCode = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.errorType = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.isRetryable = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.retryAfterSeconds = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LLMError {
    return {
      errorCode: isSet(object.errorCode) ? globalThis.String(object.errorCode) : "",
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
      errorType: isSet(object.errorType) ? globalThis.String(object.errorType) : "",
      isRetryable: isSet(object.isRetryable) ? globalThis.Boolean(object.isRetryable) : false,
      retryAfterSeconds: isSet(object.retryAfterSeconds) ? globalThis.Number(object.retryAfterSeconds) : 0,
    };
  },

  toJSON(message: LLMError): unknown {
    const obj: any = {};
    if (message.errorCode !== "") {
      obj.errorCode = message.errorCode;
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    if (message.errorType !== "") {
      obj.errorType = message.errorType;
    }
    if (message.isRetryable !== false) {
      obj.isRetryable = message.isRetryable;
    }
    if (message.retryAfterSeconds !== 0) {
      obj.retryAfterSeconds = Math.round(message.retryAfterSeconds);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LLMError>, I>>(base?: I): LLMError {
    return LLMError.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LLMError>, I>>(object: I): LLMError {
    const message = createBaseLLMError();
    message.errorCode = object.errorCode ?? "";
    message.errorMessage = object.errorMessage ?? "";
    message.errorType = object.errorType ?? "";
    message.isRetryable = object.isRetryable ?? false;
    message.retryAfterSeconds = object.retryAfterSeconds ?? 0;
    return message;
  },
};

function createBaseLLMCancel(): LLMCancel {
  return { reason: "" };
}

export const LLMCancel = {
  encode(message: LLMCancel, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.reason !== "") {
      writer.uint32(10).string(message.reason);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LLMCancel {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLLMCancel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.reason = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LLMCancel {
    return { reason: isSet(object.reason) ? globalThis.String(object.reason) : "" };
  },

  toJSON(message: LLMCancel): unknown {
    const obj: any = {};
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LLMCancel>, I>>(base?: I): LLMCancel {
    return LLMCancel.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LLMCancel>, I>>(object: I): LLMCancel {
    const message = createBaseLLMCancel();
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseToolCall(): ToolCall {
  return { toolId: "", toolName: "", toolArguments: undefined };
}

export const ToolCall = {
  encode(message: ToolCall, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.toolId !== "") {
      writer.uint32(10).string(message.toolId);
    }
    if (message.toolName !== "") {
      writer.uint32(18).string(message.toolName);
    }
    if (message.toolArguments !== undefined) {
      Struct.encode(Struct.wrap(message.toolArguments), writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ToolCall {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToolCall();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.toolId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.toolName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.toolArguments = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ToolCall {
    return {
      toolId: isSet(object.toolId) ? globalThis.String(object.toolId) : "",
      toolName: isSet(object.toolName) ? globalThis.String(object.toolName) : "",
      toolArguments: isObject(object.toolArguments) ? object.toolArguments : undefined,
    };
  },

  toJSON(message: ToolCall): unknown {
    const obj: any = {};
    if (message.toolId !== "") {
      obj.toolId = message.toolId;
    }
    if (message.toolName !== "") {
      obj.toolName = message.toolName;
    }
    if (message.toolArguments !== undefined) {
      obj.toolArguments = message.toolArguments;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ToolCall>, I>>(base?: I): ToolCall {
    return ToolCall.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ToolCall>, I>>(object: I): ToolCall {
    const message = createBaseToolCall();
    message.toolId = object.toolId ?? "";
    message.toolName = object.toolName ?? "";
    message.toolArguments = object.toolArguments ?? undefined;
    return message;
  },
};

function createBaseAgentMessage(): AgentMessage {
  return {
    agentId: "",
    executionId: "",
    messageType: 0,
    taskRequest: undefined,
    taskResponse: undefined,
    stepUpdate: undefined,
    collaboration: undefined,
    agentError: undefined,
  };
}

export const AgentMessage = {
  encode(message: AgentMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.agentId !== "") {
      writer.uint32(10).string(message.agentId);
    }
    if (message.executionId !== "") {
      writer.uint32(18).string(message.executionId);
    }
    if (message.messageType !== 0) {
      writer.uint32(24).int32(message.messageType);
    }
    if (message.taskRequest !== undefined) {
      AgentTaskRequest.encode(message.taskRequest, writer.uint32(82).fork()).ldelim();
    }
    if (message.taskResponse !== undefined) {
      AgentTaskResponse.encode(message.taskResponse, writer.uint32(90).fork()).ldelim();
    }
    if (message.stepUpdate !== undefined) {
      AgentStepUpdate.encode(message.stepUpdate, writer.uint32(98).fork()).ldelim();
    }
    if (message.collaboration !== undefined) {
      AgentCollaboration.encode(message.collaboration, writer.uint32(106).fork()).ldelim();
    }
    if (message.agentError !== undefined) {
      AgentError.encode(message.agentError, writer.uint32(114).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AgentMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgentMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.agentId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.executionId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.messageType = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.taskRequest = AgentTaskRequest.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.taskResponse = AgentTaskResponse.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.stepUpdate = AgentStepUpdate.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.collaboration = AgentCollaboration.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.agentError = AgentError.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AgentMessage {
    return {
      agentId: isSet(object.agentId) ? globalThis.String(object.agentId) : "",
      executionId: isSet(object.executionId) ? globalThis.String(object.executionId) : "",
      messageType: isSet(object.messageType) ? agentMessageTypeFromJSON(object.messageType) : 0,
      taskRequest: isSet(object.taskRequest) ? AgentTaskRequest.fromJSON(object.taskRequest) : undefined,
      taskResponse: isSet(object.taskResponse) ? AgentTaskResponse.fromJSON(object.taskResponse) : undefined,
      stepUpdate: isSet(object.stepUpdate) ? AgentStepUpdate.fromJSON(object.stepUpdate) : undefined,
      collaboration: isSet(object.collaboration) ? AgentCollaboration.fromJSON(object.collaboration) : undefined,
      agentError: isSet(object.agentError) ? AgentError.fromJSON(object.agentError) : undefined,
    };
  },

  toJSON(message: AgentMessage): unknown {
    const obj: any = {};
    if (message.agentId !== "") {
      obj.agentId = message.agentId;
    }
    if (message.executionId !== "") {
      obj.executionId = message.executionId;
    }
    if (message.messageType !== 0) {
      obj.messageType = agentMessageTypeToJSON(message.messageType);
    }
    if (message.taskRequest !== undefined) {
      obj.taskRequest = AgentTaskRequest.toJSON(message.taskRequest);
    }
    if (message.taskResponse !== undefined) {
      obj.taskResponse = AgentTaskResponse.toJSON(message.taskResponse);
    }
    if (message.stepUpdate !== undefined) {
      obj.stepUpdate = AgentStepUpdate.toJSON(message.stepUpdate);
    }
    if (message.collaboration !== undefined) {
      obj.collaboration = AgentCollaboration.toJSON(message.collaboration);
    }
    if (message.agentError !== undefined) {
      obj.agentError = AgentError.toJSON(message.agentError);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AgentMessage>, I>>(base?: I): AgentMessage {
    return AgentMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AgentMessage>, I>>(object: I): AgentMessage {
    const message = createBaseAgentMessage();
    message.agentId = object.agentId ?? "";
    message.executionId = object.executionId ?? "";
    message.messageType = object.messageType ?? 0;
    message.taskRequest = (object.taskRequest !== undefined && object.taskRequest !== null)
      ? AgentTaskRequest.fromPartial(object.taskRequest)
      : undefined;
    message.taskResponse = (object.taskResponse !== undefined && object.taskResponse !== null)
      ? AgentTaskResponse.fromPartial(object.taskResponse)
      : undefined;
    message.stepUpdate = (object.stepUpdate !== undefined && object.stepUpdate !== null)
      ? AgentStepUpdate.fromPartial(object.stepUpdate)
      : undefined;
    message.collaboration = (object.collaboration !== undefined && object.collaboration !== null)
      ? AgentCollaboration.fromPartial(object.collaboration)
      : undefined;
    message.agentError = (object.agentError !== undefined && object.agentError !== null)
      ? AgentError.fromPartial(object.agentError)
      : undefined;
    return message;
  },
};

function createBaseAgentTaskRequest(): AgentTaskRequest {
  return {
    taskDescription: "",
    taskType: "",
    taskParameters: undefined,
    requiredCapabilities: [],
    context: undefined,
    priority: 0,
    deadline: undefined,
  };
}

export const AgentTaskRequest = {
  encode(message: AgentTaskRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.taskDescription !== "") {
      writer.uint32(10).string(message.taskDescription);
    }
    if (message.taskType !== "") {
      writer.uint32(18).string(message.taskType);
    }
    if (message.taskParameters !== undefined) {
      Struct.encode(Struct.wrap(message.taskParameters), writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.requiredCapabilities) {
      writer.uint32(34).string(v!);
    }
    if (message.context !== undefined) {
      Struct.encode(Struct.wrap(message.context), writer.uint32(42).fork()).ldelim();
    }
    if (message.priority !== 0) {
      writer.uint32(48).int32(message.priority);
    }
    if (message.deadline !== undefined) {
      Timestamp.encode(toTimestamp(message.deadline), writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AgentTaskRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgentTaskRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.taskDescription = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.taskType = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.taskParameters = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requiredCapabilities.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.context = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.priority = reader.int32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.deadline = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AgentTaskRequest {
    return {
      taskDescription: isSet(object.taskDescription) ? globalThis.String(object.taskDescription) : "",
      taskType: isSet(object.taskType) ? globalThis.String(object.taskType) : "",
      taskParameters: isObject(object.taskParameters) ? object.taskParameters : undefined,
      requiredCapabilities: globalThis.Array.isArray(object?.requiredCapabilities)
        ? object.requiredCapabilities.map((e: any) => globalThis.String(e))
        : [],
      context: isObject(object.context) ? object.context : undefined,
      priority: isSet(object.priority) ? globalThis.Number(object.priority) : 0,
      deadline: isSet(object.deadline) ? fromJsonTimestamp(object.deadline) : undefined,
    };
  },

  toJSON(message: AgentTaskRequest): unknown {
    const obj: any = {};
    if (message.taskDescription !== "") {
      obj.taskDescription = message.taskDescription;
    }
    if (message.taskType !== "") {
      obj.taskType = message.taskType;
    }
    if (message.taskParameters !== undefined) {
      obj.taskParameters = message.taskParameters;
    }
    if (message.requiredCapabilities?.length) {
      obj.requiredCapabilities = message.requiredCapabilities;
    }
    if (message.context !== undefined) {
      obj.context = message.context;
    }
    if (message.priority !== 0) {
      obj.priority = Math.round(message.priority);
    }
    if (message.deadline !== undefined) {
      obj.deadline = message.deadline.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AgentTaskRequest>, I>>(base?: I): AgentTaskRequest {
    return AgentTaskRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AgentTaskRequest>, I>>(object: I): AgentTaskRequest {
    const message = createBaseAgentTaskRequest();
    message.taskDescription = object.taskDescription ?? "";
    message.taskType = object.taskType ?? "";
    message.taskParameters = object.taskParameters ?? undefined;
    message.requiredCapabilities = object.requiredCapabilities?.map((e) => e) || [];
    message.context = object.context ?? undefined;
    message.priority = object.priority ?? 0;
    message.deadline = object.deadline ?? undefined;
    return message;
  },
};

function createBaseAgentTaskResponse(): AgentTaskResponse {
  return { status: "", result: undefined, completionMessage: "", artifactsCreated: [], executionTimeMs: 0 };
}

export const AgentTaskResponse = {
  encode(message: AgentTaskResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.status !== "") {
      writer.uint32(10).string(message.status);
    }
    if (message.result !== undefined) {
      Struct.encode(Struct.wrap(message.result), writer.uint32(18).fork()).ldelim();
    }
    if (message.completionMessage !== "") {
      writer.uint32(26).string(message.completionMessage);
    }
    for (const v of message.artifactsCreated) {
      writer.uint32(34).string(v!);
    }
    if (message.executionTimeMs !== 0) {
      writer.uint32(45).float(message.executionTimeMs);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AgentTaskResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgentTaskResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.status = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.result = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.completionMessage = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.artifactsCreated.push(reader.string());
          continue;
        case 5:
          if (tag !== 45) {
            break;
          }

          message.executionTimeMs = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AgentTaskResponse {
    return {
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      result: isObject(object.result) ? object.result : undefined,
      completionMessage: isSet(object.completionMessage) ? globalThis.String(object.completionMessage) : "",
      artifactsCreated: globalThis.Array.isArray(object?.artifactsCreated)
        ? object.artifactsCreated.map((e: any) => globalThis.String(e))
        : [],
      executionTimeMs: isSet(object.executionTimeMs) ? globalThis.Number(object.executionTimeMs) : 0,
    };
  },

  toJSON(message: AgentTaskResponse): unknown {
    const obj: any = {};
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.result !== undefined) {
      obj.result = message.result;
    }
    if (message.completionMessage !== "") {
      obj.completionMessage = message.completionMessage;
    }
    if (message.artifactsCreated?.length) {
      obj.artifactsCreated = message.artifactsCreated;
    }
    if (message.executionTimeMs !== 0) {
      obj.executionTimeMs = message.executionTimeMs;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AgentTaskResponse>, I>>(base?: I): AgentTaskResponse {
    return AgentTaskResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AgentTaskResponse>, I>>(object: I): AgentTaskResponse {
    const message = createBaseAgentTaskResponse();
    message.status = object.status ?? "";
    message.result = object.result ?? undefined;
    message.completionMessage = object.completionMessage ?? "";
    message.artifactsCreated = object.artifactsCreated?.map((e) => e) || [];
    message.executionTimeMs = object.executionTimeMs ?? 0;
    return message;
  },
};

function createBaseAgentStepUpdate(): AgentStepUpdate {
  return { stepNumber: 0, stepDescription: "", stepStatus: "", stepData: undefined, progressPercentage: 0 };
}

export const AgentStepUpdate = {
  encode(message: AgentStepUpdate, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.stepNumber !== 0) {
      writer.uint32(8).int32(message.stepNumber);
    }
    if (message.stepDescription !== "") {
      writer.uint32(18).string(message.stepDescription);
    }
    if (message.stepStatus !== "") {
      writer.uint32(26).string(message.stepStatus);
    }
    if (message.stepData !== undefined) {
      Struct.encode(Struct.wrap(message.stepData), writer.uint32(34).fork()).ldelim();
    }
    if (message.progressPercentage !== 0) {
      writer.uint32(45).float(message.progressPercentage);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AgentStepUpdate {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgentStepUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.stepNumber = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.stepDescription = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.stepStatus = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.stepData = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 45) {
            break;
          }

          message.progressPercentage = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AgentStepUpdate {
    return {
      stepNumber: isSet(object.stepNumber) ? globalThis.Number(object.stepNumber) : 0,
      stepDescription: isSet(object.stepDescription) ? globalThis.String(object.stepDescription) : "",
      stepStatus: isSet(object.stepStatus) ? globalThis.String(object.stepStatus) : "",
      stepData: isObject(object.stepData) ? object.stepData : undefined,
      progressPercentage: isSet(object.progressPercentage) ? globalThis.Number(object.progressPercentage) : 0,
    };
  },

  toJSON(message: AgentStepUpdate): unknown {
    const obj: any = {};
    if (message.stepNumber !== 0) {
      obj.stepNumber = Math.round(message.stepNumber);
    }
    if (message.stepDescription !== "") {
      obj.stepDescription = message.stepDescription;
    }
    if (message.stepStatus !== "") {
      obj.stepStatus = message.stepStatus;
    }
    if (message.stepData !== undefined) {
      obj.stepData = message.stepData;
    }
    if (message.progressPercentage !== 0) {
      obj.progressPercentage = message.progressPercentage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AgentStepUpdate>, I>>(base?: I): AgentStepUpdate {
    return AgentStepUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AgentStepUpdate>, I>>(object: I): AgentStepUpdate {
    const message = createBaseAgentStepUpdate();
    message.stepNumber = object.stepNumber ?? 0;
    message.stepDescription = object.stepDescription ?? "";
    message.stepStatus = object.stepStatus ?? "";
    message.stepData = object.stepData ?? undefined;
    message.progressPercentage = object.progressPercentage ?? 0;
    return message;
  },
};

function createBaseAgentCollaboration(): AgentCollaboration {
  return { collaborationType: "", targetAgentId: "", collaborationData: undefined };
}

export const AgentCollaboration = {
  encode(message: AgentCollaboration, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.collaborationType !== "") {
      writer.uint32(10).string(message.collaborationType);
    }
    if (message.targetAgentId !== "") {
      writer.uint32(18).string(message.targetAgentId);
    }
    if (message.collaborationData !== undefined) {
      Struct.encode(Struct.wrap(message.collaborationData), writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AgentCollaboration {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgentCollaboration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.collaborationType = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.targetAgentId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.collaborationData = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AgentCollaboration {
    return {
      collaborationType: isSet(object.collaborationType) ? globalThis.String(object.collaborationType) : "",
      targetAgentId: isSet(object.targetAgentId) ? globalThis.String(object.targetAgentId) : "",
      collaborationData: isObject(object.collaborationData) ? object.collaborationData : undefined,
    };
  },

  toJSON(message: AgentCollaboration): unknown {
    const obj: any = {};
    if (message.collaborationType !== "") {
      obj.collaborationType = message.collaborationType;
    }
    if (message.targetAgentId !== "") {
      obj.targetAgentId = message.targetAgentId;
    }
    if (message.collaborationData !== undefined) {
      obj.collaborationData = message.collaborationData;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AgentCollaboration>, I>>(base?: I): AgentCollaboration {
    return AgentCollaboration.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AgentCollaboration>, I>>(object: I): AgentCollaboration {
    const message = createBaseAgentCollaboration();
    message.collaborationType = object.collaborationType ?? "";
    message.targetAgentId = object.targetAgentId ?? "";
    message.collaborationData = object.collaborationData ?? undefined;
    return message;
  },
};

function createBaseAgentError(): AgentError {
  return { errorCode: "", errorMessage: "", errorContext: "", isRecoverable: false };
}

export const AgentError = {
  encode(message: AgentError, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.errorCode !== "") {
      writer.uint32(10).string(message.errorCode);
    }
    if (message.errorMessage !== "") {
      writer.uint32(18).string(message.errorMessage);
    }
    if (message.errorContext !== "") {
      writer.uint32(26).string(message.errorContext);
    }
    if (message.isRecoverable !== false) {
      writer.uint32(32).bool(message.isRecoverable);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AgentError {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgentError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.errorCode = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.errorContext = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.isRecoverable = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AgentError {
    return {
      errorCode: isSet(object.errorCode) ? globalThis.String(object.errorCode) : "",
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
      errorContext: isSet(object.errorContext) ? globalThis.String(object.errorContext) : "",
      isRecoverable: isSet(object.isRecoverable) ? globalThis.Boolean(object.isRecoverable) : false,
    };
  },

  toJSON(message: AgentError): unknown {
    const obj: any = {};
    if (message.errorCode !== "") {
      obj.errorCode = message.errorCode;
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    if (message.errorContext !== "") {
      obj.errorContext = message.errorContext;
    }
    if (message.isRecoverable !== false) {
      obj.isRecoverable = message.isRecoverable;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AgentError>, I>>(base?: I): AgentError {
    return AgentError.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AgentError>, I>>(object: I): AgentError {
    const message = createBaseAgentError();
    message.errorCode = object.errorCode ?? "";
    message.errorMessage = object.errorMessage ?? "";
    message.errorContext = object.errorContext ?? "";
    message.isRecoverable = object.isRecoverable ?? false;
    return message;
  },
};

function createBaseToolMessage(): ToolMessage {
  return {
    toolId: "",
    toolName: "",
    toolVersion: "",
    messageType: 0,
    invocation: undefined,
    result: undefined,
    toolError: undefined,
    registration: undefined,
  };
}

export const ToolMessage = {
  encode(message: ToolMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.toolId !== "") {
      writer.uint32(10).string(message.toolId);
    }
    if (message.toolName !== "") {
      writer.uint32(18).string(message.toolName);
    }
    if (message.toolVersion !== "") {
      writer.uint32(26).string(message.toolVersion);
    }
    if (message.messageType !== 0) {
      writer.uint32(32).int32(message.messageType);
    }
    if (message.invocation !== undefined) {
      ToolInvocation.encode(message.invocation, writer.uint32(82).fork()).ldelim();
    }
    if (message.result !== undefined) {
      ToolResult.encode(message.result, writer.uint32(90).fork()).ldelim();
    }
    if (message.toolError !== undefined) {
      ToolError.encode(message.toolError, writer.uint32(98).fork()).ldelim();
    }
    if (message.registration !== undefined) {
      ToolRegistration.encode(message.registration, writer.uint32(106).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ToolMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToolMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.toolId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.toolName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.toolVersion = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.messageType = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.invocation = ToolInvocation.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.result = ToolResult.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.toolError = ToolError.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.registration = ToolRegistration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ToolMessage {
    return {
      toolId: isSet(object.toolId) ? globalThis.String(object.toolId) : "",
      toolName: isSet(object.toolName) ? globalThis.String(object.toolName) : "",
      toolVersion: isSet(object.toolVersion) ? globalThis.String(object.toolVersion) : "",
      messageType: isSet(object.messageType) ? toolMessageTypeFromJSON(object.messageType) : 0,
      invocation: isSet(object.invocation) ? ToolInvocation.fromJSON(object.invocation) : undefined,
      result: isSet(object.result) ? ToolResult.fromJSON(object.result) : undefined,
      toolError: isSet(object.toolError) ? ToolError.fromJSON(object.toolError) : undefined,
      registration: isSet(object.registration) ? ToolRegistration.fromJSON(object.registration) : undefined,
    };
  },

  toJSON(message: ToolMessage): unknown {
    const obj: any = {};
    if (message.toolId !== "") {
      obj.toolId = message.toolId;
    }
    if (message.toolName !== "") {
      obj.toolName = message.toolName;
    }
    if (message.toolVersion !== "") {
      obj.toolVersion = message.toolVersion;
    }
    if (message.messageType !== 0) {
      obj.messageType = toolMessageTypeToJSON(message.messageType);
    }
    if (message.invocation !== undefined) {
      obj.invocation = ToolInvocation.toJSON(message.invocation);
    }
    if (message.result !== undefined) {
      obj.result = ToolResult.toJSON(message.result);
    }
    if (message.toolError !== undefined) {
      obj.toolError = ToolError.toJSON(message.toolError);
    }
    if (message.registration !== undefined) {
      obj.registration = ToolRegistration.toJSON(message.registration);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ToolMessage>, I>>(base?: I): ToolMessage {
    return ToolMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ToolMessage>, I>>(object: I): ToolMessage {
    const message = createBaseToolMessage();
    message.toolId = object.toolId ?? "";
    message.toolName = object.toolName ?? "";
    message.toolVersion = object.toolVersion ?? "";
    message.messageType = object.messageType ?? 0;
    message.invocation = (object.invocation !== undefined && object.invocation !== null)
      ? ToolInvocation.fromPartial(object.invocation)
      : undefined;
    message.result = (object.result !== undefined && object.result !== null)
      ? ToolResult.fromPartial(object.result)
      : undefined;
    message.toolError = (object.toolError !== undefined && object.toolError !== null)
      ? ToolError.fromPartial(object.toolError)
      : undefined;
    message.registration = (object.registration !== undefined && object.registration !== null)
      ? ToolRegistration.fromPartial(object.registration)
      : undefined;
    return message;
  },
};

function createBaseToolInvocation(): ToolInvocation {
  return { invocationId: "", arguments: undefined, context: undefined, timeoutSeconds: 0 };
}

export const ToolInvocation = {
  encode(message: ToolInvocation, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.invocationId !== "") {
      writer.uint32(10).string(message.invocationId);
    }
    if (message.arguments !== undefined) {
      Struct.encode(Struct.wrap(message.arguments), writer.uint32(18).fork()).ldelim();
    }
    if (message.context !== undefined) {
      Struct.encode(Struct.wrap(message.context), writer.uint32(26).fork()).ldelim();
    }
    if (message.timeoutSeconds !== 0) {
      writer.uint32(32).int32(message.timeoutSeconds);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ToolInvocation {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToolInvocation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.invocationId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.arguments = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.context = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.timeoutSeconds = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ToolInvocation {
    return {
      invocationId: isSet(object.invocationId) ? globalThis.String(object.invocationId) : "",
      arguments: isObject(object.arguments) ? object.arguments : undefined,
      context: isObject(object.context) ? object.context : undefined,
      timeoutSeconds: isSet(object.timeoutSeconds) ? globalThis.Number(object.timeoutSeconds) : 0,
    };
  },

  toJSON(message: ToolInvocation): unknown {
    const obj: any = {};
    if (message.invocationId !== "") {
      obj.invocationId = message.invocationId;
    }
    if (message.arguments !== undefined) {
      obj.arguments = message.arguments;
    }
    if (message.context !== undefined) {
      obj.context = message.context;
    }
    if (message.timeoutSeconds !== 0) {
      obj.timeoutSeconds = Math.round(message.timeoutSeconds);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ToolInvocation>, I>>(base?: I): ToolInvocation {
    return ToolInvocation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ToolInvocation>, I>>(object: I): ToolInvocation {
    const message = createBaseToolInvocation();
    message.invocationId = object.invocationId ?? "";
    message.arguments = object.arguments ?? undefined;
    message.context = object.context ?? undefined;
    message.timeoutSeconds = object.timeoutSeconds ?? 0;
    return message;
  },
};

function createBaseToolResult(): ToolResult {
  return { invocationId: "", success: false, resultData: undefined, resultText: "", artifacts: [], executionTimeMs: 0 };
}

export const ToolResult = {
  encode(message: ToolResult, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.invocationId !== "") {
      writer.uint32(10).string(message.invocationId);
    }
    if (message.success !== false) {
      writer.uint32(16).bool(message.success);
    }
    if (message.resultData !== undefined) {
      Any.encode(message.resultData, writer.uint32(26).fork()).ldelim();
    }
    if (message.resultText !== "") {
      writer.uint32(34).string(message.resultText);
    }
    for (const v of message.artifacts) {
      writer.uint32(42).string(v!);
    }
    if (message.executionTimeMs !== 0) {
      writer.uint32(53).float(message.executionTimeMs);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ToolResult {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToolResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.invocationId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.resultData = Any.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.resultText = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.artifacts.push(reader.string());
          continue;
        case 6:
          if (tag !== 53) {
            break;
          }

          message.executionTimeMs = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ToolResult {
    return {
      invocationId: isSet(object.invocationId) ? globalThis.String(object.invocationId) : "",
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      resultData: isSet(object.resultData) ? Any.fromJSON(object.resultData) : undefined,
      resultText: isSet(object.resultText) ? globalThis.String(object.resultText) : "",
      artifacts: globalThis.Array.isArray(object?.artifacts)
        ? object.artifacts.map((e: any) => globalThis.String(e))
        : [],
      executionTimeMs: isSet(object.executionTimeMs) ? globalThis.Number(object.executionTimeMs) : 0,
    };
  },

  toJSON(message: ToolResult): unknown {
    const obj: any = {};
    if (message.invocationId !== "") {
      obj.invocationId = message.invocationId;
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.resultData !== undefined) {
      obj.resultData = Any.toJSON(message.resultData);
    }
    if (message.resultText !== "") {
      obj.resultText = message.resultText;
    }
    if (message.artifacts?.length) {
      obj.artifacts = message.artifacts;
    }
    if (message.executionTimeMs !== 0) {
      obj.executionTimeMs = message.executionTimeMs;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ToolResult>, I>>(base?: I): ToolResult {
    return ToolResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ToolResult>, I>>(object: I): ToolResult {
    const message = createBaseToolResult();
    message.invocationId = object.invocationId ?? "";
    message.success = object.success ?? false;
    message.resultData = (object.resultData !== undefined && object.resultData !== null)
      ? Any.fromPartial(object.resultData)
      : undefined;
    message.resultText = object.resultText ?? "";
    message.artifacts = object.artifacts?.map((e) => e) || [];
    message.executionTimeMs = object.executionTimeMs ?? 0;
    return message;
  },
};

function createBaseToolError(): ToolError {
  return { invocationId: "", errorCode: "", errorMessage: "", isRetryable: false };
}

export const ToolError = {
  encode(message: ToolError, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.invocationId !== "") {
      writer.uint32(10).string(message.invocationId);
    }
    if (message.errorCode !== "") {
      writer.uint32(18).string(message.errorCode);
    }
    if (message.errorMessage !== "") {
      writer.uint32(26).string(message.errorMessage);
    }
    if (message.isRetryable !== false) {
      writer.uint32(32).bool(message.isRetryable);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ToolError {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToolError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.invocationId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorCode = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.isRetryable = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ToolError {
    return {
      invocationId: isSet(object.invocationId) ? globalThis.String(object.invocationId) : "",
      errorCode: isSet(object.errorCode) ? globalThis.String(object.errorCode) : "",
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
      isRetryable: isSet(object.isRetryable) ? globalThis.Boolean(object.isRetryable) : false,
    };
  },

  toJSON(message: ToolError): unknown {
    const obj: any = {};
    if (message.invocationId !== "") {
      obj.invocationId = message.invocationId;
    }
    if (message.errorCode !== "") {
      obj.errorCode = message.errorCode;
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    if (message.isRetryable !== false) {
      obj.isRetryable = message.isRetryable;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ToolError>, I>>(base?: I): ToolError {
    return ToolError.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ToolError>, I>>(object: I): ToolError {
    const message = createBaseToolError();
    message.invocationId = object.invocationId ?? "";
    message.errorCode = object.errorCode ?? "";
    message.errorMessage = object.errorMessage ?? "";
    message.isRetryable = object.isRetryable ?? false;
    return message;
  },
};

function createBaseToolRegistration(): ToolRegistration {
  return { toolName: "", toolVersion: "", description: "", schema: undefined, capabilities: [], endpointUrl: "" };
}

export const ToolRegistration = {
  encode(message: ToolRegistration, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.toolName !== "") {
      writer.uint32(10).string(message.toolName);
    }
    if (message.toolVersion !== "") {
      writer.uint32(18).string(message.toolVersion);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.schema !== undefined) {
      Struct.encode(Struct.wrap(message.schema), writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.capabilities) {
      writer.uint32(42).string(v!);
    }
    if (message.endpointUrl !== "") {
      writer.uint32(50).string(message.endpointUrl);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ToolRegistration {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToolRegistration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.toolName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.toolVersion = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.schema = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.capabilities.push(reader.string());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.endpointUrl = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ToolRegistration {
    return {
      toolName: isSet(object.toolName) ? globalThis.String(object.toolName) : "",
      toolVersion: isSet(object.toolVersion) ? globalThis.String(object.toolVersion) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      schema: isObject(object.schema) ? object.schema : undefined,
      capabilities: globalThis.Array.isArray(object?.capabilities)
        ? object.capabilities.map((e: any) => globalThis.String(e))
        : [],
      endpointUrl: isSet(object.endpointUrl) ? globalThis.String(object.endpointUrl) : "",
    };
  },

  toJSON(message: ToolRegistration): unknown {
    const obj: any = {};
    if (message.toolName !== "") {
      obj.toolName = message.toolName;
    }
    if (message.toolVersion !== "") {
      obj.toolVersion = message.toolVersion;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.schema !== undefined) {
      obj.schema = message.schema;
    }
    if (message.capabilities?.length) {
      obj.capabilities = message.capabilities;
    }
    if (message.endpointUrl !== "") {
      obj.endpointUrl = message.endpointUrl;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ToolRegistration>, I>>(base?: I): ToolRegistration {
    return ToolRegistration.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ToolRegistration>, I>>(object: I): ToolRegistration {
    const message = createBaseToolRegistration();
    message.toolName = object.toolName ?? "";
    message.toolVersion = object.toolVersion ?? "";
    message.description = object.description ?? "";
    message.schema = object.schema ?? undefined;
    message.capabilities = object.capabilities?.map((e) => e) || [];
    message.endpointUrl = object.endpointUrl ?? "";
    return message;
  },
};

function createBaseWorkflowMessage(): WorkflowMessage {
  return {
    workflowId: "",
    executionId: "",
    messageType: 0,
    trigger: undefined,
    stepExecution: undefined,
    completion: undefined,
    control: undefined,
  };
}

export const WorkflowMessage = {
  encode(message: WorkflowMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.workflowId !== "") {
      writer.uint32(10).string(message.workflowId);
    }
    if (message.executionId !== "") {
      writer.uint32(18).string(message.executionId);
    }
    if (message.messageType !== 0) {
      writer.uint32(24).int32(message.messageType);
    }
    if (message.trigger !== undefined) {
      WorkflowTrigger.encode(message.trigger, writer.uint32(82).fork()).ldelim();
    }
    if (message.stepExecution !== undefined) {
      WorkflowStepExecution.encode(message.stepExecution, writer.uint32(90).fork()).ldelim();
    }
    if (message.completion !== undefined) {
      WorkflowCompletion.encode(message.completion, writer.uint32(98).fork()).ldelim();
    }
    if (message.control !== undefined) {
      WorkflowControl.encode(message.control, writer.uint32(106).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WorkflowMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkflowMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.workflowId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.executionId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.messageType = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.trigger = WorkflowTrigger.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.stepExecution = WorkflowStepExecution.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.completion = WorkflowCompletion.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.control = WorkflowControl.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkflowMessage {
    return {
      workflowId: isSet(object.workflowId) ? globalThis.String(object.workflowId) : "",
      executionId: isSet(object.executionId) ? globalThis.String(object.executionId) : "",
      messageType: isSet(object.messageType) ? workflowMessageTypeFromJSON(object.messageType) : 0,
      trigger: isSet(object.trigger) ? WorkflowTrigger.fromJSON(object.trigger) : undefined,
      stepExecution: isSet(object.stepExecution) ? WorkflowStepExecution.fromJSON(object.stepExecution) : undefined,
      completion: isSet(object.completion) ? WorkflowCompletion.fromJSON(object.completion) : undefined,
      control: isSet(object.control) ? WorkflowControl.fromJSON(object.control) : undefined,
    };
  },

  toJSON(message: WorkflowMessage): unknown {
    const obj: any = {};
    if (message.workflowId !== "") {
      obj.workflowId = message.workflowId;
    }
    if (message.executionId !== "") {
      obj.executionId = message.executionId;
    }
    if (message.messageType !== 0) {
      obj.messageType = workflowMessageTypeToJSON(message.messageType);
    }
    if (message.trigger !== undefined) {
      obj.trigger = WorkflowTrigger.toJSON(message.trigger);
    }
    if (message.stepExecution !== undefined) {
      obj.stepExecution = WorkflowStepExecution.toJSON(message.stepExecution);
    }
    if (message.completion !== undefined) {
      obj.completion = WorkflowCompletion.toJSON(message.completion);
    }
    if (message.control !== undefined) {
      obj.control = WorkflowControl.toJSON(message.control);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorkflowMessage>, I>>(base?: I): WorkflowMessage {
    return WorkflowMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorkflowMessage>, I>>(object: I): WorkflowMessage {
    const message = createBaseWorkflowMessage();
    message.workflowId = object.workflowId ?? "";
    message.executionId = object.executionId ?? "";
    message.messageType = object.messageType ?? 0;
    message.trigger = (object.trigger !== undefined && object.trigger !== null)
      ? WorkflowTrigger.fromPartial(object.trigger)
      : undefined;
    message.stepExecution = (object.stepExecution !== undefined && object.stepExecution !== null)
      ? WorkflowStepExecution.fromPartial(object.stepExecution)
      : undefined;
    message.completion = (object.completion !== undefined && object.completion !== null)
      ? WorkflowCompletion.fromPartial(object.completion)
      : undefined;
    message.control = (object.control !== undefined && object.control !== null)
      ? WorkflowControl.fromPartial(object.control)
      : undefined;
    return message;
  },
};

function createBaseWorkflowTrigger(): WorkflowTrigger {
  return { triggerType: "", triggerSource: "", triggerData: undefined, initialContext: undefined };
}

export const WorkflowTrigger = {
  encode(message: WorkflowTrigger, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.triggerType !== "") {
      writer.uint32(10).string(message.triggerType);
    }
    if (message.triggerSource !== "") {
      writer.uint32(18).string(message.triggerSource);
    }
    if (message.triggerData !== undefined) {
      Struct.encode(Struct.wrap(message.triggerData), writer.uint32(26).fork()).ldelim();
    }
    if (message.initialContext !== undefined) {
      Struct.encode(Struct.wrap(message.initialContext), writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WorkflowTrigger {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkflowTrigger();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.triggerType = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.triggerSource = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.triggerData = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.initialContext = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkflowTrigger {
    return {
      triggerType: isSet(object.triggerType) ? globalThis.String(object.triggerType) : "",
      triggerSource: isSet(object.triggerSource) ? globalThis.String(object.triggerSource) : "",
      triggerData: isObject(object.triggerData) ? object.triggerData : undefined,
      initialContext: isObject(object.initialContext) ? object.initialContext : undefined,
    };
  },

  toJSON(message: WorkflowTrigger): unknown {
    const obj: any = {};
    if (message.triggerType !== "") {
      obj.triggerType = message.triggerType;
    }
    if (message.triggerSource !== "") {
      obj.triggerSource = message.triggerSource;
    }
    if (message.triggerData !== undefined) {
      obj.triggerData = message.triggerData;
    }
    if (message.initialContext !== undefined) {
      obj.initialContext = message.initialContext;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorkflowTrigger>, I>>(base?: I): WorkflowTrigger {
    return WorkflowTrigger.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorkflowTrigger>, I>>(object: I): WorkflowTrigger {
    const message = createBaseWorkflowTrigger();
    message.triggerType = object.triggerType ?? "";
    message.triggerSource = object.triggerSource ?? "";
    message.triggerData = object.triggerData ?? undefined;
    message.initialContext = object.initialContext ?? undefined;
    return message;
  },
};

function createBaseWorkflowStepExecution(): WorkflowStepExecution {
  return { stepId: "", stepType: "", stepStatus: "", stepInput: undefined, stepOutput: undefined, nextStepId: "" };
}

export const WorkflowStepExecution = {
  encode(message: WorkflowStepExecution, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.stepId !== "") {
      writer.uint32(10).string(message.stepId);
    }
    if (message.stepType !== "") {
      writer.uint32(18).string(message.stepType);
    }
    if (message.stepStatus !== "") {
      writer.uint32(26).string(message.stepStatus);
    }
    if (message.stepInput !== undefined) {
      Struct.encode(Struct.wrap(message.stepInput), writer.uint32(34).fork()).ldelim();
    }
    if (message.stepOutput !== undefined) {
      Struct.encode(Struct.wrap(message.stepOutput), writer.uint32(42).fork()).ldelim();
    }
    if (message.nextStepId !== "") {
      writer.uint32(50).string(message.nextStepId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WorkflowStepExecution {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkflowStepExecution();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.stepId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.stepType = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.stepStatus = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.stepInput = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.stepOutput = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.nextStepId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkflowStepExecution {
    return {
      stepId: isSet(object.stepId) ? globalThis.String(object.stepId) : "",
      stepType: isSet(object.stepType) ? globalThis.String(object.stepType) : "",
      stepStatus: isSet(object.stepStatus) ? globalThis.String(object.stepStatus) : "",
      stepInput: isObject(object.stepInput) ? object.stepInput : undefined,
      stepOutput: isObject(object.stepOutput) ? object.stepOutput : undefined,
      nextStepId: isSet(object.nextStepId) ? globalThis.String(object.nextStepId) : "",
    };
  },

  toJSON(message: WorkflowStepExecution): unknown {
    const obj: any = {};
    if (message.stepId !== "") {
      obj.stepId = message.stepId;
    }
    if (message.stepType !== "") {
      obj.stepType = message.stepType;
    }
    if (message.stepStatus !== "") {
      obj.stepStatus = message.stepStatus;
    }
    if (message.stepInput !== undefined) {
      obj.stepInput = message.stepInput;
    }
    if (message.stepOutput !== undefined) {
      obj.stepOutput = message.stepOutput;
    }
    if (message.nextStepId !== "") {
      obj.nextStepId = message.nextStepId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorkflowStepExecution>, I>>(base?: I): WorkflowStepExecution {
    return WorkflowStepExecution.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorkflowStepExecution>, I>>(object: I): WorkflowStepExecution {
    const message = createBaseWorkflowStepExecution();
    message.stepId = object.stepId ?? "";
    message.stepType = object.stepType ?? "";
    message.stepStatus = object.stepStatus ?? "";
    message.stepInput = object.stepInput ?? undefined;
    message.stepOutput = object.stepOutput ?? undefined;
    message.nextStepId = object.nextStepId ?? "";
    return message;
  },
};

function createBaseWorkflowCompletion(): WorkflowCompletion {
  return { completionStatus: "", finalOutput: undefined, completionMessage: "", totalStepsExecuted: 0 };
}

export const WorkflowCompletion = {
  encode(message: WorkflowCompletion, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.completionStatus !== "") {
      writer.uint32(10).string(message.completionStatus);
    }
    if (message.finalOutput !== undefined) {
      Struct.encode(Struct.wrap(message.finalOutput), writer.uint32(18).fork()).ldelim();
    }
    if (message.completionMessage !== "") {
      writer.uint32(26).string(message.completionMessage);
    }
    if (message.totalStepsExecuted !== 0) {
      writer.uint32(32).int32(message.totalStepsExecuted);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WorkflowCompletion {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkflowCompletion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.completionStatus = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.finalOutput = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.completionMessage = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.totalStepsExecuted = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkflowCompletion {
    return {
      completionStatus: isSet(object.completionStatus) ? globalThis.String(object.completionStatus) : "",
      finalOutput: isObject(object.finalOutput) ? object.finalOutput : undefined,
      completionMessage: isSet(object.completionMessage) ? globalThis.String(object.completionMessage) : "",
      totalStepsExecuted: isSet(object.totalStepsExecuted) ? globalThis.Number(object.totalStepsExecuted) : 0,
    };
  },

  toJSON(message: WorkflowCompletion): unknown {
    const obj: any = {};
    if (message.completionStatus !== "") {
      obj.completionStatus = message.completionStatus;
    }
    if (message.finalOutput !== undefined) {
      obj.finalOutput = message.finalOutput;
    }
    if (message.completionMessage !== "") {
      obj.completionMessage = message.completionMessage;
    }
    if (message.totalStepsExecuted !== 0) {
      obj.totalStepsExecuted = Math.round(message.totalStepsExecuted);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorkflowCompletion>, I>>(base?: I): WorkflowCompletion {
    return WorkflowCompletion.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorkflowCompletion>, I>>(object: I): WorkflowCompletion {
    const message = createBaseWorkflowCompletion();
    message.completionStatus = object.completionStatus ?? "";
    message.finalOutput = object.finalOutput ?? undefined;
    message.completionMessage = object.completionMessage ?? "";
    message.totalStepsExecuted = object.totalStepsExecuted ?? 0;
    return message;
  },
};

function createBaseWorkflowControl(): WorkflowControl {
  return { controlAction: "", controlReason: "", controlParameters: undefined };
}

export const WorkflowControl = {
  encode(message: WorkflowControl, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.controlAction !== "") {
      writer.uint32(10).string(message.controlAction);
    }
    if (message.controlReason !== "") {
      writer.uint32(18).string(message.controlReason);
    }
    if (message.controlParameters !== undefined) {
      Struct.encode(Struct.wrap(message.controlParameters), writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WorkflowControl {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkflowControl();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.controlAction = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.controlReason = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.controlParameters = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkflowControl {
    return {
      controlAction: isSet(object.controlAction) ? globalThis.String(object.controlAction) : "",
      controlReason: isSet(object.controlReason) ? globalThis.String(object.controlReason) : "",
      controlParameters: isObject(object.controlParameters) ? object.controlParameters : undefined,
    };
  },

  toJSON(message: WorkflowControl): unknown {
    const obj: any = {};
    if (message.controlAction !== "") {
      obj.controlAction = message.controlAction;
    }
    if (message.controlReason !== "") {
      obj.controlReason = message.controlReason;
    }
    if (message.controlParameters !== undefined) {
      obj.controlParameters = message.controlParameters;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorkflowControl>, I>>(base?: I): WorkflowControl {
    return WorkflowControl.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorkflowControl>, I>>(object: I): WorkflowControl {
    const message = createBaseWorkflowControl();
    message.controlAction = object.controlAction ?? "";
    message.controlReason = object.controlReason ?? "";
    message.controlParameters = object.controlParameters ?? undefined;
    return message;
  },
};

function createBaseUIMessage(): UIMessage {
  return { componentId: "", messageType: 0, update: undefined, notification: undefined, command: undefined };
}

export const UIMessage = {
  encode(message: UIMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.componentId !== "") {
      writer.uint32(10).string(message.componentId);
    }
    if (message.messageType !== 0) {
      writer.uint32(16).int32(message.messageType);
    }
    if (message.update !== undefined) {
      UIUpdate.encode(message.update, writer.uint32(82).fork()).ldelim();
    }
    if (message.notification !== undefined) {
      UINotification.encode(message.notification, writer.uint32(90).fork()).ldelim();
    }
    if (message.command !== undefined) {
      UICommand.encode(message.command, writer.uint32(98).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UIMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUIMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.componentId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.messageType = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.update = UIUpdate.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.notification = UINotification.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.command = UICommand.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UIMessage {
    return {
      componentId: isSet(object.componentId) ? globalThis.String(object.componentId) : "",
      messageType: isSet(object.messageType) ? uIMessageTypeFromJSON(object.messageType) : 0,
      update: isSet(object.update) ? UIUpdate.fromJSON(object.update) : undefined,
      notification: isSet(object.notification) ? UINotification.fromJSON(object.notification) : undefined,
      command: isSet(object.command) ? UICommand.fromJSON(object.command) : undefined,
    };
  },

  toJSON(message: UIMessage): unknown {
    const obj: any = {};
    if (message.componentId !== "") {
      obj.componentId = message.componentId;
    }
    if (message.messageType !== 0) {
      obj.messageType = uIMessageTypeToJSON(message.messageType);
    }
    if (message.update !== undefined) {
      obj.update = UIUpdate.toJSON(message.update);
    }
    if (message.notification !== undefined) {
      obj.notification = UINotification.toJSON(message.notification);
    }
    if (message.command !== undefined) {
      obj.command = UICommand.toJSON(message.command);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UIMessage>, I>>(base?: I): UIMessage {
    return UIMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UIMessage>, I>>(object: I): UIMessage {
    const message = createBaseUIMessage();
    message.componentId = object.componentId ?? "";
    message.messageType = object.messageType ?? 0;
    message.update = (object.update !== undefined && object.update !== null)
      ? UIUpdate.fromPartial(object.update)
      : undefined;
    message.notification = (object.notification !== undefined && object.notification !== null)
      ? UINotification.fromPartial(object.notification)
      : undefined;
    message.command = (object.command !== undefined && object.command !== null)
      ? UICommand.fromPartial(object.command)
      : undefined;
    return message;
  },
};

function createBaseUIUpdate(): UIUpdate {
  return { updateType: "", updateData: undefined, forceRefresh: false };
}

export const UIUpdate = {
  encode(message: UIUpdate, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.updateType !== "") {
      writer.uint32(10).string(message.updateType);
    }
    if (message.updateData !== undefined) {
      Struct.encode(Struct.wrap(message.updateData), writer.uint32(18).fork()).ldelim();
    }
    if (message.forceRefresh !== false) {
      writer.uint32(24).bool(message.forceRefresh);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UIUpdate {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUIUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.updateType = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateData = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.forceRefresh = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UIUpdate {
    return {
      updateType: isSet(object.updateType) ? globalThis.String(object.updateType) : "",
      updateData: isObject(object.updateData) ? object.updateData : undefined,
      forceRefresh: isSet(object.forceRefresh) ? globalThis.Boolean(object.forceRefresh) : false,
    };
  },

  toJSON(message: UIUpdate): unknown {
    const obj: any = {};
    if (message.updateType !== "") {
      obj.updateType = message.updateType;
    }
    if (message.updateData !== undefined) {
      obj.updateData = message.updateData;
    }
    if (message.forceRefresh !== false) {
      obj.forceRefresh = message.forceRefresh;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UIUpdate>, I>>(base?: I): UIUpdate {
    return UIUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UIUpdate>, I>>(object: I): UIUpdate {
    const message = createBaseUIUpdate();
    message.updateType = object.updateType ?? "";
    message.updateData = object.updateData ?? undefined;
    message.forceRefresh = object.forceRefresh ?? false;
    return message;
  },
};

function createBaseUINotification(): UINotification {
  return { notificationType: "", title: "", message: "", durationMs: 0, dismissible: false };
}

export const UINotification = {
  encode(message: UINotification, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.notificationType !== "") {
      writer.uint32(10).string(message.notificationType);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    if (message.durationMs !== 0) {
      writer.uint32(32).int32(message.durationMs);
    }
    if (message.dismissible !== false) {
      writer.uint32(40).bool(message.dismissible);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UINotification {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUINotification();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.notificationType = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.durationMs = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.dismissible = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UINotification {
    return {
      notificationType: isSet(object.notificationType) ? globalThis.String(object.notificationType) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      durationMs: isSet(object.durationMs) ? globalThis.Number(object.durationMs) : 0,
      dismissible: isSet(object.dismissible) ? globalThis.Boolean(object.dismissible) : false,
    };
  },

  toJSON(message: UINotification): unknown {
    const obj: any = {};
    if (message.notificationType !== "") {
      obj.notificationType = message.notificationType;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.durationMs !== 0) {
      obj.durationMs = Math.round(message.durationMs);
    }
    if (message.dismissible !== false) {
      obj.dismissible = message.dismissible;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UINotification>, I>>(base?: I): UINotification {
    return UINotification.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UINotification>, I>>(object: I): UINotification {
    const message = createBaseUINotification();
    message.notificationType = object.notificationType ?? "";
    message.title = object.title ?? "";
    message.message = object.message ?? "";
    message.durationMs = object.durationMs ?? 0;
    message.dismissible = object.dismissible ?? false;
    return message;
  },
};

function createBaseUICommand(): UICommand {
  return { command: "", commandParameters: undefined };
}

export const UICommand = {
  encode(message: UICommand, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.command !== "") {
      writer.uint32(10).string(message.command);
    }
    if (message.commandParameters !== undefined) {
      Struct.encode(Struct.wrap(message.commandParameters), writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UICommand {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUICommand();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.command = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.commandParameters = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UICommand {
    return {
      command: isSet(object.command) ? globalThis.String(object.command) : "",
      commandParameters: isObject(object.commandParameters) ? object.commandParameters : undefined,
    };
  },

  toJSON(message: UICommand): unknown {
    const obj: any = {};
    if (message.command !== "") {
      obj.command = message.command;
    }
    if (message.commandParameters !== undefined) {
      obj.commandParameters = message.commandParameters;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UICommand>, I>>(base?: I): UICommand {
    return UICommand.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UICommand>, I>>(object: I): UICommand {
    const message = createBaseUICommand();
    message.command = object.command ?? "";
    message.commandParameters = object.commandParameters ?? undefined;
    return message;
  },
};

function createBaseSystemMessage(): SystemMessage {
  return {
    messageType: 0,
    serviceDiscovery: undefined,
    healthCheck: undefined,
    configUpdate: undefined,
    shutdownNotice: undefined,
  };
}

export const SystemMessage = {
  encode(message: SystemMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.messageType !== 0) {
      writer.uint32(8).int32(message.messageType);
    }
    if (message.serviceDiscovery !== undefined) {
      ServiceDiscovery.encode(message.serviceDiscovery, writer.uint32(82).fork()).ldelim();
    }
    if (message.healthCheck !== undefined) {
      HealthCheck.encode(message.healthCheck, writer.uint32(90).fork()).ldelim();
    }
    if (message.configUpdate !== undefined) {
      ConfigUpdate.encode(message.configUpdate, writer.uint32(98).fork()).ldelim();
    }
    if (message.shutdownNotice !== undefined) {
      ShutdownNotice.encode(message.shutdownNotice, writer.uint32(106).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SystemMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSystemMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.messageType = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.serviceDiscovery = ServiceDiscovery.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.healthCheck = HealthCheck.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.configUpdate = ConfigUpdate.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.shutdownNotice = ShutdownNotice.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SystemMessage {
    return {
      messageType: isSet(object.messageType) ? systemMessageTypeFromJSON(object.messageType) : 0,
      serviceDiscovery: isSet(object.serviceDiscovery) ? ServiceDiscovery.fromJSON(object.serviceDiscovery) : undefined,
      healthCheck: isSet(object.healthCheck) ? HealthCheck.fromJSON(object.healthCheck) : undefined,
      configUpdate: isSet(object.configUpdate) ? ConfigUpdate.fromJSON(object.configUpdate) : undefined,
      shutdownNotice: isSet(object.shutdownNotice) ? ShutdownNotice.fromJSON(object.shutdownNotice) : undefined,
    };
  },

  toJSON(message: SystemMessage): unknown {
    const obj: any = {};
    if (message.messageType !== 0) {
      obj.messageType = systemMessageTypeToJSON(message.messageType);
    }
    if (message.serviceDiscovery !== undefined) {
      obj.serviceDiscovery = ServiceDiscovery.toJSON(message.serviceDiscovery);
    }
    if (message.healthCheck !== undefined) {
      obj.healthCheck = HealthCheck.toJSON(message.healthCheck);
    }
    if (message.configUpdate !== undefined) {
      obj.configUpdate = ConfigUpdate.toJSON(message.configUpdate);
    }
    if (message.shutdownNotice !== undefined) {
      obj.shutdownNotice = ShutdownNotice.toJSON(message.shutdownNotice);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SystemMessage>, I>>(base?: I): SystemMessage {
    return SystemMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SystemMessage>, I>>(object: I): SystemMessage {
    const message = createBaseSystemMessage();
    message.messageType = object.messageType ?? 0;
    message.serviceDiscovery = (object.serviceDiscovery !== undefined && object.serviceDiscovery !== null)
      ? ServiceDiscovery.fromPartial(object.serviceDiscovery)
      : undefined;
    message.healthCheck = (object.healthCheck !== undefined && object.healthCheck !== null)
      ? HealthCheck.fromPartial(object.healthCheck)
      : undefined;
    message.configUpdate = (object.configUpdate !== undefined && object.configUpdate !== null)
      ? ConfigUpdate.fromPartial(object.configUpdate)
      : undefined;
    message.shutdownNotice = (object.shutdownNotice !== undefined && object.shutdownNotice !== null)
      ? ShutdownNotice.fromPartial(object.shutdownNotice)
      : undefined;
    return message;
  },
};

function createBaseServiceDiscovery(): ServiceDiscovery {
  return { serviceName: "", serviceVersion: "", endpointUrl: "", capabilities: [], status: "" };
}

export const ServiceDiscovery = {
  encode(message: ServiceDiscovery, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.serviceName !== "") {
      writer.uint32(10).string(message.serviceName);
    }
    if (message.serviceVersion !== "") {
      writer.uint32(18).string(message.serviceVersion);
    }
    if (message.endpointUrl !== "") {
      writer.uint32(26).string(message.endpointUrl);
    }
    for (const v of message.capabilities) {
      writer.uint32(34).string(v!);
    }
    if (message.status !== "") {
      writer.uint32(42).string(message.status);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ServiceDiscovery {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceDiscovery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.serviceName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.serviceVersion = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.endpointUrl = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.capabilities.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.status = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceDiscovery {
    return {
      serviceName: isSet(object.serviceName) ? globalThis.String(object.serviceName) : "",
      serviceVersion: isSet(object.serviceVersion) ? globalThis.String(object.serviceVersion) : "",
      endpointUrl: isSet(object.endpointUrl) ? globalThis.String(object.endpointUrl) : "",
      capabilities: globalThis.Array.isArray(object?.capabilities)
        ? object.capabilities.map((e: any) => globalThis.String(e))
        : [],
      status: isSet(object.status) ? globalThis.String(object.status) : "",
    };
  },

  toJSON(message: ServiceDiscovery): unknown {
    const obj: any = {};
    if (message.serviceName !== "") {
      obj.serviceName = message.serviceName;
    }
    if (message.serviceVersion !== "") {
      obj.serviceVersion = message.serviceVersion;
    }
    if (message.endpointUrl !== "") {
      obj.endpointUrl = message.endpointUrl;
    }
    if (message.capabilities?.length) {
      obj.capabilities = message.capabilities;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServiceDiscovery>, I>>(base?: I): ServiceDiscovery {
    return ServiceDiscovery.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServiceDiscovery>, I>>(object: I): ServiceDiscovery {
    const message = createBaseServiceDiscovery();
    message.serviceName = object.serviceName ?? "";
    message.serviceVersion = object.serviceVersion ?? "";
    message.endpointUrl = object.endpointUrl ?? "";
    message.capabilities = object.capabilities?.map((e) => e) || [];
    message.status = object.status ?? "";
    return message;
  },
};

function createBaseHealthCheck(): HealthCheck {
  return { serviceName: "", isHealthy: false, statusMessage: "", healthDetails: undefined };
}

export const HealthCheck = {
  encode(message: HealthCheck, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.serviceName !== "") {
      writer.uint32(10).string(message.serviceName);
    }
    if (message.isHealthy !== false) {
      writer.uint32(16).bool(message.isHealthy);
    }
    if (message.statusMessage !== "") {
      writer.uint32(26).string(message.statusMessage);
    }
    if (message.healthDetails !== undefined) {
      Struct.encode(Struct.wrap(message.healthDetails), writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HealthCheck {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheck();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.serviceName = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.isHealthy = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.statusMessage = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.healthDetails = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthCheck {
    return {
      serviceName: isSet(object.serviceName) ? globalThis.String(object.serviceName) : "",
      isHealthy: isSet(object.isHealthy) ? globalThis.Boolean(object.isHealthy) : false,
      statusMessage: isSet(object.statusMessage) ? globalThis.String(object.statusMessage) : "",
      healthDetails: isObject(object.healthDetails) ? object.healthDetails : undefined,
    };
  },

  toJSON(message: HealthCheck): unknown {
    const obj: any = {};
    if (message.serviceName !== "") {
      obj.serviceName = message.serviceName;
    }
    if (message.isHealthy !== false) {
      obj.isHealthy = message.isHealthy;
    }
    if (message.statusMessage !== "") {
      obj.statusMessage = message.statusMessage;
    }
    if (message.healthDetails !== undefined) {
      obj.healthDetails = message.healthDetails;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthCheck>, I>>(base?: I): HealthCheck {
    return HealthCheck.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthCheck>, I>>(object: I): HealthCheck {
    const message = createBaseHealthCheck();
    message.serviceName = object.serviceName ?? "";
    message.isHealthy = object.isHealthy ?? false;
    message.statusMessage = object.statusMessage ?? "";
    message.healthDetails = object.healthDetails ?? undefined;
    return message;
  },
};

function createBaseConfigUpdate(): ConfigUpdate {
  return { configKey: "", configValue: undefined, updateReason: "" };
}

export const ConfigUpdate = {
  encode(message: ConfigUpdate, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.configKey !== "") {
      writer.uint32(10).string(message.configKey);
    }
    if (message.configValue !== undefined) {
      Any.encode(message.configValue, writer.uint32(18).fork()).ldelim();
    }
    if (message.updateReason !== "") {
      writer.uint32(26).string(message.updateReason);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ConfigUpdate {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfigUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.configKey = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.configValue = Any.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateReason = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConfigUpdate {
    return {
      configKey: isSet(object.configKey) ? globalThis.String(object.configKey) : "",
      configValue: isSet(object.configValue) ? Any.fromJSON(object.configValue) : undefined,
      updateReason: isSet(object.updateReason) ? globalThis.String(object.updateReason) : "",
    };
  },

  toJSON(message: ConfigUpdate): unknown {
    const obj: any = {};
    if (message.configKey !== "") {
      obj.configKey = message.configKey;
    }
    if (message.configValue !== undefined) {
      obj.configValue = Any.toJSON(message.configValue);
    }
    if (message.updateReason !== "") {
      obj.updateReason = message.updateReason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConfigUpdate>, I>>(base?: I): ConfigUpdate {
    return ConfigUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConfigUpdate>, I>>(object: I): ConfigUpdate {
    const message = createBaseConfigUpdate();
    message.configKey = object.configKey ?? "";
    message.configValue = (object.configValue !== undefined && object.configValue !== null)
      ? Any.fromPartial(object.configValue)
      : undefined;
    message.updateReason = object.updateReason ?? "";
    return message;
  },
};

function createBaseShutdownNotice(): ShutdownNotice {
  return { serviceName: "", shutdownReason: "", gracefulShutdownSeconds: 0 };
}

export const ShutdownNotice = {
  encode(message: ShutdownNotice, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.serviceName !== "") {
      writer.uint32(10).string(message.serviceName);
    }
    if (message.shutdownReason !== "") {
      writer.uint32(18).string(message.shutdownReason);
    }
    if (message.gracefulShutdownSeconds !== 0) {
      writer.uint32(24).int32(message.gracefulShutdownSeconds);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ShutdownNotice {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShutdownNotice();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.serviceName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.shutdownReason = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.gracefulShutdownSeconds = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShutdownNotice {
    return {
      serviceName: isSet(object.serviceName) ? globalThis.String(object.serviceName) : "",
      shutdownReason: isSet(object.shutdownReason) ? globalThis.String(object.shutdownReason) : "",
      gracefulShutdownSeconds: isSet(object.gracefulShutdownSeconds)
        ? globalThis.Number(object.gracefulShutdownSeconds)
        : 0,
    };
  },

  toJSON(message: ShutdownNotice): unknown {
    const obj: any = {};
    if (message.serviceName !== "") {
      obj.serviceName = message.serviceName;
    }
    if (message.shutdownReason !== "") {
      obj.shutdownReason = message.shutdownReason;
    }
    if (message.gracefulShutdownSeconds !== 0) {
      obj.gracefulShutdownSeconds = Math.round(message.gracefulShutdownSeconds);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ShutdownNotice>, I>>(base?: I): ShutdownNotice {
    return ShutdownNotice.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ShutdownNotice>, I>>(object: I): ShutdownNotice {
    const message = createBaseShutdownNotice();
    message.serviceName = object.serviceName ?? "";
    message.shutdownReason = object.shutdownReason ?? "";
    message.gracefulShutdownSeconds = object.gracefulShutdownSeconds ?? 0;
    return message;
  },
};

function createBaseSendMessageRequest(): SendMessageRequest {
  return { message: undefined };
}

export const SendMessageRequest = {
  encode(message: SendMessageRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.message !== undefined) {
      Message.encode(message.message, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SendMessageRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendMessageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.message = Message.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendMessageRequest {
    return { message: isSet(object.message) ? Message.fromJSON(object.message) : undefined };
  },

  toJSON(message: SendMessageRequest): unknown {
    const obj: any = {};
    if (message.message !== undefined) {
      obj.message = Message.toJSON(message.message);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendMessageRequest>, I>>(base?: I): SendMessageRequest {
    return SendMessageRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendMessageRequest>, I>>(object: I): SendMessageRequest {
    const message = createBaseSendMessageRequest();
    message.message = (object.message !== undefined && object.message !== null)
      ? Message.fromPartial(object.message)
      : undefined;
    return message;
  },
};

function createBaseSendMessageResponse(): SendMessageResponse {
  return { success: false, messageId: "", status: "", errorMessage: "" };
}

export const SendMessageResponse = {
  encode(message: SendMessageResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.messageId !== "") {
      writer.uint32(18).string(message.messageId);
    }
    if (message.status !== "") {
      writer.uint32(26).string(message.status);
    }
    if (message.errorMessage !== "") {
      writer.uint32(34).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SendMessageResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendMessageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.messageId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.status = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendMessageResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      messageId: isSet(object.messageId) ? globalThis.String(object.messageId) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
    };
  },

  toJSON(message: SendMessageResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.messageId !== "") {
      obj.messageId = message.messageId;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendMessageResponse>, I>>(base?: I): SendMessageResponse {
    return SendMessageResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendMessageResponse>, I>>(object: I): SendMessageResponse {
    const message = createBaseSendMessageResponse();
    message.success = object.success ?? false;
    message.messageId = object.messageId ?? "";
    message.status = object.status ?? "";
    message.errorMessage = object.errorMessage ?? "";
    return message;
  },
};

function createBaseSendMessagesRequest(): SendMessagesRequest {
  return { messages: [], atomic: false };
}

export const SendMessagesRequest = {
  encode(message: SendMessagesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.messages) {
      Message.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.atomic !== false) {
      writer.uint32(16).bool(message.atomic);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SendMessagesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendMessagesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.messages.push(Message.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.atomic = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendMessagesRequest {
    return {
      messages: globalThis.Array.isArray(object?.messages) ? object.messages.map((e: any) => Message.fromJSON(e)) : [],
      atomic: isSet(object.atomic) ? globalThis.Boolean(object.atomic) : false,
    };
  },

  toJSON(message: SendMessagesRequest): unknown {
    const obj: any = {};
    if (message.messages?.length) {
      obj.messages = message.messages.map((e) => Message.toJSON(e));
    }
    if (message.atomic !== false) {
      obj.atomic = message.atomic;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendMessagesRequest>, I>>(base?: I): SendMessagesRequest {
    return SendMessagesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendMessagesRequest>, I>>(object: I): SendMessagesRequest {
    const message = createBaseSendMessagesRequest();
    message.messages = object.messages?.map((e) => Message.fromPartial(e)) || [];
    message.atomic = object.atomic ?? false;
    return message;
  },
};

function createBaseSendMessageResult(): SendMessageResult {
  return { messageId: "", success: false, errorMessage: "" };
}

export const SendMessageResult = {
  encode(message: SendMessageResult, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.messageId !== "") {
      writer.uint32(10).string(message.messageId);
    }
    if (message.success !== false) {
      writer.uint32(16).bool(message.success);
    }
    if (message.errorMessage !== "") {
      writer.uint32(26).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SendMessageResult {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendMessageResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.messageId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendMessageResult {
    return {
      messageId: isSet(object.messageId) ? globalThis.String(object.messageId) : "",
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
    };
  },

  toJSON(message: SendMessageResult): unknown {
    const obj: any = {};
    if (message.messageId !== "") {
      obj.messageId = message.messageId;
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendMessageResult>, I>>(base?: I): SendMessageResult {
    return SendMessageResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendMessageResult>, I>>(object: I): SendMessageResult {
    const message = createBaseSendMessageResult();
    message.messageId = object.messageId ?? "";
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? "";
    return message;
  },
};

function createBaseSendMessagesResponse(): SendMessagesResponse {
  return { success: false, results: [], successfulCount: 0, failedCount: 0 };
}

export const SendMessagesResponse = {
  encode(message: SendMessagesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    for (const v of message.results) {
      SendMessageResult.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.successfulCount !== 0) {
      writer.uint32(24).int32(message.successfulCount);
    }
    if (message.failedCount !== 0) {
      writer.uint32(32).int32(message.failedCount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SendMessagesResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendMessagesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.results.push(SendMessageResult.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.successfulCount = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.failedCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendMessagesResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      results: globalThis.Array.isArray(object?.results)
        ? object.results.map((e: any) => SendMessageResult.fromJSON(e))
        : [],
      successfulCount: isSet(object.successfulCount) ? globalThis.Number(object.successfulCount) : 0,
      failedCount: isSet(object.failedCount) ? globalThis.Number(object.failedCount) : 0,
    };
  },

  toJSON(message: SendMessagesResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.results?.length) {
      obj.results = message.results.map((e) => SendMessageResult.toJSON(e));
    }
    if (message.successfulCount !== 0) {
      obj.successfulCount = Math.round(message.successfulCount);
    }
    if (message.failedCount !== 0) {
      obj.failedCount = Math.round(message.failedCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendMessagesResponse>, I>>(base?: I): SendMessagesResponse {
    return SendMessagesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendMessagesResponse>, I>>(object: I): SendMessagesResponse {
    const message = createBaseSendMessagesResponse();
    message.success = object.success ?? false;
    message.results = object.results?.map((e) => SendMessageResult.fromPartial(e)) || [];
    message.successfulCount = object.successfulCount ?? 0;
    message.failedCount = object.failedCount ?? 0;
    return message;
  },
};

function createBaseReceiveMessagesRequest(): ReceiveMessagesRequest {
  return { serviceName: "", messageTypes: [], maxMessages: 0, waitTimeSeconds: 0 };
}

export const ReceiveMessagesRequest = {
  encode(message: ReceiveMessagesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.serviceName !== "") {
      writer.uint32(10).string(message.serviceName);
    }
    for (const v of message.messageTypes) {
      writer.uint32(18).string(v!);
    }
    if (message.maxMessages !== 0) {
      writer.uint32(24).int32(message.maxMessages);
    }
    if (message.waitTimeSeconds !== 0) {
      writer.uint32(32).int32(message.waitTimeSeconds);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ReceiveMessagesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceiveMessagesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.serviceName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.messageTypes.push(reader.string());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.maxMessages = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.waitTimeSeconds = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReceiveMessagesRequest {
    return {
      serviceName: isSet(object.serviceName) ? globalThis.String(object.serviceName) : "",
      messageTypes: globalThis.Array.isArray(object?.messageTypes)
        ? object.messageTypes.map((e: any) => globalThis.String(e))
        : [],
      maxMessages: isSet(object.maxMessages) ? globalThis.Number(object.maxMessages) : 0,
      waitTimeSeconds: isSet(object.waitTimeSeconds) ? globalThis.Number(object.waitTimeSeconds) : 0,
    };
  },

  toJSON(message: ReceiveMessagesRequest): unknown {
    const obj: any = {};
    if (message.serviceName !== "") {
      obj.serviceName = message.serviceName;
    }
    if (message.messageTypes?.length) {
      obj.messageTypes = message.messageTypes;
    }
    if (message.maxMessages !== 0) {
      obj.maxMessages = Math.round(message.maxMessages);
    }
    if (message.waitTimeSeconds !== 0) {
      obj.waitTimeSeconds = Math.round(message.waitTimeSeconds);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReceiveMessagesRequest>, I>>(base?: I): ReceiveMessagesRequest {
    return ReceiveMessagesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReceiveMessagesRequest>, I>>(object: I): ReceiveMessagesRequest {
    const message = createBaseReceiveMessagesRequest();
    message.serviceName = object.serviceName ?? "";
    message.messageTypes = object.messageTypes?.map((e) => e) || [];
    message.maxMessages = object.maxMessages ?? 0;
    message.waitTimeSeconds = object.waitTimeSeconds ?? 0;
    return message;
  },
};

function createBaseReceiveMessagesResponse(): ReceiveMessagesResponse {
  return { messages: [], receiptHandle: "" };
}

export const ReceiveMessagesResponse = {
  encode(message: ReceiveMessagesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.messages) {
      Message.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.receiptHandle !== "") {
      writer.uint32(18).string(message.receiptHandle);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ReceiveMessagesResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceiveMessagesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.messages.push(Message.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.receiptHandle = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReceiveMessagesResponse {
    return {
      messages: globalThis.Array.isArray(object?.messages) ? object.messages.map((e: any) => Message.fromJSON(e)) : [],
      receiptHandle: isSet(object.receiptHandle) ? globalThis.String(object.receiptHandle) : "",
    };
  },

  toJSON(message: ReceiveMessagesResponse): unknown {
    const obj: any = {};
    if (message.messages?.length) {
      obj.messages = message.messages.map((e) => Message.toJSON(e));
    }
    if (message.receiptHandle !== "") {
      obj.receiptHandle = message.receiptHandle;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReceiveMessagesResponse>, I>>(base?: I): ReceiveMessagesResponse {
    return ReceiveMessagesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReceiveMessagesResponse>, I>>(object: I): ReceiveMessagesResponse {
    const message = createBaseReceiveMessagesResponse();
    message.messages = object.messages?.map((e) => Message.fromPartial(e)) || [];
    message.receiptHandle = object.receiptHandle ?? "";
    return message;
  },
};

function createBaseAcknowledgeMessageRequest(): AcknowledgeMessageRequest {
  return { messageId: "", receiptHandle: "", success: false, errorMessage: "" };
}

export const AcknowledgeMessageRequest = {
  encode(message: AcknowledgeMessageRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.messageId !== "") {
      writer.uint32(10).string(message.messageId);
    }
    if (message.receiptHandle !== "") {
      writer.uint32(18).string(message.receiptHandle);
    }
    if (message.success !== false) {
      writer.uint32(24).bool(message.success);
    }
    if (message.errorMessage !== "") {
      writer.uint32(34).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AcknowledgeMessageRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAcknowledgeMessageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.messageId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.receiptHandle = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AcknowledgeMessageRequest {
    return {
      messageId: isSet(object.messageId) ? globalThis.String(object.messageId) : "",
      receiptHandle: isSet(object.receiptHandle) ? globalThis.String(object.receiptHandle) : "",
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
    };
  },

  toJSON(message: AcknowledgeMessageRequest): unknown {
    const obj: any = {};
    if (message.messageId !== "") {
      obj.messageId = message.messageId;
    }
    if (message.receiptHandle !== "") {
      obj.receiptHandle = message.receiptHandle;
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AcknowledgeMessageRequest>, I>>(base?: I): AcknowledgeMessageRequest {
    return AcknowledgeMessageRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AcknowledgeMessageRequest>, I>>(object: I): AcknowledgeMessageRequest {
    const message = createBaseAcknowledgeMessageRequest();
    message.messageId = object.messageId ?? "";
    message.receiptHandle = object.receiptHandle ?? "";
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? "";
    return message;
  },
};

function createBaseAcknowledgeMessageResponse(): AcknowledgeMessageResponse {
  return { success: false, message: "" };
}

export const AcknowledgeMessageResponse = {
  encode(message: AcknowledgeMessageResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AcknowledgeMessageResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAcknowledgeMessageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AcknowledgeMessageResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: AcknowledgeMessageResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AcknowledgeMessageResponse>, I>>(base?: I): AcknowledgeMessageResponse {
    return AcknowledgeMessageResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AcknowledgeMessageResponse>, I>>(object: I): AcknowledgeMessageResponse {
    const message = createBaseAcknowledgeMessageResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseSubscribeToMessagesRequest(): SubscribeToMessagesRequest {
  return { serviceName: "", messageTypes: [], filter: undefined };
}

export const SubscribeToMessagesRequest = {
  encode(message: SubscribeToMessagesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.serviceName !== "") {
      writer.uint32(10).string(message.serviceName);
    }
    for (const v of message.messageTypes) {
      writer.uint32(18).string(v!);
    }
    if (message.filter !== undefined) {
      MessageFilter.encode(message.filter, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubscribeToMessagesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscribeToMessagesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.serviceName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.messageTypes.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.filter = MessageFilter.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscribeToMessagesRequest {
    return {
      serviceName: isSet(object.serviceName) ? globalThis.String(object.serviceName) : "",
      messageTypes: globalThis.Array.isArray(object?.messageTypes)
        ? object.messageTypes.map((e: any) => globalThis.String(e))
        : [],
      filter: isSet(object.filter) ? MessageFilter.fromJSON(object.filter) : undefined,
    };
  },

  toJSON(message: SubscribeToMessagesRequest): unknown {
    const obj: any = {};
    if (message.serviceName !== "") {
      obj.serviceName = message.serviceName;
    }
    if (message.messageTypes?.length) {
      obj.messageTypes = message.messageTypes;
    }
    if (message.filter !== undefined) {
      obj.filter = MessageFilter.toJSON(message.filter);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubscribeToMessagesRequest>, I>>(base?: I): SubscribeToMessagesRequest {
    return SubscribeToMessagesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubscribeToMessagesRequest>, I>>(object: I): SubscribeToMessagesRequest {
    const message = createBaseSubscribeToMessagesRequest();
    message.serviceName = object.serviceName ?? "";
    message.messageTypes = object.messageTypes?.map((e) => e) || [];
    message.filter = (object.filter !== undefined && object.filter !== null)
      ? MessageFilter.fromPartial(object.filter)
      : undefined;
    return message;
  },
};

function createBaseMessageFilter(): MessageFilter {
  return { fromServices: [], userIds: [], sessionIds: [], metadataFilter: undefined };
}

export const MessageFilter = {
  encode(message: MessageFilter, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.fromServices) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.userIds) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.sessionIds) {
      writer.uint32(26).string(v!);
    }
    if (message.metadataFilter !== undefined) {
      Struct.encode(Struct.wrap(message.metadataFilter), writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MessageFilter {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fromServices.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.userIds.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sessionIds.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.metadataFilter = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageFilter {
    return {
      fromServices: globalThis.Array.isArray(object?.fromServices)
        ? object.fromServices.map((e: any) => globalThis.String(e))
        : [],
      userIds: globalThis.Array.isArray(object?.userIds) ? object.userIds.map((e: any) => globalThis.String(e)) : [],
      sessionIds: globalThis.Array.isArray(object?.sessionIds)
        ? object.sessionIds.map((e: any) => globalThis.String(e))
        : [],
      metadataFilter: isObject(object.metadataFilter) ? object.metadataFilter : undefined,
    };
  },

  toJSON(message: MessageFilter): unknown {
    const obj: any = {};
    if (message.fromServices?.length) {
      obj.fromServices = message.fromServices;
    }
    if (message.userIds?.length) {
      obj.userIds = message.userIds;
    }
    if (message.sessionIds?.length) {
      obj.sessionIds = message.sessionIds;
    }
    if (message.metadataFilter !== undefined) {
      obj.metadataFilter = message.metadataFilter;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MessageFilter>, I>>(base?: I): MessageFilter {
    return MessageFilter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MessageFilter>, I>>(object: I): MessageFilter {
    const message = createBaseMessageFilter();
    message.fromServices = object.fromServices?.map((e) => e) || [];
    message.userIds = object.userIds?.map((e) => e) || [];
    message.sessionIds = object.sessionIds?.map((e) => e) || [];
    message.metadataFilter = object.metadataFilter ?? undefined;
    return message;
  },
};

function createBaseMessageStreamResponse(): MessageStreamResponse {
  return { message: undefined, status: undefined, error: undefined };
}

export const MessageStreamResponse = {
  encode(message: MessageStreamResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.message !== undefined) {
      Message.encode(message.message, writer.uint32(10).fork()).ldelim();
    }
    if (message.status !== undefined) {
      StreamStatus.encode(message.status, writer.uint32(18).fork()).ldelim();
    }
    if (message.error !== undefined) {
      StreamError.encode(message.error, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MessageStreamResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageStreamResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.message = Message.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.status = StreamStatus.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.error = StreamError.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageStreamResponse {
    return {
      message: isSet(object.message) ? Message.fromJSON(object.message) : undefined,
      status: isSet(object.status) ? StreamStatus.fromJSON(object.status) : undefined,
      error: isSet(object.error) ? StreamError.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: MessageStreamResponse): unknown {
    const obj: any = {};
    if (message.message !== undefined) {
      obj.message = Message.toJSON(message.message);
    }
    if (message.status !== undefined) {
      obj.status = StreamStatus.toJSON(message.status);
    }
    if (message.error !== undefined) {
      obj.error = StreamError.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MessageStreamResponse>, I>>(base?: I): MessageStreamResponse {
    return MessageStreamResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MessageStreamResponse>, I>>(object: I): MessageStreamResponse {
    const message = createBaseMessageStreamResponse();
    message.message = (object.message !== undefined && object.message !== null)
      ? Message.fromPartial(object.message)
      : undefined;
    message.status = (object.status !== undefined && object.status !== null)
      ? StreamStatus.fromPartial(object.status)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null)
      ? StreamError.fromPartial(object.error)
      : undefined;
    return message;
  },
};

function createBaseStreamStatus(): StreamStatus {
  return { status: "", messagesReceived: 0 };
}

export const StreamStatus = {
  encode(message: StreamStatus, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.status !== "") {
      writer.uint32(10).string(message.status);
    }
    if (message.messagesReceived !== 0) {
      writer.uint32(16).int32(message.messagesReceived);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamStatus {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.status = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.messagesReceived = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamStatus {
    return {
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      messagesReceived: isSet(object.messagesReceived) ? globalThis.Number(object.messagesReceived) : 0,
    };
  },

  toJSON(message: StreamStatus): unknown {
    const obj: any = {};
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.messagesReceived !== 0) {
      obj.messagesReceived = Math.round(message.messagesReceived);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamStatus>, I>>(base?: I): StreamStatus {
    return StreamStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamStatus>, I>>(object: I): StreamStatus {
    const message = createBaseStreamStatus();
    message.status = object.status ?? "";
    message.messagesReceived = object.messagesReceived ?? 0;
    return message;
  },
};

function createBaseStreamError(): StreamError {
  return { errorCode: "", errorMessage: "", isRecoverable: false };
}

export const StreamError = {
  encode(message: StreamError, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.errorCode !== "") {
      writer.uint32(10).string(message.errorCode);
    }
    if (message.errorMessage !== "") {
      writer.uint32(18).string(message.errorMessage);
    }
    if (message.isRecoverable !== false) {
      writer.uint32(24).bool(message.isRecoverable);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamError {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.errorCode = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.isRecoverable = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamError {
    return {
      errorCode: isSet(object.errorCode) ? globalThis.String(object.errorCode) : "",
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
      isRecoverable: isSet(object.isRecoverable) ? globalThis.Boolean(object.isRecoverable) : false,
    };
  },

  toJSON(message: StreamError): unknown {
    const obj: any = {};
    if (message.errorCode !== "") {
      obj.errorCode = message.errorCode;
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    if (message.isRecoverable !== false) {
      obj.isRecoverable = message.isRecoverable;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamError>, I>>(base?: I): StreamError {
    return StreamError.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamError>, I>>(object: I): StreamError {
    const message = createBaseStreamError();
    message.errorCode = object.errorCode ?? "";
    message.errorMessage = object.errorMessage ?? "";
    message.isRecoverable = object.isRecoverable ?? false;
    return message;
  },
};

export type MessagingServiceService = typeof MessagingServiceService;
export const MessagingServiceService = {
  /** Message sending */
  sendMessage: {
    path: "/unhinged.messaging.MessagingService/SendMessage",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SendMessageRequest) => Buffer.from(SendMessageRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SendMessageRequest.decode(value),
    responseSerialize: (value: SendMessageResponse) => Buffer.from(SendMessageResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SendMessageResponse.decode(value),
  },
  sendMessages: {
    path: "/unhinged.messaging.MessagingService/SendMessages",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SendMessagesRequest) => Buffer.from(SendMessagesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SendMessagesRequest.decode(value),
    responseSerialize: (value: SendMessagesResponse) => Buffer.from(SendMessagesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SendMessagesResponse.decode(value),
  },
  /** Message receiving (polling) */
  receiveMessages: {
    path: "/unhinged.messaging.MessagingService/ReceiveMessages",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ReceiveMessagesRequest) => Buffer.from(ReceiveMessagesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ReceiveMessagesRequest.decode(value),
    responseSerialize: (value: ReceiveMessagesResponse) => Buffer.from(ReceiveMessagesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ReceiveMessagesResponse.decode(value),
  },
  acknowledgeMessage: {
    path: "/unhinged.messaging.MessagingService/AcknowledgeMessage",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AcknowledgeMessageRequest) =>
      Buffer.from(AcknowledgeMessageRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => AcknowledgeMessageRequest.decode(value),
    responseSerialize: (value: AcknowledgeMessageResponse) =>
      Buffer.from(AcknowledgeMessageResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AcknowledgeMessageResponse.decode(value),
  },
  /** Message streaming */
  subscribeToMessages: {
    path: "/unhinged.messaging.MessagingService/SubscribeToMessages",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: SubscribeToMessagesRequest) =>
      Buffer.from(SubscribeToMessagesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SubscribeToMessagesRequest.decode(value),
    responseSerialize: (value: MessageStreamResponse) => Buffer.from(MessageStreamResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => MessageStreamResponse.decode(value),
  },
} as const;

export interface MessagingServiceServer extends UntypedServiceImplementation {
  /** Message sending */
  sendMessage: handleUnaryCall<SendMessageRequest, SendMessageResponse>;
  sendMessages: handleUnaryCall<SendMessagesRequest, SendMessagesResponse>;
  /** Message receiving (polling) */
  receiveMessages: handleUnaryCall<ReceiveMessagesRequest, ReceiveMessagesResponse>;
  acknowledgeMessage: handleUnaryCall<AcknowledgeMessageRequest, AcknowledgeMessageResponse>;
  /** Message streaming */
  subscribeToMessages: handleServerStreamingCall<SubscribeToMessagesRequest, MessageStreamResponse>;
}

export interface MessagingServiceClient extends Client {
  /** Message sending */
  sendMessage(
    request: SendMessageRequest,
    callback: (error: ServiceError | null, response: SendMessageResponse) => void,
  ): ClientUnaryCall;
  sendMessage(
    request: SendMessageRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SendMessageResponse) => void,
  ): ClientUnaryCall;
  sendMessage(
    request: SendMessageRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SendMessageResponse) => void,
  ): ClientUnaryCall;
  sendMessages(
    request: SendMessagesRequest,
    callback: (error: ServiceError | null, response: SendMessagesResponse) => void,
  ): ClientUnaryCall;
  sendMessages(
    request: SendMessagesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SendMessagesResponse) => void,
  ): ClientUnaryCall;
  sendMessages(
    request: SendMessagesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SendMessagesResponse) => void,
  ): ClientUnaryCall;
  /** Message receiving (polling) */
  receiveMessages(
    request: ReceiveMessagesRequest,
    callback: (error: ServiceError | null, response: ReceiveMessagesResponse) => void,
  ): ClientUnaryCall;
  receiveMessages(
    request: ReceiveMessagesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ReceiveMessagesResponse) => void,
  ): ClientUnaryCall;
  receiveMessages(
    request: ReceiveMessagesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ReceiveMessagesResponse) => void,
  ): ClientUnaryCall;
  acknowledgeMessage(
    request: AcknowledgeMessageRequest,
    callback: (error: ServiceError | null, response: AcknowledgeMessageResponse) => void,
  ): ClientUnaryCall;
  acknowledgeMessage(
    request: AcknowledgeMessageRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: AcknowledgeMessageResponse) => void,
  ): ClientUnaryCall;
  acknowledgeMessage(
    request: AcknowledgeMessageRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: AcknowledgeMessageResponse) => void,
  ): ClientUnaryCall;
  /** Message streaming */
  subscribeToMessages(
    request: SubscribeToMessagesRequest,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<MessageStreamResponse>;
  subscribeToMessages(
    request: SubscribeToMessagesRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<MessageStreamResponse>;
}

export const MessagingServiceClient = makeGenericClientConstructor(
  MessagingServiceService,
  "unhinged.messaging.MessagingService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): MessagingServiceClient;
  service: typeof MessagingServiceService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000).toString();
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (globalThis.Number(t.seconds) || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
