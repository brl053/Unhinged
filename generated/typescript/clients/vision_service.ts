// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v3.21.12
// source: vision_service.proto

/* eslint-disable */
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import Long from "long";
import _m0 from "protobufjs/minimal";

/** Request for vision inference */
export interface VisionInferenceRequest {
  /** Raw image data (JPEG, PNG, etc.) */
  imageData: Uint8Array;
  /** Model to use for inference (e.g., "qwen2-vl", "blip-base") */
  model: string;
  /** Analysis prompt for the model */
  prompt: string;
  /** Type of analysis (screenshot, natural_image, document, ui_component) */
  analysisType: string;
  /** Maximum tokens for response */
  maxTokens: number;
  /** Temperature for generation (0.0 to 1.0) */
  temperature: number;
  /** Additional inference parameters */
  parameters: { [key: string]: string };
}

export interface VisionInferenceRequest_ParametersEntry {
  key: string;
  value: string;
}

/** Response from vision inference */
export interface VisionInferenceResponse {
  /** Generated description of the image */
  description: string;
  /** Confidence score (0.0 to 1.0) */
  confidence: number;
  /** Model that was actually used */
  modelUsed: string;
  /** Processing time in seconds */
  processingTime: number;
  /** Additional metadata from inference */
  metadata: { [key: string]: string };
  /** Extracted text from OCR (if applicable) */
  extractedText: string;
  /** Detected UI elements */
  uiElements: UIElement[];
  /** Generated tags/labels */
  tags: string[];
  /** Error message if inference failed */
  error: string;
  /** Success status */
  success: boolean;
}

export interface VisionInferenceResponse_MetadataEntry {
  key: string;
  value: string;
}

/** UI element detected in image */
export interface UIElement {
  /** Type of UI element (button, input, text, etc.) */
  type: string;
  /** Confidence of detection (0.0 to 1.0) */
  confidence: number;
  /** Bounding box coordinates */
  bounds?:
    | ElementBounds
    | undefined;
  /** Additional properties */
  properties: { [key: string]: string };
}

export interface UIElement_PropertiesEntry {
  key: string;
  value: string;
}

/** Bounding box for UI elements */
export interface ElementBounds {
  x: number;
  y: number;
  width: number;
  height: number;
}

/** Response with available models */
export interface ModelsResponse {
  models: ModelInfo[];
}

/** Information about a vision model */
export interface ModelInfo {
  name: string;
  displayName: string;
  description: string;
  available: boolean;
  memoryUsageMb: string;
  supportedTypes: string[];
}

/** Request for model metrics */
export interface ModelMetricsRequest {
  model: string;
}

/** Response with model performance metrics */
export interface ModelMetricsResponse {
  model: string;
  totalInferences: string;
  averageProcessingTime: number;
  averageConfidence: number;
  memoryUsageMb: string;
  gpuUtilization: number;
  additionalMetrics: { [key: string]: number };
}

export interface ModelMetricsResponse_AdditionalMetricsEntry {
  key: string;
  value: number;
}

/** Empty message for requests with no parameters */
export interface Empty {
}

/** Health check response - using simplified version for now */
export interface HealthResponse {
  healthy: boolean;
  status: string;
  details: { [key: string]: string };
  uptimeSeconds: string;
  version: string;
}

export interface HealthResponse_DetailsEntry {
  key: string;
  value: string;
}

function createBaseVisionInferenceRequest(): VisionInferenceRequest {
  return {
    imageData: new Uint8Array(0),
    model: "",
    prompt: "",
    analysisType: "",
    maxTokens: 0,
    temperature: 0,
    parameters: {},
  };
}

export const VisionInferenceRequest = {
  encode(message: VisionInferenceRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.imageData.length !== 0) {
      writer.uint32(10).bytes(message.imageData);
    }
    if (message.model !== "") {
      writer.uint32(18).string(message.model);
    }
    if (message.prompt !== "") {
      writer.uint32(26).string(message.prompt);
    }
    if (message.analysisType !== "") {
      writer.uint32(34).string(message.analysisType);
    }
    if (message.maxTokens !== 0) {
      writer.uint32(40).int32(message.maxTokens);
    }
    if (message.temperature !== 0) {
      writer.uint32(53).float(message.temperature);
    }
    Object.entries(message.parameters).forEach(([key, value]) => {
      VisionInferenceRequest_ParametersEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): VisionInferenceRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVisionInferenceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.imageData = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.model = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.prompt = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.analysisType = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.maxTokens = reader.int32();
          continue;
        case 6:
          if (tag !== 53) {
            break;
          }

          message.temperature = reader.float();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          const entry7 = VisionInferenceRequest_ParametersEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.parameters[entry7.key] = entry7.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VisionInferenceRequest {
    return {
      imageData: isSet(object.imageData) ? bytesFromBase64(object.imageData) : new Uint8Array(0),
      model: isSet(object.model) ? globalThis.String(object.model) : "",
      prompt: isSet(object.prompt) ? globalThis.String(object.prompt) : "",
      analysisType: isSet(object.analysisType) ? globalThis.String(object.analysisType) : "",
      maxTokens: isSet(object.maxTokens) ? globalThis.Number(object.maxTokens) : 0,
      temperature: isSet(object.temperature) ? globalThis.Number(object.temperature) : 0,
      parameters: isObject(object.parameters)
        ? Object.entries(object.parameters).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: VisionInferenceRequest): unknown {
    const obj: any = {};
    if (message.imageData.length !== 0) {
      obj.imageData = base64FromBytes(message.imageData);
    }
    if (message.model !== "") {
      obj.model = message.model;
    }
    if (message.prompt !== "") {
      obj.prompt = message.prompt;
    }
    if (message.analysisType !== "") {
      obj.analysisType = message.analysisType;
    }
    if (message.maxTokens !== 0) {
      obj.maxTokens = Math.round(message.maxTokens);
    }
    if (message.temperature !== 0) {
      obj.temperature = message.temperature;
    }
    if (message.parameters) {
      const entries = Object.entries(message.parameters);
      if (entries.length > 0) {
        obj.parameters = {};
        entries.forEach(([k, v]) => {
          obj.parameters[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VisionInferenceRequest>, I>>(base?: I): VisionInferenceRequest {
    return VisionInferenceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VisionInferenceRequest>, I>>(object: I): VisionInferenceRequest {
    const message = createBaseVisionInferenceRequest();
    message.imageData = object.imageData ?? new Uint8Array(0);
    message.model = object.model ?? "";
    message.prompt = object.prompt ?? "";
    message.analysisType = object.analysisType ?? "";
    message.maxTokens = object.maxTokens ?? 0;
    message.temperature = object.temperature ?? 0;
    message.parameters = Object.entries(object.parameters ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseVisionInferenceRequest_ParametersEntry(): VisionInferenceRequest_ParametersEntry {
  return { key: "", value: "" };
}

export const VisionInferenceRequest_ParametersEntry = {
  encode(message: VisionInferenceRequest_ParametersEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): VisionInferenceRequest_ParametersEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVisionInferenceRequest_ParametersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VisionInferenceRequest_ParametersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: VisionInferenceRequest_ParametersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VisionInferenceRequest_ParametersEntry>, I>>(
    base?: I,
  ): VisionInferenceRequest_ParametersEntry {
    return VisionInferenceRequest_ParametersEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VisionInferenceRequest_ParametersEntry>, I>>(
    object: I,
  ): VisionInferenceRequest_ParametersEntry {
    const message = createBaseVisionInferenceRequest_ParametersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseVisionInferenceResponse(): VisionInferenceResponse {
  return {
    description: "",
    confidence: 0,
    modelUsed: "",
    processingTime: 0,
    metadata: {},
    extractedText: "",
    uiElements: [],
    tags: [],
    error: "",
    success: false,
  };
}

export const VisionInferenceResponse = {
  encode(message: VisionInferenceResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.description !== "") {
      writer.uint32(10).string(message.description);
    }
    if (message.confidence !== 0) {
      writer.uint32(17).double(message.confidence);
    }
    if (message.modelUsed !== "") {
      writer.uint32(26).string(message.modelUsed);
    }
    if (message.processingTime !== 0) {
      writer.uint32(33).double(message.processingTime);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      VisionInferenceResponse_MetadataEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).ldelim();
    });
    if (message.extractedText !== "") {
      writer.uint32(50).string(message.extractedText);
    }
    for (const v of message.uiElements) {
      UIElement.encode(v!, writer.uint32(58).fork()).ldelim();
    }
    for (const v of message.tags) {
      writer.uint32(66).string(v!);
    }
    if (message.error !== "") {
      writer.uint32(74).string(message.error);
    }
    if (message.success !== false) {
      writer.uint32(80).bool(message.success);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): VisionInferenceResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVisionInferenceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.description = reader.string();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.confidence = reader.double();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.modelUsed = reader.string();
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.processingTime = reader.double();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = VisionInferenceResponse_MetadataEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.metadata[entry5.key] = entry5.value;
          }
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.extractedText = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.uiElements.push(UIElement.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.error = reader.string();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.success = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VisionInferenceResponse {
    return {
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : 0,
      modelUsed: isSet(object.modelUsed) ? globalThis.String(object.modelUsed) : "",
      processingTime: isSet(object.processingTime) ? globalThis.Number(object.processingTime) : 0,
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      extractedText: isSet(object.extractedText) ? globalThis.String(object.extractedText) : "",
      uiElements: globalThis.Array.isArray(object?.uiElements)
        ? object.uiElements.map((e: any) => UIElement.fromJSON(e))
        : [],
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      error: isSet(object.error) ? globalThis.String(object.error) : "",
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
    };
  },

  toJSON(message: VisionInferenceResponse): unknown {
    const obj: any = {};
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.confidence !== 0) {
      obj.confidence = message.confidence;
    }
    if (message.modelUsed !== "") {
      obj.modelUsed = message.modelUsed;
    }
    if (message.processingTime !== 0) {
      obj.processingTime = message.processingTime;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.extractedText !== "") {
      obj.extractedText = message.extractedText;
    }
    if (message.uiElements?.length) {
      obj.uiElements = message.uiElements.map((e) => UIElement.toJSON(e));
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VisionInferenceResponse>, I>>(base?: I): VisionInferenceResponse {
    return VisionInferenceResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VisionInferenceResponse>, I>>(object: I): VisionInferenceResponse {
    const message = createBaseVisionInferenceResponse();
    message.description = object.description ?? "";
    message.confidence = object.confidence ?? 0;
    message.modelUsed = object.modelUsed ?? "";
    message.processingTime = object.processingTime ?? 0;
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.extractedText = object.extractedText ?? "";
    message.uiElements = object.uiElements?.map((e) => UIElement.fromPartial(e)) || [];
    message.tags = object.tags?.map((e) => e) || [];
    message.error = object.error ?? "";
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseVisionInferenceResponse_MetadataEntry(): VisionInferenceResponse_MetadataEntry {
  return { key: "", value: "" };
}

export const VisionInferenceResponse_MetadataEntry = {
  encode(message: VisionInferenceResponse_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): VisionInferenceResponse_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVisionInferenceResponse_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VisionInferenceResponse_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: VisionInferenceResponse_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VisionInferenceResponse_MetadataEntry>, I>>(
    base?: I,
  ): VisionInferenceResponse_MetadataEntry {
    return VisionInferenceResponse_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VisionInferenceResponse_MetadataEntry>, I>>(
    object: I,
  ): VisionInferenceResponse_MetadataEntry {
    const message = createBaseVisionInferenceResponse_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseUIElement(): UIElement {
  return { type: "", confidence: 0, bounds: undefined, properties: {} };
}

export const UIElement = {
  encode(message: UIElement, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.confidence !== 0) {
      writer.uint32(17).double(message.confidence);
    }
    if (message.bounds !== undefined) {
      ElementBounds.encode(message.bounds, writer.uint32(26).fork()).ldelim();
    }
    Object.entries(message.properties).forEach(([key, value]) => {
      UIElement_PropertiesEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UIElement {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUIElement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.confidence = reader.double();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.bounds = ElementBounds.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = UIElement_PropertiesEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.properties[entry4.key] = entry4.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UIElement {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : 0,
      bounds: isSet(object.bounds) ? ElementBounds.fromJSON(object.bounds) : undefined,
      properties: isObject(object.properties)
        ? Object.entries(object.properties).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: UIElement): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.confidence !== 0) {
      obj.confidence = message.confidence;
    }
    if (message.bounds !== undefined) {
      obj.bounds = ElementBounds.toJSON(message.bounds);
    }
    if (message.properties) {
      const entries = Object.entries(message.properties);
      if (entries.length > 0) {
        obj.properties = {};
        entries.forEach(([k, v]) => {
          obj.properties[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UIElement>, I>>(base?: I): UIElement {
    return UIElement.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UIElement>, I>>(object: I): UIElement {
    const message = createBaseUIElement();
    message.type = object.type ?? "";
    message.confidence = object.confidence ?? 0;
    message.bounds = (object.bounds !== undefined && object.bounds !== null)
      ? ElementBounds.fromPartial(object.bounds)
      : undefined;
    message.properties = Object.entries(object.properties ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseUIElement_PropertiesEntry(): UIElement_PropertiesEntry {
  return { key: "", value: "" };
}

export const UIElement_PropertiesEntry = {
  encode(message: UIElement_PropertiesEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UIElement_PropertiesEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUIElement_PropertiesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UIElement_PropertiesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: UIElement_PropertiesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UIElement_PropertiesEntry>, I>>(base?: I): UIElement_PropertiesEntry {
    return UIElement_PropertiesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UIElement_PropertiesEntry>, I>>(object: I): UIElement_PropertiesEntry {
    const message = createBaseUIElement_PropertiesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseElementBounds(): ElementBounds {
  return { x: 0, y: 0, width: 0, height: 0 };
}

export const ElementBounds = {
  encode(message: ElementBounds, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.x !== 0) {
      writer.uint32(8).int32(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(16).int32(message.y);
    }
    if (message.width !== 0) {
      writer.uint32(24).int32(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(32).int32(message.height);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ElementBounds {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseElementBounds();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.x = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.y = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.width = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.height = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ElementBounds {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
    };
  },

  toJSON(message: ElementBounds): unknown {
    const obj: any = {};
    if (message.x !== 0) {
      obj.x = Math.round(message.x);
    }
    if (message.y !== 0) {
      obj.y = Math.round(message.y);
    }
    if (message.width !== 0) {
      obj.width = Math.round(message.width);
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ElementBounds>, I>>(base?: I): ElementBounds {
    return ElementBounds.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ElementBounds>, I>>(object: I): ElementBounds {
    const message = createBaseElementBounds();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    message.width = object.width ?? 0;
    message.height = object.height ?? 0;
    return message;
  },
};

function createBaseModelsResponse(): ModelsResponse {
  return { models: [] };
}

export const ModelsResponse = {
  encode(message: ModelsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.models) {
      ModelInfo.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ModelsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.models.push(ModelInfo.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelsResponse {
    return {
      models: globalThis.Array.isArray(object?.models) ? object.models.map((e: any) => ModelInfo.fromJSON(e)) : [],
    };
  },

  toJSON(message: ModelsResponse): unknown {
    const obj: any = {};
    if (message.models?.length) {
      obj.models = message.models.map((e) => ModelInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ModelsResponse>, I>>(base?: I): ModelsResponse {
    return ModelsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ModelsResponse>, I>>(object: I): ModelsResponse {
    const message = createBaseModelsResponse();
    message.models = object.models?.map((e) => ModelInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseModelInfo(): ModelInfo {
  return { name: "", displayName: "", description: "", available: false, memoryUsageMb: "0", supportedTypes: [] };
}

export const ModelInfo = {
  encode(message: ModelInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.available !== false) {
      writer.uint32(32).bool(message.available);
    }
    if (message.memoryUsageMb !== "0") {
      writer.uint32(40).int64(message.memoryUsageMb);
    }
    for (const v of message.supportedTypes) {
      writer.uint32(50).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ModelInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.available = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.memoryUsageMb = longToString(reader.int64() as Long);
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.supportedTypes.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelInfo {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      available: isSet(object.available) ? globalThis.Boolean(object.available) : false,
      memoryUsageMb: isSet(object.memoryUsageMb) ? globalThis.String(object.memoryUsageMb) : "0",
      supportedTypes: globalThis.Array.isArray(object?.supportedTypes)
        ? object.supportedTypes.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ModelInfo): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.available !== false) {
      obj.available = message.available;
    }
    if (message.memoryUsageMb !== "0") {
      obj.memoryUsageMb = message.memoryUsageMb;
    }
    if (message.supportedTypes?.length) {
      obj.supportedTypes = message.supportedTypes;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ModelInfo>, I>>(base?: I): ModelInfo {
    return ModelInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ModelInfo>, I>>(object: I): ModelInfo {
    const message = createBaseModelInfo();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.available = object.available ?? false;
    message.memoryUsageMb = object.memoryUsageMb ?? "0";
    message.supportedTypes = object.supportedTypes?.map((e) => e) || [];
    return message;
  },
};

function createBaseModelMetricsRequest(): ModelMetricsRequest {
  return { model: "" };
}

export const ModelMetricsRequest = {
  encode(message: ModelMetricsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.model !== "") {
      writer.uint32(10).string(message.model);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ModelMetricsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelMetricsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.model = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelMetricsRequest {
    return { model: isSet(object.model) ? globalThis.String(object.model) : "" };
  },

  toJSON(message: ModelMetricsRequest): unknown {
    const obj: any = {};
    if (message.model !== "") {
      obj.model = message.model;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ModelMetricsRequest>, I>>(base?: I): ModelMetricsRequest {
    return ModelMetricsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ModelMetricsRequest>, I>>(object: I): ModelMetricsRequest {
    const message = createBaseModelMetricsRequest();
    message.model = object.model ?? "";
    return message;
  },
};

function createBaseModelMetricsResponse(): ModelMetricsResponse {
  return {
    model: "",
    totalInferences: "0",
    averageProcessingTime: 0,
    averageConfidence: 0,
    memoryUsageMb: "0",
    gpuUtilization: 0,
    additionalMetrics: {},
  };
}

export const ModelMetricsResponse = {
  encode(message: ModelMetricsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.model !== "") {
      writer.uint32(10).string(message.model);
    }
    if (message.totalInferences !== "0") {
      writer.uint32(16).int64(message.totalInferences);
    }
    if (message.averageProcessingTime !== 0) {
      writer.uint32(25).double(message.averageProcessingTime);
    }
    if (message.averageConfidence !== 0) {
      writer.uint32(33).double(message.averageConfidence);
    }
    if (message.memoryUsageMb !== "0") {
      writer.uint32(40).int64(message.memoryUsageMb);
    }
    if (message.gpuUtilization !== 0) {
      writer.uint32(49).double(message.gpuUtilization);
    }
    Object.entries(message.additionalMetrics).forEach(([key, value]) => {
      ModelMetricsResponse_AdditionalMetricsEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ModelMetricsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelMetricsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.model = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.totalInferences = longToString(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.averageProcessingTime = reader.double();
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.averageConfidence = reader.double();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.memoryUsageMb = longToString(reader.int64() as Long);
          continue;
        case 6:
          if (tag !== 49) {
            break;
          }

          message.gpuUtilization = reader.double();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          const entry7 = ModelMetricsResponse_AdditionalMetricsEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.additionalMetrics[entry7.key] = entry7.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelMetricsResponse {
    return {
      model: isSet(object.model) ? globalThis.String(object.model) : "",
      totalInferences: isSet(object.totalInferences) ? globalThis.String(object.totalInferences) : "0",
      averageProcessingTime: isSet(object.averageProcessingTime) ? globalThis.Number(object.averageProcessingTime) : 0,
      averageConfidence: isSet(object.averageConfidence) ? globalThis.Number(object.averageConfidence) : 0,
      memoryUsageMb: isSet(object.memoryUsageMb) ? globalThis.String(object.memoryUsageMb) : "0",
      gpuUtilization: isSet(object.gpuUtilization) ? globalThis.Number(object.gpuUtilization) : 0,
      additionalMetrics: isObject(object.additionalMetrics)
        ? Object.entries(object.additionalMetrics).reduce<{ [key: string]: number }>((acc, [key, value]) => {
          acc[key] = Number(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ModelMetricsResponse): unknown {
    const obj: any = {};
    if (message.model !== "") {
      obj.model = message.model;
    }
    if (message.totalInferences !== "0") {
      obj.totalInferences = message.totalInferences;
    }
    if (message.averageProcessingTime !== 0) {
      obj.averageProcessingTime = message.averageProcessingTime;
    }
    if (message.averageConfidence !== 0) {
      obj.averageConfidence = message.averageConfidence;
    }
    if (message.memoryUsageMb !== "0") {
      obj.memoryUsageMb = message.memoryUsageMb;
    }
    if (message.gpuUtilization !== 0) {
      obj.gpuUtilization = message.gpuUtilization;
    }
    if (message.additionalMetrics) {
      const entries = Object.entries(message.additionalMetrics);
      if (entries.length > 0) {
        obj.additionalMetrics = {};
        entries.forEach(([k, v]) => {
          obj.additionalMetrics[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ModelMetricsResponse>, I>>(base?: I): ModelMetricsResponse {
    return ModelMetricsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ModelMetricsResponse>, I>>(object: I): ModelMetricsResponse {
    const message = createBaseModelMetricsResponse();
    message.model = object.model ?? "";
    message.totalInferences = object.totalInferences ?? "0";
    message.averageProcessingTime = object.averageProcessingTime ?? 0;
    message.averageConfidence = object.averageConfidence ?? 0;
    message.memoryUsageMb = object.memoryUsageMb ?? "0";
    message.gpuUtilization = object.gpuUtilization ?? 0;
    message.additionalMetrics = Object.entries(object.additionalMetrics ?? {}).reduce<{ [key: string]: number }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.Number(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseModelMetricsResponse_AdditionalMetricsEntry(): ModelMetricsResponse_AdditionalMetricsEntry {
  return { key: "", value: 0 };
}

export const ModelMetricsResponse_AdditionalMetricsEntry = {
  encode(message: ModelMetricsResponse_AdditionalMetricsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(17).double(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ModelMetricsResponse_AdditionalMetricsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelMetricsResponse_AdditionalMetricsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.value = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelMetricsResponse_AdditionalMetricsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: ModelMetricsResponse_AdditionalMetricsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ModelMetricsResponse_AdditionalMetricsEntry>, I>>(
    base?: I,
  ): ModelMetricsResponse_AdditionalMetricsEntry {
    return ModelMetricsResponse_AdditionalMetricsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ModelMetricsResponse_AdditionalMetricsEntry>, I>>(
    object: I,
  ): ModelMetricsResponse_AdditionalMetricsEntry {
    const message = createBaseModelMetricsResponse_AdditionalMetricsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseEmpty(): Empty {
  return {};
}

export const Empty = {
  encode(_: Empty, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Empty {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmpty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Empty {
    return {};
  },

  toJSON(_: Empty): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<Empty>, I>>(base?: I): Empty {
    return Empty.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Empty>, I>>(_: I): Empty {
    const message = createBaseEmpty();
    return message;
  },
};

function createBaseHealthResponse(): HealthResponse {
  return { healthy: false, status: "", details: {}, uptimeSeconds: "0", version: "" };
}

export const HealthResponse = {
  encode(message: HealthResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.healthy !== false) {
      writer.uint32(8).bool(message.healthy);
    }
    if (message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    Object.entries(message.details).forEach(([key, value]) => {
      HealthResponse_DetailsEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).ldelim();
    });
    if (message.uptimeSeconds !== "0") {
      writer.uint32(32).int64(message.uptimeSeconds);
    }
    if (message.version !== "") {
      writer.uint32(42).string(message.version);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HealthResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.healthy = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = HealthResponse_DetailsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.details[entry3.key] = entry3.value;
          }
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.uptimeSeconds = longToString(reader.int64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.version = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthResponse {
    return {
      healthy: isSet(object.healthy) ? globalThis.Boolean(object.healthy) : false,
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      details: isObject(object.details)
        ? Object.entries(object.details).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      uptimeSeconds: isSet(object.uptimeSeconds) ? globalThis.String(object.uptimeSeconds) : "0",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
    };
  },

  toJSON(message: HealthResponse): unknown {
    const obj: any = {};
    if (message.healthy !== false) {
      obj.healthy = message.healthy;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.details) {
      const entries = Object.entries(message.details);
      if (entries.length > 0) {
        obj.details = {};
        entries.forEach(([k, v]) => {
          obj.details[k] = v;
        });
      }
    }
    if (message.uptimeSeconds !== "0") {
      obj.uptimeSeconds = message.uptimeSeconds;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthResponse>, I>>(base?: I): HealthResponse {
    return HealthResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthResponse>, I>>(object: I): HealthResponse {
    const message = createBaseHealthResponse();
    message.healthy = object.healthy ?? false;
    message.status = object.status ?? "";
    message.details = Object.entries(object.details ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.uptimeSeconds = object.uptimeSeconds ?? "0";
    message.version = object.version ?? "";
    return message;
  },
};

function createBaseHealthResponse_DetailsEntry(): HealthResponse_DetailsEntry {
  return { key: "", value: "" };
}

export const HealthResponse_DetailsEntry = {
  encode(message: HealthResponse_DetailsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HealthResponse_DetailsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthResponse_DetailsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthResponse_DetailsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: HealthResponse_DetailsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthResponse_DetailsEntry>, I>>(base?: I): HealthResponse_DetailsEntry {
    return HealthResponse_DetailsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthResponse_DetailsEntry>, I>>(object: I): HealthResponse_DetailsEntry {
    const message = createBaseHealthResponse_DetailsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

/** Vision AI Service - Pure model inference operations */
export type VisionServiceService = typeof VisionServiceService;
export const VisionServiceService = {
  /** Perform image inference using specified model */
  infer: {
    path: "/multimodal.VisionService/Infer",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: VisionInferenceRequest) => Buffer.from(VisionInferenceRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => VisionInferenceRequest.decode(value),
    responseSerialize: (value: VisionInferenceResponse) => Buffer.from(VisionInferenceResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => VisionInferenceResponse.decode(value),
  },
  /** Get list of available vision models */
  getAvailableModels: {
    path: "/multimodal.VisionService/GetAvailableModels",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Empty.decode(value),
    responseSerialize: (value: ModelsResponse) => Buffer.from(ModelsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ModelsResponse.decode(value),
  },
  /** Health check for service availability */
  getHealth: {
    path: "/multimodal.VisionService/GetHealth",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Empty.decode(value),
    responseSerialize: (value: HealthResponse) => Buffer.from(HealthResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => HealthResponse.decode(value),
  },
  /** Get model performance metrics */
  getModelMetrics: {
    path: "/multimodal.VisionService/GetModelMetrics",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ModelMetricsRequest) => Buffer.from(ModelMetricsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ModelMetricsRequest.decode(value),
    responseSerialize: (value: ModelMetricsResponse) => Buffer.from(ModelMetricsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ModelMetricsResponse.decode(value),
  },
} as const;

export interface VisionServiceServer extends UntypedServiceImplementation {
  /** Perform image inference using specified model */
  infer: handleUnaryCall<VisionInferenceRequest, VisionInferenceResponse>;
  /** Get list of available vision models */
  getAvailableModels: handleUnaryCall<Empty, ModelsResponse>;
  /** Health check for service availability */
  getHealth: handleUnaryCall<Empty, HealthResponse>;
  /** Get model performance metrics */
  getModelMetrics: handleUnaryCall<ModelMetricsRequest, ModelMetricsResponse>;
}

export interface VisionServiceClient extends Client {
  /** Perform image inference using specified model */
  infer(
    request: VisionInferenceRequest,
    callback: (error: ServiceError | null, response: VisionInferenceResponse) => void,
  ): ClientUnaryCall;
  infer(
    request: VisionInferenceRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: VisionInferenceResponse) => void,
  ): ClientUnaryCall;
  infer(
    request: VisionInferenceRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: VisionInferenceResponse) => void,
  ): ClientUnaryCall;
  /** Get list of available vision models */
  getAvailableModels(
    request: Empty,
    callback: (error: ServiceError | null, response: ModelsResponse) => void,
  ): ClientUnaryCall;
  getAvailableModels(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ModelsResponse) => void,
  ): ClientUnaryCall;
  getAvailableModels(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ModelsResponse) => void,
  ): ClientUnaryCall;
  /** Health check for service availability */
  getHealth(request: Empty, callback: (error: ServiceError | null, response: HealthResponse) => void): ClientUnaryCall;
  getHealth(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: HealthResponse) => void,
  ): ClientUnaryCall;
  getHealth(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: HealthResponse) => void,
  ): ClientUnaryCall;
  /** Get model performance metrics */
  getModelMetrics(
    request: ModelMetricsRequest,
    callback: (error: ServiceError | null, response: ModelMetricsResponse) => void,
  ): ClientUnaryCall;
  getModelMetrics(
    request: ModelMetricsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ModelMetricsResponse) => void,
  ): ClientUnaryCall;
  getModelMetrics(
    request: ModelMetricsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ModelMetricsResponse) => void,
  ): ClientUnaryCall;
}

export const VisionServiceClient = makeGenericClientConstructor(
  VisionServiceService,
  "multimodal.VisionService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): VisionServiceClient;
  service: typeof VisionServiceService;
  serviceName: string;
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToString(long: Long) {
  return long.toString();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
