// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v3.21.12
// source: observability.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Struct } from "./google/protobuf/struct";
import { Timestamp } from "./google/protobuf/timestamp";

/** Log levels matching OpenTelemetry severity */
export enum LogLevel {
  LOG_LEVEL_UNSPECIFIED = 0,
  LOG_LEVEL_TRACE = 1,
  LOG_LEVEL_DEBUG = 2,
  LOG_LEVEL_INFO = 3,
  LOG_LEVEL_WARN = 4,
  LOG_LEVEL_ERROR = 5,
  LOG_LEVEL_FATAL = 6,
  UNRECOGNIZED = -1,
}

export function logLevelFromJSON(object: any): LogLevel {
  switch (object) {
    case 0:
    case "LOG_LEVEL_UNSPECIFIED":
      return LogLevel.LOG_LEVEL_UNSPECIFIED;
    case 1:
    case "LOG_LEVEL_TRACE":
      return LogLevel.LOG_LEVEL_TRACE;
    case 2:
    case "LOG_LEVEL_DEBUG":
      return LogLevel.LOG_LEVEL_DEBUG;
    case 3:
    case "LOG_LEVEL_INFO":
      return LogLevel.LOG_LEVEL_INFO;
    case 4:
    case "LOG_LEVEL_WARN":
      return LogLevel.LOG_LEVEL_WARN;
    case 5:
    case "LOG_LEVEL_ERROR":
      return LogLevel.LOG_LEVEL_ERROR;
    case 6:
    case "LOG_LEVEL_FATAL":
      return LogLevel.LOG_LEVEL_FATAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LogLevel.UNRECOGNIZED;
  }
}

export function logLevelToJSON(object: LogLevel): string {
  switch (object) {
    case LogLevel.LOG_LEVEL_UNSPECIFIED:
      return "LOG_LEVEL_UNSPECIFIED";
    case LogLevel.LOG_LEVEL_TRACE:
      return "LOG_LEVEL_TRACE";
    case LogLevel.LOG_LEVEL_DEBUG:
      return "LOG_LEVEL_DEBUG";
    case LogLevel.LOG_LEVEL_INFO:
      return "LOG_LEVEL_INFO";
    case LogLevel.LOG_LEVEL_WARN:
      return "LOG_LEVEL_WARN";
    case LogLevel.LOG_LEVEL_ERROR:
      return "LOG_LEVEL_ERROR";
    case LogLevel.LOG_LEVEL_FATAL:
      return "LOG_LEVEL_FATAL";
    case LogLevel.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Compression types for data lake storage */
export enum CompressionType {
  COMPRESSION_UNSPECIFIED = 0,
  COMPRESSION_NONE = 1,
  COMPRESSION_GZIP = 2,
  COMPRESSION_SNAPPY = 3,
  COMPRESSION_LZ4 = 4,
  COMPRESSION_ZSTD = 5,
  UNRECOGNIZED = -1,
}

export function compressionTypeFromJSON(object: any): CompressionType {
  switch (object) {
    case 0:
    case "COMPRESSION_UNSPECIFIED":
      return CompressionType.COMPRESSION_UNSPECIFIED;
    case 1:
    case "COMPRESSION_NONE":
      return CompressionType.COMPRESSION_NONE;
    case 2:
    case "COMPRESSION_GZIP":
      return CompressionType.COMPRESSION_GZIP;
    case 3:
    case "COMPRESSION_SNAPPY":
      return CompressionType.COMPRESSION_SNAPPY;
    case 4:
    case "COMPRESSION_LZ4":
      return CompressionType.COMPRESSION_LZ4;
    case 5:
    case "COMPRESSION_ZSTD":
      return CompressionType.COMPRESSION_ZSTD;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CompressionType.UNRECOGNIZED;
  }
}

export function compressionTypeToJSON(object: CompressionType): string {
  switch (object) {
    case CompressionType.COMPRESSION_UNSPECIFIED:
      return "COMPRESSION_UNSPECIFIED";
    case CompressionType.COMPRESSION_NONE:
      return "COMPRESSION_NONE";
    case CompressionType.COMPRESSION_GZIP:
      return "COMPRESSION_GZIP";
    case CompressionType.COMPRESSION_SNAPPY:
      return "COMPRESSION_SNAPPY";
    case CompressionType.COMPRESSION_LZ4:
      return "COMPRESSION_LZ4";
    case CompressionType.COMPRESSION_ZSTD:
      return "COMPRESSION_ZSTD";
    case CompressionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** OpenTelemetry trace context for correlation across services */
export interface TraceContext {
  /** OpenTelemetry trace ID (32 hex chars) */
  traceId: string;
  /** OpenTelemetry span ID (16 hex chars) */
  spanId: string;
  /** Parent span ID for hierarchy */
  parentSpanId: string;
  /** Trace flags (sampled, etc.) */
  traceFlags?:
    | TraceFlags
    | undefined;
  /** W3C trace state for vendor data */
  traceState: string;
  /** Additional context for correlation */
  correlationId: string;
  /** Request-specific ID */
  requestId: string;
  /** User session ID */
  sessionId: string;
  /** User identifier */
  userId: string;
}

/** OpenTelemetry trace flags */
export interface TraceFlags {
  /** Whether trace is sampled */
  sampled: boolean;
  /** Whether trace ID is random */
  randomTraceId: boolean;
}

/** Resource information for service identification */
export interface Resource {
  /** Service name (e.g., "chat-service") */
  serviceName: string;
  /** Service version */
  serviceVersion: string;
  /** Instance identifier */
  serviceInstanceId: string;
  /** Environment (dev/staging/prod) */
  deploymentEnvironment: string;
  /** Kubernetes cluster */
  k8sClusterName: string;
  /** Kubernetes namespace */
  k8sNamespace: string;
  /** Pod name */
  k8sPodName: string;
  /** Host name */
  hostName: string;
  /** Host architecture */
  hostArch: string;
  /** Custom resource attributes */
  attributes: { [key: string]: string };
}

export interface Resource_AttributesEntry {
  key: string;
  value: string;
}

/**
 * Log entry event for CDC stream integration
 * Extends the existing CDC event pattern with observability data
 */
export interface LogEvent {
  /** Standard CDC event fields */
  eventId: string;
  /** Event timestamp */
  timestamp?:
    | Date
    | undefined;
  /** Always "log_entry" */
  eventType: string;
  /** CDC sequence for ordering */
  sequenceNumber: string;
  /** OpenTelemetry context */
  traceContext?: TraceContext | undefined;
  resource?:
    | Resource
    | undefined;
  /** Log entry data */
  level: LogLevel;
  /** Log message */
  message: string;
  /** Structured metadata */
  metadata?:
    | { [key: string]: any }
    | undefined;
  /** Error information (if applicable) */
  error?:
    | ErrorInfo
    | undefined;
  /** Destination flags for dual persistence */
  destinations?:
    | DestinationFlags
    | undefined;
  /** Data lake partitioning hints */
  partitionInfo?: PartitionInfo | undefined;
}

/** Error information for exception tracking */
export interface ErrorInfo {
  /** Exception class name */
  errorType: string;
  /** Exception message */
  errorMessage: string;
  /** Full stack trace */
  stackTrace: string;
  /** Application error code */
  errorCode: string;
  /** Additional error context */
  errorAttributes: { [key: string]: string };
}

export interface ErrorInfo_ErrorAttributesEntry {
  key: string;
  value: string;
}

/** Destination flags for dual persistence routing */
export interface DestinationFlags {
  /** Output to console (C flag) */
  console: boolean;
  /** Persist to CDC stream (D flag) */
  cdcStream: boolean;
  /** Send to data lake (L flag) */
  dataLake: boolean;
  /** Data lake specific options */
  dataLakeOptions?: DataLakeOptions | undefined;
}

/** Data lake storage options */
export interface DataLakeOptions {
  /** Target table/dataset */
  tableName: string;
  /** Partitioning strategy */
  partitionStrategy: string;
  /** Batching configuration */
  batchSize: number;
  /** Flush interval */
  flushIntervalSeconds: number;
  /** Compression type */
  compression: CompressionType;
}

/** Partitioning information for data lake optimization */
export interface PartitionInfo {
  /** Date-based partition (YYYY-MM-DD) */
  datePartition: string;
  /** Hour-based partition (HH) */
  hourPartition: string;
  /** Service-based partition */
  servicePartition: string;
  /** Log level partition */
  levelPartition: string;
  /** Custom partition keys */
  customPartitions: { [key: string]: string };
}

export interface PartitionInfo_CustomPartitionsEntry {
  key: string;
  value: string;
}

function createBaseTraceContext(): TraceContext {
  return {
    traceId: "",
    spanId: "",
    parentSpanId: "",
    traceFlags: undefined,
    traceState: "",
    correlationId: "",
    requestId: "",
    sessionId: "",
    userId: "",
  };
}

export const TraceContext = {
  encode(message: TraceContext, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.traceId !== "") {
      writer.uint32(10).string(message.traceId);
    }
    if (message.spanId !== "") {
      writer.uint32(18).string(message.spanId);
    }
    if (message.parentSpanId !== "") {
      writer.uint32(26).string(message.parentSpanId);
    }
    if (message.traceFlags !== undefined) {
      TraceFlags.encode(message.traceFlags, writer.uint32(34).fork()).ldelim();
    }
    if (message.traceState !== "") {
      writer.uint32(42).string(message.traceState);
    }
    if (message.correlationId !== "") {
      writer.uint32(82).string(message.correlationId);
    }
    if (message.requestId !== "") {
      writer.uint32(90).string(message.requestId);
    }
    if (message.sessionId !== "") {
      writer.uint32(98).string(message.sessionId);
    }
    if (message.userId !== "") {
      writer.uint32(106).string(message.userId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TraceContext {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTraceContext();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.traceId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.spanId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.parentSpanId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.traceFlags = TraceFlags.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.traceState = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.correlationId = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.userId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TraceContext {
    return {
      traceId: isSet(object.traceId) ? globalThis.String(object.traceId) : "",
      spanId: isSet(object.spanId) ? globalThis.String(object.spanId) : "",
      parentSpanId: isSet(object.parentSpanId) ? globalThis.String(object.parentSpanId) : "",
      traceFlags: isSet(object.traceFlags) ? TraceFlags.fromJSON(object.traceFlags) : undefined,
      traceState: isSet(object.traceState) ? globalThis.String(object.traceState) : "",
      correlationId: isSet(object.correlationId) ? globalThis.String(object.correlationId) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
    };
  },

  toJSON(message: TraceContext): unknown {
    const obj: any = {};
    if (message.traceId !== "") {
      obj.traceId = message.traceId;
    }
    if (message.spanId !== "") {
      obj.spanId = message.spanId;
    }
    if (message.parentSpanId !== "") {
      obj.parentSpanId = message.parentSpanId;
    }
    if (message.traceFlags !== undefined) {
      obj.traceFlags = TraceFlags.toJSON(message.traceFlags);
    }
    if (message.traceState !== "") {
      obj.traceState = message.traceState;
    }
    if (message.correlationId !== "") {
      obj.correlationId = message.correlationId;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TraceContext>, I>>(base?: I): TraceContext {
    return TraceContext.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TraceContext>, I>>(object: I): TraceContext {
    const message = createBaseTraceContext();
    message.traceId = object.traceId ?? "";
    message.spanId = object.spanId ?? "";
    message.parentSpanId = object.parentSpanId ?? "";
    message.traceFlags = (object.traceFlags !== undefined && object.traceFlags !== null)
      ? TraceFlags.fromPartial(object.traceFlags)
      : undefined;
    message.traceState = object.traceState ?? "";
    message.correlationId = object.correlationId ?? "";
    message.requestId = object.requestId ?? "";
    message.sessionId = object.sessionId ?? "";
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseTraceFlags(): TraceFlags {
  return { sampled: false, randomTraceId: false };
}

export const TraceFlags = {
  encode(message: TraceFlags, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sampled !== false) {
      writer.uint32(8).bool(message.sampled);
    }
    if (message.randomTraceId !== false) {
      writer.uint32(16).bool(message.randomTraceId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TraceFlags {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTraceFlags();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sampled = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.randomTraceId = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TraceFlags {
    return {
      sampled: isSet(object.sampled) ? globalThis.Boolean(object.sampled) : false,
      randomTraceId: isSet(object.randomTraceId) ? globalThis.Boolean(object.randomTraceId) : false,
    };
  },

  toJSON(message: TraceFlags): unknown {
    const obj: any = {};
    if (message.sampled !== false) {
      obj.sampled = message.sampled;
    }
    if (message.randomTraceId !== false) {
      obj.randomTraceId = message.randomTraceId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TraceFlags>, I>>(base?: I): TraceFlags {
    return TraceFlags.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TraceFlags>, I>>(object: I): TraceFlags {
    const message = createBaseTraceFlags();
    message.sampled = object.sampled ?? false;
    message.randomTraceId = object.randomTraceId ?? false;
    return message;
  },
};

function createBaseResource(): Resource {
  return {
    serviceName: "",
    serviceVersion: "",
    serviceInstanceId: "",
    deploymentEnvironment: "",
    k8sClusterName: "",
    k8sNamespace: "",
    k8sPodName: "",
    hostName: "",
    hostArch: "",
    attributes: {},
  };
}

export const Resource = {
  encode(message: Resource, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.serviceName !== "") {
      writer.uint32(10).string(message.serviceName);
    }
    if (message.serviceVersion !== "") {
      writer.uint32(18).string(message.serviceVersion);
    }
    if (message.serviceInstanceId !== "") {
      writer.uint32(26).string(message.serviceInstanceId);
    }
    if (message.deploymentEnvironment !== "") {
      writer.uint32(34).string(message.deploymentEnvironment);
    }
    if (message.k8sClusterName !== "") {
      writer.uint32(42).string(message.k8sClusterName);
    }
    if (message.k8sNamespace !== "") {
      writer.uint32(50).string(message.k8sNamespace);
    }
    if (message.k8sPodName !== "") {
      writer.uint32(58).string(message.k8sPodName);
    }
    if (message.hostName !== "") {
      writer.uint32(66).string(message.hostName);
    }
    if (message.hostArch !== "") {
      writer.uint32(74).string(message.hostArch);
    }
    Object.entries(message.attributes).forEach(([key, value]) => {
      Resource_AttributesEntry.encode({ key: key as any, value }, writer.uint32(162).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Resource {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.serviceName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.serviceVersion = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.serviceInstanceId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.deploymentEnvironment = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.k8sClusterName = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.k8sNamespace = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.k8sPodName = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.hostName = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.hostArch = reader.string();
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          const entry20 = Resource_AttributesEntry.decode(reader, reader.uint32());
          if (entry20.value !== undefined) {
            message.attributes[entry20.key] = entry20.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Resource {
    return {
      serviceName: isSet(object.serviceName) ? globalThis.String(object.serviceName) : "",
      serviceVersion: isSet(object.serviceVersion) ? globalThis.String(object.serviceVersion) : "",
      serviceInstanceId: isSet(object.serviceInstanceId) ? globalThis.String(object.serviceInstanceId) : "",
      deploymentEnvironment: isSet(object.deploymentEnvironment) ? globalThis.String(object.deploymentEnvironment) : "",
      k8sClusterName: isSet(object.k8sClusterName) ? globalThis.String(object.k8sClusterName) : "",
      k8sNamespace: isSet(object.k8sNamespace) ? globalThis.String(object.k8sNamespace) : "",
      k8sPodName: isSet(object.k8sPodName) ? globalThis.String(object.k8sPodName) : "",
      hostName: isSet(object.hostName) ? globalThis.String(object.hostName) : "",
      hostArch: isSet(object.hostArch) ? globalThis.String(object.hostArch) : "",
      attributes: isObject(object.attributes)
        ? Object.entries(object.attributes).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Resource): unknown {
    const obj: any = {};
    if (message.serviceName !== "") {
      obj.serviceName = message.serviceName;
    }
    if (message.serviceVersion !== "") {
      obj.serviceVersion = message.serviceVersion;
    }
    if (message.serviceInstanceId !== "") {
      obj.serviceInstanceId = message.serviceInstanceId;
    }
    if (message.deploymentEnvironment !== "") {
      obj.deploymentEnvironment = message.deploymentEnvironment;
    }
    if (message.k8sClusterName !== "") {
      obj.k8sClusterName = message.k8sClusterName;
    }
    if (message.k8sNamespace !== "") {
      obj.k8sNamespace = message.k8sNamespace;
    }
    if (message.k8sPodName !== "") {
      obj.k8sPodName = message.k8sPodName;
    }
    if (message.hostName !== "") {
      obj.hostName = message.hostName;
    }
    if (message.hostArch !== "") {
      obj.hostArch = message.hostArch;
    }
    if (message.attributes) {
      const entries = Object.entries(message.attributes);
      if (entries.length > 0) {
        obj.attributes = {};
        entries.forEach(([k, v]) => {
          obj.attributes[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Resource>, I>>(base?: I): Resource {
    return Resource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Resource>, I>>(object: I): Resource {
    const message = createBaseResource();
    message.serviceName = object.serviceName ?? "";
    message.serviceVersion = object.serviceVersion ?? "";
    message.serviceInstanceId = object.serviceInstanceId ?? "";
    message.deploymentEnvironment = object.deploymentEnvironment ?? "";
    message.k8sClusterName = object.k8sClusterName ?? "";
    message.k8sNamespace = object.k8sNamespace ?? "";
    message.k8sPodName = object.k8sPodName ?? "";
    message.hostName = object.hostName ?? "";
    message.hostArch = object.hostArch ?? "";
    message.attributes = Object.entries(object.attributes ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseResource_AttributesEntry(): Resource_AttributesEntry {
  return { key: "", value: "" };
}

export const Resource_AttributesEntry = {
  encode(message: Resource_AttributesEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Resource_AttributesEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResource_AttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Resource_AttributesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Resource_AttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Resource_AttributesEntry>, I>>(base?: I): Resource_AttributesEntry {
    return Resource_AttributesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Resource_AttributesEntry>, I>>(object: I): Resource_AttributesEntry {
    const message = createBaseResource_AttributesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseLogEvent(): LogEvent {
  return {
    eventId: "",
    timestamp: undefined,
    eventType: "",
    sequenceNumber: "0",
    traceContext: undefined,
    resource: undefined,
    level: 0,
    message: "",
    metadata: undefined,
    error: undefined,
    destinations: undefined,
    partitionInfo: undefined,
  };
}

export const LogEvent = {
  encode(message: LogEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== "") {
      writer.uint32(10).string(message.eventId);
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(18).fork()).ldelim();
    }
    if (message.eventType !== "") {
      writer.uint32(26).string(message.eventType);
    }
    if (message.sequenceNumber !== "0") {
      writer.uint32(32).int64(message.sequenceNumber);
    }
    if (message.traceContext !== undefined) {
      TraceContext.encode(message.traceContext, writer.uint32(42).fork()).ldelim();
    }
    if (message.resource !== undefined) {
      Resource.encode(message.resource, writer.uint32(50).fork()).ldelim();
    }
    if (message.level !== 0) {
      writer.uint32(80).int32(message.level);
    }
    if (message.message !== "") {
      writer.uint32(90).string(message.message);
    }
    if (message.metadata !== undefined) {
      Struct.encode(Struct.wrap(message.metadata), writer.uint32(98).fork()).ldelim();
    }
    if (message.error !== undefined) {
      ErrorInfo.encode(message.error, writer.uint32(122).fork()).ldelim();
    }
    if (message.destinations !== undefined) {
      DestinationFlags.encode(message.destinations, writer.uint32(162).fork()).ldelim();
    }
    if (message.partitionInfo !== undefined) {
      PartitionInfo.encode(message.partitionInfo, writer.uint32(202).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LogEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.eventId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.eventType = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.sequenceNumber = longToString(reader.int64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.traceContext = TraceContext.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.resource = Resource.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.level = reader.int32() as any;
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.message = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.metadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.error = ErrorInfo.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.destinations = DestinationFlags.decode(reader, reader.uint32());
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.partitionInfo = PartitionInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogEvent {
    return {
      eventId: isSet(object.eventId) ? globalThis.String(object.eventId) : "",
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      eventType: isSet(object.eventType) ? globalThis.String(object.eventType) : "",
      sequenceNumber: isSet(object.sequenceNumber) ? globalThis.String(object.sequenceNumber) : "0",
      traceContext: isSet(object.traceContext) ? TraceContext.fromJSON(object.traceContext) : undefined,
      resource: isSet(object.resource) ? Resource.fromJSON(object.resource) : undefined,
      level: isSet(object.level) ? logLevelFromJSON(object.level) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      metadata: isObject(object.metadata) ? object.metadata : undefined,
      error: isSet(object.error) ? ErrorInfo.fromJSON(object.error) : undefined,
      destinations: isSet(object.destinations) ? DestinationFlags.fromJSON(object.destinations) : undefined,
      partitionInfo: isSet(object.partitionInfo) ? PartitionInfo.fromJSON(object.partitionInfo) : undefined,
    };
  },

  toJSON(message: LogEvent): unknown {
    const obj: any = {};
    if (message.eventId !== "") {
      obj.eventId = message.eventId;
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.eventType !== "") {
      obj.eventType = message.eventType;
    }
    if (message.sequenceNumber !== "0") {
      obj.sequenceNumber = message.sequenceNumber;
    }
    if (message.traceContext !== undefined) {
      obj.traceContext = TraceContext.toJSON(message.traceContext);
    }
    if (message.resource !== undefined) {
      obj.resource = Resource.toJSON(message.resource);
    }
    if (message.level !== 0) {
      obj.level = logLevelToJSON(message.level);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    if (message.error !== undefined) {
      obj.error = ErrorInfo.toJSON(message.error);
    }
    if (message.destinations !== undefined) {
      obj.destinations = DestinationFlags.toJSON(message.destinations);
    }
    if (message.partitionInfo !== undefined) {
      obj.partitionInfo = PartitionInfo.toJSON(message.partitionInfo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LogEvent>, I>>(base?: I): LogEvent {
    return LogEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LogEvent>, I>>(object: I): LogEvent {
    const message = createBaseLogEvent();
    message.eventId = object.eventId ?? "";
    message.timestamp = object.timestamp ?? undefined;
    message.eventType = object.eventType ?? "";
    message.sequenceNumber = object.sequenceNumber ?? "0";
    message.traceContext = (object.traceContext !== undefined && object.traceContext !== null)
      ? TraceContext.fromPartial(object.traceContext)
      : undefined;
    message.resource = (object.resource !== undefined && object.resource !== null)
      ? Resource.fromPartial(object.resource)
      : undefined;
    message.level = object.level ?? 0;
    message.message = object.message ?? "";
    message.metadata = object.metadata ?? undefined;
    message.error = (object.error !== undefined && object.error !== null)
      ? ErrorInfo.fromPartial(object.error)
      : undefined;
    message.destinations = (object.destinations !== undefined && object.destinations !== null)
      ? DestinationFlags.fromPartial(object.destinations)
      : undefined;
    message.partitionInfo = (object.partitionInfo !== undefined && object.partitionInfo !== null)
      ? PartitionInfo.fromPartial(object.partitionInfo)
      : undefined;
    return message;
  },
};

function createBaseErrorInfo(): ErrorInfo {
  return { errorType: "", errorMessage: "", stackTrace: "", errorCode: "", errorAttributes: {} };
}

export const ErrorInfo = {
  encode(message: ErrorInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.errorType !== "") {
      writer.uint32(10).string(message.errorType);
    }
    if (message.errorMessage !== "") {
      writer.uint32(18).string(message.errorMessage);
    }
    if (message.stackTrace !== "") {
      writer.uint32(26).string(message.stackTrace);
    }
    if (message.errorCode !== "") {
      writer.uint32(34).string(message.errorCode);
    }
    Object.entries(message.errorAttributes).forEach(([key, value]) => {
      ErrorInfo_ErrorAttributesEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ErrorInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseErrorInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.errorType = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.stackTrace = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.errorCode = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = ErrorInfo_ErrorAttributesEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.errorAttributes[entry5.key] = entry5.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ErrorInfo {
    return {
      errorType: isSet(object.errorType) ? globalThis.String(object.errorType) : "",
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
      stackTrace: isSet(object.stackTrace) ? globalThis.String(object.stackTrace) : "",
      errorCode: isSet(object.errorCode) ? globalThis.String(object.errorCode) : "",
      errorAttributes: isObject(object.errorAttributes)
        ? Object.entries(object.errorAttributes).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ErrorInfo): unknown {
    const obj: any = {};
    if (message.errorType !== "") {
      obj.errorType = message.errorType;
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    if (message.stackTrace !== "") {
      obj.stackTrace = message.stackTrace;
    }
    if (message.errorCode !== "") {
      obj.errorCode = message.errorCode;
    }
    if (message.errorAttributes) {
      const entries = Object.entries(message.errorAttributes);
      if (entries.length > 0) {
        obj.errorAttributes = {};
        entries.forEach(([k, v]) => {
          obj.errorAttributes[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ErrorInfo>, I>>(base?: I): ErrorInfo {
    return ErrorInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ErrorInfo>, I>>(object: I): ErrorInfo {
    const message = createBaseErrorInfo();
    message.errorType = object.errorType ?? "";
    message.errorMessage = object.errorMessage ?? "";
    message.stackTrace = object.stackTrace ?? "";
    message.errorCode = object.errorCode ?? "";
    message.errorAttributes = Object.entries(object.errorAttributes ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseErrorInfo_ErrorAttributesEntry(): ErrorInfo_ErrorAttributesEntry {
  return { key: "", value: "" };
}

export const ErrorInfo_ErrorAttributesEntry = {
  encode(message: ErrorInfo_ErrorAttributesEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ErrorInfo_ErrorAttributesEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseErrorInfo_ErrorAttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ErrorInfo_ErrorAttributesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ErrorInfo_ErrorAttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ErrorInfo_ErrorAttributesEntry>, I>>(base?: I): ErrorInfo_ErrorAttributesEntry {
    return ErrorInfo_ErrorAttributesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ErrorInfo_ErrorAttributesEntry>, I>>(
    object: I,
  ): ErrorInfo_ErrorAttributesEntry {
    const message = createBaseErrorInfo_ErrorAttributesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseDestinationFlags(): DestinationFlags {
  return { console: false, cdcStream: false, dataLake: false, dataLakeOptions: undefined };
}

export const DestinationFlags = {
  encode(message: DestinationFlags, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.console !== false) {
      writer.uint32(8).bool(message.console);
    }
    if (message.cdcStream !== false) {
      writer.uint32(16).bool(message.cdcStream);
    }
    if (message.dataLake !== false) {
      writer.uint32(24).bool(message.dataLake);
    }
    if (message.dataLakeOptions !== undefined) {
      DataLakeOptions.encode(message.dataLakeOptions, writer.uint32(82).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DestinationFlags {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDestinationFlags();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.console = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.cdcStream = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.dataLake = reader.bool();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.dataLakeOptions = DataLakeOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DestinationFlags {
    return {
      console: isSet(object.console) ? globalThis.Boolean(object.console) : false,
      cdcStream: isSet(object.cdcStream) ? globalThis.Boolean(object.cdcStream) : false,
      dataLake: isSet(object.dataLake) ? globalThis.Boolean(object.dataLake) : false,
      dataLakeOptions: isSet(object.dataLakeOptions) ? DataLakeOptions.fromJSON(object.dataLakeOptions) : undefined,
    };
  },

  toJSON(message: DestinationFlags): unknown {
    const obj: any = {};
    if (message.console !== false) {
      obj.console = message.console;
    }
    if (message.cdcStream !== false) {
      obj.cdcStream = message.cdcStream;
    }
    if (message.dataLake !== false) {
      obj.dataLake = message.dataLake;
    }
    if (message.dataLakeOptions !== undefined) {
      obj.dataLakeOptions = DataLakeOptions.toJSON(message.dataLakeOptions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DestinationFlags>, I>>(base?: I): DestinationFlags {
    return DestinationFlags.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DestinationFlags>, I>>(object: I): DestinationFlags {
    const message = createBaseDestinationFlags();
    message.console = object.console ?? false;
    message.cdcStream = object.cdcStream ?? false;
    message.dataLake = object.dataLake ?? false;
    message.dataLakeOptions = (object.dataLakeOptions !== undefined && object.dataLakeOptions !== null)
      ? DataLakeOptions.fromPartial(object.dataLakeOptions)
      : undefined;
    return message;
  },
};

function createBaseDataLakeOptions(): DataLakeOptions {
  return { tableName: "", partitionStrategy: "", batchSize: 0, flushIntervalSeconds: 0, compression: 0 };
}

export const DataLakeOptions = {
  encode(message: DataLakeOptions, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tableName !== "") {
      writer.uint32(10).string(message.tableName);
    }
    if (message.partitionStrategy !== "") {
      writer.uint32(18).string(message.partitionStrategy);
    }
    if (message.batchSize !== 0) {
      writer.uint32(24).int32(message.batchSize);
    }
    if (message.flushIntervalSeconds !== 0) {
      writer.uint32(32).int32(message.flushIntervalSeconds);
    }
    if (message.compression !== 0) {
      writer.uint32(40).int32(message.compression);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DataLakeOptions {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataLakeOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tableName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.partitionStrategy = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.batchSize = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.flushIntervalSeconds = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.compression = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataLakeOptions {
    return {
      tableName: isSet(object.tableName) ? globalThis.String(object.tableName) : "",
      partitionStrategy: isSet(object.partitionStrategy) ? globalThis.String(object.partitionStrategy) : "",
      batchSize: isSet(object.batchSize) ? globalThis.Number(object.batchSize) : 0,
      flushIntervalSeconds: isSet(object.flushIntervalSeconds) ? globalThis.Number(object.flushIntervalSeconds) : 0,
      compression: isSet(object.compression) ? compressionTypeFromJSON(object.compression) : 0,
    };
  },

  toJSON(message: DataLakeOptions): unknown {
    const obj: any = {};
    if (message.tableName !== "") {
      obj.tableName = message.tableName;
    }
    if (message.partitionStrategy !== "") {
      obj.partitionStrategy = message.partitionStrategy;
    }
    if (message.batchSize !== 0) {
      obj.batchSize = Math.round(message.batchSize);
    }
    if (message.flushIntervalSeconds !== 0) {
      obj.flushIntervalSeconds = Math.round(message.flushIntervalSeconds);
    }
    if (message.compression !== 0) {
      obj.compression = compressionTypeToJSON(message.compression);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DataLakeOptions>, I>>(base?: I): DataLakeOptions {
    return DataLakeOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DataLakeOptions>, I>>(object: I): DataLakeOptions {
    const message = createBaseDataLakeOptions();
    message.tableName = object.tableName ?? "";
    message.partitionStrategy = object.partitionStrategy ?? "";
    message.batchSize = object.batchSize ?? 0;
    message.flushIntervalSeconds = object.flushIntervalSeconds ?? 0;
    message.compression = object.compression ?? 0;
    return message;
  },
};

function createBasePartitionInfo(): PartitionInfo {
  return { datePartition: "", hourPartition: "", servicePartition: "", levelPartition: "", customPartitions: {} };
}

export const PartitionInfo = {
  encode(message: PartitionInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.datePartition !== "") {
      writer.uint32(10).string(message.datePartition);
    }
    if (message.hourPartition !== "") {
      writer.uint32(18).string(message.hourPartition);
    }
    if (message.servicePartition !== "") {
      writer.uint32(26).string(message.servicePartition);
    }
    if (message.levelPartition !== "") {
      writer.uint32(34).string(message.levelPartition);
    }
    Object.entries(message.customPartitions).forEach(([key, value]) => {
      PartitionInfo_CustomPartitionsEntry.encode({ key: key as any, value }, writer.uint32(82).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PartitionInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePartitionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.datePartition = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.hourPartition = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.servicePartition = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.levelPartition = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          const entry10 = PartitionInfo_CustomPartitionsEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            message.customPartitions[entry10.key] = entry10.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PartitionInfo {
    return {
      datePartition: isSet(object.datePartition) ? globalThis.String(object.datePartition) : "",
      hourPartition: isSet(object.hourPartition) ? globalThis.String(object.hourPartition) : "",
      servicePartition: isSet(object.servicePartition) ? globalThis.String(object.servicePartition) : "",
      levelPartition: isSet(object.levelPartition) ? globalThis.String(object.levelPartition) : "",
      customPartitions: isObject(object.customPartitions)
        ? Object.entries(object.customPartitions).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: PartitionInfo): unknown {
    const obj: any = {};
    if (message.datePartition !== "") {
      obj.datePartition = message.datePartition;
    }
    if (message.hourPartition !== "") {
      obj.hourPartition = message.hourPartition;
    }
    if (message.servicePartition !== "") {
      obj.servicePartition = message.servicePartition;
    }
    if (message.levelPartition !== "") {
      obj.levelPartition = message.levelPartition;
    }
    if (message.customPartitions) {
      const entries = Object.entries(message.customPartitions);
      if (entries.length > 0) {
        obj.customPartitions = {};
        entries.forEach(([k, v]) => {
          obj.customPartitions[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PartitionInfo>, I>>(base?: I): PartitionInfo {
    return PartitionInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PartitionInfo>, I>>(object: I): PartitionInfo {
    const message = createBasePartitionInfo();
    message.datePartition = object.datePartition ?? "";
    message.hourPartition = object.hourPartition ?? "";
    message.servicePartition = object.servicePartition ?? "";
    message.levelPartition = object.levelPartition ?? "";
    message.customPartitions = Object.entries(object.customPartitions ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBasePartitionInfo_CustomPartitionsEntry(): PartitionInfo_CustomPartitionsEntry {
  return { key: "", value: "" };
}

export const PartitionInfo_CustomPartitionsEntry = {
  encode(message: PartitionInfo_CustomPartitionsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PartitionInfo_CustomPartitionsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePartitionInfo_CustomPartitionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PartitionInfo_CustomPartitionsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: PartitionInfo_CustomPartitionsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PartitionInfo_CustomPartitionsEntry>, I>>(
    base?: I,
  ): PartitionInfo_CustomPartitionsEntry {
    return PartitionInfo_CustomPartitionsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PartitionInfo_CustomPartitionsEntry>, I>>(
    object: I,
  ): PartitionInfo_CustomPartitionsEntry {
    const message = createBasePartitionInfo_CustomPartitionsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000).toString();
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (globalThis.Number(t.seconds) || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToString(long: Long) {
  return long.toString();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
