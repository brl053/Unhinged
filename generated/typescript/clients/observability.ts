// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v3.21.12
// source: observability.proto

/* eslint-disable */
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  ClientWritableStream,
  handleClientStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Struct } from "./google/protobuf/struct";
import { Timestamp } from "./google/protobuf/timestamp";

/** Log levels matching OpenTelemetry severity */
export enum LogLevel {
  LOG_LEVEL_UNSPECIFIED = 0,
  LOG_LEVEL_TRACE = 1,
  LOG_LEVEL_DEBUG = 2,
  LOG_LEVEL_INFO = 3,
  LOG_LEVEL_WARN = 4,
  LOG_LEVEL_ERROR = 5,
  LOG_LEVEL_FATAL = 6,
  UNRECOGNIZED = -1,
}

export function logLevelFromJSON(object: any): LogLevel {
  switch (object) {
    case 0:
    case "LOG_LEVEL_UNSPECIFIED":
      return LogLevel.LOG_LEVEL_UNSPECIFIED;
    case 1:
    case "LOG_LEVEL_TRACE":
      return LogLevel.LOG_LEVEL_TRACE;
    case 2:
    case "LOG_LEVEL_DEBUG":
      return LogLevel.LOG_LEVEL_DEBUG;
    case 3:
    case "LOG_LEVEL_INFO":
      return LogLevel.LOG_LEVEL_INFO;
    case 4:
    case "LOG_LEVEL_WARN":
      return LogLevel.LOG_LEVEL_WARN;
    case 5:
    case "LOG_LEVEL_ERROR":
      return LogLevel.LOG_LEVEL_ERROR;
    case 6:
    case "LOG_LEVEL_FATAL":
      return LogLevel.LOG_LEVEL_FATAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LogLevel.UNRECOGNIZED;
  }
}

export function logLevelToJSON(object: LogLevel): string {
  switch (object) {
    case LogLevel.LOG_LEVEL_UNSPECIFIED:
      return "LOG_LEVEL_UNSPECIFIED";
    case LogLevel.LOG_LEVEL_TRACE:
      return "LOG_LEVEL_TRACE";
    case LogLevel.LOG_LEVEL_DEBUG:
      return "LOG_LEVEL_DEBUG";
    case LogLevel.LOG_LEVEL_INFO:
      return "LOG_LEVEL_INFO";
    case LogLevel.LOG_LEVEL_WARN:
      return "LOG_LEVEL_WARN";
    case LogLevel.LOG_LEVEL_ERROR:
      return "LOG_LEVEL_ERROR";
    case LogLevel.LOG_LEVEL_FATAL:
      return "LOG_LEVEL_FATAL";
    case LogLevel.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Compression types for data lake storage */
export enum CompressionType {
  COMPRESSION_UNSPECIFIED = 0,
  COMPRESSION_NONE = 1,
  COMPRESSION_GZIP = 2,
  COMPRESSION_SNAPPY = 3,
  COMPRESSION_LZ4 = 4,
  COMPRESSION_ZSTD = 5,
  UNRECOGNIZED = -1,
}

export function compressionTypeFromJSON(object: any): CompressionType {
  switch (object) {
    case 0:
    case "COMPRESSION_UNSPECIFIED":
      return CompressionType.COMPRESSION_UNSPECIFIED;
    case 1:
    case "COMPRESSION_NONE":
      return CompressionType.COMPRESSION_NONE;
    case 2:
    case "COMPRESSION_GZIP":
      return CompressionType.COMPRESSION_GZIP;
    case 3:
    case "COMPRESSION_SNAPPY":
      return CompressionType.COMPRESSION_SNAPPY;
    case 4:
    case "COMPRESSION_LZ4":
      return CompressionType.COMPRESSION_LZ4;
    case 5:
    case "COMPRESSION_ZSTD":
      return CompressionType.COMPRESSION_ZSTD;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CompressionType.UNRECOGNIZED;
  }
}

export function compressionTypeToJSON(object: CompressionType): string {
  switch (object) {
    case CompressionType.COMPRESSION_UNSPECIFIED:
      return "COMPRESSION_UNSPECIFIED";
    case CompressionType.COMPRESSION_NONE:
      return "COMPRESSION_NONE";
    case CompressionType.COMPRESSION_GZIP:
      return "COMPRESSION_GZIP";
    case CompressionType.COMPRESSION_SNAPPY:
      return "COMPRESSION_SNAPPY";
    case CompressionType.COMPRESSION_LZ4:
      return "COMPRESSION_LZ4";
    case CompressionType.COMPRESSION_ZSTD:
      return "COMPRESSION_ZSTD";
    case CompressionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** OpenTelemetry span kinds */
export enum SpanKind {
  SPAN_KIND_UNSPECIFIED = 0,
  /** SPAN_KIND_INTERNAL - Internal operation */
  SPAN_KIND_INTERNAL = 1,
  /** SPAN_KIND_SERVER - Server-side operation */
  SPAN_KIND_SERVER = 2,
  /** SPAN_KIND_CLIENT - Client-side operation */
  SPAN_KIND_CLIENT = 3,
  /** SPAN_KIND_PRODUCER - Message producer */
  SPAN_KIND_PRODUCER = 4,
  /** SPAN_KIND_CONSUMER - Message consumer */
  SPAN_KIND_CONSUMER = 5,
  UNRECOGNIZED = -1,
}

export function spanKindFromJSON(object: any): SpanKind {
  switch (object) {
    case 0:
    case "SPAN_KIND_UNSPECIFIED":
      return SpanKind.SPAN_KIND_UNSPECIFIED;
    case 1:
    case "SPAN_KIND_INTERNAL":
      return SpanKind.SPAN_KIND_INTERNAL;
    case 2:
    case "SPAN_KIND_SERVER":
      return SpanKind.SPAN_KIND_SERVER;
    case 3:
    case "SPAN_KIND_CLIENT":
      return SpanKind.SPAN_KIND_CLIENT;
    case 4:
    case "SPAN_KIND_PRODUCER":
      return SpanKind.SPAN_KIND_PRODUCER;
    case 5:
    case "SPAN_KIND_CONSUMER":
      return SpanKind.SPAN_KIND_CONSUMER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SpanKind.UNRECOGNIZED;
  }
}

export function spanKindToJSON(object: SpanKind): string {
  switch (object) {
    case SpanKind.SPAN_KIND_UNSPECIFIED:
      return "SPAN_KIND_UNSPECIFIED";
    case SpanKind.SPAN_KIND_INTERNAL:
      return "SPAN_KIND_INTERNAL";
    case SpanKind.SPAN_KIND_SERVER:
      return "SPAN_KIND_SERVER";
    case SpanKind.SPAN_KIND_CLIENT:
      return "SPAN_KIND_CLIENT";
    case SpanKind.SPAN_KIND_PRODUCER:
      return "SPAN_KIND_PRODUCER";
    case SpanKind.SPAN_KIND_CONSUMER:
      return "SPAN_KIND_CONSUMER";
    case SpanKind.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** OpenTelemetry status codes */
export enum StatusCode {
  /** STATUS_CODE_UNSET - Default status */
  STATUS_CODE_UNSET = 0,
  /** STATUS_CODE_OK - Success */
  STATUS_CODE_OK = 1,
  /** STATUS_CODE_ERROR - Error occurred */
  STATUS_CODE_ERROR = 2,
  UNRECOGNIZED = -1,
}

export function statusCodeFromJSON(object: any): StatusCode {
  switch (object) {
    case 0:
    case "STATUS_CODE_UNSET":
      return StatusCode.STATUS_CODE_UNSET;
    case 1:
    case "STATUS_CODE_OK":
      return StatusCode.STATUS_CODE_OK;
    case 2:
    case "STATUS_CODE_ERROR":
      return StatusCode.STATUS_CODE_ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StatusCode.UNRECOGNIZED;
  }
}

export function statusCodeToJSON(object: StatusCode): string {
  switch (object) {
    case StatusCode.STATUS_CODE_UNSET:
      return "STATUS_CODE_UNSET";
    case StatusCode.STATUS_CODE_OK:
      return "STATUS_CODE_OK";
    case StatusCode.STATUS_CODE_ERROR:
      return "STATUS_CODE_ERROR";
    case StatusCode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Aggregation temporality for metrics */
export enum AggregationTemporality {
  AGGREGATION_TEMPORALITY_UNSPECIFIED = 0,
  /** AGGREGATION_TEMPORALITY_DELTA - Delta aggregation */
  AGGREGATION_TEMPORALITY_DELTA = 1,
  /** AGGREGATION_TEMPORALITY_CUMULATIVE - Cumulative aggregation */
  AGGREGATION_TEMPORALITY_CUMULATIVE = 2,
  UNRECOGNIZED = -1,
}

export function aggregationTemporalityFromJSON(object: any): AggregationTemporality {
  switch (object) {
    case 0:
    case "AGGREGATION_TEMPORALITY_UNSPECIFIED":
      return AggregationTemporality.AGGREGATION_TEMPORALITY_UNSPECIFIED;
    case 1:
    case "AGGREGATION_TEMPORALITY_DELTA":
      return AggregationTemporality.AGGREGATION_TEMPORALITY_DELTA;
    case 2:
    case "AGGREGATION_TEMPORALITY_CUMULATIVE":
      return AggregationTemporality.AGGREGATION_TEMPORALITY_CUMULATIVE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AggregationTemporality.UNRECOGNIZED;
  }
}

export function aggregationTemporalityToJSON(object: AggregationTemporality): string {
  switch (object) {
    case AggregationTemporality.AGGREGATION_TEMPORALITY_UNSPECIFIED:
      return "AGGREGATION_TEMPORALITY_UNSPECIFIED";
    case AggregationTemporality.AGGREGATION_TEMPORALITY_DELTA:
      return "AGGREGATION_TEMPORALITY_DELTA";
    case AggregationTemporality.AGGREGATION_TEMPORALITY_CUMULATIVE:
      return "AGGREGATION_TEMPORALITY_CUMULATIVE";
    case AggregationTemporality.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Health status enumeration */
export enum HealthStatus {
  /** HEALTH_STATUS_UNKNOWN - Unknown status */
  HEALTH_STATUS_UNKNOWN = 0,
  /** HEALTH_STATUS_HEALTHY - Service is healthy */
  HEALTH_STATUS_HEALTHY = 1,
  /** HEALTH_STATUS_DEGRADED - Service is degraded */
  HEALTH_STATUS_DEGRADED = 2,
  /** HEALTH_STATUS_UNHEALTHY - Service is unhealthy */
  HEALTH_STATUS_UNHEALTHY = 3,
  /** HEALTH_STATUS_MAINTENANCE - Service is in maintenance */
  HEALTH_STATUS_MAINTENANCE = 4,
  UNRECOGNIZED = -1,
}

export function healthStatusFromJSON(object: any): HealthStatus {
  switch (object) {
    case 0:
    case "HEALTH_STATUS_UNKNOWN":
      return HealthStatus.HEALTH_STATUS_UNKNOWN;
    case 1:
    case "HEALTH_STATUS_HEALTHY":
      return HealthStatus.HEALTH_STATUS_HEALTHY;
    case 2:
    case "HEALTH_STATUS_DEGRADED":
      return HealthStatus.HEALTH_STATUS_DEGRADED;
    case 3:
    case "HEALTH_STATUS_UNHEALTHY":
      return HealthStatus.HEALTH_STATUS_UNHEALTHY;
    case 4:
    case "HEALTH_STATUS_MAINTENANCE":
      return HealthStatus.HEALTH_STATUS_MAINTENANCE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return HealthStatus.UNRECOGNIZED;
  }
}

export function healthStatusToJSON(object: HealthStatus): string {
  switch (object) {
    case HealthStatus.HEALTH_STATUS_UNKNOWN:
      return "HEALTH_STATUS_UNKNOWN";
    case HealthStatus.HEALTH_STATUS_HEALTHY:
      return "HEALTH_STATUS_HEALTHY";
    case HealthStatus.HEALTH_STATUS_DEGRADED:
      return "HEALTH_STATUS_DEGRADED";
    case HealthStatus.HEALTH_STATUS_UNHEALTHY:
      return "HEALTH_STATUS_UNHEALTHY";
    case HealthStatus.HEALTH_STATUS_MAINTENANCE:
      return "HEALTH_STATUS_MAINTENANCE";
    case HealthStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Incident severity levels */
export enum IncidentSeverity {
  INCIDENT_SEVERITY_UNKNOWN = 0,
  /** INCIDENT_SEVERITY_LOW - Minor impact */
  INCIDENT_SEVERITY_LOW = 1,
  /** INCIDENT_SEVERITY_MEDIUM - Moderate impact */
  INCIDENT_SEVERITY_MEDIUM = 2,
  /** INCIDENT_SEVERITY_HIGH - Major impact */
  INCIDENT_SEVERITY_HIGH = 3,
  /** INCIDENT_SEVERITY_CRITICAL - Critical impact */
  INCIDENT_SEVERITY_CRITICAL = 4,
  UNRECOGNIZED = -1,
}

export function incidentSeverityFromJSON(object: any): IncidentSeverity {
  switch (object) {
    case 0:
    case "INCIDENT_SEVERITY_UNKNOWN":
      return IncidentSeverity.INCIDENT_SEVERITY_UNKNOWN;
    case 1:
    case "INCIDENT_SEVERITY_LOW":
      return IncidentSeverity.INCIDENT_SEVERITY_LOW;
    case 2:
    case "INCIDENT_SEVERITY_MEDIUM":
      return IncidentSeverity.INCIDENT_SEVERITY_MEDIUM;
    case 3:
    case "INCIDENT_SEVERITY_HIGH":
      return IncidentSeverity.INCIDENT_SEVERITY_HIGH;
    case 4:
    case "INCIDENT_SEVERITY_CRITICAL":
      return IncidentSeverity.INCIDENT_SEVERITY_CRITICAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return IncidentSeverity.UNRECOGNIZED;
  }
}

export function incidentSeverityToJSON(object: IncidentSeverity): string {
  switch (object) {
    case IncidentSeverity.INCIDENT_SEVERITY_UNKNOWN:
      return "INCIDENT_SEVERITY_UNKNOWN";
    case IncidentSeverity.INCIDENT_SEVERITY_LOW:
      return "INCIDENT_SEVERITY_LOW";
    case IncidentSeverity.INCIDENT_SEVERITY_MEDIUM:
      return "INCIDENT_SEVERITY_MEDIUM";
    case IncidentSeverity.INCIDENT_SEVERITY_HIGH:
      return "INCIDENT_SEVERITY_HIGH";
    case IncidentSeverity.INCIDENT_SEVERITY_CRITICAL:
      return "INCIDENT_SEVERITY_CRITICAL";
    case IncidentSeverity.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Incident status lifecycle */
export enum IncidentStatus {
  INCIDENT_STATUS_UNKNOWN = 0,
  /** INCIDENT_STATUS_INVESTIGATING - Under investigation */
  INCIDENT_STATUS_INVESTIGATING = 1,
  /** INCIDENT_STATUS_IDENTIFIED - Root cause identified */
  INCIDENT_STATUS_IDENTIFIED = 2,
  /** INCIDENT_STATUS_MONITORING - Fix deployed, monitoring */
  INCIDENT_STATUS_MONITORING = 3,
  /** INCIDENT_STATUS_RESOLVED - Fully resolved */
  INCIDENT_STATUS_RESOLVED = 4,
  /** INCIDENT_STATUS_POSTMORTEM - Post-mortem phase */
  INCIDENT_STATUS_POSTMORTEM = 5,
  UNRECOGNIZED = -1,
}

export function incidentStatusFromJSON(object: any): IncidentStatus {
  switch (object) {
    case 0:
    case "INCIDENT_STATUS_UNKNOWN":
      return IncidentStatus.INCIDENT_STATUS_UNKNOWN;
    case 1:
    case "INCIDENT_STATUS_INVESTIGATING":
      return IncidentStatus.INCIDENT_STATUS_INVESTIGATING;
    case 2:
    case "INCIDENT_STATUS_IDENTIFIED":
      return IncidentStatus.INCIDENT_STATUS_IDENTIFIED;
    case 3:
    case "INCIDENT_STATUS_MONITORING":
      return IncidentStatus.INCIDENT_STATUS_MONITORING;
    case 4:
    case "INCIDENT_STATUS_RESOLVED":
      return IncidentStatus.INCIDENT_STATUS_RESOLVED;
    case 5:
    case "INCIDENT_STATUS_POSTMORTEM":
      return IncidentStatus.INCIDENT_STATUS_POSTMORTEM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return IncidentStatus.UNRECOGNIZED;
  }
}

export function incidentStatusToJSON(object: IncidentStatus): string {
  switch (object) {
    case IncidentStatus.INCIDENT_STATUS_UNKNOWN:
      return "INCIDENT_STATUS_UNKNOWN";
    case IncidentStatus.INCIDENT_STATUS_INVESTIGATING:
      return "INCIDENT_STATUS_INVESTIGATING";
    case IncidentStatus.INCIDENT_STATUS_IDENTIFIED:
      return "INCIDENT_STATUS_IDENTIFIED";
    case IncidentStatus.INCIDENT_STATUS_MONITORING:
      return "INCIDENT_STATUS_MONITORING";
    case IncidentStatus.INCIDENT_STATUS_RESOLVED:
      return "INCIDENT_STATUS_RESOLVED";
    case IncidentStatus.INCIDENT_STATUS_POSTMORTEM:
      return "INCIDENT_STATUS_POSTMORTEM";
    case IncidentStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Types of incident updates */
export enum UpdateType {
  UPDATE_TYPE_UNKNOWN = 0,
  /** UPDATE_TYPE_INVESTIGATING - Investigation update */
  UPDATE_TYPE_INVESTIGATING = 1,
  /** UPDATE_TYPE_UPDATE - General update */
  UPDATE_TYPE_UPDATE = 2,
  /** UPDATE_TYPE_RESOLVED - Resolution update */
  UPDATE_TYPE_RESOLVED = 3,
  /** UPDATE_TYPE_POSTMORTEM - Post-mortem update */
  UPDATE_TYPE_POSTMORTEM = 4,
  UNRECOGNIZED = -1,
}

export function updateTypeFromJSON(object: any): UpdateType {
  switch (object) {
    case 0:
    case "UPDATE_TYPE_UNKNOWN":
      return UpdateType.UPDATE_TYPE_UNKNOWN;
    case 1:
    case "UPDATE_TYPE_INVESTIGATING":
      return UpdateType.UPDATE_TYPE_INVESTIGATING;
    case 2:
    case "UPDATE_TYPE_UPDATE":
      return UpdateType.UPDATE_TYPE_UPDATE;
    case 3:
    case "UPDATE_TYPE_RESOLVED":
      return UpdateType.UPDATE_TYPE_RESOLVED;
    case 4:
    case "UPDATE_TYPE_POSTMORTEM":
      return UpdateType.UPDATE_TYPE_POSTMORTEM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return UpdateType.UNRECOGNIZED;
  }
}

export function updateTypeToJSON(object: UpdateType): string {
  switch (object) {
    case UpdateType.UPDATE_TYPE_UNKNOWN:
      return "UPDATE_TYPE_UNKNOWN";
    case UpdateType.UPDATE_TYPE_INVESTIGATING:
      return "UPDATE_TYPE_INVESTIGATING";
    case UpdateType.UPDATE_TYPE_UPDATE:
      return "UPDATE_TYPE_UPDATE";
    case UpdateType.UPDATE_TYPE_RESOLVED:
      return "UPDATE_TYPE_RESOLVED";
    case UpdateType.UPDATE_TYPE_POSTMORTEM:
      return "UPDATE_TYPE_POSTMORTEM";
    case UpdateType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** OpenTelemetry trace context for correlation across services */
export interface TraceContext {
  /** OpenTelemetry trace ID (32 hex chars) */
  traceId: string;
  /** OpenTelemetry span ID (16 hex chars) */
  spanId: string;
  /** Parent span ID for hierarchy */
  parentSpanId: string;
  /** Trace flags (sampled, etc.) */
  traceFlags?:
    | TraceFlags
    | undefined;
  /** W3C trace state for vendor data */
  traceState: string;
  /** Additional context for correlation */
  correlationId: string;
  /** Request-specific ID */
  requestId: string;
  /** User session ID */
  sessionId: string;
  /** User identifier */
  userId: string;
}

/** OpenTelemetry trace flags */
export interface TraceFlags {
  /** Whether trace is sampled */
  sampled: boolean;
  /** Whether trace ID is random */
  randomTraceId: boolean;
}

/** Resource information for service identification */
export interface Resource {
  /** Service name (e.g., "chat-service") */
  serviceName: string;
  /** Service version */
  serviceVersion: string;
  /** Instance identifier */
  serviceInstanceId: string;
  /** Environment (dev/staging/prod) */
  deploymentEnvironment: string;
  /** Kubernetes cluster */
  k8sClusterName: string;
  /** Kubernetes namespace */
  k8sNamespace: string;
  /** Pod name */
  k8sPodName: string;
  /** Host name */
  hostName: string;
  /** Host architecture */
  hostArch: string;
  /** Custom resource attributes */
  attributes: { [key: string]: string };
}

export interface Resource_AttributesEntry {
  key: string;
  value: string;
}

/**
 * Log entry event for CDC stream integration
 * Extends the existing CDC event pattern with observability data
 */
export interface LogEvent {
  /** Standard CDC event fields */
  eventId: string;
  /** Event timestamp */
  timestamp?:
    | Date
    | undefined;
  /** Always "log_entry" */
  eventType: string;
  /** CDC sequence for ordering */
  sequenceNumber: string;
  /** OpenTelemetry context */
  traceContext?: TraceContext | undefined;
  resource?:
    | Resource
    | undefined;
  /** Log entry data */
  level: LogLevel;
  /** Log message */
  message: string;
  /** Structured metadata */
  metadata?:
    | { [key: string]: any }
    | undefined;
  /** Error information (if applicable) */
  error?:
    | ErrorInfo
    | undefined;
  /** Destination flags for dual persistence */
  destinations?:
    | DestinationFlags
    | undefined;
  /** Data lake partitioning hints */
  partitionInfo?: PartitionInfo | undefined;
}

/** Error information for exception tracking */
export interface ErrorInfo {
  /** Exception class name */
  errorType: string;
  /** Exception message */
  errorMessage: string;
  /** Full stack trace */
  stackTrace: string;
  /** Application error code */
  errorCode: string;
  /** Additional error context */
  errorAttributes: { [key: string]: string };
}

export interface ErrorInfo_ErrorAttributesEntry {
  key: string;
  value: string;
}

/** Destination flags for dual persistence routing */
export interface DestinationFlags {
  /** Output to console (C flag) */
  console: boolean;
  /** Persist to CDC stream (D flag) */
  cdcStream: boolean;
  /** Send to data lake (L flag) */
  dataLake: boolean;
  /** Data lake specific options */
  dataLakeOptions?: DataLakeOptions | undefined;
}

/** Data lake storage options */
export interface DataLakeOptions {
  /** Target table/dataset */
  tableName: string;
  /** Partitioning strategy */
  partitionStrategy: string;
  /** Batching configuration */
  batchSize: number;
  /** Flush interval */
  flushIntervalSeconds: number;
  /** Compression type */
  compression: CompressionType;
}

/** Partitioning information for data lake optimization */
export interface PartitionInfo {
  /** Date-based partition (YYYY-MM-DD) */
  datePartition: string;
  /** Hour-based partition (HH) */
  hourPartition: string;
  /** Service-based partition */
  servicePartition: string;
  /** Log level partition */
  levelPartition: string;
  /** Custom partition keys */
  customPartitions: { [key: string]: string };
}

export interface PartitionInfo_CustomPartitionsEntry {
  key: string;
  value: string;
}

/**
 * Trace span event for CDC stream integration
 * Represents a single operation within a distributed trace
 */
export interface TraceEvent {
  /** Standard CDC event fields */
  eventId: string;
  /** Event timestamp */
  timestamp?:
    | Date
    | undefined;
  /** Always "trace_span" */
  eventType: string;
  /** CDC sequence for ordering */
  sequenceNumber: string;
  /** OpenTelemetry context */
  traceContext?: TraceContext | undefined;
  resource?:
    | Resource
    | undefined;
  /** Span data */
  span?:
    | SpanData
    | undefined;
  /** Destination flags for dual persistence */
  destinations?:
    | DestinationFlags
    | undefined;
  /** Data lake partitioning hints */
  partitionInfo?: PartitionInfo | undefined;
}

/** OpenTelemetry span data */
export interface SpanData {
  /** Span name (operation name) */
  name: string;
  /** Span kind (client, server, etc.) */
  kind: SpanKind;
  /** Span start time */
  startTime?:
    | Date
    | undefined;
  /** Span end time */
  endTime?:
    | Date
    | undefined;
  /** Duration in nanoseconds */
  durationNanos: string;
  /** Span status */
  status?:
    | SpanStatus
    | undefined;
  /** Span attributes (tags) */
  attributes: { [key: string]: AttributeValue };
  /** Span events (logs within span) */
  events: SpanEvent[];
  /** Span links (references to other spans) */
  links: SpanLink[];
  /** Instrumentation library info */
  instrumentationLibrary?: InstrumentationLibrary | undefined;
}

export interface SpanData_AttributesEntry {
  key: string;
  value?: AttributeValue | undefined;
}

/** Span status information */
export interface SpanStatus {
  /** Status code */
  code: StatusCode;
  /** Optional status message */
  message: string;
}

/** Span event (log within a span) */
export interface SpanEvent {
  /** Event timestamp */
  timestamp?:
    | Date
    | undefined;
  /** Event name */
  name: string;
  /** Event attributes */
  attributes: { [key: string]: AttributeValue };
}

export interface SpanEvent_AttributesEntry {
  key: string;
  value?: AttributeValue | undefined;
}

/** Span link (reference to another span) */
export interface SpanLink {
  /** Linked span context */
  traceContext?:
    | TraceContext
    | undefined;
  /** Link attributes */
  attributes: { [key: string]: AttributeValue };
}

export interface SpanLink_AttributesEntry {
  key: string;
  value?: AttributeValue | undefined;
}

/** Instrumentation library information */
export interface InstrumentationLibrary {
  /** Library name */
  name: string;
  /** Library version */
  version: string;
  /** Schema URL */
  schemaUrl: string;
}

/** Attribute value (supports multiple types) */
export interface AttributeValue {
  stringValue?: string | undefined;
  boolValue?: boolean | undefined;
  intValue?: string | undefined;
  doubleValue?: number | undefined;
  bytesValue?: Uint8Array | undefined;
  arrayValue?: AttributeArray | undefined;
  kvlistValue?: AttributeKeyValueList | undefined;
}

/** Array of attribute values */
export interface AttributeArray {
  values: AttributeValue[];
}

/** Key-value list of attributes */
export interface AttributeKeyValueList {
  values: AttributeKeyValue[];
}

/** Key-value pair for attributes */
export interface AttributeKeyValue {
  key: string;
  value?: AttributeValue | undefined;
}

/**
 * Metric event for CDC stream integration
 * Represents performance metrics and measurements
 */
export interface MetricEvent {
  /** Standard CDC event fields */
  eventId: string;
  /** Event timestamp */
  timestamp?:
    | Date
    | undefined;
  /** Always "metric_data" */
  eventType: string;
  /** CDC sequence for ordering */
  sequenceNumber: string;
  /** OpenTelemetry context */
  traceContext?: TraceContext | undefined;
  resource?:
    | Resource
    | undefined;
  /** Metric data */
  metric?:
    | MetricData
    | undefined;
  /** Destination flags for dual persistence */
  destinations?:
    | DestinationFlags
    | undefined;
  /** Data lake partitioning hints */
  partitionInfo?: PartitionInfo | undefined;
}

/** OpenTelemetry metric data */
export interface MetricData {
  /** Metric name */
  name: string;
  /** Metric description */
  description: string;
  /** Metric unit (e.g., "ms", "bytes", "1") */
  unit: string;
  /** Gauge metric */
  gauge?:
    | GaugeData
    | undefined;
  /** Counter metric */
  counter?:
    | CounterData
    | undefined;
  /** Histogram metric */
  histogram?:
    | HistogramData
    | undefined;
  /** Summary metric */
  summary?:
    | SummaryData
    | undefined;
  /** Instrumentation library info */
  instrumentationLibrary?: InstrumentationLibrary | undefined;
}

/** Gauge metric data (current value) */
export interface GaugeData {
  dataPoints: NumberDataPoint[];
}

/** Counter metric data (monotonic sum) */
export interface CounterData {
  dataPoints: NumberDataPoint[];
  /** Whether counter is monotonic */
  isMonotonic: boolean;
}

/** Histogram metric data (distribution) */
export interface HistogramData {
  dataPoints: HistogramDataPoint[];
  aggregationTemporality: AggregationTemporality;
}

/** Summary metric data (quantiles) */
export interface SummaryData {
  dataPoints: SummaryDataPoint[];
}

/** Number data point for gauge/counter metrics */
export interface NumberDataPoint {
  /** Metric labels */
  attributes: { [key: string]: AttributeValue };
  /** Start time */
  startTime?:
    | Date
    | undefined;
  /** Measurement time */
  time?:
    | Date
    | undefined;
  /** Double value */
  asDouble?:
    | number
    | undefined;
  /** Integer value */
  asInt?:
    | string
    | undefined;
  /** Associated exemplars */
  exemplars: Exemplar[];
}

export interface NumberDataPoint_AttributesEntry {
  key: string;
  value?: AttributeValue | undefined;
}

/** Histogram data point */
export interface HistogramDataPoint {
  /** Metric labels */
  attributes: { [key: string]: AttributeValue };
  /** Start time */
  startTime?:
    | Date
    | undefined;
  /** Measurement time */
  time?:
    | Date
    | undefined;
  /** Total count */
  count: string;
  /** Sum of all values */
  sum: number;
  /** Bucket boundaries */
  explicitBounds: number[];
  /** Bucket counts */
  bucketCounts: string[];
  /** Associated exemplars */
  exemplars: Exemplar[];
}

export interface HistogramDataPoint_AttributesEntry {
  key: string;
  value?: AttributeValue | undefined;
}

/** Summary data point */
export interface SummaryDataPoint {
  /** Metric labels */
  attributes: { [key: string]: AttributeValue };
  /** Start time */
  startTime?:
    | Date
    | undefined;
  /** Measurement time */
  time?:
    | Date
    | undefined;
  /** Total count */
  count: string;
  /** Sum of all values */
  sum: number;
  /** Quantile values */
  quantileValues: QuantileValue[];
}

export interface SummaryDataPoint_AttributesEntry {
  key: string;
  value?: AttributeValue | undefined;
}

/** Quantile value for summary metrics */
export interface QuantileValue {
  /** Quantile (0.0 to 1.0) */
  quantile: number;
  /** Value at quantile */
  value: number;
}

/** Exemplar for linking metrics to traces */
export interface Exemplar {
  /** Filtered attributes */
  filteredAttributes: { [key: string]: AttributeValue };
  /** Exemplar timestamp */
  timestamp?:
    | Date
    | undefined;
  /** Double value */
  asDouble?:
    | number
    | undefined;
  /** Integer value */
  asInt?:
    | string
    | undefined;
  /** Associated span ID */
  spanId: string;
  /** Associated trace ID */
  traceId: string;
}

export interface Exemplar_FilteredAttributesEntry {
  key: string;
  value?: AttributeValue | undefined;
}

/**
 * Service health event for status page integration
 * Represents overall service health and dependencies
 */
export interface ServiceHealthEvent {
  /** Standard CDC event fields */
  eventId: string;
  /** Event timestamp */
  timestamp?:
    | Date
    | undefined;
  /** Always "service_health" */
  eventType: string;
  /** CDC sequence for ordering */
  sequenceNumber: string;
  /** Service identification */
  resource?:
    | Resource
    | undefined;
  /** Health data */
  health?:
    | ServiceHealth
    | undefined;
  /** Destination flags for dual persistence */
  destinations?:
    | DestinationFlags
    | undefined;
  /** Data lake partitioning hints */
  partitionInfo?: PartitionInfo | undefined;
}

/** Service health status */
export interface ServiceHealth {
  /** Service identifier */
  serviceName: string;
  /** Overall health status */
  status: HealthStatus;
  /** Human-readable status message */
  statusMessage: string;
  /** Health check details */
  healthChecks: HealthCheck[];
  /** Service dependencies */
  dependencies: DependencyHealth[];
  /** Service Level Indicators (SLIs) */
  slis?:
    | ServiceLevelIndicators
    | undefined;
  /** System metrics */
  systemMetrics?:
    | SystemMetrics
    | undefined;
  /** Uptime information */
  uptime?: UptimeInfo | undefined;
}

/** Individual health check result */
export interface HealthCheck {
  /** Health check name */
  name: string;
  /** Check status */
  status: HealthStatus;
  /** Check message */
  message: string;
  /** Last check time */
  lastCheck?:
    | Date
    | undefined;
  /** Response time in milliseconds */
  responseTimeMs: string;
  /** Additional check metadata */
  metadata: { [key: string]: string };
}

export interface HealthCheck_MetadataEntry {
  key: string;
  value: string;
}

/** Dependency health status */
export interface DependencyHealth {
  /** Dependency name */
  name: string;
  /** Dependency type (database, service, etc.) */
  type: string;
  /** Dependency status */
  status: HealthStatus;
  /** Dependency endpoint */
  endpoint: string;
  /** Response time in milliseconds */
  responseTimeMs: string;
  /** Dependency version */
  version: string;
  /** Last check time */
  lastCheck?: Date | undefined;
}

/** Service Level Indicators */
export interface ServiceLevelIndicators {
  /** Availability percentage */
  availabilityPercent: number;
  /** Error rate percentage */
  errorRatePercent: number;
  /** 50th percentile latency */
  latencyP50Ms: number;
  /** 95th percentile latency */
  latencyP95Ms: number;
  /** 99th percentile latency */
  latencyP99Ms: number;
  /** Requests per second */
  throughputRps: number;
  /** Time window for these metrics */
  windowStart?: Date | undefined;
  windowEnd?: Date | undefined;
}

/** System-level metrics */
export interface SystemMetrics {
  /** CPU metrics */
  cpuUsagePercent: number;
  /** 1-minute load average */
  cpuLoad1m: number;
  /** 5-minute load average */
  cpuLoad5m: number;
  /** 15-minute load average */
  cpuLoad15m: number;
  /** Memory metrics */
  memoryTotalBytes: string;
  /** Used memory */
  memoryUsedBytes: string;
  /** Available memory */
  memoryAvailableBytes: string;
  /** Memory usage percentage */
  memoryUsagePercent: number;
  /** Disk metrics */
  diskTotalBytes: string;
  /** Used disk space */
  diskUsedBytes: string;
  /** Available disk space */
  diskAvailableBytes: string;
  /** Disk usage percentage */
  diskUsagePercent: number;
  /** Network metrics */
  networkBytesSent: string;
  /** Network bytes received */
  networkBytesReceived: string;
  /** Network packets sent */
  networkPacketsSent: string;
  /** Network packets received */
  networkPacketsReceived: string;
  /** Process metrics */
  processCount: number;
  /** Number of threads */
  threadCount: number;
  /** Number of open file descriptors */
  fileDescriptorCount: number;
}

/** Service uptime information */
export interface UptimeInfo {
  /** Service start time */
  startTime?:
    | Date
    | undefined;
  /** Uptime in seconds */
  uptimeSeconds: string;
  /** Number of restarts */
  restartCount: number;
  /** Last restart time */
  lastRestart?: Date | undefined;
}

/**
 * Incident event for status page and alerting
 * Represents service incidents and their lifecycle
 */
export interface IncidentEvent {
  /** Standard CDC event fields */
  eventId: string;
  /** Event timestamp */
  timestamp?:
    | Date
    | undefined;
  /** Always "incident" */
  eventType: string;
  /** CDC sequence for ordering */
  sequenceNumber: string;
  /** Incident data */
  incident?:
    | IncidentData
    | undefined;
  /** Destination flags for dual persistence */
  destinations?:
    | DestinationFlags
    | undefined;
  /** Data lake partitioning hints */
  partitionInfo?: PartitionInfo | undefined;
}

/** Incident data for tracking service issues */
export interface IncidentData {
  /** Unique incident identifier */
  incidentId: string;
  /** Incident title */
  title: string;
  /** Incident description */
  description: string;
  /** Incident severity */
  severity: IncidentSeverity;
  /** Current incident status */
  status: IncidentStatus;
  /** Timing information */
  createdAt?: Date | undefined;
  updatedAt?: Date | undefined;
  resolvedAt?:
    | Date
    | undefined;
  /** Affected services and components */
  affectedServices: string[];
  affectedComponents: string[];
  /** Incident updates */
  updates: IncidentUpdate[];
  /** Impact assessment */
  impact?:
    | IncidentImpact
    | undefined;
  /** Resolution information */
  resolution?: IncidentResolution | undefined;
}

/** Incident update/communication */
export interface IncidentUpdate {
  /** Unique update identifier */
  updateId: string;
  /** Update timestamp */
  timestamp?:
    | Date
    | undefined;
  /** Status at time of update */
  status: IncidentStatus;
  /** Update message */
  message: string;
  /** Update author */
  author: string;
  /** Type of update */
  type: UpdateType;
}

/** Incident impact assessment */
export interface IncidentImpact {
  /** Impact on availability (0-1) */
  availabilityImpact: number;
  /** Impact on performance (0-1) */
  performanceImpact: number;
  /** Number of affected users */
  affectedUsers: number;
  /** Affected geographical regions */
  affectedRegions: string[];
  /** Business impact description */
  businessImpact: string;
}

/** Incident resolution information */
export interface IncidentResolution {
  /** Root cause description */
  rootCause: string;
  /** Steps taken to resolve */
  resolutionSteps: string;
  /** Measures to prevent recurrence */
  preventionMeasures: string;
  /** Lessons learned */
  lessonsLearned: string[];
  /** Link to detailed post-mortem */
  postmortemUrl: string;
}

/** Generic ingestion response */
export interface IngestResponse {
  success: boolean;
  message: string;
  processedCount: number;
  failedCount: number;
}

/** Health reporting response */
export interface HealthResponse {
  success: boolean;
  message: string;
  nextCheck?: Date | undefined;
}

/** Incident reporting response */
export interface IncidentResponse {
  success: boolean;
  message: string;
  incidentId: string;
}

/** Health query request */
export interface HealthQuery {
  /** Filter by service names */
  serviceNames: string[];
  /** Since timestamp */
  since?: Date | undefined;
}

/** Health query response */
export interface HealthQueryResponse {
  services: ServiceHealth[];
}

/** Incident query request */
export interface IncidentQuery {
  /** Filter by status */
  statuses: IncidentStatus[];
  /** Filter by severity */
  severities: IncidentSeverity[];
  /** Since timestamp */
  since?: Date | undefined;
}

/** Incident query response */
export interface IncidentQueryResponse {
  incidents: IncidentData[];
}

/** Metric query request */
export interface MetricQuery {
  /** Metric name to query */
  metricName: string;
  /** Label filters */
  labels: { [key: string]: string };
  /** Query start time */
  startTime?:
    | Date
    | undefined;
  /** Query end time */
  endTime?: Date | undefined;
}

export interface MetricQuery_LabelsEntry {
  key: string;
  value: string;
}

/** Metric query response */
export interface MetricQueryResponse {
  metrics: MetricData[];
}

/** Trace query request */
export interface TraceQuery {
  /** Specific trace ID */
  traceId: string;
  /** Filter by service */
  serviceName: string;
  /** Query start time */
  startTime?:
    | Date
    | undefined;
  /** Query end time */
  endTime?:
    | Date
    | undefined;
  /** Result limit */
  limit: number;
}

/** Trace query response */
export interface TraceQueryResponse {
  traces: TraceEvent[];
}

function createBaseTraceContext(): TraceContext {
  return {
    traceId: "",
    spanId: "",
    parentSpanId: "",
    traceFlags: undefined,
    traceState: "",
    correlationId: "",
    requestId: "",
    sessionId: "",
    userId: "",
  };
}

export const TraceContext = {
  encode(message: TraceContext, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.traceId !== "") {
      writer.uint32(10).string(message.traceId);
    }
    if (message.spanId !== "") {
      writer.uint32(18).string(message.spanId);
    }
    if (message.parentSpanId !== "") {
      writer.uint32(26).string(message.parentSpanId);
    }
    if (message.traceFlags !== undefined) {
      TraceFlags.encode(message.traceFlags, writer.uint32(34).fork()).ldelim();
    }
    if (message.traceState !== "") {
      writer.uint32(42).string(message.traceState);
    }
    if (message.correlationId !== "") {
      writer.uint32(82).string(message.correlationId);
    }
    if (message.requestId !== "") {
      writer.uint32(90).string(message.requestId);
    }
    if (message.sessionId !== "") {
      writer.uint32(98).string(message.sessionId);
    }
    if (message.userId !== "") {
      writer.uint32(106).string(message.userId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TraceContext {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTraceContext();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.traceId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.spanId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.parentSpanId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.traceFlags = TraceFlags.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.traceState = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.correlationId = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.userId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TraceContext {
    return {
      traceId: isSet(object.traceId) ? globalThis.String(object.traceId) : "",
      spanId: isSet(object.spanId) ? globalThis.String(object.spanId) : "",
      parentSpanId: isSet(object.parentSpanId) ? globalThis.String(object.parentSpanId) : "",
      traceFlags: isSet(object.traceFlags) ? TraceFlags.fromJSON(object.traceFlags) : undefined,
      traceState: isSet(object.traceState) ? globalThis.String(object.traceState) : "",
      correlationId: isSet(object.correlationId) ? globalThis.String(object.correlationId) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
    };
  },

  toJSON(message: TraceContext): unknown {
    const obj: any = {};
    if (message.traceId !== "") {
      obj.traceId = message.traceId;
    }
    if (message.spanId !== "") {
      obj.spanId = message.spanId;
    }
    if (message.parentSpanId !== "") {
      obj.parentSpanId = message.parentSpanId;
    }
    if (message.traceFlags !== undefined) {
      obj.traceFlags = TraceFlags.toJSON(message.traceFlags);
    }
    if (message.traceState !== "") {
      obj.traceState = message.traceState;
    }
    if (message.correlationId !== "") {
      obj.correlationId = message.correlationId;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TraceContext>, I>>(base?: I): TraceContext {
    return TraceContext.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TraceContext>, I>>(object: I): TraceContext {
    const message = createBaseTraceContext();
    message.traceId = object.traceId ?? "";
    message.spanId = object.spanId ?? "";
    message.parentSpanId = object.parentSpanId ?? "";
    message.traceFlags = (object.traceFlags !== undefined && object.traceFlags !== null)
      ? TraceFlags.fromPartial(object.traceFlags)
      : undefined;
    message.traceState = object.traceState ?? "";
    message.correlationId = object.correlationId ?? "";
    message.requestId = object.requestId ?? "";
    message.sessionId = object.sessionId ?? "";
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseTraceFlags(): TraceFlags {
  return { sampled: false, randomTraceId: false };
}

export const TraceFlags = {
  encode(message: TraceFlags, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sampled !== false) {
      writer.uint32(8).bool(message.sampled);
    }
    if (message.randomTraceId !== false) {
      writer.uint32(16).bool(message.randomTraceId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TraceFlags {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTraceFlags();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sampled = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.randomTraceId = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TraceFlags {
    return {
      sampled: isSet(object.sampled) ? globalThis.Boolean(object.sampled) : false,
      randomTraceId: isSet(object.randomTraceId) ? globalThis.Boolean(object.randomTraceId) : false,
    };
  },

  toJSON(message: TraceFlags): unknown {
    const obj: any = {};
    if (message.sampled !== false) {
      obj.sampled = message.sampled;
    }
    if (message.randomTraceId !== false) {
      obj.randomTraceId = message.randomTraceId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TraceFlags>, I>>(base?: I): TraceFlags {
    return TraceFlags.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TraceFlags>, I>>(object: I): TraceFlags {
    const message = createBaseTraceFlags();
    message.sampled = object.sampled ?? false;
    message.randomTraceId = object.randomTraceId ?? false;
    return message;
  },
};

function createBaseResource(): Resource {
  return {
    serviceName: "",
    serviceVersion: "",
    serviceInstanceId: "",
    deploymentEnvironment: "",
    k8sClusterName: "",
    k8sNamespace: "",
    k8sPodName: "",
    hostName: "",
    hostArch: "",
    attributes: {},
  };
}

export const Resource = {
  encode(message: Resource, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.serviceName !== "") {
      writer.uint32(10).string(message.serviceName);
    }
    if (message.serviceVersion !== "") {
      writer.uint32(18).string(message.serviceVersion);
    }
    if (message.serviceInstanceId !== "") {
      writer.uint32(26).string(message.serviceInstanceId);
    }
    if (message.deploymentEnvironment !== "") {
      writer.uint32(34).string(message.deploymentEnvironment);
    }
    if (message.k8sClusterName !== "") {
      writer.uint32(42).string(message.k8sClusterName);
    }
    if (message.k8sNamespace !== "") {
      writer.uint32(50).string(message.k8sNamespace);
    }
    if (message.k8sPodName !== "") {
      writer.uint32(58).string(message.k8sPodName);
    }
    if (message.hostName !== "") {
      writer.uint32(66).string(message.hostName);
    }
    if (message.hostArch !== "") {
      writer.uint32(74).string(message.hostArch);
    }
    Object.entries(message.attributes).forEach(([key, value]) => {
      Resource_AttributesEntry.encode({ key: key as any, value }, writer.uint32(162).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Resource {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.serviceName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.serviceVersion = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.serviceInstanceId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.deploymentEnvironment = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.k8sClusterName = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.k8sNamespace = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.k8sPodName = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.hostName = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.hostArch = reader.string();
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          const entry20 = Resource_AttributesEntry.decode(reader, reader.uint32());
          if (entry20.value !== undefined) {
            message.attributes[entry20.key] = entry20.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Resource {
    return {
      serviceName: isSet(object.serviceName) ? globalThis.String(object.serviceName) : "",
      serviceVersion: isSet(object.serviceVersion) ? globalThis.String(object.serviceVersion) : "",
      serviceInstanceId: isSet(object.serviceInstanceId) ? globalThis.String(object.serviceInstanceId) : "",
      deploymentEnvironment: isSet(object.deploymentEnvironment) ? globalThis.String(object.deploymentEnvironment) : "",
      k8sClusterName: isSet(object.k8sClusterName) ? globalThis.String(object.k8sClusterName) : "",
      k8sNamespace: isSet(object.k8sNamespace) ? globalThis.String(object.k8sNamespace) : "",
      k8sPodName: isSet(object.k8sPodName) ? globalThis.String(object.k8sPodName) : "",
      hostName: isSet(object.hostName) ? globalThis.String(object.hostName) : "",
      hostArch: isSet(object.hostArch) ? globalThis.String(object.hostArch) : "",
      attributes: isObject(object.attributes)
        ? Object.entries(object.attributes).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Resource): unknown {
    const obj: any = {};
    if (message.serviceName !== "") {
      obj.serviceName = message.serviceName;
    }
    if (message.serviceVersion !== "") {
      obj.serviceVersion = message.serviceVersion;
    }
    if (message.serviceInstanceId !== "") {
      obj.serviceInstanceId = message.serviceInstanceId;
    }
    if (message.deploymentEnvironment !== "") {
      obj.deploymentEnvironment = message.deploymentEnvironment;
    }
    if (message.k8sClusterName !== "") {
      obj.k8sClusterName = message.k8sClusterName;
    }
    if (message.k8sNamespace !== "") {
      obj.k8sNamespace = message.k8sNamespace;
    }
    if (message.k8sPodName !== "") {
      obj.k8sPodName = message.k8sPodName;
    }
    if (message.hostName !== "") {
      obj.hostName = message.hostName;
    }
    if (message.hostArch !== "") {
      obj.hostArch = message.hostArch;
    }
    if (message.attributes) {
      const entries = Object.entries(message.attributes);
      if (entries.length > 0) {
        obj.attributes = {};
        entries.forEach(([k, v]) => {
          obj.attributes[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Resource>, I>>(base?: I): Resource {
    return Resource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Resource>, I>>(object: I): Resource {
    const message = createBaseResource();
    message.serviceName = object.serviceName ?? "";
    message.serviceVersion = object.serviceVersion ?? "";
    message.serviceInstanceId = object.serviceInstanceId ?? "";
    message.deploymentEnvironment = object.deploymentEnvironment ?? "";
    message.k8sClusterName = object.k8sClusterName ?? "";
    message.k8sNamespace = object.k8sNamespace ?? "";
    message.k8sPodName = object.k8sPodName ?? "";
    message.hostName = object.hostName ?? "";
    message.hostArch = object.hostArch ?? "";
    message.attributes = Object.entries(object.attributes ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseResource_AttributesEntry(): Resource_AttributesEntry {
  return { key: "", value: "" };
}

export const Resource_AttributesEntry = {
  encode(message: Resource_AttributesEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Resource_AttributesEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResource_AttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Resource_AttributesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Resource_AttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Resource_AttributesEntry>, I>>(base?: I): Resource_AttributesEntry {
    return Resource_AttributesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Resource_AttributesEntry>, I>>(object: I): Resource_AttributesEntry {
    const message = createBaseResource_AttributesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseLogEvent(): LogEvent {
  return {
    eventId: "",
    timestamp: undefined,
    eventType: "",
    sequenceNumber: "0",
    traceContext: undefined,
    resource: undefined,
    level: 0,
    message: "",
    metadata: undefined,
    error: undefined,
    destinations: undefined,
    partitionInfo: undefined,
  };
}

export const LogEvent = {
  encode(message: LogEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== "") {
      writer.uint32(10).string(message.eventId);
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(18).fork()).ldelim();
    }
    if (message.eventType !== "") {
      writer.uint32(26).string(message.eventType);
    }
    if (message.sequenceNumber !== "0") {
      writer.uint32(32).int64(message.sequenceNumber);
    }
    if (message.traceContext !== undefined) {
      TraceContext.encode(message.traceContext, writer.uint32(42).fork()).ldelim();
    }
    if (message.resource !== undefined) {
      Resource.encode(message.resource, writer.uint32(50).fork()).ldelim();
    }
    if (message.level !== 0) {
      writer.uint32(80).int32(message.level);
    }
    if (message.message !== "") {
      writer.uint32(90).string(message.message);
    }
    if (message.metadata !== undefined) {
      Struct.encode(Struct.wrap(message.metadata), writer.uint32(98).fork()).ldelim();
    }
    if (message.error !== undefined) {
      ErrorInfo.encode(message.error, writer.uint32(122).fork()).ldelim();
    }
    if (message.destinations !== undefined) {
      DestinationFlags.encode(message.destinations, writer.uint32(162).fork()).ldelim();
    }
    if (message.partitionInfo !== undefined) {
      PartitionInfo.encode(message.partitionInfo, writer.uint32(202).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LogEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.eventId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.eventType = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.sequenceNumber = longToString(reader.int64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.traceContext = TraceContext.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.resource = Resource.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.level = reader.int32() as any;
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.message = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.metadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.error = ErrorInfo.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.destinations = DestinationFlags.decode(reader, reader.uint32());
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.partitionInfo = PartitionInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogEvent {
    return {
      eventId: isSet(object.eventId) ? globalThis.String(object.eventId) : "",
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      eventType: isSet(object.eventType) ? globalThis.String(object.eventType) : "",
      sequenceNumber: isSet(object.sequenceNumber) ? globalThis.String(object.sequenceNumber) : "0",
      traceContext: isSet(object.traceContext) ? TraceContext.fromJSON(object.traceContext) : undefined,
      resource: isSet(object.resource) ? Resource.fromJSON(object.resource) : undefined,
      level: isSet(object.level) ? logLevelFromJSON(object.level) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      metadata: isObject(object.metadata) ? object.metadata : undefined,
      error: isSet(object.error) ? ErrorInfo.fromJSON(object.error) : undefined,
      destinations: isSet(object.destinations) ? DestinationFlags.fromJSON(object.destinations) : undefined,
      partitionInfo: isSet(object.partitionInfo) ? PartitionInfo.fromJSON(object.partitionInfo) : undefined,
    };
  },

  toJSON(message: LogEvent): unknown {
    const obj: any = {};
    if (message.eventId !== "") {
      obj.eventId = message.eventId;
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.eventType !== "") {
      obj.eventType = message.eventType;
    }
    if (message.sequenceNumber !== "0") {
      obj.sequenceNumber = message.sequenceNumber;
    }
    if (message.traceContext !== undefined) {
      obj.traceContext = TraceContext.toJSON(message.traceContext);
    }
    if (message.resource !== undefined) {
      obj.resource = Resource.toJSON(message.resource);
    }
    if (message.level !== 0) {
      obj.level = logLevelToJSON(message.level);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    if (message.error !== undefined) {
      obj.error = ErrorInfo.toJSON(message.error);
    }
    if (message.destinations !== undefined) {
      obj.destinations = DestinationFlags.toJSON(message.destinations);
    }
    if (message.partitionInfo !== undefined) {
      obj.partitionInfo = PartitionInfo.toJSON(message.partitionInfo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LogEvent>, I>>(base?: I): LogEvent {
    return LogEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LogEvent>, I>>(object: I): LogEvent {
    const message = createBaseLogEvent();
    message.eventId = object.eventId ?? "";
    message.timestamp = object.timestamp ?? undefined;
    message.eventType = object.eventType ?? "";
    message.sequenceNumber = object.sequenceNumber ?? "0";
    message.traceContext = (object.traceContext !== undefined && object.traceContext !== null)
      ? TraceContext.fromPartial(object.traceContext)
      : undefined;
    message.resource = (object.resource !== undefined && object.resource !== null)
      ? Resource.fromPartial(object.resource)
      : undefined;
    message.level = object.level ?? 0;
    message.message = object.message ?? "";
    message.metadata = object.metadata ?? undefined;
    message.error = (object.error !== undefined && object.error !== null)
      ? ErrorInfo.fromPartial(object.error)
      : undefined;
    message.destinations = (object.destinations !== undefined && object.destinations !== null)
      ? DestinationFlags.fromPartial(object.destinations)
      : undefined;
    message.partitionInfo = (object.partitionInfo !== undefined && object.partitionInfo !== null)
      ? PartitionInfo.fromPartial(object.partitionInfo)
      : undefined;
    return message;
  },
};

function createBaseErrorInfo(): ErrorInfo {
  return { errorType: "", errorMessage: "", stackTrace: "", errorCode: "", errorAttributes: {} };
}

export const ErrorInfo = {
  encode(message: ErrorInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.errorType !== "") {
      writer.uint32(10).string(message.errorType);
    }
    if (message.errorMessage !== "") {
      writer.uint32(18).string(message.errorMessage);
    }
    if (message.stackTrace !== "") {
      writer.uint32(26).string(message.stackTrace);
    }
    if (message.errorCode !== "") {
      writer.uint32(34).string(message.errorCode);
    }
    Object.entries(message.errorAttributes).forEach(([key, value]) => {
      ErrorInfo_ErrorAttributesEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ErrorInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseErrorInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.errorType = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.stackTrace = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.errorCode = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = ErrorInfo_ErrorAttributesEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.errorAttributes[entry5.key] = entry5.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ErrorInfo {
    return {
      errorType: isSet(object.errorType) ? globalThis.String(object.errorType) : "",
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
      stackTrace: isSet(object.stackTrace) ? globalThis.String(object.stackTrace) : "",
      errorCode: isSet(object.errorCode) ? globalThis.String(object.errorCode) : "",
      errorAttributes: isObject(object.errorAttributes)
        ? Object.entries(object.errorAttributes).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ErrorInfo): unknown {
    const obj: any = {};
    if (message.errorType !== "") {
      obj.errorType = message.errorType;
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    if (message.stackTrace !== "") {
      obj.stackTrace = message.stackTrace;
    }
    if (message.errorCode !== "") {
      obj.errorCode = message.errorCode;
    }
    if (message.errorAttributes) {
      const entries = Object.entries(message.errorAttributes);
      if (entries.length > 0) {
        obj.errorAttributes = {};
        entries.forEach(([k, v]) => {
          obj.errorAttributes[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ErrorInfo>, I>>(base?: I): ErrorInfo {
    return ErrorInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ErrorInfo>, I>>(object: I): ErrorInfo {
    const message = createBaseErrorInfo();
    message.errorType = object.errorType ?? "";
    message.errorMessage = object.errorMessage ?? "";
    message.stackTrace = object.stackTrace ?? "";
    message.errorCode = object.errorCode ?? "";
    message.errorAttributes = Object.entries(object.errorAttributes ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseErrorInfo_ErrorAttributesEntry(): ErrorInfo_ErrorAttributesEntry {
  return { key: "", value: "" };
}

export const ErrorInfo_ErrorAttributesEntry = {
  encode(message: ErrorInfo_ErrorAttributesEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ErrorInfo_ErrorAttributesEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseErrorInfo_ErrorAttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ErrorInfo_ErrorAttributesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ErrorInfo_ErrorAttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ErrorInfo_ErrorAttributesEntry>, I>>(base?: I): ErrorInfo_ErrorAttributesEntry {
    return ErrorInfo_ErrorAttributesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ErrorInfo_ErrorAttributesEntry>, I>>(
    object: I,
  ): ErrorInfo_ErrorAttributesEntry {
    const message = createBaseErrorInfo_ErrorAttributesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseDestinationFlags(): DestinationFlags {
  return { console: false, cdcStream: false, dataLake: false, dataLakeOptions: undefined };
}

export const DestinationFlags = {
  encode(message: DestinationFlags, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.console !== false) {
      writer.uint32(8).bool(message.console);
    }
    if (message.cdcStream !== false) {
      writer.uint32(16).bool(message.cdcStream);
    }
    if (message.dataLake !== false) {
      writer.uint32(24).bool(message.dataLake);
    }
    if (message.dataLakeOptions !== undefined) {
      DataLakeOptions.encode(message.dataLakeOptions, writer.uint32(82).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DestinationFlags {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDestinationFlags();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.console = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.cdcStream = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.dataLake = reader.bool();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.dataLakeOptions = DataLakeOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DestinationFlags {
    return {
      console: isSet(object.console) ? globalThis.Boolean(object.console) : false,
      cdcStream: isSet(object.cdcStream) ? globalThis.Boolean(object.cdcStream) : false,
      dataLake: isSet(object.dataLake) ? globalThis.Boolean(object.dataLake) : false,
      dataLakeOptions: isSet(object.dataLakeOptions) ? DataLakeOptions.fromJSON(object.dataLakeOptions) : undefined,
    };
  },

  toJSON(message: DestinationFlags): unknown {
    const obj: any = {};
    if (message.console !== false) {
      obj.console = message.console;
    }
    if (message.cdcStream !== false) {
      obj.cdcStream = message.cdcStream;
    }
    if (message.dataLake !== false) {
      obj.dataLake = message.dataLake;
    }
    if (message.dataLakeOptions !== undefined) {
      obj.dataLakeOptions = DataLakeOptions.toJSON(message.dataLakeOptions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DestinationFlags>, I>>(base?: I): DestinationFlags {
    return DestinationFlags.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DestinationFlags>, I>>(object: I): DestinationFlags {
    const message = createBaseDestinationFlags();
    message.console = object.console ?? false;
    message.cdcStream = object.cdcStream ?? false;
    message.dataLake = object.dataLake ?? false;
    message.dataLakeOptions = (object.dataLakeOptions !== undefined && object.dataLakeOptions !== null)
      ? DataLakeOptions.fromPartial(object.dataLakeOptions)
      : undefined;
    return message;
  },
};

function createBaseDataLakeOptions(): DataLakeOptions {
  return { tableName: "", partitionStrategy: "", batchSize: 0, flushIntervalSeconds: 0, compression: 0 };
}

export const DataLakeOptions = {
  encode(message: DataLakeOptions, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tableName !== "") {
      writer.uint32(10).string(message.tableName);
    }
    if (message.partitionStrategy !== "") {
      writer.uint32(18).string(message.partitionStrategy);
    }
    if (message.batchSize !== 0) {
      writer.uint32(24).int32(message.batchSize);
    }
    if (message.flushIntervalSeconds !== 0) {
      writer.uint32(32).int32(message.flushIntervalSeconds);
    }
    if (message.compression !== 0) {
      writer.uint32(40).int32(message.compression);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DataLakeOptions {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataLakeOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tableName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.partitionStrategy = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.batchSize = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.flushIntervalSeconds = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.compression = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataLakeOptions {
    return {
      tableName: isSet(object.tableName) ? globalThis.String(object.tableName) : "",
      partitionStrategy: isSet(object.partitionStrategy) ? globalThis.String(object.partitionStrategy) : "",
      batchSize: isSet(object.batchSize) ? globalThis.Number(object.batchSize) : 0,
      flushIntervalSeconds: isSet(object.flushIntervalSeconds) ? globalThis.Number(object.flushIntervalSeconds) : 0,
      compression: isSet(object.compression) ? compressionTypeFromJSON(object.compression) : 0,
    };
  },

  toJSON(message: DataLakeOptions): unknown {
    const obj: any = {};
    if (message.tableName !== "") {
      obj.tableName = message.tableName;
    }
    if (message.partitionStrategy !== "") {
      obj.partitionStrategy = message.partitionStrategy;
    }
    if (message.batchSize !== 0) {
      obj.batchSize = Math.round(message.batchSize);
    }
    if (message.flushIntervalSeconds !== 0) {
      obj.flushIntervalSeconds = Math.round(message.flushIntervalSeconds);
    }
    if (message.compression !== 0) {
      obj.compression = compressionTypeToJSON(message.compression);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DataLakeOptions>, I>>(base?: I): DataLakeOptions {
    return DataLakeOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DataLakeOptions>, I>>(object: I): DataLakeOptions {
    const message = createBaseDataLakeOptions();
    message.tableName = object.tableName ?? "";
    message.partitionStrategy = object.partitionStrategy ?? "";
    message.batchSize = object.batchSize ?? 0;
    message.flushIntervalSeconds = object.flushIntervalSeconds ?? 0;
    message.compression = object.compression ?? 0;
    return message;
  },
};

function createBasePartitionInfo(): PartitionInfo {
  return { datePartition: "", hourPartition: "", servicePartition: "", levelPartition: "", customPartitions: {} };
}

export const PartitionInfo = {
  encode(message: PartitionInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.datePartition !== "") {
      writer.uint32(10).string(message.datePartition);
    }
    if (message.hourPartition !== "") {
      writer.uint32(18).string(message.hourPartition);
    }
    if (message.servicePartition !== "") {
      writer.uint32(26).string(message.servicePartition);
    }
    if (message.levelPartition !== "") {
      writer.uint32(34).string(message.levelPartition);
    }
    Object.entries(message.customPartitions).forEach(([key, value]) => {
      PartitionInfo_CustomPartitionsEntry.encode({ key: key as any, value }, writer.uint32(82).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PartitionInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePartitionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.datePartition = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.hourPartition = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.servicePartition = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.levelPartition = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          const entry10 = PartitionInfo_CustomPartitionsEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            message.customPartitions[entry10.key] = entry10.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PartitionInfo {
    return {
      datePartition: isSet(object.datePartition) ? globalThis.String(object.datePartition) : "",
      hourPartition: isSet(object.hourPartition) ? globalThis.String(object.hourPartition) : "",
      servicePartition: isSet(object.servicePartition) ? globalThis.String(object.servicePartition) : "",
      levelPartition: isSet(object.levelPartition) ? globalThis.String(object.levelPartition) : "",
      customPartitions: isObject(object.customPartitions)
        ? Object.entries(object.customPartitions).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: PartitionInfo): unknown {
    const obj: any = {};
    if (message.datePartition !== "") {
      obj.datePartition = message.datePartition;
    }
    if (message.hourPartition !== "") {
      obj.hourPartition = message.hourPartition;
    }
    if (message.servicePartition !== "") {
      obj.servicePartition = message.servicePartition;
    }
    if (message.levelPartition !== "") {
      obj.levelPartition = message.levelPartition;
    }
    if (message.customPartitions) {
      const entries = Object.entries(message.customPartitions);
      if (entries.length > 0) {
        obj.customPartitions = {};
        entries.forEach(([k, v]) => {
          obj.customPartitions[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PartitionInfo>, I>>(base?: I): PartitionInfo {
    return PartitionInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PartitionInfo>, I>>(object: I): PartitionInfo {
    const message = createBasePartitionInfo();
    message.datePartition = object.datePartition ?? "";
    message.hourPartition = object.hourPartition ?? "";
    message.servicePartition = object.servicePartition ?? "";
    message.levelPartition = object.levelPartition ?? "";
    message.customPartitions = Object.entries(object.customPartitions ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBasePartitionInfo_CustomPartitionsEntry(): PartitionInfo_CustomPartitionsEntry {
  return { key: "", value: "" };
}

export const PartitionInfo_CustomPartitionsEntry = {
  encode(message: PartitionInfo_CustomPartitionsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PartitionInfo_CustomPartitionsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePartitionInfo_CustomPartitionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PartitionInfo_CustomPartitionsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: PartitionInfo_CustomPartitionsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PartitionInfo_CustomPartitionsEntry>, I>>(
    base?: I,
  ): PartitionInfo_CustomPartitionsEntry {
    return PartitionInfo_CustomPartitionsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PartitionInfo_CustomPartitionsEntry>, I>>(
    object: I,
  ): PartitionInfo_CustomPartitionsEntry {
    const message = createBasePartitionInfo_CustomPartitionsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseTraceEvent(): TraceEvent {
  return {
    eventId: "",
    timestamp: undefined,
    eventType: "",
    sequenceNumber: "0",
    traceContext: undefined,
    resource: undefined,
    span: undefined,
    destinations: undefined,
    partitionInfo: undefined,
  };
}

export const TraceEvent = {
  encode(message: TraceEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== "") {
      writer.uint32(10).string(message.eventId);
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(18).fork()).ldelim();
    }
    if (message.eventType !== "") {
      writer.uint32(26).string(message.eventType);
    }
    if (message.sequenceNumber !== "0") {
      writer.uint32(32).int64(message.sequenceNumber);
    }
    if (message.traceContext !== undefined) {
      TraceContext.encode(message.traceContext, writer.uint32(42).fork()).ldelim();
    }
    if (message.resource !== undefined) {
      Resource.encode(message.resource, writer.uint32(50).fork()).ldelim();
    }
    if (message.span !== undefined) {
      SpanData.encode(message.span, writer.uint32(82).fork()).ldelim();
    }
    if (message.destinations !== undefined) {
      DestinationFlags.encode(message.destinations, writer.uint32(162).fork()).ldelim();
    }
    if (message.partitionInfo !== undefined) {
      PartitionInfo.encode(message.partitionInfo, writer.uint32(202).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TraceEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTraceEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.eventId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.eventType = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.sequenceNumber = longToString(reader.int64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.traceContext = TraceContext.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.resource = Resource.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.span = SpanData.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.destinations = DestinationFlags.decode(reader, reader.uint32());
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.partitionInfo = PartitionInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TraceEvent {
    return {
      eventId: isSet(object.eventId) ? globalThis.String(object.eventId) : "",
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      eventType: isSet(object.eventType) ? globalThis.String(object.eventType) : "",
      sequenceNumber: isSet(object.sequenceNumber) ? globalThis.String(object.sequenceNumber) : "0",
      traceContext: isSet(object.traceContext) ? TraceContext.fromJSON(object.traceContext) : undefined,
      resource: isSet(object.resource) ? Resource.fromJSON(object.resource) : undefined,
      span: isSet(object.span) ? SpanData.fromJSON(object.span) : undefined,
      destinations: isSet(object.destinations) ? DestinationFlags.fromJSON(object.destinations) : undefined,
      partitionInfo: isSet(object.partitionInfo) ? PartitionInfo.fromJSON(object.partitionInfo) : undefined,
    };
  },

  toJSON(message: TraceEvent): unknown {
    const obj: any = {};
    if (message.eventId !== "") {
      obj.eventId = message.eventId;
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.eventType !== "") {
      obj.eventType = message.eventType;
    }
    if (message.sequenceNumber !== "0") {
      obj.sequenceNumber = message.sequenceNumber;
    }
    if (message.traceContext !== undefined) {
      obj.traceContext = TraceContext.toJSON(message.traceContext);
    }
    if (message.resource !== undefined) {
      obj.resource = Resource.toJSON(message.resource);
    }
    if (message.span !== undefined) {
      obj.span = SpanData.toJSON(message.span);
    }
    if (message.destinations !== undefined) {
      obj.destinations = DestinationFlags.toJSON(message.destinations);
    }
    if (message.partitionInfo !== undefined) {
      obj.partitionInfo = PartitionInfo.toJSON(message.partitionInfo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TraceEvent>, I>>(base?: I): TraceEvent {
    return TraceEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TraceEvent>, I>>(object: I): TraceEvent {
    const message = createBaseTraceEvent();
    message.eventId = object.eventId ?? "";
    message.timestamp = object.timestamp ?? undefined;
    message.eventType = object.eventType ?? "";
    message.sequenceNumber = object.sequenceNumber ?? "0";
    message.traceContext = (object.traceContext !== undefined && object.traceContext !== null)
      ? TraceContext.fromPartial(object.traceContext)
      : undefined;
    message.resource = (object.resource !== undefined && object.resource !== null)
      ? Resource.fromPartial(object.resource)
      : undefined;
    message.span = (object.span !== undefined && object.span !== null) ? SpanData.fromPartial(object.span) : undefined;
    message.destinations = (object.destinations !== undefined && object.destinations !== null)
      ? DestinationFlags.fromPartial(object.destinations)
      : undefined;
    message.partitionInfo = (object.partitionInfo !== undefined && object.partitionInfo !== null)
      ? PartitionInfo.fromPartial(object.partitionInfo)
      : undefined;
    return message;
  },
};

function createBaseSpanData(): SpanData {
  return {
    name: "",
    kind: 0,
    startTime: undefined,
    endTime: undefined,
    durationNanos: "0",
    status: undefined,
    attributes: {},
    events: [],
    links: [],
    instrumentationLibrary: undefined,
  };
}

export const SpanData = {
  encode(message: SpanData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.kind !== 0) {
      writer.uint32(16).int32(message.kind);
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(26).fork()).ldelim();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(34).fork()).ldelim();
    }
    if (message.durationNanos !== "0") {
      writer.uint32(40).int64(message.durationNanos);
    }
    if (message.status !== undefined) {
      SpanStatus.encode(message.status, writer.uint32(82).fork()).ldelim();
    }
    Object.entries(message.attributes).forEach(([key, value]) => {
      SpanData_AttributesEntry.encode({ key: key as any, value }, writer.uint32(122).fork()).ldelim();
    });
    for (const v of message.events) {
      SpanEvent.encode(v!, writer.uint32(162).fork()).ldelim();
    }
    for (const v of message.links) {
      SpanLink.encode(v!, writer.uint32(202).fork()).ldelim();
    }
    if (message.instrumentationLibrary !== undefined) {
      InstrumentationLibrary.encode(message.instrumentationLibrary, writer.uint32(242).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SpanData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpanData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.kind = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.durationNanos = longToString(reader.int64() as Long);
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.status = SpanStatus.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          const entry15 = SpanData_AttributesEntry.decode(reader, reader.uint32());
          if (entry15.value !== undefined) {
            message.attributes[entry15.key] = entry15.value;
          }
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.events.push(SpanEvent.decode(reader, reader.uint32()));
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.links.push(SpanLink.decode(reader, reader.uint32()));
          continue;
        case 30:
          if (tag !== 242) {
            break;
          }

          message.instrumentationLibrary = InstrumentationLibrary.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpanData {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      kind: isSet(object.kind) ? spanKindFromJSON(object.kind) : 0,
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      durationNanos: isSet(object.durationNanos) ? globalThis.String(object.durationNanos) : "0",
      status: isSet(object.status) ? SpanStatus.fromJSON(object.status) : undefined,
      attributes: isObject(object.attributes)
        ? Object.entries(object.attributes).reduce<{ [key: string]: AttributeValue }>((acc, [key, value]) => {
          acc[key] = AttributeValue.fromJSON(value);
          return acc;
        }, {})
        : {},
      events: globalThis.Array.isArray(object?.events) ? object.events.map((e: any) => SpanEvent.fromJSON(e)) : [],
      links: globalThis.Array.isArray(object?.links) ? object.links.map((e: any) => SpanLink.fromJSON(e)) : [],
      instrumentationLibrary: isSet(object.instrumentationLibrary)
        ? InstrumentationLibrary.fromJSON(object.instrumentationLibrary)
        : undefined,
    };
  },

  toJSON(message: SpanData): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.kind !== 0) {
      obj.kind = spanKindToJSON(message.kind);
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    if (message.durationNanos !== "0") {
      obj.durationNanos = message.durationNanos;
    }
    if (message.status !== undefined) {
      obj.status = SpanStatus.toJSON(message.status);
    }
    if (message.attributes) {
      const entries = Object.entries(message.attributes);
      if (entries.length > 0) {
        obj.attributes = {};
        entries.forEach(([k, v]) => {
          obj.attributes[k] = AttributeValue.toJSON(v);
        });
      }
    }
    if (message.events?.length) {
      obj.events = message.events.map((e) => SpanEvent.toJSON(e));
    }
    if (message.links?.length) {
      obj.links = message.links.map((e) => SpanLink.toJSON(e));
    }
    if (message.instrumentationLibrary !== undefined) {
      obj.instrumentationLibrary = InstrumentationLibrary.toJSON(message.instrumentationLibrary);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SpanData>, I>>(base?: I): SpanData {
    return SpanData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SpanData>, I>>(object: I): SpanData {
    const message = createBaseSpanData();
    message.name = object.name ?? "";
    message.kind = object.kind ?? 0;
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.durationNanos = object.durationNanos ?? "0";
    message.status = (object.status !== undefined && object.status !== null)
      ? SpanStatus.fromPartial(object.status)
      : undefined;
    message.attributes = Object.entries(object.attributes ?? {}).reduce<{ [key: string]: AttributeValue }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = AttributeValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.events = object.events?.map((e) => SpanEvent.fromPartial(e)) || [];
    message.links = object.links?.map((e) => SpanLink.fromPartial(e)) || [];
    message.instrumentationLibrary =
      (object.instrumentationLibrary !== undefined && object.instrumentationLibrary !== null)
        ? InstrumentationLibrary.fromPartial(object.instrumentationLibrary)
        : undefined;
    return message;
  },
};

function createBaseSpanData_AttributesEntry(): SpanData_AttributesEntry {
  return { key: "", value: undefined };
}

export const SpanData_AttributesEntry = {
  encode(message: SpanData_AttributesEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      AttributeValue.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SpanData_AttributesEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpanData_AttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = AttributeValue.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpanData_AttributesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? AttributeValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: SpanData_AttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = AttributeValue.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SpanData_AttributesEntry>, I>>(base?: I): SpanData_AttributesEntry {
    return SpanData_AttributesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SpanData_AttributesEntry>, I>>(object: I): SpanData_AttributesEntry {
    const message = createBaseSpanData_AttributesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? AttributeValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseSpanStatus(): SpanStatus {
  return { code: 0, message: "" };
}

export const SpanStatus = {
  encode(message: SpanStatus, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.code !== 0) {
      writer.uint32(8).int32(message.code);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SpanStatus {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpanStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.code = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpanStatus {
    return {
      code: isSet(object.code) ? statusCodeFromJSON(object.code) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: SpanStatus): unknown {
    const obj: any = {};
    if (message.code !== 0) {
      obj.code = statusCodeToJSON(message.code);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SpanStatus>, I>>(base?: I): SpanStatus {
    return SpanStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SpanStatus>, I>>(object: I): SpanStatus {
    const message = createBaseSpanStatus();
    message.code = object.code ?? 0;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseSpanEvent(): SpanEvent {
  return { timestamp: undefined, name: "", attributes: {} };
}

export const SpanEvent = {
  encode(message: SpanEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(10).fork()).ldelim();
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    Object.entries(message.attributes).forEach(([key, value]) => {
      SpanEvent_AttributesEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SpanEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpanEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = SpanEvent_AttributesEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.attributes[entry3.key] = entry3.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpanEvent {
    return {
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      attributes: isObject(object.attributes)
        ? Object.entries(object.attributes).reduce<{ [key: string]: AttributeValue }>((acc, [key, value]) => {
          acc[key] = AttributeValue.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: SpanEvent): unknown {
    const obj: any = {};
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.attributes) {
      const entries = Object.entries(message.attributes);
      if (entries.length > 0) {
        obj.attributes = {};
        entries.forEach(([k, v]) => {
          obj.attributes[k] = AttributeValue.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SpanEvent>, I>>(base?: I): SpanEvent {
    return SpanEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SpanEvent>, I>>(object: I): SpanEvent {
    const message = createBaseSpanEvent();
    message.timestamp = object.timestamp ?? undefined;
    message.name = object.name ?? "";
    message.attributes = Object.entries(object.attributes ?? {}).reduce<{ [key: string]: AttributeValue }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = AttributeValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseSpanEvent_AttributesEntry(): SpanEvent_AttributesEntry {
  return { key: "", value: undefined };
}

export const SpanEvent_AttributesEntry = {
  encode(message: SpanEvent_AttributesEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      AttributeValue.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SpanEvent_AttributesEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpanEvent_AttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = AttributeValue.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpanEvent_AttributesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? AttributeValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: SpanEvent_AttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = AttributeValue.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SpanEvent_AttributesEntry>, I>>(base?: I): SpanEvent_AttributesEntry {
    return SpanEvent_AttributesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SpanEvent_AttributesEntry>, I>>(object: I): SpanEvent_AttributesEntry {
    const message = createBaseSpanEvent_AttributesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? AttributeValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseSpanLink(): SpanLink {
  return { traceContext: undefined, attributes: {} };
}

export const SpanLink = {
  encode(message: SpanLink, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.traceContext !== undefined) {
      TraceContext.encode(message.traceContext, writer.uint32(10).fork()).ldelim();
    }
    Object.entries(message.attributes).forEach(([key, value]) => {
      SpanLink_AttributesEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SpanLink {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpanLink();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.traceContext = TraceContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = SpanLink_AttributesEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.attributes[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpanLink {
    return {
      traceContext: isSet(object.traceContext) ? TraceContext.fromJSON(object.traceContext) : undefined,
      attributes: isObject(object.attributes)
        ? Object.entries(object.attributes).reduce<{ [key: string]: AttributeValue }>((acc, [key, value]) => {
          acc[key] = AttributeValue.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: SpanLink): unknown {
    const obj: any = {};
    if (message.traceContext !== undefined) {
      obj.traceContext = TraceContext.toJSON(message.traceContext);
    }
    if (message.attributes) {
      const entries = Object.entries(message.attributes);
      if (entries.length > 0) {
        obj.attributes = {};
        entries.forEach(([k, v]) => {
          obj.attributes[k] = AttributeValue.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SpanLink>, I>>(base?: I): SpanLink {
    return SpanLink.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SpanLink>, I>>(object: I): SpanLink {
    const message = createBaseSpanLink();
    message.traceContext = (object.traceContext !== undefined && object.traceContext !== null)
      ? TraceContext.fromPartial(object.traceContext)
      : undefined;
    message.attributes = Object.entries(object.attributes ?? {}).reduce<{ [key: string]: AttributeValue }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = AttributeValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseSpanLink_AttributesEntry(): SpanLink_AttributesEntry {
  return { key: "", value: undefined };
}

export const SpanLink_AttributesEntry = {
  encode(message: SpanLink_AttributesEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      AttributeValue.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SpanLink_AttributesEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpanLink_AttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = AttributeValue.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpanLink_AttributesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? AttributeValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: SpanLink_AttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = AttributeValue.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SpanLink_AttributesEntry>, I>>(base?: I): SpanLink_AttributesEntry {
    return SpanLink_AttributesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SpanLink_AttributesEntry>, I>>(object: I): SpanLink_AttributesEntry {
    const message = createBaseSpanLink_AttributesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? AttributeValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseInstrumentationLibrary(): InstrumentationLibrary {
  return { name: "", version: "", schemaUrl: "" };
}

export const InstrumentationLibrary = {
  encode(message: InstrumentationLibrary, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    if (message.schemaUrl !== "") {
      writer.uint32(26).string(message.schemaUrl);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InstrumentationLibrary {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstrumentationLibrary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.version = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.schemaUrl = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InstrumentationLibrary {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      schemaUrl: isSet(object.schemaUrl) ? globalThis.String(object.schemaUrl) : "",
    };
  },

  toJSON(message: InstrumentationLibrary): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.schemaUrl !== "") {
      obj.schemaUrl = message.schemaUrl;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InstrumentationLibrary>, I>>(base?: I): InstrumentationLibrary {
    return InstrumentationLibrary.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InstrumentationLibrary>, I>>(object: I): InstrumentationLibrary {
    const message = createBaseInstrumentationLibrary();
    message.name = object.name ?? "";
    message.version = object.version ?? "";
    message.schemaUrl = object.schemaUrl ?? "";
    return message;
  },
};

function createBaseAttributeValue(): AttributeValue {
  return {
    stringValue: undefined,
    boolValue: undefined,
    intValue: undefined,
    doubleValue: undefined,
    bytesValue: undefined,
    arrayValue: undefined,
    kvlistValue: undefined,
  };
}

export const AttributeValue = {
  encode(message: AttributeValue, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.stringValue !== undefined) {
      writer.uint32(10).string(message.stringValue);
    }
    if (message.boolValue !== undefined) {
      writer.uint32(16).bool(message.boolValue);
    }
    if (message.intValue !== undefined) {
      writer.uint32(24).int64(message.intValue);
    }
    if (message.doubleValue !== undefined) {
      writer.uint32(33).double(message.doubleValue);
    }
    if (message.bytesValue !== undefined) {
      writer.uint32(42).bytes(message.bytesValue);
    }
    if (message.arrayValue !== undefined) {
      AttributeArray.encode(message.arrayValue, writer.uint32(50).fork()).ldelim();
    }
    if (message.kvlistValue !== undefined) {
      AttributeKeyValueList.encode(message.kvlistValue, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AttributeValue {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttributeValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.stringValue = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.boolValue = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.intValue = longToString(reader.int64() as Long);
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.doubleValue = reader.double();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.bytesValue = reader.bytes();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.arrayValue = AttributeArray.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.kvlistValue = AttributeKeyValueList.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AttributeValue {
    return {
      stringValue: isSet(object.stringValue) ? globalThis.String(object.stringValue) : undefined,
      boolValue: isSet(object.boolValue) ? globalThis.Boolean(object.boolValue) : undefined,
      intValue: isSet(object.intValue) ? globalThis.String(object.intValue) : undefined,
      doubleValue: isSet(object.doubleValue) ? globalThis.Number(object.doubleValue) : undefined,
      bytesValue: isSet(object.bytesValue) ? bytesFromBase64(object.bytesValue) : undefined,
      arrayValue: isSet(object.arrayValue) ? AttributeArray.fromJSON(object.arrayValue) : undefined,
      kvlistValue: isSet(object.kvlistValue) ? AttributeKeyValueList.fromJSON(object.kvlistValue) : undefined,
    };
  },

  toJSON(message: AttributeValue): unknown {
    const obj: any = {};
    if (message.stringValue !== undefined) {
      obj.stringValue = message.stringValue;
    }
    if (message.boolValue !== undefined) {
      obj.boolValue = message.boolValue;
    }
    if (message.intValue !== undefined) {
      obj.intValue = message.intValue;
    }
    if (message.doubleValue !== undefined) {
      obj.doubleValue = message.doubleValue;
    }
    if (message.bytesValue !== undefined) {
      obj.bytesValue = base64FromBytes(message.bytesValue);
    }
    if (message.arrayValue !== undefined) {
      obj.arrayValue = AttributeArray.toJSON(message.arrayValue);
    }
    if (message.kvlistValue !== undefined) {
      obj.kvlistValue = AttributeKeyValueList.toJSON(message.kvlistValue);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AttributeValue>, I>>(base?: I): AttributeValue {
    return AttributeValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AttributeValue>, I>>(object: I): AttributeValue {
    const message = createBaseAttributeValue();
    message.stringValue = object.stringValue ?? undefined;
    message.boolValue = object.boolValue ?? undefined;
    message.intValue = object.intValue ?? undefined;
    message.doubleValue = object.doubleValue ?? undefined;
    message.bytesValue = object.bytesValue ?? undefined;
    message.arrayValue = (object.arrayValue !== undefined && object.arrayValue !== null)
      ? AttributeArray.fromPartial(object.arrayValue)
      : undefined;
    message.kvlistValue = (object.kvlistValue !== undefined && object.kvlistValue !== null)
      ? AttributeKeyValueList.fromPartial(object.kvlistValue)
      : undefined;
    return message;
  },
};

function createBaseAttributeArray(): AttributeArray {
  return { values: [] };
}

export const AttributeArray = {
  encode(message: AttributeArray, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.values) {
      AttributeValue.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AttributeArray {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttributeArray();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.values.push(AttributeValue.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AttributeArray {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => AttributeValue.fromJSON(e)) : [],
    };
  },

  toJSON(message: AttributeArray): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values.map((e) => AttributeValue.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AttributeArray>, I>>(base?: I): AttributeArray {
    return AttributeArray.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AttributeArray>, I>>(object: I): AttributeArray {
    const message = createBaseAttributeArray();
    message.values = object.values?.map((e) => AttributeValue.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAttributeKeyValueList(): AttributeKeyValueList {
  return { values: [] };
}

export const AttributeKeyValueList = {
  encode(message: AttributeKeyValueList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.values) {
      AttributeKeyValue.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AttributeKeyValueList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttributeKeyValueList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.values.push(AttributeKeyValue.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AttributeKeyValueList {
    return {
      values: globalThis.Array.isArray(object?.values)
        ? object.values.map((e: any) => AttributeKeyValue.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AttributeKeyValueList): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values.map((e) => AttributeKeyValue.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AttributeKeyValueList>, I>>(base?: I): AttributeKeyValueList {
    return AttributeKeyValueList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AttributeKeyValueList>, I>>(object: I): AttributeKeyValueList {
    const message = createBaseAttributeKeyValueList();
    message.values = object.values?.map((e) => AttributeKeyValue.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAttributeKeyValue(): AttributeKeyValue {
  return { key: "", value: undefined };
}

export const AttributeKeyValue = {
  encode(message: AttributeKeyValue, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      AttributeValue.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AttributeKeyValue {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttributeKeyValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = AttributeValue.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AttributeKeyValue {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? AttributeValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: AttributeKeyValue): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = AttributeValue.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AttributeKeyValue>, I>>(base?: I): AttributeKeyValue {
    return AttributeKeyValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AttributeKeyValue>, I>>(object: I): AttributeKeyValue {
    const message = createBaseAttributeKeyValue();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? AttributeValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseMetricEvent(): MetricEvent {
  return {
    eventId: "",
    timestamp: undefined,
    eventType: "",
    sequenceNumber: "0",
    traceContext: undefined,
    resource: undefined,
    metric: undefined,
    destinations: undefined,
    partitionInfo: undefined,
  };
}

export const MetricEvent = {
  encode(message: MetricEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== "") {
      writer.uint32(10).string(message.eventId);
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(18).fork()).ldelim();
    }
    if (message.eventType !== "") {
      writer.uint32(26).string(message.eventType);
    }
    if (message.sequenceNumber !== "0") {
      writer.uint32(32).int64(message.sequenceNumber);
    }
    if (message.traceContext !== undefined) {
      TraceContext.encode(message.traceContext, writer.uint32(42).fork()).ldelim();
    }
    if (message.resource !== undefined) {
      Resource.encode(message.resource, writer.uint32(50).fork()).ldelim();
    }
    if (message.metric !== undefined) {
      MetricData.encode(message.metric, writer.uint32(82).fork()).ldelim();
    }
    if (message.destinations !== undefined) {
      DestinationFlags.encode(message.destinations, writer.uint32(162).fork()).ldelim();
    }
    if (message.partitionInfo !== undefined) {
      PartitionInfo.encode(message.partitionInfo, writer.uint32(202).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MetricEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.eventId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.eventType = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.sequenceNumber = longToString(reader.int64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.traceContext = TraceContext.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.resource = Resource.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.metric = MetricData.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.destinations = DestinationFlags.decode(reader, reader.uint32());
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.partitionInfo = PartitionInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetricEvent {
    return {
      eventId: isSet(object.eventId) ? globalThis.String(object.eventId) : "",
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      eventType: isSet(object.eventType) ? globalThis.String(object.eventType) : "",
      sequenceNumber: isSet(object.sequenceNumber) ? globalThis.String(object.sequenceNumber) : "0",
      traceContext: isSet(object.traceContext) ? TraceContext.fromJSON(object.traceContext) : undefined,
      resource: isSet(object.resource) ? Resource.fromJSON(object.resource) : undefined,
      metric: isSet(object.metric) ? MetricData.fromJSON(object.metric) : undefined,
      destinations: isSet(object.destinations) ? DestinationFlags.fromJSON(object.destinations) : undefined,
      partitionInfo: isSet(object.partitionInfo) ? PartitionInfo.fromJSON(object.partitionInfo) : undefined,
    };
  },

  toJSON(message: MetricEvent): unknown {
    const obj: any = {};
    if (message.eventId !== "") {
      obj.eventId = message.eventId;
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.eventType !== "") {
      obj.eventType = message.eventType;
    }
    if (message.sequenceNumber !== "0") {
      obj.sequenceNumber = message.sequenceNumber;
    }
    if (message.traceContext !== undefined) {
      obj.traceContext = TraceContext.toJSON(message.traceContext);
    }
    if (message.resource !== undefined) {
      obj.resource = Resource.toJSON(message.resource);
    }
    if (message.metric !== undefined) {
      obj.metric = MetricData.toJSON(message.metric);
    }
    if (message.destinations !== undefined) {
      obj.destinations = DestinationFlags.toJSON(message.destinations);
    }
    if (message.partitionInfo !== undefined) {
      obj.partitionInfo = PartitionInfo.toJSON(message.partitionInfo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MetricEvent>, I>>(base?: I): MetricEvent {
    return MetricEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MetricEvent>, I>>(object: I): MetricEvent {
    const message = createBaseMetricEvent();
    message.eventId = object.eventId ?? "";
    message.timestamp = object.timestamp ?? undefined;
    message.eventType = object.eventType ?? "";
    message.sequenceNumber = object.sequenceNumber ?? "0";
    message.traceContext = (object.traceContext !== undefined && object.traceContext !== null)
      ? TraceContext.fromPartial(object.traceContext)
      : undefined;
    message.resource = (object.resource !== undefined && object.resource !== null)
      ? Resource.fromPartial(object.resource)
      : undefined;
    message.metric = (object.metric !== undefined && object.metric !== null)
      ? MetricData.fromPartial(object.metric)
      : undefined;
    message.destinations = (object.destinations !== undefined && object.destinations !== null)
      ? DestinationFlags.fromPartial(object.destinations)
      : undefined;
    message.partitionInfo = (object.partitionInfo !== undefined && object.partitionInfo !== null)
      ? PartitionInfo.fromPartial(object.partitionInfo)
      : undefined;
    return message;
  },
};

function createBaseMetricData(): MetricData {
  return {
    name: "",
    description: "",
    unit: "",
    gauge: undefined,
    counter: undefined,
    histogram: undefined,
    summary: undefined,
    instrumentationLibrary: undefined,
  };
}

export const MetricData = {
  encode(message: MetricData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.unit !== "") {
      writer.uint32(26).string(message.unit);
    }
    if (message.gauge !== undefined) {
      GaugeData.encode(message.gauge, writer.uint32(82).fork()).ldelim();
    }
    if (message.counter !== undefined) {
      CounterData.encode(message.counter, writer.uint32(90).fork()).ldelim();
    }
    if (message.histogram !== undefined) {
      HistogramData.encode(message.histogram, writer.uint32(98).fork()).ldelim();
    }
    if (message.summary !== undefined) {
      SummaryData.encode(message.summary, writer.uint32(106).fork()).ldelim();
    }
    if (message.instrumentationLibrary !== undefined) {
      InstrumentationLibrary.encode(message.instrumentationLibrary, writer.uint32(162).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MetricData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unit = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.gauge = GaugeData.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.counter = CounterData.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.histogram = HistogramData.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.summary = SummaryData.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.instrumentationLibrary = InstrumentationLibrary.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetricData {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      unit: isSet(object.unit) ? globalThis.String(object.unit) : "",
      gauge: isSet(object.gauge) ? GaugeData.fromJSON(object.gauge) : undefined,
      counter: isSet(object.counter) ? CounterData.fromJSON(object.counter) : undefined,
      histogram: isSet(object.histogram) ? HistogramData.fromJSON(object.histogram) : undefined,
      summary: isSet(object.summary) ? SummaryData.fromJSON(object.summary) : undefined,
      instrumentationLibrary: isSet(object.instrumentationLibrary)
        ? InstrumentationLibrary.fromJSON(object.instrumentationLibrary)
        : undefined,
    };
  },

  toJSON(message: MetricData): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.unit !== "") {
      obj.unit = message.unit;
    }
    if (message.gauge !== undefined) {
      obj.gauge = GaugeData.toJSON(message.gauge);
    }
    if (message.counter !== undefined) {
      obj.counter = CounterData.toJSON(message.counter);
    }
    if (message.histogram !== undefined) {
      obj.histogram = HistogramData.toJSON(message.histogram);
    }
    if (message.summary !== undefined) {
      obj.summary = SummaryData.toJSON(message.summary);
    }
    if (message.instrumentationLibrary !== undefined) {
      obj.instrumentationLibrary = InstrumentationLibrary.toJSON(message.instrumentationLibrary);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MetricData>, I>>(base?: I): MetricData {
    return MetricData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MetricData>, I>>(object: I): MetricData {
    const message = createBaseMetricData();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.unit = object.unit ?? "";
    message.gauge = (object.gauge !== undefined && object.gauge !== null)
      ? GaugeData.fromPartial(object.gauge)
      : undefined;
    message.counter = (object.counter !== undefined && object.counter !== null)
      ? CounterData.fromPartial(object.counter)
      : undefined;
    message.histogram = (object.histogram !== undefined && object.histogram !== null)
      ? HistogramData.fromPartial(object.histogram)
      : undefined;
    message.summary = (object.summary !== undefined && object.summary !== null)
      ? SummaryData.fromPartial(object.summary)
      : undefined;
    message.instrumentationLibrary =
      (object.instrumentationLibrary !== undefined && object.instrumentationLibrary !== null)
        ? InstrumentationLibrary.fromPartial(object.instrumentationLibrary)
        : undefined;
    return message;
  },
};

function createBaseGaugeData(): GaugeData {
  return { dataPoints: [] };
}

export const GaugeData = {
  encode(message: GaugeData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.dataPoints) {
      NumberDataPoint.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GaugeData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGaugeData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dataPoints.push(NumberDataPoint.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GaugeData {
    return {
      dataPoints: globalThis.Array.isArray(object?.dataPoints)
        ? object.dataPoints.map((e: any) => NumberDataPoint.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GaugeData): unknown {
    const obj: any = {};
    if (message.dataPoints?.length) {
      obj.dataPoints = message.dataPoints.map((e) => NumberDataPoint.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GaugeData>, I>>(base?: I): GaugeData {
    return GaugeData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GaugeData>, I>>(object: I): GaugeData {
    const message = createBaseGaugeData();
    message.dataPoints = object.dataPoints?.map((e) => NumberDataPoint.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCounterData(): CounterData {
  return { dataPoints: [], isMonotonic: false };
}

export const CounterData = {
  encode(message: CounterData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.dataPoints) {
      NumberDataPoint.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.isMonotonic !== false) {
      writer.uint32(16).bool(message.isMonotonic);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CounterData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCounterData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dataPoints.push(NumberDataPoint.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.isMonotonic = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CounterData {
    return {
      dataPoints: globalThis.Array.isArray(object?.dataPoints)
        ? object.dataPoints.map((e: any) => NumberDataPoint.fromJSON(e))
        : [],
      isMonotonic: isSet(object.isMonotonic) ? globalThis.Boolean(object.isMonotonic) : false,
    };
  },

  toJSON(message: CounterData): unknown {
    const obj: any = {};
    if (message.dataPoints?.length) {
      obj.dataPoints = message.dataPoints.map((e) => NumberDataPoint.toJSON(e));
    }
    if (message.isMonotonic !== false) {
      obj.isMonotonic = message.isMonotonic;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CounterData>, I>>(base?: I): CounterData {
    return CounterData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CounterData>, I>>(object: I): CounterData {
    const message = createBaseCounterData();
    message.dataPoints = object.dataPoints?.map((e) => NumberDataPoint.fromPartial(e)) || [];
    message.isMonotonic = object.isMonotonic ?? false;
    return message;
  },
};

function createBaseHistogramData(): HistogramData {
  return { dataPoints: [], aggregationTemporality: 0 };
}

export const HistogramData = {
  encode(message: HistogramData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.dataPoints) {
      HistogramDataPoint.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.aggregationTemporality !== 0) {
      writer.uint32(16).int32(message.aggregationTemporality);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HistogramData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHistogramData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dataPoints.push(HistogramDataPoint.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.aggregationTemporality = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HistogramData {
    return {
      dataPoints: globalThis.Array.isArray(object?.dataPoints)
        ? object.dataPoints.map((e: any) => HistogramDataPoint.fromJSON(e))
        : [],
      aggregationTemporality: isSet(object.aggregationTemporality)
        ? aggregationTemporalityFromJSON(object.aggregationTemporality)
        : 0,
    };
  },

  toJSON(message: HistogramData): unknown {
    const obj: any = {};
    if (message.dataPoints?.length) {
      obj.dataPoints = message.dataPoints.map((e) => HistogramDataPoint.toJSON(e));
    }
    if (message.aggregationTemporality !== 0) {
      obj.aggregationTemporality = aggregationTemporalityToJSON(message.aggregationTemporality);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HistogramData>, I>>(base?: I): HistogramData {
    return HistogramData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HistogramData>, I>>(object: I): HistogramData {
    const message = createBaseHistogramData();
    message.dataPoints = object.dataPoints?.map((e) => HistogramDataPoint.fromPartial(e)) || [];
    message.aggregationTemporality = object.aggregationTemporality ?? 0;
    return message;
  },
};

function createBaseSummaryData(): SummaryData {
  return { dataPoints: [] };
}

export const SummaryData = {
  encode(message: SummaryData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.dataPoints) {
      SummaryDataPoint.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SummaryData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSummaryData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dataPoints.push(SummaryDataPoint.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SummaryData {
    return {
      dataPoints: globalThis.Array.isArray(object?.dataPoints)
        ? object.dataPoints.map((e: any) => SummaryDataPoint.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SummaryData): unknown {
    const obj: any = {};
    if (message.dataPoints?.length) {
      obj.dataPoints = message.dataPoints.map((e) => SummaryDataPoint.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SummaryData>, I>>(base?: I): SummaryData {
    return SummaryData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SummaryData>, I>>(object: I): SummaryData {
    const message = createBaseSummaryData();
    message.dataPoints = object.dataPoints?.map((e) => SummaryDataPoint.fromPartial(e)) || [];
    return message;
  },
};

function createBaseNumberDataPoint(): NumberDataPoint {
  return {
    attributes: {},
    startTime: undefined,
    time: undefined,
    asDouble: undefined,
    asInt: undefined,
    exemplars: [],
  };
}

export const NumberDataPoint = {
  encode(message: NumberDataPoint, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    Object.entries(message.attributes).forEach(([key, value]) => {
      NumberDataPoint_AttributesEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).ldelim();
    });
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(18).fork()).ldelim();
    }
    if (message.time !== undefined) {
      Timestamp.encode(toTimestamp(message.time), writer.uint32(26).fork()).ldelim();
    }
    if (message.asDouble !== undefined) {
      writer.uint32(81).double(message.asDouble);
    }
    if (message.asInt !== undefined) {
      writer.uint32(88).int64(message.asInt);
    }
    for (const v of message.exemplars) {
      Exemplar.encode(v!, writer.uint32(162).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NumberDataPoint {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNumberDataPoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = NumberDataPoint_AttributesEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.attributes[entry1.key] = entry1.value;
          }
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 81) {
            break;
          }

          message.asDouble = reader.double();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.asInt = longToString(reader.int64() as Long);
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.exemplars.push(Exemplar.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NumberDataPoint {
    return {
      attributes: isObject(object.attributes)
        ? Object.entries(object.attributes).reduce<{ [key: string]: AttributeValue }>((acc, [key, value]) => {
          acc[key] = AttributeValue.fromJSON(value);
          return acc;
        }, {})
        : {},
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      time: isSet(object.time) ? fromJsonTimestamp(object.time) : undefined,
      asDouble: isSet(object.asDouble) ? globalThis.Number(object.asDouble) : undefined,
      asInt: isSet(object.asInt) ? globalThis.String(object.asInt) : undefined,
      exemplars: globalThis.Array.isArray(object?.exemplars)
        ? object.exemplars.map((e: any) => Exemplar.fromJSON(e))
        : [],
    };
  },

  toJSON(message: NumberDataPoint): unknown {
    const obj: any = {};
    if (message.attributes) {
      const entries = Object.entries(message.attributes);
      if (entries.length > 0) {
        obj.attributes = {};
        entries.forEach(([k, v]) => {
          obj.attributes[k] = AttributeValue.toJSON(v);
        });
      }
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.time !== undefined) {
      obj.time = message.time.toISOString();
    }
    if (message.asDouble !== undefined) {
      obj.asDouble = message.asDouble;
    }
    if (message.asInt !== undefined) {
      obj.asInt = message.asInt;
    }
    if (message.exemplars?.length) {
      obj.exemplars = message.exemplars.map((e) => Exemplar.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NumberDataPoint>, I>>(base?: I): NumberDataPoint {
    return NumberDataPoint.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NumberDataPoint>, I>>(object: I): NumberDataPoint {
    const message = createBaseNumberDataPoint();
    message.attributes = Object.entries(object.attributes ?? {}).reduce<{ [key: string]: AttributeValue }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = AttributeValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.startTime = object.startTime ?? undefined;
    message.time = object.time ?? undefined;
    message.asDouble = object.asDouble ?? undefined;
    message.asInt = object.asInt ?? undefined;
    message.exemplars = object.exemplars?.map((e) => Exemplar.fromPartial(e)) || [];
    return message;
  },
};

function createBaseNumberDataPoint_AttributesEntry(): NumberDataPoint_AttributesEntry {
  return { key: "", value: undefined };
}

export const NumberDataPoint_AttributesEntry = {
  encode(message: NumberDataPoint_AttributesEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      AttributeValue.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NumberDataPoint_AttributesEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNumberDataPoint_AttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = AttributeValue.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NumberDataPoint_AttributesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? AttributeValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: NumberDataPoint_AttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = AttributeValue.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NumberDataPoint_AttributesEntry>, I>>(base?: I): NumberDataPoint_AttributesEntry {
    return NumberDataPoint_AttributesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NumberDataPoint_AttributesEntry>, I>>(
    object: I,
  ): NumberDataPoint_AttributesEntry {
    const message = createBaseNumberDataPoint_AttributesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? AttributeValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseHistogramDataPoint(): HistogramDataPoint {
  return {
    attributes: {},
    startTime: undefined,
    time: undefined,
    count: "0",
    sum: 0,
    explicitBounds: [],
    bucketCounts: [],
    exemplars: [],
  };
}

export const HistogramDataPoint = {
  encode(message: HistogramDataPoint, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    Object.entries(message.attributes).forEach(([key, value]) => {
      HistogramDataPoint_AttributesEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).ldelim();
    });
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(18).fork()).ldelim();
    }
    if (message.time !== undefined) {
      Timestamp.encode(toTimestamp(message.time), writer.uint32(26).fork()).ldelim();
    }
    if (message.count !== "0") {
      writer.uint32(80).uint64(message.count);
    }
    if (message.sum !== 0) {
      writer.uint32(89).double(message.sum);
    }
    writer.uint32(98).fork();
    for (const v of message.explicitBounds) {
      writer.double(v);
    }
    writer.ldelim();
    writer.uint32(106).fork();
    for (const v of message.bucketCounts) {
      writer.uint64(v);
    }
    writer.ldelim();
    for (const v of message.exemplars) {
      Exemplar.encode(v!, writer.uint32(162).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HistogramDataPoint {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHistogramDataPoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = HistogramDataPoint_AttributesEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.attributes[entry1.key] = entry1.value;
          }
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.count = longToString(reader.uint64() as Long);
          continue;
        case 11:
          if (tag !== 89) {
            break;
          }

          message.sum = reader.double();
          continue;
        case 12:
          if (tag === 97) {
            message.explicitBounds.push(reader.double());

            continue;
          }

          if (tag === 98) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.explicitBounds.push(reader.double());
            }

            continue;
          }

          break;
        case 13:
          if (tag === 104) {
            message.bucketCounts.push(longToString(reader.uint64() as Long));

            continue;
          }

          if (tag === 106) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.bucketCounts.push(longToString(reader.uint64() as Long));
            }

            continue;
          }

          break;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.exemplars.push(Exemplar.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HistogramDataPoint {
    return {
      attributes: isObject(object.attributes)
        ? Object.entries(object.attributes).reduce<{ [key: string]: AttributeValue }>((acc, [key, value]) => {
          acc[key] = AttributeValue.fromJSON(value);
          return acc;
        }, {})
        : {},
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      time: isSet(object.time) ? fromJsonTimestamp(object.time) : undefined,
      count: isSet(object.count) ? globalThis.String(object.count) : "0",
      sum: isSet(object.sum) ? globalThis.Number(object.sum) : 0,
      explicitBounds: globalThis.Array.isArray(object?.explicitBounds)
        ? object.explicitBounds.map((e: any) => globalThis.Number(e))
        : [],
      bucketCounts: globalThis.Array.isArray(object?.bucketCounts)
        ? object.bucketCounts.map((e: any) => globalThis.String(e))
        : [],
      exemplars: globalThis.Array.isArray(object?.exemplars)
        ? object.exemplars.map((e: any) => Exemplar.fromJSON(e))
        : [],
    };
  },

  toJSON(message: HistogramDataPoint): unknown {
    const obj: any = {};
    if (message.attributes) {
      const entries = Object.entries(message.attributes);
      if (entries.length > 0) {
        obj.attributes = {};
        entries.forEach(([k, v]) => {
          obj.attributes[k] = AttributeValue.toJSON(v);
        });
      }
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.time !== undefined) {
      obj.time = message.time.toISOString();
    }
    if (message.count !== "0") {
      obj.count = message.count;
    }
    if (message.sum !== 0) {
      obj.sum = message.sum;
    }
    if (message.explicitBounds?.length) {
      obj.explicitBounds = message.explicitBounds;
    }
    if (message.bucketCounts?.length) {
      obj.bucketCounts = message.bucketCounts;
    }
    if (message.exemplars?.length) {
      obj.exemplars = message.exemplars.map((e) => Exemplar.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HistogramDataPoint>, I>>(base?: I): HistogramDataPoint {
    return HistogramDataPoint.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HistogramDataPoint>, I>>(object: I): HistogramDataPoint {
    const message = createBaseHistogramDataPoint();
    message.attributes = Object.entries(object.attributes ?? {}).reduce<{ [key: string]: AttributeValue }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = AttributeValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.startTime = object.startTime ?? undefined;
    message.time = object.time ?? undefined;
    message.count = object.count ?? "0";
    message.sum = object.sum ?? 0;
    message.explicitBounds = object.explicitBounds?.map((e) => e) || [];
    message.bucketCounts = object.bucketCounts?.map((e) => e) || [];
    message.exemplars = object.exemplars?.map((e) => Exemplar.fromPartial(e)) || [];
    return message;
  },
};

function createBaseHistogramDataPoint_AttributesEntry(): HistogramDataPoint_AttributesEntry {
  return { key: "", value: undefined };
}

export const HistogramDataPoint_AttributesEntry = {
  encode(message: HistogramDataPoint_AttributesEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      AttributeValue.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HistogramDataPoint_AttributesEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHistogramDataPoint_AttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = AttributeValue.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HistogramDataPoint_AttributesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? AttributeValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: HistogramDataPoint_AttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = AttributeValue.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HistogramDataPoint_AttributesEntry>, I>>(
    base?: I,
  ): HistogramDataPoint_AttributesEntry {
    return HistogramDataPoint_AttributesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HistogramDataPoint_AttributesEntry>, I>>(
    object: I,
  ): HistogramDataPoint_AttributesEntry {
    const message = createBaseHistogramDataPoint_AttributesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? AttributeValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseSummaryDataPoint(): SummaryDataPoint {
  return { attributes: {}, startTime: undefined, time: undefined, count: "0", sum: 0, quantileValues: [] };
}

export const SummaryDataPoint = {
  encode(message: SummaryDataPoint, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    Object.entries(message.attributes).forEach(([key, value]) => {
      SummaryDataPoint_AttributesEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).ldelim();
    });
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(18).fork()).ldelim();
    }
    if (message.time !== undefined) {
      Timestamp.encode(toTimestamp(message.time), writer.uint32(26).fork()).ldelim();
    }
    if (message.count !== "0") {
      writer.uint32(80).uint64(message.count);
    }
    if (message.sum !== 0) {
      writer.uint32(89).double(message.sum);
    }
    for (const v of message.quantileValues) {
      QuantileValue.encode(v!, writer.uint32(98).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SummaryDataPoint {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSummaryDataPoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = SummaryDataPoint_AttributesEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.attributes[entry1.key] = entry1.value;
          }
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.count = longToString(reader.uint64() as Long);
          continue;
        case 11:
          if (tag !== 89) {
            break;
          }

          message.sum = reader.double();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.quantileValues.push(QuantileValue.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SummaryDataPoint {
    return {
      attributes: isObject(object.attributes)
        ? Object.entries(object.attributes).reduce<{ [key: string]: AttributeValue }>((acc, [key, value]) => {
          acc[key] = AttributeValue.fromJSON(value);
          return acc;
        }, {})
        : {},
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      time: isSet(object.time) ? fromJsonTimestamp(object.time) : undefined,
      count: isSet(object.count) ? globalThis.String(object.count) : "0",
      sum: isSet(object.sum) ? globalThis.Number(object.sum) : 0,
      quantileValues: globalThis.Array.isArray(object?.quantileValues)
        ? object.quantileValues.map((e: any) => QuantileValue.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SummaryDataPoint): unknown {
    const obj: any = {};
    if (message.attributes) {
      const entries = Object.entries(message.attributes);
      if (entries.length > 0) {
        obj.attributes = {};
        entries.forEach(([k, v]) => {
          obj.attributes[k] = AttributeValue.toJSON(v);
        });
      }
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.time !== undefined) {
      obj.time = message.time.toISOString();
    }
    if (message.count !== "0") {
      obj.count = message.count;
    }
    if (message.sum !== 0) {
      obj.sum = message.sum;
    }
    if (message.quantileValues?.length) {
      obj.quantileValues = message.quantileValues.map((e) => QuantileValue.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SummaryDataPoint>, I>>(base?: I): SummaryDataPoint {
    return SummaryDataPoint.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SummaryDataPoint>, I>>(object: I): SummaryDataPoint {
    const message = createBaseSummaryDataPoint();
    message.attributes = Object.entries(object.attributes ?? {}).reduce<{ [key: string]: AttributeValue }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = AttributeValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.startTime = object.startTime ?? undefined;
    message.time = object.time ?? undefined;
    message.count = object.count ?? "0";
    message.sum = object.sum ?? 0;
    message.quantileValues = object.quantileValues?.map((e) => QuantileValue.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSummaryDataPoint_AttributesEntry(): SummaryDataPoint_AttributesEntry {
  return { key: "", value: undefined };
}

export const SummaryDataPoint_AttributesEntry = {
  encode(message: SummaryDataPoint_AttributesEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      AttributeValue.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SummaryDataPoint_AttributesEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSummaryDataPoint_AttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = AttributeValue.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SummaryDataPoint_AttributesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? AttributeValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: SummaryDataPoint_AttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = AttributeValue.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SummaryDataPoint_AttributesEntry>, I>>(
    base?: I,
  ): SummaryDataPoint_AttributesEntry {
    return SummaryDataPoint_AttributesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SummaryDataPoint_AttributesEntry>, I>>(
    object: I,
  ): SummaryDataPoint_AttributesEntry {
    const message = createBaseSummaryDataPoint_AttributesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? AttributeValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseQuantileValue(): QuantileValue {
  return { quantile: 0, value: 0 };
}

export const QuantileValue = {
  encode(message: QuantileValue, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.quantile !== 0) {
      writer.uint32(9).double(message.quantile);
    }
    if (message.value !== 0) {
      writer.uint32(17).double(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QuantileValue {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuantileValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.quantile = reader.double();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.value = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuantileValue {
    return {
      quantile: isSet(object.quantile) ? globalThis.Number(object.quantile) : 0,
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: QuantileValue): unknown {
    const obj: any = {};
    if (message.quantile !== 0) {
      obj.quantile = message.quantile;
    }
    if (message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QuantileValue>, I>>(base?: I): QuantileValue {
    return QuantileValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuantileValue>, I>>(object: I): QuantileValue {
    const message = createBaseQuantileValue();
    message.quantile = object.quantile ?? 0;
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseExemplar(): Exemplar {
  return {
    filteredAttributes: {},
    timestamp: undefined,
    asDouble: undefined,
    asInt: undefined,
    spanId: "",
    traceId: "",
  };
}

export const Exemplar = {
  encode(message: Exemplar, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    Object.entries(message.filteredAttributes).forEach(([key, value]) => {
      Exemplar_FilteredAttributesEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).ldelim();
    });
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(18).fork()).ldelim();
    }
    if (message.asDouble !== undefined) {
      writer.uint32(81).double(message.asDouble);
    }
    if (message.asInt !== undefined) {
      writer.uint32(88).int64(message.asInt);
    }
    if (message.spanId !== "") {
      writer.uint32(162).string(message.spanId);
    }
    if (message.traceId !== "") {
      writer.uint32(170).string(message.traceId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Exemplar {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExemplar();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = Exemplar_FilteredAttributesEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.filteredAttributes[entry1.key] = entry1.value;
          }
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 81) {
            break;
          }

          message.asDouble = reader.double();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.asInt = longToString(reader.int64() as Long);
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.spanId = reader.string();
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.traceId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Exemplar {
    return {
      filteredAttributes: isObject(object.filteredAttributes)
        ? Object.entries(object.filteredAttributes).reduce<{ [key: string]: AttributeValue }>((acc, [key, value]) => {
          acc[key] = AttributeValue.fromJSON(value);
          return acc;
        }, {})
        : {},
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      asDouble: isSet(object.asDouble) ? globalThis.Number(object.asDouble) : undefined,
      asInt: isSet(object.asInt) ? globalThis.String(object.asInt) : undefined,
      spanId: isSet(object.spanId) ? globalThis.String(object.spanId) : "",
      traceId: isSet(object.traceId) ? globalThis.String(object.traceId) : "",
    };
  },

  toJSON(message: Exemplar): unknown {
    const obj: any = {};
    if (message.filteredAttributes) {
      const entries = Object.entries(message.filteredAttributes);
      if (entries.length > 0) {
        obj.filteredAttributes = {};
        entries.forEach(([k, v]) => {
          obj.filteredAttributes[k] = AttributeValue.toJSON(v);
        });
      }
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.asDouble !== undefined) {
      obj.asDouble = message.asDouble;
    }
    if (message.asInt !== undefined) {
      obj.asInt = message.asInt;
    }
    if (message.spanId !== "") {
      obj.spanId = message.spanId;
    }
    if (message.traceId !== "") {
      obj.traceId = message.traceId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Exemplar>, I>>(base?: I): Exemplar {
    return Exemplar.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Exemplar>, I>>(object: I): Exemplar {
    const message = createBaseExemplar();
    message.filteredAttributes = Object.entries(object.filteredAttributes ?? {}).reduce<
      { [key: string]: AttributeValue }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = AttributeValue.fromPartial(value);
      }
      return acc;
    }, {});
    message.timestamp = object.timestamp ?? undefined;
    message.asDouble = object.asDouble ?? undefined;
    message.asInt = object.asInt ?? undefined;
    message.spanId = object.spanId ?? "";
    message.traceId = object.traceId ?? "";
    return message;
  },
};

function createBaseExemplar_FilteredAttributesEntry(): Exemplar_FilteredAttributesEntry {
  return { key: "", value: undefined };
}

export const Exemplar_FilteredAttributesEntry = {
  encode(message: Exemplar_FilteredAttributesEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      AttributeValue.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Exemplar_FilteredAttributesEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExemplar_FilteredAttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = AttributeValue.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Exemplar_FilteredAttributesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? AttributeValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Exemplar_FilteredAttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = AttributeValue.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Exemplar_FilteredAttributesEntry>, I>>(
    base?: I,
  ): Exemplar_FilteredAttributesEntry {
    return Exemplar_FilteredAttributesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Exemplar_FilteredAttributesEntry>, I>>(
    object: I,
  ): Exemplar_FilteredAttributesEntry {
    const message = createBaseExemplar_FilteredAttributesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? AttributeValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseServiceHealthEvent(): ServiceHealthEvent {
  return {
    eventId: "",
    timestamp: undefined,
    eventType: "",
    sequenceNumber: "0",
    resource: undefined,
    health: undefined,
    destinations: undefined,
    partitionInfo: undefined,
  };
}

export const ServiceHealthEvent = {
  encode(message: ServiceHealthEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== "") {
      writer.uint32(10).string(message.eventId);
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(18).fork()).ldelim();
    }
    if (message.eventType !== "") {
      writer.uint32(26).string(message.eventType);
    }
    if (message.sequenceNumber !== "0") {
      writer.uint32(32).int64(message.sequenceNumber);
    }
    if (message.resource !== undefined) {
      Resource.encode(message.resource, writer.uint32(42).fork()).ldelim();
    }
    if (message.health !== undefined) {
      ServiceHealth.encode(message.health, writer.uint32(82).fork()).ldelim();
    }
    if (message.destinations !== undefined) {
      DestinationFlags.encode(message.destinations, writer.uint32(162).fork()).ldelim();
    }
    if (message.partitionInfo !== undefined) {
      PartitionInfo.encode(message.partitionInfo, writer.uint32(202).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ServiceHealthEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceHealthEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.eventId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.eventType = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.sequenceNumber = longToString(reader.int64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.resource = Resource.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.health = ServiceHealth.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.destinations = DestinationFlags.decode(reader, reader.uint32());
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.partitionInfo = PartitionInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceHealthEvent {
    return {
      eventId: isSet(object.eventId) ? globalThis.String(object.eventId) : "",
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      eventType: isSet(object.eventType) ? globalThis.String(object.eventType) : "",
      sequenceNumber: isSet(object.sequenceNumber) ? globalThis.String(object.sequenceNumber) : "0",
      resource: isSet(object.resource) ? Resource.fromJSON(object.resource) : undefined,
      health: isSet(object.health) ? ServiceHealth.fromJSON(object.health) : undefined,
      destinations: isSet(object.destinations) ? DestinationFlags.fromJSON(object.destinations) : undefined,
      partitionInfo: isSet(object.partitionInfo) ? PartitionInfo.fromJSON(object.partitionInfo) : undefined,
    };
  },

  toJSON(message: ServiceHealthEvent): unknown {
    const obj: any = {};
    if (message.eventId !== "") {
      obj.eventId = message.eventId;
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.eventType !== "") {
      obj.eventType = message.eventType;
    }
    if (message.sequenceNumber !== "0") {
      obj.sequenceNumber = message.sequenceNumber;
    }
    if (message.resource !== undefined) {
      obj.resource = Resource.toJSON(message.resource);
    }
    if (message.health !== undefined) {
      obj.health = ServiceHealth.toJSON(message.health);
    }
    if (message.destinations !== undefined) {
      obj.destinations = DestinationFlags.toJSON(message.destinations);
    }
    if (message.partitionInfo !== undefined) {
      obj.partitionInfo = PartitionInfo.toJSON(message.partitionInfo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServiceHealthEvent>, I>>(base?: I): ServiceHealthEvent {
    return ServiceHealthEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServiceHealthEvent>, I>>(object: I): ServiceHealthEvent {
    const message = createBaseServiceHealthEvent();
    message.eventId = object.eventId ?? "";
    message.timestamp = object.timestamp ?? undefined;
    message.eventType = object.eventType ?? "";
    message.sequenceNumber = object.sequenceNumber ?? "0";
    message.resource = (object.resource !== undefined && object.resource !== null)
      ? Resource.fromPartial(object.resource)
      : undefined;
    message.health = (object.health !== undefined && object.health !== null)
      ? ServiceHealth.fromPartial(object.health)
      : undefined;
    message.destinations = (object.destinations !== undefined && object.destinations !== null)
      ? DestinationFlags.fromPartial(object.destinations)
      : undefined;
    message.partitionInfo = (object.partitionInfo !== undefined && object.partitionInfo !== null)
      ? PartitionInfo.fromPartial(object.partitionInfo)
      : undefined;
    return message;
  },
};

function createBaseServiceHealth(): ServiceHealth {
  return {
    serviceName: "",
    status: 0,
    statusMessage: "",
    healthChecks: [],
    dependencies: [],
    slis: undefined,
    systemMetrics: undefined,
    uptime: undefined,
  };
}

export const ServiceHealth = {
  encode(message: ServiceHealth, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.serviceName !== "") {
      writer.uint32(10).string(message.serviceName);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (message.statusMessage !== "") {
      writer.uint32(26).string(message.statusMessage);
    }
    for (const v of message.healthChecks) {
      HealthCheck.encode(v!, writer.uint32(82).fork()).ldelim();
    }
    for (const v of message.dependencies) {
      DependencyHealth.encode(v!, writer.uint32(122).fork()).ldelim();
    }
    if (message.slis !== undefined) {
      ServiceLevelIndicators.encode(message.slis, writer.uint32(162).fork()).ldelim();
    }
    if (message.systemMetrics !== undefined) {
      SystemMetrics.encode(message.systemMetrics, writer.uint32(202).fork()).ldelim();
    }
    if (message.uptime !== undefined) {
      UptimeInfo.encode(message.uptime, writer.uint32(242).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ServiceHealth {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceHealth();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.serviceName = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.statusMessage = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.healthChecks.push(HealthCheck.decode(reader, reader.uint32()));
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.dependencies.push(DependencyHealth.decode(reader, reader.uint32()));
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.slis = ServiceLevelIndicators.decode(reader, reader.uint32());
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.systemMetrics = SystemMetrics.decode(reader, reader.uint32());
          continue;
        case 30:
          if (tag !== 242) {
            break;
          }

          message.uptime = UptimeInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceHealth {
    return {
      serviceName: isSet(object.serviceName) ? globalThis.String(object.serviceName) : "",
      status: isSet(object.status) ? healthStatusFromJSON(object.status) : 0,
      statusMessage: isSet(object.statusMessage) ? globalThis.String(object.statusMessage) : "",
      healthChecks: globalThis.Array.isArray(object?.healthChecks)
        ? object.healthChecks.map((e: any) => HealthCheck.fromJSON(e))
        : [],
      dependencies: globalThis.Array.isArray(object?.dependencies)
        ? object.dependencies.map((e: any) => DependencyHealth.fromJSON(e))
        : [],
      slis: isSet(object.slis) ? ServiceLevelIndicators.fromJSON(object.slis) : undefined,
      systemMetrics: isSet(object.systemMetrics) ? SystemMetrics.fromJSON(object.systemMetrics) : undefined,
      uptime: isSet(object.uptime) ? UptimeInfo.fromJSON(object.uptime) : undefined,
    };
  },

  toJSON(message: ServiceHealth): unknown {
    const obj: any = {};
    if (message.serviceName !== "") {
      obj.serviceName = message.serviceName;
    }
    if (message.status !== 0) {
      obj.status = healthStatusToJSON(message.status);
    }
    if (message.statusMessage !== "") {
      obj.statusMessage = message.statusMessage;
    }
    if (message.healthChecks?.length) {
      obj.healthChecks = message.healthChecks.map((e) => HealthCheck.toJSON(e));
    }
    if (message.dependencies?.length) {
      obj.dependencies = message.dependencies.map((e) => DependencyHealth.toJSON(e));
    }
    if (message.slis !== undefined) {
      obj.slis = ServiceLevelIndicators.toJSON(message.slis);
    }
    if (message.systemMetrics !== undefined) {
      obj.systemMetrics = SystemMetrics.toJSON(message.systemMetrics);
    }
    if (message.uptime !== undefined) {
      obj.uptime = UptimeInfo.toJSON(message.uptime);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServiceHealth>, I>>(base?: I): ServiceHealth {
    return ServiceHealth.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServiceHealth>, I>>(object: I): ServiceHealth {
    const message = createBaseServiceHealth();
    message.serviceName = object.serviceName ?? "";
    message.status = object.status ?? 0;
    message.statusMessage = object.statusMessage ?? "";
    message.healthChecks = object.healthChecks?.map((e) => HealthCheck.fromPartial(e)) || [];
    message.dependencies = object.dependencies?.map((e) => DependencyHealth.fromPartial(e)) || [];
    message.slis = (object.slis !== undefined && object.slis !== null)
      ? ServiceLevelIndicators.fromPartial(object.slis)
      : undefined;
    message.systemMetrics = (object.systemMetrics !== undefined && object.systemMetrics !== null)
      ? SystemMetrics.fromPartial(object.systemMetrics)
      : undefined;
    message.uptime = (object.uptime !== undefined && object.uptime !== null)
      ? UptimeInfo.fromPartial(object.uptime)
      : undefined;
    return message;
  },
};

function createBaseHealthCheck(): HealthCheck {
  return { name: "", status: 0, message: "", lastCheck: undefined, responseTimeMs: "0", metadata: {} };
}

export const HealthCheck = {
  encode(message: HealthCheck, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    if (message.lastCheck !== undefined) {
      Timestamp.encode(toTimestamp(message.lastCheck), writer.uint32(34).fork()).ldelim();
    }
    if (message.responseTimeMs !== "0") {
      writer.uint32(40).int64(message.responseTimeMs);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      HealthCheck_MetadataEntry.encode({ key: key as any, value }, writer.uint32(82).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HealthCheck {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheck();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.lastCheck = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.responseTimeMs = longToString(reader.int64() as Long);
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          const entry10 = HealthCheck_MetadataEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            message.metadata[entry10.key] = entry10.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthCheck {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      status: isSet(object.status) ? healthStatusFromJSON(object.status) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      lastCheck: isSet(object.lastCheck) ? fromJsonTimestamp(object.lastCheck) : undefined,
      responseTimeMs: isSet(object.responseTimeMs) ? globalThis.String(object.responseTimeMs) : "0",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: HealthCheck): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.status !== 0) {
      obj.status = healthStatusToJSON(message.status);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.lastCheck !== undefined) {
      obj.lastCheck = message.lastCheck.toISOString();
    }
    if (message.responseTimeMs !== "0") {
      obj.responseTimeMs = message.responseTimeMs;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthCheck>, I>>(base?: I): HealthCheck {
    return HealthCheck.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthCheck>, I>>(object: I): HealthCheck {
    const message = createBaseHealthCheck();
    message.name = object.name ?? "";
    message.status = object.status ?? 0;
    message.message = object.message ?? "";
    message.lastCheck = object.lastCheck ?? undefined;
    message.responseTimeMs = object.responseTimeMs ?? "0";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseHealthCheck_MetadataEntry(): HealthCheck_MetadataEntry {
  return { key: "", value: "" };
}

export const HealthCheck_MetadataEntry = {
  encode(message: HealthCheck_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HealthCheck_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheck_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthCheck_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: HealthCheck_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthCheck_MetadataEntry>, I>>(base?: I): HealthCheck_MetadataEntry {
    return HealthCheck_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthCheck_MetadataEntry>, I>>(object: I): HealthCheck_MetadataEntry {
    const message = createBaseHealthCheck_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseDependencyHealth(): DependencyHealth {
  return { name: "", type: "", status: 0, endpoint: "", responseTimeMs: "0", version: "", lastCheck: undefined };
}

export const DependencyHealth = {
  encode(message: DependencyHealth, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    if (message.status !== 0) {
      writer.uint32(24).int32(message.status);
    }
    if (message.endpoint !== "") {
      writer.uint32(34).string(message.endpoint);
    }
    if (message.responseTimeMs !== "0") {
      writer.uint32(40).int64(message.responseTimeMs);
    }
    if (message.version !== "") {
      writer.uint32(50).string(message.version);
    }
    if (message.lastCheck !== undefined) {
      Timestamp.encode(toTimestamp(message.lastCheck), writer.uint32(82).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DependencyHealth {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDependencyHealth();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.endpoint = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.responseTimeMs = longToString(reader.int64() as Long);
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.version = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.lastCheck = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DependencyHealth {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      status: isSet(object.status) ? healthStatusFromJSON(object.status) : 0,
      endpoint: isSet(object.endpoint) ? globalThis.String(object.endpoint) : "",
      responseTimeMs: isSet(object.responseTimeMs) ? globalThis.String(object.responseTimeMs) : "0",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      lastCheck: isSet(object.lastCheck) ? fromJsonTimestamp(object.lastCheck) : undefined,
    };
  },

  toJSON(message: DependencyHealth): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.status !== 0) {
      obj.status = healthStatusToJSON(message.status);
    }
    if (message.endpoint !== "") {
      obj.endpoint = message.endpoint;
    }
    if (message.responseTimeMs !== "0") {
      obj.responseTimeMs = message.responseTimeMs;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.lastCheck !== undefined) {
      obj.lastCheck = message.lastCheck.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DependencyHealth>, I>>(base?: I): DependencyHealth {
    return DependencyHealth.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DependencyHealth>, I>>(object: I): DependencyHealth {
    const message = createBaseDependencyHealth();
    message.name = object.name ?? "";
    message.type = object.type ?? "";
    message.status = object.status ?? 0;
    message.endpoint = object.endpoint ?? "";
    message.responseTimeMs = object.responseTimeMs ?? "0";
    message.version = object.version ?? "";
    message.lastCheck = object.lastCheck ?? undefined;
    return message;
  },
};

function createBaseServiceLevelIndicators(): ServiceLevelIndicators {
  return {
    availabilityPercent: 0,
    errorRatePercent: 0,
    latencyP50Ms: 0,
    latencyP95Ms: 0,
    latencyP99Ms: 0,
    throughputRps: 0,
    windowStart: undefined,
    windowEnd: undefined,
  };
}

export const ServiceLevelIndicators = {
  encode(message: ServiceLevelIndicators, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.availabilityPercent !== 0) {
      writer.uint32(9).double(message.availabilityPercent);
    }
    if (message.errorRatePercent !== 0) {
      writer.uint32(17).double(message.errorRatePercent);
    }
    if (message.latencyP50Ms !== 0) {
      writer.uint32(25).double(message.latencyP50Ms);
    }
    if (message.latencyP95Ms !== 0) {
      writer.uint32(33).double(message.latencyP95Ms);
    }
    if (message.latencyP99Ms !== 0) {
      writer.uint32(41).double(message.latencyP99Ms);
    }
    if (message.throughputRps !== 0) {
      writer.uint32(49).double(message.throughputRps);
    }
    if (message.windowStart !== undefined) {
      Timestamp.encode(toTimestamp(message.windowStart), writer.uint32(82).fork()).ldelim();
    }
    if (message.windowEnd !== undefined) {
      Timestamp.encode(toTimestamp(message.windowEnd), writer.uint32(90).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ServiceLevelIndicators {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceLevelIndicators();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.availabilityPercent = reader.double();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.errorRatePercent = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.latencyP50Ms = reader.double();
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.latencyP95Ms = reader.double();
          continue;
        case 5:
          if (tag !== 41) {
            break;
          }

          message.latencyP99Ms = reader.double();
          continue;
        case 6:
          if (tag !== 49) {
            break;
          }

          message.throughputRps = reader.double();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.windowStart = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.windowEnd = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceLevelIndicators {
    return {
      availabilityPercent: isSet(object.availabilityPercent) ? globalThis.Number(object.availabilityPercent) : 0,
      errorRatePercent: isSet(object.errorRatePercent) ? globalThis.Number(object.errorRatePercent) : 0,
      latencyP50Ms: isSet(object.latencyP50Ms) ? globalThis.Number(object.latencyP50Ms) : 0,
      latencyP95Ms: isSet(object.latencyP95Ms) ? globalThis.Number(object.latencyP95Ms) : 0,
      latencyP99Ms: isSet(object.latencyP99Ms) ? globalThis.Number(object.latencyP99Ms) : 0,
      throughputRps: isSet(object.throughputRps) ? globalThis.Number(object.throughputRps) : 0,
      windowStart: isSet(object.windowStart) ? fromJsonTimestamp(object.windowStart) : undefined,
      windowEnd: isSet(object.windowEnd) ? fromJsonTimestamp(object.windowEnd) : undefined,
    };
  },

  toJSON(message: ServiceLevelIndicators): unknown {
    const obj: any = {};
    if (message.availabilityPercent !== 0) {
      obj.availabilityPercent = message.availabilityPercent;
    }
    if (message.errorRatePercent !== 0) {
      obj.errorRatePercent = message.errorRatePercent;
    }
    if (message.latencyP50Ms !== 0) {
      obj.latencyP50Ms = message.latencyP50Ms;
    }
    if (message.latencyP95Ms !== 0) {
      obj.latencyP95Ms = message.latencyP95Ms;
    }
    if (message.latencyP99Ms !== 0) {
      obj.latencyP99Ms = message.latencyP99Ms;
    }
    if (message.throughputRps !== 0) {
      obj.throughputRps = message.throughputRps;
    }
    if (message.windowStart !== undefined) {
      obj.windowStart = message.windowStart.toISOString();
    }
    if (message.windowEnd !== undefined) {
      obj.windowEnd = message.windowEnd.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServiceLevelIndicators>, I>>(base?: I): ServiceLevelIndicators {
    return ServiceLevelIndicators.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServiceLevelIndicators>, I>>(object: I): ServiceLevelIndicators {
    const message = createBaseServiceLevelIndicators();
    message.availabilityPercent = object.availabilityPercent ?? 0;
    message.errorRatePercent = object.errorRatePercent ?? 0;
    message.latencyP50Ms = object.latencyP50Ms ?? 0;
    message.latencyP95Ms = object.latencyP95Ms ?? 0;
    message.latencyP99Ms = object.latencyP99Ms ?? 0;
    message.throughputRps = object.throughputRps ?? 0;
    message.windowStart = object.windowStart ?? undefined;
    message.windowEnd = object.windowEnd ?? undefined;
    return message;
  },
};

function createBaseSystemMetrics(): SystemMetrics {
  return {
    cpuUsagePercent: 0,
    cpuLoad1m: 0,
    cpuLoad5m: 0,
    cpuLoad15m: 0,
    memoryTotalBytes: "0",
    memoryUsedBytes: "0",
    memoryAvailableBytes: "0",
    memoryUsagePercent: 0,
    diskTotalBytes: "0",
    diskUsedBytes: "0",
    diskAvailableBytes: "0",
    diskUsagePercent: 0,
    networkBytesSent: "0",
    networkBytesReceived: "0",
    networkPacketsSent: "0",
    networkPacketsReceived: "0",
    processCount: 0,
    threadCount: 0,
    fileDescriptorCount: 0,
  };
}

export const SystemMetrics = {
  encode(message: SystemMetrics, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.cpuUsagePercent !== 0) {
      writer.uint32(9).double(message.cpuUsagePercent);
    }
    if (message.cpuLoad1m !== 0) {
      writer.uint32(17).double(message.cpuLoad1m);
    }
    if (message.cpuLoad5m !== 0) {
      writer.uint32(25).double(message.cpuLoad5m);
    }
    if (message.cpuLoad15m !== 0) {
      writer.uint32(33).double(message.cpuLoad15m);
    }
    if (message.memoryTotalBytes !== "0") {
      writer.uint32(80).uint64(message.memoryTotalBytes);
    }
    if (message.memoryUsedBytes !== "0") {
      writer.uint32(88).uint64(message.memoryUsedBytes);
    }
    if (message.memoryAvailableBytes !== "0") {
      writer.uint32(96).uint64(message.memoryAvailableBytes);
    }
    if (message.memoryUsagePercent !== 0) {
      writer.uint32(105).double(message.memoryUsagePercent);
    }
    if (message.diskTotalBytes !== "0") {
      writer.uint32(160).uint64(message.diskTotalBytes);
    }
    if (message.diskUsedBytes !== "0") {
      writer.uint32(168).uint64(message.diskUsedBytes);
    }
    if (message.diskAvailableBytes !== "0") {
      writer.uint32(176).uint64(message.diskAvailableBytes);
    }
    if (message.diskUsagePercent !== 0) {
      writer.uint32(185).double(message.diskUsagePercent);
    }
    if (message.networkBytesSent !== "0") {
      writer.uint32(240).uint64(message.networkBytesSent);
    }
    if (message.networkBytesReceived !== "0") {
      writer.uint32(248).uint64(message.networkBytesReceived);
    }
    if (message.networkPacketsSent !== "0") {
      writer.uint32(256).uint64(message.networkPacketsSent);
    }
    if (message.networkPacketsReceived !== "0") {
      writer.uint32(264).uint64(message.networkPacketsReceived);
    }
    if (message.processCount !== 0) {
      writer.uint32(320).uint32(message.processCount);
    }
    if (message.threadCount !== 0) {
      writer.uint32(328).uint32(message.threadCount);
    }
    if (message.fileDescriptorCount !== 0) {
      writer.uint32(336).uint32(message.fileDescriptorCount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SystemMetrics {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSystemMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.cpuUsagePercent = reader.double();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.cpuLoad1m = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.cpuLoad5m = reader.double();
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.cpuLoad15m = reader.double();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.memoryTotalBytes = longToString(reader.uint64() as Long);
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.memoryUsedBytes = longToString(reader.uint64() as Long);
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.memoryAvailableBytes = longToString(reader.uint64() as Long);
          continue;
        case 13:
          if (tag !== 105) {
            break;
          }

          message.memoryUsagePercent = reader.double();
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.diskTotalBytes = longToString(reader.uint64() as Long);
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.diskUsedBytes = longToString(reader.uint64() as Long);
          continue;
        case 22:
          if (tag !== 176) {
            break;
          }

          message.diskAvailableBytes = longToString(reader.uint64() as Long);
          continue;
        case 23:
          if (tag !== 185) {
            break;
          }

          message.diskUsagePercent = reader.double();
          continue;
        case 30:
          if (tag !== 240) {
            break;
          }

          message.networkBytesSent = longToString(reader.uint64() as Long);
          continue;
        case 31:
          if (tag !== 248) {
            break;
          }

          message.networkBytesReceived = longToString(reader.uint64() as Long);
          continue;
        case 32:
          if (tag !== 256) {
            break;
          }

          message.networkPacketsSent = longToString(reader.uint64() as Long);
          continue;
        case 33:
          if (tag !== 264) {
            break;
          }

          message.networkPacketsReceived = longToString(reader.uint64() as Long);
          continue;
        case 40:
          if (tag !== 320) {
            break;
          }

          message.processCount = reader.uint32();
          continue;
        case 41:
          if (tag !== 328) {
            break;
          }

          message.threadCount = reader.uint32();
          continue;
        case 42:
          if (tag !== 336) {
            break;
          }

          message.fileDescriptorCount = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SystemMetrics {
    return {
      cpuUsagePercent: isSet(object.cpuUsagePercent) ? globalThis.Number(object.cpuUsagePercent) : 0,
      cpuLoad1m: isSet(object.cpuLoad1m) ? globalThis.Number(object.cpuLoad1m) : 0,
      cpuLoad5m: isSet(object.cpuLoad5m) ? globalThis.Number(object.cpuLoad5m) : 0,
      cpuLoad15m: isSet(object.cpuLoad15m) ? globalThis.Number(object.cpuLoad15m) : 0,
      memoryTotalBytes: isSet(object.memoryTotalBytes) ? globalThis.String(object.memoryTotalBytes) : "0",
      memoryUsedBytes: isSet(object.memoryUsedBytes) ? globalThis.String(object.memoryUsedBytes) : "0",
      memoryAvailableBytes: isSet(object.memoryAvailableBytes) ? globalThis.String(object.memoryAvailableBytes) : "0",
      memoryUsagePercent: isSet(object.memoryUsagePercent) ? globalThis.Number(object.memoryUsagePercent) : 0,
      diskTotalBytes: isSet(object.diskTotalBytes) ? globalThis.String(object.diskTotalBytes) : "0",
      diskUsedBytes: isSet(object.diskUsedBytes) ? globalThis.String(object.diskUsedBytes) : "0",
      diskAvailableBytes: isSet(object.diskAvailableBytes) ? globalThis.String(object.diskAvailableBytes) : "0",
      diskUsagePercent: isSet(object.diskUsagePercent) ? globalThis.Number(object.diskUsagePercent) : 0,
      networkBytesSent: isSet(object.networkBytesSent) ? globalThis.String(object.networkBytesSent) : "0",
      networkBytesReceived: isSet(object.networkBytesReceived) ? globalThis.String(object.networkBytesReceived) : "0",
      networkPacketsSent: isSet(object.networkPacketsSent) ? globalThis.String(object.networkPacketsSent) : "0",
      networkPacketsReceived: isSet(object.networkPacketsReceived)
        ? globalThis.String(object.networkPacketsReceived)
        : "0",
      processCount: isSet(object.processCount) ? globalThis.Number(object.processCount) : 0,
      threadCount: isSet(object.threadCount) ? globalThis.Number(object.threadCount) : 0,
      fileDescriptorCount: isSet(object.fileDescriptorCount) ? globalThis.Number(object.fileDescriptorCount) : 0,
    };
  },

  toJSON(message: SystemMetrics): unknown {
    const obj: any = {};
    if (message.cpuUsagePercent !== 0) {
      obj.cpuUsagePercent = message.cpuUsagePercent;
    }
    if (message.cpuLoad1m !== 0) {
      obj.cpuLoad1m = message.cpuLoad1m;
    }
    if (message.cpuLoad5m !== 0) {
      obj.cpuLoad5m = message.cpuLoad5m;
    }
    if (message.cpuLoad15m !== 0) {
      obj.cpuLoad15m = message.cpuLoad15m;
    }
    if (message.memoryTotalBytes !== "0") {
      obj.memoryTotalBytes = message.memoryTotalBytes;
    }
    if (message.memoryUsedBytes !== "0") {
      obj.memoryUsedBytes = message.memoryUsedBytes;
    }
    if (message.memoryAvailableBytes !== "0") {
      obj.memoryAvailableBytes = message.memoryAvailableBytes;
    }
    if (message.memoryUsagePercent !== 0) {
      obj.memoryUsagePercent = message.memoryUsagePercent;
    }
    if (message.diskTotalBytes !== "0") {
      obj.diskTotalBytes = message.diskTotalBytes;
    }
    if (message.diskUsedBytes !== "0") {
      obj.diskUsedBytes = message.diskUsedBytes;
    }
    if (message.diskAvailableBytes !== "0") {
      obj.diskAvailableBytes = message.diskAvailableBytes;
    }
    if (message.diskUsagePercent !== 0) {
      obj.diskUsagePercent = message.diskUsagePercent;
    }
    if (message.networkBytesSent !== "0") {
      obj.networkBytesSent = message.networkBytesSent;
    }
    if (message.networkBytesReceived !== "0") {
      obj.networkBytesReceived = message.networkBytesReceived;
    }
    if (message.networkPacketsSent !== "0") {
      obj.networkPacketsSent = message.networkPacketsSent;
    }
    if (message.networkPacketsReceived !== "0") {
      obj.networkPacketsReceived = message.networkPacketsReceived;
    }
    if (message.processCount !== 0) {
      obj.processCount = Math.round(message.processCount);
    }
    if (message.threadCount !== 0) {
      obj.threadCount = Math.round(message.threadCount);
    }
    if (message.fileDescriptorCount !== 0) {
      obj.fileDescriptorCount = Math.round(message.fileDescriptorCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SystemMetrics>, I>>(base?: I): SystemMetrics {
    return SystemMetrics.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SystemMetrics>, I>>(object: I): SystemMetrics {
    const message = createBaseSystemMetrics();
    message.cpuUsagePercent = object.cpuUsagePercent ?? 0;
    message.cpuLoad1m = object.cpuLoad1m ?? 0;
    message.cpuLoad5m = object.cpuLoad5m ?? 0;
    message.cpuLoad15m = object.cpuLoad15m ?? 0;
    message.memoryTotalBytes = object.memoryTotalBytes ?? "0";
    message.memoryUsedBytes = object.memoryUsedBytes ?? "0";
    message.memoryAvailableBytes = object.memoryAvailableBytes ?? "0";
    message.memoryUsagePercent = object.memoryUsagePercent ?? 0;
    message.diskTotalBytes = object.diskTotalBytes ?? "0";
    message.diskUsedBytes = object.diskUsedBytes ?? "0";
    message.diskAvailableBytes = object.diskAvailableBytes ?? "0";
    message.diskUsagePercent = object.diskUsagePercent ?? 0;
    message.networkBytesSent = object.networkBytesSent ?? "0";
    message.networkBytesReceived = object.networkBytesReceived ?? "0";
    message.networkPacketsSent = object.networkPacketsSent ?? "0";
    message.networkPacketsReceived = object.networkPacketsReceived ?? "0";
    message.processCount = object.processCount ?? 0;
    message.threadCount = object.threadCount ?? 0;
    message.fileDescriptorCount = object.fileDescriptorCount ?? 0;
    return message;
  },
};

function createBaseUptimeInfo(): UptimeInfo {
  return { startTime: undefined, uptimeSeconds: "0", restartCount: 0, lastRestart: undefined };
}

export const UptimeInfo = {
  encode(message: UptimeInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(10).fork()).ldelim();
    }
    if (message.uptimeSeconds !== "0") {
      writer.uint32(16).int64(message.uptimeSeconds);
    }
    if (message.restartCount !== 0) {
      writer.uint32(24).uint32(message.restartCount);
    }
    if (message.lastRestart !== undefined) {
      Timestamp.encode(toTimestamp(message.lastRestart), writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UptimeInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUptimeInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.uptimeSeconds = longToString(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.restartCount = reader.uint32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.lastRestart = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UptimeInfo {
    return {
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      uptimeSeconds: isSet(object.uptimeSeconds) ? globalThis.String(object.uptimeSeconds) : "0",
      restartCount: isSet(object.restartCount) ? globalThis.Number(object.restartCount) : 0,
      lastRestart: isSet(object.lastRestart) ? fromJsonTimestamp(object.lastRestart) : undefined,
    };
  },

  toJSON(message: UptimeInfo): unknown {
    const obj: any = {};
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.uptimeSeconds !== "0") {
      obj.uptimeSeconds = message.uptimeSeconds;
    }
    if (message.restartCount !== 0) {
      obj.restartCount = Math.round(message.restartCount);
    }
    if (message.lastRestart !== undefined) {
      obj.lastRestart = message.lastRestart.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UptimeInfo>, I>>(base?: I): UptimeInfo {
    return UptimeInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UptimeInfo>, I>>(object: I): UptimeInfo {
    const message = createBaseUptimeInfo();
    message.startTime = object.startTime ?? undefined;
    message.uptimeSeconds = object.uptimeSeconds ?? "0";
    message.restartCount = object.restartCount ?? 0;
    message.lastRestart = object.lastRestart ?? undefined;
    return message;
  },
};

function createBaseIncidentEvent(): IncidentEvent {
  return {
    eventId: "",
    timestamp: undefined,
    eventType: "",
    sequenceNumber: "0",
    incident: undefined,
    destinations: undefined,
    partitionInfo: undefined,
  };
}

export const IncidentEvent = {
  encode(message: IncidentEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== "") {
      writer.uint32(10).string(message.eventId);
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(18).fork()).ldelim();
    }
    if (message.eventType !== "") {
      writer.uint32(26).string(message.eventType);
    }
    if (message.sequenceNumber !== "0") {
      writer.uint32(32).int64(message.sequenceNumber);
    }
    if (message.incident !== undefined) {
      IncidentData.encode(message.incident, writer.uint32(82).fork()).ldelim();
    }
    if (message.destinations !== undefined) {
      DestinationFlags.encode(message.destinations, writer.uint32(162).fork()).ldelim();
    }
    if (message.partitionInfo !== undefined) {
      PartitionInfo.encode(message.partitionInfo, writer.uint32(202).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): IncidentEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIncidentEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.eventId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.eventType = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.sequenceNumber = longToString(reader.int64() as Long);
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.incident = IncidentData.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.destinations = DestinationFlags.decode(reader, reader.uint32());
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.partitionInfo = PartitionInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IncidentEvent {
    return {
      eventId: isSet(object.eventId) ? globalThis.String(object.eventId) : "",
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      eventType: isSet(object.eventType) ? globalThis.String(object.eventType) : "",
      sequenceNumber: isSet(object.sequenceNumber) ? globalThis.String(object.sequenceNumber) : "0",
      incident: isSet(object.incident) ? IncidentData.fromJSON(object.incident) : undefined,
      destinations: isSet(object.destinations) ? DestinationFlags.fromJSON(object.destinations) : undefined,
      partitionInfo: isSet(object.partitionInfo) ? PartitionInfo.fromJSON(object.partitionInfo) : undefined,
    };
  },

  toJSON(message: IncidentEvent): unknown {
    const obj: any = {};
    if (message.eventId !== "") {
      obj.eventId = message.eventId;
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.eventType !== "") {
      obj.eventType = message.eventType;
    }
    if (message.sequenceNumber !== "0") {
      obj.sequenceNumber = message.sequenceNumber;
    }
    if (message.incident !== undefined) {
      obj.incident = IncidentData.toJSON(message.incident);
    }
    if (message.destinations !== undefined) {
      obj.destinations = DestinationFlags.toJSON(message.destinations);
    }
    if (message.partitionInfo !== undefined) {
      obj.partitionInfo = PartitionInfo.toJSON(message.partitionInfo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IncidentEvent>, I>>(base?: I): IncidentEvent {
    return IncidentEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IncidentEvent>, I>>(object: I): IncidentEvent {
    const message = createBaseIncidentEvent();
    message.eventId = object.eventId ?? "";
    message.timestamp = object.timestamp ?? undefined;
    message.eventType = object.eventType ?? "";
    message.sequenceNumber = object.sequenceNumber ?? "0";
    message.incident = (object.incident !== undefined && object.incident !== null)
      ? IncidentData.fromPartial(object.incident)
      : undefined;
    message.destinations = (object.destinations !== undefined && object.destinations !== null)
      ? DestinationFlags.fromPartial(object.destinations)
      : undefined;
    message.partitionInfo = (object.partitionInfo !== undefined && object.partitionInfo !== null)
      ? PartitionInfo.fromPartial(object.partitionInfo)
      : undefined;
    return message;
  },
};

function createBaseIncidentData(): IncidentData {
  return {
    incidentId: "",
    title: "",
    description: "",
    severity: 0,
    status: 0,
    createdAt: undefined,
    updatedAt: undefined,
    resolvedAt: undefined,
    affectedServices: [],
    affectedComponents: [],
    updates: [],
    impact: undefined,
    resolution: undefined,
  };
}

export const IncidentData = {
  encode(message: IncidentData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.incidentId !== "") {
      writer.uint32(10).string(message.incidentId);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.severity !== 0) {
      writer.uint32(32).int32(message.severity);
    }
    if (message.status !== 0) {
      writer.uint32(40).int32(message.status);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(82).fork()).ldelim();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(90).fork()).ldelim();
    }
    if (message.resolvedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.resolvedAt), writer.uint32(98).fork()).ldelim();
    }
    for (const v of message.affectedServices) {
      writer.uint32(122).string(v!);
    }
    for (const v of message.affectedComponents) {
      writer.uint32(130).string(v!);
    }
    for (const v of message.updates) {
      IncidentUpdate.encode(v!, writer.uint32(162).fork()).ldelim();
    }
    if (message.impact !== undefined) {
      IncidentImpact.encode(message.impact, writer.uint32(202).fork()).ldelim();
    }
    if (message.resolution !== undefined) {
      IncidentResolution.encode(message.resolution, writer.uint32(242).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): IncidentData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIncidentData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.incidentId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.severity = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.resolvedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.affectedServices.push(reader.string());
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.affectedComponents.push(reader.string());
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.updates.push(IncidentUpdate.decode(reader, reader.uint32()));
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.impact = IncidentImpact.decode(reader, reader.uint32());
          continue;
        case 30:
          if (tag !== 242) {
            break;
          }

          message.resolution = IncidentResolution.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IncidentData {
    return {
      incidentId: isSet(object.incidentId) ? globalThis.String(object.incidentId) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      severity: isSet(object.severity) ? incidentSeverityFromJSON(object.severity) : 0,
      status: isSet(object.status) ? incidentStatusFromJSON(object.status) : 0,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      resolvedAt: isSet(object.resolvedAt) ? fromJsonTimestamp(object.resolvedAt) : undefined,
      affectedServices: globalThis.Array.isArray(object?.affectedServices)
        ? object.affectedServices.map((e: any) => globalThis.String(e))
        : [],
      affectedComponents: globalThis.Array.isArray(object?.affectedComponents)
        ? object.affectedComponents.map((e: any) => globalThis.String(e))
        : [],
      updates: globalThis.Array.isArray(object?.updates)
        ? object.updates.map((e: any) => IncidentUpdate.fromJSON(e))
        : [],
      impact: isSet(object.impact) ? IncidentImpact.fromJSON(object.impact) : undefined,
      resolution: isSet(object.resolution) ? IncidentResolution.fromJSON(object.resolution) : undefined,
    };
  },

  toJSON(message: IncidentData): unknown {
    const obj: any = {};
    if (message.incidentId !== "") {
      obj.incidentId = message.incidentId;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.severity !== 0) {
      obj.severity = incidentSeverityToJSON(message.severity);
    }
    if (message.status !== 0) {
      obj.status = incidentStatusToJSON(message.status);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    if (message.resolvedAt !== undefined) {
      obj.resolvedAt = message.resolvedAt.toISOString();
    }
    if (message.affectedServices?.length) {
      obj.affectedServices = message.affectedServices;
    }
    if (message.affectedComponents?.length) {
      obj.affectedComponents = message.affectedComponents;
    }
    if (message.updates?.length) {
      obj.updates = message.updates.map((e) => IncidentUpdate.toJSON(e));
    }
    if (message.impact !== undefined) {
      obj.impact = IncidentImpact.toJSON(message.impact);
    }
    if (message.resolution !== undefined) {
      obj.resolution = IncidentResolution.toJSON(message.resolution);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IncidentData>, I>>(base?: I): IncidentData {
    return IncidentData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IncidentData>, I>>(object: I): IncidentData {
    const message = createBaseIncidentData();
    message.incidentId = object.incidentId ?? "";
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.severity = object.severity ?? 0;
    message.status = object.status ?? 0;
    message.createdAt = object.createdAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    message.resolvedAt = object.resolvedAt ?? undefined;
    message.affectedServices = object.affectedServices?.map((e) => e) || [];
    message.affectedComponents = object.affectedComponents?.map((e) => e) || [];
    message.updates = object.updates?.map((e) => IncidentUpdate.fromPartial(e)) || [];
    message.impact = (object.impact !== undefined && object.impact !== null)
      ? IncidentImpact.fromPartial(object.impact)
      : undefined;
    message.resolution = (object.resolution !== undefined && object.resolution !== null)
      ? IncidentResolution.fromPartial(object.resolution)
      : undefined;
    return message;
  },
};

function createBaseIncidentUpdate(): IncidentUpdate {
  return { updateId: "", timestamp: undefined, status: 0, message: "", author: "", type: 0 };
}

export const IncidentUpdate = {
  encode(message: IncidentUpdate, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.updateId !== "") {
      writer.uint32(10).string(message.updateId);
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(18).fork()).ldelim();
    }
    if (message.status !== 0) {
      writer.uint32(24).int32(message.status);
    }
    if (message.message !== "") {
      writer.uint32(34).string(message.message);
    }
    if (message.author !== "") {
      writer.uint32(42).string(message.author);
    }
    if (message.type !== 0) {
      writer.uint32(48).int32(message.type);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): IncidentUpdate {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIncidentUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.updateId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.message = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.author = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IncidentUpdate {
    return {
      updateId: isSet(object.updateId) ? globalThis.String(object.updateId) : "",
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      status: isSet(object.status) ? incidentStatusFromJSON(object.status) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      author: isSet(object.author) ? globalThis.String(object.author) : "",
      type: isSet(object.type) ? updateTypeFromJSON(object.type) : 0,
    };
  },

  toJSON(message: IncidentUpdate): unknown {
    const obj: any = {};
    if (message.updateId !== "") {
      obj.updateId = message.updateId;
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.status !== 0) {
      obj.status = incidentStatusToJSON(message.status);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.author !== "") {
      obj.author = message.author;
    }
    if (message.type !== 0) {
      obj.type = updateTypeToJSON(message.type);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IncidentUpdate>, I>>(base?: I): IncidentUpdate {
    return IncidentUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IncidentUpdate>, I>>(object: I): IncidentUpdate {
    const message = createBaseIncidentUpdate();
    message.updateId = object.updateId ?? "";
    message.timestamp = object.timestamp ?? undefined;
    message.status = object.status ?? 0;
    message.message = object.message ?? "";
    message.author = object.author ?? "";
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseIncidentImpact(): IncidentImpact {
  return { availabilityImpact: 0, performanceImpact: 0, affectedUsers: 0, affectedRegions: [], businessImpact: "" };
}

export const IncidentImpact = {
  encode(message: IncidentImpact, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.availabilityImpact !== 0) {
      writer.uint32(9).double(message.availabilityImpact);
    }
    if (message.performanceImpact !== 0) {
      writer.uint32(17).double(message.performanceImpact);
    }
    if (message.affectedUsers !== 0) {
      writer.uint32(24).uint32(message.affectedUsers);
    }
    for (const v of message.affectedRegions) {
      writer.uint32(34).string(v!);
    }
    if (message.businessImpact !== "") {
      writer.uint32(42).string(message.businessImpact);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): IncidentImpact {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIncidentImpact();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.availabilityImpact = reader.double();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.performanceImpact = reader.double();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.affectedUsers = reader.uint32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.affectedRegions.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.businessImpact = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IncidentImpact {
    return {
      availabilityImpact: isSet(object.availabilityImpact) ? globalThis.Number(object.availabilityImpact) : 0,
      performanceImpact: isSet(object.performanceImpact) ? globalThis.Number(object.performanceImpact) : 0,
      affectedUsers: isSet(object.affectedUsers) ? globalThis.Number(object.affectedUsers) : 0,
      affectedRegions: globalThis.Array.isArray(object?.affectedRegions)
        ? object.affectedRegions.map((e: any) => globalThis.String(e))
        : [],
      businessImpact: isSet(object.businessImpact) ? globalThis.String(object.businessImpact) : "",
    };
  },

  toJSON(message: IncidentImpact): unknown {
    const obj: any = {};
    if (message.availabilityImpact !== 0) {
      obj.availabilityImpact = message.availabilityImpact;
    }
    if (message.performanceImpact !== 0) {
      obj.performanceImpact = message.performanceImpact;
    }
    if (message.affectedUsers !== 0) {
      obj.affectedUsers = Math.round(message.affectedUsers);
    }
    if (message.affectedRegions?.length) {
      obj.affectedRegions = message.affectedRegions;
    }
    if (message.businessImpact !== "") {
      obj.businessImpact = message.businessImpact;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IncidentImpact>, I>>(base?: I): IncidentImpact {
    return IncidentImpact.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IncidentImpact>, I>>(object: I): IncidentImpact {
    const message = createBaseIncidentImpact();
    message.availabilityImpact = object.availabilityImpact ?? 0;
    message.performanceImpact = object.performanceImpact ?? 0;
    message.affectedUsers = object.affectedUsers ?? 0;
    message.affectedRegions = object.affectedRegions?.map((e) => e) || [];
    message.businessImpact = object.businessImpact ?? "";
    return message;
  },
};

function createBaseIncidentResolution(): IncidentResolution {
  return { rootCause: "", resolutionSteps: "", preventionMeasures: "", lessonsLearned: [], postmortemUrl: "" };
}

export const IncidentResolution = {
  encode(message: IncidentResolution, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.rootCause !== "") {
      writer.uint32(10).string(message.rootCause);
    }
    if (message.resolutionSteps !== "") {
      writer.uint32(18).string(message.resolutionSteps);
    }
    if (message.preventionMeasures !== "") {
      writer.uint32(26).string(message.preventionMeasures);
    }
    for (const v of message.lessonsLearned) {
      writer.uint32(34).string(v!);
    }
    if (message.postmortemUrl !== "") {
      writer.uint32(42).string(message.postmortemUrl);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): IncidentResolution {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIncidentResolution();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rootCause = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.resolutionSteps = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.preventionMeasures = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.lessonsLearned.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.postmortemUrl = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IncidentResolution {
    return {
      rootCause: isSet(object.rootCause) ? globalThis.String(object.rootCause) : "",
      resolutionSteps: isSet(object.resolutionSteps) ? globalThis.String(object.resolutionSteps) : "",
      preventionMeasures: isSet(object.preventionMeasures) ? globalThis.String(object.preventionMeasures) : "",
      lessonsLearned: globalThis.Array.isArray(object?.lessonsLearned)
        ? object.lessonsLearned.map((e: any) => globalThis.String(e))
        : [],
      postmortemUrl: isSet(object.postmortemUrl) ? globalThis.String(object.postmortemUrl) : "",
    };
  },

  toJSON(message: IncidentResolution): unknown {
    const obj: any = {};
    if (message.rootCause !== "") {
      obj.rootCause = message.rootCause;
    }
    if (message.resolutionSteps !== "") {
      obj.resolutionSteps = message.resolutionSteps;
    }
    if (message.preventionMeasures !== "") {
      obj.preventionMeasures = message.preventionMeasures;
    }
    if (message.lessonsLearned?.length) {
      obj.lessonsLearned = message.lessonsLearned;
    }
    if (message.postmortemUrl !== "") {
      obj.postmortemUrl = message.postmortemUrl;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IncidentResolution>, I>>(base?: I): IncidentResolution {
    return IncidentResolution.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IncidentResolution>, I>>(object: I): IncidentResolution {
    const message = createBaseIncidentResolution();
    message.rootCause = object.rootCause ?? "";
    message.resolutionSteps = object.resolutionSteps ?? "";
    message.preventionMeasures = object.preventionMeasures ?? "";
    message.lessonsLearned = object.lessonsLearned?.map((e) => e) || [];
    message.postmortemUrl = object.postmortemUrl ?? "";
    return message;
  },
};

function createBaseIngestResponse(): IngestResponse {
  return { success: false, message: "", processedCount: 0, failedCount: 0 };
}

export const IngestResponse = {
  encode(message: IngestResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.processedCount !== 0) {
      writer.uint32(24).uint32(message.processedCount);
    }
    if (message.failedCount !== 0) {
      writer.uint32(32).uint32(message.failedCount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): IngestResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIngestResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.processedCount = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.failedCount = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IngestResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      processedCount: isSet(object.processedCount) ? globalThis.Number(object.processedCount) : 0,
      failedCount: isSet(object.failedCount) ? globalThis.Number(object.failedCount) : 0,
    };
  },

  toJSON(message: IngestResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.processedCount !== 0) {
      obj.processedCount = Math.round(message.processedCount);
    }
    if (message.failedCount !== 0) {
      obj.failedCount = Math.round(message.failedCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IngestResponse>, I>>(base?: I): IngestResponse {
    return IngestResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IngestResponse>, I>>(object: I): IngestResponse {
    const message = createBaseIngestResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.processedCount = object.processedCount ?? 0;
    message.failedCount = object.failedCount ?? 0;
    return message;
  },
};

function createBaseHealthResponse(): HealthResponse {
  return { success: false, message: "", nextCheck: undefined };
}

export const HealthResponse = {
  encode(message: HealthResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.nextCheck !== undefined) {
      Timestamp.encode(toTimestamp(message.nextCheck), writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HealthResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.nextCheck = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      nextCheck: isSet(object.nextCheck) ? fromJsonTimestamp(object.nextCheck) : undefined,
    };
  },

  toJSON(message: HealthResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.nextCheck !== undefined) {
      obj.nextCheck = message.nextCheck.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthResponse>, I>>(base?: I): HealthResponse {
    return HealthResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthResponse>, I>>(object: I): HealthResponse {
    const message = createBaseHealthResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.nextCheck = object.nextCheck ?? undefined;
    return message;
  },
};

function createBaseIncidentResponse(): IncidentResponse {
  return { success: false, message: "", incidentId: "" };
}

export const IncidentResponse = {
  encode(message: IncidentResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.incidentId !== "") {
      writer.uint32(26).string(message.incidentId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): IncidentResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIncidentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.incidentId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IncidentResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      incidentId: isSet(object.incidentId) ? globalThis.String(object.incidentId) : "",
    };
  },

  toJSON(message: IncidentResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.incidentId !== "") {
      obj.incidentId = message.incidentId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IncidentResponse>, I>>(base?: I): IncidentResponse {
    return IncidentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IncidentResponse>, I>>(object: I): IncidentResponse {
    const message = createBaseIncidentResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.incidentId = object.incidentId ?? "";
    return message;
  },
};

function createBaseHealthQuery(): HealthQuery {
  return { serviceNames: [], since: undefined };
}

export const HealthQuery = {
  encode(message: HealthQuery, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.serviceNames) {
      writer.uint32(10).string(v!);
    }
    if (message.since !== undefined) {
      Timestamp.encode(toTimestamp(message.since), writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HealthQuery {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthQuery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.serviceNames.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.since = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthQuery {
    return {
      serviceNames: globalThis.Array.isArray(object?.serviceNames)
        ? object.serviceNames.map((e: any) => globalThis.String(e))
        : [],
      since: isSet(object.since) ? fromJsonTimestamp(object.since) : undefined,
    };
  },

  toJSON(message: HealthQuery): unknown {
    const obj: any = {};
    if (message.serviceNames?.length) {
      obj.serviceNames = message.serviceNames;
    }
    if (message.since !== undefined) {
      obj.since = message.since.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthQuery>, I>>(base?: I): HealthQuery {
    return HealthQuery.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthQuery>, I>>(object: I): HealthQuery {
    const message = createBaseHealthQuery();
    message.serviceNames = object.serviceNames?.map((e) => e) || [];
    message.since = object.since ?? undefined;
    return message;
  },
};

function createBaseHealthQueryResponse(): HealthQueryResponse {
  return { services: [] };
}

export const HealthQueryResponse = {
  encode(message: HealthQueryResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.services) {
      ServiceHealth.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HealthQueryResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthQueryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.services.push(ServiceHealth.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthQueryResponse {
    return {
      services: globalThis.Array.isArray(object?.services)
        ? object.services.map((e: any) => ServiceHealth.fromJSON(e))
        : [],
    };
  },

  toJSON(message: HealthQueryResponse): unknown {
    const obj: any = {};
    if (message.services?.length) {
      obj.services = message.services.map((e) => ServiceHealth.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthQueryResponse>, I>>(base?: I): HealthQueryResponse {
    return HealthQueryResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthQueryResponse>, I>>(object: I): HealthQueryResponse {
    const message = createBaseHealthQueryResponse();
    message.services = object.services?.map((e) => ServiceHealth.fromPartial(e)) || [];
    return message;
  },
};

function createBaseIncidentQuery(): IncidentQuery {
  return { statuses: [], severities: [], since: undefined };
}

export const IncidentQuery = {
  encode(message: IncidentQuery, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.statuses) {
      writer.int32(v);
    }
    writer.ldelim();
    writer.uint32(18).fork();
    for (const v of message.severities) {
      writer.int32(v);
    }
    writer.ldelim();
    if (message.since !== undefined) {
      Timestamp.encode(toTimestamp(message.since), writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): IncidentQuery {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIncidentQuery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.statuses.push(reader.int32() as any);

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.statuses.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 2:
          if (tag === 16) {
            message.severities.push(reader.int32() as any);

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.severities.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.since = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IncidentQuery {
    return {
      statuses: globalThis.Array.isArray(object?.statuses)
        ? object.statuses.map((e: any) => incidentStatusFromJSON(e))
        : [],
      severities: globalThis.Array.isArray(object?.severities)
        ? object.severities.map((e: any) => incidentSeverityFromJSON(e))
        : [],
      since: isSet(object.since) ? fromJsonTimestamp(object.since) : undefined,
    };
  },

  toJSON(message: IncidentQuery): unknown {
    const obj: any = {};
    if (message.statuses?.length) {
      obj.statuses = message.statuses.map((e) => incidentStatusToJSON(e));
    }
    if (message.severities?.length) {
      obj.severities = message.severities.map((e) => incidentSeverityToJSON(e));
    }
    if (message.since !== undefined) {
      obj.since = message.since.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IncidentQuery>, I>>(base?: I): IncidentQuery {
    return IncidentQuery.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IncidentQuery>, I>>(object: I): IncidentQuery {
    const message = createBaseIncidentQuery();
    message.statuses = object.statuses?.map((e) => e) || [];
    message.severities = object.severities?.map((e) => e) || [];
    message.since = object.since ?? undefined;
    return message;
  },
};

function createBaseIncidentQueryResponse(): IncidentQueryResponse {
  return { incidents: [] };
}

export const IncidentQueryResponse = {
  encode(message: IncidentQueryResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.incidents) {
      IncidentData.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): IncidentQueryResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIncidentQueryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.incidents.push(IncidentData.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IncidentQueryResponse {
    return {
      incidents: globalThis.Array.isArray(object?.incidents)
        ? object.incidents.map((e: any) => IncidentData.fromJSON(e))
        : [],
    };
  },

  toJSON(message: IncidentQueryResponse): unknown {
    const obj: any = {};
    if (message.incidents?.length) {
      obj.incidents = message.incidents.map((e) => IncidentData.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IncidentQueryResponse>, I>>(base?: I): IncidentQueryResponse {
    return IncidentQueryResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IncidentQueryResponse>, I>>(object: I): IncidentQueryResponse {
    const message = createBaseIncidentQueryResponse();
    message.incidents = object.incidents?.map((e) => IncidentData.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMetricQuery(): MetricQuery {
  return { metricName: "", labels: {}, startTime: undefined, endTime: undefined };
}

export const MetricQuery = {
  encode(message: MetricQuery, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.metricName !== "") {
      writer.uint32(10).string(message.metricName);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      MetricQuery_LabelsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    });
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(26).fork()).ldelim();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MetricQuery {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricQuery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metricName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = MetricQuery_LabelsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.labels[entry2.key] = entry2.value;
          }
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetricQuery {
    return {
      metricName: isSet(object.metricName) ? globalThis.String(object.metricName) : "",
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
    };
  },

  toJSON(message: MetricQuery): unknown {
    const obj: any = {};
    if (message.metricName !== "") {
      obj.metricName = message.metricName;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MetricQuery>, I>>(base?: I): MetricQuery {
    return MetricQuery.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MetricQuery>, I>>(object: I): MetricQuery {
    const message = createBaseMetricQuery();
    message.metricName = object.metricName ?? "";
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    return message;
  },
};

function createBaseMetricQuery_LabelsEntry(): MetricQuery_LabelsEntry {
  return { key: "", value: "" };
}

export const MetricQuery_LabelsEntry = {
  encode(message: MetricQuery_LabelsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MetricQuery_LabelsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricQuery_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetricQuery_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: MetricQuery_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MetricQuery_LabelsEntry>, I>>(base?: I): MetricQuery_LabelsEntry {
    return MetricQuery_LabelsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MetricQuery_LabelsEntry>, I>>(object: I): MetricQuery_LabelsEntry {
    const message = createBaseMetricQuery_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseMetricQueryResponse(): MetricQueryResponse {
  return { metrics: [] };
}

export const MetricQueryResponse = {
  encode(message: MetricQueryResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.metrics) {
      MetricData.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MetricQueryResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricQueryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metrics.push(MetricData.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetricQueryResponse {
    return {
      metrics: globalThis.Array.isArray(object?.metrics) ? object.metrics.map((e: any) => MetricData.fromJSON(e)) : [],
    };
  },

  toJSON(message: MetricQueryResponse): unknown {
    const obj: any = {};
    if (message.metrics?.length) {
      obj.metrics = message.metrics.map((e) => MetricData.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MetricQueryResponse>, I>>(base?: I): MetricQueryResponse {
    return MetricQueryResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MetricQueryResponse>, I>>(object: I): MetricQueryResponse {
    const message = createBaseMetricQueryResponse();
    message.metrics = object.metrics?.map((e) => MetricData.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTraceQuery(): TraceQuery {
  return { traceId: "", serviceName: "", startTime: undefined, endTime: undefined, limit: 0 };
}

export const TraceQuery = {
  encode(message: TraceQuery, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.traceId !== "") {
      writer.uint32(10).string(message.traceId);
    }
    if (message.serviceName !== "") {
      writer.uint32(18).string(message.serviceName);
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(26).fork()).ldelim();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(34).fork()).ldelim();
    }
    if (message.limit !== 0) {
      writer.uint32(40).int32(message.limit);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TraceQuery {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTraceQuery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.traceId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.serviceName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.limit = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TraceQuery {
    return {
      traceId: isSet(object.traceId) ? globalThis.String(object.traceId) : "",
      serviceName: isSet(object.serviceName) ? globalThis.String(object.serviceName) : "",
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
    };
  },

  toJSON(message: TraceQuery): unknown {
    const obj: any = {};
    if (message.traceId !== "") {
      obj.traceId = message.traceId;
    }
    if (message.serviceName !== "") {
      obj.serviceName = message.serviceName;
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TraceQuery>, I>>(base?: I): TraceQuery {
    return TraceQuery.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TraceQuery>, I>>(object: I): TraceQuery {
    const message = createBaseTraceQuery();
    message.traceId = object.traceId ?? "";
    message.serviceName = object.serviceName ?? "";
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.limit = object.limit ?? 0;
    return message;
  },
};

function createBaseTraceQueryResponse(): TraceQueryResponse {
  return { traces: [] };
}

export const TraceQueryResponse = {
  encode(message: TraceQueryResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.traces) {
      TraceEvent.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TraceQueryResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTraceQueryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.traces.push(TraceEvent.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TraceQueryResponse {
    return {
      traces: globalThis.Array.isArray(object?.traces) ? object.traces.map((e: any) => TraceEvent.fromJSON(e)) : [],
    };
  },

  toJSON(message: TraceQueryResponse): unknown {
    const obj: any = {};
    if (message.traces?.length) {
      obj.traces = message.traces.map((e) => TraceEvent.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TraceQueryResponse>, I>>(base?: I): TraceQueryResponse {
    return TraceQueryResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TraceQueryResponse>, I>>(object: I): TraceQueryResponse {
    const message = createBaseTraceQueryResponse();
    message.traces = object.traces?.map((e) => TraceEvent.fromPartial(e)) || [];
    return message;
  },
};

/** Observability service for collecting and querying telemetry data */
export type ObservabilityServiceService = typeof ObservabilityServiceService;
export const ObservabilityServiceService = {
  /** Log ingestion */
  ingestLogs: {
    path: "/unhinged.observability.v1.ObservabilityService/IngestLogs",
    requestStream: true,
    responseStream: false,
    requestSerialize: (value: LogEvent) => Buffer.from(LogEvent.encode(value).finish()),
    requestDeserialize: (value: Buffer) => LogEvent.decode(value),
    responseSerialize: (value: IngestResponse) => Buffer.from(IngestResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => IngestResponse.decode(value),
  },
  /** Trace ingestion */
  ingestTraces: {
    path: "/unhinged.observability.v1.ObservabilityService/IngestTraces",
    requestStream: true,
    responseStream: false,
    requestSerialize: (value: TraceEvent) => Buffer.from(TraceEvent.encode(value).finish()),
    requestDeserialize: (value: Buffer) => TraceEvent.decode(value),
    responseSerialize: (value: IngestResponse) => Buffer.from(IngestResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => IngestResponse.decode(value),
  },
  /** Metric ingestion */
  ingestMetrics: {
    path: "/unhinged.observability.v1.ObservabilityService/IngestMetrics",
    requestStream: true,
    responseStream: false,
    requestSerialize: (value: MetricEvent) => Buffer.from(MetricEvent.encode(value).finish()),
    requestDeserialize: (value: Buffer) => MetricEvent.decode(value),
    responseSerialize: (value: IngestResponse) => Buffer.from(IngestResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => IngestResponse.decode(value),
  },
  /** Health monitoring */
  reportHealth: {
    path: "/unhinged.observability.v1.ObservabilityService/ReportHealth",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ServiceHealthEvent) => Buffer.from(ServiceHealthEvent.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ServiceHealthEvent.decode(value),
    responseSerialize: (value: HealthResponse) => Buffer.from(HealthResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => HealthResponse.decode(value),
  },
  /** Incident management */
  reportIncident: {
    path: "/unhinged.observability.v1.ObservabilityService/ReportIncident",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: IncidentEvent) => Buffer.from(IncidentEvent.encode(value).finish()),
    requestDeserialize: (value: Buffer) => IncidentEvent.decode(value),
    responseSerialize: (value: IncidentResponse) => Buffer.from(IncidentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => IncidentResponse.decode(value),
  },
  updateIncident: {
    path: "/unhinged.observability.v1.ObservabilityService/UpdateIncident",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: IncidentEvent) => Buffer.from(IncidentEvent.encode(value).finish()),
    requestDeserialize: (value: Buffer) => IncidentEvent.decode(value),
    responseSerialize: (value: IncidentResponse) => Buffer.from(IncidentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => IncidentResponse.decode(value),
  },
  /** Query APIs for status page */
  getServiceHealth: {
    path: "/unhinged.observability.v1.ObservabilityService/GetServiceHealth",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: HealthQuery) => Buffer.from(HealthQuery.encode(value).finish()),
    requestDeserialize: (value: Buffer) => HealthQuery.decode(value),
    responseSerialize: (value: HealthQueryResponse) => Buffer.from(HealthQueryResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => HealthQueryResponse.decode(value),
  },
  getActiveIncidents: {
    path: "/unhinged.observability.v1.ObservabilityService/GetActiveIncidents",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: IncidentQuery) => Buffer.from(IncidentQuery.encode(value).finish()),
    requestDeserialize: (value: Buffer) => IncidentQuery.decode(value),
    responseSerialize: (value: IncidentQueryResponse) => Buffer.from(IncidentQueryResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => IncidentQueryResponse.decode(value),
  },
  getMetrics: {
    path: "/unhinged.observability.v1.ObservabilityService/GetMetrics",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: MetricQuery) => Buffer.from(MetricQuery.encode(value).finish()),
    requestDeserialize: (value: Buffer) => MetricQuery.decode(value),
    responseSerialize: (value: MetricQueryResponse) => Buffer.from(MetricQueryResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => MetricQueryResponse.decode(value),
  },
  getTraces: {
    path: "/unhinged.observability.v1.ObservabilityService/GetTraces",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: TraceQuery) => Buffer.from(TraceQuery.encode(value).finish()),
    requestDeserialize: (value: Buffer) => TraceQuery.decode(value),
    responseSerialize: (value: TraceQueryResponse) => Buffer.from(TraceQueryResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TraceQueryResponse.decode(value),
  },
} as const;

export interface ObservabilityServiceServer extends UntypedServiceImplementation {
  /** Log ingestion */
  ingestLogs: handleClientStreamingCall<LogEvent, IngestResponse>;
  /** Trace ingestion */
  ingestTraces: handleClientStreamingCall<TraceEvent, IngestResponse>;
  /** Metric ingestion */
  ingestMetrics: handleClientStreamingCall<MetricEvent, IngestResponse>;
  /** Health monitoring */
  reportHealth: handleUnaryCall<ServiceHealthEvent, HealthResponse>;
  /** Incident management */
  reportIncident: handleUnaryCall<IncidentEvent, IncidentResponse>;
  updateIncident: handleUnaryCall<IncidentEvent, IncidentResponse>;
  /** Query APIs for status page */
  getServiceHealth: handleUnaryCall<HealthQuery, HealthQueryResponse>;
  getActiveIncidents: handleUnaryCall<IncidentQuery, IncidentQueryResponse>;
  getMetrics: handleUnaryCall<MetricQuery, MetricQueryResponse>;
  getTraces: handleUnaryCall<TraceQuery, TraceQueryResponse>;
}

export interface ObservabilityServiceClient extends Client {
  /** Log ingestion */
  ingestLogs(callback: (error: ServiceError | null, response: IngestResponse) => void): ClientWritableStream<LogEvent>;
  ingestLogs(
    metadata: Metadata,
    callback: (error: ServiceError | null, response: IngestResponse) => void,
  ): ClientWritableStream<LogEvent>;
  ingestLogs(
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: IngestResponse) => void,
  ): ClientWritableStream<LogEvent>;
  ingestLogs(
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: IngestResponse) => void,
  ): ClientWritableStream<LogEvent>;
  /** Trace ingestion */
  ingestTraces(
    callback: (error: ServiceError | null, response: IngestResponse) => void,
  ): ClientWritableStream<TraceEvent>;
  ingestTraces(
    metadata: Metadata,
    callback: (error: ServiceError | null, response: IngestResponse) => void,
  ): ClientWritableStream<TraceEvent>;
  ingestTraces(
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: IngestResponse) => void,
  ): ClientWritableStream<TraceEvent>;
  ingestTraces(
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: IngestResponse) => void,
  ): ClientWritableStream<TraceEvent>;
  /** Metric ingestion */
  ingestMetrics(
    callback: (error: ServiceError | null, response: IngestResponse) => void,
  ): ClientWritableStream<MetricEvent>;
  ingestMetrics(
    metadata: Metadata,
    callback: (error: ServiceError | null, response: IngestResponse) => void,
  ): ClientWritableStream<MetricEvent>;
  ingestMetrics(
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: IngestResponse) => void,
  ): ClientWritableStream<MetricEvent>;
  ingestMetrics(
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: IngestResponse) => void,
  ): ClientWritableStream<MetricEvent>;
  /** Health monitoring */
  reportHealth(
    request: ServiceHealthEvent,
    callback: (error: ServiceError | null, response: HealthResponse) => void,
  ): ClientUnaryCall;
  reportHealth(
    request: ServiceHealthEvent,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: HealthResponse) => void,
  ): ClientUnaryCall;
  reportHealth(
    request: ServiceHealthEvent,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: HealthResponse) => void,
  ): ClientUnaryCall;
  /** Incident management */
  reportIncident(
    request: IncidentEvent,
    callback: (error: ServiceError | null, response: IncidentResponse) => void,
  ): ClientUnaryCall;
  reportIncident(
    request: IncidentEvent,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: IncidentResponse) => void,
  ): ClientUnaryCall;
  reportIncident(
    request: IncidentEvent,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: IncidentResponse) => void,
  ): ClientUnaryCall;
  updateIncident(
    request: IncidentEvent,
    callback: (error: ServiceError | null, response: IncidentResponse) => void,
  ): ClientUnaryCall;
  updateIncident(
    request: IncidentEvent,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: IncidentResponse) => void,
  ): ClientUnaryCall;
  updateIncident(
    request: IncidentEvent,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: IncidentResponse) => void,
  ): ClientUnaryCall;
  /** Query APIs for status page */
  getServiceHealth(
    request: HealthQuery,
    callback: (error: ServiceError | null, response: HealthQueryResponse) => void,
  ): ClientUnaryCall;
  getServiceHealth(
    request: HealthQuery,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: HealthQueryResponse) => void,
  ): ClientUnaryCall;
  getServiceHealth(
    request: HealthQuery,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: HealthQueryResponse) => void,
  ): ClientUnaryCall;
  getActiveIncidents(
    request: IncidentQuery,
    callback: (error: ServiceError | null, response: IncidentQueryResponse) => void,
  ): ClientUnaryCall;
  getActiveIncidents(
    request: IncidentQuery,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: IncidentQueryResponse) => void,
  ): ClientUnaryCall;
  getActiveIncidents(
    request: IncidentQuery,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: IncidentQueryResponse) => void,
  ): ClientUnaryCall;
  getMetrics(
    request: MetricQuery,
    callback: (error: ServiceError | null, response: MetricQueryResponse) => void,
  ): ClientUnaryCall;
  getMetrics(
    request: MetricQuery,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MetricQueryResponse) => void,
  ): ClientUnaryCall;
  getMetrics(
    request: MetricQuery,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MetricQueryResponse) => void,
  ): ClientUnaryCall;
  getTraces(
    request: TraceQuery,
    callback: (error: ServiceError | null, response: TraceQueryResponse) => void,
  ): ClientUnaryCall;
  getTraces(
    request: TraceQuery,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TraceQueryResponse) => void,
  ): ClientUnaryCall;
  getTraces(
    request: TraceQuery,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TraceQueryResponse) => void,
  ): ClientUnaryCall;
}

export const ObservabilityServiceClient = makeGenericClientConstructor(
  ObservabilityServiceService,
  "unhinged.observability.v1.ObservabilityService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): ObservabilityServiceClient;
  service: typeof ObservabilityServiceService;
  serviceName: string;
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000).toString();
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (globalThis.Number(t.seconds) || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToString(long: Long) {
  return long.toString();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
