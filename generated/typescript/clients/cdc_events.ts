// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v3.21.12
// source: cdc_events.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Struct } from "./google/protobuf/struct";
import { Timestamp } from "./google/protobuf/timestamp";

export enum DocumentEventType {
  DOCUMENT_CREATED = 0,
  DOCUMENT_UPDATED = 1,
  DOCUMENT_DELETED = 2,
  DOCUMENT_ACCESSED = 3,
  DOCUMENT_TAGGED = 4,
  DOCUMENT_VERSIONED = 5,
  UNRECOGNIZED = -1,
}

export function documentEventTypeFromJSON(object: any): DocumentEventType {
  switch (object) {
    case 0:
    case "DOCUMENT_CREATED":
      return DocumentEventType.DOCUMENT_CREATED;
    case 1:
    case "DOCUMENT_UPDATED":
      return DocumentEventType.DOCUMENT_UPDATED;
    case 2:
    case "DOCUMENT_DELETED":
      return DocumentEventType.DOCUMENT_DELETED;
    case 3:
    case "DOCUMENT_ACCESSED":
      return DocumentEventType.DOCUMENT_ACCESSED;
    case 4:
    case "DOCUMENT_TAGGED":
      return DocumentEventType.DOCUMENT_TAGGED;
    case 5:
    case "DOCUMENT_VERSIONED":
      return DocumentEventType.DOCUMENT_VERSIONED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DocumentEventType.UNRECOGNIZED;
  }
}

export function documentEventTypeToJSON(object: DocumentEventType): string {
  switch (object) {
    case DocumentEventType.DOCUMENT_CREATED:
      return "DOCUMENT_CREATED";
    case DocumentEventType.DOCUMENT_UPDATED:
      return "DOCUMENT_UPDATED";
    case DocumentEventType.DOCUMENT_DELETED:
      return "DOCUMENT_DELETED";
    case DocumentEventType.DOCUMENT_ACCESSED:
      return "DOCUMENT_ACCESSED";
    case DocumentEventType.DOCUMENT_TAGGED:
      return "DOCUMENT_TAGGED";
    case DocumentEventType.DOCUMENT_VERSIONED:
      return "DOCUMENT_VERSIONED";
    case DocumentEventType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum LLMEventType {
  LLM_PROMPT_SENT = 0,
  LLM_RESPONSE_RECEIVED = 1,
  LLM_ERROR = 2,
  LLM_FEEDBACK = 3,
  LLM_TOKEN_USAGE = 4,
  UNRECOGNIZED = -1,
}

export function lLMEventTypeFromJSON(object: any): LLMEventType {
  switch (object) {
    case 0:
    case "LLM_PROMPT_SENT":
      return LLMEventType.LLM_PROMPT_SENT;
    case 1:
    case "LLM_RESPONSE_RECEIVED":
      return LLMEventType.LLM_RESPONSE_RECEIVED;
    case 2:
    case "LLM_ERROR":
      return LLMEventType.LLM_ERROR;
    case 3:
    case "LLM_FEEDBACK":
      return LLMEventType.LLM_FEEDBACK;
    case 4:
    case "LLM_TOKEN_USAGE":
      return LLMEventType.LLM_TOKEN_USAGE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LLMEventType.UNRECOGNIZED;
  }
}

export function lLMEventTypeToJSON(object: LLMEventType): string {
  switch (object) {
    case LLMEventType.LLM_PROMPT_SENT:
      return "LLM_PROMPT_SENT";
    case LLMEventType.LLM_RESPONSE_RECEIVED:
      return "LLM_RESPONSE_RECEIVED";
    case LLMEventType.LLM_ERROR:
      return "LLM_ERROR";
    case LLMEventType.LLM_FEEDBACK:
      return "LLM_FEEDBACK";
    case LLMEventType.LLM_TOKEN_USAGE:
      return "LLM_TOKEN_USAGE";
    case LLMEventType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum AgentEventType {
  AGENT_STARTED = 0,
  AGENT_STEP_COMPLETED = 1,
  AGENT_COMPLETED = 2,
  AGENT_FAILED = 3,
  AGENT_TOOL_USED = 4,
  UNRECOGNIZED = -1,
}

export function agentEventTypeFromJSON(object: any): AgentEventType {
  switch (object) {
    case 0:
    case "AGENT_STARTED":
      return AgentEventType.AGENT_STARTED;
    case 1:
    case "AGENT_STEP_COMPLETED":
      return AgentEventType.AGENT_STEP_COMPLETED;
    case 2:
    case "AGENT_COMPLETED":
      return AgentEventType.AGENT_COMPLETED;
    case 3:
    case "AGENT_FAILED":
      return AgentEventType.AGENT_FAILED;
    case 4:
    case "AGENT_TOOL_USED":
      return AgentEventType.AGENT_TOOL_USED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AgentEventType.UNRECOGNIZED;
  }
}

export function agentEventTypeToJSON(object: AgentEventType): string {
  switch (object) {
    case AgentEventType.AGENT_STARTED:
      return "AGENT_STARTED";
    case AgentEventType.AGENT_STEP_COMPLETED:
      return "AGENT_STEP_COMPLETED";
    case AgentEventType.AGENT_COMPLETED:
      return "AGENT_COMPLETED";
    case AgentEventType.AGENT_FAILED:
      return "AGENT_FAILED";
    case AgentEventType.AGENT_TOOL_USED:
      return "AGENT_TOOL_USED";
    case AgentEventType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum SessionEventType {
  SESSION_STARTED = 0,
  SESSION_ENDED = 1,
  SESSION_CONTEXT_ACCESSED = 2,
  SESSION_HEARTBEAT = 3,
  UNRECOGNIZED = -1,
}

export function sessionEventTypeFromJSON(object: any): SessionEventType {
  switch (object) {
    case 0:
    case "SESSION_STARTED":
      return SessionEventType.SESSION_STARTED;
    case 1:
    case "SESSION_ENDED":
      return SessionEventType.SESSION_ENDED;
    case 2:
    case "SESSION_CONTEXT_ACCESSED":
      return SessionEventType.SESSION_CONTEXT_ACCESSED;
    case 3:
    case "SESSION_HEARTBEAT":
      return SessionEventType.SESSION_HEARTBEAT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SessionEventType.UNRECOGNIZED;
  }
}

export function sessionEventTypeToJSON(object: SessionEventType): string {
  switch (object) {
    case SessionEventType.SESSION_STARTED:
      return "SESSION_STARTED";
    case SessionEventType.SESSION_ENDED:
      return "SESSION_ENDED";
    case SessionEventType.SESSION_CONTEXT_ACCESSED:
      return "SESSION_CONTEXT_ACCESSED";
    case SessionEventType.SESSION_HEARTBEAT:
      return "SESSION_HEARTBEAT";
    case SessionEventType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum SystemEventType {
  HEALTH_CHECK = 0,
  METRIC_REPORTED = 1,
  ALERT_TRIGGERED = 2,
  SERVICE_STARTED = 3,
  SERVICE_STOPPED = 4,
  UNRECOGNIZED = -1,
}

export function systemEventTypeFromJSON(object: any): SystemEventType {
  switch (object) {
    case 0:
    case "HEALTH_CHECK":
      return SystemEventType.HEALTH_CHECK;
    case 1:
    case "METRIC_REPORTED":
      return SystemEventType.METRIC_REPORTED;
    case 2:
    case "ALERT_TRIGGERED":
      return SystemEventType.ALERT_TRIGGERED;
    case 3:
    case "SERVICE_STARTED":
      return SystemEventType.SERVICE_STARTED;
    case 4:
    case "SERVICE_STOPPED":
      return SystemEventType.SERVICE_STOPPED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SystemEventType.UNRECOGNIZED;
  }
}

export function systemEventTypeToJSON(object: SystemEventType): string {
  switch (object) {
    case SystemEventType.HEALTH_CHECK:
      return "HEALTH_CHECK";
    case SystemEventType.METRIC_REPORTED:
      return "METRIC_REPORTED";
    case SystemEventType.ALERT_TRIGGERED:
      return "ALERT_TRIGGERED";
    case SystemEventType.SERVICE_STARTED:
      return "SERVICE_STARTED";
    case SystemEventType.SERVICE_STOPPED:
      return "SERVICE_STOPPED";
    case SystemEventType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum WorkflowEventType {
  WORKFLOW_TRIGGERED = 0,
  WORKFLOW_STEP_EXECUTED = 1,
  WORKFLOW_COMPLETED = 2,
  WORKFLOW_FAILED = 3,
  UNRECOGNIZED = -1,
}

export function workflowEventTypeFromJSON(object: any): WorkflowEventType {
  switch (object) {
    case 0:
    case "WORKFLOW_TRIGGERED":
      return WorkflowEventType.WORKFLOW_TRIGGERED;
    case 1:
    case "WORKFLOW_STEP_EXECUTED":
      return WorkflowEventType.WORKFLOW_STEP_EXECUTED;
    case 2:
    case "WORKFLOW_COMPLETED":
      return WorkflowEventType.WORKFLOW_COMPLETED;
    case 3:
    case "WORKFLOW_FAILED":
      return WorkflowEventType.WORKFLOW_FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WorkflowEventType.UNRECOGNIZED;
  }
}

export function workflowEventTypeToJSON(object: WorkflowEventType): string {
  switch (object) {
    case WorkflowEventType.WORKFLOW_TRIGGERED:
      return "WORKFLOW_TRIGGERED";
    case WorkflowEventType.WORKFLOW_STEP_EXECUTED:
      return "WORKFLOW_STEP_EXECUTED";
    case WorkflowEventType.WORKFLOW_COMPLETED:
      return "WORKFLOW_COMPLETED";
    case WorkflowEventType.WORKFLOW_FAILED:
      return "WORKFLOW_FAILED";
    case WorkflowEventType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ChatEventType {
  CHAT_EVENT_TYPE_UNSPECIFIED = 0,
  CHAT_EVENT_TYPE_CONVERSATION_CREATED = 1,
  CHAT_EVENT_TYPE_MESSAGE_SENT = 2,
  CHAT_EVENT_TYPE_MESSAGE_UPDATED = 3,
  CHAT_EVENT_TYPE_TYPING_STARTED = 4,
  CHAT_EVENT_TYPE_PARTICIPANT_JOINED = 5,
  UNRECOGNIZED = -1,
}

export function chatEventTypeFromJSON(object: any): ChatEventType {
  switch (object) {
    case 0:
    case "CHAT_EVENT_TYPE_UNSPECIFIED":
      return ChatEventType.CHAT_EVENT_TYPE_UNSPECIFIED;
    case 1:
    case "CHAT_EVENT_TYPE_CONVERSATION_CREATED":
      return ChatEventType.CHAT_EVENT_TYPE_CONVERSATION_CREATED;
    case 2:
    case "CHAT_EVENT_TYPE_MESSAGE_SENT":
      return ChatEventType.CHAT_EVENT_TYPE_MESSAGE_SENT;
    case 3:
    case "CHAT_EVENT_TYPE_MESSAGE_UPDATED":
      return ChatEventType.CHAT_EVENT_TYPE_MESSAGE_UPDATED;
    case 4:
    case "CHAT_EVENT_TYPE_TYPING_STARTED":
      return ChatEventType.CHAT_EVENT_TYPE_TYPING_STARTED;
    case 5:
    case "CHAT_EVENT_TYPE_PARTICIPANT_JOINED":
      return ChatEventType.CHAT_EVENT_TYPE_PARTICIPANT_JOINED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ChatEventType.UNRECOGNIZED;
  }
}

export function chatEventTypeToJSON(object: ChatEventType): string {
  switch (object) {
    case ChatEventType.CHAT_EVENT_TYPE_UNSPECIFIED:
      return "CHAT_EVENT_TYPE_UNSPECIFIED";
    case ChatEventType.CHAT_EVENT_TYPE_CONVERSATION_CREATED:
      return "CHAT_EVENT_TYPE_CONVERSATION_CREATED";
    case ChatEventType.CHAT_EVENT_TYPE_MESSAGE_SENT:
      return "CHAT_EVENT_TYPE_MESSAGE_SENT";
    case ChatEventType.CHAT_EVENT_TYPE_MESSAGE_UPDATED:
      return "CHAT_EVENT_TYPE_MESSAGE_UPDATED";
    case ChatEventType.CHAT_EVENT_TYPE_TYPING_STARTED:
      return "CHAT_EVENT_TYPE_TYPING_STARTED";
    case ChatEventType.CHAT_EVENT_TYPE_PARTICIPANT_JOINED:
      return "CHAT_EVENT_TYPE_PARTICIPANT_JOINED";
    case ChatEventType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum AudioEventType {
  AUDIO_EVENT_TYPE_UNSPECIFIED = 0,
  AUDIO_EVENT_TYPE_TTS_STARTED = 1,
  AUDIO_EVENT_TYPE_TTS_COMPLETED = 2,
  AUDIO_EVENT_TYPE_STT_COMPLETED = 3,
  UNRECOGNIZED = -1,
}

export function audioEventTypeFromJSON(object: any): AudioEventType {
  switch (object) {
    case 0:
    case "AUDIO_EVENT_TYPE_UNSPECIFIED":
      return AudioEventType.AUDIO_EVENT_TYPE_UNSPECIFIED;
    case 1:
    case "AUDIO_EVENT_TYPE_TTS_STARTED":
      return AudioEventType.AUDIO_EVENT_TYPE_TTS_STARTED;
    case 2:
    case "AUDIO_EVENT_TYPE_TTS_COMPLETED":
      return AudioEventType.AUDIO_EVENT_TYPE_TTS_COMPLETED;
    case 3:
    case "AUDIO_EVENT_TYPE_STT_COMPLETED":
      return AudioEventType.AUDIO_EVENT_TYPE_STT_COMPLETED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AudioEventType.UNRECOGNIZED;
  }
}

export function audioEventTypeToJSON(object: AudioEventType): string {
  switch (object) {
    case AudioEventType.AUDIO_EVENT_TYPE_UNSPECIFIED:
      return "AUDIO_EVENT_TYPE_UNSPECIFIED";
    case AudioEventType.AUDIO_EVENT_TYPE_TTS_STARTED:
      return "AUDIO_EVENT_TYPE_TTS_STARTED";
    case AudioEventType.AUDIO_EVENT_TYPE_TTS_COMPLETED:
      return "AUDIO_EVENT_TYPE_TTS_COMPLETED";
    case AudioEventType.AUDIO_EVENT_TYPE_STT_COMPLETED:
      return "AUDIO_EVENT_TYPE_STT_COMPLETED";
    case AudioEventType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum UserEventType {
  USER_EVENT_TYPE_UNSPECIFIED = 0,
  USER_EVENT_TYPE_CREATED = 1,
  USER_EVENT_TYPE_LOGGED_IN = 2,
  USER_EVENT_TYPE_TEAM_MEMBER_ADDED = 3,
  UNRECOGNIZED = -1,
}

export function userEventTypeFromJSON(object: any): UserEventType {
  switch (object) {
    case 0:
    case "USER_EVENT_TYPE_UNSPECIFIED":
      return UserEventType.USER_EVENT_TYPE_UNSPECIFIED;
    case 1:
    case "USER_EVENT_TYPE_CREATED":
      return UserEventType.USER_EVENT_TYPE_CREATED;
    case 2:
    case "USER_EVENT_TYPE_LOGGED_IN":
      return UserEventType.USER_EVENT_TYPE_LOGGED_IN;
    case 3:
    case "USER_EVENT_TYPE_TEAM_MEMBER_ADDED":
      return UserEventType.USER_EVENT_TYPE_TEAM_MEMBER_ADDED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return UserEventType.UNRECOGNIZED;
  }
}

export function userEventTypeToJSON(object: UserEventType): string {
  switch (object) {
    case UserEventType.USER_EVENT_TYPE_UNSPECIFIED:
      return "USER_EVENT_TYPE_UNSPECIFIED";
    case UserEventType.USER_EVENT_TYPE_CREATED:
      return "USER_EVENT_TYPE_CREATED";
    case UserEventType.USER_EVENT_TYPE_LOGGED_IN:
      return "USER_EVENT_TYPE_LOGGED_IN";
    case UserEventType.USER_EVENT_TYPE_TEAM_MEMBER_ADDED:
      return "USER_EVENT_TYPE_TEAM_MEMBER_ADDED";
    case UserEventType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Universal event envelope for all CDC events */
export interface UniversalEvent {
  /** Event identification */
  eventId: string;
  eventType: string;
  eventVersion: string;
  /** Timing and sequencing */
  eventTime?: Date | undefined;
  sequenceNumber: string;
  /** Source and context */
  sourceService: string;
  sourceVersion: string;
  traceId: string;
  correlationId: string;
  /** User and session context */
  userId: string;
  sessionId: string;
  tenantId: string;
  documentEvent?: DocumentEvent | undefined;
  llmEvent?: LLMEvent | undefined;
  agentEvent?: AgentEvent | undefined;
  sessionEvent?: SessionEvent | undefined;
  systemEvent?: SystemEvent | undefined;
  workflowEvent?:
    | WorkflowEvent
    | undefined;
  /** Chat and conversation events */
  chatEvent?:
    | ChatEvent
    | undefined;
  /** Audio processing events */
  audioEvent?:
    | AudioEvent
    | undefined;
  /** User management events */
  userEvent?:
    | UserEvent
    | undefined;
  /** Metadata and tags */
  metadata?: { [key: string]: any } | undefined;
  tags: string[];
  /** Event routing and processing */
  routingKey: string;
  retryCount: number;
  expiresAt?: Date | undefined;
}

export interface DocumentEvent {
  documentUuid: string;
  documentType: string;
  namespace: string;
  version: number;
  eventType: DocumentEventType;
  created?: DocumentCreated | undefined;
  updated?: DocumentUpdated | undefined;
  deleted?: DocumentDeleted | undefined;
  accessed?: DocumentAccessed | undefined;
  tagged?: DocumentTagged | undefined;
  versioned?: DocumentVersioned | undefined;
}

export interface DocumentCreated {
  documentName: string;
  createdBy: string;
  createdByType: string;
  documentMetadata?: { [key: string]: any } | undefined;
  documentSizeBytes: string;
}

export interface DocumentUpdated {
  previousVersion: number;
  updatedBy: string;
  updatedByType: string;
  changedFields: string[];
  changes?: { [key: string]: any } | undefined;
}

export interface DocumentDeleted {
  deletedBy: string;
  deletedByType: string;
  versionsDeleted: number;
  deletionReason: string;
}

export interface DocumentAccessed {
  accessedBy: string;
  accessedByType: string;
  /** "get", "list", "search" */
  accessMethod: string;
  bodyIncluded: boolean;
}

export interface DocumentTagged {
  tag: string;
  taggedBy: string;
  taggedByType: string;
  /** "add", "remove", "update" */
  tagOperation: string;
}

export interface DocumentVersioned {
  newVersion: number;
  previousVersion: number;
  versionReason: string;
}

export interface LLMEvent {
  interactionId: string;
  modelName: string;
  provider: string;
  eventType: LLMEventType;
  promptSent?: LLMPromptSent | undefined;
  responseReceived?: LLMResponseReceived | undefined;
  llmError?: LLMError | undefined;
  feedback?: LLMFeedback | undefined;
  tokenUsage?: LLMTokenUsage | undefined;
}

export interface LLMPromptSent {
  promptText: string;
  promptParameters?: { [key: string]: any } | undefined;
  contextDocumentIds: string[];
  maxTokens: number;
  temperature: number;
}

export interface LLMResponseReceived {
  responseText: string;
  finishReason: string;
  responseTokens: number;
  responseTimeMs: number;
  responseMetadata?: { [key: string]: any } | undefined;
}

export interface LLMError {
  errorCode: string;
  errorMessage: string;
  /** "rate_limit", "context_length", "content_filter", etc. */
  errorType: string;
  isRetryable: boolean;
}

export interface LLMFeedback {
  /** "thumbs_up", "thumbs_down", "correction", "rating" */
  feedbackType: string;
  feedbackValue: string;
  feedbackText: string;
  providedBy: string;
}

export interface LLMTokenUsage {
  promptTokens: number;
  completionTokens: number;
  totalTokens: number;
  costUsd: number;
}

export interface AgentEvent {
  agentId: string;
  agentType: string;
  agentVersion: string;
  executionId: string;
  eventType: AgentEventType;
  started?: AgentStarted | undefined;
  stepCompleted?: AgentStepCompleted | undefined;
  completed?: AgentCompleted | undefined;
  failed?: AgentFailed | undefined;
  toolUsed?: AgentToolUsed | undefined;
}

export interface AgentStarted {
  taskDescription: string;
  initialContext?: { [key: string]: any } | undefined;
  availableTools: string[];
}

export interface AgentStepCompleted {
  stepNumber: number;
  stepType: string;
  stepDescription: string;
  stepResult?: { [key: string]: any } | undefined;
  stepDurationMs: number;
}

export interface AgentCompleted {
  completionStatus: string;
  finalResult?: { [key: string]: any } | undefined;
  totalSteps: number;
  totalDurationMs: number;
}

export interface AgentFailed {
  failureReason: string;
  errorMessage: string;
  failedAtStep: number;
  isRecoverable: boolean;
}

export interface AgentToolUsed {
  toolName: string;
  toolVersion: string;
  toolInput?: { [key: string]: any } | undefined;
  toolOutput?: { [key: string]: any } | undefined;
  toolDurationMs: number;
  toolSuccess: boolean;
}

export interface SessionEvent {
  sessionId: string;
  eventType: SessionEventType;
  started?: SessionStarted | undefined;
  ended?: SessionEnded | undefined;
  contextAccessed?: SessionContextAccessed | undefined;
  heartbeat?: SessionHeartbeat | undefined;
}

export interface SessionStarted {
  userAgent: string;
  ipAddress: string;
  sessionMetadata?: { [key: string]: any } | undefined;
}

export interface SessionEnded {
  endReason: string;
  sessionDurationMs: number;
  interactionsCount: number;
}

export interface SessionContextAccessed {
  documentTypes: string[];
  documentsReturned: number;
  accessReason: string;
}

export interface SessionHeartbeat {
  lastActivity?: Date | undefined;
  isActive: boolean;
}

export interface SystemEvent {
  component: string;
  eventType: SystemEventType;
  healthCheck?: HealthCheck | undefined;
  metric?: MetricReported | undefined;
  alert?: AlertTriggered | undefined;
  serviceStarted?: ServiceStarted | undefined;
  serviceStopped?: ServiceStopped | undefined;
}

export interface HealthCheck {
  isHealthy: boolean;
  status: string;
  healthDetails?: { [key: string]: any } | undefined;
}

export interface MetricReported {
  metricName: string;
  metricValue: number;
  metricUnit: string;
  metricTags?: { [key: string]: any } | undefined;
}

export interface AlertTriggered {
  alertName: string;
  severity: string;
  description: string;
  alertContext?: { [key: string]: any } | undefined;
}

export interface ServiceStarted {
  serviceName: string;
  serviceVersion: string;
  buildInfo: string;
}

export interface ServiceStopped {
  serviceName: string;
  stopReason: string;
  uptimeMs: number;
}

export interface WorkflowEvent {
  workflowId: string;
  workflowType: string;
  executionId: string;
  eventType: WorkflowEventType;
  triggered?: WorkflowTriggered | undefined;
  stepExecuted?: WorkflowStepExecuted | undefined;
  completed?: WorkflowCompleted | undefined;
  failed?: WorkflowFailed | undefined;
}

export interface WorkflowTriggered {
  triggerEventId: string;
  triggerType: string;
  triggerContext?: { [key: string]: any } | undefined;
}

export interface WorkflowStepExecuted {
  stepId: string;
  stepType: string;
  stepInput?: { [key: string]: any } | undefined;
  stepOutput?: { [key: string]: any } | undefined;
  stepDurationMs: number;
}

export interface WorkflowCompleted {
  finalOutput?: { [key: string]: any } | undefined;
  totalSteps: number;
  totalDurationMs: number;
}

export interface WorkflowFailed {
  failureStepId: string;
  failureReason: string;
  errorMessage: string;
}

export interface ChatEvent {
  conversationId: string;
  messageId: string;
  eventType: ChatEventType;
  conversationCreated?: ConversationCreated | undefined;
  messageSent?: MessageSent | undefined;
  messageUpdated?: MessageUpdated | undefined;
  typingStarted?: TypingStarted | undefined;
  participantJoined?: ParticipantJoined | undefined;
}

export interface ConversationCreated {
  title: string;
  createdBy: string;
  participantIds: string[];
}

export interface MessageSent {
  content: string;
  role: string;
  sentBy: string;
}

export interface MessageUpdated {
  content: string;
  updatedBy: string;
}

export interface TypingStarted {
  userId: string;
}

export interface ParticipantJoined {
  userId: string;
  invitedBy: string;
}

export interface AudioEvent {
  audioId: string;
  eventType: AudioEventType;
  ttsStarted?: TTSStarted | undefined;
  ttsCompleted?: TTSCompleted | undefined;
  sttCompleted?: STTCompleted | undefined;
}

export interface TTSStarted {
  text: string;
  voiceId: string;
}

export interface TTSCompleted {
  audioUrl: string;
  durationSeconds: number;
}

export interface STTCompleted {
  transcript: string;
  confidence: number;
}

export interface UserEvent {
  userId: string;
  eventType: UserEventType;
  userCreated?: UserCreated | undefined;
  userLoggedIn?: UserLoggedIn | undefined;
  teamMemberAdded?: TeamMemberAdded | undefined;
}

export interface UserCreated {
  email: string;
  name: string;
}

export interface UserLoggedIn {
  ipAddress: string;
  userAgent: string;
}

export interface TeamMemberAdded {
  teamId: string;
  role: string;
  addedBy: string;
}

function createBaseUniversalEvent(): UniversalEvent {
  return {
    eventId: "",
    eventType: "",
    eventVersion: "",
    eventTime: undefined,
    sequenceNumber: "0",
    sourceService: "",
    sourceVersion: "",
    traceId: "",
    correlationId: "",
    userId: "",
    sessionId: "",
    tenantId: "",
    documentEvent: undefined,
    llmEvent: undefined,
    agentEvent: undefined,
    sessionEvent: undefined,
    systemEvent: undefined,
    workflowEvent: undefined,
    chatEvent: undefined,
    audioEvent: undefined,
    userEvent: undefined,
    metadata: undefined,
    tags: [],
    routingKey: "",
    retryCount: 0,
    expiresAt: undefined,
  };
}

export const UniversalEvent = {
  encode(message: UniversalEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== "") {
      writer.uint32(10).string(message.eventId);
    }
    if (message.eventType !== "") {
      writer.uint32(18).string(message.eventType);
    }
    if (message.eventVersion !== "") {
      writer.uint32(26).string(message.eventVersion);
    }
    if (message.eventTime !== undefined) {
      Timestamp.encode(toTimestamp(message.eventTime), writer.uint32(34).fork()).ldelim();
    }
    if (message.sequenceNumber !== "0") {
      writer.uint32(40).int64(message.sequenceNumber);
    }
    if (message.sourceService !== "") {
      writer.uint32(50).string(message.sourceService);
    }
    if (message.sourceVersion !== "") {
      writer.uint32(58).string(message.sourceVersion);
    }
    if (message.traceId !== "") {
      writer.uint32(66).string(message.traceId);
    }
    if (message.correlationId !== "") {
      writer.uint32(74).string(message.correlationId);
    }
    if (message.userId !== "") {
      writer.uint32(82).string(message.userId);
    }
    if (message.sessionId !== "") {
      writer.uint32(90).string(message.sessionId);
    }
    if (message.tenantId !== "") {
      writer.uint32(98).string(message.tenantId);
    }
    if (message.documentEvent !== undefined) {
      DocumentEvent.encode(message.documentEvent, writer.uint32(162).fork()).ldelim();
    }
    if (message.llmEvent !== undefined) {
      LLMEvent.encode(message.llmEvent, writer.uint32(170).fork()).ldelim();
    }
    if (message.agentEvent !== undefined) {
      AgentEvent.encode(message.agentEvent, writer.uint32(178).fork()).ldelim();
    }
    if (message.sessionEvent !== undefined) {
      SessionEvent.encode(message.sessionEvent, writer.uint32(186).fork()).ldelim();
    }
    if (message.systemEvent !== undefined) {
      SystemEvent.encode(message.systemEvent, writer.uint32(194).fork()).ldelim();
    }
    if (message.workflowEvent !== undefined) {
      WorkflowEvent.encode(message.workflowEvent, writer.uint32(202).fork()).ldelim();
    }
    if (message.chatEvent !== undefined) {
      ChatEvent.encode(message.chatEvent, writer.uint32(210).fork()).ldelim();
    }
    if (message.audioEvent !== undefined) {
      AudioEvent.encode(message.audioEvent, writer.uint32(218).fork()).ldelim();
    }
    if (message.userEvent !== undefined) {
      UserEvent.encode(message.userEvent, writer.uint32(226).fork()).ldelim();
    }
    if (message.metadata !== undefined) {
      Struct.encode(Struct.wrap(message.metadata), writer.uint32(242).fork()).ldelim();
    }
    for (const v of message.tags) {
      writer.uint32(250).string(v!);
    }
    if (message.routingKey !== "") {
      writer.uint32(258).string(message.routingKey);
    }
    if (message.retryCount !== 0) {
      writer.uint32(264).int32(message.retryCount);
    }
    if (message.expiresAt !== undefined) {
      Timestamp.encode(toTimestamp(message.expiresAt), writer.uint32(274).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UniversalEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUniversalEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.eventId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.eventType = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.eventVersion = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.eventTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.sequenceNumber = longToString(reader.int64() as Long);
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.sourceService = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.sourceVersion = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.traceId = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.correlationId = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.tenantId = reader.string();
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.documentEvent = DocumentEvent.decode(reader, reader.uint32());
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.llmEvent = LLMEvent.decode(reader, reader.uint32());
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.agentEvent = AgentEvent.decode(reader, reader.uint32());
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.sessionEvent = SessionEvent.decode(reader, reader.uint32());
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.systemEvent = SystemEvent.decode(reader, reader.uint32());
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.workflowEvent = WorkflowEvent.decode(reader, reader.uint32());
          continue;
        case 26:
          if (tag !== 210) {
            break;
          }

          message.chatEvent = ChatEvent.decode(reader, reader.uint32());
          continue;
        case 27:
          if (tag !== 218) {
            break;
          }

          message.audioEvent = AudioEvent.decode(reader, reader.uint32());
          continue;
        case 28:
          if (tag !== 226) {
            break;
          }

          message.userEvent = UserEvent.decode(reader, reader.uint32());
          continue;
        case 30:
          if (tag !== 242) {
            break;
          }

          message.metadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 31:
          if (tag !== 250) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        case 32:
          if (tag !== 258) {
            break;
          }

          message.routingKey = reader.string();
          continue;
        case 33:
          if (tag !== 264) {
            break;
          }

          message.retryCount = reader.int32();
          continue;
        case 34:
          if (tag !== 274) {
            break;
          }

          message.expiresAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UniversalEvent {
    return {
      eventId: isSet(object.eventId) ? globalThis.String(object.eventId) : "",
      eventType: isSet(object.eventType) ? globalThis.String(object.eventType) : "",
      eventVersion: isSet(object.eventVersion) ? globalThis.String(object.eventVersion) : "",
      eventTime: isSet(object.eventTime) ? fromJsonTimestamp(object.eventTime) : undefined,
      sequenceNumber: isSet(object.sequenceNumber) ? globalThis.String(object.sequenceNumber) : "0",
      sourceService: isSet(object.sourceService) ? globalThis.String(object.sourceService) : "",
      sourceVersion: isSet(object.sourceVersion) ? globalThis.String(object.sourceVersion) : "",
      traceId: isSet(object.traceId) ? globalThis.String(object.traceId) : "",
      correlationId: isSet(object.correlationId) ? globalThis.String(object.correlationId) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      tenantId: isSet(object.tenantId) ? globalThis.String(object.tenantId) : "",
      documentEvent: isSet(object.documentEvent) ? DocumentEvent.fromJSON(object.documentEvent) : undefined,
      llmEvent: isSet(object.llmEvent) ? LLMEvent.fromJSON(object.llmEvent) : undefined,
      agentEvent: isSet(object.agentEvent) ? AgentEvent.fromJSON(object.agentEvent) : undefined,
      sessionEvent: isSet(object.sessionEvent) ? SessionEvent.fromJSON(object.sessionEvent) : undefined,
      systemEvent: isSet(object.systemEvent) ? SystemEvent.fromJSON(object.systemEvent) : undefined,
      workflowEvent: isSet(object.workflowEvent) ? WorkflowEvent.fromJSON(object.workflowEvent) : undefined,
      chatEvent: isSet(object.chatEvent) ? ChatEvent.fromJSON(object.chatEvent) : undefined,
      audioEvent: isSet(object.audioEvent) ? AudioEvent.fromJSON(object.audioEvent) : undefined,
      userEvent: isSet(object.userEvent) ? UserEvent.fromJSON(object.userEvent) : undefined,
      metadata: isObject(object.metadata) ? object.metadata : undefined,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      routingKey: isSet(object.routingKey) ? globalThis.String(object.routingKey) : "",
      retryCount: isSet(object.retryCount) ? globalThis.Number(object.retryCount) : 0,
      expiresAt: isSet(object.expiresAt) ? fromJsonTimestamp(object.expiresAt) : undefined,
    };
  },

  toJSON(message: UniversalEvent): unknown {
    const obj: any = {};
    if (message.eventId !== "") {
      obj.eventId = message.eventId;
    }
    if (message.eventType !== "") {
      obj.eventType = message.eventType;
    }
    if (message.eventVersion !== "") {
      obj.eventVersion = message.eventVersion;
    }
    if (message.eventTime !== undefined) {
      obj.eventTime = message.eventTime.toISOString();
    }
    if (message.sequenceNumber !== "0") {
      obj.sequenceNumber = message.sequenceNumber;
    }
    if (message.sourceService !== "") {
      obj.sourceService = message.sourceService;
    }
    if (message.sourceVersion !== "") {
      obj.sourceVersion = message.sourceVersion;
    }
    if (message.traceId !== "") {
      obj.traceId = message.traceId;
    }
    if (message.correlationId !== "") {
      obj.correlationId = message.correlationId;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.tenantId !== "") {
      obj.tenantId = message.tenantId;
    }
    if (message.documentEvent !== undefined) {
      obj.documentEvent = DocumentEvent.toJSON(message.documentEvent);
    }
    if (message.llmEvent !== undefined) {
      obj.llmEvent = LLMEvent.toJSON(message.llmEvent);
    }
    if (message.agentEvent !== undefined) {
      obj.agentEvent = AgentEvent.toJSON(message.agentEvent);
    }
    if (message.sessionEvent !== undefined) {
      obj.sessionEvent = SessionEvent.toJSON(message.sessionEvent);
    }
    if (message.systemEvent !== undefined) {
      obj.systemEvent = SystemEvent.toJSON(message.systemEvent);
    }
    if (message.workflowEvent !== undefined) {
      obj.workflowEvent = WorkflowEvent.toJSON(message.workflowEvent);
    }
    if (message.chatEvent !== undefined) {
      obj.chatEvent = ChatEvent.toJSON(message.chatEvent);
    }
    if (message.audioEvent !== undefined) {
      obj.audioEvent = AudioEvent.toJSON(message.audioEvent);
    }
    if (message.userEvent !== undefined) {
      obj.userEvent = UserEvent.toJSON(message.userEvent);
    }
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.routingKey !== "") {
      obj.routingKey = message.routingKey;
    }
    if (message.retryCount !== 0) {
      obj.retryCount = Math.round(message.retryCount);
    }
    if (message.expiresAt !== undefined) {
      obj.expiresAt = message.expiresAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UniversalEvent>, I>>(base?: I): UniversalEvent {
    return UniversalEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UniversalEvent>, I>>(object: I): UniversalEvent {
    const message = createBaseUniversalEvent();
    message.eventId = object.eventId ?? "";
    message.eventType = object.eventType ?? "";
    message.eventVersion = object.eventVersion ?? "";
    message.eventTime = object.eventTime ?? undefined;
    message.sequenceNumber = object.sequenceNumber ?? "0";
    message.sourceService = object.sourceService ?? "";
    message.sourceVersion = object.sourceVersion ?? "";
    message.traceId = object.traceId ?? "";
    message.correlationId = object.correlationId ?? "";
    message.userId = object.userId ?? "";
    message.sessionId = object.sessionId ?? "";
    message.tenantId = object.tenantId ?? "";
    message.documentEvent = (object.documentEvent !== undefined && object.documentEvent !== null)
      ? DocumentEvent.fromPartial(object.documentEvent)
      : undefined;
    message.llmEvent = (object.llmEvent !== undefined && object.llmEvent !== null)
      ? LLMEvent.fromPartial(object.llmEvent)
      : undefined;
    message.agentEvent = (object.agentEvent !== undefined && object.agentEvent !== null)
      ? AgentEvent.fromPartial(object.agentEvent)
      : undefined;
    message.sessionEvent = (object.sessionEvent !== undefined && object.sessionEvent !== null)
      ? SessionEvent.fromPartial(object.sessionEvent)
      : undefined;
    message.systemEvent = (object.systemEvent !== undefined && object.systemEvent !== null)
      ? SystemEvent.fromPartial(object.systemEvent)
      : undefined;
    message.workflowEvent = (object.workflowEvent !== undefined && object.workflowEvent !== null)
      ? WorkflowEvent.fromPartial(object.workflowEvent)
      : undefined;
    message.chatEvent = (object.chatEvent !== undefined && object.chatEvent !== null)
      ? ChatEvent.fromPartial(object.chatEvent)
      : undefined;
    message.audioEvent = (object.audioEvent !== undefined && object.audioEvent !== null)
      ? AudioEvent.fromPartial(object.audioEvent)
      : undefined;
    message.userEvent = (object.userEvent !== undefined && object.userEvent !== null)
      ? UserEvent.fromPartial(object.userEvent)
      : undefined;
    message.metadata = object.metadata ?? undefined;
    message.tags = object.tags?.map((e) => e) || [];
    message.routingKey = object.routingKey ?? "";
    message.retryCount = object.retryCount ?? 0;
    message.expiresAt = object.expiresAt ?? undefined;
    return message;
  },
};

function createBaseDocumentEvent(): DocumentEvent {
  return {
    documentUuid: "",
    documentType: "",
    namespace: "",
    version: 0,
    eventType: 0,
    created: undefined,
    updated: undefined,
    deleted: undefined,
    accessed: undefined,
    tagged: undefined,
    versioned: undefined,
  };
}

export const DocumentEvent = {
  encode(message: DocumentEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.documentUuid !== "") {
      writer.uint32(10).string(message.documentUuid);
    }
    if (message.documentType !== "") {
      writer.uint32(18).string(message.documentType);
    }
    if (message.namespace !== "") {
      writer.uint32(26).string(message.namespace);
    }
    if (message.version !== 0) {
      writer.uint32(32).int32(message.version);
    }
    if (message.eventType !== 0) {
      writer.uint32(40).int32(message.eventType);
    }
    if (message.created !== undefined) {
      DocumentCreated.encode(message.created, writer.uint32(82).fork()).ldelim();
    }
    if (message.updated !== undefined) {
      DocumentUpdated.encode(message.updated, writer.uint32(90).fork()).ldelim();
    }
    if (message.deleted !== undefined) {
      DocumentDeleted.encode(message.deleted, writer.uint32(98).fork()).ldelim();
    }
    if (message.accessed !== undefined) {
      DocumentAccessed.encode(message.accessed, writer.uint32(106).fork()).ldelim();
    }
    if (message.tagged !== undefined) {
      DocumentTagged.encode(message.tagged, writer.uint32(114).fork()).ldelim();
    }
    if (message.versioned !== undefined) {
      DocumentVersioned.encode(message.versioned, writer.uint32(122).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DocumentEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocumentEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.documentUuid = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.documentType = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.namespace = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.version = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.eventType = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.created = DocumentCreated.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.updated = DocumentUpdated.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.deleted = DocumentDeleted.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.accessed = DocumentAccessed.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.tagged = DocumentTagged.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.versioned = DocumentVersioned.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DocumentEvent {
    return {
      documentUuid: isSet(object.documentUuid) ? globalThis.String(object.documentUuid) : "",
      documentType: isSet(object.documentType) ? globalThis.String(object.documentType) : "",
      namespace: isSet(object.namespace) ? globalThis.String(object.namespace) : "",
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      eventType: isSet(object.eventType) ? documentEventTypeFromJSON(object.eventType) : 0,
      created: isSet(object.created) ? DocumentCreated.fromJSON(object.created) : undefined,
      updated: isSet(object.updated) ? DocumentUpdated.fromJSON(object.updated) : undefined,
      deleted: isSet(object.deleted) ? DocumentDeleted.fromJSON(object.deleted) : undefined,
      accessed: isSet(object.accessed) ? DocumentAccessed.fromJSON(object.accessed) : undefined,
      tagged: isSet(object.tagged) ? DocumentTagged.fromJSON(object.tagged) : undefined,
      versioned: isSet(object.versioned) ? DocumentVersioned.fromJSON(object.versioned) : undefined,
    };
  },

  toJSON(message: DocumentEvent): unknown {
    const obj: any = {};
    if (message.documentUuid !== "") {
      obj.documentUuid = message.documentUuid;
    }
    if (message.documentType !== "") {
      obj.documentType = message.documentType;
    }
    if (message.namespace !== "") {
      obj.namespace = message.namespace;
    }
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.eventType !== 0) {
      obj.eventType = documentEventTypeToJSON(message.eventType);
    }
    if (message.created !== undefined) {
      obj.created = DocumentCreated.toJSON(message.created);
    }
    if (message.updated !== undefined) {
      obj.updated = DocumentUpdated.toJSON(message.updated);
    }
    if (message.deleted !== undefined) {
      obj.deleted = DocumentDeleted.toJSON(message.deleted);
    }
    if (message.accessed !== undefined) {
      obj.accessed = DocumentAccessed.toJSON(message.accessed);
    }
    if (message.tagged !== undefined) {
      obj.tagged = DocumentTagged.toJSON(message.tagged);
    }
    if (message.versioned !== undefined) {
      obj.versioned = DocumentVersioned.toJSON(message.versioned);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DocumentEvent>, I>>(base?: I): DocumentEvent {
    return DocumentEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DocumentEvent>, I>>(object: I): DocumentEvent {
    const message = createBaseDocumentEvent();
    message.documentUuid = object.documentUuid ?? "";
    message.documentType = object.documentType ?? "";
    message.namespace = object.namespace ?? "";
    message.version = object.version ?? 0;
    message.eventType = object.eventType ?? 0;
    message.created = (object.created !== undefined && object.created !== null)
      ? DocumentCreated.fromPartial(object.created)
      : undefined;
    message.updated = (object.updated !== undefined && object.updated !== null)
      ? DocumentUpdated.fromPartial(object.updated)
      : undefined;
    message.deleted = (object.deleted !== undefined && object.deleted !== null)
      ? DocumentDeleted.fromPartial(object.deleted)
      : undefined;
    message.accessed = (object.accessed !== undefined && object.accessed !== null)
      ? DocumentAccessed.fromPartial(object.accessed)
      : undefined;
    message.tagged = (object.tagged !== undefined && object.tagged !== null)
      ? DocumentTagged.fromPartial(object.tagged)
      : undefined;
    message.versioned = (object.versioned !== undefined && object.versioned !== null)
      ? DocumentVersioned.fromPartial(object.versioned)
      : undefined;
    return message;
  },
};

function createBaseDocumentCreated(): DocumentCreated {
  return { documentName: "", createdBy: "", createdByType: "", documentMetadata: undefined, documentSizeBytes: "0" };
}

export const DocumentCreated = {
  encode(message: DocumentCreated, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.documentName !== "") {
      writer.uint32(10).string(message.documentName);
    }
    if (message.createdBy !== "") {
      writer.uint32(18).string(message.createdBy);
    }
    if (message.createdByType !== "") {
      writer.uint32(26).string(message.createdByType);
    }
    if (message.documentMetadata !== undefined) {
      Struct.encode(Struct.wrap(message.documentMetadata), writer.uint32(34).fork()).ldelim();
    }
    if (message.documentSizeBytes !== "0") {
      writer.uint32(40).int64(message.documentSizeBytes);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DocumentCreated {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocumentCreated();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.documentName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createdBy = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.createdByType = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.documentMetadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.documentSizeBytes = longToString(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DocumentCreated {
    return {
      documentName: isSet(object.documentName) ? globalThis.String(object.documentName) : "",
      createdBy: isSet(object.createdBy) ? globalThis.String(object.createdBy) : "",
      createdByType: isSet(object.createdByType) ? globalThis.String(object.createdByType) : "",
      documentMetadata: isObject(object.documentMetadata) ? object.documentMetadata : undefined,
      documentSizeBytes: isSet(object.documentSizeBytes) ? globalThis.String(object.documentSizeBytes) : "0",
    };
  },

  toJSON(message: DocumentCreated): unknown {
    const obj: any = {};
    if (message.documentName !== "") {
      obj.documentName = message.documentName;
    }
    if (message.createdBy !== "") {
      obj.createdBy = message.createdBy;
    }
    if (message.createdByType !== "") {
      obj.createdByType = message.createdByType;
    }
    if (message.documentMetadata !== undefined) {
      obj.documentMetadata = message.documentMetadata;
    }
    if (message.documentSizeBytes !== "0") {
      obj.documentSizeBytes = message.documentSizeBytes;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DocumentCreated>, I>>(base?: I): DocumentCreated {
    return DocumentCreated.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DocumentCreated>, I>>(object: I): DocumentCreated {
    const message = createBaseDocumentCreated();
    message.documentName = object.documentName ?? "";
    message.createdBy = object.createdBy ?? "";
    message.createdByType = object.createdByType ?? "";
    message.documentMetadata = object.documentMetadata ?? undefined;
    message.documentSizeBytes = object.documentSizeBytes ?? "0";
    return message;
  },
};

function createBaseDocumentUpdated(): DocumentUpdated {
  return { previousVersion: 0, updatedBy: "", updatedByType: "", changedFields: [], changes: undefined };
}

export const DocumentUpdated = {
  encode(message: DocumentUpdated, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.previousVersion !== 0) {
      writer.uint32(8).int32(message.previousVersion);
    }
    if (message.updatedBy !== "") {
      writer.uint32(18).string(message.updatedBy);
    }
    if (message.updatedByType !== "") {
      writer.uint32(26).string(message.updatedByType);
    }
    for (const v of message.changedFields) {
      writer.uint32(34).string(v!);
    }
    if (message.changes !== undefined) {
      Struct.encode(Struct.wrap(message.changes), writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DocumentUpdated {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocumentUpdated();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.previousVersion = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updatedBy = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updatedByType = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.changedFields.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.changes = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DocumentUpdated {
    return {
      previousVersion: isSet(object.previousVersion) ? globalThis.Number(object.previousVersion) : 0,
      updatedBy: isSet(object.updatedBy) ? globalThis.String(object.updatedBy) : "",
      updatedByType: isSet(object.updatedByType) ? globalThis.String(object.updatedByType) : "",
      changedFields: globalThis.Array.isArray(object?.changedFields)
        ? object.changedFields.map((e: any) => globalThis.String(e))
        : [],
      changes: isObject(object.changes) ? object.changes : undefined,
    };
  },

  toJSON(message: DocumentUpdated): unknown {
    const obj: any = {};
    if (message.previousVersion !== 0) {
      obj.previousVersion = Math.round(message.previousVersion);
    }
    if (message.updatedBy !== "") {
      obj.updatedBy = message.updatedBy;
    }
    if (message.updatedByType !== "") {
      obj.updatedByType = message.updatedByType;
    }
    if (message.changedFields?.length) {
      obj.changedFields = message.changedFields;
    }
    if (message.changes !== undefined) {
      obj.changes = message.changes;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DocumentUpdated>, I>>(base?: I): DocumentUpdated {
    return DocumentUpdated.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DocumentUpdated>, I>>(object: I): DocumentUpdated {
    const message = createBaseDocumentUpdated();
    message.previousVersion = object.previousVersion ?? 0;
    message.updatedBy = object.updatedBy ?? "";
    message.updatedByType = object.updatedByType ?? "";
    message.changedFields = object.changedFields?.map((e) => e) || [];
    message.changes = object.changes ?? undefined;
    return message;
  },
};

function createBaseDocumentDeleted(): DocumentDeleted {
  return { deletedBy: "", deletedByType: "", versionsDeleted: 0, deletionReason: "" };
}

export const DocumentDeleted = {
  encode(message: DocumentDeleted, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.deletedBy !== "") {
      writer.uint32(10).string(message.deletedBy);
    }
    if (message.deletedByType !== "") {
      writer.uint32(18).string(message.deletedByType);
    }
    if (message.versionsDeleted !== 0) {
      writer.uint32(24).int32(message.versionsDeleted);
    }
    if (message.deletionReason !== "") {
      writer.uint32(34).string(message.deletionReason);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DocumentDeleted {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocumentDeleted();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.deletedBy = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.deletedByType = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.versionsDeleted = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.deletionReason = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DocumentDeleted {
    return {
      deletedBy: isSet(object.deletedBy) ? globalThis.String(object.deletedBy) : "",
      deletedByType: isSet(object.deletedByType) ? globalThis.String(object.deletedByType) : "",
      versionsDeleted: isSet(object.versionsDeleted) ? globalThis.Number(object.versionsDeleted) : 0,
      deletionReason: isSet(object.deletionReason) ? globalThis.String(object.deletionReason) : "",
    };
  },

  toJSON(message: DocumentDeleted): unknown {
    const obj: any = {};
    if (message.deletedBy !== "") {
      obj.deletedBy = message.deletedBy;
    }
    if (message.deletedByType !== "") {
      obj.deletedByType = message.deletedByType;
    }
    if (message.versionsDeleted !== 0) {
      obj.versionsDeleted = Math.round(message.versionsDeleted);
    }
    if (message.deletionReason !== "") {
      obj.deletionReason = message.deletionReason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DocumentDeleted>, I>>(base?: I): DocumentDeleted {
    return DocumentDeleted.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DocumentDeleted>, I>>(object: I): DocumentDeleted {
    const message = createBaseDocumentDeleted();
    message.deletedBy = object.deletedBy ?? "";
    message.deletedByType = object.deletedByType ?? "";
    message.versionsDeleted = object.versionsDeleted ?? 0;
    message.deletionReason = object.deletionReason ?? "";
    return message;
  },
};

function createBaseDocumentAccessed(): DocumentAccessed {
  return { accessedBy: "", accessedByType: "", accessMethod: "", bodyIncluded: false };
}

export const DocumentAccessed = {
  encode(message: DocumentAccessed, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accessedBy !== "") {
      writer.uint32(10).string(message.accessedBy);
    }
    if (message.accessedByType !== "") {
      writer.uint32(18).string(message.accessedByType);
    }
    if (message.accessMethod !== "") {
      writer.uint32(26).string(message.accessMethod);
    }
    if (message.bodyIncluded !== false) {
      writer.uint32(32).bool(message.bodyIncluded);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DocumentAccessed {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocumentAccessed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accessedBy = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.accessedByType = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.accessMethod = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.bodyIncluded = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DocumentAccessed {
    return {
      accessedBy: isSet(object.accessedBy) ? globalThis.String(object.accessedBy) : "",
      accessedByType: isSet(object.accessedByType) ? globalThis.String(object.accessedByType) : "",
      accessMethod: isSet(object.accessMethod) ? globalThis.String(object.accessMethod) : "",
      bodyIncluded: isSet(object.bodyIncluded) ? globalThis.Boolean(object.bodyIncluded) : false,
    };
  },

  toJSON(message: DocumentAccessed): unknown {
    const obj: any = {};
    if (message.accessedBy !== "") {
      obj.accessedBy = message.accessedBy;
    }
    if (message.accessedByType !== "") {
      obj.accessedByType = message.accessedByType;
    }
    if (message.accessMethod !== "") {
      obj.accessMethod = message.accessMethod;
    }
    if (message.bodyIncluded !== false) {
      obj.bodyIncluded = message.bodyIncluded;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DocumentAccessed>, I>>(base?: I): DocumentAccessed {
    return DocumentAccessed.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DocumentAccessed>, I>>(object: I): DocumentAccessed {
    const message = createBaseDocumentAccessed();
    message.accessedBy = object.accessedBy ?? "";
    message.accessedByType = object.accessedByType ?? "";
    message.accessMethod = object.accessMethod ?? "";
    message.bodyIncluded = object.bodyIncluded ?? false;
    return message;
  },
};

function createBaseDocumentTagged(): DocumentTagged {
  return { tag: "", taggedBy: "", taggedByType: "", tagOperation: "" };
}

export const DocumentTagged = {
  encode(message: DocumentTagged, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tag !== "") {
      writer.uint32(10).string(message.tag);
    }
    if (message.taggedBy !== "") {
      writer.uint32(18).string(message.taggedBy);
    }
    if (message.taggedByType !== "") {
      writer.uint32(26).string(message.taggedByType);
    }
    if (message.tagOperation !== "") {
      writer.uint32(34).string(message.tagOperation);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DocumentTagged {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocumentTagged();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tag = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.taggedBy = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.taggedByType = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.tagOperation = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DocumentTagged {
    return {
      tag: isSet(object.tag) ? globalThis.String(object.tag) : "",
      taggedBy: isSet(object.taggedBy) ? globalThis.String(object.taggedBy) : "",
      taggedByType: isSet(object.taggedByType) ? globalThis.String(object.taggedByType) : "",
      tagOperation: isSet(object.tagOperation) ? globalThis.String(object.tagOperation) : "",
    };
  },

  toJSON(message: DocumentTagged): unknown {
    const obj: any = {};
    if (message.tag !== "") {
      obj.tag = message.tag;
    }
    if (message.taggedBy !== "") {
      obj.taggedBy = message.taggedBy;
    }
    if (message.taggedByType !== "") {
      obj.taggedByType = message.taggedByType;
    }
    if (message.tagOperation !== "") {
      obj.tagOperation = message.tagOperation;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DocumentTagged>, I>>(base?: I): DocumentTagged {
    return DocumentTagged.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DocumentTagged>, I>>(object: I): DocumentTagged {
    const message = createBaseDocumentTagged();
    message.tag = object.tag ?? "";
    message.taggedBy = object.taggedBy ?? "";
    message.taggedByType = object.taggedByType ?? "";
    message.tagOperation = object.tagOperation ?? "";
    return message;
  },
};

function createBaseDocumentVersioned(): DocumentVersioned {
  return { newVersion: 0, previousVersion: 0, versionReason: "" };
}

export const DocumentVersioned = {
  encode(message: DocumentVersioned, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.newVersion !== 0) {
      writer.uint32(8).int32(message.newVersion);
    }
    if (message.previousVersion !== 0) {
      writer.uint32(16).int32(message.previousVersion);
    }
    if (message.versionReason !== "") {
      writer.uint32(26).string(message.versionReason);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DocumentVersioned {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocumentVersioned();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.newVersion = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.previousVersion = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.versionReason = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DocumentVersioned {
    return {
      newVersion: isSet(object.newVersion) ? globalThis.Number(object.newVersion) : 0,
      previousVersion: isSet(object.previousVersion) ? globalThis.Number(object.previousVersion) : 0,
      versionReason: isSet(object.versionReason) ? globalThis.String(object.versionReason) : "",
    };
  },

  toJSON(message: DocumentVersioned): unknown {
    const obj: any = {};
    if (message.newVersion !== 0) {
      obj.newVersion = Math.round(message.newVersion);
    }
    if (message.previousVersion !== 0) {
      obj.previousVersion = Math.round(message.previousVersion);
    }
    if (message.versionReason !== "") {
      obj.versionReason = message.versionReason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DocumentVersioned>, I>>(base?: I): DocumentVersioned {
    return DocumentVersioned.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DocumentVersioned>, I>>(object: I): DocumentVersioned {
    const message = createBaseDocumentVersioned();
    message.newVersion = object.newVersion ?? 0;
    message.previousVersion = object.previousVersion ?? 0;
    message.versionReason = object.versionReason ?? "";
    return message;
  },
};

function createBaseLLMEvent(): LLMEvent {
  return {
    interactionId: "",
    modelName: "",
    provider: "",
    eventType: 0,
    promptSent: undefined,
    responseReceived: undefined,
    llmError: undefined,
    feedback: undefined,
    tokenUsage: undefined,
  };
}

export const LLMEvent = {
  encode(message: LLMEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.interactionId !== "") {
      writer.uint32(10).string(message.interactionId);
    }
    if (message.modelName !== "") {
      writer.uint32(18).string(message.modelName);
    }
    if (message.provider !== "") {
      writer.uint32(26).string(message.provider);
    }
    if (message.eventType !== 0) {
      writer.uint32(32).int32(message.eventType);
    }
    if (message.promptSent !== undefined) {
      LLMPromptSent.encode(message.promptSent, writer.uint32(82).fork()).ldelim();
    }
    if (message.responseReceived !== undefined) {
      LLMResponseReceived.encode(message.responseReceived, writer.uint32(90).fork()).ldelim();
    }
    if (message.llmError !== undefined) {
      LLMError.encode(message.llmError, writer.uint32(98).fork()).ldelim();
    }
    if (message.feedback !== undefined) {
      LLMFeedback.encode(message.feedback, writer.uint32(106).fork()).ldelim();
    }
    if (message.tokenUsage !== undefined) {
      LLMTokenUsage.encode(message.tokenUsage, writer.uint32(114).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LLMEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLLMEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.interactionId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.modelName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.provider = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.eventType = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.promptSent = LLMPromptSent.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.responseReceived = LLMResponseReceived.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.llmError = LLMError.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.feedback = LLMFeedback.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.tokenUsage = LLMTokenUsage.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LLMEvent {
    return {
      interactionId: isSet(object.interactionId) ? globalThis.String(object.interactionId) : "",
      modelName: isSet(object.modelName) ? globalThis.String(object.modelName) : "",
      provider: isSet(object.provider) ? globalThis.String(object.provider) : "",
      eventType: isSet(object.eventType) ? lLMEventTypeFromJSON(object.eventType) : 0,
      promptSent: isSet(object.promptSent) ? LLMPromptSent.fromJSON(object.promptSent) : undefined,
      responseReceived: isSet(object.responseReceived)
        ? LLMResponseReceived.fromJSON(object.responseReceived)
        : undefined,
      llmError: isSet(object.llmError) ? LLMError.fromJSON(object.llmError) : undefined,
      feedback: isSet(object.feedback) ? LLMFeedback.fromJSON(object.feedback) : undefined,
      tokenUsage: isSet(object.tokenUsage) ? LLMTokenUsage.fromJSON(object.tokenUsage) : undefined,
    };
  },

  toJSON(message: LLMEvent): unknown {
    const obj: any = {};
    if (message.interactionId !== "") {
      obj.interactionId = message.interactionId;
    }
    if (message.modelName !== "") {
      obj.modelName = message.modelName;
    }
    if (message.provider !== "") {
      obj.provider = message.provider;
    }
    if (message.eventType !== 0) {
      obj.eventType = lLMEventTypeToJSON(message.eventType);
    }
    if (message.promptSent !== undefined) {
      obj.promptSent = LLMPromptSent.toJSON(message.promptSent);
    }
    if (message.responseReceived !== undefined) {
      obj.responseReceived = LLMResponseReceived.toJSON(message.responseReceived);
    }
    if (message.llmError !== undefined) {
      obj.llmError = LLMError.toJSON(message.llmError);
    }
    if (message.feedback !== undefined) {
      obj.feedback = LLMFeedback.toJSON(message.feedback);
    }
    if (message.tokenUsage !== undefined) {
      obj.tokenUsage = LLMTokenUsage.toJSON(message.tokenUsage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LLMEvent>, I>>(base?: I): LLMEvent {
    return LLMEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LLMEvent>, I>>(object: I): LLMEvent {
    const message = createBaseLLMEvent();
    message.interactionId = object.interactionId ?? "";
    message.modelName = object.modelName ?? "";
    message.provider = object.provider ?? "";
    message.eventType = object.eventType ?? 0;
    message.promptSent = (object.promptSent !== undefined && object.promptSent !== null)
      ? LLMPromptSent.fromPartial(object.promptSent)
      : undefined;
    message.responseReceived = (object.responseReceived !== undefined && object.responseReceived !== null)
      ? LLMResponseReceived.fromPartial(object.responseReceived)
      : undefined;
    message.llmError = (object.llmError !== undefined && object.llmError !== null)
      ? LLMError.fromPartial(object.llmError)
      : undefined;
    message.feedback = (object.feedback !== undefined && object.feedback !== null)
      ? LLMFeedback.fromPartial(object.feedback)
      : undefined;
    message.tokenUsage = (object.tokenUsage !== undefined && object.tokenUsage !== null)
      ? LLMTokenUsage.fromPartial(object.tokenUsage)
      : undefined;
    return message;
  },
};

function createBaseLLMPromptSent(): LLMPromptSent {
  return { promptText: "", promptParameters: undefined, contextDocumentIds: [], maxTokens: 0, temperature: 0 };
}

export const LLMPromptSent = {
  encode(message: LLMPromptSent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.promptText !== "") {
      writer.uint32(10).string(message.promptText);
    }
    if (message.promptParameters !== undefined) {
      Struct.encode(Struct.wrap(message.promptParameters), writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.contextDocumentIds) {
      writer.uint32(26).string(v!);
    }
    if (message.maxTokens !== 0) {
      writer.uint32(32).int32(message.maxTokens);
    }
    if (message.temperature !== 0) {
      writer.uint32(45).float(message.temperature);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LLMPromptSent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLLMPromptSent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.promptText = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.promptParameters = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.contextDocumentIds.push(reader.string());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.maxTokens = reader.int32();
          continue;
        case 5:
          if (tag !== 45) {
            break;
          }

          message.temperature = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LLMPromptSent {
    return {
      promptText: isSet(object.promptText) ? globalThis.String(object.promptText) : "",
      promptParameters: isObject(object.promptParameters) ? object.promptParameters : undefined,
      contextDocumentIds: globalThis.Array.isArray(object?.contextDocumentIds)
        ? object.contextDocumentIds.map((e: any) => globalThis.String(e))
        : [],
      maxTokens: isSet(object.maxTokens) ? globalThis.Number(object.maxTokens) : 0,
      temperature: isSet(object.temperature) ? globalThis.Number(object.temperature) : 0,
    };
  },

  toJSON(message: LLMPromptSent): unknown {
    const obj: any = {};
    if (message.promptText !== "") {
      obj.promptText = message.promptText;
    }
    if (message.promptParameters !== undefined) {
      obj.promptParameters = message.promptParameters;
    }
    if (message.contextDocumentIds?.length) {
      obj.contextDocumentIds = message.contextDocumentIds;
    }
    if (message.maxTokens !== 0) {
      obj.maxTokens = Math.round(message.maxTokens);
    }
    if (message.temperature !== 0) {
      obj.temperature = message.temperature;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LLMPromptSent>, I>>(base?: I): LLMPromptSent {
    return LLMPromptSent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LLMPromptSent>, I>>(object: I): LLMPromptSent {
    const message = createBaseLLMPromptSent();
    message.promptText = object.promptText ?? "";
    message.promptParameters = object.promptParameters ?? undefined;
    message.contextDocumentIds = object.contextDocumentIds?.map((e) => e) || [];
    message.maxTokens = object.maxTokens ?? 0;
    message.temperature = object.temperature ?? 0;
    return message;
  },
};

function createBaseLLMResponseReceived(): LLMResponseReceived {
  return { responseText: "", finishReason: "", responseTokens: 0, responseTimeMs: 0, responseMetadata: undefined };
}

export const LLMResponseReceived = {
  encode(message: LLMResponseReceived, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.responseText !== "") {
      writer.uint32(10).string(message.responseText);
    }
    if (message.finishReason !== "") {
      writer.uint32(18).string(message.finishReason);
    }
    if (message.responseTokens !== 0) {
      writer.uint32(24).int32(message.responseTokens);
    }
    if (message.responseTimeMs !== 0) {
      writer.uint32(37).float(message.responseTimeMs);
    }
    if (message.responseMetadata !== undefined) {
      Struct.encode(Struct.wrap(message.responseMetadata), writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LLMResponseReceived {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLLMResponseReceived();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.responseText = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.finishReason = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.responseTokens = reader.int32();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.responseTimeMs = reader.float();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.responseMetadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LLMResponseReceived {
    return {
      responseText: isSet(object.responseText) ? globalThis.String(object.responseText) : "",
      finishReason: isSet(object.finishReason) ? globalThis.String(object.finishReason) : "",
      responseTokens: isSet(object.responseTokens) ? globalThis.Number(object.responseTokens) : 0,
      responseTimeMs: isSet(object.responseTimeMs) ? globalThis.Number(object.responseTimeMs) : 0,
      responseMetadata: isObject(object.responseMetadata) ? object.responseMetadata : undefined,
    };
  },

  toJSON(message: LLMResponseReceived): unknown {
    const obj: any = {};
    if (message.responseText !== "") {
      obj.responseText = message.responseText;
    }
    if (message.finishReason !== "") {
      obj.finishReason = message.finishReason;
    }
    if (message.responseTokens !== 0) {
      obj.responseTokens = Math.round(message.responseTokens);
    }
    if (message.responseTimeMs !== 0) {
      obj.responseTimeMs = message.responseTimeMs;
    }
    if (message.responseMetadata !== undefined) {
      obj.responseMetadata = message.responseMetadata;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LLMResponseReceived>, I>>(base?: I): LLMResponseReceived {
    return LLMResponseReceived.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LLMResponseReceived>, I>>(object: I): LLMResponseReceived {
    const message = createBaseLLMResponseReceived();
    message.responseText = object.responseText ?? "";
    message.finishReason = object.finishReason ?? "";
    message.responseTokens = object.responseTokens ?? 0;
    message.responseTimeMs = object.responseTimeMs ?? 0;
    message.responseMetadata = object.responseMetadata ?? undefined;
    return message;
  },
};

function createBaseLLMError(): LLMError {
  return { errorCode: "", errorMessage: "", errorType: "", isRetryable: false };
}

export const LLMError = {
  encode(message: LLMError, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.errorCode !== "") {
      writer.uint32(10).string(message.errorCode);
    }
    if (message.errorMessage !== "") {
      writer.uint32(18).string(message.errorMessage);
    }
    if (message.errorType !== "") {
      writer.uint32(26).string(message.errorType);
    }
    if (message.isRetryable !== false) {
      writer.uint32(32).bool(message.isRetryable);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LLMError {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLLMError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.errorCode = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.errorType = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.isRetryable = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LLMError {
    return {
      errorCode: isSet(object.errorCode) ? globalThis.String(object.errorCode) : "",
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
      errorType: isSet(object.errorType) ? globalThis.String(object.errorType) : "",
      isRetryable: isSet(object.isRetryable) ? globalThis.Boolean(object.isRetryable) : false,
    };
  },

  toJSON(message: LLMError): unknown {
    const obj: any = {};
    if (message.errorCode !== "") {
      obj.errorCode = message.errorCode;
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    if (message.errorType !== "") {
      obj.errorType = message.errorType;
    }
    if (message.isRetryable !== false) {
      obj.isRetryable = message.isRetryable;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LLMError>, I>>(base?: I): LLMError {
    return LLMError.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LLMError>, I>>(object: I): LLMError {
    const message = createBaseLLMError();
    message.errorCode = object.errorCode ?? "";
    message.errorMessage = object.errorMessage ?? "";
    message.errorType = object.errorType ?? "";
    message.isRetryable = object.isRetryable ?? false;
    return message;
  },
};

function createBaseLLMFeedback(): LLMFeedback {
  return { feedbackType: "", feedbackValue: "", feedbackText: "", providedBy: "" };
}

export const LLMFeedback = {
  encode(message: LLMFeedback, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.feedbackType !== "") {
      writer.uint32(10).string(message.feedbackType);
    }
    if (message.feedbackValue !== "") {
      writer.uint32(18).string(message.feedbackValue);
    }
    if (message.feedbackText !== "") {
      writer.uint32(26).string(message.feedbackText);
    }
    if (message.providedBy !== "") {
      writer.uint32(34).string(message.providedBy);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LLMFeedback {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLLMFeedback();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.feedbackType = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.feedbackValue = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.feedbackText = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.providedBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LLMFeedback {
    return {
      feedbackType: isSet(object.feedbackType) ? globalThis.String(object.feedbackType) : "",
      feedbackValue: isSet(object.feedbackValue) ? globalThis.String(object.feedbackValue) : "",
      feedbackText: isSet(object.feedbackText) ? globalThis.String(object.feedbackText) : "",
      providedBy: isSet(object.providedBy) ? globalThis.String(object.providedBy) : "",
    };
  },

  toJSON(message: LLMFeedback): unknown {
    const obj: any = {};
    if (message.feedbackType !== "") {
      obj.feedbackType = message.feedbackType;
    }
    if (message.feedbackValue !== "") {
      obj.feedbackValue = message.feedbackValue;
    }
    if (message.feedbackText !== "") {
      obj.feedbackText = message.feedbackText;
    }
    if (message.providedBy !== "") {
      obj.providedBy = message.providedBy;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LLMFeedback>, I>>(base?: I): LLMFeedback {
    return LLMFeedback.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LLMFeedback>, I>>(object: I): LLMFeedback {
    const message = createBaseLLMFeedback();
    message.feedbackType = object.feedbackType ?? "";
    message.feedbackValue = object.feedbackValue ?? "";
    message.feedbackText = object.feedbackText ?? "";
    message.providedBy = object.providedBy ?? "";
    return message;
  },
};

function createBaseLLMTokenUsage(): LLMTokenUsage {
  return { promptTokens: 0, completionTokens: 0, totalTokens: 0, costUsd: 0 };
}

export const LLMTokenUsage = {
  encode(message: LLMTokenUsage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.promptTokens !== 0) {
      writer.uint32(8).int32(message.promptTokens);
    }
    if (message.completionTokens !== 0) {
      writer.uint32(16).int32(message.completionTokens);
    }
    if (message.totalTokens !== 0) {
      writer.uint32(24).int32(message.totalTokens);
    }
    if (message.costUsd !== 0) {
      writer.uint32(37).float(message.costUsd);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LLMTokenUsage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLLMTokenUsage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.promptTokens = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.completionTokens = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.totalTokens = reader.int32();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.costUsd = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LLMTokenUsage {
    return {
      promptTokens: isSet(object.promptTokens) ? globalThis.Number(object.promptTokens) : 0,
      completionTokens: isSet(object.completionTokens) ? globalThis.Number(object.completionTokens) : 0,
      totalTokens: isSet(object.totalTokens) ? globalThis.Number(object.totalTokens) : 0,
      costUsd: isSet(object.costUsd) ? globalThis.Number(object.costUsd) : 0,
    };
  },

  toJSON(message: LLMTokenUsage): unknown {
    const obj: any = {};
    if (message.promptTokens !== 0) {
      obj.promptTokens = Math.round(message.promptTokens);
    }
    if (message.completionTokens !== 0) {
      obj.completionTokens = Math.round(message.completionTokens);
    }
    if (message.totalTokens !== 0) {
      obj.totalTokens = Math.round(message.totalTokens);
    }
    if (message.costUsd !== 0) {
      obj.costUsd = message.costUsd;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LLMTokenUsage>, I>>(base?: I): LLMTokenUsage {
    return LLMTokenUsage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LLMTokenUsage>, I>>(object: I): LLMTokenUsage {
    const message = createBaseLLMTokenUsage();
    message.promptTokens = object.promptTokens ?? 0;
    message.completionTokens = object.completionTokens ?? 0;
    message.totalTokens = object.totalTokens ?? 0;
    message.costUsd = object.costUsd ?? 0;
    return message;
  },
};

function createBaseAgentEvent(): AgentEvent {
  return {
    agentId: "",
    agentType: "",
    agentVersion: "",
    executionId: "",
    eventType: 0,
    started: undefined,
    stepCompleted: undefined,
    completed: undefined,
    failed: undefined,
    toolUsed: undefined,
  };
}

export const AgentEvent = {
  encode(message: AgentEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.agentId !== "") {
      writer.uint32(10).string(message.agentId);
    }
    if (message.agentType !== "") {
      writer.uint32(18).string(message.agentType);
    }
    if (message.agentVersion !== "") {
      writer.uint32(26).string(message.agentVersion);
    }
    if (message.executionId !== "") {
      writer.uint32(34).string(message.executionId);
    }
    if (message.eventType !== 0) {
      writer.uint32(40).int32(message.eventType);
    }
    if (message.started !== undefined) {
      AgentStarted.encode(message.started, writer.uint32(82).fork()).ldelim();
    }
    if (message.stepCompleted !== undefined) {
      AgentStepCompleted.encode(message.stepCompleted, writer.uint32(90).fork()).ldelim();
    }
    if (message.completed !== undefined) {
      AgentCompleted.encode(message.completed, writer.uint32(98).fork()).ldelim();
    }
    if (message.failed !== undefined) {
      AgentFailed.encode(message.failed, writer.uint32(106).fork()).ldelim();
    }
    if (message.toolUsed !== undefined) {
      AgentToolUsed.encode(message.toolUsed, writer.uint32(114).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AgentEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgentEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.agentId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.agentType = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.agentVersion = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.executionId = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.eventType = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.started = AgentStarted.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.stepCompleted = AgentStepCompleted.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.completed = AgentCompleted.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.failed = AgentFailed.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.toolUsed = AgentToolUsed.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AgentEvent {
    return {
      agentId: isSet(object.agentId) ? globalThis.String(object.agentId) : "",
      agentType: isSet(object.agentType) ? globalThis.String(object.agentType) : "",
      agentVersion: isSet(object.agentVersion) ? globalThis.String(object.agentVersion) : "",
      executionId: isSet(object.executionId) ? globalThis.String(object.executionId) : "",
      eventType: isSet(object.eventType) ? agentEventTypeFromJSON(object.eventType) : 0,
      started: isSet(object.started) ? AgentStarted.fromJSON(object.started) : undefined,
      stepCompleted: isSet(object.stepCompleted) ? AgentStepCompleted.fromJSON(object.stepCompleted) : undefined,
      completed: isSet(object.completed) ? AgentCompleted.fromJSON(object.completed) : undefined,
      failed: isSet(object.failed) ? AgentFailed.fromJSON(object.failed) : undefined,
      toolUsed: isSet(object.toolUsed) ? AgentToolUsed.fromJSON(object.toolUsed) : undefined,
    };
  },

  toJSON(message: AgentEvent): unknown {
    const obj: any = {};
    if (message.agentId !== "") {
      obj.agentId = message.agentId;
    }
    if (message.agentType !== "") {
      obj.agentType = message.agentType;
    }
    if (message.agentVersion !== "") {
      obj.agentVersion = message.agentVersion;
    }
    if (message.executionId !== "") {
      obj.executionId = message.executionId;
    }
    if (message.eventType !== 0) {
      obj.eventType = agentEventTypeToJSON(message.eventType);
    }
    if (message.started !== undefined) {
      obj.started = AgentStarted.toJSON(message.started);
    }
    if (message.stepCompleted !== undefined) {
      obj.stepCompleted = AgentStepCompleted.toJSON(message.stepCompleted);
    }
    if (message.completed !== undefined) {
      obj.completed = AgentCompleted.toJSON(message.completed);
    }
    if (message.failed !== undefined) {
      obj.failed = AgentFailed.toJSON(message.failed);
    }
    if (message.toolUsed !== undefined) {
      obj.toolUsed = AgentToolUsed.toJSON(message.toolUsed);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AgentEvent>, I>>(base?: I): AgentEvent {
    return AgentEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AgentEvent>, I>>(object: I): AgentEvent {
    const message = createBaseAgentEvent();
    message.agentId = object.agentId ?? "";
    message.agentType = object.agentType ?? "";
    message.agentVersion = object.agentVersion ?? "";
    message.executionId = object.executionId ?? "";
    message.eventType = object.eventType ?? 0;
    message.started = (object.started !== undefined && object.started !== null)
      ? AgentStarted.fromPartial(object.started)
      : undefined;
    message.stepCompleted = (object.stepCompleted !== undefined && object.stepCompleted !== null)
      ? AgentStepCompleted.fromPartial(object.stepCompleted)
      : undefined;
    message.completed = (object.completed !== undefined && object.completed !== null)
      ? AgentCompleted.fromPartial(object.completed)
      : undefined;
    message.failed = (object.failed !== undefined && object.failed !== null)
      ? AgentFailed.fromPartial(object.failed)
      : undefined;
    message.toolUsed = (object.toolUsed !== undefined && object.toolUsed !== null)
      ? AgentToolUsed.fromPartial(object.toolUsed)
      : undefined;
    return message;
  },
};

function createBaseAgentStarted(): AgentStarted {
  return { taskDescription: "", initialContext: undefined, availableTools: [] };
}

export const AgentStarted = {
  encode(message: AgentStarted, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.taskDescription !== "") {
      writer.uint32(10).string(message.taskDescription);
    }
    if (message.initialContext !== undefined) {
      Struct.encode(Struct.wrap(message.initialContext), writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.availableTools) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AgentStarted {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgentStarted();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.taskDescription = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.initialContext = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.availableTools.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AgentStarted {
    return {
      taskDescription: isSet(object.taskDescription) ? globalThis.String(object.taskDescription) : "",
      initialContext: isObject(object.initialContext) ? object.initialContext : undefined,
      availableTools: globalThis.Array.isArray(object?.availableTools)
        ? object.availableTools.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: AgentStarted): unknown {
    const obj: any = {};
    if (message.taskDescription !== "") {
      obj.taskDescription = message.taskDescription;
    }
    if (message.initialContext !== undefined) {
      obj.initialContext = message.initialContext;
    }
    if (message.availableTools?.length) {
      obj.availableTools = message.availableTools;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AgentStarted>, I>>(base?: I): AgentStarted {
    return AgentStarted.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AgentStarted>, I>>(object: I): AgentStarted {
    const message = createBaseAgentStarted();
    message.taskDescription = object.taskDescription ?? "";
    message.initialContext = object.initialContext ?? undefined;
    message.availableTools = object.availableTools?.map((e) => e) || [];
    return message;
  },
};

function createBaseAgentStepCompleted(): AgentStepCompleted {
  return { stepNumber: 0, stepType: "", stepDescription: "", stepResult: undefined, stepDurationMs: 0 };
}

export const AgentStepCompleted = {
  encode(message: AgentStepCompleted, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.stepNumber !== 0) {
      writer.uint32(8).int32(message.stepNumber);
    }
    if (message.stepType !== "") {
      writer.uint32(18).string(message.stepType);
    }
    if (message.stepDescription !== "") {
      writer.uint32(26).string(message.stepDescription);
    }
    if (message.stepResult !== undefined) {
      Struct.encode(Struct.wrap(message.stepResult), writer.uint32(34).fork()).ldelim();
    }
    if (message.stepDurationMs !== 0) {
      writer.uint32(45).float(message.stepDurationMs);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AgentStepCompleted {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgentStepCompleted();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.stepNumber = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.stepType = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.stepDescription = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.stepResult = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 45) {
            break;
          }

          message.stepDurationMs = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AgentStepCompleted {
    return {
      stepNumber: isSet(object.stepNumber) ? globalThis.Number(object.stepNumber) : 0,
      stepType: isSet(object.stepType) ? globalThis.String(object.stepType) : "",
      stepDescription: isSet(object.stepDescription) ? globalThis.String(object.stepDescription) : "",
      stepResult: isObject(object.stepResult) ? object.stepResult : undefined,
      stepDurationMs: isSet(object.stepDurationMs) ? globalThis.Number(object.stepDurationMs) : 0,
    };
  },

  toJSON(message: AgentStepCompleted): unknown {
    const obj: any = {};
    if (message.stepNumber !== 0) {
      obj.stepNumber = Math.round(message.stepNumber);
    }
    if (message.stepType !== "") {
      obj.stepType = message.stepType;
    }
    if (message.stepDescription !== "") {
      obj.stepDescription = message.stepDescription;
    }
    if (message.stepResult !== undefined) {
      obj.stepResult = message.stepResult;
    }
    if (message.stepDurationMs !== 0) {
      obj.stepDurationMs = message.stepDurationMs;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AgentStepCompleted>, I>>(base?: I): AgentStepCompleted {
    return AgentStepCompleted.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AgentStepCompleted>, I>>(object: I): AgentStepCompleted {
    const message = createBaseAgentStepCompleted();
    message.stepNumber = object.stepNumber ?? 0;
    message.stepType = object.stepType ?? "";
    message.stepDescription = object.stepDescription ?? "";
    message.stepResult = object.stepResult ?? undefined;
    message.stepDurationMs = object.stepDurationMs ?? 0;
    return message;
  },
};

function createBaseAgentCompleted(): AgentCompleted {
  return { completionStatus: "", finalResult: undefined, totalSteps: 0, totalDurationMs: 0 };
}

export const AgentCompleted = {
  encode(message: AgentCompleted, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.completionStatus !== "") {
      writer.uint32(10).string(message.completionStatus);
    }
    if (message.finalResult !== undefined) {
      Struct.encode(Struct.wrap(message.finalResult), writer.uint32(18).fork()).ldelim();
    }
    if (message.totalSteps !== 0) {
      writer.uint32(24).int32(message.totalSteps);
    }
    if (message.totalDurationMs !== 0) {
      writer.uint32(37).float(message.totalDurationMs);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AgentCompleted {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgentCompleted();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.completionStatus = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.finalResult = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.totalSteps = reader.int32();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.totalDurationMs = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AgentCompleted {
    return {
      completionStatus: isSet(object.completionStatus) ? globalThis.String(object.completionStatus) : "",
      finalResult: isObject(object.finalResult) ? object.finalResult : undefined,
      totalSteps: isSet(object.totalSteps) ? globalThis.Number(object.totalSteps) : 0,
      totalDurationMs: isSet(object.totalDurationMs) ? globalThis.Number(object.totalDurationMs) : 0,
    };
  },

  toJSON(message: AgentCompleted): unknown {
    const obj: any = {};
    if (message.completionStatus !== "") {
      obj.completionStatus = message.completionStatus;
    }
    if (message.finalResult !== undefined) {
      obj.finalResult = message.finalResult;
    }
    if (message.totalSteps !== 0) {
      obj.totalSteps = Math.round(message.totalSteps);
    }
    if (message.totalDurationMs !== 0) {
      obj.totalDurationMs = message.totalDurationMs;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AgentCompleted>, I>>(base?: I): AgentCompleted {
    return AgentCompleted.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AgentCompleted>, I>>(object: I): AgentCompleted {
    const message = createBaseAgentCompleted();
    message.completionStatus = object.completionStatus ?? "";
    message.finalResult = object.finalResult ?? undefined;
    message.totalSteps = object.totalSteps ?? 0;
    message.totalDurationMs = object.totalDurationMs ?? 0;
    return message;
  },
};

function createBaseAgentFailed(): AgentFailed {
  return { failureReason: "", errorMessage: "", failedAtStep: 0, isRecoverable: false };
}

export const AgentFailed = {
  encode(message: AgentFailed, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.failureReason !== "") {
      writer.uint32(10).string(message.failureReason);
    }
    if (message.errorMessage !== "") {
      writer.uint32(18).string(message.errorMessage);
    }
    if (message.failedAtStep !== 0) {
      writer.uint32(24).int32(message.failedAtStep);
    }
    if (message.isRecoverable !== false) {
      writer.uint32(32).bool(message.isRecoverable);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AgentFailed {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgentFailed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.failureReason = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.failedAtStep = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.isRecoverable = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AgentFailed {
    return {
      failureReason: isSet(object.failureReason) ? globalThis.String(object.failureReason) : "",
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
      failedAtStep: isSet(object.failedAtStep) ? globalThis.Number(object.failedAtStep) : 0,
      isRecoverable: isSet(object.isRecoverable) ? globalThis.Boolean(object.isRecoverable) : false,
    };
  },

  toJSON(message: AgentFailed): unknown {
    const obj: any = {};
    if (message.failureReason !== "") {
      obj.failureReason = message.failureReason;
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    if (message.failedAtStep !== 0) {
      obj.failedAtStep = Math.round(message.failedAtStep);
    }
    if (message.isRecoverable !== false) {
      obj.isRecoverable = message.isRecoverable;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AgentFailed>, I>>(base?: I): AgentFailed {
    return AgentFailed.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AgentFailed>, I>>(object: I): AgentFailed {
    const message = createBaseAgentFailed();
    message.failureReason = object.failureReason ?? "";
    message.errorMessage = object.errorMessage ?? "";
    message.failedAtStep = object.failedAtStep ?? 0;
    message.isRecoverable = object.isRecoverable ?? false;
    return message;
  },
};

function createBaseAgentToolUsed(): AgentToolUsed {
  return {
    toolName: "",
    toolVersion: "",
    toolInput: undefined,
    toolOutput: undefined,
    toolDurationMs: 0,
    toolSuccess: false,
  };
}

export const AgentToolUsed = {
  encode(message: AgentToolUsed, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.toolName !== "") {
      writer.uint32(10).string(message.toolName);
    }
    if (message.toolVersion !== "") {
      writer.uint32(18).string(message.toolVersion);
    }
    if (message.toolInput !== undefined) {
      Struct.encode(Struct.wrap(message.toolInput), writer.uint32(26).fork()).ldelim();
    }
    if (message.toolOutput !== undefined) {
      Struct.encode(Struct.wrap(message.toolOutput), writer.uint32(34).fork()).ldelim();
    }
    if (message.toolDurationMs !== 0) {
      writer.uint32(45).float(message.toolDurationMs);
    }
    if (message.toolSuccess !== false) {
      writer.uint32(48).bool(message.toolSuccess);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AgentToolUsed {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgentToolUsed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.toolName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.toolVersion = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.toolInput = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.toolOutput = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 45) {
            break;
          }

          message.toolDurationMs = reader.float();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.toolSuccess = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AgentToolUsed {
    return {
      toolName: isSet(object.toolName) ? globalThis.String(object.toolName) : "",
      toolVersion: isSet(object.toolVersion) ? globalThis.String(object.toolVersion) : "",
      toolInput: isObject(object.toolInput) ? object.toolInput : undefined,
      toolOutput: isObject(object.toolOutput) ? object.toolOutput : undefined,
      toolDurationMs: isSet(object.toolDurationMs) ? globalThis.Number(object.toolDurationMs) : 0,
      toolSuccess: isSet(object.toolSuccess) ? globalThis.Boolean(object.toolSuccess) : false,
    };
  },

  toJSON(message: AgentToolUsed): unknown {
    const obj: any = {};
    if (message.toolName !== "") {
      obj.toolName = message.toolName;
    }
    if (message.toolVersion !== "") {
      obj.toolVersion = message.toolVersion;
    }
    if (message.toolInput !== undefined) {
      obj.toolInput = message.toolInput;
    }
    if (message.toolOutput !== undefined) {
      obj.toolOutput = message.toolOutput;
    }
    if (message.toolDurationMs !== 0) {
      obj.toolDurationMs = message.toolDurationMs;
    }
    if (message.toolSuccess !== false) {
      obj.toolSuccess = message.toolSuccess;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AgentToolUsed>, I>>(base?: I): AgentToolUsed {
    return AgentToolUsed.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AgentToolUsed>, I>>(object: I): AgentToolUsed {
    const message = createBaseAgentToolUsed();
    message.toolName = object.toolName ?? "";
    message.toolVersion = object.toolVersion ?? "";
    message.toolInput = object.toolInput ?? undefined;
    message.toolOutput = object.toolOutput ?? undefined;
    message.toolDurationMs = object.toolDurationMs ?? 0;
    message.toolSuccess = object.toolSuccess ?? false;
    return message;
  },
};

function createBaseSessionEvent(): SessionEvent {
  return {
    sessionId: "",
    eventType: 0,
    started: undefined,
    ended: undefined,
    contextAccessed: undefined,
    heartbeat: undefined,
  };
}

export const SessionEvent = {
  encode(message: SessionEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.eventType !== 0) {
      writer.uint32(16).int32(message.eventType);
    }
    if (message.started !== undefined) {
      SessionStarted.encode(message.started, writer.uint32(82).fork()).ldelim();
    }
    if (message.ended !== undefined) {
      SessionEnded.encode(message.ended, writer.uint32(90).fork()).ldelim();
    }
    if (message.contextAccessed !== undefined) {
      SessionContextAccessed.encode(message.contextAccessed, writer.uint32(98).fork()).ldelim();
    }
    if (message.heartbeat !== undefined) {
      SessionHeartbeat.encode(message.heartbeat, writer.uint32(106).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SessionEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.eventType = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.started = SessionStarted.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.ended = SessionEnded.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.contextAccessed = SessionContextAccessed.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.heartbeat = SessionHeartbeat.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionEvent {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      eventType: isSet(object.eventType) ? sessionEventTypeFromJSON(object.eventType) : 0,
      started: isSet(object.started) ? SessionStarted.fromJSON(object.started) : undefined,
      ended: isSet(object.ended) ? SessionEnded.fromJSON(object.ended) : undefined,
      contextAccessed: isSet(object.contextAccessed)
        ? SessionContextAccessed.fromJSON(object.contextAccessed)
        : undefined,
      heartbeat: isSet(object.heartbeat) ? SessionHeartbeat.fromJSON(object.heartbeat) : undefined,
    };
  },

  toJSON(message: SessionEvent): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.eventType !== 0) {
      obj.eventType = sessionEventTypeToJSON(message.eventType);
    }
    if (message.started !== undefined) {
      obj.started = SessionStarted.toJSON(message.started);
    }
    if (message.ended !== undefined) {
      obj.ended = SessionEnded.toJSON(message.ended);
    }
    if (message.contextAccessed !== undefined) {
      obj.contextAccessed = SessionContextAccessed.toJSON(message.contextAccessed);
    }
    if (message.heartbeat !== undefined) {
      obj.heartbeat = SessionHeartbeat.toJSON(message.heartbeat);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SessionEvent>, I>>(base?: I): SessionEvent {
    return SessionEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SessionEvent>, I>>(object: I): SessionEvent {
    const message = createBaseSessionEvent();
    message.sessionId = object.sessionId ?? "";
    message.eventType = object.eventType ?? 0;
    message.started = (object.started !== undefined && object.started !== null)
      ? SessionStarted.fromPartial(object.started)
      : undefined;
    message.ended = (object.ended !== undefined && object.ended !== null)
      ? SessionEnded.fromPartial(object.ended)
      : undefined;
    message.contextAccessed = (object.contextAccessed !== undefined && object.contextAccessed !== null)
      ? SessionContextAccessed.fromPartial(object.contextAccessed)
      : undefined;
    message.heartbeat = (object.heartbeat !== undefined && object.heartbeat !== null)
      ? SessionHeartbeat.fromPartial(object.heartbeat)
      : undefined;
    return message;
  },
};

function createBaseSessionStarted(): SessionStarted {
  return { userAgent: "", ipAddress: "", sessionMetadata: undefined };
}

export const SessionStarted = {
  encode(message: SessionStarted, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userAgent !== "") {
      writer.uint32(10).string(message.userAgent);
    }
    if (message.ipAddress !== "") {
      writer.uint32(18).string(message.ipAddress);
    }
    if (message.sessionMetadata !== undefined) {
      Struct.encode(Struct.wrap(message.sessionMetadata), writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SessionStarted {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionStarted();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userAgent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ipAddress = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sessionMetadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionStarted {
    return {
      userAgent: isSet(object.userAgent) ? globalThis.String(object.userAgent) : "",
      ipAddress: isSet(object.ipAddress) ? globalThis.String(object.ipAddress) : "",
      sessionMetadata: isObject(object.sessionMetadata) ? object.sessionMetadata : undefined,
    };
  },

  toJSON(message: SessionStarted): unknown {
    const obj: any = {};
    if (message.userAgent !== "") {
      obj.userAgent = message.userAgent;
    }
    if (message.ipAddress !== "") {
      obj.ipAddress = message.ipAddress;
    }
    if (message.sessionMetadata !== undefined) {
      obj.sessionMetadata = message.sessionMetadata;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SessionStarted>, I>>(base?: I): SessionStarted {
    return SessionStarted.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SessionStarted>, I>>(object: I): SessionStarted {
    const message = createBaseSessionStarted();
    message.userAgent = object.userAgent ?? "";
    message.ipAddress = object.ipAddress ?? "";
    message.sessionMetadata = object.sessionMetadata ?? undefined;
    return message;
  },
};

function createBaseSessionEnded(): SessionEnded {
  return { endReason: "", sessionDurationMs: 0, interactionsCount: 0 };
}

export const SessionEnded = {
  encode(message: SessionEnded, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.endReason !== "") {
      writer.uint32(10).string(message.endReason);
    }
    if (message.sessionDurationMs !== 0) {
      writer.uint32(21).float(message.sessionDurationMs);
    }
    if (message.interactionsCount !== 0) {
      writer.uint32(24).int32(message.interactionsCount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SessionEnded {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionEnded();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.endReason = reader.string();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.sessionDurationMs = reader.float();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.interactionsCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionEnded {
    return {
      endReason: isSet(object.endReason) ? globalThis.String(object.endReason) : "",
      sessionDurationMs: isSet(object.sessionDurationMs) ? globalThis.Number(object.sessionDurationMs) : 0,
      interactionsCount: isSet(object.interactionsCount) ? globalThis.Number(object.interactionsCount) : 0,
    };
  },

  toJSON(message: SessionEnded): unknown {
    const obj: any = {};
    if (message.endReason !== "") {
      obj.endReason = message.endReason;
    }
    if (message.sessionDurationMs !== 0) {
      obj.sessionDurationMs = message.sessionDurationMs;
    }
    if (message.interactionsCount !== 0) {
      obj.interactionsCount = Math.round(message.interactionsCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SessionEnded>, I>>(base?: I): SessionEnded {
    return SessionEnded.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SessionEnded>, I>>(object: I): SessionEnded {
    const message = createBaseSessionEnded();
    message.endReason = object.endReason ?? "";
    message.sessionDurationMs = object.sessionDurationMs ?? 0;
    message.interactionsCount = object.interactionsCount ?? 0;
    return message;
  },
};

function createBaseSessionContextAccessed(): SessionContextAccessed {
  return { documentTypes: [], documentsReturned: 0, accessReason: "" };
}

export const SessionContextAccessed = {
  encode(message: SessionContextAccessed, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.documentTypes) {
      writer.uint32(10).string(v!);
    }
    if (message.documentsReturned !== 0) {
      writer.uint32(16).int32(message.documentsReturned);
    }
    if (message.accessReason !== "") {
      writer.uint32(26).string(message.accessReason);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SessionContextAccessed {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionContextAccessed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.documentTypes.push(reader.string());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.documentsReturned = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.accessReason = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionContextAccessed {
    return {
      documentTypes: globalThis.Array.isArray(object?.documentTypes)
        ? object.documentTypes.map((e: any) => globalThis.String(e))
        : [],
      documentsReturned: isSet(object.documentsReturned) ? globalThis.Number(object.documentsReturned) : 0,
      accessReason: isSet(object.accessReason) ? globalThis.String(object.accessReason) : "",
    };
  },

  toJSON(message: SessionContextAccessed): unknown {
    const obj: any = {};
    if (message.documentTypes?.length) {
      obj.documentTypes = message.documentTypes;
    }
    if (message.documentsReturned !== 0) {
      obj.documentsReturned = Math.round(message.documentsReturned);
    }
    if (message.accessReason !== "") {
      obj.accessReason = message.accessReason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SessionContextAccessed>, I>>(base?: I): SessionContextAccessed {
    return SessionContextAccessed.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SessionContextAccessed>, I>>(object: I): SessionContextAccessed {
    const message = createBaseSessionContextAccessed();
    message.documentTypes = object.documentTypes?.map((e) => e) || [];
    message.documentsReturned = object.documentsReturned ?? 0;
    message.accessReason = object.accessReason ?? "";
    return message;
  },
};

function createBaseSessionHeartbeat(): SessionHeartbeat {
  return { lastActivity: undefined, isActive: false };
}

export const SessionHeartbeat = {
  encode(message: SessionHeartbeat, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.lastActivity !== undefined) {
      Timestamp.encode(toTimestamp(message.lastActivity), writer.uint32(10).fork()).ldelim();
    }
    if (message.isActive !== false) {
      writer.uint32(16).bool(message.isActive);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SessionHeartbeat {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionHeartbeat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.lastActivity = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.isActive = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionHeartbeat {
    return {
      lastActivity: isSet(object.lastActivity) ? fromJsonTimestamp(object.lastActivity) : undefined,
      isActive: isSet(object.isActive) ? globalThis.Boolean(object.isActive) : false,
    };
  },

  toJSON(message: SessionHeartbeat): unknown {
    const obj: any = {};
    if (message.lastActivity !== undefined) {
      obj.lastActivity = message.lastActivity.toISOString();
    }
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SessionHeartbeat>, I>>(base?: I): SessionHeartbeat {
    return SessionHeartbeat.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SessionHeartbeat>, I>>(object: I): SessionHeartbeat {
    const message = createBaseSessionHeartbeat();
    message.lastActivity = object.lastActivity ?? undefined;
    message.isActive = object.isActive ?? false;
    return message;
  },
};

function createBaseSystemEvent(): SystemEvent {
  return {
    component: "",
    eventType: 0,
    healthCheck: undefined,
    metric: undefined,
    alert: undefined,
    serviceStarted: undefined,
    serviceStopped: undefined,
  };
}

export const SystemEvent = {
  encode(message: SystemEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.component !== "") {
      writer.uint32(10).string(message.component);
    }
    if (message.eventType !== 0) {
      writer.uint32(16).int32(message.eventType);
    }
    if (message.healthCheck !== undefined) {
      HealthCheck.encode(message.healthCheck, writer.uint32(82).fork()).ldelim();
    }
    if (message.metric !== undefined) {
      MetricReported.encode(message.metric, writer.uint32(90).fork()).ldelim();
    }
    if (message.alert !== undefined) {
      AlertTriggered.encode(message.alert, writer.uint32(98).fork()).ldelim();
    }
    if (message.serviceStarted !== undefined) {
      ServiceStarted.encode(message.serviceStarted, writer.uint32(106).fork()).ldelim();
    }
    if (message.serviceStopped !== undefined) {
      ServiceStopped.encode(message.serviceStopped, writer.uint32(114).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SystemEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSystemEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.component = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.eventType = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.healthCheck = HealthCheck.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.metric = MetricReported.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.alert = AlertTriggered.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.serviceStarted = ServiceStarted.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.serviceStopped = ServiceStopped.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SystemEvent {
    return {
      component: isSet(object.component) ? globalThis.String(object.component) : "",
      eventType: isSet(object.eventType) ? systemEventTypeFromJSON(object.eventType) : 0,
      healthCheck: isSet(object.healthCheck) ? HealthCheck.fromJSON(object.healthCheck) : undefined,
      metric: isSet(object.metric) ? MetricReported.fromJSON(object.metric) : undefined,
      alert: isSet(object.alert) ? AlertTriggered.fromJSON(object.alert) : undefined,
      serviceStarted: isSet(object.serviceStarted) ? ServiceStarted.fromJSON(object.serviceStarted) : undefined,
      serviceStopped: isSet(object.serviceStopped) ? ServiceStopped.fromJSON(object.serviceStopped) : undefined,
    };
  },

  toJSON(message: SystemEvent): unknown {
    const obj: any = {};
    if (message.component !== "") {
      obj.component = message.component;
    }
    if (message.eventType !== 0) {
      obj.eventType = systemEventTypeToJSON(message.eventType);
    }
    if (message.healthCheck !== undefined) {
      obj.healthCheck = HealthCheck.toJSON(message.healthCheck);
    }
    if (message.metric !== undefined) {
      obj.metric = MetricReported.toJSON(message.metric);
    }
    if (message.alert !== undefined) {
      obj.alert = AlertTriggered.toJSON(message.alert);
    }
    if (message.serviceStarted !== undefined) {
      obj.serviceStarted = ServiceStarted.toJSON(message.serviceStarted);
    }
    if (message.serviceStopped !== undefined) {
      obj.serviceStopped = ServiceStopped.toJSON(message.serviceStopped);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SystemEvent>, I>>(base?: I): SystemEvent {
    return SystemEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SystemEvent>, I>>(object: I): SystemEvent {
    const message = createBaseSystemEvent();
    message.component = object.component ?? "";
    message.eventType = object.eventType ?? 0;
    message.healthCheck = (object.healthCheck !== undefined && object.healthCheck !== null)
      ? HealthCheck.fromPartial(object.healthCheck)
      : undefined;
    message.metric = (object.metric !== undefined && object.metric !== null)
      ? MetricReported.fromPartial(object.metric)
      : undefined;
    message.alert = (object.alert !== undefined && object.alert !== null)
      ? AlertTriggered.fromPartial(object.alert)
      : undefined;
    message.serviceStarted = (object.serviceStarted !== undefined && object.serviceStarted !== null)
      ? ServiceStarted.fromPartial(object.serviceStarted)
      : undefined;
    message.serviceStopped = (object.serviceStopped !== undefined && object.serviceStopped !== null)
      ? ServiceStopped.fromPartial(object.serviceStopped)
      : undefined;
    return message;
  },
};

function createBaseHealthCheck(): HealthCheck {
  return { isHealthy: false, status: "", healthDetails: undefined };
}

export const HealthCheck = {
  encode(message: HealthCheck, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.isHealthy !== false) {
      writer.uint32(8).bool(message.isHealthy);
    }
    if (message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    if (message.healthDetails !== undefined) {
      Struct.encode(Struct.wrap(message.healthDetails), writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HealthCheck {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheck();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.isHealthy = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.healthDetails = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthCheck {
    return {
      isHealthy: isSet(object.isHealthy) ? globalThis.Boolean(object.isHealthy) : false,
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      healthDetails: isObject(object.healthDetails) ? object.healthDetails : undefined,
    };
  },

  toJSON(message: HealthCheck): unknown {
    const obj: any = {};
    if (message.isHealthy !== false) {
      obj.isHealthy = message.isHealthy;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.healthDetails !== undefined) {
      obj.healthDetails = message.healthDetails;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthCheck>, I>>(base?: I): HealthCheck {
    return HealthCheck.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthCheck>, I>>(object: I): HealthCheck {
    const message = createBaseHealthCheck();
    message.isHealthy = object.isHealthy ?? false;
    message.status = object.status ?? "";
    message.healthDetails = object.healthDetails ?? undefined;
    return message;
  },
};

function createBaseMetricReported(): MetricReported {
  return { metricName: "", metricValue: 0, metricUnit: "", metricTags: undefined };
}

export const MetricReported = {
  encode(message: MetricReported, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.metricName !== "") {
      writer.uint32(10).string(message.metricName);
    }
    if (message.metricValue !== 0) {
      writer.uint32(17).double(message.metricValue);
    }
    if (message.metricUnit !== "") {
      writer.uint32(26).string(message.metricUnit);
    }
    if (message.metricTags !== undefined) {
      Struct.encode(Struct.wrap(message.metricTags), writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MetricReported {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricReported();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metricName = reader.string();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.metricValue = reader.double();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.metricUnit = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.metricTags = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetricReported {
    return {
      metricName: isSet(object.metricName) ? globalThis.String(object.metricName) : "",
      metricValue: isSet(object.metricValue) ? globalThis.Number(object.metricValue) : 0,
      metricUnit: isSet(object.metricUnit) ? globalThis.String(object.metricUnit) : "",
      metricTags: isObject(object.metricTags) ? object.metricTags : undefined,
    };
  },

  toJSON(message: MetricReported): unknown {
    const obj: any = {};
    if (message.metricName !== "") {
      obj.metricName = message.metricName;
    }
    if (message.metricValue !== 0) {
      obj.metricValue = message.metricValue;
    }
    if (message.metricUnit !== "") {
      obj.metricUnit = message.metricUnit;
    }
    if (message.metricTags !== undefined) {
      obj.metricTags = message.metricTags;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MetricReported>, I>>(base?: I): MetricReported {
    return MetricReported.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MetricReported>, I>>(object: I): MetricReported {
    const message = createBaseMetricReported();
    message.metricName = object.metricName ?? "";
    message.metricValue = object.metricValue ?? 0;
    message.metricUnit = object.metricUnit ?? "";
    message.metricTags = object.metricTags ?? undefined;
    return message;
  },
};

function createBaseAlertTriggered(): AlertTriggered {
  return { alertName: "", severity: "", description: "", alertContext: undefined };
}

export const AlertTriggered = {
  encode(message: AlertTriggered, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.alertName !== "") {
      writer.uint32(10).string(message.alertName);
    }
    if (message.severity !== "") {
      writer.uint32(18).string(message.severity);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.alertContext !== undefined) {
      Struct.encode(Struct.wrap(message.alertContext), writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AlertTriggered {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlertTriggered();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.alertName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.severity = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.alertContext = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlertTriggered {
    return {
      alertName: isSet(object.alertName) ? globalThis.String(object.alertName) : "",
      severity: isSet(object.severity) ? globalThis.String(object.severity) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      alertContext: isObject(object.alertContext) ? object.alertContext : undefined,
    };
  },

  toJSON(message: AlertTriggered): unknown {
    const obj: any = {};
    if (message.alertName !== "") {
      obj.alertName = message.alertName;
    }
    if (message.severity !== "") {
      obj.severity = message.severity;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.alertContext !== undefined) {
      obj.alertContext = message.alertContext;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AlertTriggered>, I>>(base?: I): AlertTriggered {
    return AlertTriggered.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AlertTriggered>, I>>(object: I): AlertTriggered {
    const message = createBaseAlertTriggered();
    message.alertName = object.alertName ?? "";
    message.severity = object.severity ?? "";
    message.description = object.description ?? "";
    message.alertContext = object.alertContext ?? undefined;
    return message;
  },
};

function createBaseServiceStarted(): ServiceStarted {
  return { serviceName: "", serviceVersion: "", buildInfo: "" };
}

export const ServiceStarted = {
  encode(message: ServiceStarted, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.serviceName !== "") {
      writer.uint32(10).string(message.serviceName);
    }
    if (message.serviceVersion !== "") {
      writer.uint32(18).string(message.serviceVersion);
    }
    if (message.buildInfo !== "") {
      writer.uint32(26).string(message.buildInfo);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ServiceStarted {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceStarted();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.serviceName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.serviceVersion = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.buildInfo = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceStarted {
    return {
      serviceName: isSet(object.serviceName) ? globalThis.String(object.serviceName) : "",
      serviceVersion: isSet(object.serviceVersion) ? globalThis.String(object.serviceVersion) : "",
      buildInfo: isSet(object.buildInfo) ? globalThis.String(object.buildInfo) : "",
    };
  },

  toJSON(message: ServiceStarted): unknown {
    const obj: any = {};
    if (message.serviceName !== "") {
      obj.serviceName = message.serviceName;
    }
    if (message.serviceVersion !== "") {
      obj.serviceVersion = message.serviceVersion;
    }
    if (message.buildInfo !== "") {
      obj.buildInfo = message.buildInfo;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServiceStarted>, I>>(base?: I): ServiceStarted {
    return ServiceStarted.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServiceStarted>, I>>(object: I): ServiceStarted {
    const message = createBaseServiceStarted();
    message.serviceName = object.serviceName ?? "";
    message.serviceVersion = object.serviceVersion ?? "";
    message.buildInfo = object.buildInfo ?? "";
    return message;
  },
};

function createBaseServiceStopped(): ServiceStopped {
  return { serviceName: "", stopReason: "", uptimeMs: 0 };
}

export const ServiceStopped = {
  encode(message: ServiceStopped, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.serviceName !== "") {
      writer.uint32(10).string(message.serviceName);
    }
    if (message.stopReason !== "") {
      writer.uint32(18).string(message.stopReason);
    }
    if (message.uptimeMs !== 0) {
      writer.uint32(29).float(message.uptimeMs);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ServiceStopped {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceStopped();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.serviceName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.stopReason = reader.string();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.uptimeMs = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceStopped {
    return {
      serviceName: isSet(object.serviceName) ? globalThis.String(object.serviceName) : "",
      stopReason: isSet(object.stopReason) ? globalThis.String(object.stopReason) : "",
      uptimeMs: isSet(object.uptimeMs) ? globalThis.Number(object.uptimeMs) : 0,
    };
  },

  toJSON(message: ServiceStopped): unknown {
    const obj: any = {};
    if (message.serviceName !== "") {
      obj.serviceName = message.serviceName;
    }
    if (message.stopReason !== "") {
      obj.stopReason = message.stopReason;
    }
    if (message.uptimeMs !== 0) {
      obj.uptimeMs = message.uptimeMs;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServiceStopped>, I>>(base?: I): ServiceStopped {
    return ServiceStopped.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServiceStopped>, I>>(object: I): ServiceStopped {
    const message = createBaseServiceStopped();
    message.serviceName = object.serviceName ?? "";
    message.stopReason = object.stopReason ?? "";
    message.uptimeMs = object.uptimeMs ?? 0;
    return message;
  },
};

function createBaseWorkflowEvent(): WorkflowEvent {
  return {
    workflowId: "",
    workflowType: "",
    executionId: "",
    eventType: 0,
    triggered: undefined,
    stepExecuted: undefined,
    completed: undefined,
    failed: undefined,
  };
}

export const WorkflowEvent = {
  encode(message: WorkflowEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.workflowId !== "") {
      writer.uint32(10).string(message.workflowId);
    }
    if (message.workflowType !== "") {
      writer.uint32(18).string(message.workflowType);
    }
    if (message.executionId !== "") {
      writer.uint32(26).string(message.executionId);
    }
    if (message.eventType !== 0) {
      writer.uint32(32).int32(message.eventType);
    }
    if (message.triggered !== undefined) {
      WorkflowTriggered.encode(message.triggered, writer.uint32(82).fork()).ldelim();
    }
    if (message.stepExecuted !== undefined) {
      WorkflowStepExecuted.encode(message.stepExecuted, writer.uint32(90).fork()).ldelim();
    }
    if (message.completed !== undefined) {
      WorkflowCompleted.encode(message.completed, writer.uint32(98).fork()).ldelim();
    }
    if (message.failed !== undefined) {
      WorkflowFailed.encode(message.failed, writer.uint32(106).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WorkflowEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkflowEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.workflowId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.workflowType = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.executionId = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.eventType = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.triggered = WorkflowTriggered.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.stepExecuted = WorkflowStepExecuted.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.completed = WorkflowCompleted.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.failed = WorkflowFailed.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkflowEvent {
    return {
      workflowId: isSet(object.workflowId) ? globalThis.String(object.workflowId) : "",
      workflowType: isSet(object.workflowType) ? globalThis.String(object.workflowType) : "",
      executionId: isSet(object.executionId) ? globalThis.String(object.executionId) : "",
      eventType: isSet(object.eventType) ? workflowEventTypeFromJSON(object.eventType) : 0,
      triggered: isSet(object.triggered) ? WorkflowTriggered.fromJSON(object.triggered) : undefined,
      stepExecuted: isSet(object.stepExecuted) ? WorkflowStepExecuted.fromJSON(object.stepExecuted) : undefined,
      completed: isSet(object.completed) ? WorkflowCompleted.fromJSON(object.completed) : undefined,
      failed: isSet(object.failed) ? WorkflowFailed.fromJSON(object.failed) : undefined,
    };
  },

  toJSON(message: WorkflowEvent): unknown {
    const obj: any = {};
    if (message.workflowId !== "") {
      obj.workflowId = message.workflowId;
    }
    if (message.workflowType !== "") {
      obj.workflowType = message.workflowType;
    }
    if (message.executionId !== "") {
      obj.executionId = message.executionId;
    }
    if (message.eventType !== 0) {
      obj.eventType = workflowEventTypeToJSON(message.eventType);
    }
    if (message.triggered !== undefined) {
      obj.triggered = WorkflowTriggered.toJSON(message.triggered);
    }
    if (message.stepExecuted !== undefined) {
      obj.stepExecuted = WorkflowStepExecuted.toJSON(message.stepExecuted);
    }
    if (message.completed !== undefined) {
      obj.completed = WorkflowCompleted.toJSON(message.completed);
    }
    if (message.failed !== undefined) {
      obj.failed = WorkflowFailed.toJSON(message.failed);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorkflowEvent>, I>>(base?: I): WorkflowEvent {
    return WorkflowEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorkflowEvent>, I>>(object: I): WorkflowEvent {
    const message = createBaseWorkflowEvent();
    message.workflowId = object.workflowId ?? "";
    message.workflowType = object.workflowType ?? "";
    message.executionId = object.executionId ?? "";
    message.eventType = object.eventType ?? 0;
    message.triggered = (object.triggered !== undefined && object.triggered !== null)
      ? WorkflowTriggered.fromPartial(object.triggered)
      : undefined;
    message.stepExecuted = (object.stepExecuted !== undefined && object.stepExecuted !== null)
      ? WorkflowStepExecuted.fromPartial(object.stepExecuted)
      : undefined;
    message.completed = (object.completed !== undefined && object.completed !== null)
      ? WorkflowCompleted.fromPartial(object.completed)
      : undefined;
    message.failed = (object.failed !== undefined && object.failed !== null)
      ? WorkflowFailed.fromPartial(object.failed)
      : undefined;
    return message;
  },
};

function createBaseWorkflowTriggered(): WorkflowTriggered {
  return { triggerEventId: "", triggerType: "", triggerContext: undefined };
}

export const WorkflowTriggered = {
  encode(message: WorkflowTriggered, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.triggerEventId !== "") {
      writer.uint32(10).string(message.triggerEventId);
    }
    if (message.triggerType !== "") {
      writer.uint32(18).string(message.triggerType);
    }
    if (message.triggerContext !== undefined) {
      Struct.encode(Struct.wrap(message.triggerContext), writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WorkflowTriggered {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkflowTriggered();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.triggerEventId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.triggerType = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.triggerContext = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkflowTriggered {
    return {
      triggerEventId: isSet(object.triggerEventId) ? globalThis.String(object.triggerEventId) : "",
      triggerType: isSet(object.triggerType) ? globalThis.String(object.triggerType) : "",
      triggerContext: isObject(object.triggerContext) ? object.triggerContext : undefined,
    };
  },

  toJSON(message: WorkflowTriggered): unknown {
    const obj: any = {};
    if (message.triggerEventId !== "") {
      obj.triggerEventId = message.triggerEventId;
    }
    if (message.triggerType !== "") {
      obj.triggerType = message.triggerType;
    }
    if (message.triggerContext !== undefined) {
      obj.triggerContext = message.triggerContext;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorkflowTriggered>, I>>(base?: I): WorkflowTriggered {
    return WorkflowTriggered.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorkflowTriggered>, I>>(object: I): WorkflowTriggered {
    const message = createBaseWorkflowTriggered();
    message.triggerEventId = object.triggerEventId ?? "";
    message.triggerType = object.triggerType ?? "";
    message.triggerContext = object.triggerContext ?? undefined;
    return message;
  },
};

function createBaseWorkflowStepExecuted(): WorkflowStepExecuted {
  return { stepId: "", stepType: "", stepInput: undefined, stepOutput: undefined, stepDurationMs: 0 };
}

export const WorkflowStepExecuted = {
  encode(message: WorkflowStepExecuted, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.stepId !== "") {
      writer.uint32(10).string(message.stepId);
    }
    if (message.stepType !== "") {
      writer.uint32(18).string(message.stepType);
    }
    if (message.stepInput !== undefined) {
      Struct.encode(Struct.wrap(message.stepInput), writer.uint32(26).fork()).ldelim();
    }
    if (message.stepOutput !== undefined) {
      Struct.encode(Struct.wrap(message.stepOutput), writer.uint32(34).fork()).ldelim();
    }
    if (message.stepDurationMs !== 0) {
      writer.uint32(45).float(message.stepDurationMs);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WorkflowStepExecuted {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkflowStepExecuted();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.stepId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.stepType = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.stepInput = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.stepOutput = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 45) {
            break;
          }

          message.stepDurationMs = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkflowStepExecuted {
    return {
      stepId: isSet(object.stepId) ? globalThis.String(object.stepId) : "",
      stepType: isSet(object.stepType) ? globalThis.String(object.stepType) : "",
      stepInput: isObject(object.stepInput) ? object.stepInput : undefined,
      stepOutput: isObject(object.stepOutput) ? object.stepOutput : undefined,
      stepDurationMs: isSet(object.stepDurationMs) ? globalThis.Number(object.stepDurationMs) : 0,
    };
  },

  toJSON(message: WorkflowStepExecuted): unknown {
    const obj: any = {};
    if (message.stepId !== "") {
      obj.stepId = message.stepId;
    }
    if (message.stepType !== "") {
      obj.stepType = message.stepType;
    }
    if (message.stepInput !== undefined) {
      obj.stepInput = message.stepInput;
    }
    if (message.stepOutput !== undefined) {
      obj.stepOutput = message.stepOutput;
    }
    if (message.stepDurationMs !== 0) {
      obj.stepDurationMs = message.stepDurationMs;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorkflowStepExecuted>, I>>(base?: I): WorkflowStepExecuted {
    return WorkflowStepExecuted.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorkflowStepExecuted>, I>>(object: I): WorkflowStepExecuted {
    const message = createBaseWorkflowStepExecuted();
    message.stepId = object.stepId ?? "";
    message.stepType = object.stepType ?? "";
    message.stepInput = object.stepInput ?? undefined;
    message.stepOutput = object.stepOutput ?? undefined;
    message.stepDurationMs = object.stepDurationMs ?? 0;
    return message;
  },
};

function createBaseWorkflowCompleted(): WorkflowCompleted {
  return { finalOutput: undefined, totalSteps: 0, totalDurationMs: 0 };
}

export const WorkflowCompleted = {
  encode(message: WorkflowCompleted, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.finalOutput !== undefined) {
      Struct.encode(Struct.wrap(message.finalOutput), writer.uint32(10).fork()).ldelim();
    }
    if (message.totalSteps !== 0) {
      writer.uint32(16).int32(message.totalSteps);
    }
    if (message.totalDurationMs !== 0) {
      writer.uint32(29).float(message.totalDurationMs);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WorkflowCompleted {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkflowCompleted();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.finalOutput = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.totalSteps = reader.int32();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.totalDurationMs = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkflowCompleted {
    return {
      finalOutput: isObject(object.finalOutput) ? object.finalOutput : undefined,
      totalSteps: isSet(object.totalSteps) ? globalThis.Number(object.totalSteps) : 0,
      totalDurationMs: isSet(object.totalDurationMs) ? globalThis.Number(object.totalDurationMs) : 0,
    };
  },

  toJSON(message: WorkflowCompleted): unknown {
    const obj: any = {};
    if (message.finalOutput !== undefined) {
      obj.finalOutput = message.finalOutput;
    }
    if (message.totalSteps !== 0) {
      obj.totalSteps = Math.round(message.totalSteps);
    }
    if (message.totalDurationMs !== 0) {
      obj.totalDurationMs = message.totalDurationMs;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorkflowCompleted>, I>>(base?: I): WorkflowCompleted {
    return WorkflowCompleted.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorkflowCompleted>, I>>(object: I): WorkflowCompleted {
    const message = createBaseWorkflowCompleted();
    message.finalOutput = object.finalOutput ?? undefined;
    message.totalSteps = object.totalSteps ?? 0;
    message.totalDurationMs = object.totalDurationMs ?? 0;
    return message;
  },
};

function createBaseWorkflowFailed(): WorkflowFailed {
  return { failureStepId: "", failureReason: "", errorMessage: "" };
}

export const WorkflowFailed = {
  encode(message: WorkflowFailed, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.failureStepId !== "") {
      writer.uint32(10).string(message.failureStepId);
    }
    if (message.failureReason !== "") {
      writer.uint32(18).string(message.failureReason);
    }
    if (message.errorMessage !== "") {
      writer.uint32(26).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WorkflowFailed {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkflowFailed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.failureStepId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.failureReason = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkflowFailed {
    return {
      failureStepId: isSet(object.failureStepId) ? globalThis.String(object.failureStepId) : "",
      failureReason: isSet(object.failureReason) ? globalThis.String(object.failureReason) : "",
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
    };
  },

  toJSON(message: WorkflowFailed): unknown {
    const obj: any = {};
    if (message.failureStepId !== "") {
      obj.failureStepId = message.failureStepId;
    }
    if (message.failureReason !== "") {
      obj.failureReason = message.failureReason;
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorkflowFailed>, I>>(base?: I): WorkflowFailed {
    return WorkflowFailed.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorkflowFailed>, I>>(object: I): WorkflowFailed {
    const message = createBaseWorkflowFailed();
    message.failureStepId = object.failureStepId ?? "";
    message.failureReason = object.failureReason ?? "";
    message.errorMessage = object.errorMessage ?? "";
    return message;
  },
};

function createBaseChatEvent(): ChatEvent {
  return {
    conversationId: "",
    messageId: "",
    eventType: 0,
    conversationCreated: undefined,
    messageSent: undefined,
    messageUpdated: undefined,
    typingStarted: undefined,
    participantJoined: undefined,
  };
}

export const ChatEvent = {
  encode(message: ChatEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.conversationId !== "") {
      writer.uint32(10).string(message.conversationId);
    }
    if (message.messageId !== "") {
      writer.uint32(18).string(message.messageId);
    }
    if (message.eventType !== 0) {
      writer.uint32(24).int32(message.eventType);
    }
    if (message.conversationCreated !== undefined) {
      ConversationCreated.encode(message.conversationCreated, writer.uint32(82).fork()).ldelim();
    }
    if (message.messageSent !== undefined) {
      MessageSent.encode(message.messageSent, writer.uint32(90).fork()).ldelim();
    }
    if (message.messageUpdated !== undefined) {
      MessageUpdated.encode(message.messageUpdated, writer.uint32(98).fork()).ldelim();
    }
    if (message.typingStarted !== undefined) {
      TypingStarted.encode(message.typingStarted, writer.uint32(106).fork()).ldelim();
    }
    if (message.participantJoined !== undefined) {
      ParticipantJoined.encode(message.participantJoined, writer.uint32(114).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChatEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChatEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.conversationId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.messageId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.eventType = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.conversationCreated = ConversationCreated.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.messageSent = MessageSent.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.messageUpdated = MessageUpdated.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.typingStarted = TypingStarted.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.participantJoined = ParticipantJoined.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChatEvent {
    return {
      conversationId: isSet(object.conversationId) ? globalThis.String(object.conversationId) : "",
      messageId: isSet(object.messageId) ? globalThis.String(object.messageId) : "",
      eventType: isSet(object.eventType) ? chatEventTypeFromJSON(object.eventType) : 0,
      conversationCreated: isSet(object.conversationCreated)
        ? ConversationCreated.fromJSON(object.conversationCreated)
        : undefined,
      messageSent: isSet(object.messageSent) ? MessageSent.fromJSON(object.messageSent) : undefined,
      messageUpdated: isSet(object.messageUpdated) ? MessageUpdated.fromJSON(object.messageUpdated) : undefined,
      typingStarted: isSet(object.typingStarted) ? TypingStarted.fromJSON(object.typingStarted) : undefined,
      participantJoined: isSet(object.participantJoined)
        ? ParticipantJoined.fromJSON(object.participantJoined)
        : undefined,
    };
  },

  toJSON(message: ChatEvent): unknown {
    const obj: any = {};
    if (message.conversationId !== "") {
      obj.conversationId = message.conversationId;
    }
    if (message.messageId !== "") {
      obj.messageId = message.messageId;
    }
    if (message.eventType !== 0) {
      obj.eventType = chatEventTypeToJSON(message.eventType);
    }
    if (message.conversationCreated !== undefined) {
      obj.conversationCreated = ConversationCreated.toJSON(message.conversationCreated);
    }
    if (message.messageSent !== undefined) {
      obj.messageSent = MessageSent.toJSON(message.messageSent);
    }
    if (message.messageUpdated !== undefined) {
      obj.messageUpdated = MessageUpdated.toJSON(message.messageUpdated);
    }
    if (message.typingStarted !== undefined) {
      obj.typingStarted = TypingStarted.toJSON(message.typingStarted);
    }
    if (message.participantJoined !== undefined) {
      obj.participantJoined = ParticipantJoined.toJSON(message.participantJoined);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChatEvent>, I>>(base?: I): ChatEvent {
    return ChatEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChatEvent>, I>>(object: I): ChatEvent {
    const message = createBaseChatEvent();
    message.conversationId = object.conversationId ?? "";
    message.messageId = object.messageId ?? "";
    message.eventType = object.eventType ?? 0;
    message.conversationCreated = (object.conversationCreated !== undefined && object.conversationCreated !== null)
      ? ConversationCreated.fromPartial(object.conversationCreated)
      : undefined;
    message.messageSent = (object.messageSent !== undefined && object.messageSent !== null)
      ? MessageSent.fromPartial(object.messageSent)
      : undefined;
    message.messageUpdated = (object.messageUpdated !== undefined && object.messageUpdated !== null)
      ? MessageUpdated.fromPartial(object.messageUpdated)
      : undefined;
    message.typingStarted = (object.typingStarted !== undefined && object.typingStarted !== null)
      ? TypingStarted.fromPartial(object.typingStarted)
      : undefined;
    message.participantJoined = (object.participantJoined !== undefined && object.participantJoined !== null)
      ? ParticipantJoined.fromPartial(object.participantJoined)
      : undefined;
    return message;
  },
};

function createBaseConversationCreated(): ConversationCreated {
  return { title: "", createdBy: "", participantIds: [] };
}

export const ConversationCreated = {
  encode(message: ConversationCreated, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.createdBy !== "") {
      writer.uint32(18).string(message.createdBy);
    }
    for (const v of message.participantIds) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ConversationCreated {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversationCreated();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createdBy = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.participantIds.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConversationCreated {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      createdBy: isSet(object.createdBy) ? globalThis.String(object.createdBy) : "",
      participantIds: globalThis.Array.isArray(object?.participantIds)
        ? object.participantIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ConversationCreated): unknown {
    const obj: any = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.createdBy !== "") {
      obj.createdBy = message.createdBy;
    }
    if (message.participantIds?.length) {
      obj.participantIds = message.participantIds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConversationCreated>, I>>(base?: I): ConversationCreated {
    return ConversationCreated.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConversationCreated>, I>>(object: I): ConversationCreated {
    const message = createBaseConversationCreated();
    message.title = object.title ?? "";
    message.createdBy = object.createdBy ?? "";
    message.participantIds = object.participantIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseMessageSent(): MessageSent {
  return { content: "", role: "", sentBy: "" };
}

export const MessageSent = {
  encode(message: MessageSent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.content !== "") {
      writer.uint32(10).string(message.content);
    }
    if (message.role !== "") {
      writer.uint32(18).string(message.role);
    }
    if (message.sentBy !== "") {
      writer.uint32(26).string(message.sentBy);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MessageSent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageSent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.content = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.role = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sentBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageSent {
    return {
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      role: isSet(object.role) ? globalThis.String(object.role) : "",
      sentBy: isSet(object.sentBy) ? globalThis.String(object.sentBy) : "",
    };
  },

  toJSON(message: MessageSent): unknown {
    const obj: any = {};
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.role !== "") {
      obj.role = message.role;
    }
    if (message.sentBy !== "") {
      obj.sentBy = message.sentBy;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MessageSent>, I>>(base?: I): MessageSent {
    return MessageSent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MessageSent>, I>>(object: I): MessageSent {
    const message = createBaseMessageSent();
    message.content = object.content ?? "";
    message.role = object.role ?? "";
    message.sentBy = object.sentBy ?? "";
    return message;
  },
};

function createBaseMessageUpdated(): MessageUpdated {
  return { content: "", updatedBy: "" };
}

export const MessageUpdated = {
  encode(message: MessageUpdated, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.content !== "") {
      writer.uint32(10).string(message.content);
    }
    if (message.updatedBy !== "") {
      writer.uint32(18).string(message.updatedBy);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MessageUpdated {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageUpdated();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.content = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updatedBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageUpdated {
    return {
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      updatedBy: isSet(object.updatedBy) ? globalThis.String(object.updatedBy) : "",
    };
  },

  toJSON(message: MessageUpdated): unknown {
    const obj: any = {};
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.updatedBy !== "") {
      obj.updatedBy = message.updatedBy;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MessageUpdated>, I>>(base?: I): MessageUpdated {
    return MessageUpdated.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MessageUpdated>, I>>(object: I): MessageUpdated {
    const message = createBaseMessageUpdated();
    message.content = object.content ?? "";
    message.updatedBy = object.updatedBy ?? "";
    return message;
  },
};

function createBaseTypingStarted(): TypingStarted {
  return { userId: "" };
}

export const TypingStarted = {
  encode(message: TypingStarted, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TypingStarted {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTypingStarted();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TypingStarted {
    return { userId: isSet(object.userId) ? globalThis.String(object.userId) : "" };
  },

  toJSON(message: TypingStarted): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TypingStarted>, I>>(base?: I): TypingStarted {
    return TypingStarted.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TypingStarted>, I>>(object: I): TypingStarted {
    const message = createBaseTypingStarted();
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseParticipantJoined(): ParticipantJoined {
  return { userId: "", invitedBy: "" };
}

export const ParticipantJoined = {
  encode(message: ParticipantJoined, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.invitedBy !== "") {
      writer.uint32(18).string(message.invitedBy);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ParticipantJoined {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParticipantJoined();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.invitedBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParticipantJoined {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      invitedBy: isSet(object.invitedBy) ? globalThis.String(object.invitedBy) : "",
    };
  },

  toJSON(message: ParticipantJoined): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.invitedBy !== "") {
      obj.invitedBy = message.invitedBy;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ParticipantJoined>, I>>(base?: I): ParticipantJoined {
    return ParticipantJoined.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ParticipantJoined>, I>>(object: I): ParticipantJoined {
    const message = createBaseParticipantJoined();
    message.userId = object.userId ?? "";
    message.invitedBy = object.invitedBy ?? "";
    return message;
  },
};

function createBaseAudioEvent(): AudioEvent {
  return { audioId: "", eventType: 0, ttsStarted: undefined, ttsCompleted: undefined, sttCompleted: undefined };
}

export const AudioEvent = {
  encode(message: AudioEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.audioId !== "") {
      writer.uint32(10).string(message.audioId);
    }
    if (message.eventType !== 0) {
      writer.uint32(16).int32(message.eventType);
    }
    if (message.ttsStarted !== undefined) {
      TTSStarted.encode(message.ttsStarted, writer.uint32(82).fork()).ldelim();
    }
    if (message.ttsCompleted !== undefined) {
      TTSCompleted.encode(message.ttsCompleted, writer.uint32(90).fork()).ldelim();
    }
    if (message.sttCompleted !== undefined) {
      STTCompleted.encode(message.sttCompleted, writer.uint32(98).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AudioEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudioEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.audioId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.eventType = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.ttsStarted = TTSStarted.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.ttsCompleted = TTSCompleted.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.sttCompleted = STTCompleted.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudioEvent {
    return {
      audioId: isSet(object.audioId) ? globalThis.String(object.audioId) : "",
      eventType: isSet(object.eventType) ? audioEventTypeFromJSON(object.eventType) : 0,
      ttsStarted: isSet(object.ttsStarted) ? TTSStarted.fromJSON(object.ttsStarted) : undefined,
      ttsCompleted: isSet(object.ttsCompleted) ? TTSCompleted.fromJSON(object.ttsCompleted) : undefined,
      sttCompleted: isSet(object.sttCompleted) ? STTCompleted.fromJSON(object.sttCompleted) : undefined,
    };
  },

  toJSON(message: AudioEvent): unknown {
    const obj: any = {};
    if (message.audioId !== "") {
      obj.audioId = message.audioId;
    }
    if (message.eventType !== 0) {
      obj.eventType = audioEventTypeToJSON(message.eventType);
    }
    if (message.ttsStarted !== undefined) {
      obj.ttsStarted = TTSStarted.toJSON(message.ttsStarted);
    }
    if (message.ttsCompleted !== undefined) {
      obj.ttsCompleted = TTSCompleted.toJSON(message.ttsCompleted);
    }
    if (message.sttCompleted !== undefined) {
      obj.sttCompleted = STTCompleted.toJSON(message.sttCompleted);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AudioEvent>, I>>(base?: I): AudioEvent {
    return AudioEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AudioEvent>, I>>(object: I): AudioEvent {
    const message = createBaseAudioEvent();
    message.audioId = object.audioId ?? "";
    message.eventType = object.eventType ?? 0;
    message.ttsStarted = (object.ttsStarted !== undefined && object.ttsStarted !== null)
      ? TTSStarted.fromPartial(object.ttsStarted)
      : undefined;
    message.ttsCompleted = (object.ttsCompleted !== undefined && object.ttsCompleted !== null)
      ? TTSCompleted.fromPartial(object.ttsCompleted)
      : undefined;
    message.sttCompleted = (object.sttCompleted !== undefined && object.sttCompleted !== null)
      ? STTCompleted.fromPartial(object.sttCompleted)
      : undefined;
    return message;
  },
};

function createBaseTTSStarted(): TTSStarted {
  return { text: "", voiceId: "" };
}

export const TTSStarted = {
  encode(message: TTSStarted, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    if (message.voiceId !== "") {
      writer.uint32(18).string(message.voiceId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TTSStarted {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTTSStarted();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.voiceId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TTSStarted {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      voiceId: isSet(object.voiceId) ? globalThis.String(object.voiceId) : "",
    };
  },

  toJSON(message: TTSStarted): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.voiceId !== "") {
      obj.voiceId = message.voiceId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TTSStarted>, I>>(base?: I): TTSStarted {
    return TTSStarted.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TTSStarted>, I>>(object: I): TTSStarted {
    const message = createBaseTTSStarted();
    message.text = object.text ?? "";
    message.voiceId = object.voiceId ?? "";
    return message;
  },
};

function createBaseTTSCompleted(): TTSCompleted {
  return { audioUrl: "", durationSeconds: 0 };
}

export const TTSCompleted = {
  encode(message: TTSCompleted, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.audioUrl !== "") {
      writer.uint32(10).string(message.audioUrl);
    }
    if (message.durationSeconds !== 0) {
      writer.uint32(21).float(message.durationSeconds);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TTSCompleted {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTTSCompleted();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.audioUrl = reader.string();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.durationSeconds = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TTSCompleted {
    return {
      audioUrl: isSet(object.audioUrl) ? globalThis.String(object.audioUrl) : "",
      durationSeconds: isSet(object.durationSeconds) ? globalThis.Number(object.durationSeconds) : 0,
    };
  },

  toJSON(message: TTSCompleted): unknown {
    const obj: any = {};
    if (message.audioUrl !== "") {
      obj.audioUrl = message.audioUrl;
    }
    if (message.durationSeconds !== 0) {
      obj.durationSeconds = message.durationSeconds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TTSCompleted>, I>>(base?: I): TTSCompleted {
    return TTSCompleted.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TTSCompleted>, I>>(object: I): TTSCompleted {
    const message = createBaseTTSCompleted();
    message.audioUrl = object.audioUrl ?? "";
    message.durationSeconds = object.durationSeconds ?? 0;
    return message;
  },
};

function createBaseSTTCompleted(): STTCompleted {
  return { transcript: "", confidence: 0 };
}

export const STTCompleted = {
  encode(message: STTCompleted, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.transcript !== "") {
      writer.uint32(10).string(message.transcript);
    }
    if (message.confidence !== 0) {
      writer.uint32(21).float(message.confidence);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): STTCompleted {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSTTCompleted();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transcript = reader.string();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.confidence = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): STTCompleted {
    return {
      transcript: isSet(object.transcript) ? globalThis.String(object.transcript) : "",
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : 0,
    };
  },

  toJSON(message: STTCompleted): unknown {
    const obj: any = {};
    if (message.transcript !== "") {
      obj.transcript = message.transcript;
    }
    if (message.confidence !== 0) {
      obj.confidence = message.confidence;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<STTCompleted>, I>>(base?: I): STTCompleted {
    return STTCompleted.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<STTCompleted>, I>>(object: I): STTCompleted {
    const message = createBaseSTTCompleted();
    message.transcript = object.transcript ?? "";
    message.confidence = object.confidence ?? 0;
    return message;
  },
};

function createBaseUserEvent(): UserEvent {
  return { userId: "", eventType: 0, userCreated: undefined, userLoggedIn: undefined, teamMemberAdded: undefined };
}

export const UserEvent = {
  encode(message: UserEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.eventType !== 0) {
      writer.uint32(16).int32(message.eventType);
    }
    if (message.userCreated !== undefined) {
      UserCreated.encode(message.userCreated, writer.uint32(82).fork()).ldelim();
    }
    if (message.userLoggedIn !== undefined) {
      UserLoggedIn.encode(message.userLoggedIn, writer.uint32(90).fork()).ldelim();
    }
    if (message.teamMemberAdded !== undefined) {
      TeamMemberAdded.encode(message.teamMemberAdded, writer.uint32(98).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.eventType = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.userCreated = UserCreated.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.userLoggedIn = UserLoggedIn.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.teamMemberAdded = TeamMemberAdded.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserEvent {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      eventType: isSet(object.eventType) ? userEventTypeFromJSON(object.eventType) : 0,
      userCreated: isSet(object.userCreated) ? UserCreated.fromJSON(object.userCreated) : undefined,
      userLoggedIn: isSet(object.userLoggedIn) ? UserLoggedIn.fromJSON(object.userLoggedIn) : undefined,
      teamMemberAdded: isSet(object.teamMemberAdded) ? TeamMemberAdded.fromJSON(object.teamMemberAdded) : undefined,
    };
  },

  toJSON(message: UserEvent): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.eventType !== 0) {
      obj.eventType = userEventTypeToJSON(message.eventType);
    }
    if (message.userCreated !== undefined) {
      obj.userCreated = UserCreated.toJSON(message.userCreated);
    }
    if (message.userLoggedIn !== undefined) {
      obj.userLoggedIn = UserLoggedIn.toJSON(message.userLoggedIn);
    }
    if (message.teamMemberAdded !== undefined) {
      obj.teamMemberAdded = TeamMemberAdded.toJSON(message.teamMemberAdded);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserEvent>, I>>(base?: I): UserEvent {
    return UserEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserEvent>, I>>(object: I): UserEvent {
    const message = createBaseUserEvent();
    message.userId = object.userId ?? "";
    message.eventType = object.eventType ?? 0;
    message.userCreated = (object.userCreated !== undefined && object.userCreated !== null)
      ? UserCreated.fromPartial(object.userCreated)
      : undefined;
    message.userLoggedIn = (object.userLoggedIn !== undefined && object.userLoggedIn !== null)
      ? UserLoggedIn.fromPartial(object.userLoggedIn)
      : undefined;
    message.teamMemberAdded = (object.teamMemberAdded !== undefined && object.teamMemberAdded !== null)
      ? TeamMemberAdded.fromPartial(object.teamMemberAdded)
      : undefined;
    return message;
  },
};

function createBaseUserCreated(): UserCreated {
  return { email: "", name: "" };
}

export const UserCreated = {
  encode(message: UserCreated, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserCreated {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserCreated();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserCreated {
    return {
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: UserCreated): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserCreated>, I>>(base?: I): UserCreated {
    return UserCreated.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserCreated>, I>>(object: I): UserCreated {
    const message = createBaseUserCreated();
    message.email = object.email ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUserLoggedIn(): UserLoggedIn {
  return { ipAddress: "", userAgent: "" };
}

export const UserLoggedIn = {
  encode(message: UserLoggedIn, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ipAddress !== "") {
      writer.uint32(10).string(message.ipAddress);
    }
    if (message.userAgent !== "") {
      writer.uint32(18).string(message.userAgent);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserLoggedIn {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserLoggedIn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ipAddress = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.userAgent = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserLoggedIn {
    return {
      ipAddress: isSet(object.ipAddress) ? globalThis.String(object.ipAddress) : "",
      userAgent: isSet(object.userAgent) ? globalThis.String(object.userAgent) : "",
    };
  },

  toJSON(message: UserLoggedIn): unknown {
    const obj: any = {};
    if (message.ipAddress !== "") {
      obj.ipAddress = message.ipAddress;
    }
    if (message.userAgent !== "") {
      obj.userAgent = message.userAgent;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserLoggedIn>, I>>(base?: I): UserLoggedIn {
    return UserLoggedIn.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserLoggedIn>, I>>(object: I): UserLoggedIn {
    const message = createBaseUserLoggedIn();
    message.ipAddress = object.ipAddress ?? "";
    message.userAgent = object.userAgent ?? "";
    return message;
  },
};

function createBaseTeamMemberAdded(): TeamMemberAdded {
  return { teamId: "", role: "", addedBy: "" };
}

export const TeamMemberAdded = {
  encode(message: TeamMemberAdded, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.teamId !== "") {
      writer.uint32(10).string(message.teamId);
    }
    if (message.role !== "") {
      writer.uint32(18).string(message.role);
    }
    if (message.addedBy !== "") {
      writer.uint32(26).string(message.addedBy);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TeamMemberAdded {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTeamMemberAdded();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.teamId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.role = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.addedBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TeamMemberAdded {
    return {
      teamId: isSet(object.teamId) ? globalThis.String(object.teamId) : "",
      role: isSet(object.role) ? globalThis.String(object.role) : "",
      addedBy: isSet(object.addedBy) ? globalThis.String(object.addedBy) : "",
    };
  },

  toJSON(message: TeamMemberAdded): unknown {
    const obj: any = {};
    if (message.teamId !== "") {
      obj.teamId = message.teamId;
    }
    if (message.role !== "") {
      obj.role = message.role;
    }
    if (message.addedBy !== "") {
      obj.addedBy = message.addedBy;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TeamMemberAdded>, I>>(base?: I): TeamMemberAdded {
    return TeamMemberAdded.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TeamMemberAdded>, I>>(object: I): TeamMemberAdded {
    const message = createBaseTeamMemberAdded();
    message.teamId = object.teamId ?? "";
    message.role = object.role ?? "";
    message.addedBy = object.addedBy ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000).toString();
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (globalThis.Number(t.seconds) || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToString(long: Long) {
  return long.toString();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
