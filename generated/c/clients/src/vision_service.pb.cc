// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: vision_service.proto

#include "vision_service.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace multimodal {
PROTOBUF_CONSTEXPR VisionInferenceRequest_ParametersEntry_DoNotUse::VisionInferenceRequest_ParametersEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct VisionInferenceRequest_ParametersEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VisionInferenceRequest_ParametersEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VisionInferenceRequest_ParametersEntry_DoNotUseDefaultTypeInternal() {}
  union {
    VisionInferenceRequest_ParametersEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VisionInferenceRequest_ParametersEntry_DoNotUseDefaultTypeInternal _VisionInferenceRequest_ParametersEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR VisionInferenceRequest::VisionInferenceRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.parameters_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.image_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.model_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.prompt_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.analysis_type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.max_tokens_)*/0
  , /*decltype(_impl_.temperature_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct VisionInferenceRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VisionInferenceRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VisionInferenceRequestDefaultTypeInternal() {}
  union {
    VisionInferenceRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VisionInferenceRequestDefaultTypeInternal _VisionInferenceRequest_default_instance_;
PROTOBUF_CONSTEXPR VisionInferenceResponse_MetadataEntry_DoNotUse::VisionInferenceResponse_MetadataEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct VisionInferenceResponse_MetadataEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VisionInferenceResponse_MetadataEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VisionInferenceResponse_MetadataEntry_DoNotUseDefaultTypeInternal() {}
  union {
    VisionInferenceResponse_MetadataEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VisionInferenceResponse_MetadataEntry_DoNotUseDefaultTypeInternal _VisionInferenceResponse_MetadataEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR VisionInferenceResponse::VisionInferenceResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.metadata_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.ui_elements_)*/{}
  , /*decltype(_impl_.tags_)*/{}
  , /*decltype(_impl_.description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.model_used_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.extracted_text_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.error_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.confidence_)*/0
  , /*decltype(_impl_.processing_time_)*/0
  , /*decltype(_impl_.success_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct VisionInferenceResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VisionInferenceResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VisionInferenceResponseDefaultTypeInternal() {}
  union {
    VisionInferenceResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VisionInferenceResponseDefaultTypeInternal _VisionInferenceResponse_default_instance_;
PROTOBUF_CONSTEXPR UIElement_PropertiesEntry_DoNotUse::UIElement_PropertiesEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct UIElement_PropertiesEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UIElement_PropertiesEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UIElement_PropertiesEntry_DoNotUseDefaultTypeInternal() {}
  union {
    UIElement_PropertiesEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UIElement_PropertiesEntry_DoNotUseDefaultTypeInternal _UIElement_PropertiesEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR UIElement::UIElement(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.properties_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.bounds_)*/nullptr
  , /*decltype(_impl_.confidence_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UIElementDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UIElementDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UIElementDefaultTypeInternal() {}
  union {
    UIElement _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UIElementDefaultTypeInternal _UIElement_default_instance_;
PROTOBUF_CONSTEXPR ElementBounds::ElementBounds(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_.width_)*/0
  , /*decltype(_impl_.height_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ElementBoundsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ElementBoundsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ElementBoundsDefaultTypeInternal() {}
  union {
    ElementBounds _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ElementBoundsDefaultTypeInternal _ElementBounds_default_instance_;
PROTOBUF_CONSTEXPR ModelsResponse::ModelsResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.models_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ModelsResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModelsResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModelsResponseDefaultTypeInternal() {}
  union {
    ModelsResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelsResponseDefaultTypeInternal _ModelsResponse_default_instance_;
PROTOBUF_CONSTEXPR ModelInfo::ModelInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.supported_types_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.display_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.memory_usage_mb_)*/int64_t{0}
  , /*decltype(_impl_.available_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ModelInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModelInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModelInfoDefaultTypeInternal() {}
  union {
    ModelInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelInfoDefaultTypeInternal _ModelInfo_default_instance_;
PROTOBUF_CONSTEXPR ModelMetricsRequest::ModelMetricsRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.model_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ModelMetricsRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModelMetricsRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModelMetricsRequestDefaultTypeInternal() {}
  union {
    ModelMetricsRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelMetricsRequestDefaultTypeInternal _ModelMetricsRequest_default_instance_;
PROTOBUF_CONSTEXPR ModelMetricsResponse_AdditionalMetricsEntry_DoNotUse::ModelMetricsResponse_AdditionalMetricsEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct ModelMetricsResponse_AdditionalMetricsEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModelMetricsResponse_AdditionalMetricsEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModelMetricsResponse_AdditionalMetricsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    ModelMetricsResponse_AdditionalMetricsEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelMetricsResponse_AdditionalMetricsEntry_DoNotUseDefaultTypeInternal _ModelMetricsResponse_AdditionalMetricsEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR ModelMetricsResponse::ModelMetricsResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.additional_metrics_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.model_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.total_inferences_)*/int64_t{0}
  , /*decltype(_impl_.average_processing_time_)*/0
  , /*decltype(_impl_.average_confidence_)*/0
  , /*decltype(_impl_.memory_usage_mb_)*/int64_t{0}
  , /*decltype(_impl_.gpu_utilization_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ModelMetricsResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModelMetricsResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModelMetricsResponseDefaultTypeInternal() {}
  union {
    ModelMetricsResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelMetricsResponseDefaultTypeInternal _ModelMetricsResponse_default_instance_;
PROTOBUF_CONSTEXPR Empty::Empty(
    ::_pbi::ConstantInitialized) {}
struct EmptyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EmptyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EmptyDefaultTypeInternal() {}
  union {
    Empty _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EmptyDefaultTypeInternal _Empty_default_instance_;
PROTOBUF_CONSTEXPR HealthResponse_DetailsEntry_DoNotUse::HealthResponse_DetailsEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct HealthResponse_DetailsEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HealthResponse_DetailsEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HealthResponse_DetailsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    HealthResponse_DetailsEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HealthResponse_DetailsEntry_DoNotUseDefaultTypeInternal _HealthResponse_DetailsEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR HealthResponse::HealthResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.details_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.status_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.uptime_seconds_)*/int64_t{0}
  , /*decltype(_impl_.healthy_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct HealthResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HealthResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HealthResponseDefaultTypeInternal() {}
  union {
    HealthResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HealthResponseDefaultTypeInternal _HealthResponse_default_instance_;
}  // namespace multimodal
static ::_pb::Metadata file_level_metadata_vision_5fservice_2eproto[15];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_vision_5fservice_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_vision_5fservice_2eproto = nullptr;

const uint32_t TableStruct_vision_5fservice_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::multimodal::VisionInferenceRequest_ParametersEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::multimodal::VisionInferenceRequest_ParametersEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::multimodal::VisionInferenceRequest_ParametersEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::multimodal::VisionInferenceRequest_ParametersEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::multimodal::VisionInferenceRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::multimodal::VisionInferenceRequest, _impl_.image_data_),
  PROTOBUF_FIELD_OFFSET(::multimodal::VisionInferenceRequest, _impl_.model_),
  PROTOBUF_FIELD_OFFSET(::multimodal::VisionInferenceRequest, _impl_.prompt_),
  PROTOBUF_FIELD_OFFSET(::multimodal::VisionInferenceRequest, _impl_.analysis_type_),
  PROTOBUF_FIELD_OFFSET(::multimodal::VisionInferenceRequest, _impl_.max_tokens_),
  PROTOBUF_FIELD_OFFSET(::multimodal::VisionInferenceRequest, _impl_.temperature_),
  PROTOBUF_FIELD_OFFSET(::multimodal::VisionInferenceRequest, _impl_.parameters_),
  PROTOBUF_FIELD_OFFSET(::multimodal::VisionInferenceResponse_MetadataEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::multimodal::VisionInferenceResponse_MetadataEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::multimodal::VisionInferenceResponse_MetadataEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::multimodal::VisionInferenceResponse_MetadataEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::multimodal::VisionInferenceResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::multimodal::VisionInferenceResponse, _impl_.description_),
  PROTOBUF_FIELD_OFFSET(::multimodal::VisionInferenceResponse, _impl_.confidence_),
  PROTOBUF_FIELD_OFFSET(::multimodal::VisionInferenceResponse, _impl_.model_used_),
  PROTOBUF_FIELD_OFFSET(::multimodal::VisionInferenceResponse, _impl_.processing_time_),
  PROTOBUF_FIELD_OFFSET(::multimodal::VisionInferenceResponse, _impl_.metadata_),
  PROTOBUF_FIELD_OFFSET(::multimodal::VisionInferenceResponse, _impl_.extracted_text_),
  PROTOBUF_FIELD_OFFSET(::multimodal::VisionInferenceResponse, _impl_.ui_elements_),
  PROTOBUF_FIELD_OFFSET(::multimodal::VisionInferenceResponse, _impl_.tags_),
  PROTOBUF_FIELD_OFFSET(::multimodal::VisionInferenceResponse, _impl_.error_),
  PROTOBUF_FIELD_OFFSET(::multimodal::VisionInferenceResponse, _impl_.success_),
  PROTOBUF_FIELD_OFFSET(::multimodal::UIElement_PropertiesEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::multimodal::UIElement_PropertiesEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::multimodal::UIElement_PropertiesEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::multimodal::UIElement_PropertiesEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::multimodal::UIElement, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::multimodal::UIElement, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::multimodal::UIElement, _impl_.confidence_),
  PROTOBUF_FIELD_OFFSET(::multimodal::UIElement, _impl_.bounds_),
  PROTOBUF_FIELD_OFFSET(::multimodal::UIElement, _impl_.properties_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::multimodal::ElementBounds, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::multimodal::ElementBounds, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::multimodal::ElementBounds, _impl_.y_),
  PROTOBUF_FIELD_OFFSET(::multimodal::ElementBounds, _impl_.width_),
  PROTOBUF_FIELD_OFFSET(::multimodal::ElementBounds, _impl_.height_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::multimodal::ModelsResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::multimodal::ModelsResponse, _impl_.models_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::multimodal::ModelInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::multimodal::ModelInfo, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::multimodal::ModelInfo, _impl_.display_name_),
  PROTOBUF_FIELD_OFFSET(::multimodal::ModelInfo, _impl_.description_),
  PROTOBUF_FIELD_OFFSET(::multimodal::ModelInfo, _impl_.available_),
  PROTOBUF_FIELD_OFFSET(::multimodal::ModelInfo, _impl_.memory_usage_mb_),
  PROTOBUF_FIELD_OFFSET(::multimodal::ModelInfo, _impl_.supported_types_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::multimodal::ModelMetricsRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::multimodal::ModelMetricsRequest, _impl_.model_),
  PROTOBUF_FIELD_OFFSET(::multimodal::ModelMetricsResponse_AdditionalMetricsEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::multimodal::ModelMetricsResponse_AdditionalMetricsEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::multimodal::ModelMetricsResponse_AdditionalMetricsEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::multimodal::ModelMetricsResponse_AdditionalMetricsEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::multimodal::ModelMetricsResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::multimodal::ModelMetricsResponse, _impl_.model_),
  PROTOBUF_FIELD_OFFSET(::multimodal::ModelMetricsResponse, _impl_.total_inferences_),
  PROTOBUF_FIELD_OFFSET(::multimodal::ModelMetricsResponse, _impl_.average_processing_time_),
  PROTOBUF_FIELD_OFFSET(::multimodal::ModelMetricsResponse, _impl_.average_confidence_),
  PROTOBUF_FIELD_OFFSET(::multimodal::ModelMetricsResponse, _impl_.memory_usage_mb_),
  PROTOBUF_FIELD_OFFSET(::multimodal::ModelMetricsResponse, _impl_.gpu_utilization_),
  PROTOBUF_FIELD_OFFSET(::multimodal::ModelMetricsResponse, _impl_.additional_metrics_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::multimodal::Empty, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::multimodal::HealthResponse_DetailsEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::multimodal::HealthResponse_DetailsEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::multimodal::HealthResponse_DetailsEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::multimodal::HealthResponse_DetailsEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::multimodal::HealthResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::multimodal::HealthResponse, _impl_.healthy_),
  PROTOBUF_FIELD_OFFSET(::multimodal::HealthResponse, _impl_.status_),
  PROTOBUF_FIELD_OFFSET(::multimodal::HealthResponse, _impl_.details_),
  PROTOBUF_FIELD_OFFSET(::multimodal::HealthResponse, _impl_.uptime_seconds_),
  PROTOBUF_FIELD_OFFSET(::multimodal::HealthResponse, _impl_.version_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 8, -1, sizeof(::multimodal::VisionInferenceRequest_ParametersEntry_DoNotUse)},
  { 10, -1, -1, sizeof(::multimodal::VisionInferenceRequest)},
  { 23, 31, -1, sizeof(::multimodal::VisionInferenceResponse_MetadataEntry_DoNotUse)},
  { 33, -1, -1, sizeof(::multimodal::VisionInferenceResponse)},
  { 49, 57, -1, sizeof(::multimodal::UIElement_PropertiesEntry_DoNotUse)},
  { 59, -1, -1, sizeof(::multimodal::UIElement)},
  { 69, -1, -1, sizeof(::multimodal::ElementBounds)},
  { 79, -1, -1, sizeof(::multimodal::ModelsResponse)},
  { 86, -1, -1, sizeof(::multimodal::ModelInfo)},
  { 98, -1, -1, sizeof(::multimodal::ModelMetricsRequest)},
  { 105, 113, -1, sizeof(::multimodal::ModelMetricsResponse_AdditionalMetricsEntry_DoNotUse)},
  { 115, -1, -1, sizeof(::multimodal::ModelMetricsResponse)},
  { 128, -1, -1, sizeof(::multimodal::Empty)},
  { 134, 142, -1, sizeof(::multimodal::HealthResponse_DetailsEntry_DoNotUse)},
  { 144, -1, -1, sizeof(::multimodal::HealthResponse)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::multimodal::_VisionInferenceRequest_ParametersEntry_DoNotUse_default_instance_._instance,
  &::multimodal::_VisionInferenceRequest_default_instance_._instance,
  &::multimodal::_VisionInferenceResponse_MetadataEntry_DoNotUse_default_instance_._instance,
  &::multimodal::_VisionInferenceResponse_default_instance_._instance,
  &::multimodal::_UIElement_PropertiesEntry_DoNotUse_default_instance_._instance,
  &::multimodal::_UIElement_default_instance_._instance,
  &::multimodal::_ElementBounds_default_instance_._instance,
  &::multimodal::_ModelsResponse_default_instance_._instance,
  &::multimodal::_ModelInfo_default_instance_._instance,
  &::multimodal::_ModelMetricsRequest_default_instance_._instance,
  &::multimodal::_ModelMetricsResponse_AdditionalMetricsEntry_DoNotUse_default_instance_._instance,
  &::multimodal::_ModelMetricsResponse_default_instance_._instance,
  &::multimodal::_Empty_default_instance_._instance,
  &::multimodal::_HealthResponse_DetailsEntry_DoNotUse_default_instance_._instance,
  &::multimodal::_HealthResponse_default_instance_._instance,
};

const char descriptor_table_protodef_vision_5fservice_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\024vision_service.proto\022\nmultimodal\032\014comm"
  "on.proto\"\206\002\n\026VisionInferenceRequest\022\022\n\ni"
  "mage_data\030\001 \001(\014\022\r\n\005model\030\002 \001(\t\022\016\n\006prompt"
  "\030\003 \001(\t\022\025\n\ranalysis_type\030\004 \001(\t\022\022\n\nmax_tok"
  "ens\030\005 \001(\005\022\023\n\013temperature\030\006 \001(\002\022F\n\nparame"
  "ters\030\007 \003(\01322.multimodal.VisionInferenceR"
  "equest.ParametersEntry\0321\n\017ParametersEntr"
  "y\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:\0028\001\"\327\002\n\027Vi"
  "sionInferenceResponse\022\023\n\013description\030\001 \001"
  "(\t\022\022\n\nconfidence\030\002 \001(\001\022\022\n\nmodel_used\030\003 \001"
  "(\t\022\027\n\017processing_time\030\004 \001(\001\022C\n\010metadata\030"
  "\005 \003(\01321.multimodal.VisionInferenceRespon"
  "se.MetadataEntry\022\026\n\016extracted_text\030\006 \001(\t"
  "\022*\n\013ui_elements\030\007 \003(\0132\025.multimodal.UIEle"
  "ment\022\014\n\004tags\030\010 \003(\t\022\r\n\005error\030\t \001(\t\022\017\n\007suc"
  "cess\030\n \001(\010\032/\n\rMetadataEntry\022\013\n\003key\030\001 \001(\t"
  "\022\r\n\005value\030\002 \001(\t:\0028\001\"\306\001\n\tUIElement\022\014\n\004typ"
  "e\030\001 \001(\t\022\022\n\nconfidence\030\002 \001(\001\022)\n\006bounds\030\003 "
  "\001(\0132\031.multimodal.ElementBounds\0229\n\nproper"
  "ties\030\004 \003(\0132%.multimodal.UIElement.Proper"
  "tiesEntry\0321\n\017PropertiesEntry\022\013\n\003key\030\001 \001("
  "\t\022\r\n\005value\030\002 \001(\t:\0028\001\"D\n\rElementBounds\022\t\n"
  "\001x\030\001 \001(\005\022\t\n\001y\030\002 \001(\005\022\r\n\005width\030\003 \001(\005\022\016\n\006he"
  "ight\030\004 \001(\005\"7\n\016ModelsResponse\022%\n\006models\030\001"
  " \003(\0132\025.multimodal.ModelInfo\"\211\001\n\tModelInf"
  "o\022\014\n\004name\030\001 \001(\t\022\024\n\014display_name\030\002 \001(\t\022\023\n"
  "\013description\030\003 \001(\t\022\021\n\tavailable\030\004 \001(\010\022\027\n"
  "\017memory_usage_mb\030\005 \001(\003\022\027\n\017supported_type"
  "s\030\006 \003(\t\"$\n\023ModelMetricsRequest\022\r\n\005model\030"
  "\001 \001(\t\"\275\002\n\024ModelMetricsResponse\022\r\n\005model\030"
  "\001 \001(\t\022\030\n\020total_inferences\030\002 \001(\003\022\037\n\027avera"
  "ge_processing_time\030\003 \001(\001\022\032\n\022average_conf"
  "idence\030\004 \001(\001\022\027\n\017memory_usage_mb\030\005 \001(\003\022\027\n"
  "\017gpu_utilization\030\006 \001(\001\022S\n\022additional_met"
  "rics\030\007 \003(\01327.multimodal.ModelMetricsResp"
  "onse.AdditionalMetricsEntry\0328\n\026Additiona"
  "lMetricsEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001("
  "\001:\0028\001\"\007\n\005Empty\"\304\001\n\016HealthResponse\022\017\n\007hea"
  "lthy\030\001 \001(\010\022\016\n\006status\030\002 \001(\t\0228\n\007details\030\003 "
  "\003(\0132\'.multimodal.HealthResponse.DetailsE"
  "ntry\022\026\n\016uptime_seconds\030\004 \001(\003\022\017\n\007version\030"
  "\005 \001(\t\032.\n\014DetailsEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005va"
  "lue\030\002 \001(\t:\0028\0012\270\002\n\rVisionService\022P\n\005Infer"
  "\022\".multimodal.VisionInferenceRequest\032#.m"
  "ultimodal.VisionInferenceResponse\022C\n\022Get"
  "AvailableModels\022\021.multimodal.Empty\032\032.mul"
  "timodal.ModelsResponse\022:\n\tGetHealth\022\021.mu"
  "ltimodal.Empty\032\032.multimodal.HealthRespon"
  "se\022T\n\017GetModelMetrics\022\037.multimodal.Model"
  "MetricsRequest\032 .multimodal.ModelMetrics"
  "ResponseB4\n\034com.unhinged.multimodal.grpc"
  "B\022VisionServiceProtoP\001b\006proto3"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_vision_5fservice_2eproto_deps[1] = {
  &::descriptor_table_common_2eproto,
};
static ::_pbi::once_flag descriptor_table_vision_5fservice_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_vision_5fservice_2eproto = {
    false, false, 2070, descriptor_table_protodef_vision_5fservice_2eproto,
    "vision_service.proto",
    &descriptor_table_vision_5fservice_2eproto_once, descriptor_table_vision_5fservice_2eproto_deps, 1, 15,
    schemas, file_default_instances, TableStruct_vision_5fservice_2eproto::offsets,
    file_level_metadata_vision_5fservice_2eproto, file_level_enum_descriptors_vision_5fservice_2eproto,
    file_level_service_descriptors_vision_5fservice_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_vision_5fservice_2eproto_getter() {
  return &descriptor_table_vision_5fservice_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_vision_5fservice_2eproto(&descriptor_table_vision_5fservice_2eproto);
namespace multimodal {

// ===================================================================

VisionInferenceRequest_ParametersEntry_DoNotUse::VisionInferenceRequest_ParametersEntry_DoNotUse() {}
VisionInferenceRequest_ParametersEntry_DoNotUse::VisionInferenceRequest_ParametersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void VisionInferenceRequest_ParametersEntry_DoNotUse::MergeFrom(const VisionInferenceRequest_ParametersEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata VisionInferenceRequest_ParametersEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vision_5fservice_2eproto_getter, &descriptor_table_vision_5fservice_2eproto_once,
      file_level_metadata_vision_5fservice_2eproto[0]);
}

// ===================================================================

class VisionInferenceRequest::_Internal {
 public:
};

VisionInferenceRequest::VisionInferenceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &VisionInferenceRequest::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:multimodal.VisionInferenceRequest)
}
VisionInferenceRequest::VisionInferenceRequest(const VisionInferenceRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VisionInferenceRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_.parameters_)*/{}
    , decltype(_impl_.image_data_){}
    , decltype(_impl_.model_){}
    , decltype(_impl_.prompt_){}
    , decltype(_impl_.analysis_type_){}
    , decltype(_impl_.max_tokens_){}
    , decltype(_impl_.temperature_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.parameters_.MergeFrom(from._impl_.parameters_);
  _impl_.image_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.image_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_image_data().empty()) {
    _this->_impl_.image_data_.Set(from._internal_image_data(), 
      _this->GetArenaForAllocation());
  }
  _impl_.model_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.model_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_model().empty()) {
    _this->_impl_.model_.Set(from._internal_model(), 
      _this->GetArenaForAllocation());
  }
  _impl_.prompt_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.prompt_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_prompt().empty()) {
    _this->_impl_.prompt_.Set(from._internal_prompt(), 
      _this->GetArenaForAllocation());
  }
  _impl_.analysis_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.analysis_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_analysis_type().empty()) {
    _this->_impl_.analysis_type_.Set(from._internal_analysis_type(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.max_tokens_, &from._impl_.max_tokens_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.temperature_) -
    reinterpret_cast<char*>(&_impl_.max_tokens_)) + sizeof(_impl_.temperature_));
  // @@protoc_insertion_point(copy_constructor:multimodal.VisionInferenceRequest)
}

inline void VisionInferenceRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_.parameters_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.image_data_){}
    , decltype(_impl_.model_){}
    , decltype(_impl_.prompt_){}
    , decltype(_impl_.analysis_type_){}
    , decltype(_impl_.max_tokens_){0}
    , decltype(_impl_.temperature_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.image_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.image_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.model_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.model_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.prompt_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.prompt_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.analysis_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.analysis_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

VisionInferenceRequest::~VisionInferenceRequest() {
  // @@protoc_insertion_point(destructor:multimodal.VisionInferenceRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void VisionInferenceRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.parameters_.Destruct();
  _impl_.parameters_.~MapField();
  _impl_.image_data_.Destroy();
  _impl_.model_.Destroy();
  _impl_.prompt_.Destroy();
  _impl_.analysis_type_.Destroy();
}

void VisionInferenceRequest::ArenaDtor(void* object) {
  VisionInferenceRequest* _this = reinterpret_cast< VisionInferenceRequest* >(object);
  _this->_impl_.parameters_.Destruct();
}
void VisionInferenceRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VisionInferenceRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:multimodal.VisionInferenceRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.parameters_.Clear();
  _impl_.image_data_.ClearToEmpty();
  _impl_.model_.ClearToEmpty();
  _impl_.prompt_.ClearToEmpty();
  _impl_.analysis_type_.ClearToEmpty();
  ::memset(&_impl_.max_tokens_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.temperature_) -
      reinterpret_cast<char*>(&_impl_.max_tokens_)) + sizeof(_impl_.temperature_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VisionInferenceRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes image_data = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_image_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string model = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_model();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "multimodal.VisionInferenceRequest.model"));
        } else
          goto handle_unusual;
        continue;
      // string prompt = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_prompt();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "multimodal.VisionInferenceRequest.prompt"));
        } else
          goto handle_unusual;
        continue;
      // string analysis_type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_analysis_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "multimodal.VisionInferenceRequest.analysis_type"));
        } else
          goto handle_unusual;
        continue;
      // int32 max_tokens = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.max_tokens_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float temperature = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _impl_.temperature_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // map<string, string> parameters = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.parameters_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VisionInferenceRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:multimodal.VisionInferenceRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes image_data = 1;
  if (!this->_internal_image_data().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_image_data(), target);
  }

  // string model = 2;
  if (!this->_internal_model().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_model().data(), static_cast<int>(this->_internal_model().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "multimodal.VisionInferenceRequest.model");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_model(), target);
  }

  // string prompt = 3;
  if (!this->_internal_prompt().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_prompt().data(), static_cast<int>(this->_internal_prompt().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "multimodal.VisionInferenceRequest.prompt");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_prompt(), target);
  }

  // string analysis_type = 4;
  if (!this->_internal_analysis_type().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_analysis_type().data(), static_cast<int>(this->_internal_analysis_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "multimodal.VisionInferenceRequest.analysis_type");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_analysis_type(), target);
  }

  // int32 max_tokens = 5;
  if (this->_internal_max_tokens() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_max_tokens(), target);
  }

  // float temperature = 6;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_temperature = this->_internal_temperature();
  uint32_t raw_temperature;
  memcpy(&raw_temperature, &tmp_temperature, sizeof(tmp_temperature));
  if (raw_temperature != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(6, this->_internal_temperature(), target);
  }

  // map<string, string> parameters = 7;
  if (!this->_internal_parameters().empty()) {
    using MapType = ::_pb::Map<std::string, std::string>;
    using WireHelper = VisionInferenceRequest_ParametersEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_parameters();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "multimodal.VisionInferenceRequest.ParametersEntry.key");
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.second.data(), static_cast<int>(entry.second.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "multimodal.VisionInferenceRequest.ParametersEntry.value");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(7, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(7, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:multimodal.VisionInferenceRequest)
  return target;
}

size_t VisionInferenceRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:multimodal.VisionInferenceRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, string> parameters = 7;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_parameters_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_parameters().begin();
      it != this->_internal_parameters().end(); ++it) {
    total_size += VisionInferenceRequest_ParametersEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // bytes image_data = 1;
  if (!this->_internal_image_data().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_image_data());
  }

  // string model = 2;
  if (!this->_internal_model().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_model());
  }

  // string prompt = 3;
  if (!this->_internal_prompt().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_prompt());
  }

  // string analysis_type = 4;
  if (!this->_internal_analysis_type().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_analysis_type());
  }

  // int32 max_tokens = 5;
  if (this->_internal_max_tokens() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_max_tokens());
  }

  // float temperature = 6;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_temperature = this->_internal_temperature();
  uint32_t raw_temperature;
  memcpy(&raw_temperature, &tmp_temperature, sizeof(tmp_temperature));
  if (raw_temperature != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VisionInferenceRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VisionInferenceRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VisionInferenceRequest::GetClassData() const { return &_class_data_; }


void VisionInferenceRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VisionInferenceRequest*>(&to_msg);
  auto& from = static_cast<const VisionInferenceRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:multimodal.VisionInferenceRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.parameters_.MergeFrom(from._impl_.parameters_);
  if (!from._internal_image_data().empty()) {
    _this->_internal_set_image_data(from._internal_image_data());
  }
  if (!from._internal_model().empty()) {
    _this->_internal_set_model(from._internal_model());
  }
  if (!from._internal_prompt().empty()) {
    _this->_internal_set_prompt(from._internal_prompt());
  }
  if (!from._internal_analysis_type().empty()) {
    _this->_internal_set_analysis_type(from._internal_analysis_type());
  }
  if (from._internal_max_tokens() != 0) {
    _this->_internal_set_max_tokens(from._internal_max_tokens());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_temperature = from._internal_temperature();
  uint32_t raw_temperature;
  memcpy(&raw_temperature, &tmp_temperature, sizeof(tmp_temperature));
  if (raw_temperature != 0) {
    _this->_internal_set_temperature(from._internal_temperature());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VisionInferenceRequest::CopyFrom(const VisionInferenceRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:multimodal.VisionInferenceRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VisionInferenceRequest::IsInitialized() const {
  return true;
}

void VisionInferenceRequest::InternalSwap(VisionInferenceRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.parameters_.InternalSwap(&other->_impl_.parameters_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.image_data_, lhs_arena,
      &other->_impl_.image_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.model_, lhs_arena,
      &other->_impl_.model_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.prompt_, lhs_arena,
      &other->_impl_.prompt_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.analysis_type_, lhs_arena,
      &other->_impl_.analysis_type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VisionInferenceRequest, _impl_.temperature_)
      + sizeof(VisionInferenceRequest::_impl_.temperature_)
      - PROTOBUF_FIELD_OFFSET(VisionInferenceRequest, _impl_.max_tokens_)>(
          reinterpret_cast<char*>(&_impl_.max_tokens_),
          reinterpret_cast<char*>(&other->_impl_.max_tokens_));
}

::PROTOBUF_NAMESPACE_ID::Metadata VisionInferenceRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vision_5fservice_2eproto_getter, &descriptor_table_vision_5fservice_2eproto_once,
      file_level_metadata_vision_5fservice_2eproto[1]);
}

// ===================================================================

VisionInferenceResponse_MetadataEntry_DoNotUse::VisionInferenceResponse_MetadataEntry_DoNotUse() {}
VisionInferenceResponse_MetadataEntry_DoNotUse::VisionInferenceResponse_MetadataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void VisionInferenceResponse_MetadataEntry_DoNotUse::MergeFrom(const VisionInferenceResponse_MetadataEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata VisionInferenceResponse_MetadataEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vision_5fservice_2eproto_getter, &descriptor_table_vision_5fservice_2eproto_once,
      file_level_metadata_vision_5fservice_2eproto[2]);
}

// ===================================================================

class VisionInferenceResponse::_Internal {
 public:
};

VisionInferenceResponse::VisionInferenceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &VisionInferenceResponse::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:multimodal.VisionInferenceResponse)
}
VisionInferenceResponse::VisionInferenceResponse(const VisionInferenceResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VisionInferenceResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_.metadata_)*/{}
    , decltype(_impl_.ui_elements_){from._impl_.ui_elements_}
    , decltype(_impl_.tags_){from._impl_.tags_}
    , decltype(_impl_.description_){}
    , decltype(_impl_.model_used_){}
    , decltype(_impl_.extracted_text_){}
    , decltype(_impl_.error_){}
    , decltype(_impl_.confidence_){}
    , decltype(_impl_.processing_time_){}
    , decltype(_impl_.success_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.metadata_.MergeFrom(from._impl_.metadata_);
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_description().empty()) {
    _this->_impl_.description_.Set(from._internal_description(), 
      _this->GetArenaForAllocation());
  }
  _impl_.model_used_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.model_used_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_model_used().empty()) {
    _this->_impl_.model_used_.Set(from._internal_model_used(), 
      _this->GetArenaForAllocation());
  }
  _impl_.extracted_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.extracted_text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_extracted_text().empty()) {
    _this->_impl_.extracted_text_.Set(from._internal_extracted_text(), 
      _this->GetArenaForAllocation());
  }
  _impl_.error_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.error_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_error().empty()) {
    _this->_impl_.error_.Set(from._internal_error(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.confidence_, &from._impl_.confidence_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.success_) -
    reinterpret_cast<char*>(&_impl_.confidence_)) + sizeof(_impl_.success_));
  // @@protoc_insertion_point(copy_constructor:multimodal.VisionInferenceResponse)
}

inline void VisionInferenceResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_.metadata_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.ui_elements_){arena}
    , decltype(_impl_.tags_){arena}
    , decltype(_impl_.description_){}
    , decltype(_impl_.model_used_){}
    , decltype(_impl_.extracted_text_){}
    , decltype(_impl_.error_){}
    , decltype(_impl_.confidence_){0}
    , decltype(_impl_.processing_time_){0}
    , decltype(_impl_.success_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.model_used_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.model_used_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.extracted_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.extracted_text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.error_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.error_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

VisionInferenceResponse::~VisionInferenceResponse() {
  // @@protoc_insertion_point(destructor:multimodal.VisionInferenceResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void VisionInferenceResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.metadata_.Destruct();
  _impl_.metadata_.~MapField();
  _impl_.ui_elements_.~RepeatedPtrField();
  _impl_.tags_.~RepeatedPtrField();
  _impl_.description_.Destroy();
  _impl_.model_used_.Destroy();
  _impl_.extracted_text_.Destroy();
  _impl_.error_.Destroy();
}

void VisionInferenceResponse::ArenaDtor(void* object) {
  VisionInferenceResponse* _this = reinterpret_cast< VisionInferenceResponse* >(object);
  _this->_impl_.metadata_.Destruct();
}
void VisionInferenceResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VisionInferenceResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:multimodal.VisionInferenceResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.metadata_.Clear();
  _impl_.ui_elements_.Clear();
  _impl_.tags_.Clear();
  _impl_.description_.ClearToEmpty();
  _impl_.model_used_.ClearToEmpty();
  _impl_.extracted_text_.ClearToEmpty();
  _impl_.error_.ClearToEmpty();
  ::memset(&_impl_.confidence_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.success_) -
      reinterpret_cast<char*>(&_impl_.confidence_)) + sizeof(_impl_.success_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VisionInferenceResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string description = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "multimodal.VisionInferenceResponse.description"));
        } else
          goto handle_unusual;
        continue;
      // double confidence = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _impl_.confidence_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // string model_used = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_model_used();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "multimodal.VisionInferenceResponse.model_used"));
        } else
          goto handle_unusual;
        continue;
      // double processing_time = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _impl_.processing_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // map<string, string> metadata = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.metadata_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string extracted_text = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_extracted_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "multimodal.VisionInferenceResponse.extracted_text"));
        } else
          goto handle_unusual;
        continue;
      // repeated .multimodal.UIElement ui_elements = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_ui_elements(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string tags = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_tags();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "multimodal.VisionInferenceResponse.tags"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string error = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_error();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "multimodal.VisionInferenceResponse.error"));
        } else
          goto handle_unusual;
        continue;
      // bool success = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _impl_.success_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VisionInferenceResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:multimodal.VisionInferenceResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string description = 1;
  if (!this->_internal_description().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_description().data(), static_cast<int>(this->_internal_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "multimodal.VisionInferenceResponse.description");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_description(), target);
  }

  // double confidence = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_confidence = this->_internal_confidence();
  uint64_t raw_confidence;
  memcpy(&raw_confidence, &tmp_confidence, sizeof(tmp_confidence));
  if (raw_confidence != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_confidence(), target);
  }

  // string model_used = 3;
  if (!this->_internal_model_used().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_model_used().data(), static_cast<int>(this->_internal_model_used().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "multimodal.VisionInferenceResponse.model_used");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_model_used(), target);
  }

  // double processing_time = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_processing_time = this->_internal_processing_time();
  uint64_t raw_processing_time;
  memcpy(&raw_processing_time, &tmp_processing_time, sizeof(tmp_processing_time));
  if (raw_processing_time != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_processing_time(), target);
  }

  // map<string, string> metadata = 5;
  if (!this->_internal_metadata().empty()) {
    using MapType = ::_pb::Map<std::string, std::string>;
    using WireHelper = VisionInferenceResponse_MetadataEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_metadata();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "multimodal.VisionInferenceResponse.MetadataEntry.key");
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.second.data(), static_cast<int>(entry.second.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "multimodal.VisionInferenceResponse.MetadataEntry.value");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(5, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(5, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // string extracted_text = 6;
  if (!this->_internal_extracted_text().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_extracted_text().data(), static_cast<int>(this->_internal_extracted_text().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "multimodal.VisionInferenceResponse.extracted_text");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_extracted_text(), target);
  }

  // repeated .multimodal.UIElement ui_elements = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_ui_elements_size()); i < n; i++) {
    const auto& repfield = this->_internal_ui_elements(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated string tags = 8;
  for (int i = 0, n = this->_internal_tags_size(); i < n; i++) {
    const auto& s = this->_internal_tags(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "multimodal.VisionInferenceResponse.tags");
    target = stream->WriteString(8, s, target);
  }

  // string error = 9;
  if (!this->_internal_error().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_error().data(), static_cast<int>(this->_internal_error().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "multimodal.VisionInferenceResponse.error");
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_error(), target);
  }

  // bool success = 10;
  if (this->_internal_success() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_success(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:multimodal.VisionInferenceResponse)
  return target;
}

size_t VisionInferenceResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:multimodal.VisionInferenceResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, string> metadata = 5;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_metadata_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_metadata().begin();
      it != this->_internal_metadata().end(); ++it) {
    total_size += VisionInferenceResponse_MetadataEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // repeated .multimodal.UIElement ui_elements = 7;
  total_size += 1UL * this->_internal_ui_elements_size();
  for (const auto& msg : this->_impl_.ui_elements_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated string tags = 8;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.tags_.size());
  for (int i = 0, n = _impl_.tags_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.tags_.Get(i));
  }

  // string description = 1;
  if (!this->_internal_description().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_description());
  }

  // string model_used = 3;
  if (!this->_internal_model_used().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_model_used());
  }

  // string extracted_text = 6;
  if (!this->_internal_extracted_text().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_extracted_text());
  }

  // string error = 9;
  if (!this->_internal_error().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_error());
  }

  // double confidence = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_confidence = this->_internal_confidence();
  uint64_t raw_confidence;
  memcpy(&raw_confidence, &tmp_confidence, sizeof(tmp_confidence));
  if (raw_confidence != 0) {
    total_size += 1 + 8;
  }

  // double processing_time = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_processing_time = this->_internal_processing_time();
  uint64_t raw_processing_time;
  memcpy(&raw_processing_time, &tmp_processing_time, sizeof(tmp_processing_time));
  if (raw_processing_time != 0) {
    total_size += 1 + 8;
  }

  // bool success = 10;
  if (this->_internal_success() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VisionInferenceResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VisionInferenceResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VisionInferenceResponse::GetClassData() const { return &_class_data_; }


void VisionInferenceResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VisionInferenceResponse*>(&to_msg);
  auto& from = static_cast<const VisionInferenceResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:multimodal.VisionInferenceResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.metadata_.MergeFrom(from._impl_.metadata_);
  _this->_impl_.ui_elements_.MergeFrom(from._impl_.ui_elements_);
  _this->_impl_.tags_.MergeFrom(from._impl_.tags_);
  if (!from._internal_description().empty()) {
    _this->_internal_set_description(from._internal_description());
  }
  if (!from._internal_model_used().empty()) {
    _this->_internal_set_model_used(from._internal_model_used());
  }
  if (!from._internal_extracted_text().empty()) {
    _this->_internal_set_extracted_text(from._internal_extracted_text());
  }
  if (!from._internal_error().empty()) {
    _this->_internal_set_error(from._internal_error());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_confidence = from._internal_confidence();
  uint64_t raw_confidence;
  memcpy(&raw_confidence, &tmp_confidence, sizeof(tmp_confidence));
  if (raw_confidence != 0) {
    _this->_internal_set_confidence(from._internal_confidence());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_processing_time = from._internal_processing_time();
  uint64_t raw_processing_time;
  memcpy(&raw_processing_time, &tmp_processing_time, sizeof(tmp_processing_time));
  if (raw_processing_time != 0) {
    _this->_internal_set_processing_time(from._internal_processing_time());
  }
  if (from._internal_success() != 0) {
    _this->_internal_set_success(from._internal_success());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VisionInferenceResponse::CopyFrom(const VisionInferenceResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:multimodal.VisionInferenceResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VisionInferenceResponse::IsInitialized() const {
  return true;
}

void VisionInferenceResponse::InternalSwap(VisionInferenceResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.metadata_.InternalSwap(&other->_impl_.metadata_);
  _impl_.ui_elements_.InternalSwap(&other->_impl_.ui_elements_);
  _impl_.tags_.InternalSwap(&other->_impl_.tags_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.description_, lhs_arena,
      &other->_impl_.description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.model_used_, lhs_arena,
      &other->_impl_.model_used_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.extracted_text_, lhs_arena,
      &other->_impl_.extracted_text_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.error_, lhs_arena,
      &other->_impl_.error_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VisionInferenceResponse, _impl_.success_)
      + sizeof(VisionInferenceResponse::_impl_.success_)
      - PROTOBUF_FIELD_OFFSET(VisionInferenceResponse, _impl_.confidence_)>(
          reinterpret_cast<char*>(&_impl_.confidence_),
          reinterpret_cast<char*>(&other->_impl_.confidence_));
}

::PROTOBUF_NAMESPACE_ID::Metadata VisionInferenceResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vision_5fservice_2eproto_getter, &descriptor_table_vision_5fservice_2eproto_once,
      file_level_metadata_vision_5fservice_2eproto[3]);
}

// ===================================================================

UIElement_PropertiesEntry_DoNotUse::UIElement_PropertiesEntry_DoNotUse() {}
UIElement_PropertiesEntry_DoNotUse::UIElement_PropertiesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void UIElement_PropertiesEntry_DoNotUse::MergeFrom(const UIElement_PropertiesEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata UIElement_PropertiesEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vision_5fservice_2eproto_getter, &descriptor_table_vision_5fservice_2eproto_once,
      file_level_metadata_vision_5fservice_2eproto[4]);
}

// ===================================================================

class UIElement::_Internal {
 public:
  static const ::multimodal::ElementBounds& bounds(const UIElement* msg);
};

const ::multimodal::ElementBounds&
UIElement::_Internal::bounds(const UIElement* msg) {
  return *msg->_impl_.bounds_;
}
UIElement::UIElement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &UIElement::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:multimodal.UIElement)
}
UIElement::UIElement(const UIElement& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UIElement* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_.properties_)*/{}
    , decltype(_impl_.type_){}
    , decltype(_impl_.bounds_){nullptr}
    , decltype(_impl_.confidence_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.properties_.MergeFrom(from._impl_.properties_);
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_type().empty()) {
    _this->_impl_.type_.Set(from._internal_type(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_bounds()) {
    _this->_impl_.bounds_ = new ::multimodal::ElementBounds(*from._impl_.bounds_);
  }
  _this->_impl_.confidence_ = from._impl_.confidence_;
  // @@protoc_insertion_point(copy_constructor:multimodal.UIElement)
}

inline void UIElement::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_.properties_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.type_){}
    , decltype(_impl_.bounds_){nullptr}
    , decltype(_impl_.confidence_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

UIElement::~UIElement() {
  // @@protoc_insertion_point(destructor:multimodal.UIElement)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void UIElement::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.properties_.Destruct();
  _impl_.properties_.~MapField();
  _impl_.type_.Destroy();
  if (this != internal_default_instance()) delete _impl_.bounds_;
}

void UIElement::ArenaDtor(void* object) {
  UIElement* _this = reinterpret_cast< UIElement* >(object);
  _this->_impl_.properties_.Destruct();
}
void UIElement::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UIElement::Clear() {
// @@protoc_insertion_point(message_clear_start:multimodal.UIElement)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.properties_.Clear();
  _impl_.type_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.bounds_ != nullptr) {
    delete _impl_.bounds_;
  }
  _impl_.bounds_ = nullptr;
  _impl_.confidence_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UIElement::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "multimodal.UIElement.type"));
        } else
          goto handle_unusual;
        continue;
      // double confidence = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _impl_.confidence_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // .multimodal.ElementBounds bounds = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_bounds(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // map<string, string> properties = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.properties_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UIElement::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:multimodal.UIElement)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string type = 1;
  if (!this->_internal_type().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_type().data(), static_cast<int>(this->_internal_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "multimodal.UIElement.type");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_type(), target);
  }

  // double confidence = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_confidence = this->_internal_confidence();
  uint64_t raw_confidence;
  memcpy(&raw_confidence, &tmp_confidence, sizeof(tmp_confidence));
  if (raw_confidence != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_confidence(), target);
  }

  // .multimodal.ElementBounds bounds = 3;
  if (this->_internal_has_bounds()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::bounds(this),
        _Internal::bounds(this).GetCachedSize(), target, stream);
  }

  // map<string, string> properties = 4;
  if (!this->_internal_properties().empty()) {
    using MapType = ::_pb::Map<std::string, std::string>;
    using WireHelper = UIElement_PropertiesEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_properties();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "multimodal.UIElement.PropertiesEntry.key");
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.second.data(), static_cast<int>(entry.second.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "multimodal.UIElement.PropertiesEntry.value");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(4, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(4, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:multimodal.UIElement)
  return target;
}

size_t UIElement::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:multimodal.UIElement)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, string> properties = 4;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_properties_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_properties().begin();
      it != this->_internal_properties().end(); ++it) {
    total_size += UIElement_PropertiesEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // string type = 1;
  if (!this->_internal_type().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_type());
  }

  // .multimodal.ElementBounds bounds = 3;
  if (this->_internal_has_bounds()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.bounds_);
  }

  // double confidence = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_confidence = this->_internal_confidence();
  uint64_t raw_confidence;
  memcpy(&raw_confidence, &tmp_confidence, sizeof(tmp_confidence));
  if (raw_confidence != 0) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UIElement::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UIElement::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UIElement::GetClassData() const { return &_class_data_; }


void UIElement::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UIElement*>(&to_msg);
  auto& from = static_cast<const UIElement&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:multimodal.UIElement)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.properties_.MergeFrom(from._impl_.properties_);
  if (!from._internal_type().empty()) {
    _this->_internal_set_type(from._internal_type());
  }
  if (from._internal_has_bounds()) {
    _this->_internal_mutable_bounds()->::multimodal::ElementBounds::MergeFrom(
        from._internal_bounds());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_confidence = from._internal_confidence();
  uint64_t raw_confidence;
  memcpy(&raw_confidence, &tmp_confidence, sizeof(tmp_confidence));
  if (raw_confidence != 0) {
    _this->_internal_set_confidence(from._internal_confidence());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UIElement::CopyFrom(const UIElement& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:multimodal.UIElement)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UIElement::IsInitialized() const {
  return true;
}

void UIElement::InternalSwap(UIElement* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.properties_.InternalSwap(&other->_impl_.properties_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.type_, lhs_arena,
      &other->_impl_.type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UIElement, _impl_.confidence_)
      + sizeof(UIElement::_impl_.confidence_)
      - PROTOBUF_FIELD_OFFSET(UIElement, _impl_.bounds_)>(
          reinterpret_cast<char*>(&_impl_.bounds_),
          reinterpret_cast<char*>(&other->_impl_.bounds_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UIElement::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vision_5fservice_2eproto_getter, &descriptor_table_vision_5fservice_2eproto_once,
      file_level_metadata_vision_5fservice_2eproto[5]);
}

// ===================================================================

class ElementBounds::_Internal {
 public:
};

ElementBounds::ElementBounds(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:multimodal.ElementBounds)
}
ElementBounds::ElementBounds(const ElementBounds& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ElementBounds* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.width_){}
    , decltype(_impl_.height_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.height_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.height_));
  // @@protoc_insertion_point(copy_constructor:multimodal.ElementBounds)
}

inline void ElementBounds::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , decltype(_impl_.width_){0}
    , decltype(_impl_.height_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ElementBounds::~ElementBounds() {
  // @@protoc_insertion_point(destructor:multimodal.ElementBounds)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ElementBounds::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ElementBounds::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ElementBounds::Clear() {
// @@protoc_insertion_point(message_clear_start:multimodal.ElementBounds)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.height_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.height_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ElementBounds::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 width = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 height = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ElementBounds::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:multimodal.ElementBounds)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 x = 1;
  if (this->_internal_x() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_x(), target);
  }

  // int32 y = 2;
  if (this->_internal_y() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_y(), target);
  }

  // int32 width = 3;
  if (this->_internal_width() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_width(), target);
  }

  // int32 height = 4;
  if (this->_internal_height() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_height(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:multimodal.ElementBounds)
  return target;
}

size_t ElementBounds::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:multimodal.ElementBounds)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 x = 1;
  if (this->_internal_x() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_x());
  }

  // int32 y = 2;
  if (this->_internal_y() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_y());
  }

  // int32 width = 3;
  if (this->_internal_width() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_width());
  }

  // int32 height = 4;
  if (this->_internal_height() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_height());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ElementBounds::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ElementBounds::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ElementBounds::GetClassData() const { return &_class_data_; }


void ElementBounds::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ElementBounds*>(&to_msg);
  auto& from = static_cast<const ElementBounds&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:multimodal.ElementBounds)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_x() != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  if (from._internal_y() != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  if (from._internal_width() != 0) {
    _this->_internal_set_width(from._internal_width());
  }
  if (from._internal_height() != 0) {
    _this->_internal_set_height(from._internal_height());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ElementBounds::CopyFrom(const ElementBounds& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:multimodal.ElementBounds)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ElementBounds::IsInitialized() const {
  return true;
}

void ElementBounds::InternalSwap(ElementBounds* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ElementBounds, _impl_.height_)
      + sizeof(ElementBounds::_impl_.height_)
      - PROTOBUF_FIELD_OFFSET(ElementBounds, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ElementBounds::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vision_5fservice_2eproto_getter, &descriptor_table_vision_5fservice_2eproto_once,
      file_level_metadata_vision_5fservice_2eproto[6]);
}

// ===================================================================

class ModelsResponse::_Internal {
 public:
};

ModelsResponse::ModelsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:multimodal.ModelsResponse)
}
ModelsResponse::ModelsResponse(const ModelsResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModelsResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.models_){from._impl_.models_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:multimodal.ModelsResponse)
}

inline void ModelsResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.models_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ModelsResponse::~ModelsResponse() {
  // @@protoc_insertion_point(destructor:multimodal.ModelsResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModelsResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.models_.~RepeatedPtrField();
}

void ModelsResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModelsResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:multimodal.ModelsResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.models_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelsResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .multimodal.ModelInfo models = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_models(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelsResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:multimodal.ModelsResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .multimodal.ModelInfo models = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_models_size()); i < n; i++) {
    const auto& repfield = this->_internal_models(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:multimodal.ModelsResponse)
  return target;
}

size_t ModelsResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:multimodal.ModelsResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .multimodal.ModelInfo models = 1;
  total_size += 1UL * this->_internal_models_size();
  for (const auto& msg : this->_impl_.models_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelsResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModelsResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelsResponse::GetClassData() const { return &_class_data_; }


void ModelsResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModelsResponse*>(&to_msg);
  auto& from = static_cast<const ModelsResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:multimodal.ModelsResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.models_.MergeFrom(from._impl_.models_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelsResponse::CopyFrom(const ModelsResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:multimodal.ModelsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelsResponse::IsInitialized() const {
  return true;
}

void ModelsResponse::InternalSwap(ModelsResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.models_.InternalSwap(&other->_impl_.models_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelsResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vision_5fservice_2eproto_getter, &descriptor_table_vision_5fservice_2eproto_once,
      file_level_metadata_vision_5fservice_2eproto[7]);
}

// ===================================================================

class ModelInfo::_Internal {
 public:
};

ModelInfo::ModelInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:multimodal.ModelInfo)
}
ModelInfo::ModelInfo(const ModelInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModelInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.supported_types_){from._impl_.supported_types_}
    , decltype(_impl_.name_){}
    , decltype(_impl_.display_name_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.memory_usage_mb_){}
    , decltype(_impl_.available_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.display_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.display_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_display_name().empty()) {
    _this->_impl_.display_name_.Set(from._internal_display_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_description().empty()) {
    _this->_impl_.description_.Set(from._internal_description(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.memory_usage_mb_, &from._impl_.memory_usage_mb_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.available_) -
    reinterpret_cast<char*>(&_impl_.memory_usage_mb_)) + sizeof(_impl_.available_));
  // @@protoc_insertion_point(copy_constructor:multimodal.ModelInfo)
}

inline void ModelInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.supported_types_){arena}
    , decltype(_impl_.name_){}
    , decltype(_impl_.display_name_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.memory_usage_mb_){int64_t{0}}
    , decltype(_impl_.available_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.display_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.display_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ModelInfo::~ModelInfo() {
  // @@protoc_insertion_point(destructor:multimodal.ModelInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModelInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.supported_types_.~RepeatedPtrField();
  _impl_.name_.Destroy();
  _impl_.display_name_.Destroy();
  _impl_.description_.Destroy();
}

void ModelInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModelInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:multimodal.ModelInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.supported_types_.Clear();
  _impl_.name_.ClearToEmpty();
  _impl_.display_name_.ClearToEmpty();
  _impl_.description_.ClearToEmpty();
  ::memset(&_impl_.memory_usage_mb_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.available_) -
      reinterpret_cast<char*>(&_impl_.memory_usage_mb_)) + sizeof(_impl_.available_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "multimodal.ModelInfo.name"));
        } else
          goto handle_unusual;
        continue;
      // string display_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_display_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "multimodal.ModelInfo.display_name"));
        } else
          goto handle_unusual;
        continue;
      // string description = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "multimodal.ModelInfo.description"));
        } else
          goto handle_unusual;
        continue;
      // bool available = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.available_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 memory_usage_mb = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.memory_usage_mb_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string supported_types = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_supported_types();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "multimodal.ModelInfo.supported_types"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:multimodal.ModelInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "multimodal.ModelInfo.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // string display_name = 2;
  if (!this->_internal_display_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_display_name().data(), static_cast<int>(this->_internal_display_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "multimodal.ModelInfo.display_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_display_name(), target);
  }

  // string description = 3;
  if (!this->_internal_description().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_description().data(), static_cast<int>(this->_internal_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "multimodal.ModelInfo.description");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_description(), target);
  }

  // bool available = 4;
  if (this->_internal_available() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_available(), target);
  }

  // int64 memory_usage_mb = 5;
  if (this->_internal_memory_usage_mb() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_memory_usage_mb(), target);
  }

  // repeated string supported_types = 6;
  for (int i = 0, n = this->_internal_supported_types_size(); i < n; i++) {
    const auto& s = this->_internal_supported_types(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "multimodal.ModelInfo.supported_types");
    target = stream->WriteString(6, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:multimodal.ModelInfo)
  return target;
}

size_t ModelInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:multimodal.ModelInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string supported_types = 6;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.supported_types_.size());
  for (int i = 0, n = _impl_.supported_types_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.supported_types_.Get(i));
  }

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string display_name = 2;
  if (!this->_internal_display_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_display_name());
  }

  // string description = 3;
  if (!this->_internal_description().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_description());
  }

  // int64 memory_usage_mb = 5;
  if (this->_internal_memory_usage_mb() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_memory_usage_mb());
  }

  // bool available = 4;
  if (this->_internal_available() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModelInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelInfo::GetClassData() const { return &_class_data_; }


void ModelInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModelInfo*>(&to_msg);
  auto& from = static_cast<const ModelInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:multimodal.ModelInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.supported_types_.MergeFrom(from._impl_.supported_types_);
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_display_name().empty()) {
    _this->_internal_set_display_name(from._internal_display_name());
  }
  if (!from._internal_description().empty()) {
    _this->_internal_set_description(from._internal_description());
  }
  if (from._internal_memory_usage_mb() != 0) {
    _this->_internal_set_memory_usage_mb(from._internal_memory_usage_mb());
  }
  if (from._internal_available() != 0) {
    _this->_internal_set_available(from._internal_available());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelInfo::CopyFrom(const ModelInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:multimodal.ModelInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelInfo::IsInitialized() const {
  return true;
}

void ModelInfo::InternalSwap(ModelInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.supported_types_.InternalSwap(&other->_impl_.supported_types_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.display_name_, lhs_arena,
      &other->_impl_.display_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.description_, lhs_arena,
      &other->_impl_.description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModelInfo, _impl_.available_)
      + sizeof(ModelInfo::_impl_.available_)
      - PROTOBUF_FIELD_OFFSET(ModelInfo, _impl_.memory_usage_mb_)>(
          reinterpret_cast<char*>(&_impl_.memory_usage_mb_),
          reinterpret_cast<char*>(&other->_impl_.memory_usage_mb_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vision_5fservice_2eproto_getter, &descriptor_table_vision_5fservice_2eproto_once,
      file_level_metadata_vision_5fservice_2eproto[8]);
}

// ===================================================================

class ModelMetricsRequest::_Internal {
 public:
};

ModelMetricsRequest::ModelMetricsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:multimodal.ModelMetricsRequest)
}
ModelMetricsRequest::ModelMetricsRequest(const ModelMetricsRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModelMetricsRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.model_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.model_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.model_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_model().empty()) {
    _this->_impl_.model_.Set(from._internal_model(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:multimodal.ModelMetricsRequest)
}

inline void ModelMetricsRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.model_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.model_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.model_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ModelMetricsRequest::~ModelMetricsRequest() {
  // @@protoc_insertion_point(destructor:multimodal.ModelMetricsRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModelMetricsRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.model_.Destroy();
}

void ModelMetricsRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModelMetricsRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:multimodal.ModelMetricsRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.model_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelMetricsRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string model = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_model();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "multimodal.ModelMetricsRequest.model"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelMetricsRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:multimodal.ModelMetricsRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string model = 1;
  if (!this->_internal_model().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_model().data(), static_cast<int>(this->_internal_model().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "multimodal.ModelMetricsRequest.model");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_model(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:multimodal.ModelMetricsRequest)
  return target;
}

size_t ModelMetricsRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:multimodal.ModelMetricsRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string model = 1;
  if (!this->_internal_model().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_model());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelMetricsRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModelMetricsRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelMetricsRequest::GetClassData() const { return &_class_data_; }


void ModelMetricsRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModelMetricsRequest*>(&to_msg);
  auto& from = static_cast<const ModelMetricsRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:multimodal.ModelMetricsRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_model().empty()) {
    _this->_internal_set_model(from._internal_model());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelMetricsRequest::CopyFrom(const ModelMetricsRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:multimodal.ModelMetricsRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelMetricsRequest::IsInitialized() const {
  return true;
}

void ModelMetricsRequest::InternalSwap(ModelMetricsRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.model_, lhs_arena,
      &other->_impl_.model_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelMetricsRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vision_5fservice_2eproto_getter, &descriptor_table_vision_5fservice_2eproto_once,
      file_level_metadata_vision_5fservice_2eproto[9]);
}

// ===================================================================

ModelMetricsResponse_AdditionalMetricsEntry_DoNotUse::ModelMetricsResponse_AdditionalMetricsEntry_DoNotUse() {}
ModelMetricsResponse_AdditionalMetricsEntry_DoNotUse::ModelMetricsResponse_AdditionalMetricsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void ModelMetricsResponse_AdditionalMetricsEntry_DoNotUse::MergeFrom(const ModelMetricsResponse_AdditionalMetricsEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata ModelMetricsResponse_AdditionalMetricsEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vision_5fservice_2eproto_getter, &descriptor_table_vision_5fservice_2eproto_once,
      file_level_metadata_vision_5fservice_2eproto[10]);
}

// ===================================================================

class ModelMetricsResponse::_Internal {
 public:
};

ModelMetricsResponse::ModelMetricsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &ModelMetricsResponse::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:multimodal.ModelMetricsResponse)
}
ModelMetricsResponse::ModelMetricsResponse(const ModelMetricsResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModelMetricsResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_.additional_metrics_)*/{}
    , decltype(_impl_.model_){}
    , decltype(_impl_.total_inferences_){}
    , decltype(_impl_.average_processing_time_){}
    , decltype(_impl_.average_confidence_){}
    , decltype(_impl_.memory_usage_mb_){}
    , decltype(_impl_.gpu_utilization_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.additional_metrics_.MergeFrom(from._impl_.additional_metrics_);
  _impl_.model_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.model_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_model().empty()) {
    _this->_impl_.model_.Set(from._internal_model(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.total_inferences_, &from._impl_.total_inferences_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.gpu_utilization_) -
    reinterpret_cast<char*>(&_impl_.total_inferences_)) + sizeof(_impl_.gpu_utilization_));
  // @@protoc_insertion_point(copy_constructor:multimodal.ModelMetricsResponse)
}

inline void ModelMetricsResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_.additional_metrics_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.model_){}
    , decltype(_impl_.total_inferences_){int64_t{0}}
    , decltype(_impl_.average_processing_time_){0}
    , decltype(_impl_.average_confidence_){0}
    , decltype(_impl_.memory_usage_mb_){int64_t{0}}
    , decltype(_impl_.gpu_utilization_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.model_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.model_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ModelMetricsResponse::~ModelMetricsResponse() {
  // @@protoc_insertion_point(destructor:multimodal.ModelMetricsResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void ModelMetricsResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.additional_metrics_.Destruct();
  _impl_.additional_metrics_.~MapField();
  _impl_.model_.Destroy();
}

void ModelMetricsResponse::ArenaDtor(void* object) {
  ModelMetricsResponse* _this = reinterpret_cast< ModelMetricsResponse* >(object);
  _this->_impl_.additional_metrics_.Destruct();
}
void ModelMetricsResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModelMetricsResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:multimodal.ModelMetricsResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.additional_metrics_.Clear();
  _impl_.model_.ClearToEmpty();
  ::memset(&_impl_.total_inferences_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.gpu_utilization_) -
      reinterpret_cast<char*>(&_impl_.total_inferences_)) + sizeof(_impl_.gpu_utilization_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelMetricsResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string model = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_model();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "multimodal.ModelMetricsResponse.model"));
        } else
          goto handle_unusual;
        continue;
      // int64 total_inferences = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.total_inferences_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double average_processing_time = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _impl_.average_processing_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double average_confidence = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _impl_.average_confidence_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // int64 memory_usage_mb = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.memory_usage_mb_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double gpu_utilization = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _impl_.gpu_utilization_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // map<string, double> additional_metrics = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.additional_metrics_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelMetricsResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:multimodal.ModelMetricsResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string model = 1;
  if (!this->_internal_model().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_model().data(), static_cast<int>(this->_internal_model().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "multimodal.ModelMetricsResponse.model");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_model(), target);
  }

  // int64 total_inferences = 2;
  if (this->_internal_total_inferences() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_total_inferences(), target);
  }

  // double average_processing_time = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_average_processing_time = this->_internal_average_processing_time();
  uint64_t raw_average_processing_time;
  memcpy(&raw_average_processing_time, &tmp_average_processing_time, sizeof(tmp_average_processing_time));
  if (raw_average_processing_time != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_average_processing_time(), target);
  }

  // double average_confidence = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_average_confidence = this->_internal_average_confidence();
  uint64_t raw_average_confidence;
  memcpy(&raw_average_confidence, &tmp_average_confidence, sizeof(tmp_average_confidence));
  if (raw_average_confidence != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_average_confidence(), target);
  }

  // int64 memory_usage_mb = 5;
  if (this->_internal_memory_usage_mb() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_memory_usage_mb(), target);
  }

  // double gpu_utilization = 6;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_gpu_utilization = this->_internal_gpu_utilization();
  uint64_t raw_gpu_utilization;
  memcpy(&raw_gpu_utilization, &tmp_gpu_utilization, sizeof(tmp_gpu_utilization));
  if (raw_gpu_utilization != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(6, this->_internal_gpu_utilization(), target);
  }

  // map<string, double> additional_metrics = 7;
  if (!this->_internal_additional_metrics().empty()) {
    using MapType = ::_pb::Map<std::string, double>;
    using WireHelper = ModelMetricsResponse_AdditionalMetricsEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_additional_metrics();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "multimodal.ModelMetricsResponse.AdditionalMetricsEntry.key");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(7, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(7, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:multimodal.ModelMetricsResponse)
  return target;
}

size_t ModelMetricsResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:multimodal.ModelMetricsResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, double> additional_metrics = 7;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_additional_metrics_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, double >::const_iterator
      it = this->_internal_additional_metrics().begin();
      it != this->_internal_additional_metrics().end(); ++it) {
    total_size += ModelMetricsResponse_AdditionalMetricsEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // string model = 1;
  if (!this->_internal_model().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_model());
  }

  // int64 total_inferences = 2;
  if (this->_internal_total_inferences() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_total_inferences());
  }

  // double average_processing_time = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_average_processing_time = this->_internal_average_processing_time();
  uint64_t raw_average_processing_time;
  memcpy(&raw_average_processing_time, &tmp_average_processing_time, sizeof(tmp_average_processing_time));
  if (raw_average_processing_time != 0) {
    total_size += 1 + 8;
  }

  // double average_confidence = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_average_confidence = this->_internal_average_confidence();
  uint64_t raw_average_confidence;
  memcpy(&raw_average_confidence, &tmp_average_confidence, sizeof(tmp_average_confidence));
  if (raw_average_confidence != 0) {
    total_size += 1 + 8;
  }

  // int64 memory_usage_mb = 5;
  if (this->_internal_memory_usage_mb() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_memory_usage_mb());
  }

  // double gpu_utilization = 6;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_gpu_utilization = this->_internal_gpu_utilization();
  uint64_t raw_gpu_utilization;
  memcpy(&raw_gpu_utilization, &tmp_gpu_utilization, sizeof(tmp_gpu_utilization));
  if (raw_gpu_utilization != 0) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelMetricsResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModelMetricsResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelMetricsResponse::GetClassData() const { return &_class_data_; }


void ModelMetricsResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModelMetricsResponse*>(&to_msg);
  auto& from = static_cast<const ModelMetricsResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:multimodal.ModelMetricsResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.additional_metrics_.MergeFrom(from._impl_.additional_metrics_);
  if (!from._internal_model().empty()) {
    _this->_internal_set_model(from._internal_model());
  }
  if (from._internal_total_inferences() != 0) {
    _this->_internal_set_total_inferences(from._internal_total_inferences());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_average_processing_time = from._internal_average_processing_time();
  uint64_t raw_average_processing_time;
  memcpy(&raw_average_processing_time, &tmp_average_processing_time, sizeof(tmp_average_processing_time));
  if (raw_average_processing_time != 0) {
    _this->_internal_set_average_processing_time(from._internal_average_processing_time());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_average_confidence = from._internal_average_confidence();
  uint64_t raw_average_confidence;
  memcpy(&raw_average_confidence, &tmp_average_confidence, sizeof(tmp_average_confidence));
  if (raw_average_confidence != 0) {
    _this->_internal_set_average_confidence(from._internal_average_confidence());
  }
  if (from._internal_memory_usage_mb() != 0) {
    _this->_internal_set_memory_usage_mb(from._internal_memory_usage_mb());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_gpu_utilization = from._internal_gpu_utilization();
  uint64_t raw_gpu_utilization;
  memcpy(&raw_gpu_utilization, &tmp_gpu_utilization, sizeof(tmp_gpu_utilization));
  if (raw_gpu_utilization != 0) {
    _this->_internal_set_gpu_utilization(from._internal_gpu_utilization());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelMetricsResponse::CopyFrom(const ModelMetricsResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:multimodal.ModelMetricsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelMetricsResponse::IsInitialized() const {
  return true;
}

void ModelMetricsResponse::InternalSwap(ModelMetricsResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.additional_metrics_.InternalSwap(&other->_impl_.additional_metrics_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.model_, lhs_arena,
      &other->_impl_.model_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModelMetricsResponse, _impl_.gpu_utilization_)
      + sizeof(ModelMetricsResponse::_impl_.gpu_utilization_)
      - PROTOBUF_FIELD_OFFSET(ModelMetricsResponse, _impl_.total_inferences_)>(
          reinterpret_cast<char*>(&_impl_.total_inferences_),
          reinterpret_cast<char*>(&other->_impl_.total_inferences_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelMetricsResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vision_5fservice_2eproto_getter, &descriptor_table_vision_5fservice_2eproto_once,
      file_level_metadata_vision_5fservice_2eproto[11]);
}

// ===================================================================

class Empty::_Internal {
 public:
};

Empty::Empty(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:multimodal.Empty)
}
Empty::Empty(const Empty& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  Empty* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:multimodal.Empty)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Empty::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Empty::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata Empty::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vision_5fservice_2eproto_getter, &descriptor_table_vision_5fservice_2eproto_once,
      file_level_metadata_vision_5fservice_2eproto[12]);
}

// ===================================================================

HealthResponse_DetailsEntry_DoNotUse::HealthResponse_DetailsEntry_DoNotUse() {}
HealthResponse_DetailsEntry_DoNotUse::HealthResponse_DetailsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void HealthResponse_DetailsEntry_DoNotUse::MergeFrom(const HealthResponse_DetailsEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata HealthResponse_DetailsEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vision_5fservice_2eproto_getter, &descriptor_table_vision_5fservice_2eproto_once,
      file_level_metadata_vision_5fservice_2eproto[13]);
}

// ===================================================================

class HealthResponse::_Internal {
 public:
};

HealthResponse::HealthResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &HealthResponse::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:multimodal.HealthResponse)
}
HealthResponse::HealthResponse(const HealthResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  HealthResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_.details_)*/{}
    , decltype(_impl_.status_){}
    , decltype(_impl_.version_){}
    , decltype(_impl_.uptime_seconds_){}
    , decltype(_impl_.healthy_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.details_.MergeFrom(from._impl_.details_);
  _impl_.status_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.status_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_status().empty()) {
    _this->_impl_.status_.Set(from._internal_status(), 
      _this->GetArenaForAllocation());
  }
  _impl_.version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_version().empty()) {
    _this->_impl_.version_.Set(from._internal_version(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.uptime_seconds_, &from._impl_.uptime_seconds_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.healthy_) -
    reinterpret_cast<char*>(&_impl_.uptime_seconds_)) + sizeof(_impl_.healthy_));
  // @@protoc_insertion_point(copy_constructor:multimodal.HealthResponse)
}

inline void HealthResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_.details_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.status_){}
    , decltype(_impl_.version_){}
    , decltype(_impl_.uptime_seconds_){int64_t{0}}
    , decltype(_impl_.healthy_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.status_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.status_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

HealthResponse::~HealthResponse() {
  // @@protoc_insertion_point(destructor:multimodal.HealthResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void HealthResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.details_.Destruct();
  _impl_.details_.~MapField();
  _impl_.status_.Destroy();
  _impl_.version_.Destroy();
}

void HealthResponse::ArenaDtor(void* object) {
  HealthResponse* _this = reinterpret_cast< HealthResponse* >(object);
  _this->_impl_.details_.Destruct();
}
void HealthResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void HealthResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:multimodal.HealthResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.details_.Clear();
  _impl_.status_.ClearToEmpty();
  _impl_.version_.ClearToEmpty();
  ::memset(&_impl_.uptime_seconds_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.healthy_) -
      reinterpret_cast<char*>(&_impl_.uptime_seconds_)) + sizeof(_impl_.healthy_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* HealthResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool healthy = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.healthy_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_status();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "multimodal.HealthResponse.status"));
        } else
          goto handle_unusual;
        continue;
      // map<string, string> details = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.details_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // int64 uptime_seconds = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.uptime_seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string version = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "multimodal.HealthResponse.version"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* HealthResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:multimodal.HealthResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool healthy = 1;
  if (this->_internal_healthy() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_healthy(), target);
  }

  // string status = 2;
  if (!this->_internal_status().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_status().data(), static_cast<int>(this->_internal_status().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "multimodal.HealthResponse.status");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_status(), target);
  }

  // map<string, string> details = 3;
  if (!this->_internal_details().empty()) {
    using MapType = ::_pb::Map<std::string, std::string>;
    using WireHelper = HealthResponse_DetailsEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_details();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "multimodal.HealthResponse.DetailsEntry.key");
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.second.data(), static_cast<int>(entry.second.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "multimodal.HealthResponse.DetailsEntry.value");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(3, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(3, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // int64 uptime_seconds = 4;
  if (this->_internal_uptime_seconds() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_uptime_seconds(), target);
  }

  // string version = 5;
  if (!this->_internal_version().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_version().data(), static_cast<int>(this->_internal_version().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "multimodal.HealthResponse.version");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:multimodal.HealthResponse)
  return target;
}

size_t HealthResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:multimodal.HealthResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, string> details = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_details_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_details().begin();
      it != this->_internal_details().end(); ++it) {
    total_size += HealthResponse_DetailsEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // string status = 2;
  if (!this->_internal_status().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_status());
  }

  // string version = 5;
  if (!this->_internal_version().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_version());
  }

  // int64 uptime_seconds = 4;
  if (this->_internal_uptime_seconds() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_uptime_seconds());
  }

  // bool healthy = 1;
  if (this->_internal_healthy() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData HealthResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    HealthResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*HealthResponse::GetClassData() const { return &_class_data_; }


void HealthResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<HealthResponse*>(&to_msg);
  auto& from = static_cast<const HealthResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:multimodal.HealthResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.details_.MergeFrom(from._impl_.details_);
  if (!from._internal_status().empty()) {
    _this->_internal_set_status(from._internal_status());
  }
  if (!from._internal_version().empty()) {
    _this->_internal_set_version(from._internal_version());
  }
  if (from._internal_uptime_seconds() != 0) {
    _this->_internal_set_uptime_seconds(from._internal_uptime_seconds());
  }
  if (from._internal_healthy() != 0) {
    _this->_internal_set_healthy(from._internal_healthy());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void HealthResponse::CopyFrom(const HealthResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:multimodal.HealthResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HealthResponse::IsInitialized() const {
  return true;
}

void HealthResponse::InternalSwap(HealthResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.details_.InternalSwap(&other->_impl_.details_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.status_, lhs_arena,
      &other->_impl_.status_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.version_, lhs_arena,
      &other->_impl_.version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(HealthResponse, _impl_.healthy_)
      + sizeof(HealthResponse::_impl_.healthy_)
      - PROTOBUF_FIELD_OFFSET(HealthResponse, _impl_.uptime_seconds_)>(
          reinterpret_cast<char*>(&_impl_.uptime_seconds_),
          reinterpret_cast<char*>(&other->_impl_.uptime_seconds_));
}

::PROTOBUF_NAMESPACE_ID::Metadata HealthResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vision_5fservice_2eproto_getter, &descriptor_table_vision_5fservice_2eproto_once,
      file_level_metadata_vision_5fservice_2eproto[14]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace multimodal
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::multimodal::VisionInferenceRequest_ParametersEntry_DoNotUse*
Arena::CreateMaybeMessage< ::multimodal::VisionInferenceRequest_ParametersEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::multimodal::VisionInferenceRequest_ParametersEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::multimodal::VisionInferenceRequest*
Arena::CreateMaybeMessage< ::multimodal::VisionInferenceRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::multimodal::VisionInferenceRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::multimodal::VisionInferenceResponse_MetadataEntry_DoNotUse*
Arena::CreateMaybeMessage< ::multimodal::VisionInferenceResponse_MetadataEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::multimodal::VisionInferenceResponse_MetadataEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::multimodal::VisionInferenceResponse*
Arena::CreateMaybeMessage< ::multimodal::VisionInferenceResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::multimodal::VisionInferenceResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::multimodal::UIElement_PropertiesEntry_DoNotUse*
Arena::CreateMaybeMessage< ::multimodal::UIElement_PropertiesEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::multimodal::UIElement_PropertiesEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::multimodal::UIElement*
Arena::CreateMaybeMessage< ::multimodal::UIElement >(Arena* arena) {
  return Arena::CreateMessageInternal< ::multimodal::UIElement >(arena);
}
template<> PROTOBUF_NOINLINE ::multimodal::ElementBounds*
Arena::CreateMaybeMessage< ::multimodal::ElementBounds >(Arena* arena) {
  return Arena::CreateMessageInternal< ::multimodal::ElementBounds >(arena);
}
template<> PROTOBUF_NOINLINE ::multimodal::ModelsResponse*
Arena::CreateMaybeMessage< ::multimodal::ModelsResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::multimodal::ModelsResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::multimodal::ModelInfo*
Arena::CreateMaybeMessage< ::multimodal::ModelInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::multimodal::ModelInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::multimodal::ModelMetricsRequest*
Arena::CreateMaybeMessage< ::multimodal::ModelMetricsRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::multimodal::ModelMetricsRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::multimodal::ModelMetricsResponse_AdditionalMetricsEntry_DoNotUse*
Arena::CreateMaybeMessage< ::multimodal::ModelMetricsResponse_AdditionalMetricsEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::multimodal::ModelMetricsResponse_AdditionalMetricsEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::multimodal::ModelMetricsResponse*
Arena::CreateMaybeMessage< ::multimodal::ModelMetricsResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::multimodal::ModelMetricsResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::multimodal::Empty*
Arena::CreateMaybeMessage< ::multimodal::Empty >(Arena* arena) {
  return Arena::CreateMessageInternal< ::multimodal::Empty >(arena);
}
template<> PROTOBUF_NOINLINE ::multimodal::HealthResponse_DetailsEntry_DoNotUse*
Arena::CreateMaybeMessage< ::multimodal::HealthResponse_DetailsEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::multimodal::HealthResponse_DetailsEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::multimodal::HealthResponse*
Arena::CreateMaybeMessage< ::multimodal::HealthResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::multimodal::HealthResponse >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
