// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: audio.proto

#include "audio.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace unhinged {
namespace audio {
namespace v1 {
PROTOBUF_CONSTEXPR TTSRequest::TTSRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.effects_)*/{}
  , /*decltype(_impl_.text_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.voice_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.options_)*/nullptr
  , /*decltype(_impl_.output_format_)*/0
  , /*decltype(_impl_.sample_rate_)*/0
  , /*decltype(_impl_.channels_)*/0
  , /*decltype(_impl_.enable_ssml_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TTSRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TTSRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TTSRequestDefaultTypeInternal() {}
  union {
    TTSRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TTSRequestDefaultTypeInternal _TTSRequest_default_instance_;
PROTOBUF_CONSTEXPR STTResponse::STTResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.segments_)*/{}
  , /*decltype(_impl_.transcript_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.response_)*/nullptr
  , /*decltype(_impl_.usage_)*/nullptr
  , /*decltype(_impl_.metadata_)*/nullptr
  , /*decltype(_impl_.confidence_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct STTResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR STTResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~STTResponseDefaultTypeInternal() {}
  union {
    STTResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 STTResponseDefaultTypeInternal _STTResponse_default_instance_;
PROTOBUF_CONSTEXPR AudioOptions::AudioOptions(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.speed_)*/0
  , /*decltype(_impl_.pitch_)*/0
  , /*decltype(_impl_.volume_)*/0
  , /*decltype(_impl_.quality_)*/0
  , /*decltype(_impl_.enable_noise_reduction_)*/false
  , /*decltype(_impl_.enable_echo_cancellation_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AudioOptionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AudioOptionsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AudioOptionsDefaultTypeInternal() {}
  union {
    AudioOptions _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AudioOptionsDefaultTypeInternal _AudioOptions_default_instance_;
PROTOBUF_CONSTEXPR AudioEffect_ParametersEntry_DoNotUse::AudioEffect_ParametersEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct AudioEffect_ParametersEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AudioEffect_ParametersEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AudioEffect_ParametersEntry_DoNotUseDefaultTypeInternal() {}
  union {
    AudioEffect_ParametersEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AudioEffect_ParametersEntry_DoNotUseDefaultTypeInternal _AudioEffect_ParametersEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR AudioEffect::AudioEffect(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.parameters_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.intensity_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AudioEffectDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AudioEffectDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AudioEffectDefaultTypeInternal() {}
  union {
    AudioEffect _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AudioEffectDefaultTypeInternal _AudioEffect_default_instance_;
PROTOBUF_CONSTEXPR TranscriptSegment::TranscriptSegment(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.words_)*/{}
  , /*decltype(_impl_.text_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.speaker_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.start_time_)*/0
  , /*decltype(_impl_.end_time_)*/0
  , /*decltype(_impl_.confidence_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TranscriptSegmentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TranscriptSegmentDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TranscriptSegmentDefaultTypeInternal() {}
  union {
    TranscriptSegment _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TranscriptSegmentDefaultTypeInternal _TranscriptSegment_default_instance_;
PROTOBUF_CONSTEXPR WordTiming::WordTiming(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.word_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.start_time_)*/0
  , /*decltype(_impl_.end_time_)*/0
  , /*decltype(_impl_.confidence_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct WordTimingDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WordTimingDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~WordTimingDefaultTypeInternal() {}
  union {
    WordTiming _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WordTimingDefaultTypeInternal _WordTiming_default_instance_;
PROTOBUF_CONSTEXPR STTMetadata::STTMetadata(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.detected_languages_)*/{}
  , /*decltype(_impl_.model_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.language_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.processing_time_ms_)*/0
  , /*decltype(_impl_.signal_to_noise_ratio_)*/0
  , /*decltype(_impl_.speech_rate_wpm_)*/0
  , /*decltype(_impl_.has_background_noise_)*/false
  , /*decltype(_impl_.has_multiple_speakers_)*/false
  , /*decltype(_impl_.detected_quality_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct STTMetadataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR STTMetadataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~STTMetadataDefaultTypeInternal() {}
  union {
    STTMetadata _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 STTMetadataDefaultTypeInternal _STTMetadata_default_instance_;
PROTOBUF_CONSTEXPR Voice::Voice(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.supported_formats_)*/{}
  , /*decltype(_impl_._supported_formats_cached_byte_size_)*/{0}
  , /*decltype(_impl_.supported_sample_rates_)*/{}
  , /*decltype(_impl_._supported_sample_rates_cached_byte_size_)*/{0}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.display_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.language_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.language_code_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.preview_url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.preview_text_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.metadata_)*/nullptr
  , /*decltype(_impl_.gender_)*/0
  , /*decltype(_impl_.age_)*/0
  , /*decltype(_impl_.style_)*/0
  , /*decltype(_impl_.is_available_)*/false
  , /*decltype(_impl_.is_premium_)*/false
  , /*decltype(_impl_.cost_per_character_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct VoiceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VoiceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VoiceDefaultTypeInternal() {}
  union {
    Voice _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VoiceDefaultTypeInternal _Voice_default_instance_;
PROTOBUF_CONSTEXPR TTSChunkPayload::TTSChunkPayload(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.tts_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.audio_metadata_)*/nullptr
  , /*decltype(_impl_.chunk_index_)*/0
  , /*decltype(_impl_.progress_percent_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TTSChunkPayloadDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TTSChunkPayloadDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TTSChunkPayloadDefaultTypeInternal() {}
  union {
    TTSChunkPayload _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TTSChunkPayloadDefaultTypeInternal _TTSChunkPayload_default_instance_;
PROTOBUF_CONSTEXPR STTChunkPayload::STTChunkPayload(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.stt_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.audio_metadata_)*/nullptr
  , /*decltype(_impl_.is_final_chunk_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct STTChunkPayloadDefaultTypeInternal {
  PROTOBUF_CONSTEXPR STTChunkPayloadDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~STTChunkPayloadDefaultTypeInternal() {}
  union {
    STTChunkPayload _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 STTChunkPayloadDefaultTypeInternal _STTChunkPayload_default_instance_;
PROTOBUF_CONSTEXPR AudioMetadata::AudioMetadata(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.format_)*/0
  , /*decltype(_impl_.sample_rate_)*/0
  , /*decltype(_impl_.channels_)*/0
  , /*decltype(_impl_.bit_depth_)*/0
  , /*decltype(_impl_.total_bytes_)*/int64_t{0}
  , /*decltype(_impl_.duration_seconds_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AudioMetadataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AudioMetadataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AudioMetadataDefaultTypeInternal() {}
  union {
    AudioMetadata _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AudioMetadataDefaultTypeInternal _AudioMetadata_default_instance_;
PROTOBUF_CONSTEXPR ProcessAudioRequest::ProcessAudioRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.audio_file_)*/nullptr
  , /*decltype(_impl_.options_)*/nullptr
  , /*decltype(_impl_.processing_type_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ProcessAudioRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ProcessAudioRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ProcessAudioRequestDefaultTypeInternal() {}
  union {
    ProcessAudioRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProcessAudioRequestDefaultTypeInternal _ProcessAudioRequest_default_instance_;
PROTOBUF_CONSTEXPR ProcessAudioResponse::ProcessAudioResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.response_)*/nullptr
  , /*decltype(_impl_.usage_)*/nullptr
  , /*decltype(_impl_.result_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct ProcessAudioResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ProcessAudioResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ProcessAudioResponseDefaultTypeInternal() {}
  union {
    ProcessAudioResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProcessAudioResponseDefaultTypeInternal _ProcessAudioResponse_default_instance_;
PROTOBUF_CONSTEXPR ListVoicesRequest::ListVoicesRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.filters_)*/{}
  , /*decltype(_impl_.language_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.pagination_)*/nullptr
  , /*decltype(_impl_.gender_)*/0
  , /*decltype(_impl_.style_)*/0
  , /*decltype(_impl_.premium_only_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ListVoicesRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ListVoicesRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ListVoicesRequestDefaultTypeInternal() {}
  union {
    ListVoicesRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ListVoicesRequestDefaultTypeInternal _ListVoicesRequest_default_instance_;
PROTOBUF_CONSTEXPR ListVoicesResponse::ListVoicesResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.voices_)*/{}
  , /*decltype(_impl_.response_)*/nullptr
  , /*decltype(_impl_.pagination_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ListVoicesResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ListVoicesResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ListVoicesResponseDefaultTypeInternal() {}
  union {
    ListVoicesResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ListVoicesResponseDefaultTypeInternal _ListVoicesResponse_default_instance_;
PROTOBUF_CONSTEXPR GetVoiceRequest::GetVoiceRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.voice_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.include_preview_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GetVoiceRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetVoiceRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetVoiceRequestDefaultTypeInternal() {}
  union {
    GetVoiceRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetVoiceRequestDefaultTypeInternal _GetVoiceRequest_default_instance_;
PROTOBUF_CONSTEXPR GetVoiceResponse::GetVoiceResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.response_)*/nullptr
  , /*decltype(_impl_.voice_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GetVoiceResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetVoiceResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetVoiceResponseDefaultTypeInternal() {}
  union {
    GetVoiceResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetVoiceResponseDefaultTypeInternal _GetVoiceResponse_default_instance_;
PROTOBUF_CONSTEXPR CreateCustomVoiceRequest::CreateCustomVoiceRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.training_samples_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.target_gender_)*/0
  , /*decltype(_impl_.target_style_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CreateCustomVoiceRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CreateCustomVoiceRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CreateCustomVoiceRequestDefaultTypeInternal() {}
  union {
    CreateCustomVoiceRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CreateCustomVoiceRequestDefaultTypeInternal _CreateCustomVoiceRequest_default_instance_;
PROTOBUF_CONSTEXPR CreateCustomVoiceResponse::CreateCustomVoiceResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.training_job_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.response_)*/nullptr
  , /*decltype(_impl_.voice_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CreateCustomVoiceResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CreateCustomVoiceResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CreateCustomVoiceResponseDefaultTypeInternal() {}
  union {
    CreateCustomVoiceResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CreateCustomVoiceResponseDefaultTypeInternal _CreateCustomVoiceResponse_default_instance_;
PROTOBUF_CONSTEXPR ConvertAudioRequest::ConvertAudioRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.input_audio_)*/nullptr
  , /*decltype(_impl_.options_)*/nullptr
  , /*decltype(_impl_.target_format_)*/0
  , /*decltype(_impl_.target_sample_rate_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ConvertAudioRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConvertAudioRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConvertAudioRequestDefaultTypeInternal() {}
  union {
    ConvertAudioRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConvertAudioRequestDefaultTypeInternal _ConvertAudioRequest_default_instance_;
PROTOBUF_CONSTEXPR ConvertAudioResponse::ConvertAudioResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.response_)*/nullptr
  , /*decltype(_impl_.converted_audio_)*/nullptr
  , /*decltype(_impl_.usage_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ConvertAudioResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConvertAudioResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConvertAudioResponseDefaultTypeInternal() {}
  union {
    ConvertAudioResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConvertAudioResponseDefaultTypeInternal _ConvertAudioResponse_default_instance_;
PROTOBUF_CONSTEXPR AnalyzeAudioRequest::AnalyzeAudioRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.analysis_types_)*/{}
  , /*decltype(_impl_._analysis_types_cached_byte_size_)*/{0}
  , /*decltype(_impl_.audio_file_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AnalyzeAudioRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AnalyzeAudioRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AnalyzeAudioRequestDefaultTypeInternal() {}
  union {
    AnalyzeAudioRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AnalyzeAudioRequestDefaultTypeInternal _AnalyzeAudioRequest_default_instance_;
PROTOBUF_CONSTEXPR AnalyzeAudioResponse::AnalyzeAudioResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.response_)*/nullptr
  , /*decltype(_impl_.analysis_)*/nullptr
  , /*decltype(_impl_.usage_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AnalyzeAudioResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AnalyzeAudioResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AnalyzeAudioResponseDefaultTypeInternal() {}
  union {
    AnalyzeAudioResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AnalyzeAudioResponseDefaultTypeInternal _AnalyzeAudioResponse_default_instance_;
PROTOBUF_CONSTEXPR AudioAnalysis::AudioAnalysis(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.speech_segments_)*/{}
  , /*decltype(_impl_.detected_languages_)*/{}
  , /*decltype(_impl_.speaker_segments_)*/{}
  , /*decltype(_impl_.emotion_segments_)*/{}
  , /*decltype(_impl_.quality_metrics_)*/nullptr
  , /*decltype(_impl_.contains_speech_)*/false
  , /*decltype(_impl_.speech_percentage_)*/0
  , /*decltype(_impl_.speaker_count_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AudioAnalysisDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AudioAnalysisDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AudioAnalysisDefaultTypeInternal() {}
  union {
    AudioAnalysis _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AudioAnalysisDefaultTypeInternal _AudioAnalysis_default_instance_;
PROTOBUF_CONSTEXPR SpeechSegment::SpeechSegment(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.start_time_)*/0
  , /*decltype(_impl_.end_time_)*/0
  , /*decltype(_impl_.confidence_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SpeechSegmentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SpeechSegmentDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SpeechSegmentDefaultTypeInternal() {}
  union {
    SpeechSegment _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SpeechSegmentDefaultTypeInternal _SpeechSegment_default_instance_;
PROTOBUF_CONSTEXPR LanguageDetection::LanguageDetection(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.language_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.language_code_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.confidence_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LanguageDetectionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LanguageDetectionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LanguageDetectionDefaultTypeInternal() {}
  union {
    LanguageDetection _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LanguageDetectionDefaultTypeInternal _LanguageDetection_default_instance_;
PROTOBUF_CONSTEXPR SpeakerSegment::SpeakerSegment(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.speaker_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.start_time_)*/0
  , /*decltype(_impl_.end_time_)*/0
  , /*decltype(_impl_.confidence_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SpeakerSegmentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SpeakerSegmentDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SpeakerSegmentDefaultTypeInternal() {}
  union {
    SpeakerSegment _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SpeakerSegmentDefaultTypeInternal _SpeakerSegment_default_instance_;
PROTOBUF_CONSTEXPR EmotionSegment::EmotionSegment(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.emotion_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.start_time_)*/0
  , /*decltype(_impl_.end_time_)*/0
  , /*decltype(_impl_.confidence_)*/0
  , /*decltype(_impl_.intensity_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct EmotionSegmentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EmotionSegmentDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EmotionSegmentDefaultTypeInternal() {}
  union {
    EmotionSegment _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EmotionSegmentDefaultTypeInternal _EmotionSegment_default_instance_;
PROTOBUF_CONSTEXPR AudioQualityMetrics::AudioQualityMetrics(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.signal_to_noise_ratio_)*/0
  , /*decltype(_impl_.dynamic_range_)*/0
  , /*decltype(_impl_.has_clipping_)*/false
  , /*decltype(_impl_.has_background_noise_)*/false
  , /*decltype(_impl_.overall_quality_score_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AudioQualityMetricsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AudioQualityMetricsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AudioQualityMetricsDefaultTypeInternal() {}
  union {
    AudioQualityMetrics _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AudioQualityMetricsDefaultTypeInternal _AudioQualityMetrics_default_instance_;
}  // namespace v1
}  // namespace audio
}  // namespace unhinged
static ::_pb::Metadata file_level_metadata_audio_2eproto[30];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_audio_2eproto[8];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_audio_2eproto = nullptr;

const uint32_t TableStruct_audio_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::TTSRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::TTSRequest, _impl_.text_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::TTSRequest, _impl_.voice_id_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::TTSRequest, _impl_.options_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::TTSRequest, _impl_.output_format_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::TTSRequest, _impl_.sample_rate_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::TTSRequest, _impl_.channels_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::TTSRequest, _impl_.enable_ssml_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::TTSRequest, _impl_.effects_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::STTResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::STTResponse, _impl_.response_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::STTResponse, _impl_.transcript_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::STTResponse, _impl_.confidence_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::STTResponse, _impl_.segments_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::STTResponse, _impl_.usage_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::STTResponse, _impl_.metadata_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::AudioOptions, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::AudioOptions, _impl_.speed_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::AudioOptions, _impl_.pitch_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::AudioOptions, _impl_.volume_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::AudioOptions, _impl_.quality_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::AudioOptions, _impl_.enable_noise_reduction_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::AudioOptions, _impl_.enable_echo_cancellation_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::AudioEffect_ParametersEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::AudioEffect_ParametersEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::AudioEffect_ParametersEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::AudioEffect_ParametersEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::AudioEffect, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::AudioEffect, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::AudioEffect, _impl_.intensity_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::AudioEffect, _impl_.parameters_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::TranscriptSegment, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::TranscriptSegment, _impl_.text_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::TranscriptSegment, _impl_.start_time_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::TranscriptSegment, _impl_.end_time_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::TranscriptSegment, _impl_.confidence_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::TranscriptSegment, _impl_.words_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::TranscriptSegment, _impl_.speaker_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::WordTiming, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::WordTiming, _impl_.word_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::WordTiming, _impl_.start_time_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::WordTiming, _impl_.end_time_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::WordTiming, _impl_.confidence_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::STTMetadata, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::STTMetadata, _impl_.model_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::STTMetadata, _impl_.language_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::STTMetadata, _impl_.processing_time_ms_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::STTMetadata, _impl_.signal_to_noise_ratio_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::STTMetadata, _impl_.speech_rate_wpm_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::STTMetadata, _impl_.detected_languages_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::STTMetadata, _impl_.has_background_noise_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::STTMetadata, _impl_.has_multiple_speakers_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::STTMetadata, _impl_.detected_quality_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::Voice, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::Voice, _impl_.metadata_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::Voice, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::Voice, _impl_.display_name_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::Voice, _impl_.description_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::Voice, _impl_.language_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::Voice, _impl_.language_code_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::Voice, _impl_.gender_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::Voice, _impl_.age_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::Voice, _impl_.style_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::Voice, _impl_.supported_formats_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::Voice, _impl_.supported_sample_rates_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::Voice, _impl_.is_available_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::Voice, _impl_.is_premium_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::Voice, _impl_.cost_per_character_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::Voice, _impl_.preview_url_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::Voice, _impl_.preview_text_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::TTSChunkPayload, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::TTSChunkPayload, _impl_.tts_id_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::TTSChunkPayload, _impl_.audio_metadata_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::TTSChunkPayload, _impl_.chunk_index_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::TTSChunkPayload, _impl_.progress_percent_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::STTChunkPayload, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::STTChunkPayload, _impl_.stt_id_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::STTChunkPayload, _impl_.audio_metadata_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::STTChunkPayload, _impl_.is_final_chunk_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::AudioMetadata, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::AudioMetadata, _impl_.format_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::AudioMetadata, _impl_.sample_rate_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::AudioMetadata, _impl_.channels_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::AudioMetadata, _impl_.bit_depth_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::AudioMetadata, _impl_.duration_seconds_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::AudioMetadata, _impl_.total_bytes_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::ProcessAudioRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::ProcessAudioRequest, _impl_.audio_file_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::ProcessAudioRequest, _impl_.processing_type_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::ProcessAudioRequest, _impl_.options_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::ProcessAudioResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::ProcessAudioResponse, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::ProcessAudioResponse, _impl_.response_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::ProcessAudioResponse, _impl_.usage_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::ProcessAudioResponse, _impl_.result_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::ListVoicesRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::ListVoicesRequest, _impl_.language_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::ListVoicesRequest, _impl_.gender_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::ListVoicesRequest, _impl_.style_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::ListVoicesRequest, _impl_.premium_only_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::ListVoicesRequest, _impl_.pagination_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::ListVoicesRequest, _impl_.filters_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::ListVoicesResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::ListVoicesResponse, _impl_.response_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::ListVoicesResponse, _impl_.voices_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::ListVoicesResponse, _impl_.pagination_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::GetVoiceRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::GetVoiceRequest, _impl_.voice_id_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::GetVoiceRequest, _impl_.include_preview_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::GetVoiceResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::GetVoiceResponse, _impl_.response_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::GetVoiceResponse, _impl_.voice_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::CreateCustomVoiceRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::CreateCustomVoiceRequest, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::CreateCustomVoiceRequest, _impl_.description_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::CreateCustomVoiceRequest, _impl_.training_samples_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::CreateCustomVoiceRequest, _impl_.target_gender_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::CreateCustomVoiceRequest, _impl_.target_style_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::CreateCustomVoiceResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::CreateCustomVoiceResponse, _impl_.response_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::CreateCustomVoiceResponse, _impl_.voice_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::CreateCustomVoiceResponse, _impl_.training_job_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::ConvertAudioRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::ConvertAudioRequest, _impl_.input_audio_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::ConvertAudioRequest, _impl_.target_format_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::ConvertAudioRequest, _impl_.target_sample_rate_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::ConvertAudioRequest, _impl_.options_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::ConvertAudioResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::ConvertAudioResponse, _impl_.response_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::ConvertAudioResponse, _impl_.converted_audio_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::ConvertAudioResponse, _impl_.usage_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::AnalyzeAudioRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::AnalyzeAudioRequest, _impl_.audio_file_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::AnalyzeAudioRequest, _impl_.analysis_types_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::AnalyzeAudioResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::AnalyzeAudioResponse, _impl_.response_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::AnalyzeAudioResponse, _impl_.analysis_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::AnalyzeAudioResponse, _impl_.usage_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::AudioAnalysis, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::AudioAnalysis, _impl_.contains_speech_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::AudioAnalysis, _impl_.speech_percentage_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::AudioAnalysis, _impl_.speech_segments_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::AudioAnalysis, _impl_.detected_languages_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::AudioAnalysis, _impl_.speaker_count_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::AudioAnalysis, _impl_.speaker_segments_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::AudioAnalysis, _impl_.emotion_segments_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::AudioAnalysis, _impl_.quality_metrics_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::SpeechSegment, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::SpeechSegment, _impl_.start_time_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::SpeechSegment, _impl_.end_time_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::SpeechSegment, _impl_.confidence_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::LanguageDetection, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::LanguageDetection, _impl_.language_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::LanguageDetection, _impl_.language_code_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::LanguageDetection, _impl_.confidence_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::SpeakerSegment, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::SpeakerSegment, _impl_.speaker_id_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::SpeakerSegment, _impl_.start_time_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::SpeakerSegment, _impl_.end_time_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::SpeakerSegment, _impl_.confidence_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::EmotionSegment, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::EmotionSegment, _impl_.emotion_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::EmotionSegment, _impl_.start_time_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::EmotionSegment, _impl_.end_time_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::EmotionSegment, _impl_.confidence_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::EmotionSegment, _impl_.intensity_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::AudioQualityMetrics, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::AudioQualityMetrics, _impl_.signal_to_noise_ratio_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::AudioQualityMetrics, _impl_.dynamic_range_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::AudioQualityMetrics, _impl_.has_clipping_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::AudioQualityMetrics, _impl_.has_background_noise_),
  PROTOBUF_FIELD_OFFSET(::unhinged::audio::v1::AudioQualityMetrics, _impl_.overall_quality_score_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::unhinged::audio::v1::TTSRequest)},
  { 14, -1, -1, sizeof(::unhinged::audio::v1::STTResponse)},
  { 26, -1, -1, sizeof(::unhinged::audio::v1::AudioOptions)},
  { 38, 46, -1, sizeof(::unhinged::audio::v1::AudioEffect_ParametersEntry_DoNotUse)},
  { 48, -1, -1, sizeof(::unhinged::audio::v1::AudioEffect)},
  { 57, -1, -1, sizeof(::unhinged::audio::v1::TranscriptSegment)},
  { 69, -1, -1, sizeof(::unhinged::audio::v1::WordTiming)},
  { 79, -1, -1, sizeof(::unhinged::audio::v1::STTMetadata)},
  { 94, -1, -1, sizeof(::unhinged::audio::v1::Voice)},
  { 116, -1, -1, sizeof(::unhinged::audio::v1::TTSChunkPayload)},
  { 126, -1, -1, sizeof(::unhinged::audio::v1::STTChunkPayload)},
  { 135, -1, -1, sizeof(::unhinged::audio::v1::AudioMetadata)},
  { 147, -1, -1, sizeof(::unhinged::audio::v1::ProcessAudioRequest)},
  { 156, -1, -1, sizeof(::unhinged::audio::v1::ProcessAudioResponse)},
  { 169, -1, -1, sizeof(::unhinged::audio::v1::ListVoicesRequest)},
  { 181, -1, -1, sizeof(::unhinged::audio::v1::ListVoicesResponse)},
  { 190, -1, -1, sizeof(::unhinged::audio::v1::GetVoiceRequest)},
  { 198, -1, -1, sizeof(::unhinged::audio::v1::GetVoiceResponse)},
  { 206, -1, -1, sizeof(::unhinged::audio::v1::CreateCustomVoiceRequest)},
  { 217, -1, -1, sizeof(::unhinged::audio::v1::CreateCustomVoiceResponse)},
  { 226, -1, -1, sizeof(::unhinged::audio::v1::ConvertAudioRequest)},
  { 236, -1, -1, sizeof(::unhinged::audio::v1::ConvertAudioResponse)},
  { 245, -1, -1, sizeof(::unhinged::audio::v1::AnalyzeAudioRequest)},
  { 253, -1, -1, sizeof(::unhinged::audio::v1::AnalyzeAudioResponse)},
  { 262, -1, -1, sizeof(::unhinged::audio::v1::AudioAnalysis)},
  { 276, -1, -1, sizeof(::unhinged::audio::v1::SpeechSegment)},
  { 285, -1, -1, sizeof(::unhinged::audio::v1::LanguageDetection)},
  { 294, -1, -1, sizeof(::unhinged::audio::v1::SpeakerSegment)},
  { 304, -1, -1, sizeof(::unhinged::audio::v1::EmotionSegment)},
  { 315, -1, -1, sizeof(::unhinged::audio::v1::AudioQualityMetrics)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::unhinged::audio::v1::_TTSRequest_default_instance_._instance,
  &::unhinged::audio::v1::_STTResponse_default_instance_._instance,
  &::unhinged::audio::v1::_AudioOptions_default_instance_._instance,
  &::unhinged::audio::v1::_AudioEffect_ParametersEntry_DoNotUse_default_instance_._instance,
  &::unhinged::audio::v1::_AudioEffect_default_instance_._instance,
  &::unhinged::audio::v1::_TranscriptSegment_default_instance_._instance,
  &::unhinged::audio::v1::_WordTiming_default_instance_._instance,
  &::unhinged::audio::v1::_STTMetadata_default_instance_._instance,
  &::unhinged::audio::v1::_Voice_default_instance_._instance,
  &::unhinged::audio::v1::_TTSChunkPayload_default_instance_._instance,
  &::unhinged::audio::v1::_STTChunkPayload_default_instance_._instance,
  &::unhinged::audio::v1::_AudioMetadata_default_instance_._instance,
  &::unhinged::audio::v1::_ProcessAudioRequest_default_instance_._instance,
  &::unhinged::audio::v1::_ProcessAudioResponse_default_instance_._instance,
  &::unhinged::audio::v1::_ListVoicesRequest_default_instance_._instance,
  &::unhinged::audio::v1::_ListVoicesResponse_default_instance_._instance,
  &::unhinged::audio::v1::_GetVoiceRequest_default_instance_._instance,
  &::unhinged::audio::v1::_GetVoiceResponse_default_instance_._instance,
  &::unhinged::audio::v1::_CreateCustomVoiceRequest_default_instance_._instance,
  &::unhinged::audio::v1::_CreateCustomVoiceResponse_default_instance_._instance,
  &::unhinged::audio::v1::_ConvertAudioRequest_default_instance_._instance,
  &::unhinged::audio::v1::_ConvertAudioResponse_default_instance_._instance,
  &::unhinged::audio::v1::_AnalyzeAudioRequest_default_instance_._instance,
  &::unhinged::audio::v1::_AnalyzeAudioResponse_default_instance_._instance,
  &::unhinged::audio::v1::_AudioAnalysis_default_instance_._instance,
  &::unhinged::audio::v1::_SpeechSegment_default_instance_._instance,
  &::unhinged::audio::v1::_LanguageDetection_default_instance_._instance,
  &::unhinged::audio::v1::_SpeakerSegment_default_instance_._instance,
  &::unhinged::audio::v1::_EmotionSegment_default_instance_._instance,
  &::unhinged::audio::v1::_AudioQualityMetrics_default_instance_._instance,
};

const char descriptor_table_protodef_audio_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\013audio.proto\022\021unhinged.audio.v1\032\014common"
  ".proto\"\202\002\n\nTTSRequest\022\014\n\004text\030\001 \001(\t\022\020\n\010v"
  "oice_id\030\002 \001(\t\0220\n\007options\030\003 \001(\0132\037.unhinge"
  "d.audio.v1.AudioOptions\0225\n\routput_format"
  "\030\004 \001(\0162\036.unhinged.audio.v1.AudioFormat\022\023"
  "\n\013sample_rate\030\005 \001(\005\022\020\n\010channels\030\006 \001(\005\022\023\n"
  "\013enable_ssml\030\007 \001(\010\022/\n\007effects\030\010 \003(\0132\036.un"
  "hinged.audio.v1.AudioEffect\"\206\002\n\013STTRespo"
  "nse\0226\n\010response\030\001 \001(\0132$.unhinged.common."
  "v1.StandardResponse\022\022\n\ntranscript\030\002 \001(\t\022"
  "\022\n\nconfidence\030\003 \001(\002\0226\n\010segments\030\004 \003(\0132$."
  "unhinged.audio.v1.TranscriptSegment\022-\n\005u"
  "sage\030\005 \001(\0132\036.unhinged.common.v1.AudioUsa"
  "ge\0220\n\010metadata\030\006 \001(\0132\036.unhinged.audio.v1"
  ".STTMetadata\"\260\001\n\014AudioOptions\022\r\n\005speed\030\001"
  " \001(\002\022\r\n\005pitch\030\002 \001(\002\022\016\n\006volume\030\003 \001(\002\0220\n\007q"
  "uality\030\004 \001(\0162\037.unhinged.audio.v1.AudioQu"
  "ality\022\036\n\026enable_noise_reduction\030\005 \001(\010\022 \n"
  "\030enable_echo_cancellation\030\006 \001(\010\"\311\001\n\013Audi"
  "oEffect\0220\n\004type\030\001 \001(\0162\".unhinged.audio.v"
  "1.AudioEffectType\022\021\n\tintensity\030\002 \001(\002\022B\n\n"
  "parameters\030\003 \003(\0132..unhinged.audio.v1.Aud"
  "ioEffect.ParametersEntry\0321\n\017ParametersEn"
  "try\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:\0028\001\"\235\001\n\021"
  "TranscriptSegment\022\014\n\004text\030\001 \001(\t\022\022\n\nstart"
  "_time\030\002 \001(\002\022\020\n\010end_time\030\003 \001(\002\022\022\n\nconfide"
  "nce\030\004 \001(\002\022,\n\005words\030\005 \003(\0132\035.unhinged.audi"
  "o.v1.WordTiming\022\022\n\nspeaker_id\030\006 \001(\t\"T\n\nW"
  "ordTiming\022\014\n\004word\030\001 \001(\t\022\022\n\nstart_time\030\002 "
  "\001(\002\022\020\n\010end_time\030\003 \001(\002\022\022\n\nconfidence\030\004 \001("
  "\002\"\226\002\n\013STTMetadata\022\r\n\005model\030\001 \001(\t\022\020\n\010lang"
  "uage\030\002 \001(\t\022\032\n\022processing_time_ms\030\003 \001(\002\022\035"
  "\n\025signal_to_noise_ratio\030\004 \001(\002\022\027\n\017speech_"
  "rate_wpm\030\005 \001(\002\022\032\n\022detected_languages\030\006 \003"
  "(\t\022\034\n\024has_background_noise\030\007 \001(\010\022\035\n\025has_"
  "multiple_speakers\030\010 \001(\010\0229\n\020detected_qual"
  "ity\030\t \001(\0162\037.unhinged.audio.v1.AudioQuali"
  "ty\"\365\003\n\005Voice\0226\n\010metadata\030\001 \001(\0132$.unhinge"
  "d.common.v1.ResourceMetadata\022\014\n\004name\030\002 \001"
  "(\t\022\024\n\014display_name\030\003 \001(\t\022\023\n\013description\030"
  "\004 \001(\t\022\020\n\010language\030\005 \001(\t\022\025\n\rlanguage_code"
  "\030\006 \001(\t\022.\n\006gender\030\007 \001(\0162\036.unhinged.audio."
  "v1.VoiceGender\022(\n\003age\030\010 \001(\0162\033.unhinged.a"
  "udio.v1.VoiceAge\022,\n\005style\030\t \001(\0162\035.unhing"
  "ed.audio.v1.VoiceStyle\0229\n\021supported_form"
  "ats\030\n \003(\0162\036.unhinged.audio.v1.AudioForma"
  "t\022\036\n\026supported_sample_rates\030\013 \003(\005\022\024\n\014is_"
  "available\030\014 \001(\010\022\022\n\nis_premium\030\r \001(\010\022\032\n\022c"
  "ost_per_character\030\016 \001(\002\022\023\n\013preview_url\030\017"
  " \001(\t\022\024\n\014preview_text\030\020 \001(\t\"\212\001\n\017TTSChunkP"
  "ayload\022\016\n\006tts_id\030\001 \001(\t\0228\n\016audio_metadata"
  "\030\002 \001(\0132 .unhinged.audio.v1.AudioMetadata"
  "\022\023\n\013chunk_index\030\003 \001(\005\022\030\n\020progress_percen"
  "t\030\004 \001(\002\"s\n\017STTChunkPayload\022\016\n\006stt_id\030\001 \001"
  "(\t\0228\n\016audio_metadata\030\002 \001(\0132 .unhinged.au"
  "dio.v1.AudioMetadata\022\026\n\016is_final_chunk\030\003"
  " \001(\010\"\250\001\n\rAudioMetadata\022.\n\006format\030\001 \001(\0162\036"
  ".unhinged.audio.v1.AudioFormat\022\023\n\013sample"
  "_rate\030\002 \001(\005\022\020\n\010channels\030\003 \001(\005\022\021\n\tbit_dep"
  "th\030\004 \001(\005\022\030\n\020duration_seconds\030\005 \001(\002\022\023\n\013to"
  "tal_bytes\030\006 \001(\003\"\267\001\n\023ProcessAudioRequest\022"
  "2\n\naudio_file\030\001 \001(\0132\036.unhinged.common.v1"
  ".Attachment\022:\n\017processing_type\030\002 \001(\0162!.u"
  "nhinged.audio.v1.ProcessingType\0220\n\007optio"
  "ns\030\003 \001(\0132\037.unhinged.audio.v1.AudioOption"
  "s\"\251\002\n\024ProcessAudioResponse\0226\n\010response\030\001"
  " \001(\0132$.unhinged.common.v1.StandardRespon"
  "se\022\024\n\ntranscript\030\002 \001(\tH\000\022\025\n\013translation\030"
  "\003 \001(\tH\000\0228\n\016enhanced_audio\030\004 \001(\0132\036.unhing"
  "ed.common.v1.AttachmentH\000\0229\n\017converted_a"
  "udio\030\005 \001(\0132\036.unhinged.common.v1.Attachme"
  "ntH\000\022-\n\005usage\030\006 \001(\0132\036.unhinged.common.v1"
  ".AudioUsageB\010\n\006result\"\201\002\n\021ListVoicesRequ"
  "est\022\020\n\010language\030\001 \001(\t\022.\n\006gender\030\002 \001(\0162\036."
  "unhinged.audio.v1.VoiceGender\022,\n\005style\030\003"
  " \001(\0162\035.unhinged.audio.v1.VoiceStyle\022\024\n\014p"
  "remium_only\030\004 \001(\010\0229\n\npagination\030\005 \001(\0132%."
  "unhinged.common.v1.PaginationRequest\022+\n\007"
  "filters\030\006 \003(\0132\032.unhinged.common.v1.Filte"
  "r\"\262\001\n\022ListVoicesResponse\0226\n\010response\030\001 \001"
  "(\0132$.unhinged.common.v1.StandardResponse"
  "\022(\n\006voices\030\002 \003(\0132\030.unhinged.audio.v1.Voi"
  "ce\022:\n\npagination\030\003 \001(\0132&.unhinged.common"
  ".v1.PaginationResponse\"<\n\017GetVoiceReques"
  "t\022\020\n\010voice_id\030\001 \001(\t\022\027\n\017include_preview\030\002"
  " \001(\010\"s\n\020GetVoiceResponse\0226\n\010response\030\001 \001"
  "(\0132$.unhinged.common.v1.StandardResponse"
  "\022\'\n\005voice\030\002 \001(\0132\030.unhinged.audio.v1.Voic"
  "e\"\343\001\n\030CreateCustomVoiceRequest\022\014\n\004name\030\001"
  " \001(\t\022\023\n\013description\030\002 \001(\t\0228\n\020training_sa"
  "mples\030\003 \003(\0132\036.unhinged.common.v1.Attachm"
  "ent\0225\n\rtarget_gender\030\004 \001(\0162\036.unhinged.au"
  "dio.v1.VoiceGender\0223\n\014target_style\030\005 \001(\016"
  "2\035.unhinged.audio.v1.VoiceStyle\"\225\001\n\031Crea"
  "teCustomVoiceResponse\0226\n\010response\030\001 \001(\0132"
  "$.unhinged.common.v1.StandardResponse\022\'\n"
  "\005voice\030\002 \001(\0132\030.unhinged.audio.v1.Voice\022\027"
  "\n\017training_job_id\030\003 \001(\t\"\317\001\n\023ConvertAudio"
  "Request\0223\n\013input_audio\030\001 \001(\0132\036.unhinged."
  "common.v1.Attachment\0225\n\rtarget_format\030\002 "
  "\001(\0162\036.unhinged.audio.v1.AudioFormat\022\032\n\022t"
  "arget_sample_rate\030\003 \001(\005\0220\n\007options\030\004 \001(\013"
  "2\037.unhinged.audio.v1.AudioOptions\"\266\001\n\024Co"
  "nvertAudioResponse\0226\n\010response\030\001 \001(\0132$.u"
  "nhinged.common.v1.StandardResponse\0227\n\017co"
  "nverted_audio\030\002 \001(\0132\036.unhinged.common.v1"
  ".Attachment\022-\n\005usage\030\003 \001(\0132\036.unhinged.co"
  "mmon.v1.AudioUsage\"\202\001\n\023AnalyzeAudioReque"
  "st\0222\n\naudio_file\030\001 \001(\0132\036.unhinged.common"
  ".v1.Attachment\0227\n\016analysis_types\030\002 \003(\0162\037"
  ".unhinged.audio.v1.AnalysisType\"\261\001\n\024Anal"
  "yzeAudioResponse\0226\n\010response\030\001 \001(\0132$.unh"
  "inged.common.v1.StandardResponse\0222\n\010anal"
  "ysis\030\002 \001(\0132 .unhinged.audio.v1.AudioAnal"
  "ysis\022-\n\005usage\030\003 \001(\0132\036.unhinged.common.v1"
  ".AudioUsage\"\222\003\n\rAudioAnalysis\022\027\n\017contain"
  "s_speech\030\001 \001(\010\022\031\n\021speech_percentage\030\002 \001("
  "\002\0229\n\017speech_segments\030\003 \003(\0132 .unhinged.au"
  "dio.v1.SpeechSegment\022@\n\022detected_languag"
  "es\030\004 \003(\0132$.unhinged.audio.v1.LanguageDet"
  "ection\022\025\n\rspeaker_count\030\005 \001(\005\022;\n\020speaker"
  "_segments\030\006 \003(\0132!.unhinged.audio.v1.Spea"
  "kerSegment\022;\n\020emotion_segments\030\007 \003(\0132!.u"
  "nhinged.audio.v1.EmotionSegment\022\?\n\017quali"
  "ty_metrics\030\010 \001(\0132&.unhinged.audio.v1.Aud"
  "ioQualityMetrics\"I\n\rSpeechSegment\022\022\n\nsta"
  "rt_time\030\001 \001(\002\022\020\n\010end_time\030\002 \001(\002\022\022\n\nconfi"
  "dence\030\003 \001(\002\"P\n\021LanguageDetection\022\020\n\010lang"
  "uage\030\001 \001(\t\022\025\n\rlanguage_code\030\002 \001(\t\022\022\n\ncon"
  "fidence\030\003 \001(\002\"^\n\016SpeakerSegment\022\022\n\nspeak"
  "er_id\030\001 \001(\t\022\022\n\nstart_time\030\002 \001(\002\022\020\n\010end_t"
  "ime\030\003 \001(\002\022\022\n\nconfidence\030\004 \001(\002\"n\n\016Emotion"
  "Segment\022\017\n\007emotion\030\001 \001(\t\022\022\n\nstart_time\030\002"
  " \001(\002\022\020\n\010end_time\030\003 \001(\002\022\022\n\nconfidence\030\004 \001"
  "(\002\022\021\n\tintensity\030\005 \001(\002\"\236\001\n\023AudioQualityMe"
  "trics\022\035\n\025signal_to_noise_ratio\030\001 \001(\002\022\025\n\r"
  "dynamic_range\030\002 \001(\002\022\024\n\014has_clipping\030\003 \001("
  "\010\022\034\n\024has_background_noise\030\004 \001(\010\022\035\n\025overa"
  "ll_quality_score\030\005 \001(\002*\223\001\n\014AudioQuality\022"
  "\035\n\031AUDIO_QUALITY_UNSPECIFIED\020\000\022\025\n\021AUDIO_"
  "QUALITY_LOW\020\001\022\032\n\026AUDIO_QUALITY_STANDARD\020"
  "\002\022\026\n\022AUDIO_QUALITY_HIGH\020\003\022\031\n\025AUDIO_QUALI"
  "TY_PREMIUM\020\004*\307\001\n\013AudioFormat\022\034\n\030AUDIO_FO"
  "RMAT_UNSPECIFIED\020\000\022\024\n\020AUDIO_FORMAT_WAV\020\001"
  "\022\024\n\020AUDIO_FORMAT_MP3\020\002\022\024\n\020AUDIO_FORMAT_O"
  "GG\020\003\022\025\n\021AUDIO_FORMAT_FLAC\020\004\022\024\n\020AUDIO_FOR"
  "MAT_PCM\020\005\022\025\n\021AUDIO_FORMAT_OPUS\020\006\022\024\n\020AUDI"
  "O_FORMAT_AAC\020\007*\361\001\n\017AudioEffectType\022!\n\035AU"
  "DIO_EFFECT_TYPE_UNSPECIFIED\020\000\022\034\n\030AUDIO_E"
  "FFECT_TYPE_REVERB\020\001\022\032\n\026AUDIO_EFFECT_TYPE"
  "_ECHO\020\002\022\034\n\030AUDIO_EFFECT_TYPE_CHORUS\020\003\022 \n"
  "\034AUDIO_EFFECT_TYPE_DISTORTION\020\004\022\037\n\033AUDIO"
  "_EFFECT_TYPE_NORMALIZE\020\005\022 \n\034AUDIO_EFFECT"
  "_TYPE_COMPRESSOR\020\006*\215\001\n\013VoiceGender\022\034\n\030VO"
  "ICE_GENDER_UNSPECIFIED\020\000\022\025\n\021VOICE_GENDER"
  "_MALE\020\001\022\027\n\023VOICE_GENDER_FEMALE\020\002\022\030\n\024VOIC"
  "E_GENDER_NEUTRAL\020\003\022\026\n\022VOICE_GENDER_CHILD"
  "\020\004*\200\001\n\010VoiceAge\022\031\n\025VOICE_AGE_UNSPECIFIED"
  "\020\000\022\023\n\017VOICE_AGE_CHILD\020\001\022\031\n\025VOICE_AGE_YOU"
  "NG_ADULT\020\002\022\023\n\017VOICE_AGE_ADULT\020\003\022\024\n\020VOICE"
  "_AGE_SENIOR\020\004*\353\001\n\nVoiceStyle\022\033\n\027VOICE_ST"
  "YLE_UNSPECIFIED\020\000\022\036\n\032VOICE_STYLE_CONVERS"
  "ATIONAL\020\001\022\034\n\030VOICE_STYLE_PROFESSIONAL\020\002\022"
  "\030\n\024VOICE_STYLE_FRIENDLY\020\003\022\035\n\031VOICE_STYLE"
  "_AUTHORITATIVE\020\004\022\024\n\020VOICE_STYLE_CALM\020\005\022\031"
  "\n\025VOICE_STYLE_ENERGETIC\020\006\022\030\n\024VOICE_STYLE"
  "_DRAMATIC\020\007*\252\001\n\016ProcessingType\022\037\n\033PROCES"
  "SING_TYPE_UNSPECIFIED\020\000\022\036\n\032PROCESSING_TY"
  "PE_TRANSCRIBE\020\001\022\035\n\031PROCESSING_TYPE_TRANS"
  "LATE\020\002\022\033\n\027PROCESSING_TYPE_ENHANCE\020\003\022\033\n\027P"
  "ROCESSING_TYPE_CONVERT\020\004*\354\001\n\014AnalysisTyp"
  "e\022\035\n\031ANALYSIS_TYPE_UNSPECIFIED\020\000\022\"\n\036ANAL"
  "YSIS_TYPE_SPEECH_DETECTION\020\001\022$\n ANALYSIS"
  "_TYPE_LANGUAGE_DETECTION\020\002\022(\n$ANALYSIS_T"
  "YPE_SPEAKER_IDENTIFICATION\020\003\022#\n\037ANALYSIS"
  "_TYPE_EMOTION_DETECTION\020\004\022$\n ANALYSIS_TY"
  "PE_QUALITY_ASSESSMENT\020\0052\340\006\n\014AudioService"
  "\022P\n\014TextToSpeech\022\035.unhinged.audio.v1.TTS"
  "Request\032\037.unhinged.common.v1.StreamChunk"
  "0\001\022Q\n\014SpeechToText\022\037.unhinged.common.v1."
  "StreamChunk\032\036.unhinged.audio.v1.STTRespo"
  "nse(\001\022c\n\020ProcessAudioFile\022&.unhinged.aud"
  "io.v1.ProcessAudioRequest\032\'.unhinged.aud"
  "io.v1.ProcessAudioResponse\022Y\n\nListVoices"
  "\022$.unhinged.audio.v1.ListVoicesRequest\032%"
  ".unhinged.audio.v1.ListVoicesResponse\022S\n"
  "\010GetVoice\022\".unhinged.audio.v1.GetVoiceRe"
  "quest\032#.unhinged.audio.v1.GetVoiceRespon"
  "se\022n\n\021CreateCustomVoice\022+.unhinged.audio"
  ".v1.CreateCustomVoiceRequest\032,.unhinged."
  "audio.v1.CreateCustomVoiceResponse\022e\n\022Co"
  "nvertAudioFormat\022&.unhinged.audio.v1.Con"
  "vertAudioRequest\032\'.unhinged.audio.v1.Con"
  "vertAudioResponse\022_\n\014AnalyzeAudio\022&.unhi"
  "nged.audio.v1.AnalyzeAudioRequest\032\'.unhi"
  "nged.audio.v1.AnalyzeAudioResponse\022^\n\013He"
  "althCheck\022&.unhinged.common.v1.HealthChe"
  "ckRequest\032\'.unhinged.common.v1.HealthChe"
  "ckResponseB\036\n\016unhinged.audioB\nAudioProto"
  "P\001b\006proto3"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_audio_2eproto_deps[1] = {
  &::descriptor_table_common_2eproto,
};
static ::_pbi::once_flag descriptor_table_audio_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_audio_2eproto = {
    false, false, 7970, descriptor_table_protodef_audio_2eproto,
    "audio.proto",
    &descriptor_table_audio_2eproto_once, descriptor_table_audio_2eproto_deps, 1, 30,
    schemas, file_default_instances, TableStruct_audio_2eproto::offsets,
    file_level_metadata_audio_2eproto, file_level_enum_descriptors_audio_2eproto,
    file_level_service_descriptors_audio_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_audio_2eproto_getter() {
  return &descriptor_table_audio_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_audio_2eproto(&descriptor_table_audio_2eproto);
namespace unhinged {
namespace audio {
namespace v1 {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AudioQuality_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_audio_2eproto);
  return file_level_enum_descriptors_audio_2eproto[0];
}
bool AudioQuality_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AudioFormat_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_audio_2eproto);
  return file_level_enum_descriptors_audio_2eproto[1];
}
bool AudioFormat_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AudioEffectType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_audio_2eproto);
  return file_level_enum_descriptors_audio_2eproto[2];
}
bool AudioEffectType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VoiceGender_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_audio_2eproto);
  return file_level_enum_descriptors_audio_2eproto[3];
}
bool VoiceGender_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VoiceAge_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_audio_2eproto);
  return file_level_enum_descriptors_audio_2eproto[4];
}
bool VoiceAge_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VoiceStyle_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_audio_2eproto);
  return file_level_enum_descriptors_audio_2eproto[5];
}
bool VoiceStyle_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ProcessingType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_audio_2eproto);
  return file_level_enum_descriptors_audio_2eproto[6];
}
bool ProcessingType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AnalysisType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_audio_2eproto);
  return file_level_enum_descriptors_audio_2eproto[7];
}
bool AnalysisType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class TTSRequest::_Internal {
 public:
  static const ::unhinged::audio::v1::AudioOptions& options(const TTSRequest* msg);
};

const ::unhinged::audio::v1::AudioOptions&
TTSRequest::_Internal::options(const TTSRequest* msg) {
  return *msg->_impl_.options_;
}
TTSRequest::TTSRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unhinged.audio.v1.TTSRequest)
}
TTSRequest::TTSRequest(const TTSRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TTSRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.effects_){from._impl_.effects_}
    , decltype(_impl_.text_){}
    , decltype(_impl_.voice_id_){}
    , decltype(_impl_.options_){nullptr}
    , decltype(_impl_.output_format_){}
    , decltype(_impl_.sample_rate_){}
    , decltype(_impl_.channels_){}
    , decltype(_impl_.enable_ssml_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_text().empty()) {
    _this->_impl_.text_.Set(from._internal_text(), 
      _this->GetArenaForAllocation());
  }
  _impl_.voice_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.voice_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_voice_id().empty()) {
    _this->_impl_.voice_id_.Set(from._internal_voice_id(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_options()) {
    _this->_impl_.options_ = new ::unhinged::audio::v1::AudioOptions(*from._impl_.options_);
  }
  ::memcpy(&_impl_.output_format_, &from._impl_.output_format_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.enable_ssml_) -
    reinterpret_cast<char*>(&_impl_.output_format_)) + sizeof(_impl_.enable_ssml_));
  // @@protoc_insertion_point(copy_constructor:unhinged.audio.v1.TTSRequest)
}

inline void TTSRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.effects_){arena}
    , decltype(_impl_.text_){}
    , decltype(_impl_.voice_id_){}
    , decltype(_impl_.options_){nullptr}
    , decltype(_impl_.output_format_){0}
    , decltype(_impl_.sample_rate_){0}
    , decltype(_impl_.channels_){0}
    , decltype(_impl_.enable_ssml_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.voice_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.voice_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TTSRequest::~TTSRequest() {
  // @@protoc_insertion_point(destructor:unhinged.audio.v1.TTSRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TTSRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.effects_.~RepeatedPtrField();
  _impl_.text_.Destroy();
  _impl_.voice_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.options_;
}

void TTSRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TTSRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:unhinged.audio.v1.TTSRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.effects_.Clear();
  _impl_.text_.ClearToEmpty();
  _impl_.voice_id_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.options_ != nullptr) {
    delete _impl_.options_;
  }
  _impl_.options_ = nullptr;
  ::memset(&_impl_.output_format_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.enable_ssml_) -
      reinterpret_cast<char*>(&_impl_.output_format_)) + sizeof(_impl_.enable_ssml_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TTSRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string text = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "unhinged.audio.v1.TTSRequest.text"));
        } else
          goto handle_unusual;
        continue;
      // string voice_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_voice_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "unhinged.audio.v1.TTSRequest.voice_id"));
        } else
          goto handle_unusual;
        continue;
      // .unhinged.audio.v1.AudioOptions options = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_options(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .unhinged.audio.v1.AudioFormat output_format = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_output_format(static_cast<::unhinged::audio::v1::AudioFormat>(val));
        } else
          goto handle_unusual;
        continue;
      // int32 sample_rate = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.sample_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 channels = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.channels_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool enable_ssml = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.enable_ssml_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .unhinged.audio.v1.AudioEffect effects = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_effects(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TTSRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unhinged.audio.v1.TTSRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string text = 1;
  if (!this->_internal_text().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_text().data(), static_cast<int>(this->_internal_text().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "unhinged.audio.v1.TTSRequest.text");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_text(), target);
  }

  // string voice_id = 2;
  if (!this->_internal_voice_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_voice_id().data(), static_cast<int>(this->_internal_voice_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "unhinged.audio.v1.TTSRequest.voice_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_voice_id(), target);
  }

  // .unhinged.audio.v1.AudioOptions options = 3;
  if (this->_internal_has_options()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::options(this),
        _Internal::options(this).GetCachedSize(), target, stream);
  }

  // .unhinged.audio.v1.AudioFormat output_format = 4;
  if (this->_internal_output_format() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_output_format(), target);
  }

  // int32 sample_rate = 5;
  if (this->_internal_sample_rate() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_sample_rate(), target);
  }

  // int32 channels = 6;
  if (this->_internal_channels() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_channels(), target);
  }

  // bool enable_ssml = 7;
  if (this->_internal_enable_ssml() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_enable_ssml(), target);
  }

  // repeated .unhinged.audio.v1.AudioEffect effects = 8;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_effects_size()); i < n; i++) {
    const auto& repfield = this->_internal_effects(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unhinged.audio.v1.TTSRequest)
  return target;
}

size_t TTSRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unhinged.audio.v1.TTSRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .unhinged.audio.v1.AudioEffect effects = 8;
  total_size += 1UL * this->_internal_effects_size();
  for (const auto& msg : this->_impl_.effects_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string text = 1;
  if (!this->_internal_text().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_text());
  }

  // string voice_id = 2;
  if (!this->_internal_voice_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_voice_id());
  }

  // .unhinged.audio.v1.AudioOptions options = 3;
  if (this->_internal_has_options()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.options_);
  }

  // .unhinged.audio.v1.AudioFormat output_format = 4;
  if (this->_internal_output_format() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_output_format());
  }

  // int32 sample_rate = 5;
  if (this->_internal_sample_rate() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_sample_rate());
  }

  // int32 channels = 6;
  if (this->_internal_channels() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_channels());
  }

  // bool enable_ssml = 7;
  if (this->_internal_enable_ssml() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TTSRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TTSRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TTSRequest::GetClassData() const { return &_class_data_; }


void TTSRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TTSRequest*>(&to_msg);
  auto& from = static_cast<const TTSRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unhinged.audio.v1.TTSRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.effects_.MergeFrom(from._impl_.effects_);
  if (!from._internal_text().empty()) {
    _this->_internal_set_text(from._internal_text());
  }
  if (!from._internal_voice_id().empty()) {
    _this->_internal_set_voice_id(from._internal_voice_id());
  }
  if (from._internal_has_options()) {
    _this->_internal_mutable_options()->::unhinged::audio::v1::AudioOptions::MergeFrom(
        from._internal_options());
  }
  if (from._internal_output_format() != 0) {
    _this->_internal_set_output_format(from._internal_output_format());
  }
  if (from._internal_sample_rate() != 0) {
    _this->_internal_set_sample_rate(from._internal_sample_rate());
  }
  if (from._internal_channels() != 0) {
    _this->_internal_set_channels(from._internal_channels());
  }
  if (from._internal_enable_ssml() != 0) {
    _this->_internal_set_enable_ssml(from._internal_enable_ssml());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TTSRequest::CopyFrom(const TTSRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unhinged.audio.v1.TTSRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TTSRequest::IsInitialized() const {
  return true;
}

void TTSRequest::InternalSwap(TTSRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.effects_.InternalSwap(&other->_impl_.effects_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.text_, lhs_arena,
      &other->_impl_.text_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.voice_id_, lhs_arena,
      &other->_impl_.voice_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TTSRequest, _impl_.enable_ssml_)
      + sizeof(TTSRequest::_impl_.enable_ssml_)
      - PROTOBUF_FIELD_OFFSET(TTSRequest, _impl_.options_)>(
          reinterpret_cast<char*>(&_impl_.options_),
          reinterpret_cast<char*>(&other->_impl_.options_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TTSRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_2eproto_getter, &descriptor_table_audio_2eproto_once,
      file_level_metadata_audio_2eproto[0]);
}

// ===================================================================

class STTResponse::_Internal {
 public:
  static const ::unhinged::common::v1::StandardResponse& response(const STTResponse* msg);
  static const ::unhinged::common::v1::AudioUsage& usage(const STTResponse* msg);
  static const ::unhinged::audio::v1::STTMetadata& metadata(const STTResponse* msg);
};

const ::unhinged::common::v1::StandardResponse&
STTResponse::_Internal::response(const STTResponse* msg) {
  return *msg->_impl_.response_;
}
const ::unhinged::common::v1::AudioUsage&
STTResponse::_Internal::usage(const STTResponse* msg) {
  return *msg->_impl_.usage_;
}
const ::unhinged::audio::v1::STTMetadata&
STTResponse::_Internal::metadata(const STTResponse* msg) {
  return *msg->_impl_.metadata_;
}
void STTResponse::clear_response() {
  if (GetArenaForAllocation() == nullptr && _impl_.response_ != nullptr) {
    delete _impl_.response_;
  }
  _impl_.response_ = nullptr;
}
void STTResponse::clear_usage() {
  if (GetArenaForAllocation() == nullptr && _impl_.usage_ != nullptr) {
    delete _impl_.usage_;
  }
  _impl_.usage_ = nullptr;
}
STTResponse::STTResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unhinged.audio.v1.STTResponse)
}
STTResponse::STTResponse(const STTResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  STTResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.segments_){from._impl_.segments_}
    , decltype(_impl_.transcript_){}
    , decltype(_impl_.response_){nullptr}
    , decltype(_impl_.usage_){nullptr}
    , decltype(_impl_.metadata_){nullptr}
    , decltype(_impl_.confidence_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.transcript_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.transcript_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_transcript().empty()) {
    _this->_impl_.transcript_.Set(from._internal_transcript(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_response()) {
    _this->_impl_.response_ = new ::unhinged::common::v1::StandardResponse(*from._impl_.response_);
  }
  if (from._internal_has_usage()) {
    _this->_impl_.usage_ = new ::unhinged::common::v1::AudioUsage(*from._impl_.usage_);
  }
  if (from._internal_has_metadata()) {
    _this->_impl_.metadata_ = new ::unhinged::audio::v1::STTMetadata(*from._impl_.metadata_);
  }
  _this->_impl_.confidence_ = from._impl_.confidence_;
  // @@protoc_insertion_point(copy_constructor:unhinged.audio.v1.STTResponse)
}

inline void STTResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.segments_){arena}
    , decltype(_impl_.transcript_){}
    , decltype(_impl_.response_){nullptr}
    , decltype(_impl_.usage_){nullptr}
    , decltype(_impl_.metadata_){nullptr}
    , decltype(_impl_.confidence_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.transcript_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.transcript_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

STTResponse::~STTResponse() {
  // @@protoc_insertion_point(destructor:unhinged.audio.v1.STTResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void STTResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.segments_.~RepeatedPtrField();
  _impl_.transcript_.Destroy();
  if (this != internal_default_instance()) delete _impl_.response_;
  if (this != internal_default_instance()) delete _impl_.usage_;
  if (this != internal_default_instance()) delete _impl_.metadata_;
}

void STTResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void STTResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:unhinged.audio.v1.STTResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.segments_.Clear();
  _impl_.transcript_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.response_ != nullptr) {
    delete _impl_.response_;
  }
  _impl_.response_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.usage_ != nullptr) {
    delete _impl_.usage_;
  }
  _impl_.usage_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.metadata_ != nullptr) {
    delete _impl_.metadata_;
  }
  _impl_.metadata_ = nullptr;
  _impl_.confidence_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* STTResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .unhinged.common.v1.StandardResponse response = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string transcript = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_transcript();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "unhinged.audio.v1.STTResponse.transcript"));
        } else
          goto handle_unusual;
        continue;
      // float confidence = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _impl_.confidence_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // repeated .unhinged.audio.v1.TranscriptSegment segments = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_segments(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .unhinged.common.v1.AudioUsage usage = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_usage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .unhinged.audio.v1.STTMetadata metadata = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* STTResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unhinged.audio.v1.STTResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .unhinged.common.v1.StandardResponse response = 1;
  if (this->_internal_has_response()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::response(this),
        _Internal::response(this).GetCachedSize(), target, stream);
  }

  // string transcript = 2;
  if (!this->_internal_transcript().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_transcript().data(), static_cast<int>(this->_internal_transcript().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "unhinged.audio.v1.STTResponse.transcript");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_transcript(), target);
  }

  // float confidence = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_confidence = this->_internal_confidence();
  uint32_t raw_confidence;
  memcpy(&raw_confidence, &tmp_confidence, sizeof(tmp_confidence));
  if (raw_confidence != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_confidence(), target);
  }

  // repeated .unhinged.audio.v1.TranscriptSegment segments = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_segments_size()); i < n; i++) {
    const auto& repfield = this->_internal_segments(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .unhinged.common.v1.AudioUsage usage = 5;
  if (this->_internal_has_usage()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::usage(this),
        _Internal::usage(this).GetCachedSize(), target, stream);
  }

  // .unhinged.audio.v1.STTMetadata metadata = 6;
  if (this->_internal_has_metadata()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::metadata(this),
        _Internal::metadata(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unhinged.audio.v1.STTResponse)
  return target;
}

size_t STTResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unhinged.audio.v1.STTResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .unhinged.audio.v1.TranscriptSegment segments = 4;
  total_size += 1UL * this->_internal_segments_size();
  for (const auto& msg : this->_impl_.segments_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string transcript = 2;
  if (!this->_internal_transcript().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_transcript());
  }

  // .unhinged.common.v1.StandardResponse response = 1;
  if (this->_internal_has_response()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.response_);
  }

  // .unhinged.common.v1.AudioUsage usage = 5;
  if (this->_internal_has_usage()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.usage_);
  }

  // .unhinged.audio.v1.STTMetadata metadata = 6;
  if (this->_internal_has_metadata()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.metadata_);
  }

  // float confidence = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_confidence = this->_internal_confidence();
  uint32_t raw_confidence;
  memcpy(&raw_confidence, &tmp_confidence, sizeof(tmp_confidence));
  if (raw_confidence != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData STTResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    STTResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*STTResponse::GetClassData() const { return &_class_data_; }


void STTResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<STTResponse*>(&to_msg);
  auto& from = static_cast<const STTResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unhinged.audio.v1.STTResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.segments_.MergeFrom(from._impl_.segments_);
  if (!from._internal_transcript().empty()) {
    _this->_internal_set_transcript(from._internal_transcript());
  }
  if (from._internal_has_response()) {
    _this->_internal_mutable_response()->::unhinged::common::v1::StandardResponse::MergeFrom(
        from._internal_response());
  }
  if (from._internal_has_usage()) {
    _this->_internal_mutable_usage()->::unhinged::common::v1::AudioUsage::MergeFrom(
        from._internal_usage());
  }
  if (from._internal_has_metadata()) {
    _this->_internal_mutable_metadata()->::unhinged::audio::v1::STTMetadata::MergeFrom(
        from._internal_metadata());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_confidence = from._internal_confidence();
  uint32_t raw_confidence;
  memcpy(&raw_confidence, &tmp_confidence, sizeof(tmp_confidence));
  if (raw_confidence != 0) {
    _this->_internal_set_confidence(from._internal_confidence());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void STTResponse::CopyFrom(const STTResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unhinged.audio.v1.STTResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool STTResponse::IsInitialized() const {
  return true;
}

void STTResponse::InternalSwap(STTResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.segments_.InternalSwap(&other->_impl_.segments_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.transcript_, lhs_arena,
      &other->_impl_.transcript_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(STTResponse, _impl_.confidence_)
      + sizeof(STTResponse::_impl_.confidence_)
      - PROTOBUF_FIELD_OFFSET(STTResponse, _impl_.response_)>(
          reinterpret_cast<char*>(&_impl_.response_),
          reinterpret_cast<char*>(&other->_impl_.response_));
}

::PROTOBUF_NAMESPACE_ID::Metadata STTResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_2eproto_getter, &descriptor_table_audio_2eproto_once,
      file_level_metadata_audio_2eproto[1]);
}

// ===================================================================

class AudioOptions::_Internal {
 public:
};

AudioOptions::AudioOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unhinged.audio.v1.AudioOptions)
}
AudioOptions::AudioOptions(const AudioOptions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AudioOptions* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.speed_){}
    , decltype(_impl_.pitch_){}
    , decltype(_impl_.volume_){}
    , decltype(_impl_.quality_){}
    , decltype(_impl_.enable_noise_reduction_){}
    , decltype(_impl_.enable_echo_cancellation_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.speed_, &from._impl_.speed_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.enable_echo_cancellation_) -
    reinterpret_cast<char*>(&_impl_.speed_)) + sizeof(_impl_.enable_echo_cancellation_));
  // @@protoc_insertion_point(copy_constructor:unhinged.audio.v1.AudioOptions)
}

inline void AudioOptions::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.speed_){0}
    , decltype(_impl_.pitch_){0}
    , decltype(_impl_.volume_){0}
    , decltype(_impl_.quality_){0}
    , decltype(_impl_.enable_noise_reduction_){false}
    , decltype(_impl_.enable_echo_cancellation_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

AudioOptions::~AudioOptions() {
  // @@protoc_insertion_point(destructor:unhinged.audio.v1.AudioOptions)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AudioOptions::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AudioOptions::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AudioOptions::Clear() {
// @@protoc_insertion_point(message_clear_start:unhinged.audio.v1.AudioOptions)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.speed_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.enable_echo_cancellation_) -
      reinterpret_cast<char*>(&_impl_.speed_)) + sizeof(_impl_.enable_echo_cancellation_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AudioOptions::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float speed = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _impl_.speed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float pitch = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.pitch_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float volume = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _impl_.volume_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // .unhinged.audio.v1.AudioQuality quality = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_quality(static_cast<::unhinged::audio::v1::AudioQuality>(val));
        } else
          goto handle_unusual;
        continue;
      // bool enable_noise_reduction = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.enable_noise_reduction_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool enable_echo_cancellation = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.enable_echo_cancellation_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AudioOptions::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unhinged.audio.v1.AudioOptions)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float speed = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_speed = this->_internal_speed();
  uint32_t raw_speed;
  memcpy(&raw_speed, &tmp_speed, sizeof(tmp_speed));
  if (raw_speed != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_speed(), target);
  }

  // float pitch = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_pitch = this->_internal_pitch();
  uint32_t raw_pitch;
  memcpy(&raw_pitch, &tmp_pitch, sizeof(tmp_pitch));
  if (raw_pitch != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_pitch(), target);
  }

  // float volume = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_volume = this->_internal_volume();
  uint32_t raw_volume;
  memcpy(&raw_volume, &tmp_volume, sizeof(tmp_volume));
  if (raw_volume != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_volume(), target);
  }

  // .unhinged.audio.v1.AudioQuality quality = 4;
  if (this->_internal_quality() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_quality(), target);
  }

  // bool enable_noise_reduction = 5;
  if (this->_internal_enable_noise_reduction() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_enable_noise_reduction(), target);
  }

  // bool enable_echo_cancellation = 6;
  if (this->_internal_enable_echo_cancellation() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_enable_echo_cancellation(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unhinged.audio.v1.AudioOptions)
  return target;
}

size_t AudioOptions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unhinged.audio.v1.AudioOptions)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float speed = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_speed = this->_internal_speed();
  uint32_t raw_speed;
  memcpy(&raw_speed, &tmp_speed, sizeof(tmp_speed));
  if (raw_speed != 0) {
    total_size += 1 + 4;
  }

  // float pitch = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_pitch = this->_internal_pitch();
  uint32_t raw_pitch;
  memcpy(&raw_pitch, &tmp_pitch, sizeof(tmp_pitch));
  if (raw_pitch != 0) {
    total_size += 1 + 4;
  }

  // float volume = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_volume = this->_internal_volume();
  uint32_t raw_volume;
  memcpy(&raw_volume, &tmp_volume, sizeof(tmp_volume));
  if (raw_volume != 0) {
    total_size += 1 + 4;
  }

  // .unhinged.audio.v1.AudioQuality quality = 4;
  if (this->_internal_quality() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_quality());
  }

  // bool enable_noise_reduction = 5;
  if (this->_internal_enable_noise_reduction() != 0) {
    total_size += 1 + 1;
  }

  // bool enable_echo_cancellation = 6;
  if (this->_internal_enable_echo_cancellation() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AudioOptions::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AudioOptions::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AudioOptions::GetClassData() const { return &_class_data_; }


void AudioOptions::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AudioOptions*>(&to_msg);
  auto& from = static_cast<const AudioOptions&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unhinged.audio.v1.AudioOptions)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_speed = from._internal_speed();
  uint32_t raw_speed;
  memcpy(&raw_speed, &tmp_speed, sizeof(tmp_speed));
  if (raw_speed != 0) {
    _this->_internal_set_speed(from._internal_speed());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_pitch = from._internal_pitch();
  uint32_t raw_pitch;
  memcpy(&raw_pitch, &tmp_pitch, sizeof(tmp_pitch));
  if (raw_pitch != 0) {
    _this->_internal_set_pitch(from._internal_pitch());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_volume = from._internal_volume();
  uint32_t raw_volume;
  memcpy(&raw_volume, &tmp_volume, sizeof(tmp_volume));
  if (raw_volume != 0) {
    _this->_internal_set_volume(from._internal_volume());
  }
  if (from._internal_quality() != 0) {
    _this->_internal_set_quality(from._internal_quality());
  }
  if (from._internal_enable_noise_reduction() != 0) {
    _this->_internal_set_enable_noise_reduction(from._internal_enable_noise_reduction());
  }
  if (from._internal_enable_echo_cancellation() != 0) {
    _this->_internal_set_enable_echo_cancellation(from._internal_enable_echo_cancellation());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AudioOptions::CopyFrom(const AudioOptions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unhinged.audio.v1.AudioOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioOptions::IsInitialized() const {
  return true;
}

void AudioOptions::InternalSwap(AudioOptions* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AudioOptions, _impl_.enable_echo_cancellation_)
      + sizeof(AudioOptions::_impl_.enable_echo_cancellation_)
      - PROTOBUF_FIELD_OFFSET(AudioOptions, _impl_.speed_)>(
          reinterpret_cast<char*>(&_impl_.speed_),
          reinterpret_cast<char*>(&other->_impl_.speed_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AudioOptions::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_2eproto_getter, &descriptor_table_audio_2eproto_once,
      file_level_metadata_audio_2eproto[2]);
}

// ===================================================================

AudioEffect_ParametersEntry_DoNotUse::AudioEffect_ParametersEntry_DoNotUse() {}
AudioEffect_ParametersEntry_DoNotUse::AudioEffect_ParametersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void AudioEffect_ParametersEntry_DoNotUse::MergeFrom(const AudioEffect_ParametersEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata AudioEffect_ParametersEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_2eproto_getter, &descriptor_table_audio_2eproto_once,
      file_level_metadata_audio_2eproto[3]);
}

// ===================================================================

class AudioEffect::_Internal {
 public:
};

AudioEffect::AudioEffect(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &AudioEffect::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:unhinged.audio.v1.AudioEffect)
}
AudioEffect::AudioEffect(const AudioEffect& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AudioEffect* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_.parameters_)*/{}
    , decltype(_impl_.type_){}
    , decltype(_impl_.intensity_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.parameters_.MergeFrom(from._impl_.parameters_);
  ::memcpy(&_impl_.type_, &from._impl_.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.intensity_) -
    reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.intensity_));
  // @@protoc_insertion_point(copy_constructor:unhinged.audio.v1.AudioEffect)
}

inline void AudioEffect::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_.parameters_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.intensity_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

AudioEffect::~AudioEffect() {
  // @@protoc_insertion_point(destructor:unhinged.audio.v1.AudioEffect)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void AudioEffect::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.parameters_.Destruct();
  _impl_.parameters_.~MapField();
}

void AudioEffect::ArenaDtor(void* object) {
  AudioEffect* _this = reinterpret_cast< AudioEffect* >(object);
  _this->_impl_.parameters_.Destruct();
}
void AudioEffect::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AudioEffect::Clear() {
// @@protoc_insertion_point(message_clear_start:unhinged.audio.v1.AudioEffect)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.parameters_.Clear();
  ::memset(&_impl_.type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.intensity_) -
      reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.intensity_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AudioEffect::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .unhinged.audio.v1.AudioEffectType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::unhinged::audio::v1::AudioEffectType>(val));
        } else
          goto handle_unusual;
        continue;
      // float intensity = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.intensity_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // map<string, string> parameters = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.parameters_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AudioEffect::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unhinged.audio.v1.AudioEffect)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .unhinged.audio.v1.AudioEffectType type = 1;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // float intensity = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_intensity = this->_internal_intensity();
  uint32_t raw_intensity;
  memcpy(&raw_intensity, &tmp_intensity, sizeof(tmp_intensity));
  if (raw_intensity != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_intensity(), target);
  }

  // map<string, string> parameters = 3;
  if (!this->_internal_parameters().empty()) {
    using MapType = ::_pb::Map<std::string, std::string>;
    using WireHelper = AudioEffect_ParametersEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_parameters();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "unhinged.audio.v1.AudioEffect.ParametersEntry.key");
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.second.data(), static_cast<int>(entry.second.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "unhinged.audio.v1.AudioEffect.ParametersEntry.value");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(3, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(3, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unhinged.audio.v1.AudioEffect)
  return target;
}

size_t AudioEffect::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unhinged.audio.v1.AudioEffect)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, string> parameters = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_parameters_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_parameters().begin();
      it != this->_internal_parameters().end(); ++it) {
    total_size += AudioEffect_ParametersEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // .unhinged.audio.v1.AudioEffectType type = 1;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  // float intensity = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_intensity = this->_internal_intensity();
  uint32_t raw_intensity;
  memcpy(&raw_intensity, &tmp_intensity, sizeof(tmp_intensity));
  if (raw_intensity != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AudioEffect::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AudioEffect::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AudioEffect::GetClassData() const { return &_class_data_; }


void AudioEffect::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AudioEffect*>(&to_msg);
  auto& from = static_cast<const AudioEffect&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unhinged.audio.v1.AudioEffect)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.parameters_.MergeFrom(from._impl_.parameters_);
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_intensity = from._internal_intensity();
  uint32_t raw_intensity;
  memcpy(&raw_intensity, &tmp_intensity, sizeof(tmp_intensity));
  if (raw_intensity != 0) {
    _this->_internal_set_intensity(from._internal_intensity());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AudioEffect::CopyFrom(const AudioEffect& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unhinged.audio.v1.AudioEffect)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioEffect::IsInitialized() const {
  return true;
}

void AudioEffect::InternalSwap(AudioEffect* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.parameters_.InternalSwap(&other->_impl_.parameters_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AudioEffect, _impl_.intensity_)
      + sizeof(AudioEffect::_impl_.intensity_)
      - PROTOBUF_FIELD_OFFSET(AudioEffect, _impl_.type_)>(
          reinterpret_cast<char*>(&_impl_.type_),
          reinterpret_cast<char*>(&other->_impl_.type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AudioEffect::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_2eproto_getter, &descriptor_table_audio_2eproto_once,
      file_level_metadata_audio_2eproto[4]);
}

// ===================================================================

class TranscriptSegment::_Internal {
 public:
};

TranscriptSegment::TranscriptSegment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unhinged.audio.v1.TranscriptSegment)
}
TranscriptSegment::TranscriptSegment(const TranscriptSegment& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TranscriptSegment* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.words_){from._impl_.words_}
    , decltype(_impl_.text_){}
    , decltype(_impl_.speaker_id_){}
    , decltype(_impl_.start_time_){}
    , decltype(_impl_.end_time_){}
    , decltype(_impl_.confidence_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_text().empty()) {
    _this->_impl_.text_.Set(from._internal_text(), 
      _this->GetArenaForAllocation());
  }
  _impl_.speaker_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.speaker_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_speaker_id().empty()) {
    _this->_impl_.speaker_id_.Set(from._internal_speaker_id(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.start_time_, &from._impl_.start_time_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.confidence_) -
    reinterpret_cast<char*>(&_impl_.start_time_)) + sizeof(_impl_.confidence_));
  // @@protoc_insertion_point(copy_constructor:unhinged.audio.v1.TranscriptSegment)
}

inline void TranscriptSegment::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.words_){arena}
    , decltype(_impl_.text_){}
    , decltype(_impl_.speaker_id_){}
    , decltype(_impl_.start_time_){0}
    , decltype(_impl_.end_time_){0}
    , decltype(_impl_.confidence_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.speaker_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.speaker_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TranscriptSegment::~TranscriptSegment() {
  // @@protoc_insertion_point(destructor:unhinged.audio.v1.TranscriptSegment)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TranscriptSegment::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.words_.~RepeatedPtrField();
  _impl_.text_.Destroy();
  _impl_.speaker_id_.Destroy();
}

void TranscriptSegment::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TranscriptSegment::Clear() {
// @@protoc_insertion_point(message_clear_start:unhinged.audio.v1.TranscriptSegment)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.words_.Clear();
  _impl_.text_.ClearToEmpty();
  _impl_.speaker_id_.ClearToEmpty();
  ::memset(&_impl_.start_time_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.confidence_) -
      reinterpret_cast<char*>(&_impl_.start_time_)) + sizeof(_impl_.confidence_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TranscriptSegment::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string text = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "unhinged.audio.v1.TranscriptSegment.text"));
        } else
          goto handle_unusual;
        continue;
      // float start_time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.start_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float end_time = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _impl_.end_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float confidence = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _impl_.confidence_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // repeated .unhinged.audio.v1.WordTiming words = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_words(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string speaker_id = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_speaker_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "unhinged.audio.v1.TranscriptSegment.speaker_id"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TranscriptSegment::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unhinged.audio.v1.TranscriptSegment)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string text = 1;
  if (!this->_internal_text().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_text().data(), static_cast<int>(this->_internal_text().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "unhinged.audio.v1.TranscriptSegment.text");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_text(), target);
  }

  // float start_time = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_start_time = this->_internal_start_time();
  uint32_t raw_start_time;
  memcpy(&raw_start_time, &tmp_start_time, sizeof(tmp_start_time));
  if (raw_start_time != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_start_time(), target);
  }

  // float end_time = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_end_time = this->_internal_end_time();
  uint32_t raw_end_time;
  memcpy(&raw_end_time, &tmp_end_time, sizeof(tmp_end_time));
  if (raw_end_time != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_end_time(), target);
  }

  // float confidence = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_confidence = this->_internal_confidence();
  uint32_t raw_confidence;
  memcpy(&raw_confidence, &tmp_confidence, sizeof(tmp_confidence));
  if (raw_confidence != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_confidence(), target);
  }

  // repeated .unhinged.audio.v1.WordTiming words = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_words_size()); i < n; i++) {
    const auto& repfield = this->_internal_words(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // string speaker_id = 6;
  if (!this->_internal_speaker_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_speaker_id().data(), static_cast<int>(this->_internal_speaker_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "unhinged.audio.v1.TranscriptSegment.speaker_id");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_speaker_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unhinged.audio.v1.TranscriptSegment)
  return target;
}

size_t TranscriptSegment::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unhinged.audio.v1.TranscriptSegment)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .unhinged.audio.v1.WordTiming words = 5;
  total_size += 1UL * this->_internal_words_size();
  for (const auto& msg : this->_impl_.words_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string text = 1;
  if (!this->_internal_text().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_text());
  }

  // string speaker_id = 6;
  if (!this->_internal_speaker_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_speaker_id());
  }

  // float start_time = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_start_time = this->_internal_start_time();
  uint32_t raw_start_time;
  memcpy(&raw_start_time, &tmp_start_time, sizeof(tmp_start_time));
  if (raw_start_time != 0) {
    total_size += 1 + 4;
  }

  // float end_time = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_end_time = this->_internal_end_time();
  uint32_t raw_end_time;
  memcpy(&raw_end_time, &tmp_end_time, sizeof(tmp_end_time));
  if (raw_end_time != 0) {
    total_size += 1 + 4;
  }

  // float confidence = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_confidence = this->_internal_confidence();
  uint32_t raw_confidence;
  memcpy(&raw_confidence, &tmp_confidence, sizeof(tmp_confidence));
  if (raw_confidence != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TranscriptSegment::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TranscriptSegment::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TranscriptSegment::GetClassData() const { return &_class_data_; }


void TranscriptSegment::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TranscriptSegment*>(&to_msg);
  auto& from = static_cast<const TranscriptSegment&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unhinged.audio.v1.TranscriptSegment)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.words_.MergeFrom(from._impl_.words_);
  if (!from._internal_text().empty()) {
    _this->_internal_set_text(from._internal_text());
  }
  if (!from._internal_speaker_id().empty()) {
    _this->_internal_set_speaker_id(from._internal_speaker_id());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_start_time = from._internal_start_time();
  uint32_t raw_start_time;
  memcpy(&raw_start_time, &tmp_start_time, sizeof(tmp_start_time));
  if (raw_start_time != 0) {
    _this->_internal_set_start_time(from._internal_start_time());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_end_time = from._internal_end_time();
  uint32_t raw_end_time;
  memcpy(&raw_end_time, &tmp_end_time, sizeof(tmp_end_time));
  if (raw_end_time != 0) {
    _this->_internal_set_end_time(from._internal_end_time());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_confidence = from._internal_confidence();
  uint32_t raw_confidence;
  memcpy(&raw_confidence, &tmp_confidence, sizeof(tmp_confidence));
  if (raw_confidence != 0) {
    _this->_internal_set_confidence(from._internal_confidence());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TranscriptSegment::CopyFrom(const TranscriptSegment& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unhinged.audio.v1.TranscriptSegment)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TranscriptSegment::IsInitialized() const {
  return true;
}

void TranscriptSegment::InternalSwap(TranscriptSegment* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.words_.InternalSwap(&other->_impl_.words_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.text_, lhs_arena,
      &other->_impl_.text_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.speaker_id_, lhs_arena,
      &other->_impl_.speaker_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TranscriptSegment, _impl_.confidence_)
      + sizeof(TranscriptSegment::_impl_.confidence_)
      - PROTOBUF_FIELD_OFFSET(TranscriptSegment, _impl_.start_time_)>(
          reinterpret_cast<char*>(&_impl_.start_time_),
          reinterpret_cast<char*>(&other->_impl_.start_time_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TranscriptSegment::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_2eproto_getter, &descriptor_table_audio_2eproto_once,
      file_level_metadata_audio_2eproto[5]);
}

// ===================================================================

class WordTiming::_Internal {
 public:
};

WordTiming::WordTiming(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unhinged.audio.v1.WordTiming)
}
WordTiming::WordTiming(const WordTiming& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  WordTiming* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.word_){}
    , decltype(_impl_.start_time_){}
    , decltype(_impl_.end_time_){}
    , decltype(_impl_.confidence_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.word_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.word_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_word().empty()) {
    _this->_impl_.word_.Set(from._internal_word(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.start_time_, &from._impl_.start_time_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.confidence_) -
    reinterpret_cast<char*>(&_impl_.start_time_)) + sizeof(_impl_.confidence_));
  // @@protoc_insertion_point(copy_constructor:unhinged.audio.v1.WordTiming)
}

inline void WordTiming::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.word_){}
    , decltype(_impl_.start_time_){0}
    , decltype(_impl_.end_time_){0}
    , decltype(_impl_.confidence_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.word_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.word_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

WordTiming::~WordTiming() {
  // @@protoc_insertion_point(destructor:unhinged.audio.v1.WordTiming)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void WordTiming::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.word_.Destroy();
}

void WordTiming::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void WordTiming::Clear() {
// @@protoc_insertion_point(message_clear_start:unhinged.audio.v1.WordTiming)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.word_.ClearToEmpty();
  ::memset(&_impl_.start_time_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.confidence_) -
      reinterpret_cast<char*>(&_impl_.start_time_)) + sizeof(_impl_.confidence_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* WordTiming::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string word = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_word();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "unhinged.audio.v1.WordTiming.word"));
        } else
          goto handle_unusual;
        continue;
      // float start_time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.start_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float end_time = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _impl_.end_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float confidence = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _impl_.confidence_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* WordTiming::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unhinged.audio.v1.WordTiming)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string word = 1;
  if (!this->_internal_word().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_word().data(), static_cast<int>(this->_internal_word().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "unhinged.audio.v1.WordTiming.word");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_word(), target);
  }

  // float start_time = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_start_time = this->_internal_start_time();
  uint32_t raw_start_time;
  memcpy(&raw_start_time, &tmp_start_time, sizeof(tmp_start_time));
  if (raw_start_time != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_start_time(), target);
  }

  // float end_time = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_end_time = this->_internal_end_time();
  uint32_t raw_end_time;
  memcpy(&raw_end_time, &tmp_end_time, sizeof(tmp_end_time));
  if (raw_end_time != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_end_time(), target);
  }

  // float confidence = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_confidence = this->_internal_confidence();
  uint32_t raw_confidence;
  memcpy(&raw_confidence, &tmp_confidence, sizeof(tmp_confidence));
  if (raw_confidence != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_confidence(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unhinged.audio.v1.WordTiming)
  return target;
}

size_t WordTiming::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unhinged.audio.v1.WordTiming)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string word = 1;
  if (!this->_internal_word().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_word());
  }

  // float start_time = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_start_time = this->_internal_start_time();
  uint32_t raw_start_time;
  memcpy(&raw_start_time, &tmp_start_time, sizeof(tmp_start_time));
  if (raw_start_time != 0) {
    total_size += 1 + 4;
  }

  // float end_time = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_end_time = this->_internal_end_time();
  uint32_t raw_end_time;
  memcpy(&raw_end_time, &tmp_end_time, sizeof(tmp_end_time));
  if (raw_end_time != 0) {
    total_size += 1 + 4;
  }

  // float confidence = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_confidence = this->_internal_confidence();
  uint32_t raw_confidence;
  memcpy(&raw_confidence, &tmp_confidence, sizeof(tmp_confidence));
  if (raw_confidence != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData WordTiming::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    WordTiming::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*WordTiming::GetClassData() const { return &_class_data_; }


void WordTiming::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<WordTiming*>(&to_msg);
  auto& from = static_cast<const WordTiming&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unhinged.audio.v1.WordTiming)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_word().empty()) {
    _this->_internal_set_word(from._internal_word());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_start_time = from._internal_start_time();
  uint32_t raw_start_time;
  memcpy(&raw_start_time, &tmp_start_time, sizeof(tmp_start_time));
  if (raw_start_time != 0) {
    _this->_internal_set_start_time(from._internal_start_time());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_end_time = from._internal_end_time();
  uint32_t raw_end_time;
  memcpy(&raw_end_time, &tmp_end_time, sizeof(tmp_end_time));
  if (raw_end_time != 0) {
    _this->_internal_set_end_time(from._internal_end_time());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_confidence = from._internal_confidence();
  uint32_t raw_confidence;
  memcpy(&raw_confidence, &tmp_confidence, sizeof(tmp_confidence));
  if (raw_confidence != 0) {
    _this->_internal_set_confidence(from._internal_confidence());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void WordTiming::CopyFrom(const WordTiming& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unhinged.audio.v1.WordTiming)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WordTiming::IsInitialized() const {
  return true;
}

void WordTiming::InternalSwap(WordTiming* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.word_, lhs_arena,
      &other->_impl_.word_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(WordTiming, _impl_.confidence_)
      + sizeof(WordTiming::_impl_.confidence_)
      - PROTOBUF_FIELD_OFFSET(WordTiming, _impl_.start_time_)>(
          reinterpret_cast<char*>(&_impl_.start_time_),
          reinterpret_cast<char*>(&other->_impl_.start_time_));
}

::PROTOBUF_NAMESPACE_ID::Metadata WordTiming::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_2eproto_getter, &descriptor_table_audio_2eproto_once,
      file_level_metadata_audio_2eproto[6]);
}

// ===================================================================

class STTMetadata::_Internal {
 public:
};

STTMetadata::STTMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unhinged.audio.v1.STTMetadata)
}
STTMetadata::STTMetadata(const STTMetadata& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  STTMetadata* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.detected_languages_){from._impl_.detected_languages_}
    , decltype(_impl_.model_){}
    , decltype(_impl_.language_){}
    , decltype(_impl_.processing_time_ms_){}
    , decltype(_impl_.signal_to_noise_ratio_){}
    , decltype(_impl_.speech_rate_wpm_){}
    , decltype(_impl_.has_background_noise_){}
    , decltype(_impl_.has_multiple_speakers_){}
    , decltype(_impl_.detected_quality_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.model_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.model_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_model().empty()) {
    _this->_impl_.model_.Set(from._internal_model(), 
      _this->GetArenaForAllocation());
  }
  _impl_.language_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.language_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_language().empty()) {
    _this->_impl_.language_.Set(from._internal_language(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.processing_time_ms_, &from._impl_.processing_time_ms_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.detected_quality_) -
    reinterpret_cast<char*>(&_impl_.processing_time_ms_)) + sizeof(_impl_.detected_quality_));
  // @@protoc_insertion_point(copy_constructor:unhinged.audio.v1.STTMetadata)
}

inline void STTMetadata::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.detected_languages_){arena}
    , decltype(_impl_.model_){}
    , decltype(_impl_.language_){}
    , decltype(_impl_.processing_time_ms_){0}
    , decltype(_impl_.signal_to_noise_ratio_){0}
    , decltype(_impl_.speech_rate_wpm_){0}
    , decltype(_impl_.has_background_noise_){false}
    , decltype(_impl_.has_multiple_speakers_){false}
    , decltype(_impl_.detected_quality_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.model_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.model_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.language_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.language_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

STTMetadata::~STTMetadata() {
  // @@protoc_insertion_point(destructor:unhinged.audio.v1.STTMetadata)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void STTMetadata::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.detected_languages_.~RepeatedPtrField();
  _impl_.model_.Destroy();
  _impl_.language_.Destroy();
}

void STTMetadata::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void STTMetadata::Clear() {
// @@protoc_insertion_point(message_clear_start:unhinged.audio.v1.STTMetadata)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.detected_languages_.Clear();
  _impl_.model_.ClearToEmpty();
  _impl_.language_.ClearToEmpty();
  ::memset(&_impl_.processing_time_ms_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.detected_quality_) -
      reinterpret_cast<char*>(&_impl_.processing_time_ms_)) + sizeof(_impl_.detected_quality_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* STTMetadata::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string model = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_model();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "unhinged.audio.v1.STTMetadata.model"));
        } else
          goto handle_unusual;
        continue;
      // string language = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_language();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "unhinged.audio.v1.STTMetadata.language"));
        } else
          goto handle_unusual;
        continue;
      // float processing_time_ms = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _impl_.processing_time_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float signal_to_noise_ratio = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _impl_.signal_to_noise_ratio_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float speech_rate_wpm = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _impl_.speech_rate_wpm_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // repeated string detected_languages = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_detected_languages();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "unhinged.audio.v1.STTMetadata.detected_languages"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // bool has_background_noise = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.has_background_noise_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool has_multiple_speakers = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.has_multiple_speakers_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .unhinged.audio.v1.AudioQuality detected_quality = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_detected_quality(static_cast<::unhinged::audio::v1::AudioQuality>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* STTMetadata::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unhinged.audio.v1.STTMetadata)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string model = 1;
  if (!this->_internal_model().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_model().data(), static_cast<int>(this->_internal_model().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "unhinged.audio.v1.STTMetadata.model");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_model(), target);
  }

  // string language = 2;
  if (!this->_internal_language().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_language().data(), static_cast<int>(this->_internal_language().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "unhinged.audio.v1.STTMetadata.language");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_language(), target);
  }

  // float processing_time_ms = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_processing_time_ms = this->_internal_processing_time_ms();
  uint32_t raw_processing_time_ms;
  memcpy(&raw_processing_time_ms, &tmp_processing_time_ms, sizeof(tmp_processing_time_ms));
  if (raw_processing_time_ms != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_processing_time_ms(), target);
  }

  // float signal_to_noise_ratio = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_signal_to_noise_ratio = this->_internal_signal_to_noise_ratio();
  uint32_t raw_signal_to_noise_ratio;
  memcpy(&raw_signal_to_noise_ratio, &tmp_signal_to_noise_ratio, sizeof(tmp_signal_to_noise_ratio));
  if (raw_signal_to_noise_ratio != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_signal_to_noise_ratio(), target);
  }

  // float speech_rate_wpm = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_speech_rate_wpm = this->_internal_speech_rate_wpm();
  uint32_t raw_speech_rate_wpm;
  memcpy(&raw_speech_rate_wpm, &tmp_speech_rate_wpm, sizeof(tmp_speech_rate_wpm));
  if (raw_speech_rate_wpm != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_speech_rate_wpm(), target);
  }

  // repeated string detected_languages = 6;
  for (int i = 0, n = this->_internal_detected_languages_size(); i < n; i++) {
    const auto& s = this->_internal_detected_languages(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "unhinged.audio.v1.STTMetadata.detected_languages");
    target = stream->WriteString(6, s, target);
  }

  // bool has_background_noise = 7;
  if (this->_internal_has_background_noise() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_has_background_noise(), target);
  }

  // bool has_multiple_speakers = 8;
  if (this->_internal_has_multiple_speakers() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_has_multiple_speakers(), target);
  }

  // .unhinged.audio.v1.AudioQuality detected_quality = 9;
  if (this->_internal_detected_quality() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      9, this->_internal_detected_quality(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unhinged.audio.v1.STTMetadata)
  return target;
}

size_t STTMetadata::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unhinged.audio.v1.STTMetadata)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string detected_languages = 6;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.detected_languages_.size());
  for (int i = 0, n = _impl_.detected_languages_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.detected_languages_.Get(i));
  }

  // string model = 1;
  if (!this->_internal_model().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_model());
  }

  // string language = 2;
  if (!this->_internal_language().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_language());
  }

  // float processing_time_ms = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_processing_time_ms = this->_internal_processing_time_ms();
  uint32_t raw_processing_time_ms;
  memcpy(&raw_processing_time_ms, &tmp_processing_time_ms, sizeof(tmp_processing_time_ms));
  if (raw_processing_time_ms != 0) {
    total_size += 1 + 4;
  }

  // float signal_to_noise_ratio = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_signal_to_noise_ratio = this->_internal_signal_to_noise_ratio();
  uint32_t raw_signal_to_noise_ratio;
  memcpy(&raw_signal_to_noise_ratio, &tmp_signal_to_noise_ratio, sizeof(tmp_signal_to_noise_ratio));
  if (raw_signal_to_noise_ratio != 0) {
    total_size += 1 + 4;
  }

  // float speech_rate_wpm = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_speech_rate_wpm = this->_internal_speech_rate_wpm();
  uint32_t raw_speech_rate_wpm;
  memcpy(&raw_speech_rate_wpm, &tmp_speech_rate_wpm, sizeof(tmp_speech_rate_wpm));
  if (raw_speech_rate_wpm != 0) {
    total_size += 1 + 4;
  }

  // bool has_background_noise = 7;
  if (this->_internal_has_background_noise() != 0) {
    total_size += 1 + 1;
  }

  // bool has_multiple_speakers = 8;
  if (this->_internal_has_multiple_speakers() != 0) {
    total_size += 1 + 1;
  }

  // .unhinged.audio.v1.AudioQuality detected_quality = 9;
  if (this->_internal_detected_quality() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_detected_quality());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData STTMetadata::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    STTMetadata::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*STTMetadata::GetClassData() const { return &_class_data_; }


void STTMetadata::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<STTMetadata*>(&to_msg);
  auto& from = static_cast<const STTMetadata&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unhinged.audio.v1.STTMetadata)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.detected_languages_.MergeFrom(from._impl_.detected_languages_);
  if (!from._internal_model().empty()) {
    _this->_internal_set_model(from._internal_model());
  }
  if (!from._internal_language().empty()) {
    _this->_internal_set_language(from._internal_language());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_processing_time_ms = from._internal_processing_time_ms();
  uint32_t raw_processing_time_ms;
  memcpy(&raw_processing_time_ms, &tmp_processing_time_ms, sizeof(tmp_processing_time_ms));
  if (raw_processing_time_ms != 0) {
    _this->_internal_set_processing_time_ms(from._internal_processing_time_ms());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_signal_to_noise_ratio = from._internal_signal_to_noise_ratio();
  uint32_t raw_signal_to_noise_ratio;
  memcpy(&raw_signal_to_noise_ratio, &tmp_signal_to_noise_ratio, sizeof(tmp_signal_to_noise_ratio));
  if (raw_signal_to_noise_ratio != 0) {
    _this->_internal_set_signal_to_noise_ratio(from._internal_signal_to_noise_ratio());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_speech_rate_wpm = from._internal_speech_rate_wpm();
  uint32_t raw_speech_rate_wpm;
  memcpy(&raw_speech_rate_wpm, &tmp_speech_rate_wpm, sizeof(tmp_speech_rate_wpm));
  if (raw_speech_rate_wpm != 0) {
    _this->_internal_set_speech_rate_wpm(from._internal_speech_rate_wpm());
  }
  if (from._internal_has_background_noise() != 0) {
    _this->_internal_set_has_background_noise(from._internal_has_background_noise());
  }
  if (from._internal_has_multiple_speakers() != 0) {
    _this->_internal_set_has_multiple_speakers(from._internal_has_multiple_speakers());
  }
  if (from._internal_detected_quality() != 0) {
    _this->_internal_set_detected_quality(from._internal_detected_quality());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void STTMetadata::CopyFrom(const STTMetadata& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unhinged.audio.v1.STTMetadata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool STTMetadata::IsInitialized() const {
  return true;
}

void STTMetadata::InternalSwap(STTMetadata* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.detected_languages_.InternalSwap(&other->_impl_.detected_languages_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.model_, lhs_arena,
      &other->_impl_.model_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.language_, lhs_arena,
      &other->_impl_.language_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(STTMetadata, _impl_.detected_quality_)
      + sizeof(STTMetadata::_impl_.detected_quality_)
      - PROTOBUF_FIELD_OFFSET(STTMetadata, _impl_.processing_time_ms_)>(
          reinterpret_cast<char*>(&_impl_.processing_time_ms_),
          reinterpret_cast<char*>(&other->_impl_.processing_time_ms_));
}

::PROTOBUF_NAMESPACE_ID::Metadata STTMetadata::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_2eproto_getter, &descriptor_table_audio_2eproto_once,
      file_level_metadata_audio_2eproto[7]);
}

// ===================================================================

class Voice::_Internal {
 public:
  static const ::unhinged::common::v1::ResourceMetadata& metadata(const Voice* msg);
};

const ::unhinged::common::v1::ResourceMetadata&
Voice::_Internal::metadata(const Voice* msg) {
  return *msg->_impl_.metadata_;
}
void Voice::clear_metadata() {
  if (GetArenaForAllocation() == nullptr && _impl_.metadata_ != nullptr) {
    delete _impl_.metadata_;
  }
  _impl_.metadata_ = nullptr;
}
Voice::Voice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unhinged.audio.v1.Voice)
}
Voice::Voice(const Voice& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Voice* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.supported_formats_){from._impl_.supported_formats_}
    , /*decltype(_impl_._supported_formats_cached_byte_size_)*/{0}
    , decltype(_impl_.supported_sample_rates_){from._impl_.supported_sample_rates_}
    , /*decltype(_impl_._supported_sample_rates_cached_byte_size_)*/{0}
    , decltype(_impl_.name_){}
    , decltype(_impl_.display_name_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.language_){}
    , decltype(_impl_.language_code_){}
    , decltype(_impl_.preview_url_){}
    , decltype(_impl_.preview_text_){}
    , decltype(_impl_.metadata_){nullptr}
    , decltype(_impl_.gender_){}
    , decltype(_impl_.age_){}
    , decltype(_impl_.style_){}
    , decltype(_impl_.is_available_){}
    , decltype(_impl_.is_premium_){}
    , decltype(_impl_.cost_per_character_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.display_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.display_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_display_name().empty()) {
    _this->_impl_.display_name_.Set(from._internal_display_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_description().empty()) {
    _this->_impl_.description_.Set(from._internal_description(), 
      _this->GetArenaForAllocation());
  }
  _impl_.language_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.language_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_language().empty()) {
    _this->_impl_.language_.Set(from._internal_language(), 
      _this->GetArenaForAllocation());
  }
  _impl_.language_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.language_code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_language_code().empty()) {
    _this->_impl_.language_code_.Set(from._internal_language_code(), 
      _this->GetArenaForAllocation());
  }
  _impl_.preview_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.preview_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_preview_url().empty()) {
    _this->_impl_.preview_url_.Set(from._internal_preview_url(), 
      _this->GetArenaForAllocation());
  }
  _impl_.preview_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.preview_text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_preview_text().empty()) {
    _this->_impl_.preview_text_.Set(from._internal_preview_text(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_metadata()) {
    _this->_impl_.metadata_ = new ::unhinged::common::v1::ResourceMetadata(*from._impl_.metadata_);
  }
  ::memcpy(&_impl_.gender_, &from._impl_.gender_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.cost_per_character_) -
    reinterpret_cast<char*>(&_impl_.gender_)) + sizeof(_impl_.cost_per_character_));
  // @@protoc_insertion_point(copy_constructor:unhinged.audio.v1.Voice)
}

inline void Voice::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.supported_formats_){arena}
    , /*decltype(_impl_._supported_formats_cached_byte_size_)*/{0}
    , decltype(_impl_.supported_sample_rates_){arena}
    , /*decltype(_impl_._supported_sample_rates_cached_byte_size_)*/{0}
    , decltype(_impl_.name_){}
    , decltype(_impl_.display_name_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.language_){}
    , decltype(_impl_.language_code_){}
    , decltype(_impl_.preview_url_){}
    , decltype(_impl_.preview_text_){}
    , decltype(_impl_.metadata_){nullptr}
    , decltype(_impl_.gender_){0}
    , decltype(_impl_.age_){0}
    , decltype(_impl_.style_){0}
    , decltype(_impl_.is_available_){false}
    , decltype(_impl_.is_premium_){false}
    , decltype(_impl_.cost_per_character_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.display_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.display_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.language_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.language_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.language_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.language_code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.preview_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.preview_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.preview_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.preview_text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Voice::~Voice() {
  // @@protoc_insertion_point(destructor:unhinged.audio.v1.Voice)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Voice::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.supported_formats_.~RepeatedField();
  _impl_.supported_sample_rates_.~RepeatedField();
  _impl_.name_.Destroy();
  _impl_.display_name_.Destroy();
  _impl_.description_.Destroy();
  _impl_.language_.Destroy();
  _impl_.language_code_.Destroy();
  _impl_.preview_url_.Destroy();
  _impl_.preview_text_.Destroy();
  if (this != internal_default_instance()) delete _impl_.metadata_;
}

void Voice::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Voice::Clear() {
// @@protoc_insertion_point(message_clear_start:unhinged.audio.v1.Voice)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.supported_formats_.Clear();
  _impl_.supported_sample_rates_.Clear();
  _impl_.name_.ClearToEmpty();
  _impl_.display_name_.ClearToEmpty();
  _impl_.description_.ClearToEmpty();
  _impl_.language_.ClearToEmpty();
  _impl_.language_code_.ClearToEmpty();
  _impl_.preview_url_.ClearToEmpty();
  _impl_.preview_text_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.metadata_ != nullptr) {
    delete _impl_.metadata_;
  }
  _impl_.metadata_ = nullptr;
  ::memset(&_impl_.gender_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.cost_per_character_) -
      reinterpret_cast<char*>(&_impl_.gender_)) + sizeof(_impl_.cost_per_character_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Voice::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .unhinged.common.v1.ResourceMetadata metadata = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "unhinged.audio.v1.Voice.name"));
        } else
          goto handle_unusual;
        continue;
      // string display_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_display_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "unhinged.audio.v1.Voice.display_name"));
        } else
          goto handle_unusual;
        continue;
      // string description = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "unhinged.audio.v1.Voice.description"));
        } else
          goto handle_unusual;
        continue;
      // string language = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_language();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "unhinged.audio.v1.Voice.language"));
        } else
          goto handle_unusual;
        continue;
      // string language_code = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_language_code();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "unhinged.audio.v1.Voice.language_code"));
        } else
          goto handle_unusual;
        continue;
      // .unhinged.audio.v1.VoiceGender gender = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_gender(static_cast<::unhinged::audio::v1::VoiceGender>(val));
        } else
          goto handle_unusual;
        continue;
      // .unhinged.audio.v1.VoiceAge age = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_age(static_cast<::unhinged::audio::v1::VoiceAge>(val));
        } else
          goto handle_unusual;
        continue;
      // .unhinged.audio.v1.VoiceStyle style = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_style(static_cast<::unhinged::audio::v1::VoiceStyle>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated .unhinged.audio.v1.AudioFormat supported_formats = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser(_internal_mutable_supported_formats(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 80) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_add_supported_formats(static_cast<::unhinged::audio::v1::AudioFormat>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated int32 supported_sample_rates = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_supported_sample_rates(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 88) {
          _internal_add_supported_sample_rates(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool is_available = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _impl_.is_available_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool is_premium = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _impl_.is_premium_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float cost_per_character = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 117)) {
          _impl_.cost_per_character_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // string preview_url = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          auto str = _internal_mutable_preview_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "unhinged.audio.v1.Voice.preview_url"));
        } else
          goto handle_unusual;
        continue;
      // string preview_text = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          auto str = _internal_mutable_preview_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "unhinged.audio.v1.Voice.preview_text"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Voice::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unhinged.audio.v1.Voice)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .unhinged.common.v1.ResourceMetadata metadata = 1;
  if (this->_internal_has_metadata()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::metadata(this),
        _Internal::metadata(this).GetCachedSize(), target, stream);
  }

  // string name = 2;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "unhinged.audio.v1.Voice.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // string display_name = 3;
  if (!this->_internal_display_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_display_name().data(), static_cast<int>(this->_internal_display_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "unhinged.audio.v1.Voice.display_name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_display_name(), target);
  }

  // string description = 4;
  if (!this->_internal_description().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_description().data(), static_cast<int>(this->_internal_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "unhinged.audio.v1.Voice.description");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_description(), target);
  }

  // string language = 5;
  if (!this->_internal_language().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_language().data(), static_cast<int>(this->_internal_language().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "unhinged.audio.v1.Voice.language");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_language(), target);
  }

  // string language_code = 6;
  if (!this->_internal_language_code().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_language_code().data(), static_cast<int>(this->_internal_language_code().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "unhinged.audio.v1.Voice.language_code");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_language_code(), target);
  }

  // .unhinged.audio.v1.VoiceGender gender = 7;
  if (this->_internal_gender() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      7, this->_internal_gender(), target);
  }

  // .unhinged.audio.v1.VoiceAge age = 8;
  if (this->_internal_age() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      8, this->_internal_age(), target);
  }

  // .unhinged.audio.v1.VoiceStyle style = 9;
  if (this->_internal_style() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      9, this->_internal_style(), target);
  }

  // repeated .unhinged.audio.v1.AudioFormat supported_formats = 10;
  {
    int byte_size = _impl_._supported_formats_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteEnumPacked(
          10, _impl_.supported_formats_, byte_size, target);
    }
  }

  // repeated int32 supported_sample_rates = 11;
  {
    int byte_size = _impl_._supported_sample_rates_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          11, _internal_supported_sample_rates(), byte_size, target);
    }
  }

  // bool is_available = 12;
  if (this->_internal_is_available() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(12, this->_internal_is_available(), target);
  }

  // bool is_premium = 13;
  if (this->_internal_is_premium() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(13, this->_internal_is_premium(), target);
  }

  // float cost_per_character = 14;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_cost_per_character = this->_internal_cost_per_character();
  uint32_t raw_cost_per_character;
  memcpy(&raw_cost_per_character, &tmp_cost_per_character, sizeof(tmp_cost_per_character));
  if (raw_cost_per_character != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(14, this->_internal_cost_per_character(), target);
  }

  // string preview_url = 15;
  if (!this->_internal_preview_url().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_preview_url().data(), static_cast<int>(this->_internal_preview_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "unhinged.audio.v1.Voice.preview_url");
    target = stream->WriteStringMaybeAliased(
        15, this->_internal_preview_url(), target);
  }

  // string preview_text = 16;
  if (!this->_internal_preview_text().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_preview_text().data(), static_cast<int>(this->_internal_preview_text().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "unhinged.audio.v1.Voice.preview_text");
    target = stream->WriteStringMaybeAliased(
        16, this->_internal_preview_text(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unhinged.audio.v1.Voice)
  return target;
}

size_t Voice::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unhinged.audio.v1.Voice)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .unhinged.audio.v1.AudioFormat supported_formats = 10;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_supported_formats_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
        this->_internal_supported_formats(static_cast<int>(i)));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._supported_formats_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated int32 supported_sample_rates = 11;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.supported_sample_rates_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._supported_sample_rates_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // string name = 2;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string display_name = 3;
  if (!this->_internal_display_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_display_name());
  }

  // string description = 4;
  if (!this->_internal_description().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_description());
  }

  // string language = 5;
  if (!this->_internal_language().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_language());
  }

  // string language_code = 6;
  if (!this->_internal_language_code().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_language_code());
  }

  // string preview_url = 15;
  if (!this->_internal_preview_url().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_preview_url());
  }

  // string preview_text = 16;
  if (!this->_internal_preview_text().empty()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_preview_text());
  }

  // .unhinged.common.v1.ResourceMetadata metadata = 1;
  if (this->_internal_has_metadata()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.metadata_);
  }

  // .unhinged.audio.v1.VoiceGender gender = 7;
  if (this->_internal_gender() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_gender());
  }

  // .unhinged.audio.v1.VoiceAge age = 8;
  if (this->_internal_age() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_age());
  }

  // .unhinged.audio.v1.VoiceStyle style = 9;
  if (this->_internal_style() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_style());
  }

  // bool is_available = 12;
  if (this->_internal_is_available() != 0) {
    total_size += 1 + 1;
  }

  // bool is_premium = 13;
  if (this->_internal_is_premium() != 0) {
    total_size += 1 + 1;
  }

  // float cost_per_character = 14;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_cost_per_character = this->_internal_cost_per_character();
  uint32_t raw_cost_per_character;
  memcpy(&raw_cost_per_character, &tmp_cost_per_character, sizeof(tmp_cost_per_character));
  if (raw_cost_per_character != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Voice::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Voice::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Voice::GetClassData() const { return &_class_data_; }


void Voice::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Voice*>(&to_msg);
  auto& from = static_cast<const Voice&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unhinged.audio.v1.Voice)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.supported_formats_.MergeFrom(from._impl_.supported_formats_);
  _this->_impl_.supported_sample_rates_.MergeFrom(from._impl_.supported_sample_rates_);
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_display_name().empty()) {
    _this->_internal_set_display_name(from._internal_display_name());
  }
  if (!from._internal_description().empty()) {
    _this->_internal_set_description(from._internal_description());
  }
  if (!from._internal_language().empty()) {
    _this->_internal_set_language(from._internal_language());
  }
  if (!from._internal_language_code().empty()) {
    _this->_internal_set_language_code(from._internal_language_code());
  }
  if (!from._internal_preview_url().empty()) {
    _this->_internal_set_preview_url(from._internal_preview_url());
  }
  if (!from._internal_preview_text().empty()) {
    _this->_internal_set_preview_text(from._internal_preview_text());
  }
  if (from._internal_has_metadata()) {
    _this->_internal_mutable_metadata()->::unhinged::common::v1::ResourceMetadata::MergeFrom(
        from._internal_metadata());
  }
  if (from._internal_gender() != 0) {
    _this->_internal_set_gender(from._internal_gender());
  }
  if (from._internal_age() != 0) {
    _this->_internal_set_age(from._internal_age());
  }
  if (from._internal_style() != 0) {
    _this->_internal_set_style(from._internal_style());
  }
  if (from._internal_is_available() != 0) {
    _this->_internal_set_is_available(from._internal_is_available());
  }
  if (from._internal_is_premium() != 0) {
    _this->_internal_set_is_premium(from._internal_is_premium());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_cost_per_character = from._internal_cost_per_character();
  uint32_t raw_cost_per_character;
  memcpy(&raw_cost_per_character, &tmp_cost_per_character, sizeof(tmp_cost_per_character));
  if (raw_cost_per_character != 0) {
    _this->_internal_set_cost_per_character(from._internal_cost_per_character());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Voice::CopyFrom(const Voice& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unhinged.audio.v1.Voice)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Voice::IsInitialized() const {
  return true;
}

void Voice::InternalSwap(Voice* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.supported_formats_.InternalSwap(&other->_impl_.supported_formats_);
  _impl_.supported_sample_rates_.InternalSwap(&other->_impl_.supported_sample_rates_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.display_name_, lhs_arena,
      &other->_impl_.display_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.description_, lhs_arena,
      &other->_impl_.description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.language_, lhs_arena,
      &other->_impl_.language_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.language_code_, lhs_arena,
      &other->_impl_.language_code_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.preview_url_, lhs_arena,
      &other->_impl_.preview_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.preview_text_, lhs_arena,
      &other->_impl_.preview_text_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Voice, _impl_.cost_per_character_)
      + sizeof(Voice::_impl_.cost_per_character_)
      - PROTOBUF_FIELD_OFFSET(Voice, _impl_.metadata_)>(
          reinterpret_cast<char*>(&_impl_.metadata_),
          reinterpret_cast<char*>(&other->_impl_.metadata_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Voice::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_2eproto_getter, &descriptor_table_audio_2eproto_once,
      file_level_metadata_audio_2eproto[8]);
}

// ===================================================================

class TTSChunkPayload::_Internal {
 public:
  static const ::unhinged::audio::v1::AudioMetadata& audio_metadata(const TTSChunkPayload* msg);
};

const ::unhinged::audio::v1::AudioMetadata&
TTSChunkPayload::_Internal::audio_metadata(const TTSChunkPayload* msg) {
  return *msg->_impl_.audio_metadata_;
}
TTSChunkPayload::TTSChunkPayload(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unhinged.audio.v1.TTSChunkPayload)
}
TTSChunkPayload::TTSChunkPayload(const TTSChunkPayload& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TTSChunkPayload* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.tts_id_){}
    , decltype(_impl_.audio_metadata_){nullptr}
    , decltype(_impl_.chunk_index_){}
    , decltype(_impl_.progress_percent_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.tts_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tts_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_tts_id().empty()) {
    _this->_impl_.tts_id_.Set(from._internal_tts_id(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_audio_metadata()) {
    _this->_impl_.audio_metadata_ = new ::unhinged::audio::v1::AudioMetadata(*from._impl_.audio_metadata_);
  }
  ::memcpy(&_impl_.chunk_index_, &from._impl_.chunk_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.progress_percent_) -
    reinterpret_cast<char*>(&_impl_.chunk_index_)) + sizeof(_impl_.progress_percent_));
  // @@protoc_insertion_point(copy_constructor:unhinged.audio.v1.TTSChunkPayload)
}

inline void TTSChunkPayload::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.tts_id_){}
    , decltype(_impl_.audio_metadata_){nullptr}
    , decltype(_impl_.chunk_index_){0}
    , decltype(_impl_.progress_percent_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.tts_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tts_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TTSChunkPayload::~TTSChunkPayload() {
  // @@protoc_insertion_point(destructor:unhinged.audio.v1.TTSChunkPayload)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TTSChunkPayload::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.tts_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.audio_metadata_;
}

void TTSChunkPayload::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TTSChunkPayload::Clear() {
// @@protoc_insertion_point(message_clear_start:unhinged.audio.v1.TTSChunkPayload)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.tts_id_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.audio_metadata_ != nullptr) {
    delete _impl_.audio_metadata_;
  }
  _impl_.audio_metadata_ = nullptr;
  ::memset(&_impl_.chunk_index_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.progress_percent_) -
      reinterpret_cast<char*>(&_impl_.chunk_index_)) + sizeof(_impl_.progress_percent_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TTSChunkPayload::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string tts_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_tts_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "unhinged.audio.v1.TTSChunkPayload.tts_id"));
        } else
          goto handle_unusual;
        continue;
      // .unhinged.audio.v1.AudioMetadata audio_metadata = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_audio_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 chunk_index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.chunk_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float progress_percent = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _impl_.progress_percent_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TTSChunkPayload::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unhinged.audio.v1.TTSChunkPayload)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string tts_id = 1;
  if (!this->_internal_tts_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_tts_id().data(), static_cast<int>(this->_internal_tts_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "unhinged.audio.v1.TTSChunkPayload.tts_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_tts_id(), target);
  }

  // .unhinged.audio.v1.AudioMetadata audio_metadata = 2;
  if (this->_internal_has_audio_metadata()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::audio_metadata(this),
        _Internal::audio_metadata(this).GetCachedSize(), target, stream);
  }

  // int32 chunk_index = 3;
  if (this->_internal_chunk_index() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_chunk_index(), target);
  }

  // float progress_percent = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_progress_percent = this->_internal_progress_percent();
  uint32_t raw_progress_percent;
  memcpy(&raw_progress_percent, &tmp_progress_percent, sizeof(tmp_progress_percent));
  if (raw_progress_percent != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_progress_percent(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unhinged.audio.v1.TTSChunkPayload)
  return target;
}

size_t TTSChunkPayload::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unhinged.audio.v1.TTSChunkPayload)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string tts_id = 1;
  if (!this->_internal_tts_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_tts_id());
  }

  // .unhinged.audio.v1.AudioMetadata audio_metadata = 2;
  if (this->_internal_has_audio_metadata()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.audio_metadata_);
  }

  // int32 chunk_index = 3;
  if (this->_internal_chunk_index() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_chunk_index());
  }

  // float progress_percent = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_progress_percent = this->_internal_progress_percent();
  uint32_t raw_progress_percent;
  memcpy(&raw_progress_percent, &tmp_progress_percent, sizeof(tmp_progress_percent));
  if (raw_progress_percent != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TTSChunkPayload::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TTSChunkPayload::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TTSChunkPayload::GetClassData() const { return &_class_data_; }


void TTSChunkPayload::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TTSChunkPayload*>(&to_msg);
  auto& from = static_cast<const TTSChunkPayload&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unhinged.audio.v1.TTSChunkPayload)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_tts_id().empty()) {
    _this->_internal_set_tts_id(from._internal_tts_id());
  }
  if (from._internal_has_audio_metadata()) {
    _this->_internal_mutable_audio_metadata()->::unhinged::audio::v1::AudioMetadata::MergeFrom(
        from._internal_audio_metadata());
  }
  if (from._internal_chunk_index() != 0) {
    _this->_internal_set_chunk_index(from._internal_chunk_index());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_progress_percent = from._internal_progress_percent();
  uint32_t raw_progress_percent;
  memcpy(&raw_progress_percent, &tmp_progress_percent, sizeof(tmp_progress_percent));
  if (raw_progress_percent != 0) {
    _this->_internal_set_progress_percent(from._internal_progress_percent());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TTSChunkPayload::CopyFrom(const TTSChunkPayload& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unhinged.audio.v1.TTSChunkPayload)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TTSChunkPayload::IsInitialized() const {
  return true;
}

void TTSChunkPayload::InternalSwap(TTSChunkPayload* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.tts_id_, lhs_arena,
      &other->_impl_.tts_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TTSChunkPayload, _impl_.progress_percent_)
      + sizeof(TTSChunkPayload::_impl_.progress_percent_)
      - PROTOBUF_FIELD_OFFSET(TTSChunkPayload, _impl_.audio_metadata_)>(
          reinterpret_cast<char*>(&_impl_.audio_metadata_),
          reinterpret_cast<char*>(&other->_impl_.audio_metadata_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TTSChunkPayload::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_2eproto_getter, &descriptor_table_audio_2eproto_once,
      file_level_metadata_audio_2eproto[9]);
}

// ===================================================================

class STTChunkPayload::_Internal {
 public:
  static const ::unhinged::audio::v1::AudioMetadata& audio_metadata(const STTChunkPayload* msg);
};

const ::unhinged::audio::v1::AudioMetadata&
STTChunkPayload::_Internal::audio_metadata(const STTChunkPayload* msg) {
  return *msg->_impl_.audio_metadata_;
}
STTChunkPayload::STTChunkPayload(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unhinged.audio.v1.STTChunkPayload)
}
STTChunkPayload::STTChunkPayload(const STTChunkPayload& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  STTChunkPayload* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.stt_id_){}
    , decltype(_impl_.audio_metadata_){nullptr}
    , decltype(_impl_.is_final_chunk_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.stt_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.stt_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_stt_id().empty()) {
    _this->_impl_.stt_id_.Set(from._internal_stt_id(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_audio_metadata()) {
    _this->_impl_.audio_metadata_ = new ::unhinged::audio::v1::AudioMetadata(*from._impl_.audio_metadata_);
  }
  _this->_impl_.is_final_chunk_ = from._impl_.is_final_chunk_;
  // @@protoc_insertion_point(copy_constructor:unhinged.audio.v1.STTChunkPayload)
}

inline void STTChunkPayload::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.stt_id_){}
    , decltype(_impl_.audio_metadata_){nullptr}
    , decltype(_impl_.is_final_chunk_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.stt_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.stt_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

STTChunkPayload::~STTChunkPayload() {
  // @@protoc_insertion_point(destructor:unhinged.audio.v1.STTChunkPayload)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void STTChunkPayload::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.stt_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.audio_metadata_;
}

void STTChunkPayload::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void STTChunkPayload::Clear() {
// @@protoc_insertion_point(message_clear_start:unhinged.audio.v1.STTChunkPayload)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.stt_id_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.audio_metadata_ != nullptr) {
    delete _impl_.audio_metadata_;
  }
  _impl_.audio_metadata_ = nullptr;
  _impl_.is_final_chunk_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* STTChunkPayload::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string stt_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_stt_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "unhinged.audio.v1.STTChunkPayload.stt_id"));
        } else
          goto handle_unusual;
        continue;
      // .unhinged.audio.v1.AudioMetadata audio_metadata = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_audio_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool is_final_chunk = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.is_final_chunk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* STTChunkPayload::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unhinged.audio.v1.STTChunkPayload)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string stt_id = 1;
  if (!this->_internal_stt_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_stt_id().data(), static_cast<int>(this->_internal_stt_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "unhinged.audio.v1.STTChunkPayload.stt_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_stt_id(), target);
  }

  // .unhinged.audio.v1.AudioMetadata audio_metadata = 2;
  if (this->_internal_has_audio_metadata()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::audio_metadata(this),
        _Internal::audio_metadata(this).GetCachedSize(), target, stream);
  }

  // bool is_final_chunk = 3;
  if (this->_internal_is_final_chunk() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_is_final_chunk(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unhinged.audio.v1.STTChunkPayload)
  return target;
}

size_t STTChunkPayload::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unhinged.audio.v1.STTChunkPayload)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string stt_id = 1;
  if (!this->_internal_stt_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_stt_id());
  }

  // .unhinged.audio.v1.AudioMetadata audio_metadata = 2;
  if (this->_internal_has_audio_metadata()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.audio_metadata_);
  }

  // bool is_final_chunk = 3;
  if (this->_internal_is_final_chunk() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData STTChunkPayload::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    STTChunkPayload::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*STTChunkPayload::GetClassData() const { return &_class_data_; }


void STTChunkPayload::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<STTChunkPayload*>(&to_msg);
  auto& from = static_cast<const STTChunkPayload&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unhinged.audio.v1.STTChunkPayload)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_stt_id().empty()) {
    _this->_internal_set_stt_id(from._internal_stt_id());
  }
  if (from._internal_has_audio_metadata()) {
    _this->_internal_mutable_audio_metadata()->::unhinged::audio::v1::AudioMetadata::MergeFrom(
        from._internal_audio_metadata());
  }
  if (from._internal_is_final_chunk() != 0) {
    _this->_internal_set_is_final_chunk(from._internal_is_final_chunk());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void STTChunkPayload::CopyFrom(const STTChunkPayload& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unhinged.audio.v1.STTChunkPayload)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool STTChunkPayload::IsInitialized() const {
  return true;
}

void STTChunkPayload::InternalSwap(STTChunkPayload* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.stt_id_, lhs_arena,
      &other->_impl_.stt_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(STTChunkPayload, _impl_.is_final_chunk_)
      + sizeof(STTChunkPayload::_impl_.is_final_chunk_)
      - PROTOBUF_FIELD_OFFSET(STTChunkPayload, _impl_.audio_metadata_)>(
          reinterpret_cast<char*>(&_impl_.audio_metadata_),
          reinterpret_cast<char*>(&other->_impl_.audio_metadata_));
}

::PROTOBUF_NAMESPACE_ID::Metadata STTChunkPayload::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_2eproto_getter, &descriptor_table_audio_2eproto_once,
      file_level_metadata_audio_2eproto[10]);
}

// ===================================================================

class AudioMetadata::_Internal {
 public:
};

AudioMetadata::AudioMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unhinged.audio.v1.AudioMetadata)
}
AudioMetadata::AudioMetadata(const AudioMetadata& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AudioMetadata* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.format_){}
    , decltype(_impl_.sample_rate_){}
    , decltype(_impl_.channels_){}
    , decltype(_impl_.bit_depth_){}
    , decltype(_impl_.total_bytes_){}
    , decltype(_impl_.duration_seconds_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.format_, &from._impl_.format_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.duration_seconds_) -
    reinterpret_cast<char*>(&_impl_.format_)) + sizeof(_impl_.duration_seconds_));
  // @@protoc_insertion_point(copy_constructor:unhinged.audio.v1.AudioMetadata)
}

inline void AudioMetadata::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.format_){0}
    , decltype(_impl_.sample_rate_){0}
    , decltype(_impl_.channels_){0}
    , decltype(_impl_.bit_depth_){0}
    , decltype(_impl_.total_bytes_){int64_t{0}}
    , decltype(_impl_.duration_seconds_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

AudioMetadata::~AudioMetadata() {
  // @@protoc_insertion_point(destructor:unhinged.audio.v1.AudioMetadata)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AudioMetadata::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AudioMetadata::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AudioMetadata::Clear() {
// @@protoc_insertion_point(message_clear_start:unhinged.audio.v1.AudioMetadata)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.format_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.duration_seconds_) -
      reinterpret_cast<char*>(&_impl_.format_)) + sizeof(_impl_.duration_seconds_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AudioMetadata::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .unhinged.audio.v1.AudioFormat format = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_format(static_cast<::unhinged::audio::v1::AudioFormat>(val));
        } else
          goto handle_unusual;
        continue;
      // int32 sample_rate = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.sample_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 channels = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.channels_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 bit_depth = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.bit_depth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float duration_seconds = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _impl_.duration_seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // int64 total_bytes = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.total_bytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AudioMetadata::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unhinged.audio.v1.AudioMetadata)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .unhinged.audio.v1.AudioFormat format = 1;
  if (this->_internal_format() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_format(), target);
  }

  // int32 sample_rate = 2;
  if (this->_internal_sample_rate() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_sample_rate(), target);
  }

  // int32 channels = 3;
  if (this->_internal_channels() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_channels(), target);
  }

  // int32 bit_depth = 4;
  if (this->_internal_bit_depth() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_bit_depth(), target);
  }

  // float duration_seconds = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_duration_seconds = this->_internal_duration_seconds();
  uint32_t raw_duration_seconds;
  memcpy(&raw_duration_seconds, &tmp_duration_seconds, sizeof(tmp_duration_seconds));
  if (raw_duration_seconds != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_duration_seconds(), target);
  }

  // int64 total_bytes = 6;
  if (this->_internal_total_bytes() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(6, this->_internal_total_bytes(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unhinged.audio.v1.AudioMetadata)
  return target;
}

size_t AudioMetadata::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unhinged.audio.v1.AudioMetadata)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .unhinged.audio.v1.AudioFormat format = 1;
  if (this->_internal_format() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_format());
  }

  // int32 sample_rate = 2;
  if (this->_internal_sample_rate() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_sample_rate());
  }

  // int32 channels = 3;
  if (this->_internal_channels() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_channels());
  }

  // int32 bit_depth = 4;
  if (this->_internal_bit_depth() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_bit_depth());
  }

  // int64 total_bytes = 6;
  if (this->_internal_total_bytes() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_total_bytes());
  }

  // float duration_seconds = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_duration_seconds = this->_internal_duration_seconds();
  uint32_t raw_duration_seconds;
  memcpy(&raw_duration_seconds, &tmp_duration_seconds, sizeof(tmp_duration_seconds));
  if (raw_duration_seconds != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AudioMetadata::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AudioMetadata::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AudioMetadata::GetClassData() const { return &_class_data_; }


void AudioMetadata::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AudioMetadata*>(&to_msg);
  auto& from = static_cast<const AudioMetadata&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unhinged.audio.v1.AudioMetadata)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_format() != 0) {
    _this->_internal_set_format(from._internal_format());
  }
  if (from._internal_sample_rate() != 0) {
    _this->_internal_set_sample_rate(from._internal_sample_rate());
  }
  if (from._internal_channels() != 0) {
    _this->_internal_set_channels(from._internal_channels());
  }
  if (from._internal_bit_depth() != 0) {
    _this->_internal_set_bit_depth(from._internal_bit_depth());
  }
  if (from._internal_total_bytes() != 0) {
    _this->_internal_set_total_bytes(from._internal_total_bytes());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_duration_seconds = from._internal_duration_seconds();
  uint32_t raw_duration_seconds;
  memcpy(&raw_duration_seconds, &tmp_duration_seconds, sizeof(tmp_duration_seconds));
  if (raw_duration_seconds != 0) {
    _this->_internal_set_duration_seconds(from._internal_duration_seconds());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AudioMetadata::CopyFrom(const AudioMetadata& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unhinged.audio.v1.AudioMetadata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioMetadata::IsInitialized() const {
  return true;
}

void AudioMetadata::InternalSwap(AudioMetadata* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AudioMetadata, _impl_.duration_seconds_)
      + sizeof(AudioMetadata::_impl_.duration_seconds_)
      - PROTOBUF_FIELD_OFFSET(AudioMetadata, _impl_.format_)>(
          reinterpret_cast<char*>(&_impl_.format_),
          reinterpret_cast<char*>(&other->_impl_.format_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AudioMetadata::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_2eproto_getter, &descriptor_table_audio_2eproto_once,
      file_level_metadata_audio_2eproto[11]);
}

// ===================================================================

class ProcessAudioRequest::_Internal {
 public:
  static const ::unhinged::common::v1::Attachment& audio_file(const ProcessAudioRequest* msg);
  static const ::unhinged::audio::v1::AudioOptions& options(const ProcessAudioRequest* msg);
};

const ::unhinged::common::v1::Attachment&
ProcessAudioRequest::_Internal::audio_file(const ProcessAudioRequest* msg) {
  return *msg->_impl_.audio_file_;
}
const ::unhinged::audio::v1::AudioOptions&
ProcessAudioRequest::_Internal::options(const ProcessAudioRequest* msg) {
  return *msg->_impl_.options_;
}
void ProcessAudioRequest::clear_audio_file() {
  if (GetArenaForAllocation() == nullptr && _impl_.audio_file_ != nullptr) {
    delete _impl_.audio_file_;
  }
  _impl_.audio_file_ = nullptr;
}
ProcessAudioRequest::ProcessAudioRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unhinged.audio.v1.ProcessAudioRequest)
}
ProcessAudioRequest::ProcessAudioRequest(const ProcessAudioRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ProcessAudioRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.audio_file_){nullptr}
    , decltype(_impl_.options_){nullptr}
    , decltype(_impl_.processing_type_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_audio_file()) {
    _this->_impl_.audio_file_ = new ::unhinged::common::v1::Attachment(*from._impl_.audio_file_);
  }
  if (from._internal_has_options()) {
    _this->_impl_.options_ = new ::unhinged::audio::v1::AudioOptions(*from._impl_.options_);
  }
  _this->_impl_.processing_type_ = from._impl_.processing_type_;
  // @@protoc_insertion_point(copy_constructor:unhinged.audio.v1.ProcessAudioRequest)
}

inline void ProcessAudioRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.audio_file_){nullptr}
    , decltype(_impl_.options_){nullptr}
    , decltype(_impl_.processing_type_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ProcessAudioRequest::~ProcessAudioRequest() {
  // @@protoc_insertion_point(destructor:unhinged.audio.v1.ProcessAudioRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ProcessAudioRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.audio_file_;
  if (this != internal_default_instance()) delete _impl_.options_;
}

void ProcessAudioRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ProcessAudioRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:unhinged.audio.v1.ProcessAudioRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.audio_file_ != nullptr) {
    delete _impl_.audio_file_;
  }
  _impl_.audio_file_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.options_ != nullptr) {
    delete _impl_.options_;
  }
  _impl_.options_ = nullptr;
  _impl_.processing_type_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ProcessAudioRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .unhinged.common.v1.Attachment audio_file = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_audio_file(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .unhinged.audio.v1.ProcessingType processing_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_processing_type(static_cast<::unhinged::audio::v1::ProcessingType>(val));
        } else
          goto handle_unusual;
        continue;
      // .unhinged.audio.v1.AudioOptions options = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_options(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ProcessAudioRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unhinged.audio.v1.ProcessAudioRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .unhinged.common.v1.Attachment audio_file = 1;
  if (this->_internal_has_audio_file()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::audio_file(this),
        _Internal::audio_file(this).GetCachedSize(), target, stream);
  }

  // .unhinged.audio.v1.ProcessingType processing_type = 2;
  if (this->_internal_processing_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_processing_type(), target);
  }

  // .unhinged.audio.v1.AudioOptions options = 3;
  if (this->_internal_has_options()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::options(this),
        _Internal::options(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unhinged.audio.v1.ProcessAudioRequest)
  return target;
}

size_t ProcessAudioRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unhinged.audio.v1.ProcessAudioRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .unhinged.common.v1.Attachment audio_file = 1;
  if (this->_internal_has_audio_file()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.audio_file_);
  }

  // .unhinged.audio.v1.AudioOptions options = 3;
  if (this->_internal_has_options()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.options_);
  }

  // .unhinged.audio.v1.ProcessingType processing_type = 2;
  if (this->_internal_processing_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_processing_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ProcessAudioRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ProcessAudioRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ProcessAudioRequest::GetClassData() const { return &_class_data_; }


void ProcessAudioRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ProcessAudioRequest*>(&to_msg);
  auto& from = static_cast<const ProcessAudioRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unhinged.audio.v1.ProcessAudioRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_audio_file()) {
    _this->_internal_mutable_audio_file()->::unhinged::common::v1::Attachment::MergeFrom(
        from._internal_audio_file());
  }
  if (from._internal_has_options()) {
    _this->_internal_mutable_options()->::unhinged::audio::v1::AudioOptions::MergeFrom(
        from._internal_options());
  }
  if (from._internal_processing_type() != 0) {
    _this->_internal_set_processing_type(from._internal_processing_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ProcessAudioRequest::CopyFrom(const ProcessAudioRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unhinged.audio.v1.ProcessAudioRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProcessAudioRequest::IsInitialized() const {
  return true;
}

void ProcessAudioRequest::InternalSwap(ProcessAudioRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ProcessAudioRequest, _impl_.processing_type_)
      + sizeof(ProcessAudioRequest::_impl_.processing_type_)
      - PROTOBUF_FIELD_OFFSET(ProcessAudioRequest, _impl_.audio_file_)>(
          reinterpret_cast<char*>(&_impl_.audio_file_),
          reinterpret_cast<char*>(&other->_impl_.audio_file_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ProcessAudioRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_2eproto_getter, &descriptor_table_audio_2eproto_once,
      file_level_metadata_audio_2eproto[12]);
}

// ===================================================================

class ProcessAudioResponse::_Internal {
 public:
  static const ::unhinged::common::v1::StandardResponse& response(const ProcessAudioResponse* msg);
  static const ::unhinged::common::v1::Attachment& enhanced_audio(const ProcessAudioResponse* msg);
  static const ::unhinged::common::v1::Attachment& converted_audio(const ProcessAudioResponse* msg);
  static const ::unhinged::common::v1::AudioUsage& usage(const ProcessAudioResponse* msg);
};

const ::unhinged::common::v1::StandardResponse&
ProcessAudioResponse::_Internal::response(const ProcessAudioResponse* msg) {
  return *msg->_impl_.response_;
}
const ::unhinged::common::v1::Attachment&
ProcessAudioResponse::_Internal::enhanced_audio(const ProcessAudioResponse* msg) {
  return *msg->_impl_.result_.enhanced_audio_;
}
const ::unhinged::common::v1::Attachment&
ProcessAudioResponse::_Internal::converted_audio(const ProcessAudioResponse* msg) {
  return *msg->_impl_.result_.converted_audio_;
}
const ::unhinged::common::v1::AudioUsage&
ProcessAudioResponse::_Internal::usage(const ProcessAudioResponse* msg) {
  return *msg->_impl_.usage_;
}
void ProcessAudioResponse::clear_response() {
  if (GetArenaForAllocation() == nullptr && _impl_.response_ != nullptr) {
    delete _impl_.response_;
  }
  _impl_.response_ = nullptr;
}
void ProcessAudioResponse::set_allocated_enhanced_audio(::unhinged::common::v1::Attachment* enhanced_audio) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_result();
  if (enhanced_audio) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(enhanced_audio));
    if (message_arena != submessage_arena) {
      enhanced_audio = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, enhanced_audio, submessage_arena);
    }
    set_has_enhanced_audio();
    _impl_.result_.enhanced_audio_ = enhanced_audio;
  }
  // @@protoc_insertion_point(field_set_allocated:unhinged.audio.v1.ProcessAudioResponse.enhanced_audio)
}
void ProcessAudioResponse::clear_enhanced_audio() {
  if (_internal_has_enhanced_audio()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.result_.enhanced_audio_;
    }
    clear_has_result();
  }
}
void ProcessAudioResponse::set_allocated_converted_audio(::unhinged::common::v1::Attachment* converted_audio) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_result();
  if (converted_audio) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(converted_audio));
    if (message_arena != submessage_arena) {
      converted_audio = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, converted_audio, submessage_arena);
    }
    set_has_converted_audio();
    _impl_.result_.converted_audio_ = converted_audio;
  }
  // @@protoc_insertion_point(field_set_allocated:unhinged.audio.v1.ProcessAudioResponse.converted_audio)
}
void ProcessAudioResponse::clear_converted_audio() {
  if (_internal_has_converted_audio()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.result_.converted_audio_;
    }
    clear_has_result();
  }
}
void ProcessAudioResponse::clear_usage() {
  if (GetArenaForAllocation() == nullptr && _impl_.usage_ != nullptr) {
    delete _impl_.usage_;
  }
  _impl_.usage_ = nullptr;
}
ProcessAudioResponse::ProcessAudioResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unhinged.audio.v1.ProcessAudioResponse)
}
ProcessAudioResponse::ProcessAudioResponse(const ProcessAudioResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ProcessAudioResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.response_){nullptr}
    , decltype(_impl_.usage_){nullptr}
    , decltype(_impl_.result_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_response()) {
    _this->_impl_.response_ = new ::unhinged::common::v1::StandardResponse(*from._impl_.response_);
  }
  if (from._internal_has_usage()) {
    _this->_impl_.usage_ = new ::unhinged::common::v1::AudioUsage(*from._impl_.usage_);
  }
  clear_has_result();
  switch (from.result_case()) {
    case kTranscript: {
      _this->_internal_set_transcript(from._internal_transcript());
      break;
    }
    case kTranslation: {
      _this->_internal_set_translation(from._internal_translation());
      break;
    }
    case kEnhancedAudio: {
      _this->_internal_mutable_enhanced_audio()->::unhinged::common::v1::Attachment::MergeFrom(
          from._internal_enhanced_audio());
      break;
    }
    case kConvertedAudio: {
      _this->_internal_mutable_converted_audio()->::unhinged::common::v1::Attachment::MergeFrom(
          from._internal_converted_audio());
      break;
    }
    case RESULT_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:unhinged.audio.v1.ProcessAudioResponse)
}

inline void ProcessAudioResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.response_){nullptr}
    , decltype(_impl_.usage_){nullptr}
    , decltype(_impl_.result_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_result();
}

ProcessAudioResponse::~ProcessAudioResponse() {
  // @@protoc_insertion_point(destructor:unhinged.audio.v1.ProcessAudioResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ProcessAudioResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.response_;
  if (this != internal_default_instance()) delete _impl_.usage_;
  if (has_result()) {
    clear_result();
  }
}

void ProcessAudioResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ProcessAudioResponse::clear_result() {
// @@protoc_insertion_point(one_of_clear_start:unhinged.audio.v1.ProcessAudioResponse)
  switch (result_case()) {
    case kTranscript: {
      _impl_.result_.transcript_.Destroy();
      break;
    }
    case kTranslation: {
      _impl_.result_.translation_.Destroy();
      break;
    }
    case kEnhancedAudio: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.result_.enhanced_audio_;
      }
      break;
    }
    case kConvertedAudio: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.result_.converted_audio_;
      }
      break;
    }
    case RESULT_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = RESULT_NOT_SET;
}


void ProcessAudioResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:unhinged.audio.v1.ProcessAudioResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.response_ != nullptr) {
    delete _impl_.response_;
  }
  _impl_.response_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.usage_ != nullptr) {
    delete _impl_.usage_;
  }
  _impl_.usage_ = nullptr;
  clear_result();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ProcessAudioResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .unhinged.common.v1.StandardResponse response = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string transcript = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_transcript();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "unhinged.audio.v1.ProcessAudioResponse.transcript"));
        } else
          goto handle_unusual;
        continue;
      // string translation = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_translation();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "unhinged.audio.v1.ProcessAudioResponse.translation"));
        } else
          goto handle_unusual;
        continue;
      // .unhinged.common.v1.Attachment enhanced_audio = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_enhanced_audio(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .unhinged.common.v1.Attachment converted_audio = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_converted_audio(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .unhinged.common.v1.AudioUsage usage = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_usage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ProcessAudioResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unhinged.audio.v1.ProcessAudioResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .unhinged.common.v1.StandardResponse response = 1;
  if (this->_internal_has_response()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::response(this),
        _Internal::response(this).GetCachedSize(), target, stream);
  }

  // string transcript = 2;
  if (_internal_has_transcript()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_transcript().data(), static_cast<int>(this->_internal_transcript().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "unhinged.audio.v1.ProcessAudioResponse.transcript");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_transcript(), target);
  }

  // string translation = 3;
  if (_internal_has_translation()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_translation().data(), static_cast<int>(this->_internal_translation().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "unhinged.audio.v1.ProcessAudioResponse.translation");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_translation(), target);
  }

  // .unhinged.common.v1.Attachment enhanced_audio = 4;
  if (_internal_has_enhanced_audio()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::enhanced_audio(this),
        _Internal::enhanced_audio(this).GetCachedSize(), target, stream);
  }

  // .unhinged.common.v1.Attachment converted_audio = 5;
  if (_internal_has_converted_audio()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::converted_audio(this),
        _Internal::converted_audio(this).GetCachedSize(), target, stream);
  }

  // .unhinged.common.v1.AudioUsage usage = 6;
  if (this->_internal_has_usage()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::usage(this),
        _Internal::usage(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unhinged.audio.v1.ProcessAudioResponse)
  return target;
}

size_t ProcessAudioResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unhinged.audio.v1.ProcessAudioResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .unhinged.common.v1.StandardResponse response = 1;
  if (this->_internal_has_response()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.response_);
  }

  // .unhinged.common.v1.AudioUsage usage = 6;
  if (this->_internal_has_usage()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.usage_);
  }

  switch (result_case()) {
    // string transcript = 2;
    case kTranscript: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_transcript());
      break;
    }
    // string translation = 3;
    case kTranslation: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_translation());
      break;
    }
    // .unhinged.common.v1.Attachment enhanced_audio = 4;
    case kEnhancedAudio: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.result_.enhanced_audio_);
      break;
    }
    // .unhinged.common.v1.Attachment converted_audio = 5;
    case kConvertedAudio: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.result_.converted_audio_);
      break;
    }
    case RESULT_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ProcessAudioResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ProcessAudioResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ProcessAudioResponse::GetClassData() const { return &_class_data_; }


void ProcessAudioResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ProcessAudioResponse*>(&to_msg);
  auto& from = static_cast<const ProcessAudioResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unhinged.audio.v1.ProcessAudioResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_response()) {
    _this->_internal_mutable_response()->::unhinged::common::v1::StandardResponse::MergeFrom(
        from._internal_response());
  }
  if (from._internal_has_usage()) {
    _this->_internal_mutable_usage()->::unhinged::common::v1::AudioUsage::MergeFrom(
        from._internal_usage());
  }
  switch (from.result_case()) {
    case kTranscript: {
      _this->_internal_set_transcript(from._internal_transcript());
      break;
    }
    case kTranslation: {
      _this->_internal_set_translation(from._internal_translation());
      break;
    }
    case kEnhancedAudio: {
      _this->_internal_mutable_enhanced_audio()->::unhinged::common::v1::Attachment::MergeFrom(
          from._internal_enhanced_audio());
      break;
    }
    case kConvertedAudio: {
      _this->_internal_mutable_converted_audio()->::unhinged::common::v1::Attachment::MergeFrom(
          from._internal_converted_audio());
      break;
    }
    case RESULT_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ProcessAudioResponse::CopyFrom(const ProcessAudioResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unhinged.audio.v1.ProcessAudioResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProcessAudioResponse::IsInitialized() const {
  return true;
}

void ProcessAudioResponse::InternalSwap(ProcessAudioResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ProcessAudioResponse, _impl_.usage_)
      + sizeof(ProcessAudioResponse::_impl_.usage_)
      - PROTOBUF_FIELD_OFFSET(ProcessAudioResponse, _impl_.response_)>(
          reinterpret_cast<char*>(&_impl_.response_),
          reinterpret_cast<char*>(&other->_impl_.response_));
  swap(_impl_.result_, other->_impl_.result_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata ProcessAudioResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_2eproto_getter, &descriptor_table_audio_2eproto_once,
      file_level_metadata_audio_2eproto[13]);
}

// ===================================================================

class ListVoicesRequest::_Internal {
 public:
  static const ::unhinged::common::v1::PaginationRequest& pagination(const ListVoicesRequest* msg);
};

const ::unhinged::common::v1::PaginationRequest&
ListVoicesRequest::_Internal::pagination(const ListVoicesRequest* msg) {
  return *msg->_impl_.pagination_;
}
void ListVoicesRequest::clear_pagination() {
  if (GetArenaForAllocation() == nullptr && _impl_.pagination_ != nullptr) {
    delete _impl_.pagination_;
  }
  _impl_.pagination_ = nullptr;
}
void ListVoicesRequest::clear_filters() {
  _impl_.filters_.Clear();
}
ListVoicesRequest::ListVoicesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unhinged.audio.v1.ListVoicesRequest)
}
ListVoicesRequest::ListVoicesRequest(const ListVoicesRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ListVoicesRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.filters_){from._impl_.filters_}
    , decltype(_impl_.language_){}
    , decltype(_impl_.pagination_){nullptr}
    , decltype(_impl_.gender_){}
    , decltype(_impl_.style_){}
    , decltype(_impl_.premium_only_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.language_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.language_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_language().empty()) {
    _this->_impl_.language_.Set(from._internal_language(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_pagination()) {
    _this->_impl_.pagination_ = new ::unhinged::common::v1::PaginationRequest(*from._impl_.pagination_);
  }
  ::memcpy(&_impl_.gender_, &from._impl_.gender_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.premium_only_) -
    reinterpret_cast<char*>(&_impl_.gender_)) + sizeof(_impl_.premium_only_));
  // @@protoc_insertion_point(copy_constructor:unhinged.audio.v1.ListVoicesRequest)
}

inline void ListVoicesRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.filters_){arena}
    , decltype(_impl_.language_){}
    , decltype(_impl_.pagination_){nullptr}
    , decltype(_impl_.gender_){0}
    , decltype(_impl_.style_){0}
    , decltype(_impl_.premium_only_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.language_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.language_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ListVoicesRequest::~ListVoicesRequest() {
  // @@protoc_insertion_point(destructor:unhinged.audio.v1.ListVoicesRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ListVoicesRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.filters_.~RepeatedPtrField();
  _impl_.language_.Destroy();
  if (this != internal_default_instance()) delete _impl_.pagination_;
}

void ListVoicesRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ListVoicesRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:unhinged.audio.v1.ListVoicesRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.filters_.Clear();
  _impl_.language_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.pagination_ != nullptr) {
    delete _impl_.pagination_;
  }
  _impl_.pagination_ = nullptr;
  ::memset(&_impl_.gender_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.premium_only_) -
      reinterpret_cast<char*>(&_impl_.gender_)) + sizeof(_impl_.premium_only_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ListVoicesRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string language = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_language();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "unhinged.audio.v1.ListVoicesRequest.language"));
        } else
          goto handle_unusual;
        continue;
      // .unhinged.audio.v1.VoiceGender gender = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_gender(static_cast<::unhinged::audio::v1::VoiceGender>(val));
        } else
          goto handle_unusual;
        continue;
      // .unhinged.audio.v1.VoiceStyle style = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_style(static_cast<::unhinged::audio::v1::VoiceStyle>(val));
        } else
          goto handle_unusual;
        continue;
      // bool premium_only = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.premium_only_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .unhinged.common.v1.PaginationRequest pagination = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_pagination(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .unhinged.common.v1.Filter filters = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_filters(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ListVoicesRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unhinged.audio.v1.ListVoicesRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string language = 1;
  if (!this->_internal_language().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_language().data(), static_cast<int>(this->_internal_language().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "unhinged.audio.v1.ListVoicesRequest.language");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_language(), target);
  }

  // .unhinged.audio.v1.VoiceGender gender = 2;
  if (this->_internal_gender() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_gender(), target);
  }

  // .unhinged.audio.v1.VoiceStyle style = 3;
  if (this->_internal_style() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_style(), target);
  }

  // bool premium_only = 4;
  if (this->_internal_premium_only() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_premium_only(), target);
  }

  // .unhinged.common.v1.PaginationRequest pagination = 5;
  if (this->_internal_has_pagination()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::pagination(this),
        _Internal::pagination(this).GetCachedSize(), target, stream);
  }

  // repeated .unhinged.common.v1.Filter filters = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_filters_size()); i < n; i++) {
    const auto& repfield = this->_internal_filters(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unhinged.audio.v1.ListVoicesRequest)
  return target;
}

size_t ListVoicesRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unhinged.audio.v1.ListVoicesRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .unhinged.common.v1.Filter filters = 6;
  total_size += 1UL * this->_internal_filters_size();
  for (const auto& msg : this->_impl_.filters_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string language = 1;
  if (!this->_internal_language().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_language());
  }

  // .unhinged.common.v1.PaginationRequest pagination = 5;
  if (this->_internal_has_pagination()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.pagination_);
  }

  // .unhinged.audio.v1.VoiceGender gender = 2;
  if (this->_internal_gender() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_gender());
  }

  // .unhinged.audio.v1.VoiceStyle style = 3;
  if (this->_internal_style() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_style());
  }

  // bool premium_only = 4;
  if (this->_internal_premium_only() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ListVoicesRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ListVoicesRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ListVoicesRequest::GetClassData() const { return &_class_data_; }


void ListVoicesRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ListVoicesRequest*>(&to_msg);
  auto& from = static_cast<const ListVoicesRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unhinged.audio.v1.ListVoicesRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.filters_.MergeFrom(from._impl_.filters_);
  if (!from._internal_language().empty()) {
    _this->_internal_set_language(from._internal_language());
  }
  if (from._internal_has_pagination()) {
    _this->_internal_mutable_pagination()->::unhinged::common::v1::PaginationRequest::MergeFrom(
        from._internal_pagination());
  }
  if (from._internal_gender() != 0) {
    _this->_internal_set_gender(from._internal_gender());
  }
  if (from._internal_style() != 0) {
    _this->_internal_set_style(from._internal_style());
  }
  if (from._internal_premium_only() != 0) {
    _this->_internal_set_premium_only(from._internal_premium_only());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ListVoicesRequest::CopyFrom(const ListVoicesRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unhinged.audio.v1.ListVoicesRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListVoicesRequest::IsInitialized() const {
  return true;
}

void ListVoicesRequest::InternalSwap(ListVoicesRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.filters_.InternalSwap(&other->_impl_.filters_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.language_, lhs_arena,
      &other->_impl_.language_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ListVoicesRequest, _impl_.premium_only_)
      + sizeof(ListVoicesRequest::_impl_.premium_only_)
      - PROTOBUF_FIELD_OFFSET(ListVoicesRequest, _impl_.pagination_)>(
          reinterpret_cast<char*>(&_impl_.pagination_),
          reinterpret_cast<char*>(&other->_impl_.pagination_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ListVoicesRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_2eproto_getter, &descriptor_table_audio_2eproto_once,
      file_level_metadata_audio_2eproto[14]);
}

// ===================================================================

class ListVoicesResponse::_Internal {
 public:
  static const ::unhinged::common::v1::StandardResponse& response(const ListVoicesResponse* msg);
  static const ::unhinged::common::v1::PaginationResponse& pagination(const ListVoicesResponse* msg);
};

const ::unhinged::common::v1::StandardResponse&
ListVoicesResponse::_Internal::response(const ListVoicesResponse* msg) {
  return *msg->_impl_.response_;
}
const ::unhinged::common::v1::PaginationResponse&
ListVoicesResponse::_Internal::pagination(const ListVoicesResponse* msg) {
  return *msg->_impl_.pagination_;
}
void ListVoicesResponse::clear_response() {
  if (GetArenaForAllocation() == nullptr && _impl_.response_ != nullptr) {
    delete _impl_.response_;
  }
  _impl_.response_ = nullptr;
}
void ListVoicesResponse::clear_pagination() {
  if (GetArenaForAllocation() == nullptr && _impl_.pagination_ != nullptr) {
    delete _impl_.pagination_;
  }
  _impl_.pagination_ = nullptr;
}
ListVoicesResponse::ListVoicesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unhinged.audio.v1.ListVoicesResponse)
}
ListVoicesResponse::ListVoicesResponse(const ListVoicesResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ListVoicesResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.voices_){from._impl_.voices_}
    , decltype(_impl_.response_){nullptr}
    , decltype(_impl_.pagination_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_response()) {
    _this->_impl_.response_ = new ::unhinged::common::v1::StandardResponse(*from._impl_.response_);
  }
  if (from._internal_has_pagination()) {
    _this->_impl_.pagination_ = new ::unhinged::common::v1::PaginationResponse(*from._impl_.pagination_);
  }
  // @@protoc_insertion_point(copy_constructor:unhinged.audio.v1.ListVoicesResponse)
}

inline void ListVoicesResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.voices_){arena}
    , decltype(_impl_.response_){nullptr}
    , decltype(_impl_.pagination_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ListVoicesResponse::~ListVoicesResponse() {
  // @@protoc_insertion_point(destructor:unhinged.audio.v1.ListVoicesResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ListVoicesResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.voices_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.response_;
  if (this != internal_default_instance()) delete _impl_.pagination_;
}

void ListVoicesResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ListVoicesResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:unhinged.audio.v1.ListVoicesResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.voices_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.response_ != nullptr) {
    delete _impl_.response_;
  }
  _impl_.response_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.pagination_ != nullptr) {
    delete _impl_.pagination_;
  }
  _impl_.pagination_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ListVoicesResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .unhinged.common.v1.StandardResponse response = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .unhinged.audio.v1.Voice voices = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_voices(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .unhinged.common.v1.PaginationResponse pagination = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_pagination(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ListVoicesResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unhinged.audio.v1.ListVoicesResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .unhinged.common.v1.StandardResponse response = 1;
  if (this->_internal_has_response()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::response(this),
        _Internal::response(this).GetCachedSize(), target, stream);
  }

  // repeated .unhinged.audio.v1.Voice voices = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_voices_size()); i < n; i++) {
    const auto& repfield = this->_internal_voices(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .unhinged.common.v1.PaginationResponse pagination = 3;
  if (this->_internal_has_pagination()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::pagination(this),
        _Internal::pagination(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unhinged.audio.v1.ListVoicesResponse)
  return target;
}

size_t ListVoicesResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unhinged.audio.v1.ListVoicesResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .unhinged.audio.v1.Voice voices = 2;
  total_size += 1UL * this->_internal_voices_size();
  for (const auto& msg : this->_impl_.voices_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .unhinged.common.v1.StandardResponse response = 1;
  if (this->_internal_has_response()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.response_);
  }

  // .unhinged.common.v1.PaginationResponse pagination = 3;
  if (this->_internal_has_pagination()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.pagination_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ListVoicesResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ListVoicesResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ListVoicesResponse::GetClassData() const { return &_class_data_; }


void ListVoicesResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ListVoicesResponse*>(&to_msg);
  auto& from = static_cast<const ListVoicesResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unhinged.audio.v1.ListVoicesResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.voices_.MergeFrom(from._impl_.voices_);
  if (from._internal_has_response()) {
    _this->_internal_mutable_response()->::unhinged::common::v1::StandardResponse::MergeFrom(
        from._internal_response());
  }
  if (from._internal_has_pagination()) {
    _this->_internal_mutable_pagination()->::unhinged::common::v1::PaginationResponse::MergeFrom(
        from._internal_pagination());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ListVoicesResponse::CopyFrom(const ListVoicesResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unhinged.audio.v1.ListVoicesResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListVoicesResponse::IsInitialized() const {
  return true;
}

void ListVoicesResponse::InternalSwap(ListVoicesResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.voices_.InternalSwap(&other->_impl_.voices_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ListVoicesResponse, _impl_.pagination_)
      + sizeof(ListVoicesResponse::_impl_.pagination_)
      - PROTOBUF_FIELD_OFFSET(ListVoicesResponse, _impl_.response_)>(
          reinterpret_cast<char*>(&_impl_.response_),
          reinterpret_cast<char*>(&other->_impl_.response_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ListVoicesResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_2eproto_getter, &descriptor_table_audio_2eproto_once,
      file_level_metadata_audio_2eproto[15]);
}

// ===================================================================

class GetVoiceRequest::_Internal {
 public:
};

GetVoiceRequest::GetVoiceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unhinged.audio.v1.GetVoiceRequest)
}
GetVoiceRequest::GetVoiceRequest(const GetVoiceRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GetVoiceRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.voice_id_){}
    , decltype(_impl_.include_preview_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.voice_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.voice_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_voice_id().empty()) {
    _this->_impl_.voice_id_.Set(from._internal_voice_id(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.include_preview_ = from._impl_.include_preview_;
  // @@protoc_insertion_point(copy_constructor:unhinged.audio.v1.GetVoiceRequest)
}

inline void GetVoiceRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.voice_id_){}
    , decltype(_impl_.include_preview_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.voice_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.voice_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GetVoiceRequest::~GetVoiceRequest() {
  // @@protoc_insertion_point(destructor:unhinged.audio.v1.GetVoiceRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetVoiceRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.voice_id_.Destroy();
}

void GetVoiceRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GetVoiceRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:unhinged.audio.v1.GetVoiceRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.voice_id_.ClearToEmpty();
  _impl_.include_preview_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetVoiceRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string voice_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_voice_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "unhinged.audio.v1.GetVoiceRequest.voice_id"));
        } else
          goto handle_unusual;
        continue;
      // bool include_preview = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.include_preview_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetVoiceRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unhinged.audio.v1.GetVoiceRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string voice_id = 1;
  if (!this->_internal_voice_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_voice_id().data(), static_cast<int>(this->_internal_voice_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "unhinged.audio.v1.GetVoiceRequest.voice_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_voice_id(), target);
  }

  // bool include_preview = 2;
  if (this->_internal_include_preview() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_include_preview(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unhinged.audio.v1.GetVoiceRequest)
  return target;
}

size_t GetVoiceRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unhinged.audio.v1.GetVoiceRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string voice_id = 1;
  if (!this->_internal_voice_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_voice_id());
  }

  // bool include_preview = 2;
  if (this->_internal_include_preview() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetVoiceRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GetVoiceRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetVoiceRequest::GetClassData() const { return &_class_data_; }


void GetVoiceRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GetVoiceRequest*>(&to_msg);
  auto& from = static_cast<const GetVoiceRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unhinged.audio.v1.GetVoiceRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_voice_id().empty()) {
    _this->_internal_set_voice_id(from._internal_voice_id());
  }
  if (from._internal_include_preview() != 0) {
    _this->_internal_set_include_preview(from._internal_include_preview());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetVoiceRequest::CopyFrom(const GetVoiceRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unhinged.audio.v1.GetVoiceRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetVoiceRequest::IsInitialized() const {
  return true;
}

void GetVoiceRequest::InternalSwap(GetVoiceRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.voice_id_, lhs_arena,
      &other->_impl_.voice_id_, rhs_arena
  );
  swap(_impl_.include_preview_, other->_impl_.include_preview_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GetVoiceRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_2eproto_getter, &descriptor_table_audio_2eproto_once,
      file_level_metadata_audio_2eproto[16]);
}

// ===================================================================

class GetVoiceResponse::_Internal {
 public:
  static const ::unhinged::common::v1::StandardResponse& response(const GetVoiceResponse* msg);
  static const ::unhinged::audio::v1::Voice& voice(const GetVoiceResponse* msg);
};

const ::unhinged::common::v1::StandardResponse&
GetVoiceResponse::_Internal::response(const GetVoiceResponse* msg) {
  return *msg->_impl_.response_;
}
const ::unhinged::audio::v1::Voice&
GetVoiceResponse::_Internal::voice(const GetVoiceResponse* msg) {
  return *msg->_impl_.voice_;
}
void GetVoiceResponse::clear_response() {
  if (GetArenaForAllocation() == nullptr && _impl_.response_ != nullptr) {
    delete _impl_.response_;
  }
  _impl_.response_ = nullptr;
}
GetVoiceResponse::GetVoiceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unhinged.audio.v1.GetVoiceResponse)
}
GetVoiceResponse::GetVoiceResponse(const GetVoiceResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GetVoiceResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.response_){nullptr}
    , decltype(_impl_.voice_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_response()) {
    _this->_impl_.response_ = new ::unhinged::common::v1::StandardResponse(*from._impl_.response_);
  }
  if (from._internal_has_voice()) {
    _this->_impl_.voice_ = new ::unhinged::audio::v1::Voice(*from._impl_.voice_);
  }
  // @@protoc_insertion_point(copy_constructor:unhinged.audio.v1.GetVoiceResponse)
}

inline void GetVoiceResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.response_){nullptr}
    , decltype(_impl_.voice_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

GetVoiceResponse::~GetVoiceResponse() {
  // @@protoc_insertion_point(destructor:unhinged.audio.v1.GetVoiceResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetVoiceResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.response_;
  if (this != internal_default_instance()) delete _impl_.voice_;
}

void GetVoiceResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GetVoiceResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:unhinged.audio.v1.GetVoiceResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.response_ != nullptr) {
    delete _impl_.response_;
  }
  _impl_.response_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.voice_ != nullptr) {
    delete _impl_.voice_;
  }
  _impl_.voice_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetVoiceResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .unhinged.common.v1.StandardResponse response = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .unhinged.audio.v1.Voice voice = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_voice(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetVoiceResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unhinged.audio.v1.GetVoiceResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .unhinged.common.v1.StandardResponse response = 1;
  if (this->_internal_has_response()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::response(this),
        _Internal::response(this).GetCachedSize(), target, stream);
  }

  // .unhinged.audio.v1.Voice voice = 2;
  if (this->_internal_has_voice()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::voice(this),
        _Internal::voice(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unhinged.audio.v1.GetVoiceResponse)
  return target;
}

size_t GetVoiceResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unhinged.audio.v1.GetVoiceResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .unhinged.common.v1.StandardResponse response = 1;
  if (this->_internal_has_response()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.response_);
  }

  // .unhinged.audio.v1.Voice voice = 2;
  if (this->_internal_has_voice()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.voice_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetVoiceResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GetVoiceResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetVoiceResponse::GetClassData() const { return &_class_data_; }


void GetVoiceResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GetVoiceResponse*>(&to_msg);
  auto& from = static_cast<const GetVoiceResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unhinged.audio.v1.GetVoiceResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_response()) {
    _this->_internal_mutable_response()->::unhinged::common::v1::StandardResponse::MergeFrom(
        from._internal_response());
  }
  if (from._internal_has_voice()) {
    _this->_internal_mutable_voice()->::unhinged::audio::v1::Voice::MergeFrom(
        from._internal_voice());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetVoiceResponse::CopyFrom(const GetVoiceResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unhinged.audio.v1.GetVoiceResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetVoiceResponse::IsInitialized() const {
  return true;
}

void GetVoiceResponse::InternalSwap(GetVoiceResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GetVoiceResponse, _impl_.voice_)
      + sizeof(GetVoiceResponse::_impl_.voice_)
      - PROTOBUF_FIELD_OFFSET(GetVoiceResponse, _impl_.response_)>(
          reinterpret_cast<char*>(&_impl_.response_),
          reinterpret_cast<char*>(&other->_impl_.response_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GetVoiceResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_2eproto_getter, &descriptor_table_audio_2eproto_once,
      file_level_metadata_audio_2eproto[17]);
}

// ===================================================================

class CreateCustomVoiceRequest::_Internal {
 public:
};

void CreateCustomVoiceRequest::clear_training_samples() {
  _impl_.training_samples_.Clear();
}
CreateCustomVoiceRequest::CreateCustomVoiceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unhinged.audio.v1.CreateCustomVoiceRequest)
}
CreateCustomVoiceRequest::CreateCustomVoiceRequest(const CreateCustomVoiceRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CreateCustomVoiceRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.training_samples_){from._impl_.training_samples_}
    , decltype(_impl_.name_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.target_gender_){}
    , decltype(_impl_.target_style_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_description().empty()) {
    _this->_impl_.description_.Set(from._internal_description(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.target_gender_, &from._impl_.target_gender_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.target_style_) -
    reinterpret_cast<char*>(&_impl_.target_gender_)) + sizeof(_impl_.target_style_));
  // @@protoc_insertion_point(copy_constructor:unhinged.audio.v1.CreateCustomVoiceRequest)
}

inline void CreateCustomVoiceRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.training_samples_){arena}
    , decltype(_impl_.name_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.target_gender_){0}
    , decltype(_impl_.target_style_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CreateCustomVoiceRequest::~CreateCustomVoiceRequest() {
  // @@protoc_insertion_point(destructor:unhinged.audio.v1.CreateCustomVoiceRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CreateCustomVoiceRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.training_samples_.~RepeatedPtrField();
  _impl_.name_.Destroy();
  _impl_.description_.Destroy();
}

void CreateCustomVoiceRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CreateCustomVoiceRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:unhinged.audio.v1.CreateCustomVoiceRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.training_samples_.Clear();
  _impl_.name_.ClearToEmpty();
  _impl_.description_.ClearToEmpty();
  ::memset(&_impl_.target_gender_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.target_style_) -
      reinterpret_cast<char*>(&_impl_.target_gender_)) + sizeof(_impl_.target_style_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CreateCustomVoiceRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "unhinged.audio.v1.CreateCustomVoiceRequest.name"));
        } else
          goto handle_unusual;
        continue;
      // string description = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "unhinged.audio.v1.CreateCustomVoiceRequest.description"));
        } else
          goto handle_unusual;
        continue;
      // repeated .unhinged.common.v1.Attachment training_samples = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_training_samples(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .unhinged.audio.v1.VoiceGender target_gender = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_target_gender(static_cast<::unhinged::audio::v1::VoiceGender>(val));
        } else
          goto handle_unusual;
        continue;
      // .unhinged.audio.v1.VoiceStyle target_style = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_target_style(static_cast<::unhinged::audio::v1::VoiceStyle>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CreateCustomVoiceRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unhinged.audio.v1.CreateCustomVoiceRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "unhinged.audio.v1.CreateCustomVoiceRequest.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // string description = 2;
  if (!this->_internal_description().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_description().data(), static_cast<int>(this->_internal_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "unhinged.audio.v1.CreateCustomVoiceRequest.description");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_description(), target);
  }

  // repeated .unhinged.common.v1.Attachment training_samples = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_training_samples_size()); i < n; i++) {
    const auto& repfield = this->_internal_training_samples(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .unhinged.audio.v1.VoiceGender target_gender = 4;
  if (this->_internal_target_gender() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_target_gender(), target);
  }

  // .unhinged.audio.v1.VoiceStyle target_style = 5;
  if (this->_internal_target_style() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_target_style(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unhinged.audio.v1.CreateCustomVoiceRequest)
  return target;
}

size_t CreateCustomVoiceRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unhinged.audio.v1.CreateCustomVoiceRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .unhinged.common.v1.Attachment training_samples = 3;
  total_size += 1UL * this->_internal_training_samples_size();
  for (const auto& msg : this->_impl_.training_samples_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string description = 2;
  if (!this->_internal_description().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_description());
  }

  // .unhinged.audio.v1.VoiceGender target_gender = 4;
  if (this->_internal_target_gender() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_target_gender());
  }

  // .unhinged.audio.v1.VoiceStyle target_style = 5;
  if (this->_internal_target_style() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_target_style());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CreateCustomVoiceRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CreateCustomVoiceRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CreateCustomVoiceRequest::GetClassData() const { return &_class_data_; }


void CreateCustomVoiceRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CreateCustomVoiceRequest*>(&to_msg);
  auto& from = static_cast<const CreateCustomVoiceRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unhinged.audio.v1.CreateCustomVoiceRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.training_samples_.MergeFrom(from._impl_.training_samples_);
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_description().empty()) {
    _this->_internal_set_description(from._internal_description());
  }
  if (from._internal_target_gender() != 0) {
    _this->_internal_set_target_gender(from._internal_target_gender());
  }
  if (from._internal_target_style() != 0) {
    _this->_internal_set_target_style(from._internal_target_style());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CreateCustomVoiceRequest::CopyFrom(const CreateCustomVoiceRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unhinged.audio.v1.CreateCustomVoiceRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateCustomVoiceRequest::IsInitialized() const {
  return true;
}

void CreateCustomVoiceRequest::InternalSwap(CreateCustomVoiceRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.training_samples_.InternalSwap(&other->_impl_.training_samples_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.description_, lhs_arena,
      &other->_impl_.description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CreateCustomVoiceRequest, _impl_.target_style_)
      + sizeof(CreateCustomVoiceRequest::_impl_.target_style_)
      - PROTOBUF_FIELD_OFFSET(CreateCustomVoiceRequest, _impl_.target_gender_)>(
          reinterpret_cast<char*>(&_impl_.target_gender_),
          reinterpret_cast<char*>(&other->_impl_.target_gender_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CreateCustomVoiceRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_2eproto_getter, &descriptor_table_audio_2eproto_once,
      file_level_metadata_audio_2eproto[18]);
}

// ===================================================================

class CreateCustomVoiceResponse::_Internal {
 public:
  static const ::unhinged::common::v1::StandardResponse& response(const CreateCustomVoiceResponse* msg);
  static const ::unhinged::audio::v1::Voice& voice(const CreateCustomVoiceResponse* msg);
};

const ::unhinged::common::v1::StandardResponse&
CreateCustomVoiceResponse::_Internal::response(const CreateCustomVoiceResponse* msg) {
  return *msg->_impl_.response_;
}
const ::unhinged::audio::v1::Voice&
CreateCustomVoiceResponse::_Internal::voice(const CreateCustomVoiceResponse* msg) {
  return *msg->_impl_.voice_;
}
void CreateCustomVoiceResponse::clear_response() {
  if (GetArenaForAllocation() == nullptr && _impl_.response_ != nullptr) {
    delete _impl_.response_;
  }
  _impl_.response_ = nullptr;
}
CreateCustomVoiceResponse::CreateCustomVoiceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unhinged.audio.v1.CreateCustomVoiceResponse)
}
CreateCustomVoiceResponse::CreateCustomVoiceResponse(const CreateCustomVoiceResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CreateCustomVoiceResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.training_job_id_){}
    , decltype(_impl_.response_){nullptr}
    , decltype(_impl_.voice_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.training_job_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.training_job_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_training_job_id().empty()) {
    _this->_impl_.training_job_id_.Set(from._internal_training_job_id(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_response()) {
    _this->_impl_.response_ = new ::unhinged::common::v1::StandardResponse(*from._impl_.response_);
  }
  if (from._internal_has_voice()) {
    _this->_impl_.voice_ = new ::unhinged::audio::v1::Voice(*from._impl_.voice_);
  }
  // @@protoc_insertion_point(copy_constructor:unhinged.audio.v1.CreateCustomVoiceResponse)
}

inline void CreateCustomVoiceResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.training_job_id_){}
    , decltype(_impl_.response_){nullptr}
    , decltype(_impl_.voice_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.training_job_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.training_job_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CreateCustomVoiceResponse::~CreateCustomVoiceResponse() {
  // @@protoc_insertion_point(destructor:unhinged.audio.v1.CreateCustomVoiceResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CreateCustomVoiceResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.training_job_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.response_;
  if (this != internal_default_instance()) delete _impl_.voice_;
}

void CreateCustomVoiceResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CreateCustomVoiceResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:unhinged.audio.v1.CreateCustomVoiceResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.training_job_id_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.response_ != nullptr) {
    delete _impl_.response_;
  }
  _impl_.response_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.voice_ != nullptr) {
    delete _impl_.voice_;
  }
  _impl_.voice_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CreateCustomVoiceResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .unhinged.common.v1.StandardResponse response = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .unhinged.audio.v1.Voice voice = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_voice(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string training_job_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_training_job_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "unhinged.audio.v1.CreateCustomVoiceResponse.training_job_id"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CreateCustomVoiceResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unhinged.audio.v1.CreateCustomVoiceResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .unhinged.common.v1.StandardResponse response = 1;
  if (this->_internal_has_response()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::response(this),
        _Internal::response(this).GetCachedSize(), target, stream);
  }

  // .unhinged.audio.v1.Voice voice = 2;
  if (this->_internal_has_voice()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::voice(this),
        _Internal::voice(this).GetCachedSize(), target, stream);
  }

  // string training_job_id = 3;
  if (!this->_internal_training_job_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_training_job_id().data(), static_cast<int>(this->_internal_training_job_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "unhinged.audio.v1.CreateCustomVoiceResponse.training_job_id");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_training_job_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unhinged.audio.v1.CreateCustomVoiceResponse)
  return target;
}

size_t CreateCustomVoiceResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unhinged.audio.v1.CreateCustomVoiceResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string training_job_id = 3;
  if (!this->_internal_training_job_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_training_job_id());
  }

  // .unhinged.common.v1.StandardResponse response = 1;
  if (this->_internal_has_response()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.response_);
  }

  // .unhinged.audio.v1.Voice voice = 2;
  if (this->_internal_has_voice()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.voice_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CreateCustomVoiceResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CreateCustomVoiceResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CreateCustomVoiceResponse::GetClassData() const { return &_class_data_; }


void CreateCustomVoiceResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CreateCustomVoiceResponse*>(&to_msg);
  auto& from = static_cast<const CreateCustomVoiceResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unhinged.audio.v1.CreateCustomVoiceResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_training_job_id().empty()) {
    _this->_internal_set_training_job_id(from._internal_training_job_id());
  }
  if (from._internal_has_response()) {
    _this->_internal_mutable_response()->::unhinged::common::v1::StandardResponse::MergeFrom(
        from._internal_response());
  }
  if (from._internal_has_voice()) {
    _this->_internal_mutable_voice()->::unhinged::audio::v1::Voice::MergeFrom(
        from._internal_voice());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CreateCustomVoiceResponse::CopyFrom(const CreateCustomVoiceResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unhinged.audio.v1.CreateCustomVoiceResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateCustomVoiceResponse::IsInitialized() const {
  return true;
}

void CreateCustomVoiceResponse::InternalSwap(CreateCustomVoiceResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.training_job_id_, lhs_arena,
      &other->_impl_.training_job_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CreateCustomVoiceResponse, _impl_.voice_)
      + sizeof(CreateCustomVoiceResponse::_impl_.voice_)
      - PROTOBUF_FIELD_OFFSET(CreateCustomVoiceResponse, _impl_.response_)>(
          reinterpret_cast<char*>(&_impl_.response_),
          reinterpret_cast<char*>(&other->_impl_.response_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CreateCustomVoiceResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_2eproto_getter, &descriptor_table_audio_2eproto_once,
      file_level_metadata_audio_2eproto[19]);
}

// ===================================================================

class ConvertAudioRequest::_Internal {
 public:
  static const ::unhinged::common::v1::Attachment& input_audio(const ConvertAudioRequest* msg);
  static const ::unhinged::audio::v1::AudioOptions& options(const ConvertAudioRequest* msg);
};

const ::unhinged::common::v1::Attachment&
ConvertAudioRequest::_Internal::input_audio(const ConvertAudioRequest* msg) {
  return *msg->_impl_.input_audio_;
}
const ::unhinged::audio::v1::AudioOptions&
ConvertAudioRequest::_Internal::options(const ConvertAudioRequest* msg) {
  return *msg->_impl_.options_;
}
void ConvertAudioRequest::clear_input_audio() {
  if (GetArenaForAllocation() == nullptr && _impl_.input_audio_ != nullptr) {
    delete _impl_.input_audio_;
  }
  _impl_.input_audio_ = nullptr;
}
ConvertAudioRequest::ConvertAudioRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unhinged.audio.v1.ConvertAudioRequest)
}
ConvertAudioRequest::ConvertAudioRequest(const ConvertAudioRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ConvertAudioRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.input_audio_){nullptr}
    , decltype(_impl_.options_){nullptr}
    , decltype(_impl_.target_format_){}
    , decltype(_impl_.target_sample_rate_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_input_audio()) {
    _this->_impl_.input_audio_ = new ::unhinged::common::v1::Attachment(*from._impl_.input_audio_);
  }
  if (from._internal_has_options()) {
    _this->_impl_.options_ = new ::unhinged::audio::v1::AudioOptions(*from._impl_.options_);
  }
  ::memcpy(&_impl_.target_format_, &from._impl_.target_format_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.target_sample_rate_) -
    reinterpret_cast<char*>(&_impl_.target_format_)) + sizeof(_impl_.target_sample_rate_));
  // @@protoc_insertion_point(copy_constructor:unhinged.audio.v1.ConvertAudioRequest)
}

inline void ConvertAudioRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.input_audio_){nullptr}
    , decltype(_impl_.options_){nullptr}
    , decltype(_impl_.target_format_){0}
    , decltype(_impl_.target_sample_rate_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ConvertAudioRequest::~ConvertAudioRequest() {
  // @@protoc_insertion_point(destructor:unhinged.audio.v1.ConvertAudioRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConvertAudioRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.input_audio_;
  if (this != internal_default_instance()) delete _impl_.options_;
}

void ConvertAudioRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ConvertAudioRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:unhinged.audio.v1.ConvertAudioRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.input_audio_ != nullptr) {
    delete _impl_.input_audio_;
  }
  _impl_.input_audio_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.options_ != nullptr) {
    delete _impl_.options_;
  }
  _impl_.options_ = nullptr;
  ::memset(&_impl_.target_format_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.target_sample_rate_) -
      reinterpret_cast<char*>(&_impl_.target_format_)) + sizeof(_impl_.target_sample_rate_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ConvertAudioRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .unhinged.common.v1.Attachment input_audio = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_input_audio(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .unhinged.audio.v1.AudioFormat target_format = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_target_format(static_cast<::unhinged::audio::v1::AudioFormat>(val));
        } else
          goto handle_unusual;
        continue;
      // int32 target_sample_rate = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.target_sample_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .unhinged.audio.v1.AudioOptions options = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_options(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ConvertAudioRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unhinged.audio.v1.ConvertAudioRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .unhinged.common.v1.Attachment input_audio = 1;
  if (this->_internal_has_input_audio()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::input_audio(this),
        _Internal::input_audio(this).GetCachedSize(), target, stream);
  }

  // .unhinged.audio.v1.AudioFormat target_format = 2;
  if (this->_internal_target_format() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_target_format(), target);
  }

  // int32 target_sample_rate = 3;
  if (this->_internal_target_sample_rate() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_target_sample_rate(), target);
  }

  // .unhinged.audio.v1.AudioOptions options = 4;
  if (this->_internal_has_options()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::options(this),
        _Internal::options(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unhinged.audio.v1.ConvertAudioRequest)
  return target;
}

size_t ConvertAudioRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unhinged.audio.v1.ConvertAudioRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .unhinged.common.v1.Attachment input_audio = 1;
  if (this->_internal_has_input_audio()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.input_audio_);
  }

  // .unhinged.audio.v1.AudioOptions options = 4;
  if (this->_internal_has_options()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.options_);
  }

  // .unhinged.audio.v1.AudioFormat target_format = 2;
  if (this->_internal_target_format() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_target_format());
  }

  // int32 target_sample_rate = 3;
  if (this->_internal_target_sample_rate() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_target_sample_rate());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ConvertAudioRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ConvertAudioRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ConvertAudioRequest::GetClassData() const { return &_class_data_; }


void ConvertAudioRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ConvertAudioRequest*>(&to_msg);
  auto& from = static_cast<const ConvertAudioRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unhinged.audio.v1.ConvertAudioRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_input_audio()) {
    _this->_internal_mutable_input_audio()->::unhinged::common::v1::Attachment::MergeFrom(
        from._internal_input_audio());
  }
  if (from._internal_has_options()) {
    _this->_internal_mutable_options()->::unhinged::audio::v1::AudioOptions::MergeFrom(
        from._internal_options());
  }
  if (from._internal_target_format() != 0) {
    _this->_internal_set_target_format(from._internal_target_format());
  }
  if (from._internal_target_sample_rate() != 0) {
    _this->_internal_set_target_sample_rate(from._internal_target_sample_rate());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ConvertAudioRequest::CopyFrom(const ConvertAudioRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unhinged.audio.v1.ConvertAudioRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConvertAudioRequest::IsInitialized() const {
  return true;
}

void ConvertAudioRequest::InternalSwap(ConvertAudioRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConvertAudioRequest, _impl_.target_sample_rate_)
      + sizeof(ConvertAudioRequest::_impl_.target_sample_rate_)
      - PROTOBUF_FIELD_OFFSET(ConvertAudioRequest, _impl_.input_audio_)>(
          reinterpret_cast<char*>(&_impl_.input_audio_),
          reinterpret_cast<char*>(&other->_impl_.input_audio_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ConvertAudioRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_2eproto_getter, &descriptor_table_audio_2eproto_once,
      file_level_metadata_audio_2eproto[20]);
}

// ===================================================================

class ConvertAudioResponse::_Internal {
 public:
  static const ::unhinged::common::v1::StandardResponse& response(const ConvertAudioResponse* msg);
  static const ::unhinged::common::v1::Attachment& converted_audio(const ConvertAudioResponse* msg);
  static const ::unhinged::common::v1::AudioUsage& usage(const ConvertAudioResponse* msg);
};

const ::unhinged::common::v1::StandardResponse&
ConvertAudioResponse::_Internal::response(const ConvertAudioResponse* msg) {
  return *msg->_impl_.response_;
}
const ::unhinged::common::v1::Attachment&
ConvertAudioResponse::_Internal::converted_audio(const ConvertAudioResponse* msg) {
  return *msg->_impl_.converted_audio_;
}
const ::unhinged::common::v1::AudioUsage&
ConvertAudioResponse::_Internal::usage(const ConvertAudioResponse* msg) {
  return *msg->_impl_.usage_;
}
void ConvertAudioResponse::clear_response() {
  if (GetArenaForAllocation() == nullptr && _impl_.response_ != nullptr) {
    delete _impl_.response_;
  }
  _impl_.response_ = nullptr;
}
void ConvertAudioResponse::clear_converted_audio() {
  if (GetArenaForAllocation() == nullptr && _impl_.converted_audio_ != nullptr) {
    delete _impl_.converted_audio_;
  }
  _impl_.converted_audio_ = nullptr;
}
void ConvertAudioResponse::clear_usage() {
  if (GetArenaForAllocation() == nullptr && _impl_.usage_ != nullptr) {
    delete _impl_.usage_;
  }
  _impl_.usage_ = nullptr;
}
ConvertAudioResponse::ConvertAudioResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unhinged.audio.v1.ConvertAudioResponse)
}
ConvertAudioResponse::ConvertAudioResponse(const ConvertAudioResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ConvertAudioResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.response_){nullptr}
    , decltype(_impl_.converted_audio_){nullptr}
    , decltype(_impl_.usage_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_response()) {
    _this->_impl_.response_ = new ::unhinged::common::v1::StandardResponse(*from._impl_.response_);
  }
  if (from._internal_has_converted_audio()) {
    _this->_impl_.converted_audio_ = new ::unhinged::common::v1::Attachment(*from._impl_.converted_audio_);
  }
  if (from._internal_has_usage()) {
    _this->_impl_.usage_ = new ::unhinged::common::v1::AudioUsage(*from._impl_.usage_);
  }
  // @@protoc_insertion_point(copy_constructor:unhinged.audio.v1.ConvertAudioResponse)
}

inline void ConvertAudioResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.response_){nullptr}
    , decltype(_impl_.converted_audio_){nullptr}
    , decltype(_impl_.usage_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ConvertAudioResponse::~ConvertAudioResponse() {
  // @@protoc_insertion_point(destructor:unhinged.audio.v1.ConvertAudioResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConvertAudioResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.response_;
  if (this != internal_default_instance()) delete _impl_.converted_audio_;
  if (this != internal_default_instance()) delete _impl_.usage_;
}

void ConvertAudioResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ConvertAudioResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:unhinged.audio.v1.ConvertAudioResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.response_ != nullptr) {
    delete _impl_.response_;
  }
  _impl_.response_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.converted_audio_ != nullptr) {
    delete _impl_.converted_audio_;
  }
  _impl_.converted_audio_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.usage_ != nullptr) {
    delete _impl_.usage_;
  }
  _impl_.usage_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ConvertAudioResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .unhinged.common.v1.StandardResponse response = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .unhinged.common.v1.Attachment converted_audio = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_converted_audio(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .unhinged.common.v1.AudioUsage usage = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_usage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ConvertAudioResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unhinged.audio.v1.ConvertAudioResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .unhinged.common.v1.StandardResponse response = 1;
  if (this->_internal_has_response()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::response(this),
        _Internal::response(this).GetCachedSize(), target, stream);
  }

  // .unhinged.common.v1.Attachment converted_audio = 2;
  if (this->_internal_has_converted_audio()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::converted_audio(this),
        _Internal::converted_audio(this).GetCachedSize(), target, stream);
  }

  // .unhinged.common.v1.AudioUsage usage = 3;
  if (this->_internal_has_usage()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::usage(this),
        _Internal::usage(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unhinged.audio.v1.ConvertAudioResponse)
  return target;
}

size_t ConvertAudioResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unhinged.audio.v1.ConvertAudioResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .unhinged.common.v1.StandardResponse response = 1;
  if (this->_internal_has_response()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.response_);
  }

  // .unhinged.common.v1.Attachment converted_audio = 2;
  if (this->_internal_has_converted_audio()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.converted_audio_);
  }

  // .unhinged.common.v1.AudioUsage usage = 3;
  if (this->_internal_has_usage()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.usage_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ConvertAudioResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ConvertAudioResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ConvertAudioResponse::GetClassData() const { return &_class_data_; }


void ConvertAudioResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ConvertAudioResponse*>(&to_msg);
  auto& from = static_cast<const ConvertAudioResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unhinged.audio.v1.ConvertAudioResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_response()) {
    _this->_internal_mutable_response()->::unhinged::common::v1::StandardResponse::MergeFrom(
        from._internal_response());
  }
  if (from._internal_has_converted_audio()) {
    _this->_internal_mutable_converted_audio()->::unhinged::common::v1::Attachment::MergeFrom(
        from._internal_converted_audio());
  }
  if (from._internal_has_usage()) {
    _this->_internal_mutable_usage()->::unhinged::common::v1::AudioUsage::MergeFrom(
        from._internal_usage());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ConvertAudioResponse::CopyFrom(const ConvertAudioResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unhinged.audio.v1.ConvertAudioResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConvertAudioResponse::IsInitialized() const {
  return true;
}

void ConvertAudioResponse::InternalSwap(ConvertAudioResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConvertAudioResponse, _impl_.usage_)
      + sizeof(ConvertAudioResponse::_impl_.usage_)
      - PROTOBUF_FIELD_OFFSET(ConvertAudioResponse, _impl_.response_)>(
          reinterpret_cast<char*>(&_impl_.response_),
          reinterpret_cast<char*>(&other->_impl_.response_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ConvertAudioResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_2eproto_getter, &descriptor_table_audio_2eproto_once,
      file_level_metadata_audio_2eproto[21]);
}

// ===================================================================

class AnalyzeAudioRequest::_Internal {
 public:
  static const ::unhinged::common::v1::Attachment& audio_file(const AnalyzeAudioRequest* msg);
};

const ::unhinged::common::v1::Attachment&
AnalyzeAudioRequest::_Internal::audio_file(const AnalyzeAudioRequest* msg) {
  return *msg->_impl_.audio_file_;
}
void AnalyzeAudioRequest::clear_audio_file() {
  if (GetArenaForAllocation() == nullptr && _impl_.audio_file_ != nullptr) {
    delete _impl_.audio_file_;
  }
  _impl_.audio_file_ = nullptr;
}
AnalyzeAudioRequest::AnalyzeAudioRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unhinged.audio.v1.AnalyzeAudioRequest)
}
AnalyzeAudioRequest::AnalyzeAudioRequest(const AnalyzeAudioRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AnalyzeAudioRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.analysis_types_){from._impl_.analysis_types_}
    , /*decltype(_impl_._analysis_types_cached_byte_size_)*/{0}
    , decltype(_impl_.audio_file_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_audio_file()) {
    _this->_impl_.audio_file_ = new ::unhinged::common::v1::Attachment(*from._impl_.audio_file_);
  }
  // @@protoc_insertion_point(copy_constructor:unhinged.audio.v1.AnalyzeAudioRequest)
}

inline void AnalyzeAudioRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.analysis_types_){arena}
    , /*decltype(_impl_._analysis_types_cached_byte_size_)*/{0}
    , decltype(_impl_.audio_file_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

AnalyzeAudioRequest::~AnalyzeAudioRequest() {
  // @@protoc_insertion_point(destructor:unhinged.audio.v1.AnalyzeAudioRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AnalyzeAudioRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.analysis_types_.~RepeatedField();
  if (this != internal_default_instance()) delete _impl_.audio_file_;
}

void AnalyzeAudioRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AnalyzeAudioRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:unhinged.audio.v1.AnalyzeAudioRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.analysis_types_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.audio_file_ != nullptr) {
    delete _impl_.audio_file_;
  }
  _impl_.audio_file_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AnalyzeAudioRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .unhinged.common.v1.Attachment audio_file = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_audio_file(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .unhinged.audio.v1.AnalysisType analysis_types = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser(_internal_mutable_analysis_types(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 16) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_add_analysis_types(static_cast<::unhinged::audio::v1::AnalysisType>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AnalyzeAudioRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unhinged.audio.v1.AnalyzeAudioRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .unhinged.common.v1.Attachment audio_file = 1;
  if (this->_internal_has_audio_file()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::audio_file(this),
        _Internal::audio_file(this).GetCachedSize(), target, stream);
  }

  // repeated .unhinged.audio.v1.AnalysisType analysis_types = 2;
  {
    int byte_size = _impl_._analysis_types_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteEnumPacked(
          2, _impl_.analysis_types_, byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unhinged.audio.v1.AnalyzeAudioRequest)
  return target;
}

size_t AnalyzeAudioRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unhinged.audio.v1.AnalyzeAudioRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .unhinged.audio.v1.AnalysisType analysis_types = 2;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_analysis_types_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
        this->_internal_analysis_types(static_cast<int>(i)));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._analysis_types_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // .unhinged.common.v1.Attachment audio_file = 1;
  if (this->_internal_has_audio_file()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.audio_file_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AnalyzeAudioRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AnalyzeAudioRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AnalyzeAudioRequest::GetClassData() const { return &_class_data_; }


void AnalyzeAudioRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AnalyzeAudioRequest*>(&to_msg);
  auto& from = static_cast<const AnalyzeAudioRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unhinged.audio.v1.AnalyzeAudioRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.analysis_types_.MergeFrom(from._impl_.analysis_types_);
  if (from._internal_has_audio_file()) {
    _this->_internal_mutable_audio_file()->::unhinged::common::v1::Attachment::MergeFrom(
        from._internal_audio_file());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AnalyzeAudioRequest::CopyFrom(const AnalyzeAudioRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unhinged.audio.v1.AnalyzeAudioRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AnalyzeAudioRequest::IsInitialized() const {
  return true;
}

void AnalyzeAudioRequest::InternalSwap(AnalyzeAudioRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.analysis_types_.InternalSwap(&other->_impl_.analysis_types_);
  swap(_impl_.audio_file_, other->_impl_.audio_file_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AnalyzeAudioRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_2eproto_getter, &descriptor_table_audio_2eproto_once,
      file_level_metadata_audio_2eproto[22]);
}

// ===================================================================

class AnalyzeAudioResponse::_Internal {
 public:
  static const ::unhinged::common::v1::StandardResponse& response(const AnalyzeAudioResponse* msg);
  static const ::unhinged::audio::v1::AudioAnalysis& analysis(const AnalyzeAudioResponse* msg);
  static const ::unhinged::common::v1::AudioUsage& usage(const AnalyzeAudioResponse* msg);
};

const ::unhinged::common::v1::StandardResponse&
AnalyzeAudioResponse::_Internal::response(const AnalyzeAudioResponse* msg) {
  return *msg->_impl_.response_;
}
const ::unhinged::audio::v1::AudioAnalysis&
AnalyzeAudioResponse::_Internal::analysis(const AnalyzeAudioResponse* msg) {
  return *msg->_impl_.analysis_;
}
const ::unhinged::common::v1::AudioUsage&
AnalyzeAudioResponse::_Internal::usage(const AnalyzeAudioResponse* msg) {
  return *msg->_impl_.usage_;
}
void AnalyzeAudioResponse::clear_response() {
  if (GetArenaForAllocation() == nullptr && _impl_.response_ != nullptr) {
    delete _impl_.response_;
  }
  _impl_.response_ = nullptr;
}
void AnalyzeAudioResponse::clear_usage() {
  if (GetArenaForAllocation() == nullptr && _impl_.usage_ != nullptr) {
    delete _impl_.usage_;
  }
  _impl_.usage_ = nullptr;
}
AnalyzeAudioResponse::AnalyzeAudioResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unhinged.audio.v1.AnalyzeAudioResponse)
}
AnalyzeAudioResponse::AnalyzeAudioResponse(const AnalyzeAudioResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AnalyzeAudioResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.response_){nullptr}
    , decltype(_impl_.analysis_){nullptr}
    , decltype(_impl_.usage_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_response()) {
    _this->_impl_.response_ = new ::unhinged::common::v1::StandardResponse(*from._impl_.response_);
  }
  if (from._internal_has_analysis()) {
    _this->_impl_.analysis_ = new ::unhinged::audio::v1::AudioAnalysis(*from._impl_.analysis_);
  }
  if (from._internal_has_usage()) {
    _this->_impl_.usage_ = new ::unhinged::common::v1::AudioUsage(*from._impl_.usage_);
  }
  // @@protoc_insertion_point(copy_constructor:unhinged.audio.v1.AnalyzeAudioResponse)
}

inline void AnalyzeAudioResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.response_){nullptr}
    , decltype(_impl_.analysis_){nullptr}
    , decltype(_impl_.usage_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

AnalyzeAudioResponse::~AnalyzeAudioResponse() {
  // @@protoc_insertion_point(destructor:unhinged.audio.v1.AnalyzeAudioResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AnalyzeAudioResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.response_;
  if (this != internal_default_instance()) delete _impl_.analysis_;
  if (this != internal_default_instance()) delete _impl_.usage_;
}

void AnalyzeAudioResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AnalyzeAudioResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:unhinged.audio.v1.AnalyzeAudioResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.response_ != nullptr) {
    delete _impl_.response_;
  }
  _impl_.response_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.analysis_ != nullptr) {
    delete _impl_.analysis_;
  }
  _impl_.analysis_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.usage_ != nullptr) {
    delete _impl_.usage_;
  }
  _impl_.usage_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AnalyzeAudioResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .unhinged.common.v1.StandardResponse response = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .unhinged.audio.v1.AudioAnalysis analysis = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_analysis(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .unhinged.common.v1.AudioUsage usage = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_usage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AnalyzeAudioResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unhinged.audio.v1.AnalyzeAudioResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .unhinged.common.v1.StandardResponse response = 1;
  if (this->_internal_has_response()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::response(this),
        _Internal::response(this).GetCachedSize(), target, stream);
  }

  // .unhinged.audio.v1.AudioAnalysis analysis = 2;
  if (this->_internal_has_analysis()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::analysis(this),
        _Internal::analysis(this).GetCachedSize(), target, stream);
  }

  // .unhinged.common.v1.AudioUsage usage = 3;
  if (this->_internal_has_usage()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::usage(this),
        _Internal::usage(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unhinged.audio.v1.AnalyzeAudioResponse)
  return target;
}

size_t AnalyzeAudioResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unhinged.audio.v1.AnalyzeAudioResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .unhinged.common.v1.StandardResponse response = 1;
  if (this->_internal_has_response()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.response_);
  }

  // .unhinged.audio.v1.AudioAnalysis analysis = 2;
  if (this->_internal_has_analysis()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.analysis_);
  }

  // .unhinged.common.v1.AudioUsage usage = 3;
  if (this->_internal_has_usage()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.usage_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AnalyzeAudioResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AnalyzeAudioResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AnalyzeAudioResponse::GetClassData() const { return &_class_data_; }


void AnalyzeAudioResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AnalyzeAudioResponse*>(&to_msg);
  auto& from = static_cast<const AnalyzeAudioResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unhinged.audio.v1.AnalyzeAudioResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_response()) {
    _this->_internal_mutable_response()->::unhinged::common::v1::StandardResponse::MergeFrom(
        from._internal_response());
  }
  if (from._internal_has_analysis()) {
    _this->_internal_mutable_analysis()->::unhinged::audio::v1::AudioAnalysis::MergeFrom(
        from._internal_analysis());
  }
  if (from._internal_has_usage()) {
    _this->_internal_mutable_usage()->::unhinged::common::v1::AudioUsage::MergeFrom(
        from._internal_usage());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AnalyzeAudioResponse::CopyFrom(const AnalyzeAudioResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unhinged.audio.v1.AnalyzeAudioResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AnalyzeAudioResponse::IsInitialized() const {
  return true;
}

void AnalyzeAudioResponse::InternalSwap(AnalyzeAudioResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AnalyzeAudioResponse, _impl_.usage_)
      + sizeof(AnalyzeAudioResponse::_impl_.usage_)
      - PROTOBUF_FIELD_OFFSET(AnalyzeAudioResponse, _impl_.response_)>(
          reinterpret_cast<char*>(&_impl_.response_),
          reinterpret_cast<char*>(&other->_impl_.response_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AnalyzeAudioResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_2eproto_getter, &descriptor_table_audio_2eproto_once,
      file_level_metadata_audio_2eproto[23]);
}

// ===================================================================

class AudioAnalysis::_Internal {
 public:
  static const ::unhinged::audio::v1::AudioQualityMetrics& quality_metrics(const AudioAnalysis* msg);
};

const ::unhinged::audio::v1::AudioQualityMetrics&
AudioAnalysis::_Internal::quality_metrics(const AudioAnalysis* msg) {
  return *msg->_impl_.quality_metrics_;
}
AudioAnalysis::AudioAnalysis(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unhinged.audio.v1.AudioAnalysis)
}
AudioAnalysis::AudioAnalysis(const AudioAnalysis& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AudioAnalysis* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.speech_segments_){from._impl_.speech_segments_}
    , decltype(_impl_.detected_languages_){from._impl_.detected_languages_}
    , decltype(_impl_.speaker_segments_){from._impl_.speaker_segments_}
    , decltype(_impl_.emotion_segments_){from._impl_.emotion_segments_}
    , decltype(_impl_.quality_metrics_){nullptr}
    , decltype(_impl_.contains_speech_){}
    , decltype(_impl_.speech_percentage_){}
    , decltype(_impl_.speaker_count_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_quality_metrics()) {
    _this->_impl_.quality_metrics_ = new ::unhinged::audio::v1::AudioQualityMetrics(*from._impl_.quality_metrics_);
  }
  ::memcpy(&_impl_.contains_speech_, &from._impl_.contains_speech_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.speaker_count_) -
    reinterpret_cast<char*>(&_impl_.contains_speech_)) + sizeof(_impl_.speaker_count_));
  // @@protoc_insertion_point(copy_constructor:unhinged.audio.v1.AudioAnalysis)
}

inline void AudioAnalysis::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.speech_segments_){arena}
    , decltype(_impl_.detected_languages_){arena}
    , decltype(_impl_.speaker_segments_){arena}
    , decltype(_impl_.emotion_segments_){arena}
    , decltype(_impl_.quality_metrics_){nullptr}
    , decltype(_impl_.contains_speech_){false}
    , decltype(_impl_.speech_percentage_){0}
    , decltype(_impl_.speaker_count_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

AudioAnalysis::~AudioAnalysis() {
  // @@protoc_insertion_point(destructor:unhinged.audio.v1.AudioAnalysis)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AudioAnalysis::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.speech_segments_.~RepeatedPtrField();
  _impl_.detected_languages_.~RepeatedPtrField();
  _impl_.speaker_segments_.~RepeatedPtrField();
  _impl_.emotion_segments_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.quality_metrics_;
}

void AudioAnalysis::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AudioAnalysis::Clear() {
// @@protoc_insertion_point(message_clear_start:unhinged.audio.v1.AudioAnalysis)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.speech_segments_.Clear();
  _impl_.detected_languages_.Clear();
  _impl_.speaker_segments_.Clear();
  _impl_.emotion_segments_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.quality_metrics_ != nullptr) {
    delete _impl_.quality_metrics_;
  }
  _impl_.quality_metrics_ = nullptr;
  ::memset(&_impl_.contains_speech_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.speaker_count_) -
      reinterpret_cast<char*>(&_impl_.contains_speech_)) + sizeof(_impl_.speaker_count_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AudioAnalysis::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool contains_speech = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.contains_speech_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float speech_percentage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.speech_percentage_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // repeated .unhinged.audio.v1.SpeechSegment speech_segments = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_speech_segments(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .unhinged.audio.v1.LanguageDetection detected_languages = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_detected_languages(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // int32 speaker_count = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.speaker_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .unhinged.audio.v1.SpeakerSegment speaker_segments = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_speaker_segments(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .unhinged.audio.v1.EmotionSegment emotion_segments = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_emotion_segments(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .unhinged.audio.v1.AudioQualityMetrics quality_metrics = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_quality_metrics(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AudioAnalysis::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unhinged.audio.v1.AudioAnalysis)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool contains_speech = 1;
  if (this->_internal_contains_speech() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_contains_speech(), target);
  }

  // float speech_percentage = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_speech_percentage = this->_internal_speech_percentage();
  uint32_t raw_speech_percentage;
  memcpy(&raw_speech_percentage, &tmp_speech_percentage, sizeof(tmp_speech_percentage));
  if (raw_speech_percentage != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_speech_percentage(), target);
  }

  // repeated .unhinged.audio.v1.SpeechSegment speech_segments = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_speech_segments_size()); i < n; i++) {
    const auto& repfield = this->_internal_speech_segments(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .unhinged.audio.v1.LanguageDetection detected_languages = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_detected_languages_size()); i < n; i++) {
    const auto& repfield = this->_internal_detected_languages(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // int32 speaker_count = 5;
  if (this->_internal_speaker_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_speaker_count(), target);
  }

  // repeated .unhinged.audio.v1.SpeakerSegment speaker_segments = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_speaker_segments_size()); i < n; i++) {
    const auto& repfield = this->_internal_speaker_segments(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .unhinged.audio.v1.EmotionSegment emotion_segments = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_emotion_segments_size()); i < n; i++) {
    const auto& repfield = this->_internal_emotion_segments(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .unhinged.audio.v1.AudioQualityMetrics quality_metrics = 8;
  if (this->_internal_has_quality_metrics()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::quality_metrics(this),
        _Internal::quality_metrics(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unhinged.audio.v1.AudioAnalysis)
  return target;
}

size_t AudioAnalysis::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unhinged.audio.v1.AudioAnalysis)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .unhinged.audio.v1.SpeechSegment speech_segments = 3;
  total_size += 1UL * this->_internal_speech_segments_size();
  for (const auto& msg : this->_impl_.speech_segments_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .unhinged.audio.v1.LanguageDetection detected_languages = 4;
  total_size += 1UL * this->_internal_detected_languages_size();
  for (const auto& msg : this->_impl_.detected_languages_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .unhinged.audio.v1.SpeakerSegment speaker_segments = 6;
  total_size += 1UL * this->_internal_speaker_segments_size();
  for (const auto& msg : this->_impl_.speaker_segments_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .unhinged.audio.v1.EmotionSegment emotion_segments = 7;
  total_size += 1UL * this->_internal_emotion_segments_size();
  for (const auto& msg : this->_impl_.emotion_segments_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .unhinged.audio.v1.AudioQualityMetrics quality_metrics = 8;
  if (this->_internal_has_quality_metrics()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.quality_metrics_);
  }

  // bool contains_speech = 1;
  if (this->_internal_contains_speech() != 0) {
    total_size += 1 + 1;
  }

  // float speech_percentage = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_speech_percentage = this->_internal_speech_percentage();
  uint32_t raw_speech_percentage;
  memcpy(&raw_speech_percentage, &tmp_speech_percentage, sizeof(tmp_speech_percentage));
  if (raw_speech_percentage != 0) {
    total_size += 1 + 4;
  }

  // int32 speaker_count = 5;
  if (this->_internal_speaker_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_speaker_count());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AudioAnalysis::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AudioAnalysis::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AudioAnalysis::GetClassData() const { return &_class_data_; }


void AudioAnalysis::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AudioAnalysis*>(&to_msg);
  auto& from = static_cast<const AudioAnalysis&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unhinged.audio.v1.AudioAnalysis)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.speech_segments_.MergeFrom(from._impl_.speech_segments_);
  _this->_impl_.detected_languages_.MergeFrom(from._impl_.detected_languages_);
  _this->_impl_.speaker_segments_.MergeFrom(from._impl_.speaker_segments_);
  _this->_impl_.emotion_segments_.MergeFrom(from._impl_.emotion_segments_);
  if (from._internal_has_quality_metrics()) {
    _this->_internal_mutable_quality_metrics()->::unhinged::audio::v1::AudioQualityMetrics::MergeFrom(
        from._internal_quality_metrics());
  }
  if (from._internal_contains_speech() != 0) {
    _this->_internal_set_contains_speech(from._internal_contains_speech());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_speech_percentage = from._internal_speech_percentage();
  uint32_t raw_speech_percentage;
  memcpy(&raw_speech_percentage, &tmp_speech_percentage, sizeof(tmp_speech_percentage));
  if (raw_speech_percentage != 0) {
    _this->_internal_set_speech_percentage(from._internal_speech_percentage());
  }
  if (from._internal_speaker_count() != 0) {
    _this->_internal_set_speaker_count(from._internal_speaker_count());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AudioAnalysis::CopyFrom(const AudioAnalysis& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unhinged.audio.v1.AudioAnalysis)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioAnalysis::IsInitialized() const {
  return true;
}

void AudioAnalysis::InternalSwap(AudioAnalysis* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.speech_segments_.InternalSwap(&other->_impl_.speech_segments_);
  _impl_.detected_languages_.InternalSwap(&other->_impl_.detected_languages_);
  _impl_.speaker_segments_.InternalSwap(&other->_impl_.speaker_segments_);
  _impl_.emotion_segments_.InternalSwap(&other->_impl_.emotion_segments_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AudioAnalysis, _impl_.speaker_count_)
      + sizeof(AudioAnalysis::_impl_.speaker_count_)
      - PROTOBUF_FIELD_OFFSET(AudioAnalysis, _impl_.quality_metrics_)>(
          reinterpret_cast<char*>(&_impl_.quality_metrics_),
          reinterpret_cast<char*>(&other->_impl_.quality_metrics_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AudioAnalysis::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_2eproto_getter, &descriptor_table_audio_2eproto_once,
      file_level_metadata_audio_2eproto[24]);
}

// ===================================================================

class SpeechSegment::_Internal {
 public:
};

SpeechSegment::SpeechSegment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unhinged.audio.v1.SpeechSegment)
}
SpeechSegment::SpeechSegment(const SpeechSegment& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SpeechSegment* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.start_time_){}
    , decltype(_impl_.end_time_){}
    , decltype(_impl_.confidence_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.start_time_, &from._impl_.start_time_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.confidence_) -
    reinterpret_cast<char*>(&_impl_.start_time_)) + sizeof(_impl_.confidence_));
  // @@protoc_insertion_point(copy_constructor:unhinged.audio.v1.SpeechSegment)
}

inline void SpeechSegment::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.start_time_){0}
    , decltype(_impl_.end_time_){0}
    , decltype(_impl_.confidence_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SpeechSegment::~SpeechSegment() {
  // @@protoc_insertion_point(destructor:unhinged.audio.v1.SpeechSegment)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SpeechSegment::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SpeechSegment::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SpeechSegment::Clear() {
// @@protoc_insertion_point(message_clear_start:unhinged.audio.v1.SpeechSegment)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.start_time_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.confidence_) -
      reinterpret_cast<char*>(&_impl_.start_time_)) + sizeof(_impl_.confidence_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SpeechSegment::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float start_time = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _impl_.start_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float end_time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.end_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float confidence = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _impl_.confidence_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SpeechSegment::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unhinged.audio.v1.SpeechSegment)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float start_time = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_start_time = this->_internal_start_time();
  uint32_t raw_start_time;
  memcpy(&raw_start_time, &tmp_start_time, sizeof(tmp_start_time));
  if (raw_start_time != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_start_time(), target);
  }

  // float end_time = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_end_time = this->_internal_end_time();
  uint32_t raw_end_time;
  memcpy(&raw_end_time, &tmp_end_time, sizeof(tmp_end_time));
  if (raw_end_time != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_end_time(), target);
  }

  // float confidence = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_confidence = this->_internal_confidence();
  uint32_t raw_confidence;
  memcpy(&raw_confidence, &tmp_confidence, sizeof(tmp_confidence));
  if (raw_confidence != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_confidence(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unhinged.audio.v1.SpeechSegment)
  return target;
}

size_t SpeechSegment::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unhinged.audio.v1.SpeechSegment)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float start_time = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_start_time = this->_internal_start_time();
  uint32_t raw_start_time;
  memcpy(&raw_start_time, &tmp_start_time, sizeof(tmp_start_time));
  if (raw_start_time != 0) {
    total_size += 1 + 4;
  }

  // float end_time = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_end_time = this->_internal_end_time();
  uint32_t raw_end_time;
  memcpy(&raw_end_time, &tmp_end_time, sizeof(tmp_end_time));
  if (raw_end_time != 0) {
    total_size += 1 + 4;
  }

  // float confidence = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_confidence = this->_internal_confidence();
  uint32_t raw_confidence;
  memcpy(&raw_confidence, &tmp_confidence, sizeof(tmp_confidence));
  if (raw_confidence != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SpeechSegment::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SpeechSegment::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SpeechSegment::GetClassData() const { return &_class_data_; }


void SpeechSegment::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SpeechSegment*>(&to_msg);
  auto& from = static_cast<const SpeechSegment&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unhinged.audio.v1.SpeechSegment)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_start_time = from._internal_start_time();
  uint32_t raw_start_time;
  memcpy(&raw_start_time, &tmp_start_time, sizeof(tmp_start_time));
  if (raw_start_time != 0) {
    _this->_internal_set_start_time(from._internal_start_time());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_end_time = from._internal_end_time();
  uint32_t raw_end_time;
  memcpy(&raw_end_time, &tmp_end_time, sizeof(tmp_end_time));
  if (raw_end_time != 0) {
    _this->_internal_set_end_time(from._internal_end_time());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_confidence = from._internal_confidence();
  uint32_t raw_confidence;
  memcpy(&raw_confidence, &tmp_confidence, sizeof(tmp_confidence));
  if (raw_confidence != 0) {
    _this->_internal_set_confidence(from._internal_confidence());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SpeechSegment::CopyFrom(const SpeechSegment& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unhinged.audio.v1.SpeechSegment)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SpeechSegment::IsInitialized() const {
  return true;
}

void SpeechSegment::InternalSwap(SpeechSegment* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SpeechSegment, _impl_.confidence_)
      + sizeof(SpeechSegment::_impl_.confidence_)
      - PROTOBUF_FIELD_OFFSET(SpeechSegment, _impl_.start_time_)>(
          reinterpret_cast<char*>(&_impl_.start_time_),
          reinterpret_cast<char*>(&other->_impl_.start_time_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SpeechSegment::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_2eproto_getter, &descriptor_table_audio_2eproto_once,
      file_level_metadata_audio_2eproto[25]);
}

// ===================================================================

class LanguageDetection::_Internal {
 public:
};

LanguageDetection::LanguageDetection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unhinged.audio.v1.LanguageDetection)
}
LanguageDetection::LanguageDetection(const LanguageDetection& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LanguageDetection* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.language_){}
    , decltype(_impl_.language_code_){}
    , decltype(_impl_.confidence_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.language_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.language_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_language().empty()) {
    _this->_impl_.language_.Set(from._internal_language(), 
      _this->GetArenaForAllocation());
  }
  _impl_.language_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.language_code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_language_code().empty()) {
    _this->_impl_.language_code_.Set(from._internal_language_code(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.confidence_ = from._impl_.confidence_;
  // @@protoc_insertion_point(copy_constructor:unhinged.audio.v1.LanguageDetection)
}

inline void LanguageDetection::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.language_){}
    , decltype(_impl_.language_code_){}
    , decltype(_impl_.confidence_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.language_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.language_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.language_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.language_code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LanguageDetection::~LanguageDetection() {
  // @@protoc_insertion_point(destructor:unhinged.audio.v1.LanguageDetection)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LanguageDetection::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.language_.Destroy();
  _impl_.language_code_.Destroy();
}

void LanguageDetection::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LanguageDetection::Clear() {
// @@protoc_insertion_point(message_clear_start:unhinged.audio.v1.LanguageDetection)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.language_.ClearToEmpty();
  _impl_.language_code_.ClearToEmpty();
  _impl_.confidence_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LanguageDetection::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string language = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_language();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "unhinged.audio.v1.LanguageDetection.language"));
        } else
          goto handle_unusual;
        continue;
      // string language_code = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_language_code();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "unhinged.audio.v1.LanguageDetection.language_code"));
        } else
          goto handle_unusual;
        continue;
      // float confidence = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _impl_.confidence_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LanguageDetection::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unhinged.audio.v1.LanguageDetection)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string language = 1;
  if (!this->_internal_language().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_language().data(), static_cast<int>(this->_internal_language().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "unhinged.audio.v1.LanguageDetection.language");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_language(), target);
  }

  // string language_code = 2;
  if (!this->_internal_language_code().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_language_code().data(), static_cast<int>(this->_internal_language_code().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "unhinged.audio.v1.LanguageDetection.language_code");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_language_code(), target);
  }

  // float confidence = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_confidence = this->_internal_confidence();
  uint32_t raw_confidence;
  memcpy(&raw_confidence, &tmp_confidence, sizeof(tmp_confidence));
  if (raw_confidence != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_confidence(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unhinged.audio.v1.LanguageDetection)
  return target;
}

size_t LanguageDetection::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unhinged.audio.v1.LanguageDetection)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string language = 1;
  if (!this->_internal_language().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_language());
  }

  // string language_code = 2;
  if (!this->_internal_language_code().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_language_code());
  }

  // float confidence = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_confidence = this->_internal_confidence();
  uint32_t raw_confidence;
  memcpy(&raw_confidence, &tmp_confidence, sizeof(tmp_confidence));
  if (raw_confidence != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LanguageDetection::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LanguageDetection::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LanguageDetection::GetClassData() const { return &_class_data_; }


void LanguageDetection::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LanguageDetection*>(&to_msg);
  auto& from = static_cast<const LanguageDetection&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unhinged.audio.v1.LanguageDetection)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_language().empty()) {
    _this->_internal_set_language(from._internal_language());
  }
  if (!from._internal_language_code().empty()) {
    _this->_internal_set_language_code(from._internal_language_code());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_confidence = from._internal_confidence();
  uint32_t raw_confidence;
  memcpy(&raw_confidence, &tmp_confidence, sizeof(tmp_confidence));
  if (raw_confidence != 0) {
    _this->_internal_set_confidence(from._internal_confidence());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LanguageDetection::CopyFrom(const LanguageDetection& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unhinged.audio.v1.LanguageDetection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LanguageDetection::IsInitialized() const {
  return true;
}

void LanguageDetection::InternalSwap(LanguageDetection* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.language_, lhs_arena,
      &other->_impl_.language_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.language_code_, lhs_arena,
      &other->_impl_.language_code_, rhs_arena
  );
  swap(_impl_.confidence_, other->_impl_.confidence_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LanguageDetection::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_2eproto_getter, &descriptor_table_audio_2eproto_once,
      file_level_metadata_audio_2eproto[26]);
}

// ===================================================================

class SpeakerSegment::_Internal {
 public:
};

SpeakerSegment::SpeakerSegment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unhinged.audio.v1.SpeakerSegment)
}
SpeakerSegment::SpeakerSegment(const SpeakerSegment& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SpeakerSegment* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.speaker_id_){}
    , decltype(_impl_.start_time_){}
    , decltype(_impl_.end_time_){}
    , decltype(_impl_.confidence_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.speaker_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.speaker_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_speaker_id().empty()) {
    _this->_impl_.speaker_id_.Set(from._internal_speaker_id(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.start_time_, &from._impl_.start_time_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.confidence_) -
    reinterpret_cast<char*>(&_impl_.start_time_)) + sizeof(_impl_.confidence_));
  // @@protoc_insertion_point(copy_constructor:unhinged.audio.v1.SpeakerSegment)
}

inline void SpeakerSegment::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.speaker_id_){}
    , decltype(_impl_.start_time_){0}
    , decltype(_impl_.end_time_){0}
    , decltype(_impl_.confidence_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.speaker_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.speaker_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SpeakerSegment::~SpeakerSegment() {
  // @@protoc_insertion_point(destructor:unhinged.audio.v1.SpeakerSegment)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SpeakerSegment::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.speaker_id_.Destroy();
}

void SpeakerSegment::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SpeakerSegment::Clear() {
// @@protoc_insertion_point(message_clear_start:unhinged.audio.v1.SpeakerSegment)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.speaker_id_.ClearToEmpty();
  ::memset(&_impl_.start_time_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.confidence_) -
      reinterpret_cast<char*>(&_impl_.start_time_)) + sizeof(_impl_.confidence_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SpeakerSegment::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string speaker_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_speaker_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "unhinged.audio.v1.SpeakerSegment.speaker_id"));
        } else
          goto handle_unusual;
        continue;
      // float start_time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.start_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float end_time = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _impl_.end_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float confidence = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _impl_.confidence_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SpeakerSegment::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unhinged.audio.v1.SpeakerSegment)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string speaker_id = 1;
  if (!this->_internal_speaker_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_speaker_id().data(), static_cast<int>(this->_internal_speaker_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "unhinged.audio.v1.SpeakerSegment.speaker_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_speaker_id(), target);
  }

  // float start_time = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_start_time = this->_internal_start_time();
  uint32_t raw_start_time;
  memcpy(&raw_start_time, &tmp_start_time, sizeof(tmp_start_time));
  if (raw_start_time != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_start_time(), target);
  }

  // float end_time = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_end_time = this->_internal_end_time();
  uint32_t raw_end_time;
  memcpy(&raw_end_time, &tmp_end_time, sizeof(tmp_end_time));
  if (raw_end_time != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_end_time(), target);
  }

  // float confidence = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_confidence = this->_internal_confidence();
  uint32_t raw_confidence;
  memcpy(&raw_confidence, &tmp_confidence, sizeof(tmp_confidence));
  if (raw_confidence != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_confidence(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unhinged.audio.v1.SpeakerSegment)
  return target;
}

size_t SpeakerSegment::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unhinged.audio.v1.SpeakerSegment)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string speaker_id = 1;
  if (!this->_internal_speaker_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_speaker_id());
  }

  // float start_time = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_start_time = this->_internal_start_time();
  uint32_t raw_start_time;
  memcpy(&raw_start_time, &tmp_start_time, sizeof(tmp_start_time));
  if (raw_start_time != 0) {
    total_size += 1 + 4;
  }

  // float end_time = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_end_time = this->_internal_end_time();
  uint32_t raw_end_time;
  memcpy(&raw_end_time, &tmp_end_time, sizeof(tmp_end_time));
  if (raw_end_time != 0) {
    total_size += 1 + 4;
  }

  // float confidence = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_confidence = this->_internal_confidence();
  uint32_t raw_confidence;
  memcpy(&raw_confidence, &tmp_confidence, sizeof(tmp_confidence));
  if (raw_confidence != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SpeakerSegment::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SpeakerSegment::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SpeakerSegment::GetClassData() const { return &_class_data_; }


void SpeakerSegment::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SpeakerSegment*>(&to_msg);
  auto& from = static_cast<const SpeakerSegment&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unhinged.audio.v1.SpeakerSegment)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_speaker_id().empty()) {
    _this->_internal_set_speaker_id(from._internal_speaker_id());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_start_time = from._internal_start_time();
  uint32_t raw_start_time;
  memcpy(&raw_start_time, &tmp_start_time, sizeof(tmp_start_time));
  if (raw_start_time != 0) {
    _this->_internal_set_start_time(from._internal_start_time());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_end_time = from._internal_end_time();
  uint32_t raw_end_time;
  memcpy(&raw_end_time, &tmp_end_time, sizeof(tmp_end_time));
  if (raw_end_time != 0) {
    _this->_internal_set_end_time(from._internal_end_time());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_confidence = from._internal_confidence();
  uint32_t raw_confidence;
  memcpy(&raw_confidence, &tmp_confidence, sizeof(tmp_confidence));
  if (raw_confidence != 0) {
    _this->_internal_set_confidence(from._internal_confidence());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SpeakerSegment::CopyFrom(const SpeakerSegment& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unhinged.audio.v1.SpeakerSegment)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SpeakerSegment::IsInitialized() const {
  return true;
}

void SpeakerSegment::InternalSwap(SpeakerSegment* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.speaker_id_, lhs_arena,
      &other->_impl_.speaker_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SpeakerSegment, _impl_.confidence_)
      + sizeof(SpeakerSegment::_impl_.confidence_)
      - PROTOBUF_FIELD_OFFSET(SpeakerSegment, _impl_.start_time_)>(
          reinterpret_cast<char*>(&_impl_.start_time_),
          reinterpret_cast<char*>(&other->_impl_.start_time_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SpeakerSegment::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_2eproto_getter, &descriptor_table_audio_2eproto_once,
      file_level_metadata_audio_2eproto[27]);
}

// ===================================================================

class EmotionSegment::_Internal {
 public:
};

EmotionSegment::EmotionSegment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unhinged.audio.v1.EmotionSegment)
}
EmotionSegment::EmotionSegment(const EmotionSegment& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EmotionSegment* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.emotion_){}
    , decltype(_impl_.start_time_){}
    , decltype(_impl_.end_time_){}
    , decltype(_impl_.confidence_){}
    , decltype(_impl_.intensity_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.emotion_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.emotion_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_emotion().empty()) {
    _this->_impl_.emotion_.Set(from._internal_emotion(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.start_time_, &from._impl_.start_time_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.intensity_) -
    reinterpret_cast<char*>(&_impl_.start_time_)) + sizeof(_impl_.intensity_));
  // @@protoc_insertion_point(copy_constructor:unhinged.audio.v1.EmotionSegment)
}

inline void EmotionSegment::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.emotion_){}
    , decltype(_impl_.start_time_){0}
    , decltype(_impl_.end_time_){0}
    , decltype(_impl_.confidence_){0}
    , decltype(_impl_.intensity_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.emotion_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.emotion_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

EmotionSegment::~EmotionSegment() {
  // @@protoc_insertion_point(destructor:unhinged.audio.v1.EmotionSegment)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EmotionSegment::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.emotion_.Destroy();
}

void EmotionSegment::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EmotionSegment::Clear() {
// @@protoc_insertion_point(message_clear_start:unhinged.audio.v1.EmotionSegment)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.emotion_.ClearToEmpty();
  ::memset(&_impl_.start_time_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.intensity_) -
      reinterpret_cast<char*>(&_impl_.start_time_)) + sizeof(_impl_.intensity_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EmotionSegment::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string emotion = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_emotion();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "unhinged.audio.v1.EmotionSegment.emotion"));
        } else
          goto handle_unusual;
        continue;
      // float start_time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.start_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float end_time = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _impl_.end_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float confidence = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _impl_.confidence_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float intensity = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _impl_.intensity_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EmotionSegment::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unhinged.audio.v1.EmotionSegment)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string emotion = 1;
  if (!this->_internal_emotion().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_emotion().data(), static_cast<int>(this->_internal_emotion().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "unhinged.audio.v1.EmotionSegment.emotion");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_emotion(), target);
  }

  // float start_time = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_start_time = this->_internal_start_time();
  uint32_t raw_start_time;
  memcpy(&raw_start_time, &tmp_start_time, sizeof(tmp_start_time));
  if (raw_start_time != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_start_time(), target);
  }

  // float end_time = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_end_time = this->_internal_end_time();
  uint32_t raw_end_time;
  memcpy(&raw_end_time, &tmp_end_time, sizeof(tmp_end_time));
  if (raw_end_time != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_end_time(), target);
  }

  // float confidence = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_confidence = this->_internal_confidence();
  uint32_t raw_confidence;
  memcpy(&raw_confidence, &tmp_confidence, sizeof(tmp_confidence));
  if (raw_confidence != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_confidence(), target);
  }

  // float intensity = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_intensity = this->_internal_intensity();
  uint32_t raw_intensity;
  memcpy(&raw_intensity, &tmp_intensity, sizeof(tmp_intensity));
  if (raw_intensity != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_intensity(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unhinged.audio.v1.EmotionSegment)
  return target;
}

size_t EmotionSegment::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unhinged.audio.v1.EmotionSegment)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string emotion = 1;
  if (!this->_internal_emotion().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_emotion());
  }

  // float start_time = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_start_time = this->_internal_start_time();
  uint32_t raw_start_time;
  memcpy(&raw_start_time, &tmp_start_time, sizeof(tmp_start_time));
  if (raw_start_time != 0) {
    total_size += 1 + 4;
  }

  // float end_time = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_end_time = this->_internal_end_time();
  uint32_t raw_end_time;
  memcpy(&raw_end_time, &tmp_end_time, sizeof(tmp_end_time));
  if (raw_end_time != 0) {
    total_size += 1 + 4;
  }

  // float confidence = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_confidence = this->_internal_confidence();
  uint32_t raw_confidence;
  memcpy(&raw_confidence, &tmp_confidence, sizeof(tmp_confidence));
  if (raw_confidence != 0) {
    total_size += 1 + 4;
  }

  // float intensity = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_intensity = this->_internal_intensity();
  uint32_t raw_intensity;
  memcpy(&raw_intensity, &tmp_intensity, sizeof(tmp_intensity));
  if (raw_intensity != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EmotionSegment::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EmotionSegment::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EmotionSegment::GetClassData() const { return &_class_data_; }


void EmotionSegment::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EmotionSegment*>(&to_msg);
  auto& from = static_cast<const EmotionSegment&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unhinged.audio.v1.EmotionSegment)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_emotion().empty()) {
    _this->_internal_set_emotion(from._internal_emotion());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_start_time = from._internal_start_time();
  uint32_t raw_start_time;
  memcpy(&raw_start_time, &tmp_start_time, sizeof(tmp_start_time));
  if (raw_start_time != 0) {
    _this->_internal_set_start_time(from._internal_start_time());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_end_time = from._internal_end_time();
  uint32_t raw_end_time;
  memcpy(&raw_end_time, &tmp_end_time, sizeof(tmp_end_time));
  if (raw_end_time != 0) {
    _this->_internal_set_end_time(from._internal_end_time());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_confidence = from._internal_confidence();
  uint32_t raw_confidence;
  memcpy(&raw_confidence, &tmp_confidence, sizeof(tmp_confidence));
  if (raw_confidence != 0) {
    _this->_internal_set_confidence(from._internal_confidence());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_intensity = from._internal_intensity();
  uint32_t raw_intensity;
  memcpy(&raw_intensity, &tmp_intensity, sizeof(tmp_intensity));
  if (raw_intensity != 0) {
    _this->_internal_set_intensity(from._internal_intensity());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EmotionSegment::CopyFrom(const EmotionSegment& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unhinged.audio.v1.EmotionSegment)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EmotionSegment::IsInitialized() const {
  return true;
}

void EmotionSegment::InternalSwap(EmotionSegment* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.emotion_, lhs_arena,
      &other->_impl_.emotion_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EmotionSegment, _impl_.intensity_)
      + sizeof(EmotionSegment::_impl_.intensity_)
      - PROTOBUF_FIELD_OFFSET(EmotionSegment, _impl_.start_time_)>(
          reinterpret_cast<char*>(&_impl_.start_time_),
          reinterpret_cast<char*>(&other->_impl_.start_time_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EmotionSegment::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_2eproto_getter, &descriptor_table_audio_2eproto_once,
      file_level_metadata_audio_2eproto[28]);
}

// ===================================================================

class AudioQualityMetrics::_Internal {
 public:
};

AudioQualityMetrics::AudioQualityMetrics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unhinged.audio.v1.AudioQualityMetrics)
}
AudioQualityMetrics::AudioQualityMetrics(const AudioQualityMetrics& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AudioQualityMetrics* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.signal_to_noise_ratio_){}
    , decltype(_impl_.dynamic_range_){}
    , decltype(_impl_.has_clipping_){}
    , decltype(_impl_.has_background_noise_){}
    , decltype(_impl_.overall_quality_score_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.signal_to_noise_ratio_, &from._impl_.signal_to_noise_ratio_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.overall_quality_score_) -
    reinterpret_cast<char*>(&_impl_.signal_to_noise_ratio_)) + sizeof(_impl_.overall_quality_score_));
  // @@protoc_insertion_point(copy_constructor:unhinged.audio.v1.AudioQualityMetrics)
}

inline void AudioQualityMetrics::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.signal_to_noise_ratio_){0}
    , decltype(_impl_.dynamic_range_){0}
    , decltype(_impl_.has_clipping_){false}
    , decltype(_impl_.has_background_noise_){false}
    , decltype(_impl_.overall_quality_score_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

AudioQualityMetrics::~AudioQualityMetrics() {
  // @@protoc_insertion_point(destructor:unhinged.audio.v1.AudioQualityMetrics)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AudioQualityMetrics::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AudioQualityMetrics::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AudioQualityMetrics::Clear() {
// @@protoc_insertion_point(message_clear_start:unhinged.audio.v1.AudioQualityMetrics)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.signal_to_noise_ratio_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.overall_quality_score_) -
      reinterpret_cast<char*>(&_impl_.signal_to_noise_ratio_)) + sizeof(_impl_.overall_quality_score_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AudioQualityMetrics::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float signal_to_noise_ratio = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _impl_.signal_to_noise_ratio_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float dynamic_range = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.dynamic_range_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // bool has_clipping = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.has_clipping_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool has_background_noise = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.has_background_noise_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float overall_quality_score = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _impl_.overall_quality_score_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AudioQualityMetrics::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unhinged.audio.v1.AudioQualityMetrics)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float signal_to_noise_ratio = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_signal_to_noise_ratio = this->_internal_signal_to_noise_ratio();
  uint32_t raw_signal_to_noise_ratio;
  memcpy(&raw_signal_to_noise_ratio, &tmp_signal_to_noise_ratio, sizeof(tmp_signal_to_noise_ratio));
  if (raw_signal_to_noise_ratio != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_signal_to_noise_ratio(), target);
  }

  // float dynamic_range = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_dynamic_range = this->_internal_dynamic_range();
  uint32_t raw_dynamic_range;
  memcpy(&raw_dynamic_range, &tmp_dynamic_range, sizeof(tmp_dynamic_range));
  if (raw_dynamic_range != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_dynamic_range(), target);
  }

  // bool has_clipping = 3;
  if (this->_internal_has_clipping() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_has_clipping(), target);
  }

  // bool has_background_noise = 4;
  if (this->_internal_has_background_noise() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_has_background_noise(), target);
  }

  // float overall_quality_score = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_overall_quality_score = this->_internal_overall_quality_score();
  uint32_t raw_overall_quality_score;
  memcpy(&raw_overall_quality_score, &tmp_overall_quality_score, sizeof(tmp_overall_quality_score));
  if (raw_overall_quality_score != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_overall_quality_score(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unhinged.audio.v1.AudioQualityMetrics)
  return target;
}

size_t AudioQualityMetrics::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unhinged.audio.v1.AudioQualityMetrics)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float signal_to_noise_ratio = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_signal_to_noise_ratio = this->_internal_signal_to_noise_ratio();
  uint32_t raw_signal_to_noise_ratio;
  memcpy(&raw_signal_to_noise_ratio, &tmp_signal_to_noise_ratio, sizeof(tmp_signal_to_noise_ratio));
  if (raw_signal_to_noise_ratio != 0) {
    total_size += 1 + 4;
  }

  // float dynamic_range = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_dynamic_range = this->_internal_dynamic_range();
  uint32_t raw_dynamic_range;
  memcpy(&raw_dynamic_range, &tmp_dynamic_range, sizeof(tmp_dynamic_range));
  if (raw_dynamic_range != 0) {
    total_size += 1 + 4;
  }

  // bool has_clipping = 3;
  if (this->_internal_has_clipping() != 0) {
    total_size += 1 + 1;
  }

  // bool has_background_noise = 4;
  if (this->_internal_has_background_noise() != 0) {
    total_size += 1 + 1;
  }

  // float overall_quality_score = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_overall_quality_score = this->_internal_overall_quality_score();
  uint32_t raw_overall_quality_score;
  memcpy(&raw_overall_quality_score, &tmp_overall_quality_score, sizeof(tmp_overall_quality_score));
  if (raw_overall_quality_score != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AudioQualityMetrics::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AudioQualityMetrics::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AudioQualityMetrics::GetClassData() const { return &_class_data_; }


void AudioQualityMetrics::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AudioQualityMetrics*>(&to_msg);
  auto& from = static_cast<const AudioQualityMetrics&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unhinged.audio.v1.AudioQualityMetrics)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_signal_to_noise_ratio = from._internal_signal_to_noise_ratio();
  uint32_t raw_signal_to_noise_ratio;
  memcpy(&raw_signal_to_noise_ratio, &tmp_signal_to_noise_ratio, sizeof(tmp_signal_to_noise_ratio));
  if (raw_signal_to_noise_ratio != 0) {
    _this->_internal_set_signal_to_noise_ratio(from._internal_signal_to_noise_ratio());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_dynamic_range = from._internal_dynamic_range();
  uint32_t raw_dynamic_range;
  memcpy(&raw_dynamic_range, &tmp_dynamic_range, sizeof(tmp_dynamic_range));
  if (raw_dynamic_range != 0) {
    _this->_internal_set_dynamic_range(from._internal_dynamic_range());
  }
  if (from._internal_has_clipping() != 0) {
    _this->_internal_set_has_clipping(from._internal_has_clipping());
  }
  if (from._internal_has_background_noise() != 0) {
    _this->_internal_set_has_background_noise(from._internal_has_background_noise());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_overall_quality_score = from._internal_overall_quality_score();
  uint32_t raw_overall_quality_score;
  memcpy(&raw_overall_quality_score, &tmp_overall_quality_score, sizeof(tmp_overall_quality_score));
  if (raw_overall_quality_score != 0) {
    _this->_internal_set_overall_quality_score(from._internal_overall_quality_score());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AudioQualityMetrics::CopyFrom(const AudioQualityMetrics& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unhinged.audio.v1.AudioQualityMetrics)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioQualityMetrics::IsInitialized() const {
  return true;
}

void AudioQualityMetrics::InternalSwap(AudioQualityMetrics* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AudioQualityMetrics, _impl_.overall_quality_score_)
      + sizeof(AudioQualityMetrics::_impl_.overall_quality_score_)
      - PROTOBUF_FIELD_OFFSET(AudioQualityMetrics, _impl_.signal_to_noise_ratio_)>(
          reinterpret_cast<char*>(&_impl_.signal_to_noise_ratio_),
          reinterpret_cast<char*>(&other->_impl_.signal_to_noise_ratio_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AudioQualityMetrics::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_2eproto_getter, &descriptor_table_audio_2eproto_once,
      file_level_metadata_audio_2eproto[29]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace audio
}  // namespace unhinged
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::unhinged::audio::v1::TTSRequest*
Arena::CreateMaybeMessage< ::unhinged::audio::v1::TTSRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unhinged::audio::v1::TTSRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::unhinged::audio::v1::STTResponse*
Arena::CreateMaybeMessage< ::unhinged::audio::v1::STTResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unhinged::audio::v1::STTResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::unhinged::audio::v1::AudioOptions*
Arena::CreateMaybeMessage< ::unhinged::audio::v1::AudioOptions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unhinged::audio::v1::AudioOptions >(arena);
}
template<> PROTOBUF_NOINLINE ::unhinged::audio::v1::AudioEffect_ParametersEntry_DoNotUse*
Arena::CreateMaybeMessage< ::unhinged::audio::v1::AudioEffect_ParametersEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unhinged::audio::v1::AudioEffect_ParametersEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::unhinged::audio::v1::AudioEffect*
Arena::CreateMaybeMessage< ::unhinged::audio::v1::AudioEffect >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unhinged::audio::v1::AudioEffect >(arena);
}
template<> PROTOBUF_NOINLINE ::unhinged::audio::v1::TranscriptSegment*
Arena::CreateMaybeMessage< ::unhinged::audio::v1::TranscriptSegment >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unhinged::audio::v1::TranscriptSegment >(arena);
}
template<> PROTOBUF_NOINLINE ::unhinged::audio::v1::WordTiming*
Arena::CreateMaybeMessage< ::unhinged::audio::v1::WordTiming >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unhinged::audio::v1::WordTiming >(arena);
}
template<> PROTOBUF_NOINLINE ::unhinged::audio::v1::STTMetadata*
Arena::CreateMaybeMessage< ::unhinged::audio::v1::STTMetadata >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unhinged::audio::v1::STTMetadata >(arena);
}
template<> PROTOBUF_NOINLINE ::unhinged::audio::v1::Voice*
Arena::CreateMaybeMessage< ::unhinged::audio::v1::Voice >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unhinged::audio::v1::Voice >(arena);
}
template<> PROTOBUF_NOINLINE ::unhinged::audio::v1::TTSChunkPayload*
Arena::CreateMaybeMessage< ::unhinged::audio::v1::TTSChunkPayload >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unhinged::audio::v1::TTSChunkPayload >(arena);
}
template<> PROTOBUF_NOINLINE ::unhinged::audio::v1::STTChunkPayload*
Arena::CreateMaybeMessage< ::unhinged::audio::v1::STTChunkPayload >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unhinged::audio::v1::STTChunkPayload >(arena);
}
template<> PROTOBUF_NOINLINE ::unhinged::audio::v1::AudioMetadata*
Arena::CreateMaybeMessage< ::unhinged::audio::v1::AudioMetadata >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unhinged::audio::v1::AudioMetadata >(arena);
}
template<> PROTOBUF_NOINLINE ::unhinged::audio::v1::ProcessAudioRequest*
Arena::CreateMaybeMessage< ::unhinged::audio::v1::ProcessAudioRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unhinged::audio::v1::ProcessAudioRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::unhinged::audio::v1::ProcessAudioResponse*
Arena::CreateMaybeMessage< ::unhinged::audio::v1::ProcessAudioResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unhinged::audio::v1::ProcessAudioResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::unhinged::audio::v1::ListVoicesRequest*
Arena::CreateMaybeMessage< ::unhinged::audio::v1::ListVoicesRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unhinged::audio::v1::ListVoicesRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::unhinged::audio::v1::ListVoicesResponse*
Arena::CreateMaybeMessage< ::unhinged::audio::v1::ListVoicesResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unhinged::audio::v1::ListVoicesResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::unhinged::audio::v1::GetVoiceRequest*
Arena::CreateMaybeMessage< ::unhinged::audio::v1::GetVoiceRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unhinged::audio::v1::GetVoiceRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::unhinged::audio::v1::GetVoiceResponse*
Arena::CreateMaybeMessage< ::unhinged::audio::v1::GetVoiceResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unhinged::audio::v1::GetVoiceResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::unhinged::audio::v1::CreateCustomVoiceRequest*
Arena::CreateMaybeMessage< ::unhinged::audio::v1::CreateCustomVoiceRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unhinged::audio::v1::CreateCustomVoiceRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::unhinged::audio::v1::CreateCustomVoiceResponse*
Arena::CreateMaybeMessage< ::unhinged::audio::v1::CreateCustomVoiceResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unhinged::audio::v1::CreateCustomVoiceResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::unhinged::audio::v1::ConvertAudioRequest*
Arena::CreateMaybeMessage< ::unhinged::audio::v1::ConvertAudioRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unhinged::audio::v1::ConvertAudioRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::unhinged::audio::v1::ConvertAudioResponse*
Arena::CreateMaybeMessage< ::unhinged::audio::v1::ConvertAudioResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unhinged::audio::v1::ConvertAudioResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::unhinged::audio::v1::AnalyzeAudioRequest*
Arena::CreateMaybeMessage< ::unhinged::audio::v1::AnalyzeAudioRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unhinged::audio::v1::AnalyzeAudioRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::unhinged::audio::v1::AnalyzeAudioResponse*
Arena::CreateMaybeMessage< ::unhinged::audio::v1::AnalyzeAudioResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unhinged::audio::v1::AnalyzeAudioResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::unhinged::audio::v1::AudioAnalysis*
Arena::CreateMaybeMessage< ::unhinged::audio::v1::AudioAnalysis >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unhinged::audio::v1::AudioAnalysis >(arena);
}
template<> PROTOBUF_NOINLINE ::unhinged::audio::v1::SpeechSegment*
Arena::CreateMaybeMessage< ::unhinged::audio::v1::SpeechSegment >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unhinged::audio::v1::SpeechSegment >(arena);
}
template<> PROTOBUF_NOINLINE ::unhinged::audio::v1::LanguageDetection*
Arena::CreateMaybeMessage< ::unhinged::audio::v1::LanguageDetection >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unhinged::audio::v1::LanguageDetection >(arena);
}
template<> PROTOBUF_NOINLINE ::unhinged::audio::v1::SpeakerSegment*
Arena::CreateMaybeMessage< ::unhinged::audio::v1::SpeakerSegment >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unhinged::audio::v1::SpeakerSegment >(arena);
}
template<> PROTOBUF_NOINLINE ::unhinged::audio::v1::EmotionSegment*
Arena::CreateMaybeMessage< ::unhinged::audio::v1::EmotionSegment >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unhinged::audio::v1::EmotionSegment >(arena);
}
template<> PROTOBUF_NOINLINE ::unhinged::audio::v1::AudioQualityMetrics*
Arena::CreateMaybeMessage< ::unhinged::audio::v1::AudioQualityMetrics >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unhinged::audio::v1::AudioQualityMetrics >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
