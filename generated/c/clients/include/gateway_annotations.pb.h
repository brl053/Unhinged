// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: gateway_annotations.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_gateway_5fannotations_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_gateway_5fannotations_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/descriptor.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_gateway_5fannotations_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_gateway_5fannotations_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_gateway_5fannotations_2eproto;
namespace unhinged {
namespace gateway {
namespace v1 {
class CacheRule;
struct CacheRuleDefaultTypeInternal;
extern CacheRuleDefaultTypeInternal _CacheRule_default_instance_;
class CorsRule;
struct CorsRuleDefaultTypeInternal;
extern CorsRuleDefaultTypeInternal _CorsRule_default_instance_;
class HttpRule;
struct HttpRuleDefaultTypeInternal;
extern HttpRuleDefaultTypeInternal _HttpRule_default_instance_;
class LongPollingRule;
struct LongPollingRuleDefaultTypeInternal;
extern LongPollingRuleDefaultTypeInternal _LongPollingRule_default_instance_;
class RateLimitRule;
struct RateLimitRuleDefaultTypeInternal;
extern RateLimitRuleDefaultTypeInternal _RateLimitRule_default_instance_;
class ServerSentEventsRule;
struct ServerSentEventsRuleDefaultTypeInternal;
extern ServerSentEventsRuleDefaultTypeInternal _ServerSentEventsRule_default_instance_;
class ServiceRule;
struct ServiceRuleDefaultTypeInternal;
extern ServiceRuleDefaultTypeInternal _ServiceRule_default_instance_;
class WebSocketRule;
struct WebSocketRuleDefaultTypeInternal;
extern WebSocketRuleDefaultTypeInternal _WebSocketRule_default_instance_;
}  // namespace v1
}  // namespace gateway
}  // namespace unhinged
PROTOBUF_NAMESPACE_OPEN
template<> ::unhinged::gateway::v1::CacheRule* Arena::CreateMaybeMessage<::unhinged::gateway::v1::CacheRule>(Arena*);
template<> ::unhinged::gateway::v1::CorsRule* Arena::CreateMaybeMessage<::unhinged::gateway::v1::CorsRule>(Arena*);
template<> ::unhinged::gateway::v1::HttpRule* Arena::CreateMaybeMessage<::unhinged::gateway::v1::HttpRule>(Arena*);
template<> ::unhinged::gateway::v1::LongPollingRule* Arena::CreateMaybeMessage<::unhinged::gateway::v1::LongPollingRule>(Arena*);
template<> ::unhinged::gateway::v1::RateLimitRule* Arena::CreateMaybeMessage<::unhinged::gateway::v1::RateLimitRule>(Arena*);
template<> ::unhinged::gateway::v1::ServerSentEventsRule* Arena::CreateMaybeMessage<::unhinged::gateway::v1::ServerSentEventsRule>(Arena*);
template<> ::unhinged::gateway::v1::ServiceRule* Arena::CreateMaybeMessage<::unhinged::gateway::v1::ServiceRule>(Arena*);
template<> ::unhinged::gateway::v1::WebSocketRule* Arena::CreateMaybeMessage<::unhinged::gateway::v1::WebSocketRule>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace unhinged {
namespace gateway {
namespace v1 {

// ===================================================================

class HttpRule final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.gateway.v1.HttpRule) */ {
 public:
  inline HttpRule() : HttpRule(nullptr) {}
  ~HttpRule() override;
  explicit PROTOBUF_CONSTEXPR HttpRule(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HttpRule(const HttpRule& from);
  HttpRule(HttpRule&& from) noexcept
    : HttpRule() {
    *this = ::std::move(from);
  }

  inline HttpRule& operator=(const HttpRule& from) {
    CopyFrom(from);
    return *this;
  }
  inline HttpRule& operator=(HttpRule&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HttpRule& default_instance() {
    return *internal_default_instance();
  }
  static inline const HttpRule* internal_default_instance() {
    return reinterpret_cast<const HttpRule*>(
               &_HttpRule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(HttpRule& a, HttpRule& b) {
    a.Swap(&b);
  }
  inline void Swap(HttpRule* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HttpRule* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HttpRule* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HttpRule>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HttpRule& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HttpRule& from) {
    HttpRule::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HttpRule* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.gateway.v1.HttpRule";
  }
  protected:
  explicit HttpRule(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQueryParamsFieldNumber = 4,
    kRequiredScopesFieldNumber = 11,
    kTagsFieldNumber = 22,
    kMethodFieldNumber = 1,
    kPathFieldNumber = 2,
    kBodyFieldNumber = 3,
    kResponseWrapperFieldNumber = 6,
    kAuthTypeFieldNumber = 12,
    kSummaryFieldNumber = 20,
    kDescriptionFieldNumber = 21,
    kRateLimitFieldNumber = 15,
    kCacheFieldNumber = 16,
    kCorsFieldNumber = 17,
    kStreamResponseFieldNumber = 5,
    kAuthRequiredFieldNumber = 10,
  };
  // repeated string query_params = 4;
  int query_params_size() const;
  private:
  int _internal_query_params_size() const;
  public:
  void clear_query_params();
  const std::string& query_params(int index) const;
  std::string* mutable_query_params(int index);
  void set_query_params(int index, const std::string& value);
  void set_query_params(int index, std::string&& value);
  void set_query_params(int index, const char* value);
  void set_query_params(int index, const char* value, size_t size);
  std::string* add_query_params();
  void add_query_params(const std::string& value);
  void add_query_params(std::string&& value);
  void add_query_params(const char* value);
  void add_query_params(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& query_params() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_query_params();
  private:
  const std::string& _internal_query_params(int index) const;
  std::string* _internal_add_query_params();
  public:

  // repeated string required_scopes = 11;
  int required_scopes_size() const;
  private:
  int _internal_required_scopes_size() const;
  public:
  void clear_required_scopes();
  const std::string& required_scopes(int index) const;
  std::string* mutable_required_scopes(int index);
  void set_required_scopes(int index, const std::string& value);
  void set_required_scopes(int index, std::string&& value);
  void set_required_scopes(int index, const char* value);
  void set_required_scopes(int index, const char* value, size_t size);
  std::string* add_required_scopes();
  void add_required_scopes(const std::string& value);
  void add_required_scopes(std::string&& value);
  void add_required_scopes(const char* value);
  void add_required_scopes(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& required_scopes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_required_scopes();
  private:
  const std::string& _internal_required_scopes(int index) const;
  std::string* _internal_add_required_scopes();
  public:

  // repeated string tags = 22;
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  const std::string& tags(int index) const;
  std::string* mutable_tags(int index);
  void set_tags(int index, const std::string& value);
  void set_tags(int index, std::string&& value);
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, size_t size);
  std::string* add_tags();
  void add_tags(const std::string& value);
  void add_tags(std::string&& value);
  void add_tags(const char* value);
  void add_tags(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tags();
  private:
  const std::string& _internal_tags(int index) const;
  std::string* _internal_add_tags();
  public:

  // string method = 1;
  void clear_method();
  const std::string& method() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_method(ArgT0&& arg0, ArgT... args);
  std::string* mutable_method();
  PROTOBUF_NODISCARD std::string* release_method();
  void set_allocated_method(std::string* method);
  private:
  const std::string& _internal_method() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_method(const std::string& value);
  std::string* _internal_mutable_method();
  public:

  // string path = 2;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // string body = 3;
  void clear_body();
  const std::string& body() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_body(ArgT0&& arg0, ArgT... args);
  std::string* mutable_body();
  PROTOBUF_NODISCARD std::string* release_body();
  void set_allocated_body(std::string* body);
  private:
  const std::string& _internal_body() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_body(const std::string& value);
  std::string* _internal_mutable_body();
  public:

  // string response_wrapper = 6;
  void clear_response_wrapper();
  const std::string& response_wrapper() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_response_wrapper(ArgT0&& arg0, ArgT... args);
  std::string* mutable_response_wrapper();
  PROTOBUF_NODISCARD std::string* release_response_wrapper();
  void set_allocated_response_wrapper(std::string* response_wrapper);
  private:
  const std::string& _internal_response_wrapper() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_response_wrapper(const std::string& value);
  std::string* _internal_mutable_response_wrapper();
  public:

  // string auth_type = 12;
  void clear_auth_type();
  const std::string& auth_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_auth_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_auth_type();
  PROTOBUF_NODISCARD std::string* release_auth_type();
  void set_allocated_auth_type(std::string* auth_type);
  private:
  const std::string& _internal_auth_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_auth_type(const std::string& value);
  std::string* _internal_mutable_auth_type();
  public:

  // string summary = 20;
  void clear_summary();
  const std::string& summary() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_summary(ArgT0&& arg0, ArgT... args);
  std::string* mutable_summary();
  PROTOBUF_NODISCARD std::string* release_summary();
  void set_allocated_summary(std::string* summary);
  private:
  const std::string& _internal_summary() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_summary(const std::string& value);
  std::string* _internal_mutable_summary();
  public:

  // string description = 21;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // .unhinged.gateway.v1.RateLimitRule rate_limit = 15;
  bool has_rate_limit() const;
  private:
  bool _internal_has_rate_limit() const;
  public:
  void clear_rate_limit();
  const ::unhinged::gateway::v1::RateLimitRule& rate_limit() const;
  PROTOBUF_NODISCARD ::unhinged::gateway::v1::RateLimitRule* release_rate_limit();
  ::unhinged::gateway::v1::RateLimitRule* mutable_rate_limit();
  void set_allocated_rate_limit(::unhinged::gateway::v1::RateLimitRule* rate_limit);
  private:
  const ::unhinged::gateway::v1::RateLimitRule& _internal_rate_limit() const;
  ::unhinged::gateway::v1::RateLimitRule* _internal_mutable_rate_limit();
  public:
  void unsafe_arena_set_allocated_rate_limit(
      ::unhinged::gateway::v1::RateLimitRule* rate_limit);
  ::unhinged::gateway::v1::RateLimitRule* unsafe_arena_release_rate_limit();

  // .unhinged.gateway.v1.CacheRule cache = 16;
  bool has_cache() const;
  private:
  bool _internal_has_cache() const;
  public:
  void clear_cache();
  const ::unhinged::gateway::v1::CacheRule& cache() const;
  PROTOBUF_NODISCARD ::unhinged::gateway::v1::CacheRule* release_cache();
  ::unhinged::gateway::v1::CacheRule* mutable_cache();
  void set_allocated_cache(::unhinged::gateway::v1::CacheRule* cache);
  private:
  const ::unhinged::gateway::v1::CacheRule& _internal_cache() const;
  ::unhinged::gateway::v1::CacheRule* _internal_mutable_cache();
  public:
  void unsafe_arena_set_allocated_cache(
      ::unhinged::gateway::v1::CacheRule* cache);
  ::unhinged::gateway::v1::CacheRule* unsafe_arena_release_cache();

  // .unhinged.gateway.v1.CorsRule cors = 17;
  bool has_cors() const;
  private:
  bool _internal_has_cors() const;
  public:
  void clear_cors();
  const ::unhinged::gateway::v1::CorsRule& cors() const;
  PROTOBUF_NODISCARD ::unhinged::gateway::v1::CorsRule* release_cors();
  ::unhinged::gateway::v1::CorsRule* mutable_cors();
  void set_allocated_cors(::unhinged::gateway::v1::CorsRule* cors);
  private:
  const ::unhinged::gateway::v1::CorsRule& _internal_cors() const;
  ::unhinged::gateway::v1::CorsRule* _internal_mutable_cors();
  public:
  void unsafe_arena_set_allocated_cors(
      ::unhinged::gateway::v1::CorsRule* cors);
  ::unhinged::gateway::v1::CorsRule* unsafe_arena_release_cors();

  // bool stream_response = 5;
  void clear_stream_response();
  bool stream_response() const;
  void set_stream_response(bool value);
  private:
  bool _internal_stream_response() const;
  void _internal_set_stream_response(bool value);
  public:

  // bool auth_required = 10;
  void clear_auth_required();
  bool auth_required() const;
  void set_auth_required(bool value);
  private:
  bool _internal_auth_required() const;
  void _internal_set_auth_required(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.gateway.v1.HttpRule)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> query_params_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> required_scopes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tags_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr method_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr body_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr response_wrapper_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr auth_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr summary_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::unhinged::gateway::v1::RateLimitRule* rate_limit_;
    ::unhinged::gateway::v1::CacheRule* cache_;
    ::unhinged::gateway::v1::CorsRule* cors_;
    bool stream_response_;
    bool auth_required_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gateway_5fannotations_2eproto;
};
// -------------------------------------------------------------------

class RateLimitRule final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.gateway.v1.RateLimitRule) */ {
 public:
  inline RateLimitRule() : RateLimitRule(nullptr) {}
  ~RateLimitRule() override;
  explicit PROTOBUF_CONSTEXPR RateLimitRule(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RateLimitRule(const RateLimitRule& from);
  RateLimitRule(RateLimitRule&& from) noexcept
    : RateLimitRule() {
    *this = ::std::move(from);
  }

  inline RateLimitRule& operator=(const RateLimitRule& from) {
    CopyFrom(from);
    return *this;
  }
  inline RateLimitRule& operator=(RateLimitRule&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RateLimitRule& default_instance() {
    return *internal_default_instance();
  }
  static inline const RateLimitRule* internal_default_instance() {
    return reinterpret_cast<const RateLimitRule*>(
               &_RateLimitRule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RateLimitRule& a, RateLimitRule& b) {
    a.Swap(&b);
  }
  inline void Swap(RateLimitRule* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RateLimitRule* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RateLimitRule* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RateLimitRule>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RateLimitRule& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RateLimitRule& from) {
    RateLimitRule::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RateLimitRule* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.gateway.v1.RateLimitRule";
  }
  protected:
  explicit RateLimitRule(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyStrategyFieldNumber = 4,
    kCustomKeyFieldFieldNumber = 5,
    kRequestsPerMinuteFieldNumber = 1,
    kRequestsPerHourFieldNumber = 2,
    kRequestsPerDayFieldNumber = 3,
  };
  // string key_strategy = 4;
  void clear_key_strategy();
  const std::string& key_strategy() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key_strategy(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key_strategy();
  PROTOBUF_NODISCARD std::string* release_key_strategy();
  void set_allocated_key_strategy(std::string* key_strategy);
  private:
  const std::string& _internal_key_strategy() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key_strategy(const std::string& value);
  std::string* _internal_mutable_key_strategy();
  public:

  // string custom_key_field = 5;
  void clear_custom_key_field();
  const std::string& custom_key_field() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_custom_key_field(ArgT0&& arg0, ArgT... args);
  std::string* mutable_custom_key_field();
  PROTOBUF_NODISCARD std::string* release_custom_key_field();
  void set_allocated_custom_key_field(std::string* custom_key_field);
  private:
  const std::string& _internal_custom_key_field() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_custom_key_field(const std::string& value);
  std::string* _internal_mutable_custom_key_field();
  public:

  // int32 requests_per_minute = 1;
  void clear_requests_per_minute();
  int32_t requests_per_minute() const;
  void set_requests_per_minute(int32_t value);
  private:
  int32_t _internal_requests_per_minute() const;
  void _internal_set_requests_per_minute(int32_t value);
  public:

  // int32 requests_per_hour = 2;
  void clear_requests_per_hour();
  int32_t requests_per_hour() const;
  void set_requests_per_hour(int32_t value);
  private:
  int32_t _internal_requests_per_hour() const;
  void _internal_set_requests_per_hour(int32_t value);
  public:

  // int32 requests_per_day = 3;
  void clear_requests_per_day();
  int32_t requests_per_day() const;
  void set_requests_per_day(int32_t value);
  private:
  int32_t _internal_requests_per_day() const;
  void _internal_set_requests_per_day(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.gateway.v1.RateLimitRule)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_strategy_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr custom_key_field_;
    int32_t requests_per_minute_;
    int32_t requests_per_hour_;
    int32_t requests_per_day_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gateway_5fannotations_2eproto;
};
// -------------------------------------------------------------------

class CacheRule final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.gateway.v1.CacheRule) */ {
 public:
  inline CacheRule() : CacheRule(nullptr) {}
  ~CacheRule() override;
  explicit PROTOBUF_CONSTEXPR CacheRule(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CacheRule(const CacheRule& from);
  CacheRule(CacheRule&& from) noexcept
    : CacheRule() {
    *this = ::std::move(from);
  }

  inline CacheRule& operator=(const CacheRule& from) {
    CopyFrom(from);
    return *this;
  }
  inline CacheRule& operator=(CacheRule&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CacheRule& default_instance() {
    return *internal_default_instance();
  }
  static inline const CacheRule* internal_default_instance() {
    return reinterpret_cast<const CacheRule*>(
               &_CacheRule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CacheRule& a, CacheRule& b) {
    a.Swap(&b);
  }
  inline void Swap(CacheRule* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CacheRule* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CacheRule* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CacheRule>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CacheRule& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CacheRule& from) {
    CacheRule::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CacheRule* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.gateway.v1.CacheRule";
  }
  protected:
  explicit CacheRule(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCacheKeysFieldNumber = 2,
    kVaryHeadersFieldNumber = 4,
    kTtlSecondsFieldNumber = 1,
    kPrivateCacheFieldNumber = 3,
  };
  // repeated string cache_keys = 2;
  int cache_keys_size() const;
  private:
  int _internal_cache_keys_size() const;
  public:
  void clear_cache_keys();
  const std::string& cache_keys(int index) const;
  std::string* mutable_cache_keys(int index);
  void set_cache_keys(int index, const std::string& value);
  void set_cache_keys(int index, std::string&& value);
  void set_cache_keys(int index, const char* value);
  void set_cache_keys(int index, const char* value, size_t size);
  std::string* add_cache_keys();
  void add_cache_keys(const std::string& value);
  void add_cache_keys(std::string&& value);
  void add_cache_keys(const char* value);
  void add_cache_keys(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& cache_keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_cache_keys();
  private:
  const std::string& _internal_cache_keys(int index) const;
  std::string* _internal_add_cache_keys();
  public:

  // repeated string vary_headers = 4;
  int vary_headers_size() const;
  private:
  int _internal_vary_headers_size() const;
  public:
  void clear_vary_headers();
  const std::string& vary_headers(int index) const;
  std::string* mutable_vary_headers(int index);
  void set_vary_headers(int index, const std::string& value);
  void set_vary_headers(int index, std::string&& value);
  void set_vary_headers(int index, const char* value);
  void set_vary_headers(int index, const char* value, size_t size);
  std::string* add_vary_headers();
  void add_vary_headers(const std::string& value);
  void add_vary_headers(std::string&& value);
  void add_vary_headers(const char* value);
  void add_vary_headers(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& vary_headers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_vary_headers();
  private:
  const std::string& _internal_vary_headers(int index) const;
  std::string* _internal_add_vary_headers();
  public:

  // int32 ttl_seconds = 1;
  void clear_ttl_seconds();
  int32_t ttl_seconds() const;
  void set_ttl_seconds(int32_t value);
  private:
  int32_t _internal_ttl_seconds() const;
  void _internal_set_ttl_seconds(int32_t value);
  public:

  // bool private_cache = 3;
  void clear_private_cache();
  bool private_cache() const;
  void set_private_cache(bool value);
  private:
  bool _internal_private_cache() const;
  void _internal_set_private_cache(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.gateway.v1.CacheRule)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> cache_keys_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> vary_headers_;
    int32_t ttl_seconds_;
    bool private_cache_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gateway_5fannotations_2eproto;
};
// -------------------------------------------------------------------

class CorsRule final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.gateway.v1.CorsRule) */ {
 public:
  inline CorsRule() : CorsRule(nullptr) {}
  ~CorsRule() override;
  explicit PROTOBUF_CONSTEXPR CorsRule(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CorsRule(const CorsRule& from);
  CorsRule(CorsRule&& from) noexcept
    : CorsRule() {
    *this = ::std::move(from);
  }

  inline CorsRule& operator=(const CorsRule& from) {
    CopyFrom(from);
    return *this;
  }
  inline CorsRule& operator=(CorsRule&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CorsRule& default_instance() {
    return *internal_default_instance();
  }
  static inline const CorsRule* internal_default_instance() {
    return reinterpret_cast<const CorsRule*>(
               &_CorsRule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CorsRule& a, CorsRule& b) {
    a.Swap(&b);
  }
  inline void Swap(CorsRule* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CorsRule* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CorsRule* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CorsRule>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CorsRule& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CorsRule& from) {
    CorsRule::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CorsRule* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.gateway.v1.CorsRule";
  }
  protected:
  explicit CorsRule(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAllowedOriginsFieldNumber = 1,
    kAllowedMethodsFieldNumber = 2,
    kAllowedHeadersFieldNumber = 3,
    kAllowCredentialsFieldNumber = 4,
    kMaxAgeSecondsFieldNumber = 5,
  };
  // repeated string allowed_origins = 1;
  int allowed_origins_size() const;
  private:
  int _internal_allowed_origins_size() const;
  public:
  void clear_allowed_origins();
  const std::string& allowed_origins(int index) const;
  std::string* mutable_allowed_origins(int index);
  void set_allowed_origins(int index, const std::string& value);
  void set_allowed_origins(int index, std::string&& value);
  void set_allowed_origins(int index, const char* value);
  void set_allowed_origins(int index, const char* value, size_t size);
  std::string* add_allowed_origins();
  void add_allowed_origins(const std::string& value);
  void add_allowed_origins(std::string&& value);
  void add_allowed_origins(const char* value);
  void add_allowed_origins(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& allowed_origins() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_allowed_origins();
  private:
  const std::string& _internal_allowed_origins(int index) const;
  std::string* _internal_add_allowed_origins();
  public:

  // repeated string allowed_methods = 2;
  int allowed_methods_size() const;
  private:
  int _internal_allowed_methods_size() const;
  public:
  void clear_allowed_methods();
  const std::string& allowed_methods(int index) const;
  std::string* mutable_allowed_methods(int index);
  void set_allowed_methods(int index, const std::string& value);
  void set_allowed_methods(int index, std::string&& value);
  void set_allowed_methods(int index, const char* value);
  void set_allowed_methods(int index, const char* value, size_t size);
  std::string* add_allowed_methods();
  void add_allowed_methods(const std::string& value);
  void add_allowed_methods(std::string&& value);
  void add_allowed_methods(const char* value);
  void add_allowed_methods(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& allowed_methods() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_allowed_methods();
  private:
  const std::string& _internal_allowed_methods(int index) const;
  std::string* _internal_add_allowed_methods();
  public:

  // repeated string allowed_headers = 3;
  int allowed_headers_size() const;
  private:
  int _internal_allowed_headers_size() const;
  public:
  void clear_allowed_headers();
  const std::string& allowed_headers(int index) const;
  std::string* mutable_allowed_headers(int index);
  void set_allowed_headers(int index, const std::string& value);
  void set_allowed_headers(int index, std::string&& value);
  void set_allowed_headers(int index, const char* value);
  void set_allowed_headers(int index, const char* value, size_t size);
  std::string* add_allowed_headers();
  void add_allowed_headers(const std::string& value);
  void add_allowed_headers(std::string&& value);
  void add_allowed_headers(const char* value);
  void add_allowed_headers(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& allowed_headers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_allowed_headers();
  private:
  const std::string& _internal_allowed_headers(int index) const;
  std::string* _internal_add_allowed_headers();
  public:

  // bool allow_credentials = 4;
  void clear_allow_credentials();
  bool allow_credentials() const;
  void set_allow_credentials(bool value);
  private:
  bool _internal_allow_credentials() const;
  void _internal_set_allow_credentials(bool value);
  public:

  // int32 max_age_seconds = 5;
  void clear_max_age_seconds();
  int32_t max_age_seconds() const;
  void set_max_age_seconds(int32_t value);
  private:
  int32_t _internal_max_age_seconds() const;
  void _internal_set_max_age_seconds(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.gateway.v1.CorsRule)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> allowed_origins_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> allowed_methods_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> allowed_headers_;
    bool allow_credentials_;
    int32_t max_age_seconds_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gateway_5fannotations_2eproto;
};
// -------------------------------------------------------------------

class WebSocketRule final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.gateway.v1.WebSocketRule) */ {
 public:
  inline WebSocketRule() : WebSocketRule(nullptr) {}
  ~WebSocketRule() override;
  explicit PROTOBUF_CONSTEXPR WebSocketRule(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WebSocketRule(const WebSocketRule& from);
  WebSocketRule(WebSocketRule&& from) noexcept
    : WebSocketRule() {
    *this = ::std::move(from);
  }

  inline WebSocketRule& operator=(const WebSocketRule& from) {
    CopyFrom(from);
    return *this;
  }
  inline WebSocketRule& operator=(WebSocketRule&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WebSocketRule& default_instance() {
    return *internal_default_instance();
  }
  static inline const WebSocketRule* internal_default_instance() {
    return reinterpret_cast<const WebSocketRule*>(
               &_WebSocketRule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(WebSocketRule& a, WebSocketRule& b) {
    a.Swap(&b);
  }
  inline void Swap(WebSocketRule* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WebSocketRule* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WebSocketRule* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WebSocketRule>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WebSocketRule& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WebSocketRule& from) {
    WebSocketRule::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WebSocketRule* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.gateway.v1.WebSocketRule";
  }
  protected:
  explicit WebSocketRule(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequiredScopesFieldNumber = 11,
    kTagsFieldNumber = 27,
    kPathFieldNumber = 1,
    kEventTypeFieldNumber = 2,
    kRequestFieldFieldNumber = 15,
    kResponseFieldFieldNumber = 16,
    kBroadcastFilterFieldNumber = 18,
    kSummaryFieldNumber = 25,
    kDescriptionFieldNumber = 26,
    kRateLimitFieldNumber = 20,
    kMaxConnectionsPerUserFieldNumber = 12,
    kIdleTimeoutSecondsFieldNumber = 13,
    kAuthRequiredFieldNumber = 10,
    kBroadcastFieldNumber = 17,
  };
  // repeated string required_scopes = 11;
  int required_scopes_size() const;
  private:
  int _internal_required_scopes_size() const;
  public:
  void clear_required_scopes();
  const std::string& required_scopes(int index) const;
  std::string* mutable_required_scopes(int index);
  void set_required_scopes(int index, const std::string& value);
  void set_required_scopes(int index, std::string&& value);
  void set_required_scopes(int index, const char* value);
  void set_required_scopes(int index, const char* value, size_t size);
  std::string* add_required_scopes();
  void add_required_scopes(const std::string& value);
  void add_required_scopes(std::string&& value);
  void add_required_scopes(const char* value);
  void add_required_scopes(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& required_scopes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_required_scopes();
  private:
  const std::string& _internal_required_scopes(int index) const;
  std::string* _internal_add_required_scopes();
  public:

  // repeated string tags = 27;
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  const std::string& tags(int index) const;
  std::string* mutable_tags(int index);
  void set_tags(int index, const std::string& value);
  void set_tags(int index, std::string&& value);
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, size_t size);
  std::string* add_tags();
  void add_tags(const std::string& value);
  void add_tags(std::string&& value);
  void add_tags(const char* value);
  void add_tags(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tags();
  private:
  const std::string& _internal_tags(int index) const;
  std::string* _internal_add_tags();
  public:

  // string path = 1;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // string event_type = 2;
  void clear_event_type();
  const std::string& event_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_event_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_event_type();
  PROTOBUF_NODISCARD std::string* release_event_type();
  void set_allocated_event_type(std::string* event_type);
  private:
  const std::string& _internal_event_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_event_type(const std::string& value);
  std::string* _internal_mutable_event_type();
  public:

  // string request_field = 15;
  void clear_request_field();
  const std::string& request_field() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_request_field(ArgT0&& arg0, ArgT... args);
  std::string* mutable_request_field();
  PROTOBUF_NODISCARD std::string* release_request_field();
  void set_allocated_request_field(std::string* request_field);
  private:
  const std::string& _internal_request_field() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_field(const std::string& value);
  std::string* _internal_mutable_request_field();
  public:

  // string response_field = 16;
  void clear_response_field();
  const std::string& response_field() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_response_field(ArgT0&& arg0, ArgT... args);
  std::string* mutable_response_field();
  PROTOBUF_NODISCARD std::string* release_response_field();
  void set_allocated_response_field(std::string* response_field);
  private:
  const std::string& _internal_response_field() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_response_field(const std::string& value);
  std::string* _internal_mutable_response_field();
  public:

  // string broadcast_filter = 18;
  void clear_broadcast_filter();
  const std::string& broadcast_filter() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_broadcast_filter(ArgT0&& arg0, ArgT... args);
  std::string* mutable_broadcast_filter();
  PROTOBUF_NODISCARD std::string* release_broadcast_filter();
  void set_allocated_broadcast_filter(std::string* broadcast_filter);
  private:
  const std::string& _internal_broadcast_filter() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_broadcast_filter(const std::string& value);
  std::string* _internal_mutable_broadcast_filter();
  public:

  // string summary = 25;
  void clear_summary();
  const std::string& summary() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_summary(ArgT0&& arg0, ArgT... args);
  std::string* mutable_summary();
  PROTOBUF_NODISCARD std::string* release_summary();
  void set_allocated_summary(std::string* summary);
  private:
  const std::string& _internal_summary() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_summary(const std::string& value);
  std::string* _internal_mutable_summary();
  public:

  // string description = 26;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // .unhinged.gateway.v1.RateLimitRule rate_limit = 20;
  bool has_rate_limit() const;
  private:
  bool _internal_has_rate_limit() const;
  public:
  void clear_rate_limit();
  const ::unhinged::gateway::v1::RateLimitRule& rate_limit() const;
  PROTOBUF_NODISCARD ::unhinged::gateway::v1::RateLimitRule* release_rate_limit();
  ::unhinged::gateway::v1::RateLimitRule* mutable_rate_limit();
  void set_allocated_rate_limit(::unhinged::gateway::v1::RateLimitRule* rate_limit);
  private:
  const ::unhinged::gateway::v1::RateLimitRule& _internal_rate_limit() const;
  ::unhinged::gateway::v1::RateLimitRule* _internal_mutable_rate_limit();
  public:
  void unsafe_arena_set_allocated_rate_limit(
      ::unhinged::gateway::v1::RateLimitRule* rate_limit);
  ::unhinged::gateway::v1::RateLimitRule* unsafe_arena_release_rate_limit();

  // int32 max_connections_per_user = 12;
  void clear_max_connections_per_user();
  int32_t max_connections_per_user() const;
  void set_max_connections_per_user(int32_t value);
  private:
  int32_t _internal_max_connections_per_user() const;
  void _internal_set_max_connections_per_user(int32_t value);
  public:

  // int32 idle_timeout_seconds = 13;
  void clear_idle_timeout_seconds();
  int32_t idle_timeout_seconds() const;
  void set_idle_timeout_seconds(int32_t value);
  private:
  int32_t _internal_idle_timeout_seconds() const;
  void _internal_set_idle_timeout_seconds(int32_t value);
  public:

  // bool auth_required = 10;
  void clear_auth_required();
  bool auth_required() const;
  void set_auth_required(bool value);
  private:
  bool _internal_auth_required() const;
  void _internal_set_auth_required(bool value);
  public:

  // bool broadcast = 17;
  void clear_broadcast();
  bool broadcast() const;
  void set_broadcast(bool value);
  private:
  bool _internal_broadcast() const;
  void _internal_set_broadcast(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.gateway.v1.WebSocketRule)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> required_scopes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tags_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr event_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_field_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr response_field_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr broadcast_filter_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr summary_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::unhinged::gateway::v1::RateLimitRule* rate_limit_;
    int32_t max_connections_per_user_;
    int32_t idle_timeout_seconds_;
    bool auth_required_;
    bool broadcast_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gateway_5fannotations_2eproto;
};
// -------------------------------------------------------------------

class ServerSentEventsRule final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.gateway.v1.ServerSentEventsRule) */ {
 public:
  inline ServerSentEventsRule() : ServerSentEventsRule(nullptr) {}
  ~ServerSentEventsRule() override;
  explicit PROTOBUF_CONSTEXPR ServerSentEventsRule(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServerSentEventsRule(const ServerSentEventsRule& from);
  ServerSentEventsRule(ServerSentEventsRule&& from) noexcept
    : ServerSentEventsRule() {
    *this = ::std::move(from);
  }

  inline ServerSentEventsRule& operator=(const ServerSentEventsRule& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerSentEventsRule& operator=(ServerSentEventsRule&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerSentEventsRule& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServerSentEventsRule* internal_default_instance() {
    return reinterpret_cast<const ServerSentEventsRule*>(
               &_ServerSentEventsRule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ServerSentEventsRule& a, ServerSentEventsRule& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerSentEventsRule* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerSentEventsRule* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerSentEventsRule* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServerSentEventsRule>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServerSentEventsRule& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ServerSentEventsRule& from) {
    ServerSentEventsRule::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerSentEventsRule* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.gateway.v1.ServerSentEventsRule";
  }
  protected:
  explicit ServerSentEventsRule(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequiredScopesFieldNumber = 11,
    kFilterParamsFieldNumber = 20,
    kTagsFieldNumber = 27,
    kPathFieldNumber = 1,
    kEventTypeFieldNumber = 2,
    kDataFieldFieldNumber = 15,
    kIdFieldFieldNumber = 16,
    kRoutingKeyFieldNumber = 21,
    kSummaryFieldNumber = 25,
    kDescriptionFieldNumber = 26,
    kKeepaliveIntervalSecondsFieldNumber = 12,
    kMaxStreamDurationSecondsFieldNumber = 13,
    kAuthRequiredFieldNumber = 10,
    kJsonEncodeFieldNumber = 17,
  };
  // repeated string required_scopes = 11;
  int required_scopes_size() const;
  private:
  int _internal_required_scopes_size() const;
  public:
  void clear_required_scopes();
  const std::string& required_scopes(int index) const;
  std::string* mutable_required_scopes(int index);
  void set_required_scopes(int index, const std::string& value);
  void set_required_scopes(int index, std::string&& value);
  void set_required_scopes(int index, const char* value);
  void set_required_scopes(int index, const char* value, size_t size);
  std::string* add_required_scopes();
  void add_required_scopes(const std::string& value);
  void add_required_scopes(std::string&& value);
  void add_required_scopes(const char* value);
  void add_required_scopes(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& required_scopes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_required_scopes();
  private:
  const std::string& _internal_required_scopes(int index) const;
  std::string* _internal_add_required_scopes();
  public:

  // repeated string filter_params = 20;
  int filter_params_size() const;
  private:
  int _internal_filter_params_size() const;
  public:
  void clear_filter_params();
  const std::string& filter_params(int index) const;
  std::string* mutable_filter_params(int index);
  void set_filter_params(int index, const std::string& value);
  void set_filter_params(int index, std::string&& value);
  void set_filter_params(int index, const char* value);
  void set_filter_params(int index, const char* value, size_t size);
  std::string* add_filter_params();
  void add_filter_params(const std::string& value);
  void add_filter_params(std::string&& value);
  void add_filter_params(const char* value);
  void add_filter_params(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& filter_params() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_filter_params();
  private:
  const std::string& _internal_filter_params(int index) const;
  std::string* _internal_add_filter_params();
  public:

  // repeated string tags = 27;
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  const std::string& tags(int index) const;
  std::string* mutable_tags(int index);
  void set_tags(int index, const std::string& value);
  void set_tags(int index, std::string&& value);
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, size_t size);
  std::string* add_tags();
  void add_tags(const std::string& value);
  void add_tags(std::string&& value);
  void add_tags(const char* value);
  void add_tags(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tags();
  private:
  const std::string& _internal_tags(int index) const;
  std::string* _internal_add_tags();
  public:

  // string path = 1;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // string event_type = 2;
  void clear_event_type();
  const std::string& event_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_event_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_event_type();
  PROTOBUF_NODISCARD std::string* release_event_type();
  void set_allocated_event_type(std::string* event_type);
  private:
  const std::string& _internal_event_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_event_type(const std::string& value);
  std::string* _internal_mutable_event_type();
  public:

  // string data_field = 15;
  void clear_data_field();
  const std::string& data_field() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data_field(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data_field();
  PROTOBUF_NODISCARD std::string* release_data_field();
  void set_allocated_data_field(std::string* data_field);
  private:
  const std::string& _internal_data_field() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data_field(const std::string& value);
  std::string* _internal_mutable_data_field();
  public:

  // string id_field = 16;
  void clear_id_field();
  const std::string& id_field() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id_field(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id_field();
  PROTOBUF_NODISCARD std::string* release_id_field();
  void set_allocated_id_field(std::string* id_field);
  private:
  const std::string& _internal_id_field() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id_field(const std::string& value);
  std::string* _internal_mutable_id_field();
  public:

  // string routing_key = 21;
  void clear_routing_key();
  const std::string& routing_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_routing_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_routing_key();
  PROTOBUF_NODISCARD std::string* release_routing_key();
  void set_allocated_routing_key(std::string* routing_key);
  private:
  const std::string& _internal_routing_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_routing_key(const std::string& value);
  std::string* _internal_mutable_routing_key();
  public:

  // string summary = 25;
  void clear_summary();
  const std::string& summary() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_summary(ArgT0&& arg0, ArgT... args);
  std::string* mutable_summary();
  PROTOBUF_NODISCARD std::string* release_summary();
  void set_allocated_summary(std::string* summary);
  private:
  const std::string& _internal_summary() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_summary(const std::string& value);
  std::string* _internal_mutable_summary();
  public:

  // string description = 26;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // int32 keepalive_interval_seconds = 12;
  void clear_keepalive_interval_seconds();
  int32_t keepalive_interval_seconds() const;
  void set_keepalive_interval_seconds(int32_t value);
  private:
  int32_t _internal_keepalive_interval_seconds() const;
  void _internal_set_keepalive_interval_seconds(int32_t value);
  public:

  // int32 max_stream_duration_seconds = 13;
  void clear_max_stream_duration_seconds();
  int32_t max_stream_duration_seconds() const;
  void set_max_stream_duration_seconds(int32_t value);
  private:
  int32_t _internal_max_stream_duration_seconds() const;
  void _internal_set_max_stream_duration_seconds(int32_t value);
  public:

  // bool auth_required = 10;
  void clear_auth_required();
  bool auth_required() const;
  void set_auth_required(bool value);
  private:
  bool _internal_auth_required() const;
  void _internal_set_auth_required(bool value);
  public:

  // bool json_encode = 17;
  void clear_json_encode();
  bool json_encode() const;
  void set_json_encode(bool value);
  private:
  bool _internal_json_encode() const;
  void _internal_set_json_encode(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.gateway.v1.ServerSentEventsRule)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> required_scopes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> filter_params_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tags_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr event_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_field_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_field_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr routing_key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr summary_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    int32_t keepalive_interval_seconds_;
    int32_t max_stream_duration_seconds_;
    bool auth_required_;
    bool json_encode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gateway_5fannotations_2eproto;
};
// -------------------------------------------------------------------

class LongPollingRule final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.gateway.v1.LongPollingRule) */ {
 public:
  inline LongPollingRule() : LongPollingRule(nullptr) {}
  ~LongPollingRule() override;
  explicit PROTOBUF_CONSTEXPR LongPollingRule(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LongPollingRule(const LongPollingRule& from);
  LongPollingRule(LongPollingRule&& from) noexcept
    : LongPollingRule() {
    *this = ::std::move(from);
  }

  inline LongPollingRule& operator=(const LongPollingRule& from) {
    CopyFrom(from);
    return *this;
  }
  inline LongPollingRule& operator=(LongPollingRule&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LongPollingRule& default_instance() {
    return *internal_default_instance();
  }
  static inline const LongPollingRule* internal_default_instance() {
    return reinterpret_cast<const LongPollingRule*>(
               &_LongPollingRule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(LongPollingRule& a, LongPollingRule& b) {
    a.Swap(&b);
  }
  inline void Swap(LongPollingRule* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LongPollingRule* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LongPollingRule* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LongPollingRule>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LongPollingRule& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LongPollingRule& from) {
    LongPollingRule::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LongPollingRule* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.gateway.v1.LongPollingRule";
  }
  protected:
  explicit LongPollingRule(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequiredScopesFieldNumber = 11,
    kTagsFieldNumber = 22,
    kPathFieldNumber = 1,
    kEventsFieldFieldNumber = 15,
    kCursorFieldFieldNumber = 16,
    kSummaryFieldNumber = 20,
    kDescriptionFieldNumber = 21,
    kTimeoutSecondsFieldNumber = 2,
    kMaxEventsFieldNumber = 3,
    kAuthRequiredFieldNumber = 10,
    kIncludeMetadataFieldNumber = 17,
  };
  // repeated string required_scopes = 11;
  int required_scopes_size() const;
  private:
  int _internal_required_scopes_size() const;
  public:
  void clear_required_scopes();
  const std::string& required_scopes(int index) const;
  std::string* mutable_required_scopes(int index);
  void set_required_scopes(int index, const std::string& value);
  void set_required_scopes(int index, std::string&& value);
  void set_required_scopes(int index, const char* value);
  void set_required_scopes(int index, const char* value, size_t size);
  std::string* add_required_scopes();
  void add_required_scopes(const std::string& value);
  void add_required_scopes(std::string&& value);
  void add_required_scopes(const char* value);
  void add_required_scopes(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& required_scopes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_required_scopes();
  private:
  const std::string& _internal_required_scopes(int index) const;
  std::string* _internal_add_required_scopes();
  public:

  // repeated string tags = 22;
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  const std::string& tags(int index) const;
  std::string* mutable_tags(int index);
  void set_tags(int index, const std::string& value);
  void set_tags(int index, std::string&& value);
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, size_t size);
  std::string* add_tags();
  void add_tags(const std::string& value);
  void add_tags(std::string&& value);
  void add_tags(const char* value);
  void add_tags(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tags();
  private:
  const std::string& _internal_tags(int index) const;
  std::string* _internal_add_tags();
  public:

  // string path = 1;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // string events_field = 15;
  void clear_events_field();
  const std::string& events_field() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_events_field(ArgT0&& arg0, ArgT... args);
  std::string* mutable_events_field();
  PROTOBUF_NODISCARD std::string* release_events_field();
  void set_allocated_events_field(std::string* events_field);
  private:
  const std::string& _internal_events_field() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_events_field(const std::string& value);
  std::string* _internal_mutable_events_field();
  public:

  // string cursor_field = 16;
  void clear_cursor_field();
  const std::string& cursor_field() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cursor_field(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cursor_field();
  PROTOBUF_NODISCARD std::string* release_cursor_field();
  void set_allocated_cursor_field(std::string* cursor_field);
  private:
  const std::string& _internal_cursor_field() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cursor_field(const std::string& value);
  std::string* _internal_mutable_cursor_field();
  public:

  // string summary = 20;
  void clear_summary();
  const std::string& summary() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_summary(ArgT0&& arg0, ArgT... args);
  std::string* mutable_summary();
  PROTOBUF_NODISCARD std::string* release_summary();
  void set_allocated_summary(std::string* summary);
  private:
  const std::string& _internal_summary() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_summary(const std::string& value);
  std::string* _internal_mutable_summary();
  public:

  // string description = 21;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // int32 timeout_seconds = 2;
  void clear_timeout_seconds();
  int32_t timeout_seconds() const;
  void set_timeout_seconds(int32_t value);
  private:
  int32_t _internal_timeout_seconds() const;
  void _internal_set_timeout_seconds(int32_t value);
  public:

  // int32 max_events = 3;
  void clear_max_events();
  int32_t max_events() const;
  void set_max_events(int32_t value);
  private:
  int32_t _internal_max_events() const;
  void _internal_set_max_events(int32_t value);
  public:

  // bool auth_required = 10;
  void clear_auth_required();
  bool auth_required() const;
  void set_auth_required(bool value);
  private:
  bool _internal_auth_required() const;
  void _internal_set_auth_required(bool value);
  public:

  // bool include_metadata = 17;
  void clear_include_metadata();
  bool include_metadata() const;
  void set_include_metadata(bool value);
  private:
  bool _internal_include_metadata() const;
  void _internal_set_include_metadata(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.gateway.v1.LongPollingRule)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> required_scopes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tags_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr events_field_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cursor_field_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr summary_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    int32_t timeout_seconds_;
    int32_t max_events_;
    bool auth_required_;
    bool include_metadata_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gateway_5fannotations_2eproto;
};
// -------------------------------------------------------------------

class ServiceRule final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.gateway.v1.ServiceRule) */ {
 public:
  inline ServiceRule() : ServiceRule(nullptr) {}
  ~ServiceRule() override;
  explicit PROTOBUF_CONSTEXPR ServiceRule(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServiceRule(const ServiceRule& from);
  ServiceRule(ServiceRule&& from) noexcept
    : ServiceRule() {
    *this = ::std::move(from);
  }

  inline ServiceRule& operator=(const ServiceRule& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServiceRule& operator=(ServiceRule&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServiceRule& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServiceRule* internal_default_instance() {
    return reinterpret_cast<const ServiceRule*>(
               &_ServiceRule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ServiceRule& a, ServiceRule& b) {
    a.Swap(&b);
  }
  inline void Swap(ServiceRule* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServiceRule* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServiceRule* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServiceRule>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServiceRule& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ServiceRule& from) {
    ServiceRule::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServiceRule* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.gateway.v1.ServiceRule";
  }
  protected:
  explicit ServiceRule(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDefaultScopesFieldNumber = 11,
    kTagsFieldNumber = 22,
    kBasePathFieldNumber = 1,
    kVersionFieldNumber = 2,
    kAuthProviderFieldNumber = 12,
    kTitleFieldNumber = 20,
    kDescriptionFieldNumber = 21,
    kContactEmailFieldNumber = 23,
    kLicenseFieldNumber = 24,
    kDefaultRateLimitFieldNumber = 15,
    kDefaultCorsFieldNumber = 16,
    kDefaultAuthRequiredFieldNumber = 10,
  };
  // repeated string default_scopes = 11;
  int default_scopes_size() const;
  private:
  int _internal_default_scopes_size() const;
  public:
  void clear_default_scopes();
  const std::string& default_scopes(int index) const;
  std::string* mutable_default_scopes(int index);
  void set_default_scopes(int index, const std::string& value);
  void set_default_scopes(int index, std::string&& value);
  void set_default_scopes(int index, const char* value);
  void set_default_scopes(int index, const char* value, size_t size);
  std::string* add_default_scopes();
  void add_default_scopes(const std::string& value);
  void add_default_scopes(std::string&& value);
  void add_default_scopes(const char* value);
  void add_default_scopes(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& default_scopes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_default_scopes();
  private:
  const std::string& _internal_default_scopes(int index) const;
  std::string* _internal_add_default_scopes();
  public:

  // repeated string tags = 22;
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  const std::string& tags(int index) const;
  std::string* mutable_tags(int index);
  void set_tags(int index, const std::string& value);
  void set_tags(int index, std::string&& value);
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, size_t size);
  std::string* add_tags();
  void add_tags(const std::string& value);
  void add_tags(std::string&& value);
  void add_tags(const char* value);
  void add_tags(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tags();
  private:
  const std::string& _internal_tags(int index) const;
  std::string* _internal_add_tags();
  public:

  // string base_path = 1;
  void clear_base_path();
  const std::string& base_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_base_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_base_path();
  PROTOBUF_NODISCARD std::string* release_base_path();
  void set_allocated_base_path(std::string* base_path);
  private:
  const std::string& _internal_base_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_base_path(const std::string& value);
  std::string* _internal_mutable_base_path();
  public:

  // string version = 2;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string auth_provider = 12;
  void clear_auth_provider();
  const std::string& auth_provider() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_auth_provider(ArgT0&& arg0, ArgT... args);
  std::string* mutable_auth_provider();
  PROTOBUF_NODISCARD std::string* release_auth_provider();
  void set_allocated_auth_provider(std::string* auth_provider);
  private:
  const std::string& _internal_auth_provider() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_auth_provider(const std::string& value);
  std::string* _internal_mutable_auth_provider();
  public:

  // string title = 20;
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // string description = 21;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string contact_email = 23;
  void clear_contact_email();
  const std::string& contact_email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contact_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contact_email();
  PROTOBUF_NODISCARD std::string* release_contact_email();
  void set_allocated_contact_email(std::string* contact_email);
  private:
  const std::string& _internal_contact_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contact_email(const std::string& value);
  std::string* _internal_mutable_contact_email();
  public:

  // string license = 24;
  void clear_license();
  const std::string& license() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_license(ArgT0&& arg0, ArgT... args);
  std::string* mutable_license();
  PROTOBUF_NODISCARD std::string* release_license();
  void set_allocated_license(std::string* license);
  private:
  const std::string& _internal_license() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_license(const std::string& value);
  std::string* _internal_mutable_license();
  public:

  // .unhinged.gateway.v1.RateLimitRule default_rate_limit = 15;
  bool has_default_rate_limit() const;
  private:
  bool _internal_has_default_rate_limit() const;
  public:
  void clear_default_rate_limit();
  const ::unhinged::gateway::v1::RateLimitRule& default_rate_limit() const;
  PROTOBUF_NODISCARD ::unhinged::gateway::v1::RateLimitRule* release_default_rate_limit();
  ::unhinged::gateway::v1::RateLimitRule* mutable_default_rate_limit();
  void set_allocated_default_rate_limit(::unhinged::gateway::v1::RateLimitRule* default_rate_limit);
  private:
  const ::unhinged::gateway::v1::RateLimitRule& _internal_default_rate_limit() const;
  ::unhinged::gateway::v1::RateLimitRule* _internal_mutable_default_rate_limit();
  public:
  void unsafe_arena_set_allocated_default_rate_limit(
      ::unhinged::gateway::v1::RateLimitRule* default_rate_limit);
  ::unhinged::gateway::v1::RateLimitRule* unsafe_arena_release_default_rate_limit();

  // .unhinged.gateway.v1.CorsRule default_cors = 16;
  bool has_default_cors() const;
  private:
  bool _internal_has_default_cors() const;
  public:
  void clear_default_cors();
  const ::unhinged::gateway::v1::CorsRule& default_cors() const;
  PROTOBUF_NODISCARD ::unhinged::gateway::v1::CorsRule* release_default_cors();
  ::unhinged::gateway::v1::CorsRule* mutable_default_cors();
  void set_allocated_default_cors(::unhinged::gateway::v1::CorsRule* default_cors);
  private:
  const ::unhinged::gateway::v1::CorsRule& _internal_default_cors() const;
  ::unhinged::gateway::v1::CorsRule* _internal_mutable_default_cors();
  public:
  void unsafe_arena_set_allocated_default_cors(
      ::unhinged::gateway::v1::CorsRule* default_cors);
  ::unhinged::gateway::v1::CorsRule* unsafe_arena_release_default_cors();

  // bool default_auth_required = 10;
  void clear_default_auth_required();
  bool default_auth_required() const;
  void set_default_auth_required(bool value);
  private:
  bool _internal_default_auth_required() const;
  void _internal_set_default_auth_required(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.gateway.v1.ServiceRule)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> default_scopes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tags_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr base_path_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr auth_provider_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contact_email_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr license_;
    ::unhinged::gateway::v1::RateLimitRule* default_rate_limit_;
    ::unhinged::gateway::v1::CorsRule* default_cors_;
    bool default_auth_required_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gateway_5fannotations_2eproto;
};
// ===================================================================

static const int kHttpFieldNumber = 50001;
extern ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::PROTOBUF_NAMESPACE_ID::MethodOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::MessageTypeTraits< ::unhinged::gateway::v1::HttpRule >, 11, false >
  http;
static const int kWebsocketFieldNumber = 50002;
extern ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::PROTOBUF_NAMESPACE_ID::MethodOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::MessageTypeTraits< ::unhinged::gateway::v1::WebSocketRule >, 11, false >
  websocket;
static const int kSseFieldNumber = 50003;
extern ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::PROTOBUF_NAMESPACE_ID::MethodOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::MessageTypeTraits< ::unhinged::gateway::v1::ServerSentEventsRule >, 11, false >
  sse;
static const int kLongPollingFieldNumber = 50004;
extern ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::PROTOBUF_NAMESPACE_ID::MethodOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::MessageTypeTraits< ::unhinged::gateway::v1::LongPollingRule >, 11, false >
  long_polling;
static const int kServiceFieldNumber = 50010;
extern ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::PROTOBUF_NAMESPACE_ID::ServiceOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::MessageTypeTraits< ::unhinged::gateway::v1::ServiceRule >, 11, false >
  service;
static const int kGatewayExcludeFieldNumber = 50020;
extern ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::PROTOBUF_NAMESPACE_ID::MessageOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::PrimitiveTypeTraits< bool >, 8, false >
  gateway_exclude;
static const int kJsonNameOverrideFieldNumber = 50021;
extern ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::PROTOBUF_NAMESPACE_ID::MessageOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::StringTypeTraits, 9, false >
  json_name_override;
static const int kPathParamFieldNumber = 50030;
extern ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::PROTOBUF_NAMESPACE_ID::FieldOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::PrimitiveTypeTraits< bool >, 8, false >
  path_param;
static const int kQueryParamFieldNumber = 50031;
extern ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::PROTOBUF_NAMESPACE_ID::FieldOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::PrimitiveTypeTraits< bool >, 8, false >
  query_param;
static const int kHeaderParamFieldNumber = 50032;
extern ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::PROTOBUF_NAMESPACE_ID::FieldOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::PrimitiveTypeTraits< bool >, 8, false >
  header_param;
static const int kParamNameFieldNumber = 50033;
extern ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::PROTOBUF_NAMESPACE_ID::FieldOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::StringTypeTraits, 9, false >
  param_name;
static const int kRequiredParamFieldNumber = 50034;
extern ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::PROTOBUF_NAMESPACE_ID::FieldOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::PrimitiveTypeTraits< bool >, 8, false >
  required_param;

// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// HttpRule

// string method = 1;
inline void HttpRule::clear_method() {
  _impl_.method_.ClearToEmpty();
}
inline const std::string& HttpRule::method() const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.HttpRule.method)
  return _internal_method();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HttpRule::set_method(ArgT0&& arg0, ArgT... args) {
 
 _impl_.method_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.HttpRule.method)
}
inline std::string* HttpRule::mutable_method() {
  std::string* _s = _internal_mutable_method();
  // @@protoc_insertion_point(field_mutable:unhinged.gateway.v1.HttpRule.method)
  return _s;
}
inline const std::string& HttpRule::_internal_method() const {
  return _impl_.method_.Get();
}
inline void HttpRule::_internal_set_method(const std::string& value) {
  
  _impl_.method_.Set(value, GetArenaForAllocation());
}
inline std::string* HttpRule::_internal_mutable_method() {
  
  return _impl_.method_.Mutable(GetArenaForAllocation());
}
inline std::string* HttpRule::release_method() {
  // @@protoc_insertion_point(field_release:unhinged.gateway.v1.HttpRule.method)
  return _impl_.method_.Release();
}
inline void HttpRule::set_allocated_method(std::string* method) {
  if (method != nullptr) {
    
  } else {
    
  }
  _impl_.method_.SetAllocated(method, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.method_.IsDefault()) {
    _impl_.method_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.gateway.v1.HttpRule.method)
}

// string path = 2;
inline void HttpRule::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& HttpRule::path() const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.HttpRule.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HttpRule::set_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.HttpRule.path)
}
inline std::string* HttpRule::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:unhinged.gateway.v1.HttpRule.path)
  return _s;
}
inline const std::string& HttpRule::_internal_path() const {
  return _impl_.path_.Get();
}
inline void HttpRule::_internal_set_path(const std::string& value) {
  
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* HttpRule::_internal_mutable_path() {
  
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* HttpRule::release_path() {
  // @@protoc_insertion_point(field_release:unhinged.gateway.v1.HttpRule.path)
  return _impl_.path_.Release();
}
inline void HttpRule::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.gateway.v1.HttpRule.path)
}

// string body = 3;
inline void HttpRule::clear_body() {
  _impl_.body_.ClearToEmpty();
}
inline const std::string& HttpRule::body() const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.HttpRule.body)
  return _internal_body();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HttpRule::set_body(ArgT0&& arg0, ArgT... args) {
 
 _impl_.body_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.HttpRule.body)
}
inline std::string* HttpRule::mutable_body() {
  std::string* _s = _internal_mutable_body();
  // @@protoc_insertion_point(field_mutable:unhinged.gateway.v1.HttpRule.body)
  return _s;
}
inline const std::string& HttpRule::_internal_body() const {
  return _impl_.body_.Get();
}
inline void HttpRule::_internal_set_body(const std::string& value) {
  
  _impl_.body_.Set(value, GetArenaForAllocation());
}
inline std::string* HttpRule::_internal_mutable_body() {
  
  return _impl_.body_.Mutable(GetArenaForAllocation());
}
inline std::string* HttpRule::release_body() {
  // @@protoc_insertion_point(field_release:unhinged.gateway.v1.HttpRule.body)
  return _impl_.body_.Release();
}
inline void HttpRule::set_allocated_body(std::string* body) {
  if (body != nullptr) {
    
  } else {
    
  }
  _impl_.body_.SetAllocated(body, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.body_.IsDefault()) {
    _impl_.body_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.gateway.v1.HttpRule.body)
}

// repeated string query_params = 4;
inline int HttpRule::_internal_query_params_size() const {
  return _impl_.query_params_.size();
}
inline int HttpRule::query_params_size() const {
  return _internal_query_params_size();
}
inline void HttpRule::clear_query_params() {
  _impl_.query_params_.Clear();
}
inline std::string* HttpRule::add_query_params() {
  std::string* _s = _internal_add_query_params();
  // @@protoc_insertion_point(field_add_mutable:unhinged.gateway.v1.HttpRule.query_params)
  return _s;
}
inline const std::string& HttpRule::_internal_query_params(int index) const {
  return _impl_.query_params_.Get(index);
}
inline const std::string& HttpRule::query_params(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.HttpRule.query_params)
  return _internal_query_params(index);
}
inline std::string* HttpRule::mutable_query_params(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.gateway.v1.HttpRule.query_params)
  return _impl_.query_params_.Mutable(index);
}
inline void HttpRule::set_query_params(int index, const std::string& value) {
  _impl_.query_params_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.HttpRule.query_params)
}
inline void HttpRule::set_query_params(int index, std::string&& value) {
  _impl_.query_params_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.HttpRule.query_params)
}
inline void HttpRule::set_query_params(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.query_params_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.gateway.v1.HttpRule.query_params)
}
inline void HttpRule::set_query_params(int index, const char* value, size_t size) {
  _impl_.query_params_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.gateway.v1.HttpRule.query_params)
}
inline std::string* HttpRule::_internal_add_query_params() {
  return _impl_.query_params_.Add();
}
inline void HttpRule::add_query_params(const std::string& value) {
  _impl_.query_params_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.gateway.v1.HttpRule.query_params)
}
inline void HttpRule::add_query_params(std::string&& value) {
  _impl_.query_params_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.gateway.v1.HttpRule.query_params)
}
inline void HttpRule::add_query_params(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.query_params_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.gateway.v1.HttpRule.query_params)
}
inline void HttpRule::add_query_params(const char* value, size_t size) {
  _impl_.query_params_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.gateway.v1.HttpRule.query_params)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
HttpRule::query_params() const {
  // @@protoc_insertion_point(field_list:unhinged.gateway.v1.HttpRule.query_params)
  return _impl_.query_params_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
HttpRule::mutable_query_params() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.gateway.v1.HttpRule.query_params)
  return &_impl_.query_params_;
}

// bool stream_response = 5;
inline void HttpRule::clear_stream_response() {
  _impl_.stream_response_ = false;
}
inline bool HttpRule::_internal_stream_response() const {
  return _impl_.stream_response_;
}
inline bool HttpRule::stream_response() const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.HttpRule.stream_response)
  return _internal_stream_response();
}
inline void HttpRule::_internal_set_stream_response(bool value) {
  
  _impl_.stream_response_ = value;
}
inline void HttpRule::set_stream_response(bool value) {
  _internal_set_stream_response(value);
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.HttpRule.stream_response)
}

// string response_wrapper = 6;
inline void HttpRule::clear_response_wrapper() {
  _impl_.response_wrapper_.ClearToEmpty();
}
inline const std::string& HttpRule::response_wrapper() const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.HttpRule.response_wrapper)
  return _internal_response_wrapper();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HttpRule::set_response_wrapper(ArgT0&& arg0, ArgT... args) {
 
 _impl_.response_wrapper_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.HttpRule.response_wrapper)
}
inline std::string* HttpRule::mutable_response_wrapper() {
  std::string* _s = _internal_mutable_response_wrapper();
  // @@protoc_insertion_point(field_mutable:unhinged.gateway.v1.HttpRule.response_wrapper)
  return _s;
}
inline const std::string& HttpRule::_internal_response_wrapper() const {
  return _impl_.response_wrapper_.Get();
}
inline void HttpRule::_internal_set_response_wrapper(const std::string& value) {
  
  _impl_.response_wrapper_.Set(value, GetArenaForAllocation());
}
inline std::string* HttpRule::_internal_mutable_response_wrapper() {
  
  return _impl_.response_wrapper_.Mutable(GetArenaForAllocation());
}
inline std::string* HttpRule::release_response_wrapper() {
  // @@protoc_insertion_point(field_release:unhinged.gateway.v1.HttpRule.response_wrapper)
  return _impl_.response_wrapper_.Release();
}
inline void HttpRule::set_allocated_response_wrapper(std::string* response_wrapper) {
  if (response_wrapper != nullptr) {
    
  } else {
    
  }
  _impl_.response_wrapper_.SetAllocated(response_wrapper, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.response_wrapper_.IsDefault()) {
    _impl_.response_wrapper_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.gateway.v1.HttpRule.response_wrapper)
}

// bool auth_required = 10;
inline void HttpRule::clear_auth_required() {
  _impl_.auth_required_ = false;
}
inline bool HttpRule::_internal_auth_required() const {
  return _impl_.auth_required_;
}
inline bool HttpRule::auth_required() const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.HttpRule.auth_required)
  return _internal_auth_required();
}
inline void HttpRule::_internal_set_auth_required(bool value) {
  
  _impl_.auth_required_ = value;
}
inline void HttpRule::set_auth_required(bool value) {
  _internal_set_auth_required(value);
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.HttpRule.auth_required)
}

// repeated string required_scopes = 11;
inline int HttpRule::_internal_required_scopes_size() const {
  return _impl_.required_scopes_.size();
}
inline int HttpRule::required_scopes_size() const {
  return _internal_required_scopes_size();
}
inline void HttpRule::clear_required_scopes() {
  _impl_.required_scopes_.Clear();
}
inline std::string* HttpRule::add_required_scopes() {
  std::string* _s = _internal_add_required_scopes();
  // @@protoc_insertion_point(field_add_mutable:unhinged.gateway.v1.HttpRule.required_scopes)
  return _s;
}
inline const std::string& HttpRule::_internal_required_scopes(int index) const {
  return _impl_.required_scopes_.Get(index);
}
inline const std::string& HttpRule::required_scopes(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.HttpRule.required_scopes)
  return _internal_required_scopes(index);
}
inline std::string* HttpRule::mutable_required_scopes(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.gateway.v1.HttpRule.required_scopes)
  return _impl_.required_scopes_.Mutable(index);
}
inline void HttpRule::set_required_scopes(int index, const std::string& value) {
  _impl_.required_scopes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.HttpRule.required_scopes)
}
inline void HttpRule::set_required_scopes(int index, std::string&& value) {
  _impl_.required_scopes_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.HttpRule.required_scopes)
}
inline void HttpRule::set_required_scopes(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.required_scopes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.gateway.v1.HttpRule.required_scopes)
}
inline void HttpRule::set_required_scopes(int index, const char* value, size_t size) {
  _impl_.required_scopes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.gateway.v1.HttpRule.required_scopes)
}
inline std::string* HttpRule::_internal_add_required_scopes() {
  return _impl_.required_scopes_.Add();
}
inline void HttpRule::add_required_scopes(const std::string& value) {
  _impl_.required_scopes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.gateway.v1.HttpRule.required_scopes)
}
inline void HttpRule::add_required_scopes(std::string&& value) {
  _impl_.required_scopes_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.gateway.v1.HttpRule.required_scopes)
}
inline void HttpRule::add_required_scopes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.required_scopes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.gateway.v1.HttpRule.required_scopes)
}
inline void HttpRule::add_required_scopes(const char* value, size_t size) {
  _impl_.required_scopes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.gateway.v1.HttpRule.required_scopes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
HttpRule::required_scopes() const {
  // @@protoc_insertion_point(field_list:unhinged.gateway.v1.HttpRule.required_scopes)
  return _impl_.required_scopes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
HttpRule::mutable_required_scopes() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.gateway.v1.HttpRule.required_scopes)
  return &_impl_.required_scopes_;
}

// string auth_type = 12;
inline void HttpRule::clear_auth_type() {
  _impl_.auth_type_.ClearToEmpty();
}
inline const std::string& HttpRule::auth_type() const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.HttpRule.auth_type)
  return _internal_auth_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HttpRule::set_auth_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.auth_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.HttpRule.auth_type)
}
inline std::string* HttpRule::mutable_auth_type() {
  std::string* _s = _internal_mutable_auth_type();
  // @@protoc_insertion_point(field_mutable:unhinged.gateway.v1.HttpRule.auth_type)
  return _s;
}
inline const std::string& HttpRule::_internal_auth_type() const {
  return _impl_.auth_type_.Get();
}
inline void HttpRule::_internal_set_auth_type(const std::string& value) {
  
  _impl_.auth_type_.Set(value, GetArenaForAllocation());
}
inline std::string* HttpRule::_internal_mutable_auth_type() {
  
  return _impl_.auth_type_.Mutable(GetArenaForAllocation());
}
inline std::string* HttpRule::release_auth_type() {
  // @@protoc_insertion_point(field_release:unhinged.gateway.v1.HttpRule.auth_type)
  return _impl_.auth_type_.Release();
}
inline void HttpRule::set_allocated_auth_type(std::string* auth_type) {
  if (auth_type != nullptr) {
    
  } else {
    
  }
  _impl_.auth_type_.SetAllocated(auth_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.auth_type_.IsDefault()) {
    _impl_.auth_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.gateway.v1.HttpRule.auth_type)
}

// .unhinged.gateway.v1.RateLimitRule rate_limit = 15;
inline bool HttpRule::_internal_has_rate_limit() const {
  return this != internal_default_instance() && _impl_.rate_limit_ != nullptr;
}
inline bool HttpRule::has_rate_limit() const {
  return _internal_has_rate_limit();
}
inline void HttpRule::clear_rate_limit() {
  if (GetArenaForAllocation() == nullptr && _impl_.rate_limit_ != nullptr) {
    delete _impl_.rate_limit_;
  }
  _impl_.rate_limit_ = nullptr;
}
inline const ::unhinged::gateway::v1::RateLimitRule& HttpRule::_internal_rate_limit() const {
  const ::unhinged::gateway::v1::RateLimitRule* p = _impl_.rate_limit_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::gateway::v1::RateLimitRule&>(
      ::unhinged::gateway::v1::_RateLimitRule_default_instance_);
}
inline const ::unhinged::gateway::v1::RateLimitRule& HttpRule::rate_limit() const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.HttpRule.rate_limit)
  return _internal_rate_limit();
}
inline void HttpRule::unsafe_arena_set_allocated_rate_limit(
    ::unhinged::gateway::v1::RateLimitRule* rate_limit) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rate_limit_);
  }
  _impl_.rate_limit_ = rate_limit;
  if (rate_limit) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.gateway.v1.HttpRule.rate_limit)
}
inline ::unhinged::gateway::v1::RateLimitRule* HttpRule::release_rate_limit() {
  
  ::unhinged::gateway::v1::RateLimitRule* temp = _impl_.rate_limit_;
  _impl_.rate_limit_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::gateway::v1::RateLimitRule* HttpRule::unsafe_arena_release_rate_limit() {
  // @@protoc_insertion_point(field_release:unhinged.gateway.v1.HttpRule.rate_limit)
  
  ::unhinged::gateway::v1::RateLimitRule* temp = _impl_.rate_limit_;
  _impl_.rate_limit_ = nullptr;
  return temp;
}
inline ::unhinged::gateway::v1::RateLimitRule* HttpRule::_internal_mutable_rate_limit() {
  
  if (_impl_.rate_limit_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::gateway::v1::RateLimitRule>(GetArenaForAllocation());
    _impl_.rate_limit_ = p;
  }
  return _impl_.rate_limit_;
}
inline ::unhinged::gateway::v1::RateLimitRule* HttpRule::mutable_rate_limit() {
  ::unhinged::gateway::v1::RateLimitRule* _msg = _internal_mutable_rate_limit();
  // @@protoc_insertion_point(field_mutable:unhinged.gateway.v1.HttpRule.rate_limit)
  return _msg;
}
inline void HttpRule::set_allocated_rate_limit(::unhinged::gateway::v1::RateLimitRule* rate_limit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rate_limit_;
  }
  if (rate_limit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rate_limit);
    if (message_arena != submessage_arena) {
      rate_limit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rate_limit, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.rate_limit_ = rate_limit;
  // @@protoc_insertion_point(field_set_allocated:unhinged.gateway.v1.HttpRule.rate_limit)
}

// .unhinged.gateway.v1.CacheRule cache = 16;
inline bool HttpRule::_internal_has_cache() const {
  return this != internal_default_instance() && _impl_.cache_ != nullptr;
}
inline bool HttpRule::has_cache() const {
  return _internal_has_cache();
}
inline void HttpRule::clear_cache() {
  if (GetArenaForAllocation() == nullptr && _impl_.cache_ != nullptr) {
    delete _impl_.cache_;
  }
  _impl_.cache_ = nullptr;
}
inline const ::unhinged::gateway::v1::CacheRule& HttpRule::_internal_cache() const {
  const ::unhinged::gateway::v1::CacheRule* p = _impl_.cache_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::gateway::v1::CacheRule&>(
      ::unhinged::gateway::v1::_CacheRule_default_instance_);
}
inline const ::unhinged::gateway::v1::CacheRule& HttpRule::cache() const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.HttpRule.cache)
  return _internal_cache();
}
inline void HttpRule::unsafe_arena_set_allocated_cache(
    ::unhinged::gateway::v1::CacheRule* cache) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cache_);
  }
  _impl_.cache_ = cache;
  if (cache) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.gateway.v1.HttpRule.cache)
}
inline ::unhinged::gateway::v1::CacheRule* HttpRule::release_cache() {
  
  ::unhinged::gateway::v1::CacheRule* temp = _impl_.cache_;
  _impl_.cache_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::gateway::v1::CacheRule* HttpRule::unsafe_arena_release_cache() {
  // @@protoc_insertion_point(field_release:unhinged.gateway.v1.HttpRule.cache)
  
  ::unhinged::gateway::v1::CacheRule* temp = _impl_.cache_;
  _impl_.cache_ = nullptr;
  return temp;
}
inline ::unhinged::gateway::v1::CacheRule* HttpRule::_internal_mutable_cache() {
  
  if (_impl_.cache_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::gateway::v1::CacheRule>(GetArenaForAllocation());
    _impl_.cache_ = p;
  }
  return _impl_.cache_;
}
inline ::unhinged::gateway::v1::CacheRule* HttpRule::mutable_cache() {
  ::unhinged::gateway::v1::CacheRule* _msg = _internal_mutable_cache();
  // @@protoc_insertion_point(field_mutable:unhinged.gateway.v1.HttpRule.cache)
  return _msg;
}
inline void HttpRule::set_allocated_cache(::unhinged::gateway::v1::CacheRule* cache) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cache_;
  }
  if (cache) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cache);
    if (message_arena != submessage_arena) {
      cache = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cache, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.cache_ = cache;
  // @@protoc_insertion_point(field_set_allocated:unhinged.gateway.v1.HttpRule.cache)
}

// .unhinged.gateway.v1.CorsRule cors = 17;
inline bool HttpRule::_internal_has_cors() const {
  return this != internal_default_instance() && _impl_.cors_ != nullptr;
}
inline bool HttpRule::has_cors() const {
  return _internal_has_cors();
}
inline void HttpRule::clear_cors() {
  if (GetArenaForAllocation() == nullptr && _impl_.cors_ != nullptr) {
    delete _impl_.cors_;
  }
  _impl_.cors_ = nullptr;
}
inline const ::unhinged::gateway::v1::CorsRule& HttpRule::_internal_cors() const {
  const ::unhinged::gateway::v1::CorsRule* p = _impl_.cors_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::gateway::v1::CorsRule&>(
      ::unhinged::gateway::v1::_CorsRule_default_instance_);
}
inline const ::unhinged::gateway::v1::CorsRule& HttpRule::cors() const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.HttpRule.cors)
  return _internal_cors();
}
inline void HttpRule::unsafe_arena_set_allocated_cors(
    ::unhinged::gateway::v1::CorsRule* cors) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cors_);
  }
  _impl_.cors_ = cors;
  if (cors) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.gateway.v1.HttpRule.cors)
}
inline ::unhinged::gateway::v1::CorsRule* HttpRule::release_cors() {
  
  ::unhinged::gateway::v1::CorsRule* temp = _impl_.cors_;
  _impl_.cors_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::gateway::v1::CorsRule* HttpRule::unsafe_arena_release_cors() {
  // @@protoc_insertion_point(field_release:unhinged.gateway.v1.HttpRule.cors)
  
  ::unhinged::gateway::v1::CorsRule* temp = _impl_.cors_;
  _impl_.cors_ = nullptr;
  return temp;
}
inline ::unhinged::gateway::v1::CorsRule* HttpRule::_internal_mutable_cors() {
  
  if (_impl_.cors_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::gateway::v1::CorsRule>(GetArenaForAllocation());
    _impl_.cors_ = p;
  }
  return _impl_.cors_;
}
inline ::unhinged::gateway::v1::CorsRule* HttpRule::mutable_cors() {
  ::unhinged::gateway::v1::CorsRule* _msg = _internal_mutable_cors();
  // @@protoc_insertion_point(field_mutable:unhinged.gateway.v1.HttpRule.cors)
  return _msg;
}
inline void HttpRule::set_allocated_cors(::unhinged::gateway::v1::CorsRule* cors) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cors_;
  }
  if (cors) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cors);
    if (message_arena != submessage_arena) {
      cors = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cors, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.cors_ = cors;
  // @@protoc_insertion_point(field_set_allocated:unhinged.gateway.v1.HttpRule.cors)
}

// string summary = 20;
inline void HttpRule::clear_summary() {
  _impl_.summary_.ClearToEmpty();
}
inline const std::string& HttpRule::summary() const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.HttpRule.summary)
  return _internal_summary();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HttpRule::set_summary(ArgT0&& arg0, ArgT... args) {
 
 _impl_.summary_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.HttpRule.summary)
}
inline std::string* HttpRule::mutable_summary() {
  std::string* _s = _internal_mutable_summary();
  // @@protoc_insertion_point(field_mutable:unhinged.gateway.v1.HttpRule.summary)
  return _s;
}
inline const std::string& HttpRule::_internal_summary() const {
  return _impl_.summary_.Get();
}
inline void HttpRule::_internal_set_summary(const std::string& value) {
  
  _impl_.summary_.Set(value, GetArenaForAllocation());
}
inline std::string* HttpRule::_internal_mutable_summary() {
  
  return _impl_.summary_.Mutable(GetArenaForAllocation());
}
inline std::string* HttpRule::release_summary() {
  // @@protoc_insertion_point(field_release:unhinged.gateway.v1.HttpRule.summary)
  return _impl_.summary_.Release();
}
inline void HttpRule::set_allocated_summary(std::string* summary) {
  if (summary != nullptr) {
    
  } else {
    
  }
  _impl_.summary_.SetAllocated(summary, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.summary_.IsDefault()) {
    _impl_.summary_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.gateway.v1.HttpRule.summary)
}

// string description = 21;
inline void HttpRule::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& HttpRule::description() const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.HttpRule.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HttpRule::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.HttpRule.description)
}
inline std::string* HttpRule::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:unhinged.gateway.v1.HttpRule.description)
  return _s;
}
inline const std::string& HttpRule::_internal_description() const {
  return _impl_.description_.Get();
}
inline void HttpRule::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* HttpRule::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* HttpRule::release_description() {
  // @@protoc_insertion_point(field_release:unhinged.gateway.v1.HttpRule.description)
  return _impl_.description_.Release();
}
inline void HttpRule::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.gateway.v1.HttpRule.description)
}

// repeated string tags = 22;
inline int HttpRule::_internal_tags_size() const {
  return _impl_.tags_.size();
}
inline int HttpRule::tags_size() const {
  return _internal_tags_size();
}
inline void HttpRule::clear_tags() {
  _impl_.tags_.Clear();
}
inline std::string* HttpRule::add_tags() {
  std::string* _s = _internal_add_tags();
  // @@protoc_insertion_point(field_add_mutable:unhinged.gateway.v1.HttpRule.tags)
  return _s;
}
inline const std::string& HttpRule::_internal_tags(int index) const {
  return _impl_.tags_.Get(index);
}
inline const std::string& HttpRule::tags(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.HttpRule.tags)
  return _internal_tags(index);
}
inline std::string* HttpRule::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.gateway.v1.HttpRule.tags)
  return _impl_.tags_.Mutable(index);
}
inline void HttpRule::set_tags(int index, const std::string& value) {
  _impl_.tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.HttpRule.tags)
}
inline void HttpRule::set_tags(int index, std::string&& value) {
  _impl_.tags_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.HttpRule.tags)
}
inline void HttpRule::set_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.gateway.v1.HttpRule.tags)
}
inline void HttpRule::set_tags(int index, const char* value, size_t size) {
  _impl_.tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.gateway.v1.HttpRule.tags)
}
inline std::string* HttpRule::_internal_add_tags() {
  return _impl_.tags_.Add();
}
inline void HttpRule::add_tags(const std::string& value) {
  _impl_.tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.gateway.v1.HttpRule.tags)
}
inline void HttpRule::add_tags(std::string&& value) {
  _impl_.tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.gateway.v1.HttpRule.tags)
}
inline void HttpRule::add_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.gateway.v1.HttpRule.tags)
}
inline void HttpRule::add_tags(const char* value, size_t size) {
  _impl_.tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.gateway.v1.HttpRule.tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
HttpRule::tags() const {
  // @@protoc_insertion_point(field_list:unhinged.gateway.v1.HttpRule.tags)
  return _impl_.tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
HttpRule::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.gateway.v1.HttpRule.tags)
  return &_impl_.tags_;
}

// -------------------------------------------------------------------

// RateLimitRule

// int32 requests_per_minute = 1;
inline void RateLimitRule::clear_requests_per_minute() {
  _impl_.requests_per_minute_ = 0;
}
inline int32_t RateLimitRule::_internal_requests_per_minute() const {
  return _impl_.requests_per_minute_;
}
inline int32_t RateLimitRule::requests_per_minute() const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.RateLimitRule.requests_per_minute)
  return _internal_requests_per_minute();
}
inline void RateLimitRule::_internal_set_requests_per_minute(int32_t value) {
  
  _impl_.requests_per_minute_ = value;
}
inline void RateLimitRule::set_requests_per_minute(int32_t value) {
  _internal_set_requests_per_minute(value);
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.RateLimitRule.requests_per_minute)
}

// int32 requests_per_hour = 2;
inline void RateLimitRule::clear_requests_per_hour() {
  _impl_.requests_per_hour_ = 0;
}
inline int32_t RateLimitRule::_internal_requests_per_hour() const {
  return _impl_.requests_per_hour_;
}
inline int32_t RateLimitRule::requests_per_hour() const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.RateLimitRule.requests_per_hour)
  return _internal_requests_per_hour();
}
inline void RateLimitRule::_internal_set_requests_per_hour(int32_t value) {
  
  _impl_.requests_per_hour_ = value;
}
inline void RateLimitRule::set_requests_per_hour(int32_t value) {
  _internal_set_requests_per_hour(value);
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.RateLimitRule.requests_per_hour)
}

// int32 requests_per_day = 3;
inline void RateLimitRule::clear_requests_per_day() {
  _impl_.requests_per_day_ = 0;
}
inline int32_t RateLimitRule::_internal_requests_per_day() const {
  return _impl_.requests_per_day_;
}
inline int32_t RateLimitRule::requests_per_day() const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.RateLimitRule.requests_per_day)
  return _internal_requests_per_day();
}
inline void RateLimitRule::_internal_set_requests_per_day(int32_t value) {
  
  _impl_.requests_per_day_ = value;
}
inline void RateLimitRule::set_requests_per_day(int32_t value) {
  _internal_set_requests_per_day(value);
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.RateLimitRule.requests_per_day)
}

// string key_strategy = 4;
inline void RateLimitRule::clear_key_strategy() {
  _impl_.key_strategy_.ClearToEmpty();
}
inline const std::string& RateLimitRule::key_strategy() const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.RateLimitRule.key_strategy)
  return _internal_key_strategy();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RateLimitRule::set_key_strategy(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_strategy_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.RateLimitRule.key_strategy)
}
inline std::string* RateLimitRule::mutable_key_strategy() {
  std::string* _s = _internal_mutable_key_strategy();
  // @@protoc_insertion_point(field_mutable:unhinged.gateway.v1.RateLimitRule.key_strategy)
  return _s;
}
inline const std::string& RateLimitRule::_internal_key_strategy() const {
  return _impl_.key_strategy_.Get();
}
inline void RateLimitRule::_internal_set_key_strategy(const std::string& value) {
  
  _impl_.key_strategy_.Set(value, GetArenaForAllocation());
}
inline std::string* RateLimitRule::_internal_mutable_key_strategy() {
  
  return _impl_.key_strategy_.Mutable(GetArenaForAllocation());
}
inline std::string* RateLimitRule::release_key_strategy() {
  // @@protoc_insertion_point(field_release:unhinged.gateway.v1.RateLimitRule.key_strategy)
  return _impl_.key_strategy_.Release();
}
inline void RateLimitRule::set_allocated_key_strategy(std::string* key_strategy) {
  if (key_strategy != nullptr) {
    
  } else {
    
  }
  _impl_.key_strategy_.SetAllocated(key_strategy, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_strategy_.IsDefault()) {
    _impl_.key_strategy_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.gateway.v1.RateLimitRule.key_strategy)
}

// string custom_key_field = 5;
inline void RateLimitRule::clear_custom_key_field() {
  _impl_.custom_key_field_.ClearToEmpty();
}
inline const std::string& RateLimitRule::custom_key_field() const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.RateLimitRule.custom_key_field)
  return _internal_custom_key_field();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RateLimitRule::set_custom_key_field(ArgT0&& arg0, ArgT... args) {
 
 _impl_.custom_key_field_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.RateLimitRule.custom_key_field)
}
inline std::string* RateLimitRule::mutable_custom_key_field() {
  std::string* _s = _internal_mutable_custom_key_field();
  // @@protoc_insertion_point(field_mutable:unhinged.gateway.v1.RateLimitRule.custom_key_field)
  return _s;
}
inline const std::string& RateLimitRule::_internal_custom_key_field() const {
  return _impl_.custom_key_field_.Get();
}
inline void RateLimitRule::_internal_set_custom_key_field(const std::string& value) {
  
  _impl_.custom_key_field_.Set(value, GetArenaForAllocation());
}
inline std::string* RateLimitRule::_internal_mutable_custom_key_field() {
  
  return _impl_.custom_key_field_.Mutable(GetArenaForAllocation());
}
inline std::string* RateLimitRule::release_custom_key_field() {
  // @@protoc_insertion_point(field_release:unhinged.gateway.v1.RateLimitRule.custom_key_field)
  return _impl_.custom_key_field_.Release();
}
inline void RateLimitRule::set_allocated_custom_key_field(std::string* custom_key_field) {
  if (custom_key_field != nullptr) {
    
  } else {
    
  }
  _impl_.custom_key_field_.SetAllocated(custom_key_field, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.custom_key_field_.IsDefault()) {
    _impl_.custom_key_field_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.gateway.v1.RateLimitRule.custom_key_field)
}

// -------------------------------------------------------------------

// CacheRule

// int32 ttl_seconds = 1;
inline void CacheRule::clear_ttl_seconds() {
  _impl_.ttl_seconds_ = 0;
}
inline int32_t CacheRule::_internal_ttl_seconds() const {
  return _impl_.ttl_seconds_;
}
inline int32_t CacheRule::ttl_seconds() const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.CacheRule.ttl_seconds)
  return _internal_ttl_seconds();
}
inline void CacheRule::_internal_set_ttl_seconds(int32_t value) {
  
  _impl_.ttl_seconds_ = value;
}
inline void CacheRule::set_ttl_seconds(int32_t value) {
  _internal_set_ttl_seconds(value);
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.CacheRule.ttl_seconds)
}

// repeated string cache_keys = 2;
inline int CacheRule::_internal_cache_keys_size() const {
  return _impl_.cache_keys_.size();
}
inline int CacheRule::cache_keys_size() const {
  return _internal_cache_keys_size();
}
inline void CacheRule::clear_cache_keys() {
  _impl_.cache_keys_.Clear();
}
inline std::string* CacheRule::add_cache_keys() {
  std::string* _s = _internal_add_cache_keys();
  // @@protoc_insertion_point(field_add_mutable:unhinged.gateway.v1.CacheRule.cache_keys)
  return _s;
}
inline const std::string& CacheRule::_internal_cache_keys(int index) const {
  return _impl_.cache_keys_.Get(index);
}
inline const std::string& CacheRule::cache_keys(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.CacheRule.cache_keys)
  return _internal_cache_keys(index);
}
inline std::string* CacheRule::mutable_cache_keys(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.gateway.v1.CacheRule.cache_keys)
  return _impl_.cache_keys_.Mutable(index);
}
inline void CacheRule::set_cache_keys(int index, const std::string& value) {
  _impl_.cache_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.CacheRule.cache_keys)
}
inline void CacheRule::set_cache_keys(int index, std::string&& value) {
  _impl_.cache_keys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.CacheRule.cache_keys)
}
inline void CacheRule::set_cache_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.cache_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.gateway.v1.CacheRule.cache_keys)
}
inline void CacheRule::set_cache_keys(int index, const char* value, size_t size) {
  _impl_.cache_keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.gateway.v1.CacheRule.cache_keys)
}
inline std::string* CacheRule::_internal_add_cache_keys() {
  return _impl_.cache_keys_.Add();
}
inline void CacheRule::add_cache_keys(const std::string& value) {
  _impl_.cache_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.gateway.v1.CacheRule.cache_keys)
}
inline void CacheRule::add_cache_keys(std::string&& value) {
  _impl_.cache_keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.gateway.v1.CacheRule.cache_keys)
}
inline void CacheRule::add_cache_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.cache_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.gateway.v1.CacheRule.cache_keys)
}
inline void CacheRule::add_cache_keys(const char* value, size_t size) {
  _impl_.cache_keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.gateway.v1.CacheRule.cache_keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CacheRule::cache_keys() const {
  // @@protoc_insertion_point(field_list:unhinged.gateway.v1.CacheRule.cache_keys)
  return _impl_.cache_keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CacheRule::mutable_cache_keys() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.gateway.v1.CacheRule.cache_keys)
  return &_impl_.cache_keys_;
}

// bool private_cache = 3;
inline void CacheRule::clear_private_cache() {
  _impl_.private_cache_ = false;
}
inline bool CacheRule::_internal_private_cache() const {
  return _impl_.private_cache_;
}
inline bool CacheRule::private_cache() const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.CacheRule.private_cache)
  return _internal_private_cache();
}
inline void CacheRule::_internal_set_private_cache(bool value) {
  
  _impl_.private_cache_ = value;
}
inline void CacheRule::set_private_cache(bool value) {
  _internal_set_private_cache(value);
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.CacheRule.private_cache)
}

// repeated string vary_headers = 4;
inline int CacheRule::_internal_vary_headers_size() const {
  return _impl_.vary_headers_.size();
}
inline int CacheRule::vary_headers_size() const {
  return _internal_vary_headers_size();
}
inline void CacheRule::clear_vary_headers() {
  _impl_.vary_headers_.Clear();
}
inline std::string* CacheRule::add_vary_headers() {
  std::string* _s = _internal_add_vary_headers();
  // @@protoc_insertion_point(field_add_mutable:unhinged.gateway.v1.CacheRule.vary_headers)
  return _s;
}
inline const std::string& CacheRule::_internal_vary_headers(int index) const {
  return _impl_.vary_headers_.Get(index);
}
inline const std::string& CacheRule::vary_headers(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.CacheRule.vary_headers)
  return _internal_vary_headers(index);
}
inline std::string* CacheRule::mutable_vary_headers(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.gateway.v1.CacheRule.vary_headers)
  return _impl_.vary_headers_.Mutable(index);
}
inline void CacheRule::set_vary_headers(int index, const std::string& value) {
  _impl_.vary_headers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.CacheRule.vary_headers)
}
inline void CacheRule::set_vary_headers(int index, std::string&& value) {
  _impl_.vary_headers_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.CacheRule.vary_headers)
}
inline void CacheRule::set_vary_headers(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.vary_headers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.gateway.v1.CacheRule.vary_headers)
}
inline void CacheRule::set_vary_headers(int index, const char* value, size_t size) {
  _impl_.vary_headers_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.gateway.v1.CacheRule.vary_headers)
}
inline std::string* CacheRule::_internal_add_vary_headers() {
  return _impl_.vary_headers_.Add();
}
inline void CacheRule::add_vary_headers(const std::string& value) {
  _impl_.vary_headers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.gateway.v1.CacheRule.vary_headers)
}
inline void CacheRule::add_vary_headers(std::string&& value) {
  _impl_.vary_headers_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.gateway.v1.CacheRule.vary_headers)
}
inline void CacheRule::add_vary_headers(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.vary_headers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.gateway.v1.CacheRule.vary_headers)
}
inline void CacheRule::add_vary_headers(const char* value, size_t size) {
  _impl_.vary_headers_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.gateway.v1.CacheRule.vary_headers)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CacheRule::vary_headers() const {
  // @@protoc_insertion_point(field_list:unhinged.gateway.v1.CacheRule.vary_headers)
  return _impl_.vary_headers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CacheRule::mutable_vary_headers() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.gateway.v1.CacheRule.vary_headers)
  return &_impl_.vary_headers_;
}

// -------------------------------------------------------------------

// CorsRule

// repeated string allowed_origins = 1;
inline int CorsRule::_internal_allowed_origins_size() const {
  return _impl_.allowed_origins_.size();
}
inline int CorsRule::allowed_origins_size() const {
  return _internal_allowed_origins_size();
}
inline void CorsRule::clear_allowed_origins() {
  _impl_.allowed_origins_.Clear();
}
inline std::string* CorsRule::add_allowed_origins() {
  std::string* _s = _internal_add_allowed_origins();
  // @@protoc_insertion_point(field_add_mutable:unhinged.gateway.v1.CorsRule.allowed_origins)
  return _s;
}
inline const std::string& CorsRule::_internal_allowed_origins(int index) const {
  return _impl_.allowed_origins_.Get(index);
}
inline const std::string& CorsRule::allowed_origins(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.CorsRule.allowed_origins)
  return _internal_allowed_origins(index);
}
inline std::string* CorsRule::mutable_allowed_origins(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.gateway.v1.CorsRule.allowed_origins)
  return _impl_.allowed_origins_.Mutable(index);
}
inline void CorsRule::set_allowed_origins(int index, const std::string& value) {
  _impl_.allowed_origins_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.CorsRule.allowed_origins)
}
inline void CorsRule::set_allowed_origins(int index, std::string&& value) {
  _impl_.allowed_origins_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.CorsRule.allowed_origins)
}
inline void CorsRule::set_allowed_origins(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.allowed_origins_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.gateway.v1.CorsRule.allowed_origins)
}
inline void CorsRule::set_allowed_origins(int index, const char* value, size_t size) {
  _impl_.allowed_origins_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.gateway.v1.CorsRule.allowed_origins)
}
inline std::string* CorsRule::_internal_add_allowed_origins() {
  return _impl_.allowed_origins_.Add();
}
inline void CorsRule::add_allowed_origins(const std::string& value) {
  _impl_.allowed_origins_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.gateway.v1.CorsRule.allowed_origins)
}
inline void CorsRule::add_allowed_origins(std::string&& value) {
  _impl_.allowed_origins_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.gateway.v1.CorsRule.allowed_origins)
}
inline void CorsRule::add_allowed_origins(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.allowed_origins_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.gateway.v1.CorsRule.allowed_origins)
}
inline void CorsRule::add_allowed_origins(const char* value, size_t size) {
  _impl_.allowed_origins_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.gateway.v1.CorsRule.allowed_origins)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CorsRule::allowed_origins() const {
  // @@protoc_insertion_point(field_list:unhinged.gateway.v1.CorsRule.allowed_origins)
  return _impl_.allowed_origins_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CorsRule::mutable_allowed_origins() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.gateway.v1.CorsRule.allowed_origins)
  return &_impl_.allowed_origins_;
}

// repeated string allowed_methods = 2;
inline int CorsRule::_internal_allowed_methods_size() const {
  return _impl_.allowed_methods_.size();
}
inline int CorsRule::allowed_methods_size() const {
  return _internal_allowed_methods_size();
}
inline void CorsRule::clear_allowed_methods() {
  _impl_.allowed_methods_.Clear();
}
inline std::string* CorsRule::add_allowed_methods() {
  std::string* _s = _internal_add_allowed_methods();
  // @@protoc_insertion_point(field_add_mutable:unhinged.gateway.v1.CorsRule.allowed_methods)
  return _s;
}
inline const std::string& CorsRule::_internal_allowed_methods(int index) const {
  return _impl_.allowed_methods_.Get(index);
}
inline const std::string& CorsRule::allowed_methods(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.CorsRule.allowed_methods)
  return _internal_allowed_methods(index);
}
inline std::string* CorsRule::mutable_allowed_methods(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.gateway.v1.CorsRule.allowed_methods)
  return _impl_.allowed_methods_.Mutable(index);
}
inline void CorsRule::set_allowed_methods(int index, const std::string& value) {
  _impl_.allowed_methods_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.CorsRule.allowed_methods)
}
inline void CorsRule::set_allowed_methods(int index, std::string&& value) {
  _impl_.allowed_methods_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.CorsRule.allowed_methods)
}
inline void CorsRule::set_allowed_methods(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.allowed_methods_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.gateway.v1.CorsRule.allowed_methods)
}
inline void CorsRule::set_allowed_methods(int index, const char* value, size_t size) {
  _impl_.allowed_methods_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.gateway.v1.CorsRule.allowed_methods)
}
inline std::string* CorsRule::_internal_add_allowed_methods() {
  return _impl_.allowed_methods_.Add();
}
inline void CorsRule::add_allowed_methods(const std::string& value) {
  _impl_.allowed_methods_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.gateway.v1.CorsRule.allowed_methods)
}
inline void CorsRule::add_allowed_methods(std::string&& value) {
  _impl_.allowed_methods_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.gateway.v1.CorsRule.allowed_methods)
}
inline void CorsRule::add_allowed_methods(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.allowed_methods_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.gateway.v1.CorsRule.allowed_methods)
}
inline void CorsRule::add_allowed_methods(const char* value, size_t size) {
  _impl_.allowed_methods_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.gateway.v1.CorsRule.allowed_methods)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CorsRule::allowed_methods() const {
  // @@protoc_insertion_point(field_list:unhinged.gateway.v1.CorsRule.allowed_methods)
  return _impl_.allowed_methods_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CorsRule::mutable_allowed_methods() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.gateway.v1.CorsRule.allowed_methods)
  return &_impl_.allowed_methods_;
}

// repeated string allowed_headers = 3;
inline int CorsRule::_internal_allowed_headers_size() const {
  return _impl_.allowed_headers_.size();
}
inline int CorsRule::allowed_headers_size() const {
  return _internal_allowed_headers_size();
}
inline void CorsRule::clear_allowed_headers() {
  _impl_.allowed_headers_.Clear();
}
inline std::string* CorsRule::add_allowed_headers() {
  std::string* _s = _internal_add_allowed_headers();
  // @@protoc_insertion_point(field_add_mutable:unhinged.gateway.v1.CorsRule.allowed_headers)
  return _s;
}
inline const std::string& CorsRule::_internal_allowed_headers(int index) const {
  return _impl_.allowed_headers_.Get(index);
}
inline const std::string& CorsRule::allowed_headers(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.CorsRule.allowed_headers)
  return _internal_allowed_headers(index);
}
inline std::string* CorsRule::mutable_allowed_headers(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.gateway.v1.CorsRule.allowed_headers)
  return _impl_.allowed_headers_.Mutable(index);
}
inline void CorsRule::set_allowed_headers(int index, const std::string& value) {
  _impl_.allowed_headers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.CorsRule.allowed_headers)
}
inline void CorsRule::set_allowed_headers(int index, std::string&& value) {
  _impl_.allowed_headers_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.CorsRule.allowed_headers)
}
inline void CorsRule::set_allowed_headers(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.allowed_headers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.gateway.v1.CorsRule.allowed_headers)
}
inline void CorsRule::set_allowed_headers(int index, const char* value, size_t size) {
  _impl_.allowed_headers_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.gateway.v1.CorsRule.allowed_headers)
}
inline std::string* CorsRule::_internal_add_allowed_headers() {
  return _impl_.allowed_headers_.Add();
}
inline void CorsRule::add_allowed_headers(const std::string& value) {
  _impl_.allowed_headers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.gateway.v1.CorsRule.allowed_headers)
}
inline void CorsRule::add_allowed_headers(std::string&& value) {
  _impl_.allowed_headers_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.gateway.v1.CorsRule.allowed_headers)
}
inline void CorsRule::add_allowed_headers(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.allowed_headers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.gateway.v1.CorsRule.allowed_headers)
}
inline void CorsRule::add_allowed_headers(const char* value, size_t size) {
  _impl_.allowed_headers_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.gateway.v1.CorsRule.allowed_headers)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CorsRule::allowed_headers() const {
  // @@protoc_insertion_point(field_list:unhinged.gateway.v1.CorsRule.allowed_headers)
  return _impl_.allowed_headers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CorsRule::mutable_allowed_headers() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.gateway.v1.CorsRule.allowed_headers)
  return &_impl_.allowed_headers_;
}

// bool allow_credentials = 4;
inline void CorsRule::clear_allow_credentials() {
  _impl_.allow_credentials_ = false;
}
inline bool CorsRule::_internal_allow_credentials() const {
  return _impl_.allow_credentials_;
}
inline bool CorsRule::allow_credentials() const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.CorsRule.allow_credentials)
  return _internal_allow_credentials();
}
inline void CorsRule::_internal_set_allow_credentials(bool value) {
  
  _impl_.allow_credentials_ = value;
}
inline void CorsRule::set_allow_credentials(bool value) {
  _internal_set_allow_credentials(value);
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.CorsRule.allow_credentials)
}

// int32 max_age_seconds = 5;
inline void CorsRule::clear_max_age_seconds() {
  _impl_.max_age_seconds_ = 0;
}
inline int32_t CorsRule::_internal_max_age_seconds() const {
  return _impl_.max_age_seconds_;
}
inline int32_t CorsRule::max_age_seconds() const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.CorsRule.max_age_seconds)
  return _internal_max_age_seconds();
}
inline void CorsRule::_internal_set_max_age_seconds(int32_t value) {
  
  _impl_.max_age_seconds_ = value;
}
inline void CorsRule::set_max_age_seconds(int32_t value) {
  _internal_set_max_age_seconds(value);
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.CorsRule.max_age_seconds)
}

// -------------------------------------------------------------------

// WebSocketRule

// string path = 1;
inline void WebSocketRule::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& WebSocketRule::path() const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.WebSocketRule.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WebSocketRule::set_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.WebSocketRule.path)
}
inline std::string* WebSocketRule::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:unhinged.gateway.v1.WebSocketRule.path)
  return _s;
}
inline const std::string& WebSocketRule::_internal_path() const {
  return _impl_.path_.Get();
}
inline void WebSocketRule::_internal_set_path(const std::string& value) {
  
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* WebSocketRule::_internal_mutable_path() {
  
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* WebSocketRule::release_path() {
  // @@protoc_insertion_point(field_release:unhinged.gateway.v1.WebSocketRule.path)
  return _impl_.path_.Release();
}
inline void WebSocketRule::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.gateway.v1.WebSocketRule.path)
}

// string event_type = 2;
inline void WebSocketRule::clear_event_type() {
  _impl_.event_type_.ClearToEmpty();
}
inline const std::string& WebSocketRule::event_type() const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.WebSocketRule.event_type)
  return _internal_event_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WebSocketRule::set_event_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.event_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.WebSocketRule.event_type)
}
inline std::string* WebSocketRule::mutable_event_type() {
  std::string* _s = _internal_mutable_event_type();
  // @@protoc_insertion_point(field_mutable:unhinged.gateway.v1.WebSocketRule.event_type)
  return _s;
}
inline const std::string& WebSocketRule::_internal_event_type() const {
  return _impl_.event_type_.Get();
}
inline void WebSocketRule::_internal_set_event_type(const std::string& value) {
  
  _impl_.event_type_.Set(value, GetArenaForAllocation());
}
inline std::string* WebSocketRule::_internal_mutable_event_type() {
  
  return _impl_.event_type_.Mutable(GetArenaForAllocation());
}
inline std::string* WebSocketRule::release_event_type() {
  // @@protoc_insertion_point(field_release:unhinged.gateway.v1.WebSocketRule.event_type)
  return _impl_.event_type_.Release();
}
inline void WebSocketRule::set_allocated_event_type(std::string* event_type) {
  if (event_type != nullptr) {
    
  } else {
    
  }
  _impl_.event_type_.SetAllocated(event_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.event_type_.IsDefault()) {
    _impl_.event_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.gateway.v1.WebSocketRule.event_type)
}

// bool auth_required = 10;
inline void WebSocketRule::clear_auth_required() {
  _impl_.auth_required_ = false;
}
inline bool WebSocketRule::_internal_auth_required() const {
  return _impl_.auth_required_;
}
inline bool WebSocketRule::auth_required() const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.WebSocketRule.auth_required)
  return _internal_auth_required();
}
inline void WebSocketRule::_internal_set_auth_required(bool value) {
  
  _impl_.auth_required_ = value;
}
inline void WebSocketRule::set_auth_required(bool value) {
  _internal_set_auth_required(value);
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.WebSocketRule.auth_required)
}

// repeated string required_scopes = 11;
inline int WebSocketRule::_internal_required_scopes_size() const {
  return _impl_.required_scopes_.size();
}
inline int WebSocketRule::required_scopes_size() const {
  return _internal_required_scopes_size();
}
inline void WebSocketRule::clear_required_scopes() {
  _impl_.required_scopes_.Clear();
}
inline std::string* WebSocketRule::add_required_scopes() {
  std::string* _s = _internal_add_required_scopes();
  // @@protoc_insertion_point(field_add_mutable:unhinged.gateway.v1.WebSocketRule.required_scopes)
  return _s;
}
inline const std::string& WebSocketRule::_internal_required_scopes(int index) const {
  return _impl_.required_scopes_.Get(index);
}
inline const std::string& WebSocketRule::required_scopes(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.WebSocketRule.required_scopes)
  return _internal_required_scopes(index);
}
inline std::string* WebSocketRule::mutable_required_scopes(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.gateway.v1.WebSocketRule.required_scopes)
  return _impl_.required_scopes_.Mutable(index);
}
inline void WebSocketRule::set_required_scopes(int index, const std::string& value) {
  _impl_.required_scopes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.WebSocketRule.required_scopes)
}
inline void WebSocketRule::set_required_scopes(int index, std::string&& value) {
  _impl_.required_scopes_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.WebSocketRule.required_scopes)
}
inline void WebSocketRule::set_required_scopes(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.required_scopes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.gateway.v1.WebSocketRule.required_scopes)
}
inline void WebSocketRule::set_required_scopes(int index, const char* value, size_t size) {
  _impl_.required_scopes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.gateway.v1.WebSocketRule.required_scopes)
}
inline std::string* WebSocketRule::_internal_add_required_scopes() {
  return _impl_.required_scopes_.Add();
}
inline void WebSocketRule::add_required_scopes(const std::string& value) {
  _impl_.required_scopes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.gateway.v1.WebSocketRule.required_scopes)
}
inline void WebSocketRule::add_required_scopes(std::string&& value) {
  _impl_.required_scopes_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.gateway.v1.WebSocketRule.required_scopes)
}
inline void WebSocketRule::add_required_scopes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.required_scopes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.gateway.v1.WebSocketRule.required_scopes)
}
inline void WebSocketRule::add_required_scopes(const char* value, size_t size) {
  _impl_.required_scopes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.gateway.v1.WebSocketRule.required_scopes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
WebSocketRule::required_scopes() const {
  // @@protoc_insertion_point(field_list:unhinged.gateway.v1.WebSocketRule.required_scopes)
  return _impl_.required_scopes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
WebSocketRule::mutable_required_scopes() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.gateway.v1.WebSocketRule.required_scopes)
  return &_impl_.required_scopes_;
}

// int32 max_connections_per_user = 12;
inline void WebSocketRule::clear_max_connections_per_user() {
  _impl_.max_connections_per_user_ = 0;
}
inline int32_t WebSocketRule::_internal_max_connections_per_user() const {
  return _impl_.max_connections_per_user_;
}
inline int32_t WebSocketRule::max_connections_per_user() const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.WebSocketRule.max_connections_per_user)
  return _internal_max_connections_per_user();
}
inline void WebSocketRule::_internal_set_max_connections_per_user(int32_t value) {
  
  _impl_.max_connections_per_user_ = value;
}
inline void WebSocketRule::set_max_connections_per_user(int32_t value) {
  _internal_set_max_connections_per_user(value);
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.WebSocketRule.max_connections_per_user)
}

// int32 idle_timeout_seconds = 13;
inline void WebSocketRule::clear_idle_timeout_seconds() {
  _impl_.idle_timeout_seconds_ = 0;
}
inline int32_t WebSocketRule::_internal_idle_timeout_seconds() const {
  return _impl_.idle_timeout_seconds_;
}
inline int32_t WebSocketRule::idle_timeout_seconds() const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.WebSocketRule.idle_timeout_seconds)
  return _internal_idle_timeout_seconds();
}
inline void WebSocketRule::_internal_set_idle_timeout_seconds(int32_t value) {
  
  _impl_.idle_timeout_seconds_ = value;
}
inline void WebSocketRule::set_idle_timeout_seconds(int32_t value) {
  _internal_set_idle_timeout_seconds(value);
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.WebSocketRule.idle_timeout_seconds)
}

// string request_field = 15;
inline void WebSocketRule::clear_request_field() {
  _impl_.request_field_.ClearToEmpty();
}
inline const std::string& WebSocketRule::request_field() const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.WebSocketRule.request_field)
  return _internal_request_field();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WebSocketRule::set_request_field(ArgT0&& arg0, ArgT... args) {
 
 _impl_.request_field_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.WebSocketRule.request_field)
}
inline std::string* WebSocketRule::mutable_request_field() {
  std::string* _s = _internal_mutable_request_field();
  // @@protoc_insertion_point(field_mutable:unhinged.gateway.v1.WebSocketRule.request_field)
  return _s;
}
inline const std::string& WebSocketRule::_internal_request_field() const {
  return _impl_.request_field_.Get();
}
inline void WebSocketRule::_internal_set_request_field(const std::string& value) {
  
  _impl_.request_field_.Set(value, GetArenaForAllocation());
}
inline std::string* WebSocketRule::_internal_mutable_request_field() {
  
  return _impl_.request_field_.Mutable(GetArenaForAllocation());
}
inline std::string* WebSocketRule::release_request_field() {
  // @@protoc_insertion_point(field_release:unhinged.gateway.v1.WebSocketRule.request_field)
  return _impl_.request_field_.Release();
}
inline void WebSocketRule::set_allocated_request_field(std::string* request_field) {
  if (request_field != nullptr) {
    
  } else {
    
  }
  _impl_.request_field_.SetAllocated(request_field, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.request_field_.IsDefault()) {
    _impl_.request_field_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.gateway.v1.WebSocketRule.request_field)
}

// string response_field = 16;
inline void WebSocketRule::clear_response_field() {
  _impl_.response_field_.ClearToEmpty();
}
inline const std::string& WebSocketRule::response_field() const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.WebSocketRule.response_field)
  return _internal_response_field();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WebSocketRule::set_response_field(ArgT0&& arg0, ArgT... args) {
 
 _impl_.response_field_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.WebSocketRule.response_field)
}
inline std::string* WebSocketRule::mutable_response_field() {
  std::string* _s = _internal_mutable_response_field();
  // @@protoc_insertion_point(field_mutable:unhinged.gateway.v1.WebSocketRule.response_field)
  return _s;
}
inline const std::string& WebSocketRule::_internal_response_field() const {
  return _impl_.response_field_.Get();
}
inline void WebSocketRule::_internal_set_response_field(const std::string& value) {
  
  _impl_.response_field_.Set(value, GetArenaForAllocation());
}
inline std::string* WebSocketRule::_internal_mutable_response_field() {
  
  return _impl_.response_field_.Mutable(GetArenaForAllocation());
}
inline std::string* WebSocketRule::release_response_field() {
  // @@protoc_insertion_point(field_release:unhinged.gateway.v1.WebSocketRule.response_field)
  return _impl_.response_field_.Release();
}
inline void WebSocketRule::set_allocated_response_field(std::string* response_field) {
  if (response_field != nullptr) {
    
  } else {
    
  }
  _impl_.response_field_.SetAllocated(response_field, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.response_field_.IsDefault()) {
    _impl_.response_field_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.gateway.v1.WebSocketRule.response_field)
}

// bool broadcast = 17;
inline void WebSocketRule::clear_broadcast() {
  _impl_.broadcast_ = false;
}
inline bool WebSocketRule::_internal_broadcast() const {
  return _impl_.broadcast_;
}
inline bool WebSocketRule::broadcast() const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.WebSocketRule.broadcast)
  return _internal_broadcast();
}
inline void WebSocketRule::_internal_set_broadcast(bool value) {
  
  _impl_.broadcast_ = value;
}
inline void WebSocketRule::set_broadcast(bool value) {
  _internal_set_broadcast(value);
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.WebSocketRule.broadcast)
}

// string broadcast_filter = 18;
inline void WebSocketRule::clear_broadcast_filter() {
  _impl_.broadcast_filter_.ClearToEmpty();
}
inline const std::string& WebSocketRule::broadcast_filter() const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.WebSocketRule.broadcast_filter)
  return _internal_broadcast_filter();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WebSocketRule::set_broadcast_filter(ArgT0&& arg0, ArgT... args) {
 
 _impl_.broadcast_filter_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.WebSocketRule.broadcast_filter)
}
inline std::string* WebSocketRule::mutable_broadcast_filter() {
  std::string* _s = _internal_mutable_broadcast_filter();
  // @@protoc_insertion_point(field_mutable:unhinged.gateway.v1.WebSocketRule.broadcast_filter)
  return _s;
}
inline const std::string& WebSocketRule::_internal_broadcast_filter() const {
  return _impl_.broadcast_filter_.Get();
}
inline void WebSocketRule::_internal_set_broadcast_filter(const std::string& value) {
  
  _impl_.broadcast_filter_.Set(value, GetArenaForAllocation());
}
inline std::string* WebSocketRule::_internal_mutable_broadcast_filter() {
  
  return _impl_.broadcast_filter_.Mutable(GetArenaForAllocation());
}
inline std::string* WebSocketRule::release_broadcast_filter() {
  // @@protoc_insertion_point(field_release:unhinged.gateway.v1.WebSocketRule.broadcast_filter)
  return _impl_.broadcast_filter_.Release();
}
inline void WebSocketRule::set_allocated_broadcast_filter(std::string* broadcast_filter) {
  if (broadcast_filter != nullptr) {
    
  } else {
    
  }
  _impl_.broadcast_filter_.SetAllocated(broadcast_filter, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.broadcast_filter_.IsDefault()) {
    _impl_.broadcast_filter_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.gateway.v1.WebSocketRule.broadcast_filter)
}

// .unhinged.gateway.v1.RateLimitRule rate_limit = 20;
inline bool WebSocketRule::_internal_has_rate_limit() const {
  return this != internal_default_instance() && _impl_.rate_limit_ != nullptr;
}
inline bool WebSocketRule::has_rate_limit() const {
  return _internal_has_rate_limit();
}
inline void WebSocketRule::clear_rate_limit() {
  if (GetArenaForAllocation() == nullptr && _impl_.rate_limit_ != nullptr) {
    delete _impl_.rate_limit_;
  }
  _impl_.rate_limit_ = nullptr;
}
inline const ::unhinged::gateway::v1::RateLimitRule& WebSocketRule::_internal_rate_limit() const {
  const ::unhinged::gateway::v1::RateLimitRule* p = _impl_.rate_limit_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::gateway::v1::RateLimitRule&>(
      ::unhinged::gateway::v1::_RateLimitRule_default_instance_);
}
inline const ::unhinged::gateway::v1::RateLimitRule& WebSocketRule::rate_limit() const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.WebSocketRule.rate_limit)
  return _internal_rate_limit();
}
inline void WebSocketRule::unsafe_arena_set_allocated_rate_limit(
    ::unhinged::gateway::v1::RateLimitRule* rate_limit) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rate_limit_);
  }
  _impl_.rate_limit_ = rate_limit;
  if (rate_limit) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.gateway.v1.WebSocketRule.rate_limit)
}
inline ::unhinged::gateway::v1::RateLimitRule* WebSocketRule::release_rate_limit() {
  
  ::unhinged::gateway::v1::RateLimitRule* temp = _impl_.rate_limit_;
  _impl_.rate_limit_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::gateway::v1::RateLimitRule* WebSocketRule::unsafe_arena_release_rate_limit() {
  // @@protoc_insertion_point(field_release:unhinged.gateway.v1.WebSocketRule.rate_limit)
  
  ::unhinged::gateway::v1::RateLimitRule* temp = _impl_.rate_limit_;
  _impl_.rate_limit_ = nullptr;
  return temp;
}
inline ::unhinged::gateway::v1::RateLimitRule* WebSocketRule::_internal_mutable_rate_limit() {
  
  if (_impl_.rate_limit_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::gateway::v1::RateLimitRule>(GetArenaForAllocation());
    _impl_.rate_limit_ = p;
  }
  return _impl_.rate_limit_;
}
inline ::unhinged::gateway::v1::RateLimitRule* WebSocketRule::mutable_rate_limit() {
  ::unhinged::gateway::v1::RateLimitRule* _msg = _internal_mutable_rate_limit();
  // @@protoc_insertion_point(field_mutable:unhinged.gateway.v1.WebSocketRule.rate_limit)
  return _msg;
}
inline void WebSocketRule::set_allocated_rate_limit(::unhinged::gateway::v1::RateLimitRule* rate_limit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rate_limit_;
  }
  if (rate_limit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rate_limit);
    if (message_arena != submessage_arena) {
      rate_limit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rate_limit, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.rate_limit_ = rate_limit;
  // @@protoc_insertion_point(field_set_allocated:unhinged.gateway.v1.WebSocketRule.rate_limit)
}

// string summary = 25;
inline void WebSocketRule::clear_summary() {
  _impl_.summary_.ClearToEmpty();
}
inline const std::string& WebSocketRule::summary() const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.WebSocketRule.summary)
  return _internal_summary();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WebSocketRule::set_summary(ArgT0&& arg0, ArgT... args) {
 
 _impl_.summary_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.WebSocketRule.summary)
}
inline std::string* WebSocketRule::mutable_summary() {
  std::string* _s = _internal_mutable_summary();
  // @@protoc_insertion_point(field_mutable:unhinged.gateway.v1.WebSocketRule.summary)
  return _s;
}
inline const std::string& WebSocketRule::_internal_summary() const {
  return _impl_.summary_.Get();
}
inline void WebSocketRule::_internal_set_summary(const std::string& value) {
  
  _impl_.summary_.Set(value, GetArenaForAllocation());
}
inline std::string* WebSocketRule::_internal_mutable_summary() {
  
  return _impl_.summary_.Mutable(GetArenaForAllocation());
}
inline std::string* WebSocketRule::release_summary() {
  // @@protoc_insertion_point(field_release:unhinged.gateway.v1.WebSocketRule.summary)
  return _impl_.summary_.Release();
}
inline void WebSocketRule::set_allocated_summary(std::string* summary) {
  if (summary != nullptr) {
    
  } else {
    
  }
  _impl_.summary_.SetAllocated(summary, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.summary_.IsDefault()) {
    _impl_.summary_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.gateway.v1.WebSocketRule.summary)
}

// string description = 26;
inline void WebSocketRule::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& WebSocketRule::description() const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.WebSocketRule.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WebSocketRule::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.WebSocketRule.description)
}
inline std::string* WebSocketRule::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:unhinged.gateway.v1.WebSocketRule.description)
  return _s;
}
inline const std::string& WebSocketRule::_internal_description() const {
  return _impl_.description_.Get();
}
inline void WebSocketRule::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* WebSocketRule::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* WebSocketRule::release_description() {
  // @@protoc_insertion_point(field_release:unhinged.gateway.v1.WebSocketRule.description)
  return _impl_.description_.Release();
}
inline void WebSocketRule::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.gateway.v1.WebSocketRule.description)
}

// repeated string tags = 27;
inline int WebSocketRule::_internal_tags_size() const {
  return _impl_.tags_.size();
}
inline int WebSocketRule::tags_size() const {
  return _internal_tags_size();
}
inline void WebSocketRule::clear_tags() {
  _impl_.tags_.Clear();
}
inline std::string* WebSocketRule::add_tags() {
  std::string* _s = _internal_add_tags();
  // @@protoc_insertion_point(field_add_mutable:unhinged.gateway.v1.WebSocketRule.tags)
  return _s;
}
inline const std::string& WebSocketRule::_internal_tags(int index) const {
  return _impl_.tags_.Get(index);
}
inline const std::string& WebSocketRule::tags(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.WebSocketRule.tags)
  return _internal_tags(index);
}
inline std::string* WebSocketRule::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.gateway.v1.WebSocketRule.tags)
  return _impl_.tags_.Mutable(index);
}
inline void WebSocketRule::set_tags(int index, const std::string& value) {
  _impl_.tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.WebSocketRule.tags)
}
inline void WebSocketRule::set_tags(int index, std::string&& value) {
  _impl_.tags_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.WebSocketRule.tags)
}
inline void WebSocketRule::set_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.gateway.v1.WebSocketRule.tags)
}
inline void WebSocketRule::set_tags(int index, const char* value, size_t size) {
  _impl_.tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.gateway.v1.WebSocketRule.tags)
}
inline std::string* WebSocketRule::_internal_add_tags() {
  return _impl_.tags_.Add();
}
inline void WebSocketRule::add_tags(const std::string& value) {
  _impl_.tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.gateway.v1.WebSocketRule.tags)
}
inline void WebSocketRule::add_tags(std::string&& value) {
  _impl_.tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.gateway.v1.WebSocketRule.tags)
}
inline void WebSocketRule::add_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.gateway.v1.WebSocketRule.tags)
}
inline void WebSocketRule::add_tags(const char* value, size_t size) {
  _impl_.tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.gateway.v1.WebSocketRule.tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
WebSocketRule::tags() const {
  // @@protoc_insertion_point(field_list:unhinged.gateway.v1.WebSocketRule.tags)
  return _impl_.tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
WebSocketRule::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.gateway.v1.WebSocketRule.tags)
  return &_impl_.tags_;
}

// -------------------------------------------------------------------

// ServerSentEventsRule

// string path = 1;
inline void ServerSentEventsRule::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& ServerSentEventsRule::path() const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.ServerSentEventsRule.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServerSentEventsRule::set_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.ServerSentEventsRule.path)
}
inline std::string* ServerSentEventsRule::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:unhinged.gateway.v1.ServerSentEventsRule.path)
  return _s;
}
inline const std::string& ServerSentEventsRule::_internal_path() const {
  return _impl_.path_.Get();
}
inline void ServerSentEventsRule::_internal_set_path(const std::string& value) {
  
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* ServerSentEventsRule::_internal_mutable_path() {
  
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* ServerSentEventsRule::release_path() {
  // @@protoc_insertion_point(field_release:unhinged.gateway.v1.ServerSentEventsRule.path)
  return _impl_.path_.Release();
}
inline void ServerSentEventsRule::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.gateway.v1.ServerSentEventsRule.path)
}

// string event_type = 2;
inline void ServerSentEventsRule::clear_event_type() {
  _impl_.event_type_.ClearToEmpty();
}
inline const std::string& ServerSentEventsRule::event_type() const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.ServerSentEventsRule.event_type)
  return _internal_event_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServerSentEventsRule::set_event_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.event_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.ServerSentEventsRule.event_type)
}
inline std::string* ServerSentEventsRule::mutable_event_type() {
  std::string* _s = _internal_mutable_event_type();
  // @@protoc_insertion_point(field_mutable:unhinged.gateway.v1.ServerSentEventsRule.event_type)
  return _s;
}
inline const std::string& ServerSentEventsRule::_internal_event_type() const {
  return _impl_.event_type_.Get();
}
inline void ServerSentEventsRule::_internal_set_event_type(const std::string& value) {
  
  _impl_.event_type_.Set(value, GetArenaForAllocation());
}
inline std::string* ServerSentEventsRule::_internal_mutable_event_type() {
  
  return _impl_.event_type_.Mutable(GetArenaForAllocation());
}
inline std::string* ServerSentEventsRule::release_event_type() {
  // @@protoc_insertion_point(field_release:unhinged.gateway.v1.ServerSentEventsRule.event_type)
  return _impl_.event_type_.Release();
}
inline void ServerSentEventsRule::set_allocated_event_type(std::string* event_type) {
  if (event_type != nullptr) {
    
  } else {
    
  }
  _impl_.event_type_.SetAllocated(event_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.event_type_.IsDefault()) {
    _impl_.event_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.gateway.v1.ServerSentEventsRule.event_type)
}

// bool auth_required = 10;
inline void ServerSentEventsRule::clear_auth_required() {
  _impl_.auth_required_ = false;
}
inline bool ServerSentEventsRule::_internal_auth_required() const {
  return _impl_.auth_required_;
}
inline bool ServerSentEventsRule::auth_required() const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.ServerSentEventsRule.auth_required)
  return _internal_auth_required();
}
inline void ServerSentEventsRule::_internal_set_auth_required(bool value) {
  
  _impl_.auth_required_ = value;
}
inline void ServerSentEventsRule::set_auth_required(bool value) {
  _internal_set_auth_required(value);
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.ServerSentEventsRule.auth_required)
}

// repeated string required_scopes = 11;
inline int ServerSentEventsRule::_internal_required_scopes_size() const {
  return _impl_.required_scopes_.size();
}
inline int ServerSentEventsRule::required_scopes_size() const {
  return _internal_required_scopes_size();
}
inline void ServerSentEventsRule::clear_required_scopes() {
  _impl_.required_scopes_.Clear();
}
inline std::string* ServerSentEventsRule::add_required_scopes() {
  std::string* _s = _internal_add_required_scopes();
  // @@protoc_insertion_point(field_add_mutable:unhinged.gateway.v1.ServerSentEventsRule.required_scopes)
  return _s;
}
inline const std::string& ServerSentEventsRule::_internal_required_scopes(int index) const {
  return _impl_.required_scopes_.Get(index);
}
inline const std::string& ServerSentEventsRule::required_scopes(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.ServerSentEventsRule.required_scopes)
  return _internal_required_scopes(index);
}
inline std::string* ServerSentEventsRule::mutable_required_scopes(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.gateway.v1.ServerSentEventsRule.required_scopes)
  return _impl_.required_scopes_.Mutable(index);
}
inline void ServerSentEventsRule::set_required_scopes(int index, const std::string& value) {
  _impl_.required_scopes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.ServerSentEventsRule.required_scopes)
}
inline void ServerSentEventsRule::set_required_scopes(int index, std::string&& value) {
  _impl_.required_scopes_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.ServerSentEventsRule.required_scopes)
}
inline void ServerSentEventsRule::set_required_scopes(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.required_scopes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.gateway.v1.ServerSentEventsRule.required_scopes)
}
inline void ServerSentEventsRule::set_required_scopes(int index, const char* value, size_t size) {
  _impl_.required_scopes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.gateway.v1.ServerSentEventsRule.required_scopes)
}
inline std::string* ServerSentEventsRule::_internal_add_required_scopes() {
  return _impl_.required_scopes_.Add();
}
inline void ServerSentEventsRule::add_required_scopes(const std::string& value) {
  _impl_.required_scopes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.gateway.v1.ServerSentEventsRule.required_scopes)
}
inline void ServerSentEventsRule::add_required_scopes(std::string&& value) {
  _impl_.required_scopes_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.gateway.v1.ServerSentEventsRule.required_scopes)
}
inline void ServerSentEventsRule::add_required_scopes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.required_scopes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.gateway.v1.ServerSentEventsRule.required_scopes)
}
inline void ServerSentEventsRule::add_required_scopes(const char* value, size_t size) {
  _impl_.required_scopes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.gateway.v1.ServerSentEventsRule.required_scopes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ServerSentEventsRule::required_scopes() const {
  // @@protoc_insertion_point(field_list:unhinged.gateway.v1.ServerSentEventsRule.required_scopes)
  return _impl_.required_scopes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ServerSentEventsRule::mutable_required_scopes() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.gateway.v1.ServerSentEventsRule.required_scopes)
  return &_impl_.required_scopes_;
}

// int32 keepalive_interval_seconds = 12;
inline void ServerSentEventsRule::clear_keepalive_interval_seconds() {
  _impl_.keepalive_interval_seconds_ = 0;
}
inline int32_t ServerSentEventsRule::_internal_keepalive_interval_seconds() const {
  return _impl_.keepalive_interval_seconds_;
}
inline int32_t ServerSentEventsRule::keepalive_interval_seconds() const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.ServerSentEventsRule.keepalive_interval_seconds)
  return _internal_keepalive_interval_seconds();
}
inline void ServerSentEventsRule::_internal_set_keepalive_interval_seconds(int32_t value) {
  
  _impl_.keepalive_interval_seconds_ = value;
}
inline void ServerSentEventsRule::set_keepalive_interval_seconds(int32_t value) {
  _internal_set_keepalive_interval_seconds(value);
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.ServerSentEventsRule.keepalive_interval_seconds)
}

// int32 max_stream_duration_seconds = 13;
inline void ServerSentEventsRule::clear_max_stream_duration_seconds() {
  _impl_.max_stream_duration_seconds_ = 0;
}
inline int32_t ServerSentEventsRule::_internal_max_stream_duration_seconds() const {
  return _impl_.max_stream_duration_seconds_;
}
inline int32_t ServerSentEventsRule::max_stream_duration_seconds() const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.ServerSentEventsRule.max_stream_duration_seconds)
  return _internal_max_stream_duration_seconds();
}
inline void ServerSentEventsRule::_internal_set_max_stream_duration_seconds(int32_t value) {
  
  _impl_.max_stream_duration_seconds_ = value;
}
inline void ServerSentEventsRule::set_max_stream_duration_seconds(int32_t value) {
  _internal_set_max_stream_duration_seconds(value);
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.ServerSentEventsRule.max_stream_duration_seconds)
}

// string data_field = 15;
inline void ServerSentEventsRule::clear_data_field() {
  _impl_.data_field_.ClearToEmpty();
}
inline const std::string& ServerSentEventsRule::data_field() const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.ServerSentEventsRule.data_field)
  return _internal_data_field();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServerSentEventsRule::set_data_field(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_field_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.ServerSentEventsRule.data_field)
}
inline std::string* ServerSentEventsRule::mutable_data_field() {
  std::string* _s = _internal_mutable_data_field();
  // @@protoc_insertion_point(field_mutable:unhinged.gateway.v1.ServerSentEventsRule.data_field)
  return _s;
}
inline const std::string& ServerSentEventsRule::_internal_data_field() const {
  return _impl_.data_field_.Get();
}
inline void ServerSentEventsRule::_internal_set_data_field(const std::string& value) {
  
  _impl_.data_field_.Set(value, GetArenaForAllocation());
}
inline std::string* ServerSentEventsRule::_internal_mutable_data_field() {
  
  return _impl_.data_field_.Mutable(GetArenaForAllocation());
}
inline std::string* ServerSentEventsRule::release_data_field() {
  // @@protoc_insertion_point(field_release:unhinged.gateway.v1.ServerSentEventsRule.data_field)
  return _impl_.data_field_.Release();
}
inline void ServerSentEventsRule::set_allocated_data_field(std::string* data_field) {
  if (data_field != nullptr) {
    
  } else {
    
  }
  _impl_.data_field_.SetAllocated(data_field, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_field_.IsDefault()) {
    _impl_.data_field_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.gateway.v1.ServerSentEventsRule.data_field)
}

// string id_field = 16;
inline void ServerSentEventsRule::clear_id_field() {
  _impl_.id_field_.ClearToEmpty();
}
inline const std::string& ServerSentEventsRule::id_field() const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.ServerSentEventsRule.id_field)
  return _internal_id_field();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServerSentEventsRule::set_id_field(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_field_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.ServerSentEventsRule.id_field)
}
inline std::string* ServerSentEventsRule::mutable_id_field() {
  std::string* _s = _internal_mutable_id_field();
  // @@protoc_insertion_point(field_mutable:unhinged.gateway.v1.ServerSentEventsRule.id_field)
  return _s;
}
inline const std::string& ServerSentEventsRule::_internal_id_field() const {
  return _impl_.id_field_.Get();
}
inline void ServerSentEventsRule::_internal_set_id_field(const std::string& value) {
  
  _impl_.id_field_.Set(value, GetArenaForAllocation());
}
inline std::string* ServerSentEventsRule::_internal_mutable_id_field() {
  
  return _impl_.id_field_.Mutable(GetArenaForAllocation());
}
inline std::string* ServerSentEventsRule::release_id_field() {
  // @@protoc_insertion_point(field_release:unhinged.gateway.v1.ServerSentEventsRule.id_field)
  return _impl_.id_field_.Release();
}
inline void ServerSentEventsRule::set_allocated_id_field(std::string* id_field) {
  if (id_field != nullptr) {
    
  } else {
    
  }
  _impl_.id_field_.SetAllocated(id_field, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_field_.IsDefault()) {
    _impl_.id_field_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.gateway.v1.ServerSentEventsRule.id_field)
}

// bool json_encode = 17;
inline void ServerSentEventsRule::clear_json_encode() {
  _impl_.json_encode_ = false;
}
inline bool ServerSentEventsRule::_internal_json_encode() const {
  return _impl_.json_encode_;
}
inline bool ServerSentEventsRule::json_encode() const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.ServerSentEventsRule.json_encode)
  return _internal_json_encode();
}
inline void ServerSentEventsRule::_internal_set_json_encode(bool value) {
  
  _impl_.json_encode_ = value;
}
inline void ServerSentEventsRule::set_json_encode(bool value) {
  _internal_set_json_encode(value);
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.ServerSentEventsRule.json_encode)
}

// repeated string filter_params = 20;
inline int ServerSentEventsRule::_internal_filter_params_size() const {
  return _impl_.filter_params_.size();
}
inline int ServerSentEventsRule::filter_params_size() const {
  return _internal_filter_params_size();
}
inline void ServerSentEventsRule::clear_filter_params() {
  _impl_.filter_params_.Clear();
}
inline std::string* ServerSentEventsRule::add_filter_params() {
  std::string* _s = _internal_add_filter_params();
  // @@protoc_insertion_point(field_add_mutable:unhinged.gateway.v1.ServerSentEventsRule.filter_params)
  return _s;
}
inline const std::string& ServerSentEventsRule::_internal_filter_params(int index) const {
  return _impl_.filter_params_.Get(index);
}
inline const std::string& ServerSentEventsRule::filter_params(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.ServerSentEventsRule.filter_params)
  return _internal_filter_params(index);
}
inline std::string* ServerSentEventsRule::mutable_filter_params(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.gateway.v1.ServerSentEventsRule.filter_params)
  return _impl_.filter_params_.Mutable(index);
}
inline void ServerSentEventsRule::set_filter_params(int index, const std::string& value) {
  _impl_.filter_params_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.ServerSentEventsRule.filter_params)
}
inline void ServerSentEventsRule::set_filter_params(int index, std::string&& value) {
  _impl_.filter_params_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.ServerSentEventsRule.filter_params)
}
inline void ServerSentEventsRule::set_filter_params(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.filter_params_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.gateway.v1.ServerSentEventsRule.filter_params)
}
inline void ServerSentEventsRule::set_filter_params(int index, const char* value, size_t size) {
  _impl_.filter_params_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.gateway.v1.ServerSentEventsRule.filter_params)
}
inline std::string* ServerSentEventsRule::_internal_add_filter_params() {
  return _impl_.filter_params_.Add();
}
inline void ServerSentEventsRule::add_filter_params(const std::string& value) {
  _impl_.filter_params_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.gateway.v1.ServerSentEventsRule.filter_params)
}
inline void ServerSentEventsRule::add_filter_params(std::string&& value) {
  _impl_.filter_params_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.gateway.v1.ServerSentEventsRule.filter_params)
}
inline void ServerSentEventsRule::add_filter_params(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.filter_params_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.gateway.v1.ServerSentEventsRule.filter_params)
}
inline void ServerSentEventsRule::add_filter_params(const char* value, size_t size) {
  _impl_.filter_params_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.gateway.v1.ServerSentEventsRule.filter_params)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ServerSentEventsRule::filter_params() const {
  // @@protoc_insertion_point(field_list:unhinged.gateway.v1.ServerSentEventsRule.filter_params)
  return _impl_.filter_params_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ServerSentEventsRule::mutable_filter_params() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.gateway.v1.ServerSentEventsRule.filter_params)
  return &_impl_.filter_params_;
}

// string routing_key = 21;
inline void ServerSentEventsRule::clear_routing_key() {
  _impl_.routing_key_.ClearToEmpty();
}
inline const std::string& ServerSentEventsRule::routing_key() const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.ServerSentEventsRule.routing_key)
  return _internal_routing_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServerSentEventsRule::set_routing_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.routing_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.ServerSentEventsRule.routing_key)
}
inline std::string* ServerSentEventsRule::mutable_routing_key() {
  std::string* _s = _internal_mutable_routing_key();
  // @@protoc_insertion_point(field_mutable:unhinged.gateway.v1.ServerSentEventsRule.routing_key)
  return _s;
}
inline const std::string& ServerSentEventsRule::_internal_routing_key() const {
  return _impl_.routing_key_.Get();
}
inline void ServerSentEventsRule::_internal_set_routing_key(const std::string& value) {
  
  _impl_.routing_key_.Set(value, GetArenaForAllocation());
}
inline std::string* ServerSentEventsRule::_internal_mutable_routing_key() {
  
  return _impl_.routing_key_.Mutable(GetArenaForAllocation());
}
inline std::string* ServerSentEventsRule::release_routing_key() {
  // @@protoc_insertion_point(field_release:unhinged.gateway.v1.ServerSentEventsRule.routing_key)
  return _impl_.routing_key_.Release();
}
inline void ServerSentEventsRule::set_allocated_routing_key(std::string* routing_key) {
  if (routing_key != nullptr) {
    
  } else {
    
  }
  _impl_.routing_key_.SetAllocated(routing_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.routing_key_.IsDefault()) {
    _impl_.routing_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.gateway.v1.ServerSentEventsRule.routing_key)
}

// string summary = 25;
inline void ServerSentEventsRule::clear_summary() {
  _impl_.summary_.ClearToEmpty();
}
inline const std::string& ServerSentEventsRule::summary() const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.ServerSentEventsRule.summary)
  return _internal_summary();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServerSentEventsRule::set_summary(ArgT0&& arg0, ArgT... args) {
 
 _impl_.summary_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.ServerSentEventsRule.summary)
}
inline std::string* ServerSentEventsRule::mutable_summary() {
  std::string* _s = _internal_mutable_summary();
  // @@protoc_insertion_point(field_mutable:unhinged.gateway.v1.ServerSentEventsRule.summary)
  return _s;
}
inline const std::string& ServerSentEventsRule::_internal_summary() const {
  return _impl_.summary_.Get();
}
inline void ServerSentEventsRule::_internal_set_summary(const std::string& value) {
  
  _impl_.summary_.Set(value, GetArenaForAllocation());
}
inline std::string* ServerSentEventsRule::_internal_mutable_summary() {
  
  return _impl_.summary_.Mutable(GetArenaForAllocation());
}
inline std::string* ServerSentEventsRule::release_summary() {
  // @@protoc_insertion_point(field_release:unhinged.gateway.v1.ServerSentEventsRule.summary)
  return _impl_.summary_.Release();
}
inline void ServerSentEventsRule::set_allocated_summary(std::string* summary) {
  if (summary != nullptr) {
    
  } else {
    
  }
  _impl_.summary_.SetAllocated(summary, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.summary_.IsDefault()) {
    _impl_.summary_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.gateway.v1.ServerSentEventsRule.summary)
}

// string description = 26;
inline void ServerSentEventsRule::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& ServerSentEventsRule::description() const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.ServerSentEventsRule.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServerSentEventsRule::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.ServerSentEventsRule.description)
}
inline std::string* ServerSentEventsRule::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:unhinged.gateway.v1.ServerSentEventsRule.description)
  return _s;
}
inline const std::string& ServerSentEventsRule::_internal_description() const {
  return _impl_.description_.Get();
}
inline void ServerSentEventsRule::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* ServerSentEventsRule::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* ServerSentEventsRule::release_description() {
  // @@protoc_insertion_point(field_release:unhinged.gateway.v1.ServerSentEventsRule.description)
  return _impl_.description_.Release();
}
inline void ServerSentEventsRule::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.gateway.v1.ServerSentEventsRule.description)
}

// repeated string tags = 27;
inline int ServerSentEventsRule::_internal_tags_size() const {
  return _impl_.tags_.size();
}
inline int ServerSentEventsRule::tags_size() const {
  return _internal_tags_size();
}
inline void ServerSentEventsRule::clear_tags() {
  _impl_.tags_.Clear();
}
inline std::string* ServerSentEventsRule::add_tags() {
  std::string* _s = _internal_add_tags();
  // @@protoc_insertion_point(field_add_mutable:unhinged.gateway.v1.ServerSentEventsRule.tags)
  return _s;
}
inline const std::string& ServerSentEventsRule::_internal_tags(int index) const {
  return _impl_.tags_.Get(index);
}
inline const std::string& ServerSentEventsRule::tags(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.ServerSentEventsRule.tags)
  return _internal_tags(index);
}
inline std::string* ServerSentEventsRule::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.gateway.v1.ServerSentEventsRule.tags)
  return _impl_.tags_.Mutable(index);
}
inline void ServerSentEventsRule::set_tags(int index, const std::string& value) {
  _impl_.tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.ServerSentEventsRule.tags)
}
inline void ServerSentEventsRule::set_tags(int index, std::string&& value) {
  _impl_.tags_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.ServerSentEventsRule.tags)
}
inline void ServerSentEventsRule::set_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.gateway.v1.ServerSentEventsRule.tags)
}
inline void ServerSentEventsRule::set_tags(int index, const char* value, size_t size) {
  _impl_.tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.gateway.v1.ServerSentEventsRule.tags)
}
inline std::string* ServerSentEventsRule::_internal_add_tags() {
  return _impl_.tags_.Add();
}
inline void ServerSentEventsRule::add_tags(const std::string& value) {
  _impl_.tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.gateway.v1.ServerSentEventsRule.tags)
}
inline void ServerSentEventsRule::add_tags(std::string&& value) {
  _impl_.tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.gateway.v1.ServerSentEventsRule.tags)
}
inline void ServerSentEventsRule::add_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.gateway.v1.ServerSentEventsRule.tags)
}
inline void ServerSentEventsRule::add_tags(const char* value, size_t size) {
  _impl_.tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.gateway.v1.ServerSentEventsRule.tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ServerSentEventsRule::tags() const {
  // @@protoc_insertion_point(field_list:unhinged.gateway.v1.ServerSentEventsRule.tags)
  return _impl_.tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ServerSentEventsRule::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.gateway.v1.ServerSentEventsRule.tags)
  return &_impl_.tags_;
}

// -------------------------------------------------------------------

// LongPollingRule

// string path = 1;
inline void LongPollingRule::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& LongPollingRule::path() const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.LongPollingRule.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LongPollingRule::set_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.LongPollingRule.path)
}
inline std::string* LongPollingRule::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:unhinged.gateway.v1.LongPollingRule.path)
  return _s;
}
inline const std::string& LongPollingRule::_internal_path() const {
  return _impl_.path_.Get();
}
inline void LongPollingRule::_internal_set_path(const std::string& value) {
  
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* LongPollingRule::_internal_mutable_path() {
  
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* LongPollingRule::release_path() {
  // @@protoc_insertion_point(field_release:unhinged.gateway.v1.LongPollingRule.path)
  return _impl_.path_.Release();
}
inline void LongPollingRule::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.gateway.v1.LongPollingRule.path)
}

// int32 timeout_seconds = 2;
inline void LongPollingRule::clear_timeout_seconds() {
  _impl_.timeout_seconds_ = 0;
}
inline int32_t LongPollingRule::_internal_timeout_seconds() const {
  return _impl_.timeout_seconds_;
}
inline int32_t LongPollingRule::timeout_seconds() const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.LongPollingRule.timeout_seconds)
  return _internal_timeout_seconds();
}
inline void LongPollingRule::_internal_set_timeout_seconds(int32_t value) {
  
  _impl_.timeout_seconds_ = value;
}
inline void LongPollingRule::set_timeout_seconds(int32_t value) {
  _internal_set_timeout_seconds(value);
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.LongPollingRule.timeout_seconds)
}

// int32 max_events = 3;
inline void LongPollingRule::clear_max_events() {
  _impl_.max_events_ = 0;
}
inline int32_t LongPollingRule::_internal_max_events() const {
  return _impl_.max_events_;
}
inline int32_t LongPollingRule::max_events() const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.LongPollingRule.max_events)
  return _internal_max_events();
}
inline void LongPollingRule::_internal_set_max_events(int32_t value) {
  
  _impl_.max_events_ = value;
}
inline void LongPollingRule::set_max_events(int32_t value) {
  _internal_set_max_events(value);
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.LongPollingRule.max_events)
}

// bool auth_required = 10;
inline void LongPollingRule::clear_auth_required() {
  _impl_.auth_required_ = false;
}
inline bool LongPollingRule::_internal_auth_required() const {
  return _impl_.auth_required_;
}
inline bool LongPollingRule::auth_required() const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.LongPollingRule.auth_required)
  return _internal_auth_required();
}
inline void LongPollingRule::_internal_set_auth_required(bool value) {
  
  _impl_.auth_required_ = value;
}
inline void LongPollingRule::set_auth_required(bool value) {
  _internal_set_auth_required(value);
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.LongPollingRule.auth_required)
}

// repeated string required_scopes = 11;
inline int LongPollingRule::_internal_required_scopes_size() const {
  return _impl_.required_scopes_.size();
}
inline int LongPollingRule::required_scopes_size() const {
  return _internal_required_scopes_size();
}
inline void LongPollingRule::clear_required_scopes() {
  _impl_.required_scopes_.Clear();
}
inline std::string* LongPollingRule::add_required_scopes() {
  std::string* _s = _internal_add_required_scopes();
  // @@protoc_insertion_point(field_add_mutable:unhinged.gateway.v1.LongPollingRule.required_scopes)
  return _s;
}
inline const std::string& LongPollingRule::_internal_required_scopes(int index) const {
  return _impl_.required_scopes_.Get(index);
}
inline const std::string& LongPollingRule::required_scopes(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.LongPollingRule.required_scopes)
  return _internal_required_scopes(index);
}
inline std::string* LongPollingRule::mutable_required_scopes(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.gateway.v1.LongPollingRule.required_scopes)
  return _impl_.required_scopes_.Mutable(index);
}
inline void LongPollingRule::set_required_scopes(int index, const std::string& value) {
  _impl_.required_scopes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.LongPollingRule.required_scopes)
}
inline void LongPollingRule::set_required_scopes(int index, std::string&& value) {
  _impl_.required_scopes_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.LongPollingRule.required_scopes)
}
inline void LongPollingRule::set_required_scopes(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.required_scopes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.gateway.v1.LongPollingRule.required_scopes)
}
inline void LongPollingRule::set_required_scopes(int index, const char* value, size_t size) {
  _impl_.required_scopes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.gateway.v1.LongPollingRule.required_scopes)
}
inline std::string* LongPollingRule::_internal_add_required_scopes() {
  return _impl_.required_scopes_.Add();
}
inline void LongPollingRule::add_required_scopes(const std::string& value) {
  _impl_.required_scopes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.gateway.v1.LongPollingRule.required_scopes)
}
inline void LongPollingRule::add_required_scopes(std::string&& value) {
  _impl_.required_scopes_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.gateway.v1.LongPollingRule.required_scopes)
}
inline void LongPollingRule::add_required_scopes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.required_scopes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.gateway.v1.LongPollingRule.required_scopes)
}
inline void LongPollingRule::add_required_scopes(const char* value, size_t size) {
  _impl_.required_scopes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.gateway.v1.LongPollingRule.required_scopes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
LongPollingRule::required_scopes() const {
  // @@protoc_insertion_point(field_list:unhinged.gateway.v1.LongPollingRule.required_scopes)
  return _impl_.required_scopes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
LongPollingRule::mutable_required_scopes() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.gateway.v1.LongPollingRule.required_scopes)
  return &_impl_.required_scopes_;
}

// string events_field = 15;
inline void LongPollingRule::clear_events_field() {
  _impl_.events_field_.ClearToEmpty();
}
inline const std::string& LongPollingRule::events_field() const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.LongPollingRule.events_field)
  return _internal_events_field();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LongPollingRule::set_events_field(ArgT0&& arg0, ArgT... args) {
 
 _impl_.events_field_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.LongPollingRule.events_field)
}
inline std::string* LongPollingRule::mutable_events_field() {
  std::string* _s = _internal_mutable_events_field();
  // @@protoc_insertion_point(field_mutable:unhinged.gateway.v1.LongPollingRule.events_field)
  return _s;
}
inline const std::string& LongPollingRule::_internal_events_field() const {
  return _impl_.events_field_.Get();
}
inline void LongPollingRule::_internal_set_events_field(const std::string& value) {
  
  _impl_.events_field_.Set(value, GetArenaForAllocation());
}
inline std::string* LongPollingRule::_internal_mutable_events_field() {
  
  return _impl_.events_field_.Mutable(GetArenaForAllocation());
}
inline std::string* LongPollingRule::release_events_field() {
  // @@protoc_insertion_point(field_release:unhinged.gateway.v1.LongPollingRule.events_field)
  return _impl_.events_field_.Release();
}
inline void LongPollingRule::set_allocated_events_field(std::string* events_field) {
  if (events_field != nullptr) {
    
  } else {
    
  }
  _impl_.events_field_.SetAllocated(events_field, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.events_field_.IsDefault()) {
    _impl_.events_field_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.gateway.v1.LongPollingRule.events_field)
}

// string cursor_field = 16;
inline void LongPollingRule::clear_cursor_field() {
  _impl_.cursor_field_.ClearToEmpty();
}
inline const std::string& LongPollingRule::cursor_field() const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.LongPollingRule.cursor_field)
  return _internal_cursor_field();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LongPollingRule::set_cursor_field(ArgT0&& arg0, ArgT... args) {
 
 _impl_.cursor_field_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.LongPollingRule.cursor_field)
}
inline std::string* LongPollingRule::mutable_cursor_field() {
  std::string* _s = _internal_mutable_cursor_field();
  // @@protoc_insertion_point(field_mutable:unhinged.gateway.v1.LongPollingRule.cursor_field)
  return _s;
}
inline const std::string& LongPollingRule::_internal_cursor_field() const {
  return _impl_.cursor_field_.Get();
}
inline void LongPollingRule::_internal_set_cursor_field(const std::string& value) {
  
  _impl_.cursor_field_.Set(value, GetArenaForAllocation());
}
inline std::string* LongPollingRule::_internal_mutable_cursor_field() {
  
  return _impl_.cursor_field_.Mutable(GetArenaForAllocation());
}
inline std::string* LongPollingRule::release_cursor_field() {
  // @@protoc_insertion_point(field_release:unhinged.gateway.v1.LongPollingRule.cursor_field)
  return _impl_.cursor_field_.Release();
}
inline void LongPollingRule::set_allocated_cursor_field(std::string* cursor_field) {
  if (cursor_field != nullptr) {
    
  } else {
    
  }
  _impl_.cursor_field_.SetAllocated(cursor_field, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cursor_field_.IsDefault()) {
    _impl_.cursor_field_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.gateway.v1.LongPollingRule.cursor_field)
}

// bool include_metadata = 17;
inline void LongPollingRule::clear_include_metadata() {
  _impl_.include_metadata_ = false;
}
inline bool LongPollingRule::_internal_include_metadata() const {
  return _impl_.include_metadata_;
}
inline bool LongPollingRule::include_metadata() const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.LongPollingRule.include_metadata)
  return _internal_include_metadata();
}
inline void LongPollingRule::_internal_set_include_metadata(bool value) {
  
  _impl_.include_metadata_ = value;
}
inline void LongPollingRule::set_include_metadata(bool value) {
  _internal_set_include_metadata(value);
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.LongPollingRule.include_metadata)
}

// string summary = 20;
inline void LongPollingRule::clear_summary() {
  _impl_.summary_.ClearToEmpty();
}
inline const std::string& LongPollingRule::summary() const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.LongPollingRule.summary)
  return _internal_summary();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LongPollingRule::set_summary(ArgT0&& arg0, ArgT... args) {
 
 _impl_.summary_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.LongPollingRule.summary)
}
inline std::string* LongPollingRule::mutable_summary() {
  std::string* _s = _internal_mutable_summary();
  // @@protoc_insertion_point(field_mutable:unhinged.gateway.v1.LongPollingRule.summary)
  return _s;
}
inline const std::string& LongPollingRule::_internal_summary() const {
  return _impl_.summary_.Get();
}
inline void LongPollingRule::_internal_set_summary(const std::string& value) {
  
  _impl_.summary_.Set(value, GetArenaForAllocation());
}
inline std::string* LongPollingRule::_internal_mutable_summary() {
  
  return _impl_.summary_.Mutable(GetArenaForAllocation());
}
inline std::string* LongPollingRule::release_summary() {
  // @@protoc_insertion_point(field_release:unhinged.gateway.v1.LongPollingRule.summary)
  return _impl_.summary_.Release();
}
inline void LongPollingRule::set_allocated_summary(std::string* summary) {
  if (summary != nullptr) {
    
  } else {
    
  }
  _impl_.summary_.SetAllocated(summary, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.summary_.IsDefault()) {
    _impl_.summary_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.gateway.v1.LongPollingRule.summary)
}

// string description = 21;
inline void LongPollingRule::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& LongPollingRule::description() const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.LongPollingRule.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LongPollingRule::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.LongPollingRule.description)
}
inline std::string* LongPollingRule::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:unhinged.gateway.v1.LongPollingRule.description)
  return _s;
}
inline const std::string& LongPollingRule::_internal_description() const {
  return _impl_.description_.Get();
}
inline void LongPollingRule::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* LongPollingRule::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* LongPollingRule::release_description() {
  // @@protoc_insertion_point(field_release:unhinged.gateway.v1.LongPollingRule.description)
  return _impl_.description_.Release();
}
inline void LongPollingRule::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.gateway.v1.LongPollingRule.description)
}

// repeated string tags = 22;
inline int LongPollingRule::_internal_tags_size() const {
  return _impl_.tags_.size();
}
inline int LongPollingRule::tags_size() const {
  return _internal_tags_size();
}
inline void LongPollingRule::clear_tags() {
  _impl_.tags_.Clear();
}
inline std::string* LongPollingRule::add_tags() {
  std::string* _s = _internal_add_tags();
  // @@protoc_insertion_point(field_add_mutable:unhinged.gateway.v1.LongPollingRule.tags)
  return _s;
}
inline const std::string& LongPollingRule::_internal_tags(int index) const {
  return _impl_.tags_.Get(index);
}
inline const std::string& LongPollingRule::tags(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.LongPollingRule.tags)
  return _internal_tags(index);
}
inline std::string* LongPollingRule::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.gateway.v1.LongPollingRule.tags)
  return _impl_.tags_.Mutable(index);
}
inline void LongPollingRule::set_tags(int index, const std::string& value) {
  _impl_.tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.LongPollingRule.tags)
}
inline void LongPollingRule::set_tags(int index, std::string&& value) {
  _impl_.tags_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.LongPollingRule.tags)
}
inline void LongPollingRule::set_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.gateway.v1.LongPollingRule.tags)
}
inline void LongPollingRule::set_tags(int index, const char* value, size_t size) {
  _impl_.tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.gateway.v1.LongPollingRule.tags)
}
inline std::string* LongPollingRule::_internal_add_tags() {
  return _impl_.tags_.Add();
}
inline void LongPollingRule::add_tags(const std::string& value) {
  _impl_.tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.gateway.v1.LongPollingRule.tags)
}
inline void LongPollingRule::add_tags(std::string&& value) {
  _impl_.tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.gateway.v1.LongPollingRule.tags)
}
inline void LongPollingRule::add_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.gateway.v1.LongPollingRule.tags)
}
inline void LongPollingRule::add_tags(const char* value, size_t size) {
  _impl_.tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.gateway.v1.LongPollingRule.tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
LongPollingRule::tags() const {
  // @@protoc_insertion_point(field_list:unhinged.gateway.v1.LongPollingRule.tags)
  return _impl_.tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
LongPollingRule::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.gateway.v1.LongPollingRule.tags)
  return &_impl_.tags_;
}

// -------------------------------------------------------------------

// ServiceRule

// string base_path = 1;
inline void ServiceRule::clear_base_path() {
  _impl_.base_path_.ClearToEmpty();
}
inline const std::string& ServiceRule::base_path() const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.ServiceRule.base_path)
  return _internal_base_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceRule::set_base_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.base_path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.ServiceRule.base_path)
}
inline std::string* ServiceRule::mutable_base_path() {
  std::string* _s = _internal_mutable_base_path();
  // @@protoc_insertion_point(field_mutable:unhinged.gateway.v1.ServiceRule.base_path)
  return _s;
}
inline const std::string& ServiceRule::_internal_base_path() const {
  return _impl_.base_path_.Get();
}
inline void ServiceRule::_internal_set_base_path(const std::string& value) {
  
  _impl_.base_path_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceRule::_internal_mutable_base_path() {
  
  return _impl_.base_path_.Mutable(GetArenaForAllocation());
}
inline std::string* ServiceRule::release_base_path() {
  // @@protoc_insertion_point(field_release:unhinged.gateway.v1.ServiceRule.base_path)
  return _impl_.base_path_.Release();
}
inline void ServiceRule::set_allocated_base_path(std::string* base_path) {
  if (base_path != nullptr) {
    
  } else {
    
  }
  _impl_.base_path_.SetAllocated(base_path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.base_path_.IsDefault()) {
    _impl_.base_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.gateway.v1.ServiceRule.base_path)
}

// string version = 2;
inline void ServiceRule::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& ServiceRule::version() const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.ServiceRule.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceRule::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.ServiceRule.version)
}
inline std::string* ServiceRule::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:unhinged.gateway.v1.ServiceRule.version)
  return _s;
}
inline const std::string& ServiceRule::_internal_version() const {
  return _impl_.version_.Get();
}
inline void ServiceRule::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceRule::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* ServiceRule::release_version() {
  // @@protoc_insertion_point(field_release:unhinged.gateway.v1.ServiceRule.version)
  return _impl_.version_.Release();
}
inline void ServiceRule::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.gateway.v1.ServiceRule.version)
}

// bool default_auth_required = 10;
inline void ServiceRule::clear_default_auth_required() {
  _impl_.default_auth_required_ = false;
}
inline bool ServiceRule::_internal_default_auth_required() const {
  return _impl_.default_auth_required_;
}
inline bool ServiceRule::default_auth_required() const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.ServiceRule.default_auth_required)
  return _internal_default_auth_required();
}
inline void ServiceRule::_internal_set_default_auth_required(bool value) {
  
  _impl_.default_auth_required_ = value;
}
inline void ServiceRule::set_default_auth_required(bool value) {
  _internal_set_default_auth_required(value);
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.ServiceRule.default_auth_required)
}

// repeated string default_scopes = 11;
inline int ServiceRule::_internal_default_scopes_size() const {
  return _impl_.default_scopes_.size();
}
inline int ServiceRule::default_scopes_size() const {
  return _internal_default_scopes_size();
}
inline void ServiceRule::clear_default_scopes() {
  _impl_.default_scopes_.Clear();
}
inline std::string* ServiceRule::add_default_scopes() {
  std::string* _s = _internal_add_default_scopes();
  // @@protoc_insertion_point(field_add_mutable:unhinged.gateway.v1.ServiceRule.default_scopes)
  return _s;
}
inline const std::string& ServiceRule::_internal_default_scopes(int index) const {
  return _impl_.default_scopes_.Get(index);
}
inline const std::string& ServiceRule::default_scopes(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.ServiceRule.default_scopes)
  return _internal_default_scopes(index);
}
inline std::string* ServiceRule::mutable_default_scopes(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.gateway.v1.ServiceRule.default_scopes)
  return _impl_.default_scopes_.Mutable(index);
}
inline void ServiceRule::set_default_scopes(int index, const std::string& value) {
  _impl_.default_scopes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.ServiceRule.default_scopes)
}
inline void ServiceRule::set_default_scopes(int index, std::string&& value) {
  _impl_.default_scopes_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.ServiceRule.default_scopes)
}
inline void ServiceRule::set_default_scopes(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.default_scopes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.gateway.v1.ServiceRule.default_scopes)
}
inline void ServiceRule::set_default_scopes(int index, const char* value, size_t size) {
  _impl_.default_scopes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.gateway.v1.ServiceRule.default_scopes)
}
inline std::string* ServiceRule::_internal_add_default_scopes() {
  return _impl_.default_scopes_.Add();
}
inline void ServiceRule::add_default_scopes(const std::string& value) {
  _impl_.default_scopes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.gateway.v1.ServiceRule.default_scopes)
}
inline void ServiceRule::add_default_scopes(std::string&& value) {
  _impl_.default_scopes_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.gateway.v1.ServiceRule.default_scopes)
}
inline void ServiceRule::add_default_scopes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.default_scopes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.gateway.v1.ServiceRule.default_scopes)
}
inline void ServiceRule::add_default_scopes(const char* value, size_t size) {
  _impl_.default_scopes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.gateway.v1.ServiceRule.default_scopes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ServiceRule::default_scopes() const {
  // @@protoc_insertion_point(field_list:unhinged.gateway.v1.ServiceRule.default_scopes)
  return _impl_.default_scopes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ServiceRule::mutable_default_scopes() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.gateway.v1.ServiceRule.default_scopes)
  return &_impl_.default_scopes_;
}

// string auth_provider = 12;
inline void ServiceRule::clear_auth_provider() {
  _impl_.auth_provider_.ClearToEmpty();
}
inline const std::string& ServiceRule::auth_provider() const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.ServiceRule.auth_provider)
  return _internal_auth_provider();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceRule::set_auth_provider(ArgT0&& arg0, ArgT... args) {
 
 _impl_.auth_provider_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.ServiceRule.auth_provider)
}
inline std::string* ServiceRule::mutable_auth_provider() {
  std::string* _s = _internal_mutable_auth_provider();
  // @@protoc_insertion_point(field_mutable:unhinged.gateway.v1.ServiceRule.auth_provider)
  return _s;
}
inline const std::string& ServiceRule::_internal_auth_provider() const {
  return _impl_.auth_provider_.Get();
}
inline void ServiceRule::_internal_set_auth_provider(const std::string& value) {
  
  _impl_.auth_provider_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceRule::_internal_mutable_auth_provider() {
  
  return _impl_.auth_provider_.Mutable(GetArenaForAllocation());
}
inline std::string* ServiceRule::release_auth_provider() {
  // @@protoc_insertion_point(field_release:unhinged.gateway.v1.ServiceRule.auth_provider)
  return _impl_.auth_provider_.Release();
}
inline void ServiceRule::set_allocated_auth_provider(std::string* auth_provider) {
  if (auth_provider != nullptr) {
    
  } else {
    
  }
  _impl_.auth_provider_.SetAllocated(auth_provider, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.auth_provider_.IsDefault()) {
    _impl_.auth_provider_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.gateway.v1.ServiceRule.auth_provider)
}

// .unhinged.gateway.v1.RateLimitRule default_rate_limit = 15;
inline bool ServiceRule::_internal_has_default_rate_limit() const {
  return this != internal_default_instance() && _impl_.default_rate_limit_ != nullptr;
}
inline bool ServiceRule::has_default_rate_limit() const {
  return _internal_has_default_rate_limit();
}
inline void ServiceRule::clear_default_rate_limit() {
  if (GetArenaForAllocation() == nullptr && _impl_.default_rate_limit_ != nullptr) {
    delete _impl_.default_rate_limit_;
  }
  _impl_.default_rate_limit_ = nullptr;
}
inline const ::unhinged::gateway::v1::RateLimitRule& ServiceRule::_internal_default_rate_limit() const {
  const ::unhinged::gateway::v1::RateLimitRule* p = _impl_.default_rate_limit_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::gateway::v1::RateLimitRule&>(
      ::unhinged::gateway::v1::_RateLimitRule_default_instance_);
}
inline const ::unhinged::gateway::v1::RateLimitRule& ServiceRule::default_rate_limit() const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.ServiceRule.default_rate_limit)
  return _internal_default_rate_limit();
}
inline void ServiceRule::unsafe_arena_set_allocated_default_rate_limit(
    ::unhinged::gateway::v1::RateLimitRule* default_rate_limit) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.default_rate_limit_);
  }
  _impl_.default_rate_limit_ = default_rate_limit;
  if (default_rate_limit) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.gateway.v1.ServiceRule.default_rate_limit)
}
inline ::unhinged::gateway::v1::RateLimitRule* ServiceRule::release_default_rate_limit() {
  
  ::unhinged::gateway::v1::RateLimitRule* temp = _impl_.default_rate_limit_;
  _impl_.default_rate_limit_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::gateway::v1::RateLimitRule* ServiceRule::unsafe_arena_release_default_rate_limit() {
  // @@protoc_insertion_point(field_release:unhinged.gateway.v1.ServiceRule.default_rate_limit)
  
  ::unhinged::gateway::v1::RateLimitRule* temp = _impl_.default_rate_limit_;
  _impl_.default_rate_limit_ = nullptr;
  return temp;
}
inline ::unhinged::gateway::v1::RateLimitRule* ServiceRule::_internal_mutable_default_rate_limit() {
  
  if (_impl_.default_rate_limit_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::gateway::v1::RateLimitRule>(GetArenaForAllocation());
    _impl_.default_rate_limit_ = p;
  }
  return _impl_.default_rate_limit_;
}
inline ::unhinged::gateway::v1::RateLimitRule* ServiceRule::mutable_default_rate_limit() {
  ::unhinged::gateway::v1::RateLimitRule* _msg = _internal_mutable_default_rate_limit();
  // @@protoc_insertion_point(field_mutable:unhinged.gateway.v1.ServiceRule.default_rate_limit)
  return _msg;
}
inline void ServiceRule::set_allocated_default_rate_limit(::unhinged::gateway::v1::RateLimitRule* default_rate_limit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.default_rate_limit_;
  }
  if (default_rate_limit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(default_rate_limit);
    if (message_arena != submessage_arena) {
      default_rate_limit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, default_rate_limit, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.default_rate_limit_ = default_rate_limit;
  // @@protoc_insertion_point(field_set_allocated:unhinged.gateway.v1.ServiceRule.default_rate_limit)
}

// .unhinged.gateway.v1.CorsRule default_cors = 16;
inline bool ServiceRule::_internal_has_default_cors() const {
  return this != internal_default_instance() && _impl_.default_cors_ != nullptr;
}
inline bool ServiceRule::has_default_cors() const {
  return _internal_has_default_cors();
}
inline void ServiceRule::clear_default_cors() {
  if (GetArenaForAllocation() == nullptr && _impl_.default_cors_ != nullptr) {
    delete _impl_.default_cors_;
  }
  _impl_.default_cors_ = nullptr;
}
inline const ::unhinged::gateway::v1::CorsRule& ServiceRule::_internal_default_cors() const {
  const ::unhinged::gateway::v1::CorsRule* p = _impl_.default_cors_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::gateway::v1::CorsRule&>(
      ::unhinged::gateway::v1::_CorsRule_default_instance_);
}
inline const ::unhinged::gateway::v1::CorsRule& ServiceRule::default_cors() const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.ServiceRule.default_cors)
  return _internal_default_cors();
}
inline void ServiceRule::unsafe_arena_set_allocated_default_cors(
    ::unhinged::gateway::v1::CorsRule* default_cors) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.default_cors_);
  }
  _impl_.default_cors_ = default_cors;
  if (default_cors) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.gateway.v1.ServiceRule.default_cors)
}
inline ::unhinged::gateway::v1::CorsRule* ServiceRule::release_default_cors() {
  
  ::unhinged::gateway::v1::CorsRule* temp = _impl_.default_cors_;
  _impl_.default_cors_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::gateway::v1::CorsRule* ServiceRule::unsafe_arena_release_default_cors() {
  // @@protoc_insertion_point(field_release:unhinged.gateway.v1.ServiceRule.default_cors)
  
  ::unhinged::gateway::v1::CorsRule* temp = _impl_.default_cors_;
  _impl_.default_cors_ = nullptr;
  return temp;
}
inline ::unhinged::gateway::v1::CorsRule* ServiceRule::_internal_mutable_default_cors() {
  
  if (_impl_.default_cors_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::gateway::v1::CorsRule>(GetArenaForAllocation());
    _impl_.default_cors_ = p;
  }
  return _impl_.default_cors_;
}
inline ::unhinged::gateway::v1::CorsRule* ServiceRule::mutable_default_cors() {
  ::unhinged::gateway::v1::CorsRule* _msg = _internal_mutable_default_cors();
  // @@protoc_insertion_point(field_mutable:unhinged.gateway.v1.ServiceRule.default_cors)
  return _msg;
}
inline void ServiceRule::set_allocated_default_cors(::unhinged::gateway::v1::CorsRule* default_cors) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.default_cors_;
  }
  if (default_cors) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(default_cors);
    if (message_arena != submessage_arena) {
      default_cors = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, default_cors, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.default_cors_ = default_cors;
  // @@protoc_insertion_point(field_set_allocated:unhinged.gateway.v1.ServiceRule.default_cors)
}

// string title = 20;
inline void ServiceRule::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& ServiceRule::title() const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.ServiceRule.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceRule::set_title(ArgT0&& arg0, ArgT... args) {
 
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.ServiceRule.title)
}
inline std::string* ServiceRule::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:unhinged.gateway.v1.ServiceRule.title)
  return _s;
}
inline const std::string& ServiceRule::_internal_title() const {
  return _impl_.title_.Get();
}
inline void ServiceRule::_internal_set_title(const std::string& value) {
  
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceRule::_internal_mutable_title() {
  
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* ServiceRule::release_title() {
  // @@protoc_insertion_point(field_release:unhinged.gateway.v1.ServiceRule.title)
  return _impl_.title_.Release();
}
inline void ServiceRule::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.gateway.v1.ServiceRule.title)
}

// string description = 21;
inline void ServiceRule::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& ServiceRule::description() const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.ServiceRule.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceRule::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.ServiceRule.description)
}
inline std::string* ServiceRule::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:unhinged.gateway.v1.ServiceRule.description)
  return _s;
}
inline const std::string& ServiceRule::_internal_description() const {
  return _impl_.description_.Get();
}
inline void ServiceRule::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceRule::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* ServiceRule::release_description() {
  // @@protoc_insertion_point(field_release:unhinged.gateway.v1.ServiceRule.description)
  return _impl_.description_.Release();
}
inline void ServiceRule::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.gateway.v1.ServiceRule.description)
}

// repeated string tags = 22;
inline int ServiceRule::_internal_tags_size() const {
  return _impl_.tags_.size();
}
inline int ServiceRule::tags_size() const {
  return _internal_tags_size();
}
inline void ServiceRule::clear_tags() {
  _impl_.tags_.Clear();
}
inline std::string* ServiceRule::add_tags() {
  std::string* _s = _internal_add_tags();
  // @@protoc_insertion_point(field_add_mutable:unhinged.gateway.v1.ServiceRule.tags)
  return _s;
}
inline const std::string& ServiceRule::_internal_tags(int index) const {
  return _impl_.tags_.Get(index);
}
inline const std::string& ServiceRule::tags(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.ServiceRule.tags)
  return _internal_tags(index);
}
inline std::string* ServiceRule::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.gateway.v1.ServiceRule.tags)
  return _impl_.tags_.Mutable(index);
}
inline void ServiceRule::set_tags(int index, const std::string& value) {
  _impl_.tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.ServiceRule.tags)
}
inline void ServiceRule::set_tags(int index, std::string&& value) {
  _impl_.tags_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.ServiceRule.tags)
}
inline void ServiceRule::set_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.gateway.v1.ServiceRule.tags)
}
inline void ServiceRule::set_tags(int index, const char* value, size_t size) {
  _impl_.tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.gateway.v1.ServiceRule.tags)
}
inline std::string* ServiceRule::_internal_add_tags() {
  return _impl_.tags_.Add();
}
inline void ServiceRule::add_tags(const std::string& value) {
  _impl_.tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.gateway.v1.ServiceRule.tags)
}
inline void ServiceRule::add_tags(std::string&& value) {
  _impl_.tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.gateway.v1.ServiceRule.tags)
}
inline void ServiceRule::add_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.gateway.v1.ServiceRule.tags)
}
inline void ServiceRule::add_tags(const char* value, size_t size) {
  _impl_.tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.gateway.v1.ServiceRule.tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ServiceRule::tags() const {
  // @@protoc_insertion_point(field_list:unhinged.gateway.v1.ServiceRule.tags)
  return _impl_.tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ServiceRule::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.gateway.v1.ServiceRule.tags)
  return &_impl_.tags_;
}

// string contact_email = 23;
inline void ServiceRule::clear_contact_email() {
  _impl_.contact_email_.ClearToEmpty();
}
inline const std::string& ServiceRule::contact_email() const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.ServiceRule.contact_email)
  return _internal_contact_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceRule::set_contact_email(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contact_email_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.ServiceRule.contact_email)
}
inline std::string* ServiceRule::mutable_contact_email() {
  std::string* _s = _internal_mutable_contact_email();
  // @@protoc_insertion_point(field_mutable:unhinged.gateway.v1.ServiceRule.contact_email)
  return _s;
}
inline const std::string& ServiceRule::_internal_contact_email() const {
  return _impl_.contact_email_.Get();
}
inline void ServiceRule::_internal_set_contact_email(const std::string& value) {
  
  _impl_.contact_email_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceRule::_internal_mutable_contact_email() {
  
  return _impl_.contact_email_.Mutable(GetArenaForAllocation());
}
inline std::string* ServiceRule::release_contact_email() {
  // @@protoc_insertion_point(field_release:unhinged.gateway.v1.ServiceRule.contact_email)
  return _impl_.contact_email_.Release();
}
inline void ServiceRule::set_allocated_contact_email(std::string* contact_email) {
  if (contact_email != nullptr) {
    
  } else {
    
  }
  _impl_.contact_email_.SetAllocated(contact_email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contact_email_.IsDefault()) {
    _impl_.contact_email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.gateway.v1.ServiceRule.contact_email)
}

// string license = 24;
inline void ServiceRule::clear_license() {
  _impl_.license_.ClearToEmpty();
}
inline const std::string& ServiceRule::license() const {
  // @@protoc_insertion_point(field_get:unhinged.gateway.v1.ServiceRule.license)
  return _internal_license();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceRule::set_license(ArgT0&& arg0, ArgT... args) {
 
 _impl_.license_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.gateway.v1.ServiceRule.license)
}
inline std::string* ServiceRule::mutable_license() {
  std::string* _s = _internal_mutable_license();
  // @@protoc_insertion_point(field_mutable:unhinged.gateway.v1.ServiceRule.license)
  return _s;
}
inline const std::string& ServiceRule::_internal_license() const {
  return _impl_.license_.Get();
}
inline void ServiceRule::_internal_set_license(const std::string& value) {
  
  _impl_.license_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceRule::_internal_mutable_license() {
  
  return _impl_.license_.Mutable(GetArenaForAllocation());
}
inline std::string* ServiceRule::release_license() {
  // @@protoc_insertion_point(field_release:unhinged.gateway.v1.ServiceRule.license)
  return _impl_.license_.Release();
}
inline void ServiceRule::set_allocated_license(std::string* license) {
  if (license != nullptr) {
    
  } else {
    
  }
  _impl_.license_.SetAllocated(license, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.license_.IsDefault()) {
    _impl_.license_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.gateway.v1.ServiceRule.license)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace gateway
}  // namespace unhinged

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_gateway_5fannotations_2eproto
