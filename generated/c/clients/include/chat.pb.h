// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: chat.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_chat_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_chat_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_chat_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_chat_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_chat_2eproto;
namespace unhinged {
namespace chat {
namespace v1 {
class ChatChunkPayload;
struct ChatChunkPayloadDefaultTypeInternal;
extern ChatChunkPayloadDefaultTypeInternal _ChatChunkPayload_default_instance_;
class ChatMessage;
struct ChatMessageDefaultTypeInternal;
extern ChatMessageDefaultTypeInternal _ChatMessage_default_instance_;
class Conversation;
struct ConversationDefaultTypeInternal;
extern ConversationDefaultTypeInternal _Conversation_default_instance_;
class ConversationSettings;
struct ConversationSettingsDefaultTypeInternal;
extern ConversationSettingsDefaultTypeInternal _ConversationSettings_default_instance_;
class CreateConversationRequest;
struct CreateConversationRequestDefaultTypeInternal;
extern CreateConversationRequestDefaultTypeInternal _CreateConversationRequest_default_instance_;
class CreateConversationResponse;
struct CreateConversationResponseDefaultTypeInternal;
extern CreateConversationResponseDefaultTypeInternal _CreateConversationResponse_default_instance_;
class DeleteConversationRequest;
struct DeleteConversationRequestDefaultTypeInternal;
extern DeleteConversationRequestDefaultTypeInternal _DeleteConversationRequest_default_instance_;
class DeleteConversationResponse;
struct DeleteConversationResponseDefaultTypeInternal;
extern DeleteConversationResponseDefaultTypeInternal _DeleteConversationResponse_default_instance_;
class DeleteMessageRequest;
struct DeleteMessageRequestDefaultTypeInternal;
extern DeleteMessageRequestDefaultTypeInternal _DeleteMessageRequest_default_instance_;
class DeleteMessageResponse;
struct DeleteMessageResponseDefaultTypeInternal;
extern DeleteMessageResponseDefaultTypeInternal _DeleteMessageResponse_default_instance_;
class GetConversationRequest;
struct GetConversationRequestDefaultTypeInternal;
extern GetConversationRequestDefaultTypeInternal _GetConversationRequest_default_instance_;
class GetConversationResponse;
struct GetConversationResponseDefaultTypeInternal;
extern GetConversationResponseDefaultTypeInternal _GetConversationResponse_default_instance_;
class GetMessagesRequest;
struct GetMessagesRequestDefaultTypeInternal;
extern GetMessagesRequestDefaultTypeInternal _GetMessagesRequest_default_instance_;
class GetMessagesResponse;
struct GetMessagesResponseDefaultTypeInternal;
extern GetMessagesResponseDefaultTypeInternal _GetMessagesResponse_default_instance_;
class ListConversationsRequest;
struct ListConversationsRequestDefaultTypeInternal;
extern ListConversationsRequestDefaultTypeInternal _ListConversationsRequest_default_instance_;
class ListConversationsResponse;
struct ListConversationsResponseDefaultTypeInternal;
extern ListConversationsResponseDefaultTypeInternal _ListConversationsResponse_default_instance_;
class SendMessageRequest;
struct SendMessageRequestDefaultTypeInternal;
extern SendMessageRequestDefaultTypeInternal _SendMessageRequest_default_instance_;
class SendMessageResponse;
struct SendMessageResponseDefaultTypeInternal;
extern SendMessageResponseDefaultTypeInternal _SendMessageResponse_default_instance_;
class StreamChatRequest;
struct StreamChatRequestDefaultTypeInternal;
extern StreamChatRequestDefaultTypeInternal _StreamChatRequest_default_instance_;
class StreamOptions;
struct StreamOptionsDefaultTypeInternal;
extern StreamOptionsDefaultTypeInternal _StreamOptions_default_instance_;
class SubscribeRequest;
struct SubscribeRequestDefaultTypeInternal;
extern SubscribeRequestDefaultTypeInternal _SubscribeRequest_default_instance_;
class ToolCall;
struct ToolCallDefaultTypeInternal;
extern ToolCallDefaultTypeInternal _ToolCall_default_instance_;
class UpdateConversationRequest;
struct UpdateConversationRequestDefaultTypeInternal;
extern UpdateConversationRequestDefaultTypeInternal _UpdateConversationRequest_default_instance_;
class UpdateConversationResponse;
struct UpdateConversationResponseDefaultTypeInternal;
extern UpdateConversationResponseDefaultTypeInternal _UpdateConversationResponse_default_instance_;
class UpdateMessageRequest;
struct UpdateMessageRequestDefaultTypeInternal;
extern UpdateMessageRequestDefaultTypeInternal _UpdateMessageRequest_default_instance_;
class UpdateMessageResponse;
struct UpdateMessageResponseDefaultTypeInternal;
extern UpdateMessageResponseDefaultTypeInternal _UpdateMessageResponse_default_instance_;
}  // namespace v1
}  // namespace chat
}  // namespace unhinged
PROTOBUF_NAMESPACE_OPEN
template<> ::unhinged::chat::v1::ChatChunkPayload* Arena::CreateMaybeMessage<::unhinged::chat::v1::ChatChunkPayload>(Arena*);
template<> ::unhinged::chat::v1::ChatMessage* Arena::CreateMaybeMessage<::unhinged::chat::v1::ChatMessage>(Arena*);
template<> ::unhinged::chat::v1::Conversation* Arena::CreateMaybeMessage<::unhinged::chat::v1::Conversation>(Arena*);
template<> ::unhinged::chat::v1::ConversationSettings* Arena::CreateMaybeMessage<::unhinged::chat::v1::ConversationSettings>(Arena*);
template<> ::unhinged::chat::v1::CreateConversationRequest* Arena::CreateMaybeMessage<::unhinged::chat::v1::CreateConversationRequest>(Arena*);
template<> ::unhinged::chat::v1::CreateConversationResponse* Arena::CreateMaybeMessage<::unhinged::chat::v1::CreateConversationResponse>(Arena*);
template<> ::unhinged::chat::v1::DeleteConversationRequest* Arena::CreateMaybeMessage<::unhinged::chat::v1::DeleteConversationRequest>(Arena*);
template<> ::unhinged::chat::v1::DeleteConversationResponse* Arena::CreateMaybeMessage<::unhinged::chat::v1::DeleteConversationResponse>(Arena*);
template<> ::unhinged::chat::v1::DeleteMessageRequest* Arena::CreateMaybeMessage<::unhinged::chat::v1::DeleteMessageRequest>(Arena*);
template<> ::unhinged::chat::v1::DeleteMessageResponse* Arena::CreateMaybeMessage<::unhinged::chat::v1::DeleteMessageResponse>(Arena*);
template<> ::unhinged::chat::v1::GetConversationRequest* Arena::CreateMaybeMessage<::unhinged::chat::v1::GetConversationRequest>(Arena*);
template<> ::unhinged::chat::v1::GetConversationResponse* Arena::CreateMaybeMessage<::unhinged::chat::v1::GetConversationResponse>(Arena*);
template<> ::unhinged::chat::v1::GetMessagesRequest* Arena::CreateMaybeMessage<::unhinged::chat::v1::GetMessagesRequest>(Arena*);
template<> ::unhinged::chat::v1::GetMessagesResponse* Arena::CreateMaybeMessage<::unhinged::chat::v1::GetMessagesResponse>(Arena*);
template<> ::unhinged::chat::v1::ListConversationsRequest* Arena::CreateMaybeMessage<::unhinged::chat::v1::ListConversationsRequest>(Arena*);
template<> ::unhinged::chat::v1::ListConversationsResponse* Arena::CreateMaybeMessage<::unhinged::chat::v1::ListConversationsResponse>(Arena*);
template<> ::unhinged::chat::v1::SendMessageRequest* Arena::CreateMaybeMessage<::unhinged::chat::v1::SendMessageRequest>(Arena*);
template<> ::unhinged::chat::v1::SendMessageResponse* Arena::CreateMaybeMessage<::unhinged::chat::v1::SendMessageResponse>(Arena*);
template<> ::unhinged::chat::v1::StreamChatRequest* Arena::CreateMaybeMessage<::unhinged::chat::v1::StreamChatRequest>(Arena*);
template<> ::unhinged::chat::v1::StreamOptions* Arena::CreateMaybeMessage<::unhinged::chat::v1::StreamOptions>(Arena*);
template<> ::unhinged::chat::v1::SubscribeRequest* Arena::CreateMaybeMessage<::unhinged::chat::v1::SubscribeRequest>(Arena*);
template<> ::unhinged::chat::v1::ToolCall* Arena::CreateMaybeMessage<::unhinged::chat::v1::ToolCall>(Arena*);
template<> ::unhinged::chat::v1::UpdateConversationRequest* Arena::CreateMaybeMessage<::unhinged::chat::v1::UpdateConversationRequest>(Arena*);
template<> ::unhinged::chat::v1::UpdateConversationResponse* Arena::CreateMaybeMessage<::unhinged::chat::v1::UpdateConversationResponse>(Arena*);
template<> ::unhinged::chat::v1::UpdateMessageRequest* Arena::CreateMaybeMessage<::unhinged::chat::v1::UpdateMessageRequest>(Arena*);
template<> ::unhinged::chat::v1::UpdateMessageResponse* Arena::CreateMaybeMessage<::unhinged::chat::v1::UpdateMessageResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace unhinged {
namespace chat {
namespace v1 {

enum ConversationStatus : int {
  CONVERSATION_STATUS_UNSPECIFIED = 0,
  CONVERSATION_STATUS_ACTIVE = 1,
  CONVERSATION_STATUS_ARCHIVED = 2,
  CONVERSATION_STATUS_DELETED = 3,
  CONVERSATION_STATUS_LOCKED = 4,
  ConversationStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ConversationStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ConversationStatus_IsValid(int value);
constexpr ConversationStatus ConversationStatus_MIN = CONVERSATION_STATUS_UNSPECIFIED;
constexpr ConversationStatus ConversationStatus_MAX = CONVERSATION_STATUS_LOCKED;
constexpr int ConversationStatus_ARRAYSIZE = ConversationStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ConversationStatus_descriptor();
template<typename T>
inline const std::string& ConversationStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ConversationStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ConversationStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ConversationStatus_descriptor(), enum_t_value);
}
inline bool ConversationStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConversationStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ConversationStatus>(
    ConversationStatus_descriptor(), name, value);
}
enum MessageRole : int {
  MESSAGE_ROLE_UNSPECIFIED = 0,
  MESSAGE_ROLE_USER = 1,
  MESSAGE_ROLE_ASSISTANT = 2,
  MESSAGE_ROLE_SYSTEM = 3,
  MESSAGE_ROLE_TOOL = 4,
  MessageRole_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MessageRole_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MessageRole_IsValid(int value);
constexpr MessageRole MessageRole_MIN = MESSAGE_ROLE_UNSPECIFIED;
constexpr MessageRole MessageRole_MAX = MESSAGE_ROLE_TOOL;
constexpr int MessageRole_ARRAYSIZE = MessageRole_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MessageRole_descriptor();
template<typename T>
inline const std::string& MessageRole_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MessageRole>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MessageRole_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MessageRole_descriptor(), enum_t_value);
}
inline bool MessageRole_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MessageRole* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MessageRole>(
    MessageRole_descriptor(), name, value);
}
enum MessageStatus : int {
  MESSAGE_STATUS_UNSPECIFIED = 0,
  MESSAGE_STATUS_SENT = 1,
  MESSAGE_STATUS_PROCESSING = 2,
  MESSAGE_STATUS_COMPLETED = 3,
  MESSAGE_STATUS_FAILED = 4,
  MESSAGE_STATUS_EDITED = 5,
  MESSAGE_STATUS_DELETED = 6,
  MessageStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MessageStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MessageStatus_IsValid(int value);
constexpr MessageStatus MessageStatus_MIN = MESSAGE_STATUS_UNSPECIFIED;
constexpr MessageStatus MessageStatus_MAX = MESSAGE_STATUS_DELETED;
constexpr int MessageStatus_ARRAYSIZE = MessageStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MessageStatus_descriptor();
template<typename T>
inline const std::string& MessageStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MessageStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MessageStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MessageStatus_descriptor(), enum_t_value);
}
inline bool MessageStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MessageStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MessageStatus>(
    MessageStatus_descriptor(), name, value);
}
enum ToolCallStatus : int {
  TOOL_CALL_STATUS_UNSPECIFIED = 0,
  TOOL_CALL_STATUS_PENDING = 1,
  TOOL_CALL_STATUS_EXECUTING = 2,
  TOOL_CALL_STATUS_COMPLETED = 3,
  TOOL_CALL_STATUS_FAILED = 4,
  ToolCallStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ToolCallStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ToolCallStatus_IsValid(int value);
constexpr ToolCallStatus ToolCallStatus_MIN = TOOL_CALL_STATUS_UNSPECIFIED;
constexpr ToolCallStatus ToolCallStatus_MAX = TOOL_CALL_STATUS_FAILED;
constexpr int ToolCallStatus_ARRAYSIZE = ToolCallStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ToolCallStatus_descriptor();
template<typename T>
inline const std::string& ToolCallStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ToolCallStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ToolCallStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ToolCallStatus_descriptor(), enum_t_value);
}
inline bool ToolCallStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ToolCallStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ToolCallStatus>(
    ToolCallStatus_descriptor(), name, value);
}
enum UpdateType : int {
  UPDATE_TYPE_UNSPECIFIED = 0,
  UPDATE_TYPE_MESSAGE_SENT = 1,
  UPDATE_TYPE_MESSAGE_UPDATED = 2,
  UPDATE_TYPE_MESSAGE_DELETED = 3,
  UPDATE_TYPE_TYPING_STARTED = 4,
  UPDATE_TYPE_TYPING_STOPPED = 5,
  UPDATE_TYPE_PARTICIPANT_JOINED = 6,
  UPDATE_TYPE_PARTICIPANT_LEFT = 7,
  UpdateType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  UpdateType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool UpdateType_IsValid(int value);
constexpr UpdateType UpdateType_MIN = UPDATE_TYPE_UNSPECIFIED;
constexpr UpdateType UpdateType_MAX = UPDATE_TYPE_PARTICIPANT_LEFT;
constexpr int UpdateType_ARRAYSIZE = UpdateType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UpdateType_descriptor();
template<typename T>
inline const std::string& UpdateType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UpdateType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UpdateType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UpdateType_descriptor(), enum_t_value);
}
inline bool UpdateType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UpdateType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UpdateType>(
    UpdateType_descriptor(), name, value);
}
// ===================================================================

class Conversation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.chat.v1.Conversation) */ {
 public:
  inline Conversation() : Conversation(nullptr) {}
  ~Conversation() override;
  explicit PROTOBUF_CONSTEXPR Conversation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Conversation(const Conversation& from);
  Conversation(Conversation&& from) noexcept
    : Conversation() {
    *this = ::std::move(from);
  }

  inline Conversation& operator=(const Conversation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Conversation& operator=(Conversation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Conversation& default_instance() {
    return *internal_default_instance();
  }
  static inline const Conversation* internal_default_instance() {
    return reinterpret_cast<const Conversation*>(
               &_Conversation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Conversation& a, Conversation& b) {
    a.Swap(&b);
  }
  inline void Swap(Conversation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Conversation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Conversation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Conversation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Conversation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Conversation& from) {
    Conversation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Conversation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.chat.v1.Conversation";
  }
  protected:
  explicit Conversation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParticipantIdsFieldNumber = 7,
    kTitleFieldNumber = 2,
    kDescriptionFieldNumber = 3,
    kMetadataFieldNumber = 1,
    kSettingsFieldNumber = 4,
    kMessageCountFieldNumber = 5,
    kStatusFieldNumber = 6,
  };
  // repeated string participant_ids = 7;
  int participant_ids_size() const;
  private:
  int _internal_participant_ids_size() const;
  public:
  void clear_participant_ids();
  const std::string& participant_ids(int index) const;
  std::string* mutable_participant_ids(int index);
  void set_participant_ids(int index, const std::string& value);
  void set_participant_ids(int index, std::string&& value);
  void set_participant_ids(int index, const char* value);
  void set_participant_ids(int index, const char* value, size_t size);
  std::string* add_participant_ids();
  void add_participant_ids(const std::string& value);
  void add_participant_ids(std::string&& value);
  void add_participant_ids(const char* value);
  void add_participant_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& participant_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_participant_ids();
  private:
  const std::string& _internal_participant_ids(int index) const;
  std::string* _internal_add_participant_ids();
  public:

  // string title = 2;
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // string description = 3;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // .unhinged.common.v1.ResourceMetadata metadata = 1;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::unhinged::common::v1::ResourceMetadata& metadata() const;
  PROTOBUF_NODISCARD ::unhinged::common::v1::ResourceMetadata* release_metadata();
  ::unhinged::common::v1::ResourceMetadata* mutable_metadata();
  void set_allocated_metadata(::unhinged::common::v1::ResourceMetadata* metadata);
  private:
  const ::unhinged::common::v1::ResourceMetadata& _internal_metadata() const;
  ::unhinged::common::v1::ResourceMetadata* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::unhinged::common::v1::ResourceMetadata* metadata);
  ::unhinged::common::v1::ResourceMetadata* unsafe_arena_release_metadata();

  // .unhinged.chat.v1.ConversationSettings settings = 4;
  bool has_settings() const;
  private:
  bool _internal_has_settings() const;
  public:
  void clear_settings();
  const ::unhinged::chat::v1::ConversationSettings& settings() const;
  PROTOBUF_NODISCARD ::unhinged::chat::v1::ConversationSettings* release_settings();
  ::unhinged::chat::v1::ConversationSettings* mutable_settings();
  void set_allocated_settings(::unhinged::chat::v1::ConversationSettings* settings);
  private:
  const ::unhinged::chat::v1::ConversationSettings& _internal_settings() const;
  ::unhinged::chat::v1::ConversationSettings* _internal_mutable_settings();
  public:
  void unsafe_arena_set_allocated_settings(
      ::unhinged::chat::v1::ConversationSettings* settings);
  ::unhinged::chat::v1::ConversationSettings* unsafe_arena_release_settings();

  // int32 message_count = 5;
  void clear_message_count();
  int32_t message_count() const;
  void set_message_count(int32_t value);
  private:
  int32_t _internal_message_count() const;
  void _internal_set_message_count(int32_t value);
  public:

  // .unhinged.chat.v1.ConversationStatus status = 6;
  void clear_status();
  ::unhinged::chat::v1::ConversationStatus status() const;
  void set_status(::unhinged::chat::v1::ConversationStatus value);
  private:
  ::unhinged::chat::v1::ConversationStatus _internal_status() const;
  void _internal_set_status(::unhinged::chat::v1::ConversationStatus value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.chat.v1.Conversation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> participant_ids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::unhinged::common::v1::ResourceMetadata* metadata_;
    ::unhinged::chat::v1::ConversationSettings* settings_;
    int32_t message_count_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_2eproto;
};
// -------------------------------------------------------------------

class ConversationSettings final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.chat.v1.ConversationSettings) */ {
 public:
  inline ConversationSettings() : ConversationSettings(nullptr) {}
  ~ConversationSettings() override;
  explicit PROTOBUF_CONSTEXPR ConversationSettings(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConversationSettings(const ConversationSettings& from);
  ConversationSettings(ConversationSettings&& from) noexcept
    : ConversationSettings() {
    *this = ::std::move(from);
  }

  inline ConversationSettings& operator=(const ConversationSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConversationSettings& operator=(ConversationSettings&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConversationSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConversationSettings* internal_default_instance() {
    return reinterpret_cast<const ConversationSettings*>(
               &_ConversationSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ConversationSettings& a, ConversationSettings& b) {
    a.Swap(&b);
  }
  inline void Swap(ConversationSettings* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConversationSettings* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConversationSettings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConversationSettings>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConversationSettings& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConversationSettings& from) {
    ConversationSettings::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConversationSettings* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.chat.v1.ConversationSettings";
  }
  protected:
  explicit ConversationSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStopSequencesFieldNumber = 4,
    kAvailableToolsFieldNumber = 8,
    kModelFieldNumber = 1,
    kTemperatureFieldNumber = 2,
    kMaxTokensFieldNumber = 3,
    kContextWindowSizeFieldNumber = 6,
    kIncludeContextFieldNumber = 5,
    kEnableToolsFieldNumber = 7,
  };
  // repeated string stop_sequences = 4;
  int stop_sequences_size() const;
  private:
  int _internal_stop_sequences_size() const;
  public:
  void clear_stop_sequences();
  const std::string& stop_sequences(int index) const;
  std::string* mutable_stop_sequences(int index);
  void set_stop_sequences(int index, const std::string& value);
  void set_stop_sequences(int index, std::string&& value);
  void set_stop_sequences(int index, const char* value);
  void set_stop_sequences(int index, const char* value, size_t size);
  std::string* add_stop_sequences();
  void add_stop_sequences(const std::string& value);
  void add_stop_sequences(std::string&& value);
  void add_stop_sequences(const char* value);
  void add_stop_sequences(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& stop_sequences() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_stop_sequences();
  private:
  const std::string& _internal_stop_sequences(int index) const;
  std::string* _internal_add_stop_sequences();
  public:

  // repeated string available_tools = 8;
  int available_tools_size() const;
  private:
  int _internal_available_tools_size() const;
  public:
  void clear_available_tools();
  const std::string& available_tools(int index) const;
  std::string* mutable_available_tools(int index);
  void set_available_tools(int index, const std::string& value);
  void set_available_tools(int index, std::string&& value);
  void set_available_tools(int index, const char* value);
  void set_available_tools(int index, const char* value, size_t size);
  std::string* add_available_tools();
  void add_available_tools(const std::string& value);
  void add_available_tools(std::string&& value);
  void add_available_tools(const char* value);
  void add_available_tools(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& available_tools() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_available_tools();
  private:
  const std::string& _internal_available_tools(int index) const;
  std::string* _internal_add_available_tools();
  public:

  // string model = 1;
  void clear_model();
  const std::string& model() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model();
  PROTOBUF_NODISCARD std::string* release_model();
  void set_allocated_model(std::string* model);
  private:
  const std::string& _internal_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model(const std::string& value);
  std::string* _internal_mutable_model();
  public:

  // float temperature = 2;
  void clear_temperature();
  float temperature() const;
  void set_temperature(float value);
  private:
  float _internal_temperature() const;
  void _internal_set_temperature(float value);
  public:

  // int32 max_tokens = 3;
  void clear_max_tokens();
  int32_t max_tokens() const;
  void set_max_tokens(int32_t value);
  private:
  int32_t _internal_max_tokens() const;
  void _internal_set_max_tokens(int32_t value);
  public:

  // int32 context_window_size = 6;
  void clear_context_window_size();
  int32_t context_window_size() const;
  void set_context_window_size(int32_t value);
  private:
  int32_t _internal_context_window_size() const;
  void _internal_set_context_window_size(int32_t value);
  public:

  // bool include_context = 5;
  void clear_include_context();
  bool include_context() const;
  void set_include_context(bool value);
  private:
  bool _internal_include_context() const;
  void _internal_set_include_context(bool value);
  public:

  // bool enable_tools = 7;
  void clear_enable_tools();
  bool enable_tools() const;
  void set_enable_tools(bool value);
  private:
  bool _internal_enable_tools() const;
  void _internal_set_enable_tools(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.chat.v1.ConversationSettings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> stop_sequences_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> available_tools_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_;
    float temperature_;
    int32_t max_tokens_;
    int32_t context_window_size_;
    bool include_context_;
    bool enable_tools_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_2eproto;
};
// -------------------------------------------------------------------

class ChatMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.chat.v1.ChatMessage) */ {
 public:
  inline ChatMessage() : ChatMessage(nullptr) {}
  ~ChatMessage() override;
  explicit PROTOBUF_CONSTEXPR ChatMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChatMessage(const ChatMessage& from);
  ChatMessage(ChatMessage&& from) noexcept
    : ChatMessage() {
    *this = ::std::move(from);
  }

  inline ChatMessage& operator=(const ChatMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatMessage& operator=(ChatMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChatMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChatMessage* internal_default_instance() {
    return reinterpret_cast<const ChatMessage*>(
               &_ChatMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ChatMessage& a, ChatMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ChatMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChatMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChatMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChatMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChatMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChatMessage& from) {
    ChatMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChatMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.chat.v1.ChatMessage";
  }
  protected:
  explicit ChatMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttachmentsFieldNumber = 5,
    kToolCallsFieldNumber = 9,
    kConversationIdFieldNumber = 2,
    kContentFieldNumber = 4,
    kParentMessageIdFieldNumber = 7,
    kMetadataFieldNumber = 1,
    kUsageFieldNumber = 8,
    kRoleFieldNumber = 3,
    kStatusFieldNumber = 6,
  };
  // repeated .unhinged.common.v1.Attachment attachments = 5;
  int attachments_size() const;
  private:
  int _internal_attachments_size() const;
  public:
  void clear_attachments();
  ::unhinged::common::v1::Attachment* mutable_attachments(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::common::v1::Attachment >*
      mutable_attachments();
  private:
  const ::unhinged::common::v1::Attachment& _internal_attachments(int index) const;
  ::unhinged::common::v1::Attachment* _internal_add_attachments();
  public:
  const ::unhinged::common::v1::Attachment& attachments(int index) const;
  ::unhinged::common::v1::Attachment* add_attachments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::common::v1::Attachment >&
      attachments() const;

  // repeated .unhinged.chat.v1.ToolCall tool_calls = 9;
  int tool_calls_size() const;
  private:
  int _internal_tool_calls_size() const;
  public:
  void clear_tool_calls();
  ::unhinged::chat::v1::ToolCall* mutable_tool_calls(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::chat::v1::ToolCall >*
      mutable_tool_calls();
  private:
  const ::unhinged::chat::v1::ToolCall& _internal_tool_calls(int index) const;
  ::unhinged::chat::v1::ToolCall* _internal_add_tool_calls();
  public:
  const ::unhinged::chat::v1::ToolCall& tool_calls(int index) const;
  ::unhinged::chat::v1::ToolCall* add_tool_calls();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::chat::v1::ToolCall >&
      tool_calls() const;

  // string conversation_id = 2;
  void clear_conversation_id();
  const std::string& conversation_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_conversation_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_conversation_id();
  PROTOBUF_NODISCARD std::string* release_conversation_id();
  void set_allocated_conversation_id(std::string* conversation_id);
  private:
  const std::string& _internal_conversation_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_conversation_id(const std::string& value);
  std::string* _internal_mutable_conversation_id();
  public:

  // string content = 4;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // string parent_message_id = 7;
  void clear_parent_message_id();
  const std::string& parent_message_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent_message_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent_message_id();
  PROTOBUF_NODISCARD std::string* release_parent_message_id();
  void set_allocated_parent_message_id(std::string* parent_message_id);
  private:
  const std::string& _internal_parent_message_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent_message_id(const std::string& value);
  std::string* _internal_mutable_parent_message_id();
  public:

  // .unhinged.common.v1.ResourceMetadata metadata = 1;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::unhinged::common::v1::ResourceMetadata& metadata() const;
  PROTOBUF_NODISCARD ::unhinged::common::v1::ResourceMetadata* release_metadata();
  ::unhinged::common::v1::ResourceMetadata* mutable_metadata();
  void set_allocated_metadata(::unhinged::common::v1::ResourceMetadata* metadata);
  private:
  const ::unhinged::common::v1::ResourceMetadata& _internal_metadata() const;
  ::unhinged::common::v1::ResourceMetadata* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::unhinged::common::v1::ResourceMetadata* metadata);
  ::unhinged::common::v1::ResourceMetadata* unsafe_arena_release_metadata();

  // .unhinged.common.v1.UsageMetrics usage = 8;
  bool has_usage() const;
  private:
  bool _internal_has_usage() const;
  public:
  void clear_usage();
  const ::unhinged::common::v1::UsageMetrics& usage() const;
  PROTOBUF_NODISCARD ::unhinged::common::v1::UsageMetrics* release_usage();
  ::unhinged::common::v1::UsageMetrics* mutable_usage();
  void set_allocated_usage(::unhinged::common::v1::UsageMetrics* usage);
  private:
  const ::unhinged::common::v1::UsageMetrics& _internal_usage() const;
  ::unhinged::common::v1::UsageMetrics* _internal_mutable_usage();
  public:
  void unsafe_arena_set_allocated_usage(
      ::unhinged::common::v1::UsageMetrics* usage);
  ::unhinged::common::v1::UsageMetrics* unsafe_arena_release_usage();

  // .unhinged.chat.v1.MessageRole role = 3;
  void clear_role();
  ::unhinged::chat::v1::MessageRole role() const;
  void set_role(::unhinged::chat::v1::MessageRole value);
  private:
  ::unhinged::chat::v1::MessageRole _internal_role() const;
  void _internal_set_role(::unhinged::chat::v1::MessageRole value);
  public:

  // .unhinged.chat.v1.MessageStatus status = 6;
  void clear_status();
  ::unhinged::chat::v1::MessageStatus status() const;
  void set_status(::unhinged::chat::v1::MessageStatus value);
  private:
  ::unhinged::chat::v1::MessageStatus _internal_status() const;
  void _internal_set_status(::unhinged::chat::v1::MessageStatus value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.chat.v1.ChatMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::common::v1::Attachment > attachments_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::chat::v1::ToolCall > tool_calls_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr conversation_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_message_id_;
    ::unhinged::common::v1::ResourceMetadata* metadata_;
    ::unhinged::common::v1::UsageMetrics* usage_;
    int role_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_2eproto;
};
// -------------------------------------------------------------------

class ToolCall final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.chat.v1.ToolCall) */ {
 public:
  inline ToolCall() : ToolCall(nullptr) {}
  ~ToolCall() override;
  explicit PROTOBUF_CONSTEXPR ToolCall(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ToolCall(const ToolCall& from);
  ToolCall(ToolCall&& from) noexcept
    : ToolCall() {
    *this = ::std::move(from);
  }

  inline ToolCall& operator=(const ToolCall& from) {
    CopyFrom(from);
    return *this;
  }
  inline ToolCall& operator=(ToolCall&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ToolCall& default_instance() {
    return *internal_default_instance();
  }
  static inline const ToolCall* internal_default_instance() {
    return reinterpret_cast<const ToolCall*>(
               &_ToolCall_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ToolCall& a, ToolCall& b) {
    a.Swap(&b);
  }
  inline void Swap(ToolCall* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ToolCall* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ToolCall* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ToolCall>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ToolCall& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ToolCall& from) {
    ToolCall::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ToolCall* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.chat.v1.ToolCall";
  }
  protected:
  explicit ToolCall(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kToolCallIdFieldNumber = 1,
    kToolNameFieldNumber = 2,
    kArgumentsFieldNumber = 3,
    kResultFieldNumber = 4,
    kStatusFieldNumber = 5,
  };
  // string tool_call_id = 1;
  void clear_tool_call_id();
  const std::string& tool_call_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tool_call_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tool_call_id();
  PROTOBUF_NODISCARD std::string* release_tool_call_id();
  void set_allocated_tool_call_id(std::string* tool_call_id);
  private:
  const std::string& _internal_tool_call_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tool_call_id(const std::string& value);
  std::string* _internal_mutable_tool_call_id();
  public:

  // string tool_name = 2;
  void clear_tool_name();
  const std::string& tool_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tool_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tool_name();
  PROTOBUF_NODISCARD std::string* release_tool_name();
  void set_allocated_tool_name(std::string* tool_name);
  private:
  const std::string& _internal_tool_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tool_name(const std::string& value);
  std::string* _internal_mutable_tool_name();
  public:

  // string arguments = 3;
  void clear_arguments();
  const std::string& arguments() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_arguments(ArgT0&& arg0, ArgT... args);
  std::string* mutable_arguments();
  PROTOBUF_NODISCARD std::string* release_arguments();
  void set_allocated_arguments(std::string* arguments);
  private:
  const std::string& _internal_arguments() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_arguments(const std::string& value);
  std::string* _internal_mutable_arguments();
  public:

  // string result = 4;
  void clear_result();
  const std::string& result() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_result(ArgT0&& arg0, ArgT... args);
  std::string* mutable_result();
  PROTOBUF_NODISCARD std::string* release_result();
  void set_allocated_result(std::string* result);
  private:
  const std::string& _internal_result() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_result(const std::string& value);
  std::string* _internal_mutable_result();
  public:

  // .unhinged.chat.v1.ToolCallStatus status = 5;
  void clear_status();
  ::unhinged::chat::v1::ToolCallStatus status() const;
  void set_status(::unhinged::chat::v1::ToolCallStatus value);
  private:
  ::unhinged::chat::v1::ToolCallStatus _internal_status() const;
  void _internal_set_status(::unhinged::chat::v1::ToolCallStatus value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.chat.v1.ToolCall)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tool_call_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tool_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr arguments_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr result_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_2eproto;
};
// -------------------------------------------------------------------

class CreateConversationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.chat.v1.CreateConversationRequest) */ {
 public:
  inline CreateConversationRequest() : CreateConversationRequest(nullptr) {}
  ~CreateConversationRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateConversationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateConversationRequest(const CreateConversationRequest& from);
  CreateConversationRequest(CreateConversationRequest&& from) noexcept
    : CreateConversationRequest() {
    *this = ::std::move(from);
  }

  inline CreateConversationRequest& operator=(const CreateConversationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateConversationRequest& operator=(CreateConversationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateConversationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateConversationRequest* internal_default_instance() {
    return reinterpret_cast<const CreateConversationRequest*>(
               &_CreateConversationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CreateConversationRequest& a, CreateConversationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateConversationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateConversationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateConversationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateConversationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateConversationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateConversationRequest& from) {
    CreateConversationRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateConversationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.chat.v1.CreateConversationRequest";
  }
  protected:
  explicit CreateConversationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTeamIdFieldNumber = 1,
    kNamespaceIdFieldNumber = 2,
    kTitleFieldNumber = 3,
    kDescriptionFieldNumber = 4,
    kSettingsFieldNumber = 5,
  };
  // string team_id = 1;
  void clear_team_id();
  const std::string& team_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_team_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_team_id();
  PROTOBUF_NODISCARD std::string* release_team_id();
  void set_allocated_team_id(std::string* team_id);
  private:
  const std::string& _internal_team_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_team_id(const std::string& value);
  std::string* _internal_mutable_team_id();
  public:

  // string namespace_id = 2;
  void clear_namespace_id();
  const std::string& namespace_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_namespace_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_namespace_id();
  PROTOBUF_NODISCARD std::string* release_namespace_id();
  void set_allocated_namespace_id(std::string* namespace_id);
  private:
  const std::string& _internal_namespace_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_namespace_id(const std::string& value);
  std::string* _internal_mutable_namespace_id();
  public:

  // string title = 3;
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // string description = 4;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // .unhinged.chat.v1.ConversationSettings settings = 5;
  bool has_settings() const;
  private:
  bool _internal_has_settings() const;
  public:
  void clear_settings();
  const ::unhinged::chat::v1::ConversationSettings& settings() const;
  PROTOBUF_NODISCARD ::unhinged::chat::v1::ConversationSettings* release_settings();
  ::unhinged::chat::v1::ConversationSettings* mutable_settings();
  void set_allocated_settings(::unhinged::chat::v1::ConversationSettings* settings);
  private:
  const ::unhinged::chat::v1::ConversationSettings& _internal_settings() const;
  ::unhinged::chat::v1::ConversationSettings* _internal_mutable_settings();
  public:
  void unsafe_arena_set_allocated_settings(
      ::unhinged::chat::v1::ConversationSettings* settings);
  ::unhinged::chat::v1::ConversationSettings* unsafe_arena_release_settings();

  // @@protoc_insertion_point(class_scope:unhinged.chat.v1.CreateConversationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr team_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr namespace_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::unhinged::chat::v1::ConversationSettings* settings_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_2eproto;
};
// -------------------------------------------------------------------

class CreateConversationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.chat.v1.CreateConversationResponse) */ {
 public:
  inline CreateConversationResponse() : CreateConversationResponse(nullptr) {}
  ~CreateConversationResponse() override;
  explicit PROTOBUF_CONSTEXPR CreateConversationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateConversationResponse(const CreateConversationResponse& from);
  CreateConversationResponse(CreateConversationResponse&& from) noexcept
    : CreateConversationResponse() {
    *this = ::std::move(from);
  }

  inline CreateConversationResponse& operator=(const CreateConversationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateConversationResponse& operator=(CreateConversationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateConversationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateConversationResponse* internal_default_instance() {
    return reinterpret_cast<const CreateConversationResponse*>(
               &_CreateConversationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CreateConversationResponse& a, CreateConversationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateConversationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateConversationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateConversationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateConversationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateConversationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateConversationResponse& from) {
    CreateConversationResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateConversationResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.chat.v1.CreateConversationResponse";
  }
  protected:
  explicit CreateConversationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 1,
    kConversationFieldNumber = 2,
  };
  // .unhinged.common.v1.StandardResponse response = 1;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::unhinged::common::v1::StandardResponse& response() const;
  PROTOBUF_NODISCARD ::unhinged::common::v1::StandardResponse* release_response();
  ::unhinged::common::v1::StandardResponse* mutable_response();
  void set_allocated_response(::unhinged::common::v1::StandardResponse* response);
  private:
  const ::unhinged::common::v1::StandardResponse& _internal_response() const;
  ::unhinged::common::v1::StandardResponse* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::unhinged::common::v1::StandardResponse* response);
  ::unhinged::common::v1::StandardResponse* unsafe_arena_release_response();

  // .unhinged.chat.v1.Conversation conversation = 2;
  bool has_conversation() const;
  private:
  bool _internal_has_conversation() const;
  public:
  void clear_conversation();
  const ::unhinged::chat::v1::Conversation& conversation() const;
  PROTOBUF_NODISCARD ::unhinged::chat::v1::Conversation* release_conversation();
  ::unhinged::chat::v1::Conversation* mutable_conversation();
  void set_allocated_conversation(::unhinged::chat::v1::Conversation* conversation);
  private:
  const ::unhinged::chat::v1::Conversation& _internal_conversation() const;
  ::unhinged::chat::v1::Conversation* _internal_mutable_conversation();
  public:
  void unsafe_arena_set_allocated_conversation(
      ::unhinged::chat::v1::Conversation* conversation);
  ::unhinged::chat::v1::Conversation* unsafe_arena_release_conversation();

  // @@protoc_insertion_point(class_scope:unhinged.chat.v1.CreateConversationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::unhinged::common::v1::StandardResponse* response_;
    ::unhinged::chat::v1::Conversation* conversation_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_2eproto;
};
// -------------------------------------------------------------------

class GetConversationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.chat.v1.GetConversationRequest) */ {
 public:
  inline GetConversationRequest() : GetConversationRequest(nullptr) {}
  ~GetConversationRequest() override;
  explicit PROTOBUF_CONSTEXPR GetConversationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetConversationRequest(const GetConversationRequest& from);
  GetConversationRequest(GetConversationRequest&& from) noexcept
    : GetConversationRequest() {
    *this = ::std::move(from);
  }

  inline GetConversationRequest& operator=(const GetConversationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetConversationRequest& operator=(GetConversationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetConversationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetConversationRequest* internal_default_instance() {
    return reinterpret_cast<const GetConversationRequest*>(
               &_GetConversationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GetConversationRequest& a, GetConversationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetConversationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetConversationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetConversationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetConversationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetConversationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetConversationRequest& from) {
    GetConversationRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetConversationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.chat.v1.GetConversationRequest";
  }
  protected:
  explicit GetConversationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConversationIdFieldNumber = 1,
    kIncludeMessagesFieldNumber = 2,
    kMessageLimitFieldNumber = 3,
  };
  // string conversation_id = 1;
  void clear_conversation_id();
  const std::string& conversation_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_conversation_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_conversation_id();
  PROTOBUF_NODISCARD std::string* release_conversation_id();
  void set_allocated_conversation_id(std::string* conversation_id);
  private:
  const std::string& _internal_conversation_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_conversation_id(const std::string& value);
  std::string* _internal_mutable_conversation_id();
  public:

  // bool include_messages = 2;
  void clear_include_messages();
  bool include_messages() const;
  void set_include_messages(bool value);
  private:
  bool _internal_include_messages() const;
  void _internal_set_include_messages(bool value);
  public:

  // int32 message_limit = 3;
  void clear_message_limit();
  int32_t message_limit() const;
  void set_message_limit(int32_t value);
  private:
  int32_t _internal_message_limit() const;
  void _internal_set_message_limit(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.chat.v1.GetConversationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr conversation_id_;
    bool include_messages_;
    int32_t message_limit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_2eproto;
};
// -------------------------------------------------------------------

class GetConversationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.chat.v1.GetConversationResponse) */ {
 public:
  inline GetConversationResponse() : GetConversationResponse(nullptr) {}
  ~GetConversationResponse() override;
  explicit PROTOBUF_CONSTEXPR GetConversationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetConversationResponse(const GetConversationResponse& from);
  GetConversationResponse(GetConversationResponse&& from) noexcept
    : GetConversationResponse() {
    *this = ::std::move(from);
  }

  inline GetConversationResponse& operator=(const GetConversationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetConversationResponse& operator=(GetConversationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetConversationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetConversationResponse* internal_default_instance() {
    return reinterpret_cast<const GetConversationResponse*>(
               &_GetConversationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GetConversationResponse& a, GetConversationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetConversationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetConversationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetConversationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetConversationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetConversationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetConversationResponse& from) {
    GetConversationResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetConversationResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.chat.v1.GetConversationResponse";
  }
  protected:
  explicit GetConversationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessagesFieldNumber = 3,
    kResponseFieldNumber = 1,
    kConversationFieldNumber = 2,
  };
  // repeated .unhinged.chat.v1.ChatMessage messages = 3;
  int messages_size() const;
  private:
  int _internal_messages_size() const;
  public:
  void clear_messages();
  ::unhinged::chat::v1::ChatMessage* mutable_messages(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::chat::v1::ChatMessage >*
      mutable_messages();
  private:
  const ::unhinged::chat::v1::ChatMessage& _internal_messages(int index) const;
  ::unhinged::chat::v1::ChatMessage* _internal_add_messages();
  public:
  const ::unhinged::chat::v1::ChatMessage& messages(int index) const;
  ::unhinged::chat::v1::ChatMessage* add_messages();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::chat::v1::ChatMessage >&
      messages() const;

  // .unhinged.common.v1.StandardResponse response = 1;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::unhinged::common::v1::StandardResponse& response() const;
  PROTOBUF_NODISCARD ::unhinged::common::v1::StandardResponse* release_response();
  ::unhinged::common::v1::StandardResponse* mutable_response();
  void set_allocated_response(::unhinged::common::v1::StandardResponse* response);
  private:
  const ::unhinged::common::v1::StandardResponse& _internal_response() const;
  ::unhinged::common::v1::StandardResponse* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::unhinged::common::v1::StandardResponse* response);
  ::unhinged::common::v1::StandardResponse* unsafe_arena_release_response();

  // .unhinged.chat.v1.Conversation conversation = 2;
  bool has_conversation() const;
  private:
  bool _internal_has_conversation() const;
  public:
  void clear_conversation();
  const ::unhinged::chat::v1::Conversation& conversation() const;
  PROTOBUF_NODISCARD ::unhinged::chat::v1::Conversation* release_conversation();
  ::unhinged::chat::v1::Conversation* mutable_conversation();
  void set_allocated_conversation(::unhinged::chat::v1::Conversation* conversation);
  private:
  const ::unhinged::chat::v1::Conversation& _internal_conversation() const;
  ::unhinged::chat::v1::Conversation* _internal_mutable_conversation();
  public:
  void unsafe_arena_set_allocated_conversation(
      ::unhinged::chat::v1::Conversation* conversation);
  ::unhinged::chat::v1::Conversation* unsafe_arena_release_conversation();

  // @@protoc_insertion_point(class_scope:unhinged.chat.v1.GetConversationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::chat::v1::ChatMessage > messages_;
    ::unhinged::common::v1::StandardResponse* response_;
    ::unhinged::chat::v1::Conversation* conversation_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_2eproto;
};
// -------------------------------------------------------------------

class ListConversationsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.chat.v1.ListConversationsRequest) */ {
 public:
  inline ListConversationsRequest() : ListConversationsRequest(nullptr) {}
  ~ListConversationsRequest() override;
  explicit PROTOBUF_CONSTEXPR ListConversationsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListConversationsRequest(const ListConversationsRequest& from);
  ListConversationsRequest(ListConversationsRequest&& from) noexcept
    : ListConversationsRequest() {
    *this = ::std::move(from);
  }

  inline ListConversationsRequest& operator=(const ListConversationsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListConversationsRequest& operator=(ListConversationsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListConversationsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListConversationsRequest* internal_default_instance() {
    return reinterpret_cast<const ListConversationsRequest*>(
               &_ListConversationsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ListConversationsRequest& a, ListConversationsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListConversationsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListConversationsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListConversationsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListConversationsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListConversationsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListConversationsRequest& from) {
    ListConversationsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListConversationsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.chat.v1.ListConversationsRequest";
  }
  protected:
  explicit ListConversationsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFiltersFieldNumber = 5,
    kTeamIdFieldNumber = 1,
    kNamespaceIdFieldNumber = 2,
    kPaginationFieldNumber = 4,
    kStatusFieldNumber = 3,
  };
  // repeated .unhinged.common.v1.Filter filters = 5;
  int filters_size() const;
  private:
  int _internal_filters_size() const;
  public:
  void clear_filters();
  ::unhinged::common::v1::Filter* mutable_filters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::common::v1::Filter >*
      mutable_filters();
  private:
  const ::unhinged::common::v1::Filter& _internal_filters(int index) const;
  ::unhinged::common::v1::Filter* _internal_add_filters();
  public:
  const ::unhinged::common::v1::Filter& filters(int index) const;
  ::unhinged::common::v1::Filter* add_filters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::common::v1::Filter >&
      filters() const;

  // string team_id = 1;
  void clear_team_id();
  const std::string& team_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_team_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_team_id();
  PROTOBUF_NODISCARD std::string* release_team_id();
  void set_allocated_team_id(std::string* team_id);
  private:
  const std::string& _internal_team_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_team_id(const std::string& value);
  std::string* _internal_mutable_team_id();
  public:

  // string namespace_id = 2;
  void clear_namespace_id();
  const std::string& namespace_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_namespace_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_namespace_id();
  PROTOBUF_NODISCARD std::string* release_namespace_id();
  void set_allocated_namespace_id(std::string* namespace_id);
  private:
  const std::string& _internal_namespace_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_namespace_id(const std::string& value);
  std::string* _internal_mutable_namespace_id();
  public:

  // .unhinged.common.v1.PaginationRequest pagination = 4;
  bool has_pagination() const;
  private:
  bool _internal_has_pagination() const;
  public:
  void clear_pagination();
  const ::unhinged::common::v1::PaginationRequest& pagination() const;
  PROTOBUF_NODISCARD ::unhinged::common::v1::PaginationRequest* release_pagination();
  ::unhinged::common::v1::PaginationRequest* mutable_pagination();
  void set_allocated_pagination(::unhinged::common::v1::PaginationRequest* pagination);
  private:
  const ::unhinged::common::v1::PaginationRequest& _internal_pagination() const;
  ::unhinged::common::v1::PaginationRequest* _internal_mutable_pagination();
  public:
  void unsafe_arena_set_allocated_pagination(
      ::unhinged::common::v1::PaginationRequest* pagination);
  ::unhinged::common::v1::PaginationRequest* unsafe_arena_release_pagination();

  // .unhinged.chat.v1.ConversationStatus status = 3;
  void clear_status();
  ::unhinged::chat::v1::ConversationStatus status() const;
  void set_status(::unhinged::chat::v1::ConversationStatus value);
  private:
  ::unhinged::chat::v1::ConversationStatus _internal_status() const;
  void _internal_set_status(::unhinged::chat::v1::ConversationStatus value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.chat.v1.ListConversationsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::common::v1::Filter > filters_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr team_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr namespace_id_;
    ::unhinged::common::v1::PaginationRequest* pagination_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_2eproto;
};
// -------------------------------------------------------------------

class ListConversationsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.chat.v1.ListConversationsResponse) */ {
 public:
  inline ListConversationsResponse() : ListConversationsResponse(nullptr) {}
  ~ListConversationsResponse() override;
  explicit PROTOBUF_CONSTEXPR ListConversationsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListConversationsResponse(const ListConversationsResponse& from);
  ListConversationsResponse(ListConversationsResponse&& from) noexcept
    : ListConversationsResponse() {
    *this = ::std::move(from);
  }

  inline ListConversationsResponse& operator=(const ListConversationsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListConversationsResponse& operator=(ListConversationsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListConversationsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListConversationsResponse* internal_default_instance() {
    return reinterpret_cast<const ListConversationsResponse*>(
               &_ListConversationsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ListConversationsResponse& a, ListConversationsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListConversationsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListConversationsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListConversationsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListConversationsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListConversationsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListConversationsResponse& from) {
    ListConversationsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListConversationsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.chat.v1.ListConversationsResponse";
  }
  protected:
  explicit ListConversationsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConversationsFieldNumber = 2,
    kResponseFieldNumber = 1,
    kPaginationFieldNumber = 3,
  };
  // repeated .unhinged.chat.v1.Conversation conversations = 2;
  int conversations_size() const;
  private:
  int _internal_conversations_size() const;
  public:
  void clear_conversations();
  ::unhinged::chat::v1::Conversation* mutable_conversations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::chat::v1::Conversation >*
      mutable_conversations();
  private:
  const ::unhinged::chat::v1::Conversation& _internal_conversations(int index) const;
  ::unhinged::chat::v1::Conversation* _internal_add_conversations();
  public:
  const ::unhinged::chat::v1::Conversation& conversations(int index) const;
  ::unhinged::chat::v1::Conversation* add_conversations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::chat::v1::Conversation >&
      conversations() const;

  // .unhinged.common.v1.StandardResponse response = 1;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::unhinged::common::v1::StandardResponse& response() const;
  PROTOBUF_NODISCARD ::unhinged::common::v1::StandardResponse* release_response();
  ::unhinged::common::v1::StandardResponse* mutable_response();
  void set_allocated_response(::unhinged::common::v1::StandardResponse* response);
  private:
  const ::unhinged::common::v1::StandardResponse& _internal_response() const;
  ::unhinged::common::v1::StandardResponse* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::unhinged::common::v1::StandardResponse* response);
  ::unhinged::common::v1::StandardResponse* unsafe_arena_release_response();

  // .unhinged.common.v1.PaginationResponse pagination = 3;
  bool has_pagination() const;
  private:
  bool _internal_has_pagination() const;
  public:
  void clear_pagination();
  const ::unhinged::common::v1::PaginationResponse& pagination() const;
  PROTOBUF_NODISCARD ::unhinged::common::v1::PaginationResponse* release_pagination();
  ::unhinged::common::v1::PaginationResponse* mutable_pagination();
  void set_allocated_pagination(::unhinged::common::v1::PaginationResponse* pagination);
  private:
  const ::unhinged::common::v1::PaginationResponse& _internal_pagination() const;
  ::unhinged::common::v1::PaginationResponse* _internal_mutable_pagination();
  public:
  void unsafe_arena_set_allocated_pagination(
      ::unhinged::common::v1::PaginationResponse* pagination);
  ::unhinged::common::v1::PaginationResponse* unsafe_arena_release_pagination();

  // @@protoc_insertion_point(class_scope:unhinged.chat.v1.ListConversationsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::chat::v1::Conversation > conversations_;
    ::unhinged::common::v1::StandardResponse* response_;
    ::unhinged::common::v1::PaginationResponse* pagination_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_2eproto;
};
// -------------------------------------------------------------------

class SendMessageRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.chat.v1.SendMessageRequest) */ {
 public:
  inline SendMessageRequest() : SendMessageRequest(nullptr) {}
  ~SendMessageRequest() override;
  explicit PROTOBUF_CONSTEXPR SendMessageRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendMessageRequest(const SendMessageRequest& from);
  SendMessageRequest(SendMessageRequest&& from) noexcept
    : SendMessageRequest() {
    *this = ::std::move(from);
  }

  inline SendMessageRequest& operator=(const SendMessageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendMessageRequest& operator=(SendMessageRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendMessageRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendMessageRequest* internal_default_instance() {
    return reinterpret_cast<const SendMessageRequest*>(
               &_SendMessageRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SendMessageRequest& a, SendMessageRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SendMessageRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendMessageRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendMessageRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendMessageRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendMessageRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SendMessageRequest& from) {
    SendMessageRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendMessageRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.chat.v1.SendMessageRequest";
  }
  protected:
  explicit SendMessageRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttachmentsFieldNumber = 4,
    kConversationIdFieldNumber = 1,
    kContentFieldNumber = 3,
    kParentMessageIdFieldNumber = 5,
    kRoleFieldNumber = 2,
  };
  // repeated .unhinged.common.v1.Attachment attachments = 4;
  int attachments_size() const;
  private:
  int _internal_attachments_size() const;
  public:
  void clear_attachments();
  ::unhinged::common::v1::Attachment* mutable_attachments(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::common::v1::Attachment >*
      mutable_attachments();
  private:
  const ::unhinged::common::v1::Attachment& _internal_attachments(int index) const;
  ::unhinged::common::v1::Attachment* _internal_add_attachments();
  public:
  const ::unhinged::common::v1::Attachment& attachments(int index) const;
  ::unhinged::common::v1::Attachment* add_attachments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::common::v1::Attachment >&
      attachments() const;

  // string conversation_id = 1;
  void clear_conversation_id();
  const std::string& conversation_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_conversation_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_conversation_id();
  PROTOBUF_NODISCARD std::string* release_conversation_id();
  void set_allocated_conversation_id(std::string* conversation_id);
  private:
  const std::string& _internal_conversation_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_conversation_id(const std::string& value);
  std::string* _internal_mutable_conversation_id();
  public:

  // string content = 3;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // string parent_message_id = 5;
  void clear_parent_message_id();
  const std::string& parent_message_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent_message_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent_message_id();
  PROTOBUF_NODISCARD std::string* release_parent_message_id();
  void set_allocated_parent_message_id(std::string* parent_message_id);
  private:
  const std::string& _internal_parent_message_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent_message_id(const std::string& value);
  std::string* _internal_mutable_parent_message_id();
  public:

  // .unhinged.chat.v1.MessageRole role = 2;
  void clear_role();
  ::unhinged::chat::v1::MessageRole role() const;
  void set_role(::unhinged::chat::v1::MessageRole value);
  private:
  ::unhinged::chat::v1::MessageRole _internal_role() const;
  void _internal_set_role(::unhinged::chat::v1::MessageRole value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.chat.v1.SendMessageRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::common::v1::Attachment > attachments_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr conversation_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_message_id_;
    int role_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_2eproto;
};
// -------------------------------------------------------------------

class SendMessageResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.chat.v1.SendMessageResponse) */ {
 public:
  inline SendMessageResponse() : SendMessageResponse(nullptr) {}
  ~SendMessageResponse() override;
  explicit PROTOBUF_CONSTEXPR SendMessageResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendMessageResponse(const SendMessageResponse& from);
  SendMessageResponse(SendMessageResponse&& from) noexcept
    : SendMessageResponse() {
    *this = ::std::move(from);
  }

  inline SendMessageResponse& operator=(const SendMessageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendMessageResponse& operator=(SendMessageResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendMessageResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendMessageResponse* internal_default_instance() {
    return reinterpret_cast<const SendMessageResponse*>(
               &_SendMessageResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SendMessageResponse& a, SendMessageResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SendMessageResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendMessageResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendMessageResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendMessageResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendMessageResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SendMessageResponse& from) {
    SendMessageResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendMessageResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.chat.v1.SendMessageResponse";
  }
  protected:
  explicit SendMessageResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 1,
    kMessageFieldNumber = 2,
  };
  // .unhinged.common.v1.StandardResponse response = 1;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::unhinged::common::v1::StandardResponse& response() const;
  PROTOBUF_NODISCARD ::unhinged::common::v1::StandardResponse* release_response();
  ::unhinged::common::v1::StandardResponse* mutable_response();
  void set_allocated_response(::unhinged::common::v1::StandardResponse* response);
  private:
  const ::unhinged::common::v1::StandardResponse& _internal_response() const;
  ::unhinged::common::v1::StandardResponse* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::unhinged::common::v1::StandardResponse* response);
  ::unhinged::common::v1::StandardResponse* unsafe_arena_release_response();

  // .unhinged.chat.v1.ChatMessage message = 2;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const ::unhinged::chat::v1::ChatMessage& message() const;
  PROTOBUF_NODISCARD ::unhinged::chat::v1::ChatMessage* release_message();
  ::unhinged::chat::v1::ChatMessage* mutable_message();
  void set_allocated_message(::unhinged::chat::v1::ChatMessage* message);
  private:
  const ::unhinged::chat::v1::ChatMessage& _internal_message() const;
  ::unhinged::chat::v1::ChatMessage* _internal_mutable_message();
  public:
  void unsafe_arena_set_allocated_message(
      ::unhinged::chat::v1::ChatMessage* message);
  ::unhinged::chat::v1::ChatMessage* unsafe_arena_release_message();

  // @@protoc_insertion_point(class_scope:unhinged.chat.v1.SendMessageResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::unhinged::common::v1::StandardResponse* response_;
    ::unhinged::chat::v1::ChatMessage* message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_2eproto;
};
// -------------------------------------------------------------------

class StreamChatRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.chat.v1.StreamChatRequest) */ {
 public:
  inline StreamChatRequest() : StreamChatRequest(nullptr) {}
  ~StreamChatRequest() override;
  explicit PROTOBUF_CONSTEXPR StreamChatRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamChatRequest(const StreamChatRequest& from);
  StreamChatRequest(StreamChatRequest&& from) noexcept
    : StreamChatRequest() {
    *this = ::std::move(from);
  }

  inline StreamChatRequest& operator=(const StreamChatRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamChatRequest& operator=(StreamChatRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamChatRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamChatRequest* internal_default_instance() {
    return reinterpret_cast<const StreamChatRequest*>(
               &_StreamChatRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(StreamChatRequest& a, StreamChatRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamChatRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamChatRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamChatRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamChatRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamChatRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamChatRequest& from) {
    StreamChatRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamChatRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.chat.v1.StreamChatRequest";
  }
  protected:
  explicit StreamChatRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttachmentsFieldNumber = 3,
    kConversationIdFieldNumber = 1,
    kContentFieldNumber = 2,
    kOptionsFieldNumber = 4,
  };
  // repeated .unhinged.common.v1.Attachment attachments = 3;
  int attachments_size() const;
  private:
  int _internal_attachments_size() const;
  public:
  void clear_attachments();
  ::unhinged::common::v1::Attachment* mutable_attachments(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::common::v1::Attachment >*
      mutable_attachments();
  private:
  const ::unhinged::common::v1::Attachment& _internal_attachments(int index) const;
  ::unhinged::common::v1::Attachment* _internal_add_attachments();
  public:
  const ::unhinged::common::v1::Attachment& attachments(int index) const;
  ::unhinged::common::v1::Attachment* add_attachments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::common::v1::Attachment >&
      attachments() const;

  // string conversation_id = 1;
  void clear_conversation_id();
  const std::string& conversation_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_conversation_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_conversation_id();
  PROTOBUF_NODISCARD std::string* release_conversation_id();
  void set_allocated_conversation_id(std::string* conversation_id);
  private:
  const std::string& _internal_conversation_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_conversation_id(const std::string& value);
  std::string* _internal_mutable_conversation_id();
  public:

  // string content = 2;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // .unhinged.chat.v1.StreamOptions options = 4;
  bool has_options() const;
  private:
  bool _internal_has_options() const;
  public:
  void clear_options();
  const ::unhinged::chat::v1::StreamOptions& options() const;
  PROTOBUF_NODISCARD ::unhinged::chat::v1::StreamOptions* release_options();
  ::unhinged::chat::v1::StreamOptions* mutable_options();
  void set_allocated_options(::unhinged::chat::v1::StreamOptions* options);
  private:
  const ::unhinged::chat::v1::StreamOptions& _internal_options() const;
  ::unhinged::chat::v1::StreamOptions* _internal_mutable_options();
  public:
  void unsafe_arena_set_allocated_options(
      ::unhinged::chat::v1::StreamOptions* options);
  ::unhinged::chat::v1::StreamOptions* unsafe_arena_release_options();

  // @@protoc_insertion_point(class_scope:unhinged.chat.v1.StreamChatRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::common::v1::Attachment > attachments_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr conversation_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    ::unhinged::chat::v1::StreamOptions* options_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_2eproto;
};
// -------------------------------------------------------------------

class StreamOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.chat.v1.StreamOptions) */ {
 public:
  inline StreamOptions() : StreamOptions(nullptr) {}
  ~StreamOptions() override;
  explicit PROTOBUF_CONSTEXPR StreamOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamOptions(const StreamOptions& from);
  StreamOptions(StreamOptions&& from) noexcept
    : StreamOptions() {
    *this = ::std::move(from);
  }

  inline StreamOptions& operator=(const StreamOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamOptions& operator=(StreamOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamOptions* internal_default_instance() {
    return reinterpret_cast<const StreamOptions*>(
               &_StreamOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(StreamOptions& a, StreamOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamOptions& from) {
    StreamOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.chat.v1.StreamOptions";
  }
  protected:
  explicit StreamOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelFieldNumber = 1,
    kMaxTokensFieldNumber = 2,
    kTemperatureFieldNumber = 3,
    kIncludeContextFieldNumber = 4,
    kEnableToolsFieldNumber = 5,
  };
  // string model = 1;
  void clear_model();
  const std::string& model() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model();
  PROTOBUF_NODISCARD std::string* release_model();
  void set_allocated_model(std::string* model);
  private:
  const std::string& _internal_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model(const std::string& value);
  std::string* _internal_mutable_model();
  public:

  // int32 max_tokens = 2;
  void clear_max_tokens();
  int32_t max_tokens() const;
  void set_max_tokens(int32_t value);
  private:
  int32_t _internal_max_tokens() const;
  void _internal_set_max_tokens(int32_t value);
  public:

  // float temperature = 3;
  void clear_temperature();
  float temperature() const;
  void set_temperature(float value);
  private:
  float _internal_temperature() const;
  void _internal_set_temperature(float value);
  public:

  // bool include_context = 4;
  void clear_include_context();
  bool include_context() const;
  void set_include_context(bool value);
  private:
  bool _internal_include_context() const;
  void _internal_set_include_context(bool value);
  public:

  // bool enable_tools = 5;
  void clear_enable_tools();
  bool enable_tools() const;
  void set_enable_tools(bool value);
  private:
  bool _internal_enable_tools() const;
  void _internal_set_enable_tools(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.chat.v1.StreamOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_;
    int32_t max_tokens_;
    float temperature_;
    bool include_context_;
    bool enable_tools_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_2eproto;
};
// -------------------------------------------------------------------

class ChatChunkPayload final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.chat.v1.ChatChunkPayload) */ {
 public:
  inline ChatChunkPayload() : ChatChunkPayload(nullptr) {}
  ~ChatChunkPayload() override;
  explicit PROTOBUF_CONSTEXPR ChatChunkPayload(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChatChunkPayload(const ChatChunkPayload& from);
  ChatChunkPayload(ChatChunkPayload&& from) noexcept
    : ChatChunkPayload() {
    *this = ::std::move(from);
  }

  inline ChatChunkPayload& operator=(const ChatChunkPayload& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatChunkPayload& operator=(ChatChunkPayload&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChatChunkPayload& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChatChunkPayload* internal_default_instance() {
    return reinterpret_cast<const ChatChunkPayload*>(
               &_ChatChunkPayload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ChatChunkPayload& a, ChatChunkPayload& b) {
    a.Swap(&b);
  }
  inline void Swap(ChatChunkPayload* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChatChunkPayload* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChatChunkPayload* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChatChunkPayload>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChatChunkPayload& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChatChunkPayload& from) {
    ChatChunkPayload::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChatChunkPayload* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.chat.v1.ChatChunkPayload";
  }
  protected:
  explicit ChatChunkPayload(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kToolCallsFieldNumber = 5,
    kMessageIdFieldNumber = 1,
    kConversationIdFieldNumber = 2,
    kContentFieldNumber = 4,
    kRoleFieldNumber = 3,
  };
  // repeated .unhinged.chat.v1.ToolCall tool_calls = 5;
  int tool_calls_size() const;
  private:
  int _internal_tool_calls_size() const;
  public:
  void clear_tool_calls();
  ::unhinged::chat::v1::ToolCall* mutable_tool_calls(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::chat::v1::ToolCall >*
      mutable_tool_calls();
  private:
  const ::unhinged::chat::v1::ToolCall& _internal_tool_calls(int index) const;
  ::unhinged::chat::v1::ToolCall* _internal_add_tool_calls();
  public:
  const ::unhinged::chat::v1::ToolCall& tool_calls(int index) const;
  ::unhinged::chat::v1::ToolCall* add_tool_calls();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::chat::v1::ToolCall >&
      tool_calls() const;

  // string message_id = 1;
  void clear_message_id();
  const std::string& message_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message_id();
  PROTOBUF_NODISCARD std::string* release_message_id();
  void set_allocated_message_id(std::string* message_id);
  private:
  const std::string& _internal_message_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message_id(const std::string& value);
  std::string* _internal_mutable_message_id();
  public:

  // string conversation_id = 2;
  void clear_conversation_id();
  const std::string& conversation_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_conversation_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_conversation_id();
  PROTOBUF_NODISCARD std::string* release_conversation_id();
  void set_allocated_conversation_id(std::string* conversation_id);
  private:
  const std::string& _internal_conversation_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_conversation_id(const std::string& value);
  std::string* _internal_mutable_conversation_id();
  public:

  // string content = 4;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // .unhinged.chat.v1.MessageRole role = 3;
  void clear_role();
  ::unhinged::chat::v1::MessageRole role() const;
  void set_role(::unhinged::chat::v1::MessageRole value);
  private:
  ::unhinged::chat::v1::MessageRole _internal_role() const;
  void _internal_set_role(::unhinged::chat::v1::MessageRole value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.chat.v1.ChatChunkPayload)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::chat::v1::ToolCall > tool_calls_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr conversation_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    int role_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_2eproto;
};
// -------------------------------------------------------------------

class SubscribeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.chat.v1.SubscribeRequest) */ {
 public:
  inline SubscribeRequest() : SubscribeRequest(nullptr) {}
  ~SubscribeRequest() override;
  explicit PROTOBUF_CONSTEXPR SubscribeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscribeRequest(const SubscribeRequest& from);
  SubscribeRequest(SubscribeRequest&& from) noexcept
    : SubscribeRequest() {
    *this = ::std::move(from);
  }

  inline SubscribeRequest& operator=(const SubscribeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeRequest& operator=(SubscribeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscribeRequest* internal_default_instance() {
    return reinterpret_cast<const SubscribeRequest*>(
               &_SubscribeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(SubscribeRequest& a, SubscribeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscribeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubscribeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubscribeRequest& from) {
    SubscribeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscribeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.chat.v1.SubscribeRequest";
  }
  protected:
  explicit SubscribeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventTypesFieldNumber = 2,
    kConversationIdFieldNumber = 1,
  };
  // repeated .unhinged.chat.v1.UpdateType event_types = 2;
  int event_types_size() const;
  private:
  int _internal_event_types_size() const;
  public:
  void clear_event_types();
  private:
  ::unhinged::chat::v1::UpdateType _internal_event_types(int index) const;
  void _internal_add_event_types(::unhinged::chat::v1::UpdateType value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_event_types();
  public:
  ::unhinged::chat::v1::UpdateType event_types(int index) const;
  void set_event_types(int index, ::unhinged::chat::v1::UpdateType value);
  void add_event_types(::unhinged::chat::v1::UpdateType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& event_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_event_types();

  // string conversation_id = 1;
  void clear_conversation_id();
  const std::string& conversation_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_conversation_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_conversation_id();
  PROTOBUF_NODISCARD std::string* release_conversation_id();
  void set_allocated_conversation_id(std::string* conversation_id);
  private:
  const std::string& _internal_conversation_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_conversation_id(const std::string& value);
  std::string* _internal_mutable_conversation_id();
  public:

  // @@protoc_insertion_point(class_scope:unhinged.chat.v1.SubscribeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> event_types_;
    mutable std::atomic<int> _event_types_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr conversation_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_2eproto;
};
// -------------------------------------------------------------------

class GetMessagesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.chat.v1.GetMessagesRequest) */ {
 public:
  inline GetMessagesRequest() : GetMessagesRequest(nullptr) {}
  ~GetMessagesRequest() override;
  explicit PROTOBUF_CONSTEXPR GetMessagesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetMessagesRequest(const GetMessagesRequest& from);
  GetMessagesRequest(GetMessagesRequest&& from) noexcept
    : GetMessagesRequest() {
    *this = ::std::move(from);
  }

  inline GetMessagesRequest& operator=(const GetMessagesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetMessagesRequest& operator=(GetMessagesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetMessagesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetMessagesRequest* internal_default_instance() {
    return reinterpret_cast<const GetMessagesRequest*>(
               &_GetMessagesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(GetMessagesRequest& a, GetMessagesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetMessagesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetMessagesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetMessagesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetMessagesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetMessagesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetMessagesRequest& from) {
    GetMessagesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetMessagesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.chat.v1.GetMessagesRequest";
  }
  protected:
  explicit GetMessagesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFiltersFieldNumber = 4,
    kConversationIdFieldNumber = 1,
    kPaginationFieldNumber = 2,
    kRoleFilterFieldNumber = 3,
  };
  // repeated .unhinged.common.v1.Filter filters = 4;
  int filters_size() const;
  private:
  int _internal_filters_size() const;
  public:
  void clear_filters();
  ::unhinged::common::v1::Filter* mutable_filters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::common::v1::Filter >*
      mutable_filters();
  private:
  const ::unhinged::common::v1::Filter& _internal_filters(int index) const;
  ::unhinged::common::v1::Filter* _internal_add_filters();
  public:
  const ::unhinged::common::v1::Filter& filters(int index) const;
  ::unhinged::common::v1::Filter* add_filters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::common::v1::Filter >&
      filters() const;

  // string conversation_id = 1;
  void clear_conversation_id();
  const std::string& conversation_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_conversation_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_conversation_id();
  PROTOBUF_NODISCARD std::string* release_conversation_id();
  void set_allocated_conversation_id(std::string* conversation_id);
  private:
  const std::string& _internal_conversation_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_conversation_id(const std::string& value);
  std::string* _internal_mutable_conversation_id();
  public:

  // .unhinged.common.v1.PaginationRequest pagination = 2;
  bool has_pagination() const;
  private:
  bool _internal_has_pagination() const;
  public:
  void clear_pagination();
  const ::unhinged::common::v1::PaginationRequest& pagination() const;
  PROTOBUF_NODISCARD ::unhinged::common::v1::PaginationRequest* release_pagination();
  ::unhinged::common::v1::PaginationRequest* mutable_pagination();
  void set_allocated_pagination(::unhinged::common::v1::PaginationRequest* pagination);
  private:
  const ::unhinged::common::v1::PaginationRequest& _internal_pagination() const;
  ::unhinged::common::v1::PaginationRequest* _internal_mutable_pagination();
  public:
  void unsafe_arena_set_allocated_pagination(
      ::unhinged::common::v1::PaginationRequest* pagination);
  ::unhinged::common::v1::PaginationRequest* unsafe_arena_release_pagination();

  // .unhinged.chat.v1.MessageRole role_filter = 3;
  void clear_role_filter();
  ::unhinged::chat::v1::MessageRole role_filter() const;
  void set_role_filter(::unhinged::chat::v1::MessageRole value);
  private:
  ::unhinged::chat::v1::MessageRole _internal_role_filter() const;
  void _internal_set_role_filter(::unhinged::chat::v1::MessageRole value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.chat.v1.GetMessagesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::common::v1::Filter > filters_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr conversation_id_;
    ::unhinged::common::v1::PaginationRequest* pagination_;
    int role_filter_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_2eproto;
};
// -------------------------------------------------------------------

class GetMessagesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.chat.v1.GetMessagesResponse) */ {
 public:
  inline GetMessagesResponse() : GetMessagesResponse(nullptr) {}
  ~GetMessagesResponse() override;
  explicit PROTOBUF_CONSTEXPR GetMessagesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetMessagesResponse(const GetMessagesResponse& from);
  GetMessagesResponse(GetMessagesResponse&& from) noexcept
    : GetMessagesResponse() {
    *this = ::std::move(from);
  }

  inline GetMessagesResponse& operator=(const GetMessagesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetMessagesResponse& operator=(GetMessagesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetMessagesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetMessagesResponse* internal_default_instance() {
    return reinterpret_cast<const GetMessagesResponse*>(
               &_GetMessagesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(GetMessagesResponse& a, GetMessagesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetMessagesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetMessagesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetMessagesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetMessagesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetMessagesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetMessagesResponse& from) {
    GetMessagesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetMessagesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.chat.v1.GetMessagesResponse";
  }
  protected:
  explicit GetMessagesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessagesFieldNumber = 2,
    kResponseFieldNumber = 1,
    kPaginationFieldNumber = 3,
  };
  // repeated .unhinged.chat.v1.ChatMessage messages = 2;
  int messages_size() const;
  private:
  int _internal_messages_size() const;
  public:
  void clear_messages();
  ::unhinged::chat::v1::ChatMessage* mutable_messages(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::chat::v1::ChatMessage >*
      mutable_messages();
  private:
  const ::unhinged::chat::v1::ChatMessage& _internal_messages(int index) const;
  ::unhinged::chat::v1::ChatMessage* _internal_add_messages();
  public:
  const ::unhinged::chat::v1::ChatMessage& messages(int index) const;
  ::unhinged::chat::v1::ChatMessage* add_messages();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::chat::v1::ChatMessage >&
      messages() const;

  // .unhinged.common.v1.StandardResponse response = 1;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::unhinged::common::v1::StandardResponse& response() const;
  PROTOBUF_NODISCARD ::unhinged::common::v1::StandardResponse* release_response();
  ::unhinged::common::v1::StandardResponse* mutable_response();
  void set_allocated_response(::unhinged::common::v1::StandardResponse* response);
  private:
  const ::unhinged::common::v1::StandardResponse& _internal_response() const;
  ::unhinged::common::v1::StandardResponse* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::unhinged::common::v1::StandardResponse* response);
  ::unhinged::common::v1::StandardResponse* unsafe_arena_release_response();

  // .unhinged.common.v1.PaginationResponse pagination = 3;
  bool has_pagination() const;
  private:
  bool _internal_has_pagination() const;
  public:
  void clear_pagination();
  const ::unhinged::common::v1::PaginationResponse& pagination() const;
  PROTOBUF_NODISCARD ::unhinged::common::v1::PaginationResponse* release_pagination();
  ::unhinged::common::v1::PaginationResponse* mutable_pagination();
  void set_allocated_pagination(::unhinged::common::v1::PaginationResponse* pagination);
  private:
  const ::unhinged::common::v1::PaginationResponse& _internal_pagination() const;
  ::unhinged::common::v1::PaginationResponse* _internal_mutable_pagination();
  public:
  void unsafe_arena_set_allocated_pagination(
      ::unhinged::common::v1::PaginationResponse* pagination);
  ::unhinged::common::v1::PaginationResponse* unsafe_arena_release_pagination();

  // @@protoc_insertion_point(class_scope:unhinged.chat.v1.GetMessagesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::chat::v1::ChatMessage > messages_;
    ::unhinged::common::v1::StandardResponse* response_;
    ::unhinged::common::v1::PaginationResponse* pagination_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_2eproto;
};
// -------------------------------------------------------------------

class UpdateConversationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.chat.v1.UpdateConversationRequest) */ {
 public:
  inline UpdateConversationRequest() : UpdateConversationRequest(nullptr) {}
  ~UpdateConversationRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateConversationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateConversationRequest(const UpdateConversationRequest& from);
  UpdateConversationRequest(UpdateConversationRequest&& from) noexcept
    : UpdateConversationRequest() {
    *this = ::std::move(from);
  }

  inline UpdateConversationRequest& operator=(const UpdateConversationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateConversationRequest& operator=(UpdateConversationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateConversationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateConversationRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateConversationRequest*>(
               &_UpdateConversationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(UpdateConversationRequest& a, UpdateConversationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateConversationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateConversationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateConversationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateConversationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateConversationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateConversationRequest& from) {
    UpdateConversationRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateConversationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.chat.v1.UpdateConversationRequest";
  }
  protected:
  explicit UpdateConversationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConversationIdFieldNumber = 1,
    kTitleFieldNumber = 2,
    kDescriptionFieldNumber = 3,
    kSettingsFieldNumber = 4,
  };
  // string conversation_id = 1;
  void clear_conversation_id();
  const std::string& conversation_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_conversation_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_conversation_id();
  PROTOBUF_NODISCARD std::string* release_conversation_id();
  void set_allocated_conversation_id(std::string* conversation_id);
  private:
  const std::string& _internal_conversation_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_conversation_id(const std::string& value);
  std::string* _internal_mutable_conversation_id();
  public:

  // string title = 2;
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // string description = 3;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // .unhinged.chat.v1.ConversationSettings settings = 4;
  bool has_settings() const;
  private:
  bool _internal_has_settings() const;
  public:
  void clear_settings();
  const ::unhinged::chat::v1::ConversationSettings& settings() const;
  PROTOBUF_NODISCARD ::unhinged::chat::v1::ConversationSettings* release_settings();
  ::unhinged::chat::v1::ConversationSettings* mutable_settings();
  void set_allocated_settings(::unhinged::chat::v1::ConversationSettings* settings);
  private:
  const ::unhinged::chat::v1::ConversationSettings& _internal_settings() const;
  ::unhinged::chat::v1::ConversationSettings* _internal_mutable_settings();
  public:
  void unsafe_arena_set_allocated_settings(
      ::unhinged::chat::v1::ConversationSettings* settings);
  ::unhinged::chat::v1::ConversationSettings* unsafe_arena_release_settings();

  // @@protoc_insertion_point(class_scope:unhinged.chat.v1.UpdateConversationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr conversation_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::unhinged::chat::v1::ConversationSettings* settings_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_2eproto;
};
// -------------------------------------------------------------------

class UpdateConversationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.chat.v1.UpdateConversationResponse) */ {
 public:
  inline UpdateConversationResponse() : UpdateConversationResponse(nullptr) {}
  ~UpdateConversationResponse() override;
  explicit PROTOBUF_CONSTEXPR UpdateConversationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateConversationResponse(const UpdateConversationResponse& from);
  UpdateConversationResponse(UpdateConversationResponse&& from) noexcept
    : UpdateConversationResponse() {
    *this = ::std::move(from);
  }

  inline UpdateConversationResponse& operator=(const UpdateConversationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateConversationResponse& operator=(UpdateConversationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateConversationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateConversationResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateConversationResponse*>(
               &_UpdateConversationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(UpdateConversationResponse& a, UpdateConversationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateConversationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateConversationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateConversationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateConversationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateConversationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateConversationResponse& from) {
    UpdateConversationResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateConversationResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.chat.v1.UpdateConversationResponse";
  }
  protected:
  explicit UpdateConversationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 1,
    kConversationFieldNumber = 2,
  };
  // .unhinged.common.v1.StandardResponse response = 1;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::unhinged::common::v1::StandardResponse& response() const;
  PROTOBUF_NODISCARD ::unhinged::common::v1::StandardResponse* release_response();
  ::unhinged::common::v1::StandardResponse* mutable_response();
  void set_allocated_response(::unhinged::common::v1::StandardResponse* response);
  private:
  const ::unhinged::common::v1::StandardResponse& _internal_response() const;
  ::unhinged::common::v1::StandardResponse* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::unhinged::common::v1::StandardResponse* response);
  ::unhinged::common::v1::StandardResponse* unsafe_arena_release_response();

  // .unhinged.chat.v1.Conversation conversation = 2;
  bool has_conversation() const;
  private:
  bool _internal_has_conversation() const;
  public:
  void clear_conversation();
  const ::unhinged::chat::v1::Conversation& conversation() const;
  PROTOBUF_NODISCARD ::unhinged::chat::v1::Conversation* release_conversation();
  ::unhinged::chat::v1::Conversation* mutable_conversation();
  void set_allocated_conversation(::unhinged::chat::v1::Conversation* conversation);
  private:
  const ::unhinged::chat::v1::Conversation& _internal_conversation() const;
  ::unhinged::chat::v1::Conversation* _internal_mutable_conversation();
  public:
  void unsafe_arena_set_allocated_conversation(
      ::unhinged::chat::v1::Conversation* conversation);
  ::unhinged::chat::v1::Conversation* unsafe_arena_release_conversation();

  // @@protoc_insertion_point(class_scope:unhinged.chat.v1.UpdateConversationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::unhinged::common::v1::StandardResponse* response_;
    ::unhinged::chat::v1::Conversation* conversation_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_2eproto;
};
// -------------------------------------------------------------------

class UpdateMessageRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.chat.v1.UpdateMessageRequest) */ {
 public:
  inline UpdateMessageRequest() : UpdateMessageRequest(nullptr) {}
  ~UpdateMessageRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateMessageRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateMessageRequest(const UpdateMessageRequest& from);
  UpdateMessageRequest(UpdateMessageRequest&& from) noexcept
    : UpdateMessageRequest() {
    *this = ::std::move(from);
  }

  inline UpdateMessageRequest& operator=(const UpdateMessageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateMessageRequest& operator=(UpdateMessageRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateMessageRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateMessageRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateMessageRequest*>(
               &_UpdateMessageRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(UpdateMessageRequest& a, UpdateMessageRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateMessageRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateMessageRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateMessageRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateMessageRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateMessageRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateMessageRequest& from) {
    UpdateMessageRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateMessageRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.chat.v1.UpdateMessageRequest";
  }
  protected:
  explicit UpdateMessageRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageIdFieldNumber = 1,
    kContentFieldNumber = 2,
  };
  // string message_id = 1;
  void clear_message_id();
  const std::string& message_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message_id();
  PROTOBUF_NODISCARD std::string* release_message_id();
  void set_allocated_message_id(std::string* message_id);
  private:
  const std::string& _internal_message_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message_id(const std::string& value);
  std::string* _internal_mutable_message_id();
  public:

  // string content = 2;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // @@protoc_insertion_point(class_scope:unhinged.chat.v1.UpdateMessageRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_2eproto;
};
// -------------------------------------------------------------------

class UpdateMessageResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.chat.v1.UpdateMessageResponse) */ {
 public:
  inline UpdateMessageResponse() : UpdateMessageResponse(nullptr) {}
  ~UpdateMessageResponse() override;
  explicit PROTOBUF_CONSTEXPR UpdateMessageResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateMessageResponse(const UpdateMessageResponse& from);
  UpdateMessageResponse(UpdateMessageResponse&& from) noexcept
    : UpdateMessageResponse() {
    *this = ::std::move(from);
  }

  inline UpdateMessageResponse& operator=(const UpdateMessageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateMessageResponse& operator=(UpdateMessageResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateMessageResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateMessageResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateMessageResponse*>(
               &_UpdateMessageResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(UpdateMessageResponse& a, UpdateMessageResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateMessageResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateMessageResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateMessageResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateMessageResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateMessageResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateMessageResponse& from) {
    UpdateMessageResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateMessageResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.chat.v1.UpdateMessageResponse";
  }
  protected:
  explicit UpdateMessageResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 1,
    kMessageFieldNumber = 2,
  };
  // .unhinged.common.v1.StandardResponse response = 1;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::unhinged::common::v1::StandardResponse& response() const;
  PROTOBUF_NODISCARD ::unhinged::common::v1::StandardResponse* release_response();
  ::unhinged::common::v1::StandardResponse* mutable_response();
  void set_allocated_response(::unhinged::common::v1::StandardResponse* response);
  private:
  const ::unhinged::common::v1::StandardResponse& _internal_response() const;
  ::unhinged::common::v1::StandardResponse* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::unhinged::common::v1::StandardResponse* response);
  ::unhinged::common::v1::StandardResponse* unsafe_arena_release_response();

  // .unhinged.chat.v1.ChatMessage message = 2;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const ::unhinged::chat::v1::ChatMessage& message() const;
  PROTOBUF_NODISCARD ::unhinged::chat::v1::ChatMessage* release_message();
  ::unhinged::chat::v1::ChatMessage* mutable_message();
  void set_allocated_message(::unhinged::chat::v1::ChatMessage* message);
  private:
  const ::unhinged::chat::v1::ChatMessage& _internal_message() const;
  ::unhinged::chat::v1::ChatMessage* _internal_mutable_message();
  public:
  void unsafe_arena_set_allocated_message(
      ::unhinged::chat::v1::ChatMessage* message);
  ::unhinged::chat::v1::ChatMessage* unsafe_arena_release_message();

  // @@protoc_insertion_point(class_scope:unhinged.chat.v1.UpdateMessageResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::unhinged::common::v1::StandardResponse* response_;
    ::unhinged::chat::v1::ChatMessage* message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_2eproto;
};
// -------------------------------------------------------------------

class DeleteConversationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.chat.v1.DeleteConversationRequest) */ {
 public:
  inline DeleteConversationRequest() : DeleteConversationRequest(nullptr) {}
  ~DeleteConversationRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteConversationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteConversationRequest(const DeleteConversationRequest& from);
  DeleteConversationRequest(DeleteConversationRequest&& from) noexcept
    : DeleteConversationRequest() {
    *this = ::std::move(from);
  }

  inline DeleteConversationRequest& operator=(const DeleteConversationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteConversationRequest& operator=(DeleteConversationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteConversationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteConversationRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteConversationRequest*>(
               &_DeleteConversationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(DeleteConversationRequest& a, DeleteConversationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteConversationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteConversationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteConversationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteConversationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteConversationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteConversationRequest& from) {
    DeleteConversationRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteConversationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.chat.v1.DeleteConversationRequest";
  }
  protected:
  explicit DeleteConversationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConversationIdFieldNumber = 1,
    kHardDeleteFieldNumber = 2,
  };
  // string conversation_id = 1;
  void clear_conversation_id();
  const std::string& conversation_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_conversation_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_conversation_id();
  PROTOBUF_NODISCARD std::string* release_conversation_id();
  void set_allocated_conversation_id(std::string* conversation_id);
  private:
  const std::string& _internal_conversation_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_conversation_id(const std::string& value);
  std::string* _internal_mutable_conversation_id();
  public:

  // bool hard_delete = 2;
  void clear_hard_delete();
  bool hard_delete() const;
  void set_hard_delete(bool value);
  private:
  bool _internal_hard_delete() const;
  void _internal_set_hard_delete(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.chat.v1.DeleteConversationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr conversation_id_;
    bool hard_delete_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_2eproto;
};
// -------------------------------------------------------------------

class DeleteConversationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.chat.v1.DeleteConversationResponse) */ {
 public:
  inline DeleteConversationResponse() : DeleteConversationResponse(nullptr) {}
  ~DeleteConversationResponse() override;
  explicit PROTOBUF_CONSTEXPR DeleteConversationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteConversationResponse(const DeleteConversationResponse& from);
  DeleteConversationResponse(DeleteConversationResponse&& from) noexcept
    : DeleteConversationResponse() {
    *this = ::std::move(from);
  }

  inline DeleteConversationResponse& operator=(const DeleteConversationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteConversationResponse& operator=(DeleteConversationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteConversationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteConversationResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteConversationResponse*>(
               &_DeleteConversationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(DeleteConversationResponse& a, DeleteConversationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteConversationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteConversationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteConversationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteConversationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteConversationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteConversationResponse& from) {
    DeleteConversationResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteConversationResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.chat.v1.DeleteConversationResponse";
  }
  protected:
  explicit DeleteConversationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 1,
  };
  // .unhinged.common.v1.StandardResponse response = 1;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::unhinged::common::v1::StandardResponse& response() const;
  PROTOBUF_NODISCARD ::unhinged::common::v1::StandardResponse* release_response();
  ::unhinged::common::v1::StandardResponse* mutable_response();
  void set_allocated_response(::unhinged::common::v1::StandardResponse* response);
  private:
  const ::unhinged::common::v1::StandardResponse& _internal_response() const;
  ::unhinged::common::v1::StandardResponse* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::unhinged::common::v1::StandardResponse* response);
  ::unhinged::common::v1::StandardResponse* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:unhinged.chat.v1.DeleteConversationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::unhinged::common::v1::StandardResponse* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_2eproto;
};
// -------------------------------------------------------------------

class DeleteMessageRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.chat.v1.DeleteMessageRequest) */ {
 public:
  inline DeleteMessageRequest() : DeleteMessageRequest(nullptr) {}
  ~DeleteMessageRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteMessageRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteMessageRequest(const DeleteMessageRequest& from);
  DeleteMessageRequest(DeleteMessageRequest&& from) noexcept
    : DeleteMessageRequest() {
    *this = ::std::move(from);
  }

  inline DeleteMessageRequest& operator=(const DeleteMessageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteMessageRequest& operator=(DeleteMessageRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteMessageRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteMessageRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteMessageRequest*>(
               &_DeleteMessageRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(DeleteMessageRequest& a, DeleteMessageRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteMessageRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteMessageRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteMessageRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteMessageRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteMessageRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteMessageRequest& from) {
    DeleteMessageRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteMessageRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.chat.v1.DeleteMessageRequest";
  }
  protected:
  explicit DeleteMessageRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageIdFieldNumber = 1,
    kHardDeleteFieldNumber = 2,
  };
  // string message_id = 1;
  void clear_message_id();
  const std::string& message_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message_id();
  PROTOBUF_NODISCARD std::string* release_message_id();
  void set_allocated_message_id(std::string* message_id);
  private:
  const std::string& _internal_message_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message_id(const std::string& value);
  std::string* _internal_mutable_message_id();
  public:

  // bool hard_delete = 2;
  void clear_hard_delete();
  bool hard_delete() const;
  void set_hard_delete(bool value);
  private:
  bool _internal_hard_delete() const;
  void _internal_set_hard_delete(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.chat.v1.DeleteMessageRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_id_;
    bool hard_delete_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_2eproto;
};
// -------------------------------------------------------------------

class DeleteMessageResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.chat.v1.DeleteMessageResponse) */ {
 public:
  inline DeleteMessageResponse() : DeleteMessageResponse(nullptr) {}
  ~DeleteMessageResponse() override;
  explicit PROTOBUF_CONSTEXPR DeleteMessageResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteMessageResponse(const DeleteMessageResponse& from);
  DeleteMessageResponse(DeleteMessageResponse&& from) noexcept
    : DeleteMessageResponse() {
    *this = ::std::move(from);
  }

  inline DeleteMessageResponse& operator=(const DeleteMessageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteMessageResponse& operator=(DeleteMessageResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteMessageResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteMessageResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteMessageResponse*>(
               &_DeleteMessageResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(DeleteMessageResponse& a, DeleteMessageResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteMessageResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteMessageResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteMessageResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteMessageResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteMessageResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteMessageResponse& from) {
    DeleteMessageResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteMessageResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.chat.v1.DeleteMessageResponse";
  }
  protected:
  explicit DeleteMessageResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 1,
  };
  // .unhinged.common.v1.StandardResponse response = 1;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::unhinged::common::v1::StandardResponse& response() const;
  PROTOBUF_NODISCARD ::unhinged::common::v1::StandardResponse* release_response();
  ::unhinged::common::v1::StandardResponse* mutable_response();
  void set_allocated_response(::unhinged::common::v1::StandardResponse* response);
  private:
  const ::unhinged::common::v1::StandardResponse& _internal_response() const;
  ::unhinged::common::v1::StandardResponse* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::unhinged::common::v1::StandardResponse* response);
  ::unhinged::common::v1::StandardResponse* unsafe_arena_release_response();

  // @@protoc_insertion_point(class_scope:unhinged.chat.v1.DeleteMessageResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::unhinged::common::v1::StandardResponse* response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Conversation

// .unhinged.common.v1.ResourceMetadata metadata = 1;
inline bool Conversation::_internal_has_metadata() const {
  return this != internal_default_instance() && _impl_.metadata_ != nullptr;
}
inline bool Conversation::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::unhinged::common::v1::ResourceMetadata& Conversation::_internal_metadata() const {
  const ::unhinged::common::v1::ResourceMetadata* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::common::v1::ResourceMetadata&>(
      ::unhinged::common::v1::_ResourceMetadata_default_instance_);
}
inline const ::unhinged::common::v1::ResourceMetadata& Conversation::metadata() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.Conversation.metadata)
  return _internal_metadata();
}
inline void Conversation::unsafe_arena_set_allocated_metadata(
    ::unhinged::common::v1::ResourceMetadata* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.chat.v1.Conversation.metadata)
}
inline ::unhinged::common::v1::ResourceMetadata* Conversation::release_metadata() {
  
  ::unhinged::common::v1::ResourceMetadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::common::v1::ResourceMetadata* Conversation::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:unhinged.chat.v1.Conversation.metadata)
  
  ::unhinged::common::v1::ResourceMetadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::unhinged::common::v1::ResourceMetadata* Conversation::_internal_mutable_metadata() {
  
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::common::v1::ResourceMetadata>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::unhinged::common::v1::ResourceMetadata* Conversation::mutable_metadata() {
  ::unhinged::common::v1::ResourceMetadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.Conversation.metadata)
  return _msg;
}
inline void Conversation::set_allocated_metadata(::unhinged::common::v1::ResourceMetadata* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:unhinged.chat.v1.Conversation.metadata)
}

// string title = 2;
inline void Conversation::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& Conversation::title() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.Conversation.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Conversation::set_title(ArgT0&& arg0, ArgT... args) {
 
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.Conversation.title)
}
inline std::string* Conversation::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.Conversation.title)
  return _s;
}
inline const std::string& Conversation::_internal_title() const {
  return _impl_.title_.Get();
}
inline void Conversation::_internal_set_title(const std::string& value) {
  
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* Conversation::_internal_mutable_title() {
  
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* Conversation::release_title() {
  // @@protoc_insertion_point(field_release:unhinged.chat.v1.Conversation.title)
  return _impl_.title_.Release();
}
inline void Conversation::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.chat.v1.Conversation.title)
}

// string description = 3;
inline void Conversation::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Conversation::description() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.Conversation.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Conversation::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.Conversation.description)
}
inline std::string* Conversation::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.Conversation.description)
  return _s;
}
inline const std::string& Conversation::_internal_description() const {
  return _impl_.description_.Get();
}
inline void Conversation::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* Conversation::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* Conversation::release_description() {
  // @@protoc_insertion_point(field_release:unhinged.chat.v1.Conversation.description)
  return _impl_.description_.Release();
}
inline void Conversation::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.chat.v1.Conversation.description)
}

// .unhinged.chat.v1.ConversationSettings settings = 4;
inline bool Conversation::_internal_has_settings() const {
  return this != internal_default_instance() && _impl_.settings_ != nullptr;
}
inline bool Conversation::has_settings() const {
  return _internal_has_settings();
}
inline void Conversation::clear_settings() {
  if (GetArenaForAllocation() == nullptr && _impl_.settings_ != nullptr) {
    delete _impl_.settings_;
  }
  _impl_.settings_ = nullptr;
}
inline const ::unhinged::chat::v1::ConversationSettings& Conversation::_internal_settings() const {
  const ::unhinged::chat::v1::ConversationSettings* p = _impl_.settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::chat::v1::ConversationSettings&>(
      ::unhinged::chat::v1::_ConversationSettings_default_instance_);
}
inline const ::unhinged::chat::v1::ConversationSettings& Conversation::settings() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.Conversation.settings)
  return _internal_settings();
}
inline void Conversation::unsafe_arena_set_allocated_settings(
    ::unhinged::chat::v1::ConversationSettings* settings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.settings_);
  }
  _impl_.settings_ = settings;
  if (settings) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.chat.v1.Conversation.settings)
}
inline ::unhinged::chat::v1::ConversationSettings* Conversation::release_settings() {
  
  ::unhinged::chat::v1::ConversationSettings* temp = _impl_.settings_;
  _impl_.settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::chat::v1::ConversationSettings* Conversation::unsafe_arena_release_settings() {
  // @@protoc_insertion_point(field_release:unhinged.chat.v1.Conversation.settings)
  
  ::unhinged::chat::v1::ConversationSettings* temp = _impl_.settings_;
  _impl_.settings_ = nullptr;
  return temp;
}
inline ::unhinged::chat::v1::ConversationSettings* Conversation::_internal_mutable_settings() {
  
  if (_impl_.settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::chat::v1::ConversationSettings>(GetArenaForAllocation());
    _impl_.settings_ = p;
  }
  return _impl_.settings_;
}
inline ::unhinged::chat::v1::ConversationSettings* Conversation::mutable_settings() {
  ::unhinged::chat::v1::ConversationSettings* _msg = _internal_mutable_settings();
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.Conversation.settings)
  return _msg;
}
inline void Conversation::set_allocated_settings(::unhinged::chat::v1::ConversationSettings* settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.settings_;
  }
  if (settings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(settings);
    if (message_arena != submessage_arena) {
      settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, settings, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.settings_ = settings;
  // @@protoc_insertion_point(field_set_allocated:unhinged.chat.v1.Conversation.settings)
}

// int32 message_count = 5;
inline void Conversation::clear_message_count() {
  _impl_.message_count_ = 0;
}
inline int32_t Conversation::_internal_message_count() const {
  return _impl_.message_count_;
}
inline int32_t Conversation::message_count() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.Conversation.message_count)
  return _internal_message_count();
}
inline void Conversation::_internal_set_message_count(int32_t value) {
  
  _impl_.message_count_ = value;
}
inline void Conversation::set_message_count(int32_t value) {
  _internal_set_message_count(value);
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.Conversation.message_count)
}

// .unhinged.chat.v1.ConversationStatus status = 6;
inline void Conversation::clear_status() {
  _impl_.status_ = 0;
}
inline ::unhinged::chat::v1::ConversationStatus Conversation::_internal_status() const {
  return static_cast< ::unhinged::chat::v1::ConversationStatus >(_impl_.status_);
}
inline ::unhinged::chat::v1::ConversationStatus Conversation::status() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.Conversation.status)
  return _internal_status();
}
inline void Conversation::_internal_set_status(::unhinged::chat::v1::ConversationStatus value) {
  
  _impl_.status_ = value;
}
inline void Conversation::set_status(::unhinged::chat::v1::ConversationStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.Conversation.status)
}

// repeated string participant_ids = 7;
inline int Conversation::_internal_participant_ids_size() const {
  return _impl_.participant_ids_.size();
}
inline int Conversation::participant_ids_size() const {
  return _internal_participant_ids_size();
}
inline void Conversation::clear_participant_ids() {
  _impl_.participant_ids_.Clear();
}
inline std::string* Conversation::add_participant_ids() {
  std::string* _s = _internal_add_participant_ids();
  // @@protoc_insertion_point(field_add_mutable:unhinged.chat.v1.Conversation.participant_ids)
  return _s;
}
inline const std::string& Conversation::_internal_participant_ids(int index) const {
  return _impl_.participant_ids_.Get(index);
}
inline const std::string& Conversation::participant_ids(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.Conversation.participant_ids)
  return _internal_participant_ids(index);
}
inline std::string* Conversation::mutable_participant_ids(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.Conversation.participant_ids)
  return _impl_.participant_ids_.Mutable(index);
}
inline void Conversation::set_participant_ids(int index, const std::string& value) {
  _impl_.participant_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.Conversation.participant_ids)
}
inline void Conversation::set_participant_ids(int index, std::string&& value) {
  _impl_.participant_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.Conversation.participant_ids)
}
inline void Conversation::set_participant_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.participant_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.chat.v1.Conversation.participant_ids)
}
inline void Conversation::set_participant_ids(int index, const char* value, size_t size) {
  _impl_.participant_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.chat.v1.Conversation.participant_ids)
}
inline std::string* Conversation::_internal_add_participant_ids() {
  return _impl_.participant_ids_.Add();
}
inline void Conversation::add_participant_ids(const std::string& value) {
  _impl_.participant_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.chat.v1.Conversation.participant_ids)
}
inline void Conversation::add_participant_ids(std::string&& value) {
  _impl_.participant_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.chat.v1.Conversation.participant_ids)
}
inline void Conversation::add_participant_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.participant_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.chat.v1.Conversation.participant_ids)
}
inline void Conversation::add_participant_ids(const char* value, size_t size) {
  _impl_.participant_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.chat.v1.Conversation.participant_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Conversation::participant_ids() const {
  // @@protoc_insertion_point(field_list:unhinged.chat.v1.Conversation.participant_ids)
  return _impl_.participant_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Conversation::mutable_participant_ids() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.chat.v1.Conversation.participant_ids)
  return &_impl_.participant_ids_;
}

// -------------------------------------------------------------------

// ConversationSettings

// string model = 1;
inline void ConversationSettings::clear_model() {
  _impl_.model_.ClearToEmpty();
}
inline const std::string& ConversationSettings::model() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.ConversationSettings.model)
  return _internal_model();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConversationSettings::set_model(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.ConversationSettings.model)
}
inline std::string* ConversationSettings::mutable_model() {
  std::string* _s = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.ConversationSettings.model)
  return _s;
}
inline const std::string& ConversationSettings::_internal_model() const {
  return _impl_.model_.Get();
}
inline void ConversationSettings::_internal_set_model(const std::string& value) {
  
  _impl_.model_.Set(value, GetArenaForAllocation());
}
inline std::string* ConversationSettings::_internal_mutable_model() {
  
  return _impl_.model_.Mutable(GetArenaForAllocation());
}
inline std::string* ConversationSettings::release_model() {
  // @@protoc_insertion_point(field_release:unhinged.chat.v1.ConversationSettings.model)
  return _impl_.model_.Release();
}
inline void ConversationSettings::set_allocated_model(std::string* model) {
  if (model != nullptr) {
    
  } else {
    
  }
  _impl_.model_.SetAllocated(model, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_.IsDefault()) {
    _impl_.model_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.chat.v1.ConversationSettings.model)
}

// float temperature = 2;
inline void ConversationSettings::clear_temperature() {
  _impl_.temperature_ = 0;
}
inline float ConversationSettings::_internal_temperature() const {
  return _impl_.temperature_;
}
inline float ConversationSettings::temperature() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.ConversationSettings.temperature)
  return _internal_temperature();
}
inline void ConversationSettings::_internal_set_temperature(float value) {
  
  _impl_.temperature_ = value;
}
inline void ConversationSettings::set_temperature(float value) {
  _internal_set_temperature(value);
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.ConversationSettings.temperature)
}

// int32 max_tokens = 3;
inline void ConversationSettings::clear_max_tokens() {
  _impl_.max_tokens_ = 0;
}
inline int32_t ConversationSettings::_internal_max_tokens() const {
  return _impl_.max_tokens_;
}
inline int32_t ConversationSettings::max_tokens() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.ConversationSettings.max_tokens)
  return _internal_max_tokens();
}
inline void ConversationSettings::_internal_set_max_tokens(int32_t value) {
  
  _impl_.max_tokens_ = value;
}
inline void ConversationSettings::set_max_tokens(int32_t value) {
  _internal_set_max_tokens(value);
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.ConversationSettings.max_tokens)
}

// repeated string stop_sequences = 4;
inline int ConversationSettings::_internal_stop_sequences_size() const {
  return _impl_.stop_sequences_.size();
}
inline int ConversationSettings::stop_sequences_size() const {
  return _internal_stop_sequences_size();
}
inline void ConversationSettings::clear_stop_sequences() {
  _impl_.stop_sequences_.Clear();
}
inline std::string* ConversationSettings::add_stop_sequences() {
  std::string* _s = _internal_add_stop_sequences();
  // @@protoc_insertion_point(field_add_mutable:unhinged.chat.v1.ConversationSettings.stop_sequences)
  return _s;
}
inline const std::string& ConversationSettings::_internal_stop_sequences(int index) const {
  return _impl_.stop_sequences_.Get(index);
}
inline const std::string& ConversationSettings::stop_sequences(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.ConversationSettings.stop_sequences)
  return _internal_stop_sequences(index);
}
inline std::string* ConversationSettings::mutable_stop_sequences(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.ConversationSettings.stop_sequences)
  return _impl_.stop_sequences_.Mutable(index);
}
inline void ConversationSettings::set_stop_sequences(int index, const std::string& value) {
  _impl_.stop_sequences_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.ConversationSettings.stop_sequences)
}
inline void ConversationSettings::set_stop_sequences(int index, std::string&& value) {
  _impl_.stop_sequences_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.ConversationSettings.stop_sequences)
}
inline void ConversationSettings::set_stop_sequences(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.stop_sequences_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.chat.v1.ConversationSettings.stop_sequences)
}
inline void ConversationSettings::set_stop_sequences(int index, const char* value, size_t size) {
  _impl_.stop_sequences_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.chat.v1.ConversationSettings.stop_sequences)
}
inline std::string* ConversationSettings::_internal_add_stop_sequences() {
  return _impl_.stop_sequences_.Add();
}
inline void ConversationSettings::add_stop_sequences(const std::string& value) {
  _impl_.stop_sequences_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.chat.v1.ConversationSettings.stop_sequences)
}
inline void ConversationSettings::add_stop_sequences(std::string&& value) {
  _impl_.stop_sequences_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.chat.v1.ConversationSettings.stop_sequences)
}
inline void ConversationSettings::add_stop_sequences(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.stop_sequences_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.chat.v1.ConversationSettings.stop_sequences)
}
inline void ConversationSettings::add_stop_sequences(const char* value, size_t size) {
  _impl_.stop_sequences_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.chat.v1.ConversationSettings.stop_sequences)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ConversationSettings::stop_sequences() const {
  // @@protoc_insertion_point(field_list:unhinged.chat.v1.ConversationSettings.stop_sequences)
  return _impl_.stop_sequences_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ConversationSettings::mutable_stop_sequences() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.chat.v1.ConversationSettings.stop_sequences)
  return &_impl_.stop_sequences_;
}

// bool include_context = 5;
inline void ConversationSettings::clear_include_context() {
  _impl_.include_context_ = false;
}
inline bool ConversationSettings::_internal_include_context() const {
  return _impl_.include_context_;
}
inline bool ConversationSettings::include_context() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.ConversationSettings.include_context)
  return _internal_include_context();
}
inline void ConversationSettings::_internal_set_include_context(bool value) {
  
  _impl_.include_context_ = value;
}
inline void ConversationSettings::set_include_context(bool value) {
  _internal_set_include_context(value);
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.ConversationSettings.include_context)
}

// int32 context_window_size = 6;
inline void ConversationSettings::clear_context_window_size() {
  _impl_.context_window_size_ = 0;
}
inline int32_t ConversationSettings::_internal_context_window_size() const {
  return _impl_.context_window_size_;
}
inline int32_t ConversationSettings::context_window_size() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.ConversationSettings.context_window_size)
  return _internal_context_window_size();
}
inline void ConversationSettings::_internal_set_context_window_size(int32_t value) {
  
  _impl_.context_window_size_ = value;
}
inline void ConversationSettings::set_context_window_size(int32_t value) {
  _internal_set_context_window_size(value);
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.ConversationSettings.context_window_size)
}

// bool enable_tools = 7;
inline void ConversationSettings::clear_enable_tools() {
  _impl_.enable_tools_ = false;
}
inline bool ConversationSettings::_internal_enable_tools() const {
  return _impl_.enable_tools_;
}
inline bool ConversationSettings::enable_tools() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.ConversationSettings.enable_tools)
  return _internal_enable_tools();
}
inline void ConversationSettings::_internal_set_enable_tools(bool value) {
  
  _impl_.enable_tools_ = value;
}
inline void ConversationSettings::set_enable_tools(bool value) {
  _internal_set_enable_tools(value);
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.ConversationSettings.enable_tools)
}

// repeated string available_tools = 8;
inline int ConversationSettings::_internal_available_tools_size() const {
  return _impl_.available_tools_.size();
}
inline int ConversationSettings::available_tools_size() const {
  return _internal_available_tools_size();
}
inline void ConversationSettings::clear_available_tools() {
  _impl_.available_tools_.Clear();
}
inline std::string* ConversationSettings::add_available_tools() {
  std::string* _s = _internal_add_available_tools();
  // @@protoc_insertion_point(field_add_mutable:unhinged.chat.v1.ConversationSettings.available_tools)
  return _s;
}
inline const std::string& ConversationSettings::_internal_available_tools(int index) const {
  return _impl_.available_tools_.Get(index);
}
inline const std::string& ConversationSettings::available_tools(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.ConversationSettings.available_tools)
  return _internal_available_tools(index);
}
inline std::string* ConversationSettings::mutable_available_tools(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.ConversationSettings.available_tools)
  return _impl_.available_tools_.Mutable(index);
}
inline void ConversationSettings::set_available_tools(int index, const std::string& value) {
  _impl_.available_tools_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.ConversationSettings.available_tools)
}
inline void ConversationSettings::set_available_tools(int index, std::string&& value) {
  _impl_.available_tools_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.ConversationSettings.available_tools)
}
inline void ConversationSettings::set_available_tools(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.available_tools_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.chat.v1.ConversationSettings.available_tools)
}
inline void ConversationSettings::set_available_tools(int index, const char* value, size_t size) {
  _impl_.available_tools_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.chat.v1.ConversationSettings.available_tools)
}
inline std::string* ConversationSettings::_internal_add_available_tools() {
  return _impl_.available_tools_.Add();
}
inline void ConversationSettings::add_available_tools(const std::string& value) {
  _impl_.available_tools_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.chat.v1.ConversationSettings.available_tools)
}
inline void ConversationSettings::add_available_tools(std::string&& value) {
  _impl_.available_tools_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.chat.v1.ConversationSettings.available_tools)
}
inline void ConversationSettings::add_available_tools(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.available_tools_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.chat.v1.ConversationSettings.available_tools)
}
inline void ConversationSettings::add_available_tools(const char* value, size_t size) {
  _impl_.available_tools_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.chat.v1.ConversationSettings.available_tools)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ConversationSettings::available_tools() const {
  // @@protoc_insertion_point(field_list:unhinged.chat.v1.ConversationSettings.available_tools)
  return _impl_.available_tools_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ConversationSettings::mutable_available_tools() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.chat.v1.ConversationSettings.available_tools)
  return &_impl_.available_tools_;
}

// -------------------------------------------------------------------

// ChatMessage

// .unhinged.common.v1.ResourceMetadata metadata = 1;
inline bool ChatMessage::_internal_has_metadata() const {
  return this != internal_default_instance() && _impl_.metadata_ != nullptr;
}
inline bool ChatMessage::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::unhinged::common::v1::ResourceMetadata& ChatMessage::_internal_metadata() const {
  const ::unhinged::common::v1::ResourceMetadata* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::common::v1::ResourceMetadata&>(
      ::unhinged::common::v1::_ResourceMetadata_default_instance_);
}
inline const ::unhinged::common::v1::ResourceMetadata& ChatMessage::metadata() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.ChatMessage.metadata)
  return _internal_metadata();
}
inline void ChatMessage::unsafe_arena_set_allocated_metadata(
    ::unhinged::common::v1::ResourceMetadata* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.chat.v1.ChatMessage.metadata)
}
inline ::unhinged::common::v1::ResourceMetadata* ChatMessage::release_metadata() {
  
  ::unhinged::common::v1::ResourceMetadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::common::v1::ResourceMetadata* ChatMessage::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:unhinged.chat.v1.ChatMessage.metadata)
  
  ::unhinged::common::v1::ResourceMetadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::unhinged::common::v1::ResourceMetadata* ChatMessage::_internal_mutable_metadata() {
  
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::common::v1::ResourceMetadata>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::unhinged::common::v1::ResourceMetadata* ChatMessage::mutable_metadata() {
  ::unhinged::common::v1::ResourceMetadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.ChatMessage.metadata)
  return _msg;
}
inline void ChatMessage::set_allocated_metadata(::unhinged::common::v1::ResourceMetadata* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:unhinged.chat.v1.ChatMessage.metadata)
}

// string conversation_id = 2;
inline void ChatMessage::clear_conversation_id() {
  _impl_.conversation_id_.ClearToEmpty();
}
inline const std::string& ChatMessage::conversation_id() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.ChatMessage.conversation_id)
  return _internal_conversation_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatMessage::set_conversation_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.conversation_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.ChatMessage.conversation_id)
}
inline std::string* ChatMessage::mutable_conversation_id() {
  std::string* _s = _internal_mutable_conversation_id();
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.ChatMessage.conversation_id)
  return _s;
}
inline const std::string& ChatMessage::_internal_conversation_id() const {
  return _impl_.conversation_id_.Get();
}
inline void ChatMessage::_internal_set_conversation_id(const std::string& value) {
  
  _impl_.conversation_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatMessage::_internal_mutable_conversation_id() {
  
  return _impl_.conversation_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatMessage::release_conversation_id() {
  // @@protoc_insertion_point(field_release:unhinged.chat.v1.ChatMessage.conversation_id)
  return _impl_.conversation_id_.Release();
}
inline void ChatMessage::set_allocated_conversation_id(std::string* conversation_id) {
  if (conversation_id != nullptr) {
    
  } else {
    
  }
  _impl_.conversation_id_.SetAllocated(conversation_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.conversation_id_.IsDefault()) {
    _impl_.conversation_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.chat.v1.ChatMessage.conversation_id)
}

// .unhinged.chat.v1.MessageRole role = 3;
inline void ChatMessage::clear_role() {
  _impl_.role_ = 0;
}
inline ::unhinged::chat::v1::MessageRole ChatMessage::_internal_role() const {
  return static_cast< ::unhinged::chat::v1::MessageRole >(_impl_.role_);
}
inline ::unhinged::chat::v1::MessageRole ChatMessage::role() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.ChatMessage.role)
  return _internal_role();
}
inline void ChatMessage::_internal_set_role(::unhinged::chat::v1::MessageRole value) {
  
  _impl_.role_ = value;
}
inline void ChatMessage::set_role(::unhinged::chat::v1::MessageRole value) {
  _internal_set_role(value);
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.ChatMessage.role)
}

// string content = 4;
inline void ChatMessage::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& ChatMessage::content() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.ChatMessage.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatMessage::set_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.ChatMessage.content)
}
inline std::string* ChatMessage::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.ChatMessage.content)
  return _s;
}
inline const std::string& ChatMessage::_internal_content() const {
  return _impl_.content_.Get();
}
inline void ChatMessage::_internal_set_content(const std::string& value) {
  
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatMessage::_internal_mutable_content() {
  
  return _impl_.content_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatMessage::release_content() {
  // @@protoc_insertion_point(field_release:unhinged.chat.v1.ChatMessage.content)
  return _impl_.content_.Release();
}
inline void ChatMessage::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.chat.v1.ChatMessage.content)
}

// repeated .unhinged.common.v1.Attachment attachments = 5;
inline int ChatMessage::_internal_attachments_size() const {
  return _impl_.attachments_.size();
}
inline int ChatMessage::attachments_size() const {
  return _internal_attachments_size();
}
inline ::unhinged::common::v1::Attachment* ChatMessage::mutable_attachments(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.ChatMessage.attachments)
  return _impl_.attachments_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::common::v1::Attachment >*
ChatMessage::mutable_attachments() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.chat.v1.ChatMessage.attachments)
  return &_impl_.attachments_;
}
inline const ::unhinged::common::v1::Attachment& ChatMessage::_internal_attachments(int index) const {
  return _impl_.attachments_.Get(index);
}
inline const ::unhinged::common::v1::Attachment& ChatMessage::attachments(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.ChatMessage.attachments)
  return _internal_attachments(index);
}
inline ::unhinged::common::v1::Attachment* ChatMessage::_internal_add_attachments() {
  return _impl_.attachments_.Add();
}
inline ::unhinged::common::v1::Attachment* ChatMessage::add_attachments() {
  ::unhinged::common::v1::Attachment* _add = _internal_add_attachments();
  // @@protoc_insertion_point(field_add:unhinged.chat.v1.ChatMessage.attachments)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::common::v1::Attachment >&
ChatMessage::attachments() const {
  // @@protoc_insertion_point(field_list:unhinged.chat.v1.ChatMessage.attachments)
  return _impl_.attachments_;
}

// .unhinged.chat.v1.MessageStatus status = 6;
inline void ChatMessage::clear_status() {
  _impl_.status_ = 0;
}
inline ::unhinged::chat::v1::MessageStatus ChatMessage::_internal_status() const {
  return static_cast< ::unhinged::chat::v1::MessageStatus >(_impl_.status_);
}
inline ::unhinged::chat::v1::MessageStatus ChatMessage::status() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.ChatMessage.status)
  return _internal_status();
}
inline void ChatMessage::_internal_set_status(::unhinged::chat::v1::MessageStatus value) {
  
  _impl_.status_ = value;
}
inline void ChatMessage::set_status(::unhinged::chat::v1::MessageStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.ChatMessage.status)
}

// string parent_message_id = 7;
inline void ChatMessage::clear_parent_message_id() {
  _impl_.parent_message_id_.ClearToEmpty();
}
inline const std::string& ChatMessage::parent_message_id() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.ChatMessage.parent_message_id)
  return _internal_parent_message_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatMessage::set_parent_message_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.parent_message_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.ChatMessage.parent_message_id)
}
inline std::string* ChatMessage::mutable_parent_message_id() {
  std::string* _s = _internal_mutable_parent_message_id();
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.ChatMessage.parent_message_id)
  return _s;
}
inline const std::string& ChatMessage::_internal_parent_message_id() const {
  return _impl_.parent_message_id_.Get();
}
inline void ChatMessage::_internal_set_parent_message_id(const std::string& value) {
  
  _impl_.parent_message_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatMessage::_internal_mutable_parent_message_id() {
  
  return _impl_.parent_message_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatMessage::release_parent_message_id() {
  // @@protoc_insertion_point(field_release:unhinged.chat.v1.ChatMessage.parent_message_id)
  return _impl_.parent_message_id_.Release();
}
inline void ChatMessage::set_allocated_parent_message_id(std::string* parent_message_id) {
  if (parent_message_id != nullptr) {
    
  } else {
    
  }
  _impl_.parent_message_id_.SetAllocated(parent_message_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parent_message_id_.IsDefault()) {
    _impl_.parent_message_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.chat.v1.ChatMessage.parent_message_id)
}

// .unhinged.common.v1.UsageMetrics usage = 8;
inline bool ChatMessage::_internal_has_usage() const {
  return this != internal_default_instance() && _impl_.usage_ != nullptr;
}
inline bool ChatMessage::has_usage() const {
  return _internal_has_usage();
}
inline const ::unhinged::common::v1::UsageMetrics& ChatMessage::_internal_usage() const {
  const ::unhinged::common::v1::UsageMetrics* p = _impl_.usage_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::common::v1::UsageMetrics&>(
      ::unhinged::common::v1::_UsageMetrics_default_instance_);
}
inline const ::unhinged::common::v1::UsageMetrics& ChatMessage::usage() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.ChatMessage.usage)
  return _internal_usage();
}
inline void ChatMessage::unsafe_arena_set_allocated_usage(
    ::unhinged::common::v1::UsageMetrics* usage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.usage_);
  }
  _impl_.usage_ = usage;
  if (usage) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.chat.v1.ChatMessage.usage)
}
inline ::unhinged::common::v1::UsageMetrics* ChatMessage::release_usage() {
  
  ::unhinged::common::v1::UsageMetrics* temp = _impl_.usage_;
  _impl_.usage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::common::v1::UsageMetrics* ChatMessage::unsafe_arena_release_usage() {
  // @@protoc_insertion_point(field_release:unhinged.chat.v1.ChatMessage.usage)
  
  ::unhinged::common::v1::UsageMetrics* temp = _impl_.usage_;
  _impl_.usage_ = nullptr;
  return temp;
}
inline ::unhinged::common::v1::UsageMetrics* ChatMessage::_internal_mutable_usage() {
  
  if (_impl_.usage_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::common::v1::UsageMetrics>(GetArenaForAllocation());
    _impl_.usage_ = p;
  }
  return _impl_.usage_;
}
inline ::unhinged::common::v1::UsageMetrics* ChatMessage::mutable_usage() {
  ::unhinged::common::v1::UsageMetrics* _msg = _internal_mutable_usage();
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.ChatMessage.usage)
  return _msg;
}
inline void ChatMessage::set_allocated_usage(::unhinged::common::v1::UsageMetrics* usage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.usage_);
  }
  if (usage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(usage));
    if (message_arena != submessage_arena) {
      usage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, usage, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.usage_ = usage;
  // @@protoc_insertion_point(field_set_allocated:unhinged.chat.v1.ChatMessage.usage)
}

// repeated .unhinged.chat.v1.ToolCall tool_calls = 9;
inline int ChatMessage::_internal_tool_calls_size() const {
  return _impl_.tool_calls_.size();
}
inline int ChatMessage::tool_calls_size() const {
  return _internal_tool_calls_size();
}
inline void ChatMessage::clear_tool_calls() {
  _impl_.tool_calls_.Clear();
}
inline ::unhinged::chat::v1::ToolCall* ChatMessage::mutable_tool_calls(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.ChatMessage.tool_calls)
  return _impl_.tool_calls_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::chat::v1::ToolCall >*
ChatMessage::mutable_tool_calls() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.chat.v1.ChatMessage.tool_calls)
  return &_impl_.tool_calls_;
}
inline const ::unhinged::chat::v1::ToolCall& ChatMessage::_internal_tool_calls(int index) const {
  return _impl_.tool_calls_.Get(index);
}
inline const ::unhinged::chat::v1::ToolCall& ChatMessage::tool_calls(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.ChatMessage.tool_calls)
  return _internal_tool_calls(index);
}
inline ::unhinged::chat::v1::ToolCall* ChatMessage::_internal_add_tool_calls() {
  return _impl_.tool_calls_.Add();
}
inline ::unhinged::chat::v1::ToolCall* ChatMessage::add_tool_calls() {
  ::unhinged::chat::v1::ToolCall* _add = _internal_add_tool_calls();
  // @@protoc_insertion_point(field_add:unhinged.chat.v1.ChatMessage.tool_calls)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::chat::v1::ToolCall >&
ChatMessage::tool_calls() const {
  // @@protoc_insertion_point(field_list:unhinged.chat.v1.ChatMessage.tool_calls)
  return _impl_.tool_calls_;
}

// -------------------------------------------------------------------

// ToolCall

// string tool_call_id = 1;
inline void ToolCall::clear_tool_call_id() {
  _impl_.tool_call_id_.ClearToEmpty();
}
inline const std::string& ToolCall::tool_call_id() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.ToolCall.tool_call_id)
  return _internal_tool_call_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ToolCall::set_tool_call_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tool_call_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.ToolCall.tool_call_id)
}
inline std::string* ToolCall::mutable_tool_call_id() {
  std::string* _s = _internal_mutable_tool_call_id();
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.ToolCall.tool_call_id)
  return _s;
}
inline const std::string& ToolCall::_internal_tool_call_id() const {
  return _impl_.tool_call_id_.Get();
}
inline void ToolCall::_internal_set_tool_call_id(const std::string& value) {
  
  _impl_.tool_call_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ToolCall::_internal_mutable_tool_call_id() {
  
  return _impl_.tool_call_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ToolCall::release_tool_call_id() {
  // @@protoc_insertion_point(field_release:unhinged.chat.v1.ToolCall.tool_call_id)
  return _impl_.tool_call_id_.Release();
}
inline void ToolCall::set_allocated_tool_call_id(std::string* tool_call_id) {
  if (tool_call_id != nullptr) {
    
  } else {
    
  }
  _impl_.tool_call_id_.SetAllocated(tool_call_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tool_call_id_.IsDefault()) {
    _impl_.tool_call_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.chat.v1.ToolCall.tool_call_id)
}

// string tool_name = 2;
inline void ToolCall::clear_tool_name() {
  _impl_.tool_name_.ClearToEmpty();
}
inline const std::string& ToolCall::tool_name() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.ToolCall.tool_name)
  return _internal_tool_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ToolCall::set_tool_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tool_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.ToolCall.tool_name)
}
inline std::string* ToolCall::mutable_tool_name() {
  std::string* _s = _internal_mutable_tool_name();
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.ToolCall.tool_name)
  return _s;
}
inline const std::string& ToolCall::_internal_tool_name() const {
  return _impl_.tool_name_.Get();
}
inline void ToolCall::_internal_set_tool_name(const std::string& value) {
  
  _impl_.tool_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ToolCall::_internal_mutable_tool_name() {
  
  return _impl_.tool_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ToolCall::release_tool_name() {
  // @@protoc_insertion_point(field_release:unhinged.chat.v1.ToolCall.tool_name)
  return _impl_.tool_name_.Release();
}
inline void ToolCall::set_allocated_tool_name(std::string* tool_name) {
  if (tool_name != nullptr) {
    
  } else {
    
  }
  _impl_.tool_name_.SetAllocated(tool_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tool_name_.IsDefault()) {
    _impl_.tool_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.chat.v1.ToolCall.tool_name)
}

// string arguments = 3;
inline void ToolCall::clear_arguments() {
  _impl_.arguments_.ClearToEmpty();
}
inline const std::string& ToolCall::arguments() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.ToolCall.arguments)
  return _internal_arguments();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ToolCall::set_arguments(ArgT0&& arg0, ArgT... args) {
 
 _impl_.arguments_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.ToolCall.arguments)
}
inline std::string* ToolCall::mutable_arguments() {
  std::string* _s = _internal_mutable_arguments();
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.ToolCall.arguments)
  return _s;
}
inline const std::string& ToolCall::_internal_arguments() const {
  return _impl_.arguments_.Get();
}
inline void ToolCall::_internal_set_arguments(const std::string& value) {
  
  _impl_.arguments_.Set(value, GetArenaForAllocation());
}
inline std::string* ToolCall::_internal_mutable_arguments() {
  
  return _impl_.arguments_.Mutable(GetArenaForAllocation());
}
inline std::string* ToolCall::release_arguments() {
  // @@protoc_insertion_point(field_release:unhinged.chat.v1.ToolCall.arguments)
  return _impl_.arguments_.Release();
}
inline void ToolCall::set_allocated_arguments(std::string* arguments) {
  if (arguments != nullptr) {
    
  } else {
    
  }
  _impl_.arguments_.SetAllocated(arguments, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.arguments_.IsDefault()) {
    _impl_.arguments_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.chat.v1.ToolCall.arguments)
}

// string result = 4;
inline void ToolCall::clear_result() {
  _impl_.result_.ClearToEmpty();
}
inline const std::string& ToolCall::result() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.ToolCall.result)
  return _internal_result();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ToolCall::set_result(ArgT0&& arg0, ArgT... args) {
 
 _impl_.result_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.ToolCall.result)
}
inline std::string* ToolCall::mutable_result() {
  std::string* _s = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.ToolCall.result)
  return _s;
}
inline const std::string& ToolCall::_internal_result() const {
  return _impl_.result_.Get();
}
inline void ToolCall::_internal_set_result(const std::string& value) {
  
  _impl_.result_.Set(value, GetArenaForAllocation());
}
inline std::string* ToolCall::_internal_mutable_result() {
  
  return _impl_.result_.Mutable(GetArenaForAllocation());
}
inline std::string* ToolCall::release_result() {
  // @@protoc_insertion_point(field_release:unhinged.chat.v1.ToolCall.result)
  return _impl_.result_.Release();
}
inline void ToolCall::set_allocated_result(std::string* result) {
  if (result != nullptr) {
    
  } else {
    
  }
  _impl_.result_.SetAllocated(result, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.result_.IsDefault()) {
    _impl_.result_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.chat.v1.ToolCall.result)
}

// .unhinged.chat.v1.ToolCallStatus status = 5;
inline void ToolCall::clear_status() {
  _impl_.status_ = 0;
}
inline ::unhinged::chat::v1::ToolCallStatus ToolCall::_internal_status() const {
  return static_cast< ::unhinged::chat::v1::ToolCallStatus >(_impl_.status_);
}
inline ::unhinged::chat::v1::ToolCallStatus ToolCall::status() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.ToolCall.status)
  return _internal_status();
}
inline void ToolCall::_internal_set_status(::unhinged::chat::v1::ToolCallStatus value) {
  
  _impl_.status_ = value;
}
inline void ToolCall::set_status(::unhinged::chat::v1::ToolCallStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.ToolCall.status)
}

// -------------------------------------------------------------------

// CreateConversationRequest

// string team_id = 1;
inline void CreateConversationRequest::clear_team_id() {
  _impl_.team_id_.ClearToEmpty();
}
inline const std::string& CreateConversationRequest::team_id() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.CreateConversationRequest.team_id)
  return _internal_team_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateConversationRequest::set_team_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.team_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.CreateConversationRequest.team_id)
}
inline std::string* CreateConversationRequest::mutable_team_id() {
  std::string* _s = _internal_mutable_team_id();
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.CreateConversationRequest.team_id)
  return _s;
}
inline const std::string& CreateConversationRequest::_internal_team_id() const {
  return _impl_.team_id_.Get();
}
inline void CreateConversationRequest::_internal_set_team_id(const std::string& value) {
  
  _impl_.team_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateConversationRequest::_internal_mutable_team_id() {
  
  return _impl_.team_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateConversationRequest::release_team_id() {
  // @@protoc_insertion_point(field_release:unhinged.chat.v1.CreateConversationRequest.team_id)
  return _impl_.team_id_.Release();
}
inline void CreateConversationRequest::set_allocated_team_id(std::string* team_id) {
  if (team_id != nullptr) {
    
  } else {
    
  }
  _impl_.team_id_.SetAllocated(team_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.team_id_.IsDefault()) {
    _impl_.team_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.chat.v1.CreateConversationRequest.team_id)
}

// string namespace_id = 2;
inline void CreateConversationRequest::clear_namespace_id() {
  _impl_.namespace_id_.ClearToEmpty();
}
inline const std::string& CreateConversationRequest::namespace_id() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.CreateConversationRequest.namespace_id)
  return _internal_namespace_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateConversationRequest::set_namespace_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.namespace_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.CreateConversationRequest.namespace_id)
}
inline std::string* CreateConversationRequest::mutable_namespace_id() {
  std::string* _s = _internal_mutable_namespace_id();
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.CreateConversationRequest.namespace_id)
  return _s;
}
inline const std::string& CreateConversationRequest::_internal_namespace_id() const {
  return _impl_.namespace_id_.Get();
}
inline void CreateConversationRequest::_internal_set_namespace_id(const std::string& value) {
  
  _impl_.namespace_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateConversationRequest::_internal_mutable_namespace_id() {
  
  return _impl_.namespace_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateConversationRequest::release_namespace_id() {
  // @@protoc_insertion_point(field_release:unhinged.chat.v1.CreateConversationRequest.namespace_id)
  return _impl_.namespace_id_.Release();
}
inline void CreateConversationRequest::set_allocated_namespace_id(std::string* namespace_id) {
  if (namespace_id != nullptr) {
    
  } else {
    
  }
  _impl_.namespace_id_.SetAllocated(namespace_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.namespace_id_.IsDefault()) {
    _impl_.namespace_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.chat.v1.CreateConversationRequest.namespace_id)
}

// string title = 3;
inline void CreateConversationRequest::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& CreateConversationRequest::title() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.CreateConversationRequest.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateConversationRequest::set_title(ArgT0&& arg0, ArgT... args) {
 
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.CreateConversationRequest.title)
}
inline std::string* CreateConversationRequest::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.CreateConversationRequest.title)
  return _s;
}
inline const std::string& CreateConversationRequest::_internal_title() const {
  return _impl_.title_.Get();
}
inline void CreateConversationRequest::_internal_set_title(const std::string& value) {
  
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateConversationRequest::_internal_mutable_title() {
  
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateConversationRequest::release_title() {
  // @@protoc_insertion_point(field_release:unhinged.chat.v1.CreateConversationRequest.title)
  return _impl_.title_.Release();
}
inline void CreateConversationRequest::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.chat.v1.CreateConversationRequest.title)
}

// string description = 4;
inline void CreateConversationRequest::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& CreateConversationRequest::description() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.CreateConversationRequest.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateConversationRequest::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.CreateConversationRequest.description)
}
inline std::string* CreateConversationRequest::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.CreateConversationRequest.description)
  return _s;
}
inline const std::string& CreateConversationRequest::_internal_description() const {
  return _impl_.description_.Get();
}
inline void CreateConversationRequest::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateConversationRequest::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateConversationRequest::release_description() {
  // @@protoc_insertion_point(field_release:unhinged.chat.v1.CreateConversationRequest.description)
  return _impl_.description_.Release();
}
inline void CreateConversationRequest::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.chat.v1.CreateConversationRequest.description)
}

// .unhinged.chat.v1.ConversationSettings settings = 5;
inline bool CreateConversationRequest::_internal_has_settings() const {
  return this != internal_default_instance() && _impl_.settings_ != nullptr;
}
inline bool CreateConversationRequest::has_settings() const {
  return _internal_has_settings();
}
inline void CreateConversationRequest::clear_settings() {
  if (GetArenaForAllocation() == nullptr && _impl_.settings_ != nullptr) {
    delete _impl_.settings_;
  }
  _impl_.settings_ = nullptr;
}
inline const ::unhinged::chat::v1::ConversationSettings& CreateConversationRequest::_internal_settings() const {
  const ::unhinged::chat::v1::ConversationSettings* p = _impl_.settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::chat::v1::ConversationSettings&>(
      ::unhinged::chat::v1::_ConversationSettings_default_instance_);
}
inline const ::unhinged::chat::v1::ConversationSettings& CreateConversationRequest::settings() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.CreateConversationRequest.settings)
  return _internal_settings();
}
inline void CreateConversationRequest::unsafe_arena_set_allocated_settings(
    ::unhinged::chat::v1::ConversationSettings* settings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.settings_);
  }
  _impl_.settings_ = settings;
  if (settings) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.chat.v1.CreateConversationRequest.settings)
}
inline ::unhinged::chat::v1::ConversationSettings* CreateConversationRequest::release_settings() {
  
  ::unhinged::chat::v1::ConversationSettings* temp = _impl_.settings_;
  _impl_.settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::chat::v1::ConversationSettings* CreateConversationRequest::unsafe_arena_release_settings() {
  // @@protoc_insertion_point(field_release:unhinged.chat.v1.CreateConversationRequest.settings)
  
  ::unhinged::chat::v1::ConversationSettings* temp = _impl_.settings_;
  _impl_.settings_ = nullptr;
  return temp;
}
inline ::unhinged::chat::v1::ConversationSettings* CreateConversationRequest::_internal_mutable_settings() {
  
  if (_impl_.settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::chat::v1::ConversationSettings>(GetArenaForAllocation());
    _impl_.settings_ = p;
  }
  return _impl_.settings_;
}
inline ::unhinged::chat::v1::ConversationSettings* CreateConversationRequest::mutable_settings() {
  ::unhinged::chat::v1::ConversationSettings* _msg = _internal_mutable_settings();
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.CreateConversationRequest.settings)
  return _msg;
}
inline void CreateConversationRequest::set_allocated_settings(::unhinged::chat::v1::ConversationSettings* settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.settings_;
  }
  if (settings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(settings);
    if (message_arena != submessage_arena) {
      settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, settings, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.settings_ = settings;
  // @@protoc_insertion_point(field_set_allocated:unhinged.chat.v1.CreateConversationRequest.settings)
}

// -------------------------------------------------------------------

// CreateConversationResponse

// .unhinged.common.v1.StandardResponse response = 1;
inline bool CreateConversationResponse::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool CreateConversationResponse::has_response() const {
  return _internal_has_response();
}
inline const ::unhinged::common::v1::StandardResponse& CreateConversationResponse::_internal_response() const {
  const ::unhinged::common::v1::StandardResponse* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::common::v1::StandardResponse&>(
      ::unhinged::common::v1::_StandardResponse_default_instance_);
}
inline const ::unhinged::common::v1::StandardResponse& CreateConversationResponse::response() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.CreateConversationResponse.response)
  return _internal_response();
}
inline void CreateConversationResponse::unsafe_arena_set_allocated_response(
    ::unhinged::common::v1::StandardResponse* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.chat.v1.CreateConversationResponse.response)
}
inline ::unhinged::common::v1::StandardResponse* CreateConversationResponse::release_response() {
  
  ::unhinged::common::v1::StandardResponse* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::common::v1::StandardResponse* CreateConversationResponse::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:unhinged.chat.v1.CreateConversationResponse.response)
  
  ::unhinged::common::v1::StandardResponse* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::unhinged::common::v1::StandardResponse* CreateConversationResponse::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::common::v1::StandardResponse>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::unhinged::common::v1::StandardResponse* CreateConversationResponse::mutable_response() {
  ::unhinged::common::v1::StandardResponse* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.CreateConversationResponse.response)
  return _msg;
}
inline void CreateConversationResponse::set_allocated_response(::unhinged::common::v1::StandardResponse* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:unhinged.chat.v1.CreateConversationResponse.response)
}

// .unhinged.chat.v1.Conversation conversation = 2;
inline bool CreateConversationResponse::_internal_has_conversation() const {
  return this != internal_default_instance() && _impl_.conversation_ != nullptr;
}
inline bool CreateConversationResponse::has_conversation() const {
  return _internal_has_conversation();
}
inline void CreateConversationResponse::clear_conversation() {
  if (GetArenaForAllocation() == nullptr && _impl_.conversation_ != nullptr) {
    delete _impl_.conversation_;
  }
  _impl_.conversation_ = nullptr;
}
inline const ::unhinged::chat::v1::Conversation& CreateConversationResponse::_internal_conversation() const {
  const ::unhinged::chat::v1::Conversation* p = _impl_.conversation_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::chat::v1::Conversation&>(
      ::unhinged::chat::v1::_Conversation_default_instance_);
}
inline const ::unhinged::chat::v1::Conversation& CreateConversationResponse::conversation() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.CreateConversationResponse.conversation)
  return _internal_conversation();
}
inline void CreateConversationResponse::unsafe_arena_set_allocated_conversation(
    ::unhinged::chat::v1::Conversation* conversation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.conversation_);
  }
  _impl_.conversation_ = conversation;
  if (conversation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.chat.v1.CreateConversationResponse.conversation)
}
inline ::unhinged::chat::v1::Conversation* CreateConversationResponse::release_conversation() {
  
  ::unhinged::chat::v1::Conversation* temp = _impl_.conversation_;
  _impl_.conversation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::chat::v1::Conversation* CreateConversationResponse::unsafe_arena_release_conversation() {
  // @@protoc_insertion_point(field_release:unhinged.chat.v1.CreateConversationResponse.conversation)
  
  ::unhinged::chat::v1::Conversation* temp = _impl_.conversation_;
  _impl_.conversation_ = nullptr;
  return temp;
}
inline ::unhinged::chat::v1::Conversation* CreateConversationResponse::_internal_mutable_conversation() {
  
  if (_impl_.conversation_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::chat::v1::Conversation>(GetArenaForAllocation());
    _impl_.conversation_ = p;
  }
  return _impl_.conversation_;
}
inline ::unhinged::chat::v1::Conversation* CreateConversationResponse::mutable_conversation() {
  ::unhinged::chat::v1::Conversation* _msg = _internal_mutable_conversation();
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.CreateConversationResponse.conversation)
  return _msg;
}
inline void CreateConversationResponse::set_allocated_conversation(::unhinged::chat::v1::Conversation* conversation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.conversation_;
  }
  if (conversation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(conversation);
    if (message_arena != submessage_arena) {
      conversation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, conversation, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.conversation_ = conversation;
  // @@protoc_insertion_point(field_set_allocated:unhinged.chat.v1.CreateConversationResponse.conversation)
}

// -------------------------------------------------------------------

// GetConversationRequest

// string conversation_id = 1;
inline void GetConversationRequest::clear_conversation_id() {
  _impl_.conversation_id_.ClearToEmpty();
}
inline const std::string& GetConversationRequest::conversation_id() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.GetConversationRequest.conversation_id)
  return _internal_conversation_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetConversationRequest::set_conversation_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.conversation_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.GetConversationRequest.conversation_id)
}
inline std::string* GetConversationRequest::mutable_conversation_id() {
  std::string* _s = _internal_mutable_conversation_id();
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.GetConversationRequest.conversation_id)
  return _s;
}
inline const std::string& GetConversationRequest::_internal_conversation_id() const {
  return _impl_.conversation_id_.Get();
}
inline void GetConversationRequest::_internal_set_conversation_id(const std::string& value) {
  
  _impl_.conversation_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetConversationRequest::_internal_mutable_conversation_id() {
  
  return _impl_.conversation_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetConversationRequest::release_conversation_id() {
  // @@protoc_insertion_point(field_release:unhinged.chat.v1.GetConversationRequest.conversation_id)
  return _impl_.conversation_id_.Release();
}
inline void GetConversationRequest::set_allocated_conversation_id(std::string* conversation_id) {
  if (conversation_id != nullptr) {
    
  } else {
    
  }
  _impl_.conversation_id_.SetAllocated(conversation_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.conversation_id_.IsDefault()) {
    _impl_.conversation_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.chat.v1.GetConversationRequest.conversation_id)
}

// bool include_messages = 2;
inline void GetConversationRequest::clear_include_messages() {
  _impl_.include_messages_ = false;
}
inline bool GetConversationRequest::_internal_include_messages() const {
  return _impl_.include_messages_;
}
inline bool GetConversationRequest::include_messages() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.GetConversationRequest.include_messages)
  return _internal_include_messages();
}
inline void GetConversationRequest::_internal_set_include_messages(bool value) {
  
  _impl_.include_messages_ = value;
}
inline void GetConversationRequest::set_include_messages(bool value) {
  _internal_set_include_messages(value);
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.GetConversationRequest.include_messages)
}

// int32 message_limit = 3;
inline void GetConversationRequest::clear_message_limit() {
  _impl_.message_limit_ = 0;
}
inline int32_t GetConversationRequest::_internal_message_limit() const {
  return _impl_.message_limit_;
}
inline int32_t GetConversationRequest::message_limit() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.GetConversationRequest.message_limit)
  return _internal_message_limit();
}
inline void GetConversationRequest::_internal_set_message_limit(int32_t value) {
  
  _impl_.message_limit_ = value;
}
inline void GetConversationRequest::set_message_limit(int32_t value) {
  _internal_set_message_limit(value);
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.GetConversationRequest.message_limit)
}

// -------------------------------------------------------------------

// GetConversationResponse

// .unhinged.common.v1.StandardResponse response = 1;
inline bool GetConversationResponse::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool GetConversationResponse::has_response() const {
  return _internal_has_response();
}
inline const ::unhinged::common::v1::StandardResponse& GetConversationResponse::_internal_response() const {
  const ::unhinged::common::v1::StandardResponse* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::common::v1::StandardResponse&>(
      ::unhinged::common::v1::_StandardResponse_default_instance_);
}
inline const ::unhinged::common::v1::StandardResponse& GetConversationResponse::response() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.GetConversationResponse.response)
  return _internal_response();
}
inline void GetConversationResponse::unsafe_arena_set_allocated_response(
    ::unhinged::common::v1::StandardResponse* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.chat.v1.GetConversationResponse.response)
}
inline ::unhinged::common::v1::StandardResponse* GetConversationResponse::release_response() {
  
  ::unhinged::common::v1::StandardResponse* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::common::v1::StandardResponse* GetConversationResponse::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:unhinged.chat.v1.GetConversationResponse.response)
  
  ::unhinged::common::v1::StandardResponse* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::unhinged::common::v1::StandardResponse* GetConversationResponse::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::common::v1::StandardResponse>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::unhinged::common::v1::StandardResponse* GetConversationResponse::mutable_response() {
  ::unhinged::common::v1::StandardResponse* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.GetConversationResponse.response)
  return _msg;
}
inline void GetConversationResponse::set_allocated_response(::unhinged::common::v1::StandardResponse* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:unhinged.chat.v1.GetConversationResponse.response)
}

// .unhinged.chat.v1.Conversation conversation = 2;
inline bool GetConversationResponse::_internal_has_conversation() const {
  return this != internal_default_instance() && _impl_.conversation_ != nullptr;
}
inline bool GetConversationResponse::has_conversation() const {
  return _internal_has_conversation();
}
inline void GetConversationResponse::clear_conversation() {
  if (GetArenaForAllocation() == nullptr && _impl_.conversation_ != nullptr) {
    delete _impl_.conversation_;
  }
  _impl_.conversation_ = nullptr;
}
inline const ::unhinged::chat::v1::Conversation& GetConversationResponse::_internal_conversation() const {
  const ::unhinged::chat::v1::Conversation* p = _impl_.conversation_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::chat::v1::Conversation&>(
      ::unhinged::chat::v1::_Conversation_default_instance_);
}
inline const ::unhinged::chat::v1::Conversation& GetConversationResponse::conversation() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.GetConversationResponse.conversation)
  return _internal_conversation();
}
inline void GetConversationResponse::unsafe_arena_set_allocated_conversation(
    ::unhinged::chat::v1::Conversation* conversation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.conversation_);
  }
  _impl_.conversation_ = conversation;
  if (conversation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.chat.v1.GetConversationResponse.conversation)
}
inline ::unhinged::chat::v1::Conversation* GetConversationResponse::release_conversation() {
  
  ::unhinged::chat::v1::Conversation* temp = _impl_.conversation_;
  _impl_.conversation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::chat::v1::Conversation* GetConversationResponse::unsafe_arena_release_conversation() {
  // @@protoc_insertion_point(field_release:unhinged.chat.v1.GetConversationResponse.conversation)
  
  ::unhinged::chat::v1::Conversation* temp = _impl_.conversation_;
  _impl_.conversation_ = nullptr;
  return temp;
}
inline ::unhinged::chat::v1::Conversation* GetConversationResponse::_internal_mutable_conversation() {
  
  if (_impl_.conversation_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::chat::v1::Conversation>(GetArenaForAllocation());
    _impl_.conversation_ = p;
  }
  return _impl_.conversation_;
}
inline ::unhinged::chat::v1::Conversation* GetConversationResponse::mutable_conversation() {
  ::unhinged::chat::v1::Conversation* _msg = _internal_mutable_conversation();
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.GetConversationResponse.conversation)
  return _msg;
}
inline void GetConversationResponse::set_allocated_conversation(::unhinged::chat::v1::Conversation* conversation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.conversation_;
  }
  if (conversation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(conversation);
    if (message_arena != submessage_arena) {
      conversation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, conversation, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.conversation_ = conversation;
  // @@protoc_insertion_point(field_set_allocated:unhinged.chat.v1.GetConversationResponse.conversation)
}

// repeated .unhinged.chat.v1.ChatMessage messages = 3;
inline int GetConversationResponse::_internal_messages_size() const {
  return _impl_.messages_.size();
}
inline int GetConversationResponse::messages_size() const {
  return _internal_messages_size();
}
inline void GetConversationResponse::clear_messages() {
  _impl_.messages_.Clear();
}
inline ::unhinged::chat::v1::ChatMessage* GetConversationResponse::mutable_messages(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.GetConversationResponse.messages)
  return _impl_.messages_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::chat::v1::ChatMessage >*
GetConversationResponse::mutable_messages() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.chat.v1.GetConversationResponse.messages)
  return &_impl_.messages_;
}
inline const ::unhinged::chat::v1::ChatMessage& GetConversationResponse::_internal_messages(int index) const {
  return _impl_.messages_.Get(index);
}
inline const ::unhinged::chat::v1::ChatMessage& GetConversationResponse::messages(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.GetConversationResponse.messages)
  return _internal_messages(index);
}
inline ::unhinged::chat::v1::ChatMessage* GetConversationResponse::_internal_add_messages() {
  return _impl_.messages_.Add();
}
inline ::unhinged::chat::v1::ChatMessage* GetConversationResponse::add_messages() {
  ::unhinged::chat::v1::ChatMessage* _add = _internal_add_messages();
  // @@protoc_insertion_point(field_add:unhinged.chat.v1.GetConversationResponse.messages)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::chat::v1::ChatMessage >&
GetConversationResponse::messages() const {
  // @@protoc_insertion_point(field_list:unhinged.chat.v1.GetConversationResponse.messages)
  return _impl_.messages_;
}

// -------------------------------------------------------------------

// ListConversationsRequest

// string team_id = 1;
inline void ListConversationsRequest::clear_team_id() {
  _impl_.team_id_.ClearToEmpty();
}
inline const std::string& ListConversationsRequest::team_id() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.ListConversationsRequest.team_id)
  return _internal_team_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListConversationsRequest::set_team_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.team_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.ListConversationsRequest.team_id)
}
inline std::string* ListConversationsRequest::mutable_team_id() {
  std::string* _s = _internal_mutable_team_id();
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.ListConversationsRequest.team_id)
  return _s;
}
inline const std::string& ListConversationsRequest::_internal_team_id() const {
  return _impl_.team_id_.Get();
}
inline void ListConversationsRequest::_internal_set_team_id(const std::string& value) {
  
  _impl_.team_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ListConversationsRequest::_internal_mutable_team_id() {
  
  return _impl_.team_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ListConversationsRequest::release_team_id() {
  // @@protoc_insertion_point(field_release:unhinged.chat.v1.ListConversationsRequest.team_id)
  return _impl_.team_id_.Release();
}
inline void ListConversationsRequest::set_allocated_team_id(std::string* team_id) {
  if (team_id != nullptr) {
    
  } else {
    
  }
  _impl_.team_id_.SetAllocated(team_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.team_id_.IsDefault()) {
    _impl_.team_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.chat.v1.ListConversationsRequest.team_id)
}

// string namespace_id = 2;
inline void ListConversationsRequest::clear_namespace_id() {
  _impl_.namespace_id_.ClearToEmpty();
}
inline const std::string& ListConversationsRequest::namespace_id() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.ListConversationsRequest.namespace_id)
  return _internal_namespace_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListConversationsRequest::set_namespace_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.namespace_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.ListConversationsRequest.namespace_id)
}
inline std::string* ListConversationsRequest::mutable_namespace_id() {
  std::string* _s = _internal_mutable_namespace_id();
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.ListConversationsRequest.namespace_id)
  return _s;
}
inline const std::string& ListConversationsRequest::_internal_namespace_id() const {
  return _impl_.namespace_id_.Get();
}
inline void ListConversationsRequest::_internal_set_namespace_id(const std::string& value) {
  
  _impl_.namespace_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ListConversationsRequest::_internal_mutable_namespace_id() {
  
  return _impl_.namespace_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ListConversationsRequest::release_namespace_id() {
  // @@protoc_insertion_point(field_release:unhinged.chat.v1.ListConversationsRequest.namespace_id)
  return _impl_.namespace_id_.Release();
}
inline void ListConversationsRequest::set_allocated_namespace_id(std::string* namespace_id) {
  if (namespace_id != nullptr) {
    
  } else {
    
  }
  _impl_.namespace_id_.SetAllocated(namespace_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.namespace_id_.IsDefault()) {
    _impl_.namespace_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.chat.v1.ListConversationsRequest.namespace_id)
}

// .unhinged.chat.v1.ConversationStatus status = 3;
inline void ListConversationsRequest::clear_status() {
  _impl_.status_ = 0;
}
inline ::unhinged::chat::v1::ConversationStatus ListConversationsRequest::_internal_status() const {
  return static_cast< ::unhinged::chat::v1::ConversationStatus >(_impl_.status_);
}
inline ::unhinged::chat::v1::ConversationStatus ListConversationsRequest::status() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.ListConversationsRequest.status)
  return _internal_status();
}
inline void ListConversationsRequest::_internal_set_status(::unhinged::chat::v1::ConversationStatus value) {
  
  _impl_.status_ = value;
}
inline void ListConversationsRequest::set_status(::unhinged::chat::v1::ConversationStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.ListConversationsRequest.status)
}

// .unhinged.common.v1.PaginationRequest pagination = 4;
inline bool ListConversationsRequest::_internal_has_pagination() const {
  return this != internal_default_instance() && _impl_.pagination_ != nullptr;
}
inline bool ListConversationsRequest::has_pagination() const {
  return _internal_has_pagination();
}
inline const ::unhinged::common::v1::PaginationRequest& ListConversationsRequest::_internal_pagination() const {
  const ::unhinged::common::v1::PaginationRequest* p = _impl_.pagination_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::common::v1::PaginationRequest&>(
      ::unhinged::common::v1::_PaginationRequest_default_instance_);
}
inline const ::unhinged::common::v1::PaginationRequest& ListConversationsRequest::pagination() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.ListConversationsRequest.pagination)
  return _internal_pagination();
}
inline void ListConversationsRequest::unsafe_arena_set_allocated_pagination(
    ::unhinged::common::v1::PaginationRequest* pagination) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pagination_);
  }
  _impl_.pagination_ = pagination;
  if (pagination) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.chat.v1.ListConversationsRequest.pagination)
}
inline ::unhinged::common::v1::PaginationRequest* ListConversationsRequest::release_pagination() {
  
  ::unhinged::common::v1::PaginationRequest* temp = _impl_.pagination_;
  _impl_.pagination_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::common::v1::PaginationRequest* ListConversationsRequest::unsafe_arena_release_pagination() {
  // @@protoc_insertion_point(field_release:unhinged.chat.v1.ListConversationsRequest.pagination)
  
  ::unhinged::common::v1::PaginationRequest* temp = _impl_.pagination_;
  _impl_.pagination_ = nullptr;
  return temp;
}
inline ::unhinged::common::v1::PaginationRequest* ListConversationsRequest::_internal_mutable_pagination() {
  
  if (_impl_.pagination_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::common::v1::PaginationRequest>(GetArenaForAllocation());
    _impl_.pagination_ = p;
  }
  return _impl_.pagination_;
}
inline ::unhinged::common::v1::PaginationRequest* ListConversationsRequest::mutable_pagination() {
  ::unhinged::common::v1::PaginationRequest* _msg = _internal_mutable_pagination();
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.ListConversationsRequest.pagination)
  return _msg;
}
inline void ListConversationsRequest::set_allocated_pagination(::unhinged::common::v1::PaginationRequest* pagination) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pagination_);
  }
  if (pagination) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pagination));
    if (message_arena != submessage_arena) {
      pagination = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pagination, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pagination_ = pagination;
  // @@protoc_insertion_point(field_set_allocated:unhinged.chat.v1.ListConversationsRequest.pagination)
}

// repeated .unhinged.common.v1.Filter filters = 5;
inline int ListConversationsRequest::_internal_filters_size() const {
  return _impl_.filters_.size();
}
inline int ListConversationsRequest::filters_size() const {
  return _internal_filters_size();
}
inline ::unhinged::common::v1::Filter* ListConversationsRequest::mutable_filters(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.ListConversationsRequest.filters)
  return _impl_.filters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::common::v1::Filter >*
ListConversationsRequest::mutable_filters() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.chat.v1.ListConversationsRequest.filters)
  return &_impl_.filters_;
}
inline const ::unhinged::common::v1::Filter& ListConversationsRequest::_internal_filters(int index) const {
  return _impl_.filters_.Get(index);
}
inline const ::unhinged::common::v1::Filter& ListConversationsRequest::filters(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.ListConversationsRequest.filters)
  return _internal_filters(index);
}
inline ::unhinged::common::v1::Filter* ListConversationsRequest::_internal_add_filters() {
  return _impl_.filters_.Add();
}
inline ::unhinged::common::v1::Filter* ListConversationsRequest::add_filters() {
  ::unhinged::common::v1::Filter* _add = _internal_add_filters();
  // @@protoc_insertion_point(field_add:unhinged.chat.v1.ListConversationsRequest.filters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::common::v1::Filter >&
ListConversationsRequest::filters() const {
  // @@protoc_insertion_point(field_list:unhinged.chat.v1.ListConversationsRequest.filters)
  return _impl_.filters_;
}

// -------------------------------------------------------------------

// ListConversationsResponse

// .unhinged.common.v1.StandardResponse response = 1;
inline bool ListConversationsResponse::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool ListConversationsResponse::has_response() const {
  return _internal_has_response();
}
inline const ::unhinged::common::v1::StandardResponse& ListConversationsResponse::_internal_response() const {
  const ::unhinged::common::v1::StandardResponse* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::common::v1::StandardResponse&>(
      ::unhinged::common::v1::_StandardResponse_default_instance_);
}
inline const ::unhinged::common::v1::StandardResponse& ListConversationsResponse::response() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.ListConversationsResponse.response)
  return _internal_response();
}
inline void ListConversationsResponse::unsafe_arena_set_allocated_response(
    ::unhinged::common::v1::StandardResponse* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.chat.v1.ListConversationsResponse.response)
}
inline ::unhinged::common::v1::StandardResponse* ListConversationsResponse::release_response() {
  
  ::unhinged::common::v1::StandardResponse* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::common::v1::StandardResponse* ListConversationsResponse::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:unhinged.chat.v1.ListConversationsResponse.response)
  
  ::unhinged::common::v1::StandardResponse* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::unhinged::common::v1::StandardResponse* ListConversationsResponse::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::common::v1::StandardResponse>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::unhinged::common::v1::StandardResponse* ListConversationsResponse::mutable_response() {
  ::unhinged::common::v1::StandardResponse* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.ListConversationsResponse.response)
  return _msg;
}
inline void ListConversationsResponse::set_allocated_response(::unhinged::common::v1::StandardResponse* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:unhinged.chat.v1.ListConversationsResponse.response)
}

// repeated .unhinged.chat.v1.Conversation conversations = 2;
inline int ListConversationsResponse::_internal_conversations_size() const {
  return _impl_.conversations_.size();
}
inline int ListConversationsResponse::conversations_size() const {
  return _internal_conversations_size();
}
inline void ListConversationsResponse::clear_conversations() {
  _impl_.conversations_.Clear();
}
inline ::unhinged::chat::v1::Conversation* ListConversationsResponse::mutable_conversations(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.ListConversationsResponse.conversations)
  return _impl_.conversations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::chat::v1::Conversation >*
ListConversationsResponse::mutable_conversations() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.chat.v1.ListConversationsResponse.conversations)
  return &_impl_.conversations_;
}
inline const ::unhinged::chat::v1::Conversation& ListConversationsResponse::_internal_conversations(int index) const {
  return _impl_.conversations_.Get(index);
}
inline const ::unhinged::chat::v1::Conversation& ListConversationsResponse::conversations(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.ListConversationsResponse.conversations)
  return _internal_conversations(index);
}
inline ::unhinged::chat::v1::Conversation* ListConversationsResponse::_internal_add_conversations() {
  return _impl_.conversations_.Add();
}
inline ::unhinged::chat::v1::Conversation* ListConversationsResponse::add_conversations() {
  ::unhinged::chat::v1::Conversation* _add = _internal_add_conversations();
  // @@protoc_insertion_point(field_add:unhinged.chat.v1.ListConversationsResponse.conversations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::chat::v1::Conversation >&
ListConversationsResponse::conversations() const {
  // @@protoc_insertion_point(field_list:unhinged.chat.v1.ListConversationsResponse.conversations)
  return _impl_.conversations_;
}

// .unhinged.common.v1.PaginationResponse pagination = 3;
inline bool ListConversationsResponse::_internal_has_pagination() const {
  return this != internal_default_instance() && _impl_.pagination_ != nullptr;
}
inline bool ListConversationsResponse::has_pagination() const {
  return _internal_has_pagination();
}
inline const ::unhinged::common::v1::PaginationResponse& ListConversationsResponse::_internal_pagination() const {
  const ::unhinged::common::v1::PaginationResponse* p = _impl_.pagination_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::common::v1::PaginationResponse&>(
      ::unhinged::common::v1::_PaginationResponse_default_instance_);
}
inline const ::unhinged::common::v1::PaginationResponse& ListConversationsResponse::pagination() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.ListConversationsResponse.pagination)
  return _internal_pagination();
}
inline void ListConversationsResponse::unsafe_arena_set_allocated_pagination(
    ::unhinged::common::v1::PaginationResponse* pagination) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pagination_);
  }
  _impl_.pagination_ = pagination;
  if (pagination) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.chat.v1.ListConversationsResponse.pagination)
}
inline ::unhinged::common::v1::PaginationResponse* ListConversationsResponse::release_pagination() {
  
  ::unhinged::common::v1::PaginationResponse* temp = _impl_.pagination_;
  _impl_.pagination_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::common::v1::PaginationResponse* ListConversationsResponse::unsafe_arena_release_pagination() {
  // @@protoc_insertion_point(field_release:unhinged.chat.v1.ListConversationsResponse.pagination)
  
  ::unhinged::common::v1::PaginationResponse* temp = _impl_.pagination_;
  _impl_.pagination_ = nullptr;
  return temp;
}
inline ::unhinged::common::v1::PaginationResponse* ListConversationsResponse::_internal_mutable_pagination() {
  
  if (_impl_.pagination_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::common::v1::PaginationResponse>(GetArenaForAllocation());
    _impl_.pagination_ = p;
  }
  return _impl_.pagination_;
}
inline ::unhinged::common::v1::PaginationResponse* ListConversationsResponse::mutable_pagination() {
  ::unhinged::common::v1::PaginationResponse* _msg = _internal_mutable_pagination();
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.ListConversationsResponse.pagination)
  return _msg;
}
inline void ListConversationsResponse::set_allocated_pagination(::unhinged::common::v1::PaginationResponse* pagination) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pagination_);
  }
  if (pagination) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pagination));
    if (message_arena != submessage_arena) {
      pagination = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pagination, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pagination_ = pagination;
  // @@protoc_insertion_point(field_set_allocated:unhinged.chat.v1.ListConversationsResponse.pagination)
}

// -------------------------------------------------------------------

// SendMessageRequest

// string conversation_id = 1;
inline void SendMessageRequest::clear_conversation_id() {
  _impl_.conversation_id_.ClearToEmpty();
}
inline const std::string& SendMessageRequest::conversation_id() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.SendMessageRequest.conversation_id)
  return _internal_conversation_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendMessageRequest::set_conversation_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.conversation_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.SendMessageRequest.conversation_id)
}
inline std::string* SendMessageRequest::mutable_conversation_id() {
  std::string* _s = _internal_mutable_conversation_id();
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.SendMessageRequest.conversation_id)
  return _s;
}
inline const std::string& SendMessageRequest::_internal_conversation_id() const {
  return _impl_.conversation_id_.Get();
}
inline void SendMessageRequest::_internal_set_conversation_id(const std::string& value) {
  
  _impl_.conversation_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SendMessageRequest::_internal_mutable_conversation_id() {
  
  return _impl_.conversation_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SendMessageRequest::release_conversation_id() {
  // @@protoc_insertion_point(field_release:unhinged.chat.v1.SendMessageRequest.conversation_id)
  return _impl_.conversation_id_.Release();
}
inline void SendMessageRequest::set_allocated_conversation_id(std::string* conversation_id) {
  if (conversation_id != nullptr) {
    
  } else {
    
  }
  _impl_.conversation_id_.SetAllocated(conversation_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.conversation_id_.IsDefault()) {
    _impl_.conversation_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.chat.v1.SendMessageRequest.conversation_id)
}

// .unhinged.chat.v1.MessageRole role = 2;
inline void SendMessageRequest::clear_role() {
  _impl_.role_ = 0;
}
inline ::unhinged::chat::v1::MessageRole SendMessageRequest::_internal_role() const {
  return static_cast< ::unhinged::chat::v1::MessageRole >(_impl_.role_);
}
inline ::unhinged::chat::v1::MessageRole SendMessageRequest::role() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.SendMessageRequest.role)
  return _internal_role();
}
inline void SendMessageRequest::_internal_set_role(::unhinged::chat::v1::MessageRole value) {
  
  _impl_.role_ = value;
}
inline void SendMessageRequest::set_role(::unhinged::chat::v1::MessageRole value) {
  _internal_set_role(value);
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.SendMessageRequest.role)
}

// string content = 3;
inline void SendMessageRequest::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& SendMessageRequest::content() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.SendMessageRequest.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendMessageRequest::set_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.SendMessageRequest.content)
}
inline std::string* SendMessageRequest::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.SendMessageRequest.content)
  return _s;
}
inline const std::string& SendMessageRequest::_internal_content() const {
  return _impl_.content_.Get();
}
inline void SendMessageRequest::_internal_set_content(const std::string& value) {
  
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* SendMessageRequest::_internal_mutable_content() {
  
  return _impl_.content_.Mutable(GetArenaForAllocation());
}
inline std::string* SendMessageRequest::release_content() {
  // @@protoc_insertion_point(field_release:unhinged.chat.v1.SendMessageRequest.content)
  return _impl_.content_.Release();
}
inline void SendMessageRequest::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.chat.v1.SendMessageRequest.content)
}

// repeated .unhinged.common.v1.Attachment attachments = 4;
inline int SendMessageRequest::_internal_attachments_size() const {
  return _impl_.attachments_.size();
}
inline int SendMessageRequest::attachments_size() const {
  return _internal_attachments_size();
}
inline ::unhinged::common::v1::Attachment* SendMessageRequest::mutable_attachments(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.SendMessageRequest.attachments)
  return _impl_.attachments_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::common::v1::Attachment >*
SendMessageRequest::mutable_attachments() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.chat.v1.SendMessageRequest.attachments)
  return &_impl_.attachments_;
}
inline const ::unhinged::common::v1::Attachment& SendMessageRequest::_internal_attachments(int index) const {
  return _impl_.attachments_.Get(index);
}
inline const ::unhinged::common::v1::Attachment& SendMessageRequest::attachments(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.SendMessageRequest.attachments)
  return _internal_attachments(index);
}
inline ::unhinged::common::v1::Attachment* SendMessageRequest::_internal_add_attachments() {
  return _impl_.attachments_.Add();
}
inline ::unhinged::common::v1::Attachment* SendMessageRequest::add_attachments() {
  ::unhinged::common::v1::Attachment* _add = _internal_add_attachments();
  // @@protoc_insertion_point(field_add:unhinged.chat.v1.SendMessageRequest.attachments)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::common::v1::Attachment >&
SendMessageRequest::attachments() const {
  // @@protoc_insertion_point(field_list:unhinged.chat.v1.SendMessageRequest.attachments)
  return _impl_.attachments_;
}

// string parent_message_id = 5;
inline void SendMessageRequest::clear_parent_message_id() {
  _impl_.parent_message_id_.ClearToEmpty();
}
inline const std::string& SendMessageRequest::parent_message_id() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.SendMessageRequest.parent_message_id)
  return _internal_parent_message_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendMessageRequest::set_parent_message_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.parent_message_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.SendMessageRequest.parent_message_id)
}
inline std::string* SendMessageRequest::mutable_parent_message_id() {
  std::string* _s = _internal_mutable_parent_message_id();
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.SendMessageRequest.parent_message_id)
  return _s;
}
inline const std::string& SendMessageRequest::_internal_parent_message_id() const {
  return _impl_.parent_message_id_.Get();
}
inline void SendMessageRequest::_internal_set_parent_message_id(const std::string& value) {
  
  _impl_.parent_message_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SendMessageRequest::_internal_mutable_parent_message_id() {
  
  return _impl_.parent_message_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SendMessageRequest::release_parent_message_id() {
  // @@protoc_insertion_point(field_release:unhinged.chat.v1.SendMessageRequest.parent_message_id)
  return _impl_.parent_message_id_.Release();
}
inline void SendMessageRequest::set_allocated_parent_message_id(std::string* parent_message_id) {
  if (parent_message_id != nullptr) {
    
  } else {
    
  }
  _impl_.parent_message_id_.SetAllocated(parent_message_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parent_message_id_.IsDefault()) {
    _impl_.parent_message_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.chat.v1.SendMessageRequest.parent_message_id)
}

// -------------------------------------------------------------------

// SendMessageResponse

// .unhinged.common.v1.StandardResponse response = 1;
inline bool SendMessageResponse::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool SendMessageResponse::has_response() const {
  return _internal_has_response();
}
inline const ::unhinged::common::v1::StandardResponse& SendMessageResponse::_internal_response() const {
  const ::unhinged::common::v1::StandardResponse* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::common::v1::StandardResponse&>(
      ::unhinged::common::v1::_StandardResponse_default_instance_);
}
inline const ::unhinged::common::v1::StandardResponse& SendMessageResponse::response() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.SendMessageResponse.response)
  return _internal_response();
}
inline void SendMessageResponse::unsafe_arena_set_allocated_response(
    ::unhinged::common::v1::StandardResponse* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.chat.v1.SendMessageResponse.response)
}
inline ::unhinged::common::v1::StandardResponse* SendMessageResponse::release_response() {
  
  ::unhinged::common::v1::StandardResponse* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::common::v1::StandardResponse* SendMessageResponse::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:unhinged.chat.v1.SendMessageResponse.response)
  
  ::unhinged::common::v1::StandardResponse* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::unhinged::common::v1::StandardResponse* SendMessageResponse::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::common::v1::StandardResponse>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::unhinged::common::v1::StandardResponse* SendMessageResponse::mutable_response() {
  ::unhinged::common::v1::StandardResponse* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.SendMessageResponse.response)
  return _msg;
}
inline void SendMessageResponse::set_allocated_response(::unhinged::common::v1::StandardResponse* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:unhinged.chat.v1.SendMessageResponse.response)
}

// .unhinged.chat.v1.ChatMessage message = 2;
inline bool SendMessageResponse::_internal_has_message() const {
  return this != internal_default_instance() && _impl_.message_ != nullptr;
}
inline bool SendMessageResponse::has_message() const {
  return _internal_has_message();
}
inline void SendMessageResponse::clear_message() {
  if (GetArenaForAllocation() == nullptr && _impl_.message_ != nullptr) {
    delete _impl_.message_;
  }
  _impl_.message_ = nullptr;
}
inline const ::unhinged::chat::v1::ChatMessage& SendMessageResponse::_internal_message() const {
  const ::unhinged::chat::v1::ChatMessage* p = _impl_.message_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::chat::v1::ChatMessage&>(
      ::unhinged::chat::v1::_ChatMessage_default_instance_);
}
inline const ::unhinged::chat::v1::ChatMessage& SendMessageResponse::message() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.SendMessageResponse.message)
  return _internal_message();
}
inline void SendMessageResponse::unsafe_arena_set_allocated_message(
    ::unhinged::chat::v1::ChatMessage* message) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.message_);
  }
  _impl_.message_ = message;
  if (message) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.chat.v1.SendMessageResponse.message)
}
inline ::unhinged::chat::v1::ChatMessage* SendMessageResponse::release_message() {
  
  ::unhinged::chat::v1::ChatMessage* temp = _impl_.message_;
  _impl_.message_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::chat::v1::ChatMessage* SendMessageResponse::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_release:unhinged.chat.v1.SendMessageResponse.message)
  
  ::unhinged::chat::v1::ChatMessage* temp = _impl_.message_;
  _impl_.message_ = nullptr;
  return temp;
}
inline ::unhinged::chat::v1::ChatMessage* SendMessageResponse::_internal_mutable_message() {
  
  if (_impl_.message_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::chat::v1::ChatMessage>(GetArenaForAllocation());
    _impl_.message_ = p;
  }
  return _impl_.message_;
}
inline ::unhinged::chat::v1::ChatMessage* SendMessageResponse::mutable_message() {
  ::unhinged::chat::v1::ChatMessage* _msg = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.SendMessageResponse.message)
  return _msg;
}
inline void SendMessageResponse::set_allocated_message(::unhinged::chat::v1::ChatMessage* message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.message_;
  }
  if (message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(message);
    if (message_arena != submessage_arena) {
      message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, message, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.message_ = message;
  // @@protoc_insertion_point(field_set_allocated:unhinged.chat.v1.SendMessageResponse.message)
}

// -------------------------------------------------------------------

// StreamChatRequest

// string conversation_id = 1;
inline void StreamChatRequest::clear_conversation_id() {
  _impl_.conversation_id_.ClearToEmpty();
}
inline const std::string& StreamChatRequest::conversation_id() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.StreamChatRequest.conversation_id)
  return _internal_conversation_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamChatRequest::set_conversation_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.conversation_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.StreamChatRequest.conversation_id)
}
inline std::string* StreamChatRequest::mutable_conversation_id() {
  std::string* _s = _internal_mutable_conversation_id();
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.StreamChatRequest.conversation_id)
  return _s;
}
inline const std::string& StreamChatRequest::_internal_conversation_id() const {
  return _impl_.conversation_id_.Get();
}
inline void StreamChatRequest::_internal_set_conversation_id(const std::string& value) {
  
  _impl_.conversation_id_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamChatRequest::_internal_mutable_conversation_id() {
  
  return _impl_.conversation_id_.Mutable(GetArenaForAllocation());
}
inline std::string* StreamChatRequest::release_conversation_id() {
  // @@protoc_insertion_point(field_release:unhinged.chat.v1.StreamChatRequest.conversation_id)
  return _impl_.conversation_id_.Release();
}
inline void StreamChatRequest::set_allocated_conversation_id(std::string* conversation_id) {
  if (conversation_id != nullptr) {
    
  } else {
    
  }
  _impl_.conversation_id_.SetAllocated(conversation_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.conversation_id_.IsDefault()) {
    _impl_.conversation_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.chat.v1.StreamChatRequest.conversation_id)
}

// string content = 2;
inline void StreamChatRequest::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& StreamChatRequest::content() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.StreamChatRequest.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamChatRequest::set_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.StreamChatRequest.content)
}
inline std::string* StreamChatRequest::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.StreamChatRequest.content)
  return _s;
}
inline const std::string& StreamChatRequest::_internal_content() const {
  return _impl_.content_.Get();
}
inline void StreamChatRequest::_internal_set_content(const std::string& value) {
  
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamChatRequest::_internal_mutable_content() {
  
  return _impl_.content_.Mutable(GetArenaForAllocation());
}
inline std::string* StreamChatRequest::release_content() {
  // @@protoc_insertion_point(field_release:unhinged.chat.v1.StreamChatRequest.content)
  return _impl_.content_.Release();
}
inline void StreamChatRequest::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.chat.v1.StreamChatRequest.content)
}

// repeated .unhinged.common.v1.Attachment attachments = 3;
inline int StreamChatRequest::_internal_attachments_size() const {
  return _impl_.attachments_.size();
}
inline int StreamChatRequest::attachments_size() const {
  return _internal_attachments_size();
}
inline ::unhinged::common::v1::Attachment* StreamChatRequest::mutable_attachments(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.StreamChatRequest.attachments)
  return _impl_.attachments_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::common::v1::Attachment >*
StreamChatRequest::mutable_attachments() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.chat.v1.StreamChatRequest.attachments)
  return &_impl_.attachments_;
}
inline const ::unhinged::common::v1::Attachment& StreamChatRequest::_internal_attachments(int index) const {
  return _impl_.attachments_.Get(index);
}
inline const ::unhinged::common::v1::Attachment& StreamChatRequest::attachments(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.StreamChatRequest.attachments)
  return _internal_attachments(index);
}
inline ::unhinged::common::v1::Attachment* StreamChatRequest::_internal_add_attachments() {
  return _impl_.attachments_.Add();
}
inline ::unhinged::common::v1::Attachment* StreamChatRequest::add_attachments() {
  ::unhinged::common::v1::Attachment* _add = _internal_add_attachments();
  // @@protoc_insertion_point(field_add:unhinged.chat.v1.StreamChatRequest.attachments)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::common::v1::Attachment >&
StreamChatRequest::attachments() const {
  // @@protoc_insertion_point(field_list:unhinged.chat.v1.StreamChatRequest.attachments)
  return _impl_.attachments_;
}

// .unhinged.chat.v1.StreamOptions options = 4;
inline bool StreamChatRequest::_internal_has_options() const {
  return this != internal_default_instance() && _impl_.options_ != nullptr;
}
inline bool StreamChatRequest::has_options() const {
  return _internal_has_options();
}
inline void StreamChatRequest::clear_options() {
  if (GetArenaForAllocation() == nullptr && _impl_.options_ != nullptr) {
    delete _impl_.options_;
  }
  _impl_.options_ = nullptr;
}
inline const ::unhinged::chat::v1::StreamOptions& StreamChatRequest::_internal_options() const {
  const ::unhinged::chat::v1::StreamOptions* p = _impl_.options_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::chat::v1::StreamOptions&>(
      ::unhinged::chat::v1::_StreamOptions_default_instance_);
}
inline const ::unhinged::chat::v1::StreamOptions& StreamChatRequest::options() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.StreamChatRequest.options)
  return _internal_options();
}
inline void StreamChatRequest::unsafe_arena_set_allocated_options(
    ::unhinged::chat::v1::StreamOptions* options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.options_);
  }
  _impl_.options_ = options;
  if (options) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.chat.v1.StreamChatRequest.options)
}
inline ::unhinged::chat::v1::StreamOptions* StreamChatRequest::release_options() {
  
  ::unhinged::chat::v1::StreamOptions* temp = _impl_.options_;
  _impl_.options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::chat::v1::StreamOptions* StreamChatRequest::unsafe_arena_release_options() {
  // @@protoc_insertion_point(field_release:unhinged.chat.v1.StreamChatRequest.options)
  
  ::unhinged::chat::v1::StreamOptions* temp = _impl_.options_;
  _impl_.options_ = nullptr;
  return temp;
}
inline ::unhinged::chat::v1::StreamOptions* StreamChatRequest::_internal_mutable_options() {
  
  if (_impl_.options_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::chat::v1::StreamOptions>(GetArenaForAllocation());
    _impl_.options_ = p;
  }
  return _impl_.options_;
}
inline ::unhinged::chat::v1::StreamOptions* StreamChatRequest::mutable_options() {
  ::unhinged::chat::v1::StreamOptions* _msg = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.StreamChatRequest.options)
  return _msg;
}
inline void StreamChatRequest::set_allocated_options(::unhinged::chat::v1::StreamOptions* options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.options_;
  }
  if (options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(options);
    if (message_arena != submessage_arena) {
      options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.options_ = options;
  // @@protoc_insertion_point(field_set_allocated:unhinged.chat.v1.StreamChatRequest.options)
}

// -------------------------------------------------------------------

// StreamOptions

// string model = 1;
inline void StreamOptions::clear_model() {
  _impl_.model_.ClearToEmpty();
}
inline const std::string& StreamOptions::model() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.StreamOptions.model)
  return _internal_model();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamOptions::set_model(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.StreamOptions.model)
}
inline std::string* StreamOptions::mutable_model() {
  std::string* _s = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.StreamOptions.model)
  return _s;
}
inline const std::string& StreamOptions::_internal_model() const {
  return _impl_.model_.Get();
}
inline void StreamOptions::_internal_set_model(const std::string& value) {
  
  _impl_.model_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamOptions::_internal_mutable_model() {
  
  return _impl_.model_.Mutable(GetArenaForAllocation());
}
inline std::string* StreamOptions::release_model() {
  // @@protoc_insertion_point(field_release:unhinged.chat.v1.StreamOptions.model)
  return _impl_.model_.Release();
}
inline void StreamOptions::set_allocated_model(std::string* model) {
  if (model != nullptr) {
    
  } else {
    
  }
  _impl_.model_.SetAllocated(model, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_.IsDefault()) {
    _impl_.model_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.chat.v1.StreamOptions.model)
}

// int32 max_tokens = 2;
inline void StreamOptions::clear_max_tokens() {
  _impl_.max_tokens_ = 0;
}
inline int32_t StreamOptions::_internal_max_tokens() const {
  return _impl_.max_tokens_;
}
inline int32_t StreamOptions::max_tokens() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.StreamOptions.max_tokens)
  return _internal_max_tokens();
}
inline void StreamOptions::_internal_set_max_tokens(int32_t value) {
  
  _impl_.max_tokens_ = value;
}
inline void StreamOptions::set_max_tokens(int32_t value) {
  _internal_set_max_tokens(value);
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.StreamOptions.max_tokens)
}

// float temperature = 3;
inline void StreamOptions::clear_temperature() {
  _impl_.temperature_ = 0;
}
inline float StreamOptions::_internal_temperature() const {
  return _impl_.temperature_;
}
inline float StreamOptions::temperature() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.StreamOptions.temperature)
  return _internal_temperature();
}
inline void StreamOptions::_internal_set_temperature(float value) {
  
  _impl_.temperature_ = value;
}
inline void StreamOptions::set_temperature(float value) {
  _internal_set_temperature(value);
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.StreamOptions.temperature)
}

// bool include_context = 4;
inline void StreamOptions::clear_include_context() {
  _impl_.include_context_ = false;
}
inline bool StreamOptions::_internal_include_context() const {
  return _impl_.include_context_;
}
inline bool StreamOptions::include_context() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.StreamOptions.include_context)
  return _internal_include_context();
}
inline void StreamOptions::_internal_set_include_context(bool value) {
  
  _impl_.include_context_ = value;
}
inline void StreamOptions::set_include_context(bool value) {
  _internal_set_include_context(value);
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.StreamOptions.include_context)
}

// bool enable_tools = 5;
inline void StreamOptions::clear_enable_tools() {
  _impl_.enable_tools_ = false;
}
inline bool StreamOptions::_internal_enable_tools() const {
  return _impl_.enable_tools_;
}
inline bool StreamOptions::enable_tools() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.StreamOptions.enable_tools)
  return _internal_enable_tools();
}
inline void StreamOptions::_internal_set_enable_tools(bool value) {
  
  _impl_.enable_tools_ = value;
}
inline void StreamOptions::set_enable_tools(bool value) {
  _internal_set_enable_tools(value);
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.StreamOptions.enable_tools)
}

// -------------------------------------------------------------------

// ChatChunkPayload

// string message_id = 1;
inline void ChatChunkPayload::clear_message_id() {
  _impl_.message_id_.ClearToEmpty();
}
inline const std::string& ChatChunkPayload::message_id() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.ChatChunkPayload.message_id)
  return _internal_message_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatChunkPayload::set_message_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.ChatChunkPayload.message_id)
}
inline std::string* ChatChunkPayload::mutable_message_id() {
  std::string* _s = _internal_mutable_message_id();
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.ChatChunkPayload.message_id)
  return _s;
}
inline const std::string& ChatChunkPayload::_internal_message_id() const {
  return _impl_.message_id_.Get();
}
inline void ChatChunkPayload::_internal_set_message_id(const std::string& value) {
  
  _impl_.message_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatChunkPayload::_internal_mutable_message_id() {
  
  return _impl_.message_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatChunkPayload::release_message_id() {
  // @@protoc_insertion_point(field_release:unhinged.chat.v1.ChatChunkPayload.message_id)
  return _impl_.message_id_.Release();
}
inline void ChatChunkPayload::set_allocated_message_id(std::string* message_id) {
  if (message_id != nullptr) {
    
  } else {
    
  }
  _impl_.message_id_.SetAllocated(message_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_id_.IsDefault()) {
    _impl_.message_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.chat.v1.ChatChunkPayload.message_id)
}

// string conversation_id = 2;
inline void ChatChunkPayload::clear_conversation_id() {
  _impl_.conversation_id_.ClearToEmpty();
}
inline const std::string& ChatChunkPayload::conversation_id() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.ChatChunkPayload.conversation_id)
  return _internal_conversation_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatChunkPayload::set_conversation_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.conversation_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.ChatChunkPayload.conversation_id)
}
inline std::string* ChatChunkPayload::mutable_conversation_id() {
  std::string* _s = _internal_mutable_conversation_id();
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.ChatChunkPayload.conversation_id)
  return _s;
}
inline const std::string& ChatChunkPayload::_internal_conversation_id() const {
  return _impl_.conversation_id_.Get();
}
inline void ChatChunkPayload::_internal_set_conversation_id(const std::string& value) {
  
  _impl_.conversation_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatChunkPayload::_internal_mutable_conversation_id() {
  
  return _impl_.conversation_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatChunkPayload::release_conversation_id() {
  // @@protoc_insertion_point(field_release:unhinged.chat.v1.ChatChunkPayload.conversation_id)
  return _impl_.conversation_id_.Release();
}
inline void ChatChunkPayload::set_allocated_conversation_id(std::string* conversation_id) {
  if (conversation_id != nullptr) {
    
  } else {
    
  }
  _impl_.conversation_id_.SetAllocated(conversation_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.conversation_id_.IsDefault()) {
    _impl_.conversation_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.chat.v1.ChatChunkPayload.conversation_id)
}

// .unhinged.chat.v1.MessageRole role = 3;
inline void ChatChunkPayload::clear_role() {
  _impl_.role_ = 0;
}
inline ::unhinged::chat::v1::MessageRole ChatChunkPayload::_internal_role() const {
  return static_cast< ::unhinged::chat::v1::MessageRole >(_impl_.role_);
}
inline ::unhinged::chat::v1::MessageRole ChatChunkPayload::role() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.ChatChunkPayload.role)
  return _internal_role();
}
inline void ChatChunkPayload::_internal_set_role(::unhinged::chat::v1::MessageRole value) {
  
  _impl_.role_ = value;
}
inline void ChatChunkPayload::set_role(::unhinged::chat::v1::MessageRole value) {
  _internal_set_role(value);
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.ChatChunkPayload.role)
}

// string content = 4;
inline void ChatChunkPayload::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& ChatChunkPayload::content() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.ChatChunkPayload.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatChunkPayload::set_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.ChatChunkPayload.content)
}
inline std::string* ChatChunkPayload::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.ChatChunkPayload.content)
  return _s;
}
inline const std::string& ChatChunkPayload::_internal_content() const {
  return _impl_.content_.Get();
}
inline void ChatChunkPayload::_internal_set_content(const std::string& value) {
  
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatChunkPayload::_internal_mutable_content() {
  
  return _impl_.content_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatChunkPayload::release_content() {
  // @@protoc_insertion_point(field_release:unhinged.chat.v1.ChatChunkPayload.content)
  return _impl_.content_.Release();
}
inline void ChatChunkPayload::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.chat.v1.ChatChunkPayload.content)
}

// repeated .unhinged.chat.v1.ToolCall tool_calls = 5;
inline int ChatChunkPayload::_internal_tool_calls_size() const {
  return _impl_.tool_calls_.size();
}
inline int ChatChunkPayload::tool_calls_size() const {
  return _internal_tool_calls_size();
}
inline void ChatChunkPayload::clear_tool_calls() {
  _impl_.tool_calls_.Clear();
}
inline ::unhinged::chat::v1::ToolCall* ChatChunkPayload::mutable_tool_calls(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.ChatChunkPayload.tool_calls)
  return _impl_.tool_calls_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::chat::v1::ToolCall >*
ChatChunkPayload::mutable_tool_calls() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.chat.v1.ChatChunkPayload.tool_calls)
  return &_impl_.tool_calls_;
}
inline const ::unhinged::chat::v1::ToolCall& ChatChunkPayload::_internal_tool_calls(int index) const {
  return _impl_.tool_calls_.Get(index);
}
inline const ::unhinged::chat::v1::ToolCall& ChatChunkPayload::tool_calls(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.ChatChunkPayload.tool_calls)
  return _internal_tool_calls(index);
}
inline ::unhinged::chat::v1::ToolCall* ChatChunkPayload::_internal_add_tool_calls() {
  return _impl_.tool_calls_.Add();
}
inline ::unhinged::chat::v1::ToolCall* ChatChunkPayload::add_tool_calls() {
  ::unhinged::chat::v1::ToolCall* _add = _internal_add_tool_calls();
  // @@protoc_insertion_point(field_add:unhinged.chat.v1.ChatChunkPayload.tool_calls)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::chat::v1::ToolCall >&
ChatChunkPayload::tool_calls() const {
  // @@protoc_insertion_point(field_list:unhinged.chat.v1.ChatChunkPayload.tool_calls)
  return _impl_.tool_calls_;
}

// -------------------------------------------------------------------

// SubscribeRequest

// string conversation_id = 1;
inline void SubscribeRequest::clear_conversation_id() {
  _impl_.conversation_id_.ClearToEmpty();
}
inline const std::string& SubscribeRequest::conversation_id() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.SubscribeRequest.conversation_id)
  return _internal_conversation_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubscribeRequest::set_conversation_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.conversation_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.SubscribeRequest.conversation_id)
}
inline std::string* SubscribeRequest::mutable_conversation_id() {
  std::string* _s = _internal_mutable_conversation_id();
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.SubscribeRequest.conversation_id)
  return _s;
}
inline const std::string& SubscribeRequest::_internal_conversation_id() const {
  return _impl_.conversation_id_.Get();
}
inline void SubscribeRequest::_internal_set_conversation_id(const std::string& value) {
  
  _impl_.conversation_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SubscribeRequest::_internal_mutable_conversation_id() {
  
  return _impl_.conversation_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SubscribeRequest::release_conversation_id() {
  // @@protoc_insertion_point(field_release:unhinged.chat.v1.SubscribeRequest.conversation_id)
  return _impl_.conversation_id_.Release();
}
inline void SubscribeRequest::set_allocated_conversation_id(std::string* conversation_id) {
  if (conversation_id != nullptr) {
    
  } else {
    
  }
  _impl_.conversation_id_.SetAllocated(conversation_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.conversation_id_.IsDefault()) {
    _impl_.conversation_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.chat.v1.SubscribeRequest.conversation_id)
}

// repeated .unhinged.chat.v1.UpdateType event_types = 2;
inline int SubscribeRequest::_internal_event_types_size() const {
  return _impl_.event_types_.size();
}
inline int SubscribeRequest::event_types_size() const {
  return _internal_event_types_size();
}
inline void SubscribeRequest::clear_event_types() {
  _impl_.event_types_.Clear();
}
inline ::unhinged::chat::v1::UpdateType SubscribeRequest::_internal_event_types(int index) const {
  return static_cast< ::unhinged::chat::v1::UpdateType >(_impl_.event_types_.Get(index));
}
inline ::unhinged::chat::v1::UpdateType SubscribeRequest::event_types(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.SubscribeRequest.event_types)
  return _internal_event_types(index);
}
inline void SubscribeRequest::set_event_types(int index, ::unhinged::chat::v1::UpdateType value) {
  _impl_.event_types_.Set(index, value);
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.SubscribeRequest.event_types)
}
inline void SubscribeRequest::_internal_add_event_types(::unhinged::chat::v1::UpdateType value) {
  _impl_.event_types_.Add(value);
}
inline void SubscribeRequest::add_event_types(::unhinged::chat::v1::UpdateType value) {
  _internal_add_event_types(value);
  // @@protoc_insertion_point(field_add:unhinged.chat.v1.SubscribeRequest.event_types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
SubscribeRequest::event_types() const {
  // @@protoc_insertion_point(field_list:unhinged.chat.v1.SubscribeRequest.event_types)
  return _impl_.event_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
SubscribeRequest::_internal_mutable_event_types() {
  return &_impl_.event_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
SubscribeRequest::mutable_event_types() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.chat.v1.SubscribeRequest.event_types)
  return _internal_mutable_event_types();
}

// -------------------------------------------------------------------

// GetMessagesRequest

// string conversation_id = 1;
inline void GetMessagesRequest::clear_conversation_id() {
  _impl_.conversation_id_.ClearToEmpty();
}
inline const std::string& GetMessagesRequest::conversation_id() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.GetMessagesRequest.conversation_id)
  return _internal_conversation_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetMessagesRequest::set_conversation_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.conversation_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.GetMessagesRequest.conversation_id)
}
inline std::string* GetMessagesRequest::mutable_conversation_id() {
  std::string* _s = _internal_mutable_conversation_id();
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.GetMessagesRequest.conversation_id)
  return _s;
}
inline const std::string& GetMessagesRequest::_internal_conversation_id() const {
  return _impl_.conversation_id_.Get();
}
inline void GetMessagesRequest::_internal_set_conversation_id(const std::string& value) {
  
  _impl_.conversation_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetMessagesRequest::_internal_mutable_conversation_id() {
  
  return _impl_.conversation_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetMessagesRequest::release_conversation_id() {
  // @@protoc_insertion_point(field_release:unhinged.chat.v1.GetMessagesRequest.conversation_id)
  return _impl_.conversation_id_.Release();
}
inline void GetMessagesRequest::set_allocated_conversation_id(std::string* conversation_id) {
  if (conversation_id != nullptr) {
    
  } else {
    
  }
  _impl_.conversation_id_.SetAllocated(conversation_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.conversation_id_.IsDefault()) {
    _impl_.conversation_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.chat.v1.GetMessagesRequest.conversation_id)
}

// .unhinged.common.v1.PaginationRequest pagination = 2;
inline bool GetMessagesRequest::_internal_has_pagination() const {
  return this != internal_default_instance() && _impl_.pagination_ != nullptr;
}
inline bool GetMessagesRequest::has_pagination() const {
  return _internal_has_pagination();
}
inline const ::unhinged::common::v1::PaginationRequest& GetMessagesRequest::_internal_pagination() const {
  const ::unhinged::common::v1::PaginationRequest* p = _impl_.pagination_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::common::v1::PaginationRequest&>(
      ::unhinged::common::v1::_PaginationRequest_default_instance_);
}
inline const ::unhinged::common::v1::PaginationRequest& GetMessagesRequest::pagination() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.GetMessagesRequest.pagination)
  return _internal_pagination();
}
inline void GetMessagesRequest::unsafe_arena_set_allocated_pagination(
    ::unhinged::common::v1::PaginationRequest* pagination) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pagination_);
  }
  _impl_.pagination_ = pagination;
  if (pagination) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.chat.v1.GetMessagesRequest.pagination)
}
inline ::unhinged::common::v1::PaginationRequest* GetMessagesRequest::release_pagination() {
  
  ::unhinged::common::v1::PaginationRequest* temp = _impl_.pagination_;
  _impl_.pagination_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::common::v1::PaginationRequest* GetMessagesRequest::unsafe_arena_release_pagination() {
  // @@protoc_insertion_point(field_release:unhinged.chat.v1.GetMessagesRequest.pagination)
  
  ::unhinged::common::v1::PaginationRequest* temp = _impl_.pagination_;
  _impl_.pagination_ = nullptr;
  return temp;
}
inline ::unhinged::common::v1::PaginationRequest* GetMessagesRequest::_internal_mutable_pagination() {
  
  if (_impl_.pagination_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::common::v1::PaginationRequest>(GetArenaForAllocation());
    _impl_.pagination_ = p;
  }
  return _impl_.pagination_;
}
inline ::unhinged::common::v1::PaginationRequest* GetMessagesRequest::mutable_pagination() {
  ::unhinged::common::v1::PaginationRequest* _msg = _internal_mutable_pagination();
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.GetMessagesRequest.pagination)
  return _msg;
}
inline void GetMessagesRequest::set_allocated_pagination(::unhinged::common::v1::PaginationRequest* pagination) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pagination_);
  }
  if (pagination) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pagination));
    if (message_arena != submessage_arena) {
      pagination = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pagination, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pagination_ = pagination;
  // @@protoc_insertion_point(field_set_allocated:unhinged.chat.v1.GetMessagesRequest.pagination)
}

// .unhinged.chat.v1.MessageRole role_filter = 3;
inline void GetMessagesRequest::clear_role_filter() {
  _impl_.role_filter_ = 0;
}
inline ::unhinged::chat::v1::MessageRole GetMessagesRequest::_internal_role_filter() const {
  return static_cast< ::unhinged::chat::v1::MessageRole >(_impl_.role_filter_);
}
inline ::unhinged::chat::v1::MessageRole GetMessagesRequest::role_filter() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.GetMessagesRequest.role_filter)
  return _internal_role_filter();
}
inline void GetMessagesRequest::_internal_set_role_filter(::unhinged::chat::v1::MessageRole value) {
  
  _impl_.role_filter_ = value;
}
inline void GetMessagesRequest::set_role_filter(::unhinged::chat::v1::MessageRole value) {
  _internal_set_role_filter(value);
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.GetMessagesRequest.role_filter)
}

// repeated .unhinged.common.v1.Filter filters = 4;
inline int GetMessagesRequest::_internal_filters_size() const {
  return _impl_.filters_.size();
}
inline int GetMessagesRequest::filters_size() const {
  return _internal_filters_size();
}
inline ::unhinged::common::v1::Filter* GetMessagesRequest::mutable_filters(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.GetMessagesRequest.filters)
  return _impl_.filters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::common::v1::Filter >*
GetMessagesRequest::mutable_filters() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.chat.v1.GetMessagesRequest.filters)
  return &_impl_.filters_;
}
inline const ::unhinged::common::v1::Filter& GetMessagesRequest::_internal_filters(int index) const {
  return _impl_.filters_.Get(index);
}
inline const ::unhinged::common::v1::Filter& GetMessagesRequest::filters(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.GetMessagesRequest.filters)
  return _internal_filters(index);
}
inline ::unhinged::common::v1::Filter* GetMessagesRequest::_internal_add_filters() {
  return _impl_.filters_.Add();
}
inline ::unhinged::common::v1::Filter* GetMessagesRequest::add_filters() {
  ::unhinged::common::v1::Filter* _add = _internal_add_filters();
  // @@protoc_insertion_point(field_add:unhinged.chat.v1.GetMessagesRequest.filters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::common::v1::Filter >&
GetMessagesRequest::filters() const {
  // @@protoc_insertion_point(field_list:unhinged.chat.v1.GetMessagesRequest.filters)
  return _impl_.filters_;
}

// -------------------------------------------------------------------

// GetMessagesResponse

// .unhinged.common.v1.StandardResponse response = 1;
inline bool GetMessagesResponse::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool GetMessagesResponse::has_response() const {
  return _internal_has_response();
}
inline const ::unhinged::common::v1::StandardResponse& GetMessagesResponse::_internal_response() const {
  const ::unhinged::common::v1::StandardResponse* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::common::v1::StandardResponse&>(
      ::unhinged::common::v1::_StandardResponse_default_instance_);
}
inline const ::unhinged::common::v1::StandardResponse& GetMessagesResponse::response() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.GetMessagesResponse.response)
  return _internal_response();
}
inline void GetMessagesResponse::unsafe_arena_set_allocated_response(
    ::unhinged::common::v1::StandardResponse* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.chat.v1.GetMessagesResponse.response)
}
inline ::unhinged::common::v1::StandardResponse* GetMessagesResponse::release_response() {
  
  ::unhinged::common::v1::StandardResponse* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::common::v1::StandardResponse* GetMessagesResponse::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:unhinged.chat.v1.GetMessagesResponse.response)
  
  ::unhinged::common::v1::StandardResponse* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::unhinged::common::v1::StandardResponse* GetMessagesResponse::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::common::v1::StandardResponse>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::unhinged::common::v1::StandardResponse* GetMessagesResponse::mutable_response() {
  ::unhinged::common::v1::StandardResponse* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.GetMessagesResponse.response)
  return _msg;
}
inline void GetMessagesResponse::set_allocated_response(::unhinged::common::v1::StandardResponse* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:unhinged.chat.v1.GetMessagesResponse.response)
}

// repeated .unhinged.chat.v1.ChatMessage messages = 2;
inline int GetMessagesResponse::_internal_messages_size() const {
  return _impl_.messages_.size();
}
inline int GetMessagesResponse::messages_size() const {
  return _internal_messages_size();
}
inline void GetMessagesResponse::clear_messages() {
  _impl_.messages_.Clear();
}
inline ::unhinged::chat::v1::ChatMessage* GetMessagesResponse::mutable_messages(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.GetMessagesResponse.messages)
  return _impl_.messages_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::chat::v1::ChatMessage >*
GetMessagesResponse::mutable_messages() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.chat.v1.GetMessagesResponse.messages)
  return &_impl_.messages_;
}
inline const ::unhinged::chat::v1::ChatMessage& GetMessagesResponse::_internal_messages(int index) const {
  return _impl_.messages_.Get(index);
}
inline const ::unhinged::chat::v1::ChatMessage& GetMessagesResponse::messages(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.GetMessagesResponse.messages)
  return _internal_messages(index);
}
inline ::unhinged::chat::v1::ChatMessage* GetMessagesResponse::_internal_add_messages() {
  return _impl_.messages_.Add();
}
inline ::unhinged::chat::v1::ChatMessage* GetMessagesResponse::add_messages() {
  ::unhinged::chat::v1::ChatMessage* _add = _internal_add_messages();
  // @@protoc_insertion_point(field_add:unhinged.chat.v1.GetMessagesResponse.messages)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::chat::v1::ChatMessage >&
GetMessagesResponse::messages() const {
  // @@protoc_insertion_point(field_list:unhinged.chat.v1.GetMessagesResponse.messages)
  return _impl_.messages_;
}

// .unhinged.common.v1.PaginationResponse pagination = 3;
inline bool GetMessagesResponse::_internal_has_pagination() const {
  return this != internal_default_instance() && _impl_.pagination_ != nullptr;
}
inline bool GetMessagesResponse::has_pagination() const {
  return _internal_has_pagination();
}
inline const ::unhinged::common::v1::PaginationResponse& GetMessagesResponse::_internal_pagination() const {
  const ::unhinged::common::v1::PaginationResponse* p = _impl_.pagination_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::common::v1::PaginationResponse&>(
      ::unhinged::common::v1::_PaginationResponse_default_instance_);
}
inline const ::unhinged::common::v1::PaginationResponse& GetMessagesResponse::pagination() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.GetMessagesResponse.pagination)
  return _internal_pagination();
}
inline void GetMessagesResponse::unsafe_arena_set_allocated_pagination(
    ::unhinged::common::v1::PaginationResponse* pagination) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pagination_);
  }
  _impl_.pagination_ = pagination;
  if (pagination) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.chat.v1.GetMessagesResponse.pagination)
}
inline ::unhinged::common::v1::PaginationResponse* GetMessagesResponse::release_pagination() {
  
  ::unhinged::common::v1::PaginationResponse* temp = _impl_.pagination_;
  _impl_.pagination_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::common::v1::PaginationResponse* GetMessagesResponse::unsafe_arena_release_pagination() {
  // @@protoc_insertion_point(field_release:unhinged.chat.v1.GetMessagesResponse.pagination)
  
  ::unhinged::common::v1::PaginationResponse* temp = _impl_.pagination_;
  _impl_.pagination_ = nullptr;
  return temp;
}
inline ::unhinged::common::v1::PaginationResponse* GetMessagesResponse::_internal_mutable_pagination() {
  
  if (_impl_.pagination_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::common::v1::PaginationResponse>(GetArenaForAllocation());
    _impl_.pagination_ = p;
  }
  return _impl_.pagination_;
}
inline ::unhinged::common::v1::PaginationResponse* GetMessagesResponse::mutable_pagination() {
  ::unhinged::common::v1::PaginationResponse* _msg = _internal_mutable_pagination();
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.GetMessagesResponse.pagination)
  return _msg;
}
inline void GetMessagesResponse::set_allocated_pagination(::unhinged::common::v1::PaginationResponse* pagination) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pagination_);
  }
  if (pagination) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pagination));
    if (message_arena != submessage_arena) {
      pagination = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pagination, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pagination_ = pagination;
  // @@protoc_insertion_point(field_set_allocated:unhinged.chat.v1.GetMessagesResponse.pagination)
}

// -------------------------------------------------------------------

// UpdateConversationRequest

// string conversation_id = 1;
inline void UpdateConversationRequest::clear_conversation_id() {
  _impl_.conversation_id_.ClearToEmpty();
}
inline const std::string& UpdateConversationRequest::conversation_id() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.UpdateConversationRequest.conversation_id)
  return _internal_conversation_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateConversationRequest::set_conversation_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.conversation_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.UpdateConversationRequest.conversation_id)
}
inline std::string* UpdateConversationRequest::mutable_conversation_id() {
  std::string* _s = _internal_mutable_conversation_id();
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.UpdateConversationRequest.conversation_id)
  return _s;
}
inline const std::string& UpdateConversationRequest::_internal_conversation_id() const {
  return _impl_.conversation_id_.Get();
}
inline void UpdateConversationRequest::_internal_set_conversation_id(const std::string& value) {
  
  _impl_.conversation_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateConversationRequest::_internal_mutable_conversation_id() {
  
  return _impl_.conversation_id_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateConversationRequest::release_conversation_id() {
  // @@protoc_insertion_point(field_release:unhinged.chat.v1.UpdateConversationRequest.conversation_id)
  return _impl_.conversation_id_.Release();
}
inline void UpdateConversationRequest::set_allocated_conversation_id(std::string* conversation_id) {
  if (conversation_id != nullptr) {
    
  } else {
    
  }
  _impl_.conversation_id_.SetAllocated(conversation_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.conversation_id_.IsDefault()) {
    _impl_.conversation_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.chat.v1.UpdateConversationRequest.conversation_id)
}

// string title = 2;
inline void UpdateConversationRequest::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& UpdateConversationRequest::title() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.UpdateConversationRequest.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateConversationRequest::set_title(ArgT0&& arg0, ArgT... args) {
 
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.UpdateConversationRequest.title)
}
inline std::string* UpdateConversationRequest::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.UpdateConversationRequest.title)
  return _s;
}
inline const std::string& UpdateConversationRequest::_internal_title() const {
  return _impl_.title_.Get();
}
inline void UpdateConversationRequest::_internal_set_title(const std::string& value) {
  
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateConversationRequest::_internal_mutable_title() {
  
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateConversationRequest::release_title() {
  // @@protoc_insertion_point(field_release:unhinged.chat.v1.UpdateConversationRequest.title)
  return _impl_.title_.Release();
}
inline void UpdateConversationRequest::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.chat.v1.UpdateConversationRequest.title)
}

// string description = 3;
inline void UpdateConversationRequest::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& UpdateConversationRequest::description() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.UpdateConversationRequest.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateConversationRequest::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.UpdateConversationRequest.description)
}
inline std::string* UpdateConversationRequest::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.UpdateConversationRequest.description)
  return _s;
}
inline const std::string& UpdateConversationRequest::_internal_description() const {
  return _impl_.description_.Get();
}
inline void UpdateConversationRequest::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateConversationRequest::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateConversationRequest::release_description() {
  // @@protoc_insertion_point(field_release:unhinged.chat.v1.UpdateConversationRequest.description)
  return _impl_.description_.Release();
}
inline void UpdateConversationRequest::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.chat.v1.UpdateConversationRequest.description)
}

// .unhinged.chat.v1.ConversationSettings settings = 4;
inline bool UpdateConversationRequest::_internal_has_settings() const {
  return this != internal_default_instance() && _impl_.settings_ != nullptr;
}
inline bool UpdateConversationRequest::has_settings() const {
  return _internal_has_settings();
}
inline void UpdateConversationRequest::clear_settings() {
  if (GetArenaForAllocation() == nullptr && _impl_.settings_ != nullptr) {
    delete _impl_.settings_;
  }
  _impl_.settings_ = nullptr;
}
inline const ::unhinged::chat::v1::ConversationSettings& UpdateConversationRequest::_internal_settings() const {
  const ::unhinged::chat::v1::ConversationSettings* p = _impl_.settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::chat::v1::ConversationSettings&>(
      ::unhinged::chat::v1::_ConversationSettings_default_instance_);
}
inline const ::unhinged::chat::v1::ConversationSettings& UpdateConversationRequest::settings() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.UpdateConversationRequest.settings)
  return _internal_settings();
}
inline void UpdateConversationRequest::unsafe_arena_set_allocated_settings(
    ::unhinged::chat::v1::ConversationSettings* settings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.settings_);
  }
  _impl_.settings_ = settings;
  if (settings) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.chat.v1.UpdateConversationRequest.settings)
}
inline ::unhinged::chat::v1::ConversationSettings* UpdateConversationRequest::release_settings() {
  
  ::unhinged::chat::v1::ConversationSettings* temp = _impl_.settings_;
  _impl_.settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::chat::v1::ConversationSettings* UpdateConversationRequest::unsafe_arena_release_settings() {
  // @@protoc_insertion_point(field_release:unhinged.chat.v1.UpdateConversationRequest.settings)
  
  ::unhinged::chat::v1::ConversationSettings* temp = _impl_.settings_;
  _impl_.settings_ = nullptr;
  return temp;
}
inline ::unhinged::chat::v1::ConversationSettings* UpdateConversationRequest::_internal_mutable_settings() {
  
  if (_impl_.settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::chat::v1::ConversationSettings>(GetArenaForAllocation());
    _impl_.settings_ = p;
  }
  return _impl_.settings_;
}
inline ::unhinged::chat::v1::ConversationSettings* UpdateConversationRequest::mutable_settings() {
  ::unhinged::chat::v1::ConversationSettings* _msg = _internal_mutable_settings();
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.UpdateConversationRequest.settings)
  return _msg;
}
inline void UpdateConversationRequest::set_allocated_settings(::unhinged::chat::v1::ConversationSettings* settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.settings_;
  }
  if (settings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(settings);
    if (message_arena != submessage_arena) {
      settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, settings, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.settings_ = settings;
  // @@protoc_insertion_point(field_set_allocated:unhinged.chat.v1.UpdateConversationRequest.settings)
}

// -------------------------------------------------------------------

// UpdateConversationResponse

// .unhinged.common.v1.StandardResponse response = 1;
inline bool UpdateConversationResponse::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool UpdateConversationResponse::has_response() const {
  return _internal_has_response();
}
inline const ::unhinged::common::v1::StandardResponse& UpdateConversationResponse::_internal_response() const {
  const ::unhinged::common::v1::StandardResponse* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::common::v1::StandardResponse&>(
      ::unhinged::common::v1::_StandardResponse_default_instance_);
}
inline const ::unhinged::common::v1::StandardResponse& UpdateConversationResponse::response() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.UpdateConversationResponse.response)
  return _internal_response();
}
inline void UpdateConversationResponse::unsafe_arena_set_allocated_response(
    ::unhinged::common::v1::StandardResponse* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.chat.v1.UpdateConversationResponse.response)
}
inline ::unhinged::common::v1::StandardResponse* UpdateConversationResponse::release_response() {
  
  ::unhinged::common::v1::StandardResponse* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::common::v1::StandardResponse* UpdateConversationResponse::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:unhinged.chat.v1.UpdateConversationResponse.response)
  
  ::unhinged::common::v1::StandardResponse* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::unhinged::common::v1::StandardResponse* UpdateConversationResponse::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::common::v1::StandardResponse>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::unhinged::common::v1::StandardResponse* UpdateConversationResponse::mutable_response() {
  ::unhinged::common::v1::StandardResponse* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.UpdateConversationResponse.response)
  return _msg;
}
inline void UpdateConversationResponse::set_allocated_response(::unhinged::common::v1::StandardResponse* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:unhinged.chat.v1.UpdateConversationResponse.response)
}

// .unhinged.chat.v1.Conversation conversation = 2;
inline bool UpdateConversationResponse::_internal_has_conversation() const {
  return this != internal_default_instance() && _impl_.conversation_ != nullptr;
}
inline bool UpdateConversationResponse::has_conversation() const {
  return _internal_has_conversation();
}
inline void UpdateConversationResponse::clear_conversation() {
  if (GetArenaForAllocation() == nullptr && _impl_.conversation_ != nullptr) {
    delete _impl_.conversation_;
  }
  _impl_.conversation_ = nullptr;
}
inline const ::unhinged::chat::v1::Conversation& UpdateConversationResponse::_internal_conversation() const {
  const ::unhinged::chat::v1::Conversation* p = _impl_.conversation_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::chat::v1::Conversation&>(
      ::unhinged::chat::v1::_Conversation_default_instance_);
}
inline const ::unhinged::chat::v1::Conversation& UpdateConversationResponse::conversation() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.UpdateConversationResponse.conversation)
  return _internal_conversation();
}
inline void UpdateConversationResponse::unsafe_arena_set_allocated_conversation(
    ::unhinged::chat::v1::Conversation* conversation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.conversation_);
  }
  _impl_.conversation_ = conversation;
  if (conversation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.chat.v1.UpdateConversationResponse.conversation)
}
inline ::unhinged::chat::v1::Conversation* UpdateConversationResponse::release_conversation() {
  
  ::unhinged::chat::v1::Conversation* temp = _impl_.conversation_;
  _impl_.conversation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::chat::v1::Conversation* UpdateConversationResponse::unsafe_arena_release_conversation() {
  // @@protoc_insertion_point(field_release:unhinged.chat.v1.UpdateConversationResponse.conversation)
  
  ::unhinged::chat::v1::Conversation* temp = _impl_.conversation_;
  _impl_.conversation_ = nullptr;
  return temp;
}
inline ::unhinged::chat::v1::Conversation* UpdateConversationResponse::_internal_mutable_conversation() {
  
  if (_impl_.conversation_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::chat::v1::Conversation>(GetArenaForAllocation());
    _impl_.conversation_ = p;
  }
  return _impl_.conversation_;
}
inline ::unhinged::chat::v1::Conversation* UpdateConversationResponse::mutable_conversation() {
  ::unhinged::chat::v1::Conversation* _msg = _internal_mutable_conversation();
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.UpdateConversationResponse.conversation)
  return _msg;
}
inline void UpdateConversationResponse::set_allocated_conversation(::unhinged::chat::v1::Conversation* conversation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.conversation_;
  }
  if (conversation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(conversation);
    if (message_arena != submessage_arena) {
      conversation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, conversation, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.conversation_ = conversation;
  // @@protoc_insertion_point(field_set_allocated:unhinged.chat.v1.UpdateConversationResponse.conversation)
}

// -------------------------------------------------------------------

// UpdateMessageRequest

// string message_id = 1;
inline void UpdateMessageRequest::clear_message_id() {
  _impl_.message_id_.ClearToEmpty();
}
inline const std::string& UpdateMessageRequest::message_id() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.UpdateMessageRequest.message_id)
  return _internal_message_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateMessageRequest::set_message_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.UpdateMessageRequest.message_id)
}
inline std::string* UpdateMessageRequest::mutable_message_id() {
  std::string* _s = _internal_mutable_message_id();
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.UpdateMessageRequest.message_id)
  return _s;
}
inline const std::string& UpdateMessageRequest::_internal_message_id() const {
  return _impl_.message_id_.Get();
}
inline void UpdateMessageRequest::_internal_set_message_id(const std::string& value) {
  
  _impl_.message_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateMessageRequest::_internal_mutable_message_id() {
  
  return _impl_.message_id_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateMessageRequest::release_message_id() {
  // @@protoc_insertion_point(field_release:unhinged.chat.v1.UpdateMessageRequest.message_id)
  return _impl_.message_id_.Release();
}
inline void UpdateMessageRequest::set_allocated_message_id(std::string* message_id) {
  if (message_id != nullptr) {
    
  } else {
    
  }
  _impl_.message_id_.SetAllocated(message_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_id_.IsDefault()) {
    _impl_.message_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.chat.v1.UpdateMessageRequest.message_id)
}

// string content = 2;
inline void UpdateMessageRequest::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& UpdateMessageRequest::content() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.UpdateMessageRequest.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateMessageRequest::set_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.UpdateMessageRequest.content)
}
inline std::string* UpdateMessageRequest::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.UpdateMessageRequest.content)
  return _s;
}
inline const std::string& UpdateMessageRequest::_internal_content() const {
  return _impl_.content_.Get();
}
inline void UpdateMessageRequest::_internal_set_content(const std::string& value) {
  
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateMessageRequest::_internal_mutable_content() {
  
  return _impl_.content_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateMessageRequest::release_content() {
  // @@protoc_insertion_point(field_release:unhinged.chat.v1.UpdateMessageRequest.content)
  return _impl_.content_.Release();
}
inline void UpdateMessageRequest::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.chat.v1.UpdateMessageRequest.content)
}

// -------------------------------------------------------------------

// UpdateMessageResponse

// .unhinged.common.v1.StandardResponse response = 1;
inline bool UpdateMessageResponse::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool UpdateMessageResponse::has_response() const {
  return _internal_has_response();
}
inline const ::unhinged::common::v1::StandardResponse& UpdateMessageResponse::_internal_response() const {
  const ::unhinged::common::v1::StandardResponse* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::common::v1::StandardResponse&>(
      ::unhinged::common::v1::_StandardResponse_default_instance_);
}
inline const ::unhinged::common::v1::StandardResponse& UpdateMessageResponse::response() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.UpdateMessageResponse.response)
  return _internal_response();
}
inline void UpdateMessageResponse::unsafe_arena_set_allocated_response(
    ::unhinged::common::v1::StandardResponse* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.chat.v1.UpdateMessageResponse.response)
}
inline ::unhinged::common::v1::StandardResponse* UpdateMessageResponse::release_response() {
  
  ::unhinged::common::v1::StandardResponse* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::common::v1::StandardResponse* UpdateMessageResponse::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:unhinged.chat.v1.UpdateMessageResponse.response)
  
  ::unhinged::common::v1::StandardResponse* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::unhinged::common::v1::StandardResponse* UpdateMessageResponse::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::common::v1::StandardResponse>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::unhinged::common::v1::StandardResponse* UpdateMessageResponse::mutable_response() {
  ::unhinged::common::v1::StandardResponse* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.UpdateMessageResponse.response)
  return _msg;
}
inline void UpdateMessageResponse::set_allocated_response(::unhinged::common::v1::StandardResponse* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:unhinged.chat.v1.UpdateMessageResponse.response)
}

// .unhinged.chat.v1.ChatMessage message = 2;
inline bool UpdateMessageResponse::_internal_has_message() const {
  return this != internal_default_instance() && _impl_.message_ != nullptr;
}
inline bool UpdateMessageResponse::has_message() const {
  return _internal_has_message();
}
inline void UpdateMessageResponse::clear_message() {
  if (GetArenaForAllocation() == nullptr && _impl_.message_ != nullptr) {
    delete _impl_.message_;
  }
  _impl_.message_ = nullptr;
}
inline const ::unhinged::chat::v1::ChatMessage& UpdateMessageResponse::_internal_message() const {
  const ::unhinged::chat::v1::ChatMessage* p = _impl_.message_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::chat::v1::ChatMessage&>(
      ::unhinged::chat::v1::_ChatMessage_default_instance_);
}
inline const ::unhinged::chat::v1::ChatMessage& UpdateMessageResponse::message() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.UpdateMessageResponse.message)
  return _internal_message();
}
inline void UpdateMessageResponse::unsafe_arena_set_allocated_message(
    ::unhinged::chat::v1::ChatMessage* message) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.message_);
  }
  _impl_.message_ = message;
  if (message) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.chat.v1.UpdateMessageResponse.message)
}
inline ::unhinged::chat::v1::ChatMessage* UpdateMessageResponse::release_message() {
  
  ::unhinged::chat::v1::ChatMessage* temp = _impl_.message_;
  _impl_.message_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::chat::v1::ChatMessage* UpdateMessageResponse::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_release:unhinged.chat.v1.UpdateMessageResponse.message)
  
  ::unhinged::chat::v1::ChatMessage* temp = _impl_.message_;
  _impl_.message_ = nullptr;
  return temp;
}
inline ::unhinged::chat::v1::ChatMessage* UpdateMessageResponse::_internal_mutable_message() {
  
  if (_impl_.message_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::chat::v1::ChatMessage>(GetArenaForAllocation());
    _impl_.message_ = p;
  }
  return _impl_.message_;
}
inline ::unhinged::chat::v1::ChatMessage* UpdateMessageResponse::mutable_message() {
  ::unhinged::chat::v1::ChatMessage* _msg = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.UpdateMessageResponse.message)
  return _msg;
}
inline void UpdateMessageResponse::set_allocated_message(::unhinged::chat::v1::ChatMessage* message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.message_;
  }
  if (message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(message);
    if (message_arena != submessage_arena) {
      message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, message, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.message_ = message;
  // @@protoc_insertion_point(field_set_allocated:unhinged.chat.v1.UpdateMessageResponse.message)
}

// -------------------------------------------------------------------

// DeleteConversationRequest

// string conversation_id = 1;
inline void DeleteConversationRequest::clear_conversation_id() {
  _impl_.conversation_id_.ClearToEmpty();
}
inline const std::string& DeleteConversationRequest::conversation_id() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.DeleteConversationRequest.conversation_id)
  return _internal_conversation_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteConversationRequest::set_conversation_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.conversation_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.DeleteConversationRequest.conversation_id)
}
inline std::string* DeleteConversationRequest::mutable_conversation_id() {
  std::string* _s = _internal_mutable_conversation_id();
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.DeleteConversationRequest.conversation_id)
  return _s;
}
inline const std::string& DeleteConversationRequest::_internal_conversation_id() const {
  return _impl_.conversation_id_.Get();
}
inline void DeleteConversationRequest::_internal_set_conversation_id(const std::string& value) {
  
  _impl_.conversation_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteConversationRequest::_internal_mutable_conversation_id() {
  
  return _impl_.conversation_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteConversationRequest::release_conversation_id() {
  // @@protoc_insertion_point(field_release:unhinged.chat.v1.DeleteConversationRequest.conversation_id)
  return _impl_.conversation_id_.Release();
}
inline void DeleteConversationRequest::set_allocated_conversation_id(std::string* conversation_id) {
  if (conversation_id != nullptr) {
    
  } else {
    
  }
  _impl_.conversation_id_.SetAllocated(conversation_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.conversation_id_.IsDefault()) {
    _impl_.conversation_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.chat.v1.DeleteConversationRequest.conversation_id)
}

// bool hard_delete = 2;
inline void DeleteConversationRequest::clear_hard_delete() {
  _impl_.hard_delete_ = false;
}
inline bool DeleteConversationRequest::_internal_hard_delete() const {
  return _impl_.hard_delete_;
}
inline bool DeleteConversationRequest::hard_delete() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.DeleteConversationRequest.hard_delete)
  return _internal_hard_delete();
}
inline void DeleteConversationRequest::_internal_set_hard_delete(bool value) {
  
  _impl_.hard_delete_ = value;
}
inline void DeleteConversationRequest::set_hard_delete(bool value) {
  _internal_set_hard_delete(value);
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.DeleteConversationRequest.hard_delete)
}

// -------------------------------------------------------------------

// DeleteConversationResponse

// .unhinged.common.v1.StandardResponse response = 1;
inline bool DeleteConversationResponse::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool DeleteConversationResponse::has_response() const {
  return _internal_has_response();
}
inline const ::unhinged::common::v1::StandardResponse& DeleteConversationResponse::_internal_response() const {
  const ::unhinged::common::v1::StandardResponse* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::common::v1::StandardResponse&>(
      ::unhinged::common::v1::_StandardResponse_default_instance_);
}
inline const ::unhinged::common::v1::StandardResponse& DeleteConversationResponse::response() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.DeleteConversationResponse.response)
  return _internal_response();
}
inline void DeleteConversationResponse::unsafe_arena_set_allocated_response(
    ::unhinged::common::v1::StandardResponse* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.chat.v1.DeleteConversationResponse.response)
}
inline ::unhinged::common::v1::StandardResponse* DeleteConversationResponse::release_response() {
  
  ::unhinged::common::v1::StandardResponse* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::common::v1::StandardResponse* DeleteConversationResponse::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:unhinged.chat.v1.DeleteConversationResponse.response)
  
  ::unhinged::common::v1::StandardResponse* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::unhinged::common::v1::StandardResponse* DeleteConversationResponse::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::common::v1::StandardResponse>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::unhinged::common::v1::StandardResponse* DeleteConversationResponse::mutable_response() {
  ::unhinged::common::v1::StandardResponse* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.DeleteConversationResponse.response)
  return _msg;
}
inline void DeleteConversationResponse::set_allocated_response(::unhinged::common::v1::StandardResponse* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:unhinged.chat.v1.DeleteConversationResponse.response)
}

// -------------------------------------------------------------------

// DeleteMessageRequest

// string message_id = 1;
inline void DeleteMessageRequest::clear_message_id() {
  _impl_.message_id_.ClearToEmpty();
}
inline const std::string& DeleteMessageRequest::message_id() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.DeleteMessageRequest.message_id)
  return _internal_message_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteMessageRequest::set_message_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.DeleteMessageRequest.message_id)
}
inline std::string* DeleteMessageRequest::mutable_message_id() {
  std::string* _s = _internal_mutable_message_id();
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.DeleteMessageRequest.message_id)
  return _s;
}
inline const std::string& DeleteMessageRequest::_internal_message_id() const {
  return _impl_.message_id_.Get();
}
inline void DeleteMessageRequest::_internal_set_message_id(const std::string& value) {
  
  _impl_.message_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteMessageRequest::_internal_mutable_message_id() {
  
  return _impl_.message_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteMessageRequest::release_message_id() {
  // @@protoc_insertion_point(field_release:unhinged.chat.v1.DeleteMessageRequest.message_id)
  return _impl_.message_id_.Release();
}
inline void DeleteMessageRequest::set_allocated_message_id(std::string* message_id) {
  if (message_id != nullptr) {
    
  } else {
    
  }
  _impl_.message_id_.SetAllocated(message_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_id_.IsDefault()) {
    _impl_.message_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.chat.v1.DeleteMessageRequest.message_id)
}

// bool hard_delete = 2;
inline void DeleteMessageRequest::clear_hard_delete() {
  _impl_.hard_delete_ = false;
}
inline bool DeleteMessageRequest::_internal_hard_delete() const {
  return _impl_.hard_delete_;
}
inline bool DeleteMessageRequest::hard_delete() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.DeleteMessageRequest.hard_delete)
  return _internal_hard_delete();
}
inline void DeleteMessageRequest::_internal_set_hard_delete(bool value) {
  
  _impl_.hard_delete_ = value;
}
inline void DeleteMessageRequest::set_hard_delete(bool value) {
  _internal_set_hard_delete(value);
  // @@protoc_insertion_point(field_set:unhinged.chat.v1.DeleteMessageRequest.hard_delete)
}

// -------------------------------------------------------------------

// DeleteMessageResponse

// .unhinged.common.v1.StandardResponse response = 1;
inline bool DeleteMessageResponse::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool DeleteMessageResponse::has_response() const {
  return _internal_has_response();
}
inline const ::unhinged::common::v1::StandardResponse& DeleteMessageResponse::_internal_response() const {
  const ::unhinged::common::v1::StandardResponse* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::common::v1::StandardResponse&>(
      ::unhinged::common::v1::_StandardResponse_default_instance_);
}
inline const ::unhinged::common::v1::StandardResponse& DeleteMessageResponse::response() const {
  // @@protoc_insertion_point(field_get:unhinged.chat.v1.DeleteMessageResponse.response)
  return _internal_response();
}
inline void DeleteMessageResponse::unsafe_arena_set_allocated_response(
    ::unhinged::common::v1::StandardResponse* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.chat.v1.DeleteMessageResponse.response)
}
inline ::unhinged::common::v1::StandardResponse* DeleteMessageResponse::release_response() {
  
  ::unhinged::common::v1::StandardResponse* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::common::v1::StandardResponse* DeleteMessageResponse::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:unhinged.chat.v1.DeleteMessageResponse.response)
  
  ::unhinged::common::v1::StandardResponse* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::unhinged::common::v1::StandardResponse* DeleteMessageResponse::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::common::v1::StandardResponse>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::unhinged::common::v1::StandardResponse* DeleteMessageResponse::mutable_response() {
  ::unhinged::common::v1::StandardResponse* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:unhinged.chat.v1.DeleteMessageResponse.response)
  return _msg;
}
inline void DeleteMessageResponse::set_allocated_response(::unhinged::common::v1::StandardResponse* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:unhinged.chat.v1.DeleteMessageResponse.response)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace chat
}  // namespace unhinged

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::unhinged::chat::v1::ConversationStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::unhinged::chat::v1::ConversationStatus>() {
  return ::unhinged::chat::v1::ConversationStatus_descriptor();
}
template <> struct is_proto_enum< ::unhinged::chat::v1::MessageRole> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::unhinged::chat::v1::MessageRole>() {
  return ::unhinged::chat::v1::MessageRole_descriptor();
}
template <> struct is_proto_enum< ::unhinged::chat::v1::MessageStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::unhinged::chat::v1::MessageStatus>() {
  return ::unhinged::chat::v1::MessageStatus_descriptor();
}
template <> struct is_proto_enum< ::unhinged::chat::v1::ToolCallStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::unhinged::chat::v1::ToolCallStatus>() {
  return ::unhinged::chat::v1::ToolCallStatus_descriptor();
}
template <> struct is_proto_enum< ::unhinged::chat::v1::UpdateType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::unhinged::chat::v1::UpdateType>() {
  return ::unhinged::chat::v1::UpdateType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_chat_2eproto
