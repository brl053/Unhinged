// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messaging.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_messaging_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_messaging_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
#include <google/protobuf/struct.pb.h>
#include <google/protobuf/any.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_messaging_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_messaging_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_messaging_2eproto;
namespace unhinged {
namespace messaging {
class AcknowledgeMessageRequest;
struct AcknowledgeMessageRequestDefaultTypeInternal;
extern AcknowledgeMessageRequestDefaultTypeInternal _AcknowledgeMessageRequest_default_instance_;
class AcknowledgeMessageResponse;
struct AcknowledgeMessageResponseDefaultTypeInternal;
extern AcknowledgeMessageResponseDefaultTypeInternal _AcknowledgeMessageResponse_default_instance_;
class AgentCollaboration;
struct AgentCollaborationDefaultTypeInternal;
extern AgentCollaborationDefaultTypeInternal _AgentCollaboration_default_instance_;
class AgentError;
struct AgentErrorDefaultTypeInternal;
extern AgentErrorDefaultTypeInternal _AgentError_default_instance_;
class AgentMessage;
struct AgentMessageDefaultTypeInternal;
extern AgentMessageDefaultTypeInternal _AgentMessage_default_instance_;
class AgentStepUpdate;
struct AgentStepUpdateDefaultTypeInternal;
extern AgentStepUpdateDefaultTypeInternal _AgentStepUpdate_default_instance_;
class AgentTaskRequest;
struct AgentTaskRequestDefaultTypeInternal;
extern AgentTaskRequestDefaultTypeInternal _AgentTaskRequest_default_instance_;
class AgentTaskResponse;
struct AgentTaskResponseDefaultTypeInternal;
extern AgentTaskResponseDefaultTypeInternal _AgentTaskResponse_default_instance_;
class ConfigUpdate;
struct ConfigUpdateDefaultTypeInternal;
extern ConfigUpdateDefaultTypeInternal _ConfigUpdate_default_instance_;
class ContextDocument;
struct ContextDocumentDefaultTypeInternal;
extern ContextDocumentDefaultTypeInternal _ContextDocument_default_instance_;
class HealthCheck;
struct HealthCheckDefaultTypeInternal;
extern HealthCheckDefaultTypeInternal _HealthCheck_default_instance_;
class LLMCancel;
struct LLMCancelDefaultTypeInternal;
extern LLMCancelDefaultTypeInternal _LLMCancel_default_instance_;
class LLMError;
struct LLMErrorDefaultTypeInternal;
extern LLMErrorDefaultTypeInternal _LLMError_default_instance_;
class LLMMessage;
struct LLMMessageDefaultTypeInternal;
extern LLMMessageDefaultTypeInternal _LLMMessage_default_instance_;
class LLMPromptRequest;
struct LLMPromptRequestDefaultTypeInternal;
extern LLMPromptRequestDefaultTypeInternal _LLMPromptRequest_default_instance_;
class LLMPromptResponse;
struct LLMPromptResponseDefaultTypeInternal;
extern LLMPromptResponseDefaultTypeInternal _LLMPromptResponse_default_instance_;
class LLMStreamChunk;
struct LLMStreamChunkDefaultTypeInternal;
extern LLMStreamChunkDefaultTypeInternal _LLMStreamChunk_default_instance_;
class Message;
struct MessageDefaultTypeInternal;
extern MessageDefaultTypeInternal _Message_default_instance_;
class MessageFilter;
struct MessageFilterDefaultTypeInternal;
extern MessageFilterDefaultTypeInternal _MessageFilter_default_instance_;
class MessageOptions;
struct MessageOptionsDefaultTypeInternal;
extern MessageOptionsDefaultTypeInternal _MessageOptions_default_instance_;
class MessageStreamResponse;
struct MessageStreamResponseDefaultTypeInternal;
extern MessageStreamResponseDefaultTypeInternal _MessageStreamResponse_default_instance_;
class ReceiveMessagesRequest;
struct ReceiveMessagesRequestDefaultTypeInternal;
extern ReceiveMessagesRequestDefaultTypeInternal _ReceiveMessagesRequest_default_instance_;
class ReceiveMessagesResponse;
struct ReceiveMessagesResponseDefaultTypeInternal;
extern ReceiveMessagesResponseDefaultTypeInternal _ReceiveMessagesResponse_default_instance_;
class SendMessageRequest;
struct SendMessageRequestDefaultTypeInternal;
extern SendMessageRequestDefaultTypeInternal _SendMessageRequest_default_instance_;
class SendMessageResponse;
struct SendMessageResponseDefaultTypeInternal;
extern SendMessageResponseDefaultTypeInternal _SendMessageResponse_default_instance_;
class SendMessageResult;
struct SendMessageResultDefaultTypeInternal;
extern SendMessageResultDefaultTypeInternal _SendMessageResult_default_instance_;
class SendMessagesRequest;
struct SendMessagesRequestDefaultTypeInternal;
extern SendMessagesRequestDefaultTypeInternal _SendMessagesRequest_default_instance_;
class SendMessagesResponse;
struct SendMessagesResponseDefaultTypeInternal;
extern SendMessagesResponseDefaultTypeInternal _SendMessagesResponse_default_instance_;
class ServiceDiscovery;
struct ServiceDiscoveryDefaultTypeInternal;
extern ServiceDiscoveryDefaultTypeInternal _ServiceDiscovery_default_instance_;
class ShutdownNotice;
struct ShutdownNoticeDefaultTypeInternal;
extern ShutdownNoticeDefaultTypeInternal _ShutdownNotice_default_instance_;
class StreamError;
struct StreamErrorDefaultTypeInternal;
extern StreamErrorDefaultTypeInternal _StreamError_default_instance_;
class StreamStatus;
struct StreamStatusDefaultTypeInternal;
extern StreamStatusDefaultTypeInternal _StreamStatus_default_instance_;
class SubscribeToMessagesRequest;
struct SubscribeToMessagesRequestDefaultTypeInternal;
extern SubscribeToMessagesRequestDefaultTypeInternal _SubscribeToMessagesRequest_default_instance_;
class SystemMessage;
struct SystemMessageDefaultTypeInternal;
extern SystemMessageDefaultTypeInternal _SystemMessage_default_instance_;
class ToolCall;
struct ToolCallDefaultTypeInternal;
extern ToolCallDefaultTypeInternal _ToolCall_default_instance_;
class ToolError;
struct ToolErrorDefaultTypeInternal;
extern ToolErrorDefaultTypeInternal _ToolError_default_instance_;
class ToolInvocation;
struct ToolInvocationDefaultTypeInternal;
extern ToolInvocationDefaultTypeInternal _ToolInvocation_default_instance_;
class ToolMessage;
struct ToolMessageDefaultTypeInternal;
extern ToolMessageDefaultTypeInternal _ToolMessage_default_instance_;
class ToolRegistration;
struct ToolRegistrationDefaultTypeInternal;
extern ToolRegistrationDefaultTypeInternal _ToolRegistration_default_instance_;
class ToolResult;
struct ToolResultDefaultTypeInternal;
extern ToolResultDefaultTypeInternal _ToolResult_default_instance_;
class UICommand;
struct UICommandDefaultTypeInternal;
extern UICommandDefaultTypeInternal _UICommand_default_instance_;
class UIMessage;
struct UIMessageDefaultTypeInternal;
extern UIMessageDefaultTypeInternal _UIMessage_default_instance_;
class UINotification;
struct UINotificationDefaultTypeInternal;
extern UINotificationDefaultTypeInternal _UINotification_default_instance_;
class UIUpdate;
struct UIUpdateDefaultTypeInternal;
extern UIUpdateDefaultTypeInternal _UIUpdate_default_instance_;
class WorkflowCompletion;
struct WorkflowCompletionDefaultTypeInternal;
extern WorkflowCompletionDefaultTypeInternal _WorkflowCompletion_default_instance_;
class WorkflowControl;
struct WorkflowControlDefaultTypeInternal;
extern WorkflowControlDefaultTypeInternal _WorkflowControl_default_instance_;
class WorkflowMessage;
struct WorkflowMessageDefaultTypeInternal;
extern WorkflowMessageDefaultTypeInternal _WorkflowMessage_default_instance_;
class WorkflowStepExecution;
struct WorkflowStepExecutionDefaultTypeInternal;
extern WorkflowStepExecutionDefaultTypeInternal _WorkflowStepExecution_default_instance_;
class WorkflowTrigger;
struct WorkflowTriggerDefaultTypeInternal;
extern WorkflowTriggerDefaultTypeInternal _WorkflowTrigger_default_instance_;
}  // namespace messaging
}  // namespace unhinged
PROTOBUF_NAMESPACE_OPEN
template<> ::unhinged::messaging::AcknowledgeMessageRequest* Arena::CreateMaybeMessage<::unhinged::messaging::AcknowledgeMessageRequest>(Arena*);
template<> ::unhinged::messaging::AcknowledgeMessageResponse* Arena::CreateMaybeMessage<::unhinged::messaging::AcknowledgeMessageResponse>(Arena*);
template<> ::unhinged::messaging::AgentCollaboration* Arena::CreateMaybeMessage<::unhinged::messaging::AgentCollaboration>(Arena*);
template<> ::unhinged::messaging::AgentError* Arena::CreateMaybeMessage<::unhinged::messaging::AgentError>(Arena*);
template<> ::unhinged::messaging::AgentMessage* Arena::CreateMaybeMessage<::unhinged::messaging::AgentMessage>(Arena*);
template<> ::unhinged::messaging::AgentStepUpdate* Arena::CreateMaybeMessage<::unhinged::messaging::AgentStepUpdate>(Arena*);
template<> ::unhinged::messaging::AgentTaskRequest* Arena::CreateMaybeMessage<::unhinged::messaging::AgentTaskRequest>(Arena*);
template<> ::unhinged::messaging::AgentTaskResponse* Arena::CreateMaybeMessage<::unhinged::messaging::AgentTaskResponse>(Arena*);
template<> ::unhinged::messaging::ConfigUpdate* Arena::CreateMaybeMessage<::unhinged::messaging::ConfigUpdate>(Arena*);
template<> ::unhinged::messaging::ContextDocument* Arena::CreateMaybeMessage<::unhinged::messaging::ContextDocument>(Arena*);
template<> ::unhinged::messaging::HealthCheck* Arena::CreateMaybeMessage<::unhinged::messaging::HealthCheck>(Arena*);
template<> ::unhinged::messaging::LLMCancel* Arena::CreateMaybeMessage<::unhinged::messaging::LLMCancel>(Arena*);
template<> ::unhinged::messaging::LLMError* Arena::CreateMaybeMessage<::unhinged::messaging::LLMError>(Arena*);
template<> ::unhinged::messaging::LLMMessage* Arena::CreateMaybeMessage<::unhinged::messaging::LLMMessage>(Arena*);
template<> ::unhinged::messaging::LLMPromptRequest* Arena::CreateMaybeMessage<::unhinged::messaging::LLMPromptRequest>(Arena*);
template<> ::unhinged::messaging::LLMPromptResponse* Arena::CreateMaybeMessage<::unhinged::messaging::LLMPromptResponse>(Arena*);
template<> ::unhinged::messaging::LLMStreamChunk* Arena::CreateMaybeMessage<::unhinged::messaging::LLMStreamChunk>(Arena*);
template<> ::unhinged::messaging::Message* Arena::CreateMaybeMessage<::unhinged::messaging::Message>(Arena*);
template<> ::unhinged::messaging::MessageFilter* Arena::CreateMaybeMessage<::unhinged::messaging::MessageFilter>(Arena*);
template<> ::unhinged::messaging::MessageOptions* Arena::CreateMaybeMessage<::unhinged::messaging::MessageOptions>(Arena*);
template<> ::unhinged::messaging::MessageStreamResponse* Arena::CreateMaybeMessage<::unhinged::messaging::MessageStreamResponse>(Arena*);
template<> ::unhinged::messaging::ReceiveMessagesRequest* Arena::CreateMaybeMessage<::unhinged::messaging::ReceiveMessagesRequest>(Arena*);
template<> ::unhinged::messaging::ReceiveMessagesResponse* Arena::CreateMaybeMessage<::unhinged::messaging::ReceiveMessagesResponse>(Arena*);
template<> ::unhinged::messaging::SendMessageRequest* Arena::CreateMaybeMessage<::unhinged::messaging::SendMessageRequest>(Arena*);
template<> ::unhinged::messaging::SendMessageResponse* Arena::CreateMaybeMessage<::unhinged::messaging::SendMessageResponse>(Arena*);
template<> ::unhinged::messaging::SendMessageResult* Arena::CreateMaybeMessage<::unhinged::messaging::SendMessageResult>(Arena*);
template<> ::unhinged::messaging::SendMessagesRequest* Arena::CreateMaybeMessage<::unhinged::messaging::SendMessagesRequest>(Arena*);
template<> ::unhinged::messaging::SendMessagesResponse* Arena::CreateMaybeMessage<::unhinged::messaging::SendMessagesResponse>(Arena*);
template<> ::unhinged::messaging::ServiceDiscovery* Arena::CreateMaybeMessage<::unhinged::messaging::ServiceDiscovery>(Arena*);
template<> ::unhinged::messaging::ShutdownNotice* Arena::CreateMaybeMessage<::unhinged::messaging::ShutdownNotice>(Arena*);
template<> ::unhinged::messaging::StreamError* Arena::CreateMaybeMessage<::unhinged::messaging::StreamError>(Arena*);
template<> ::unhinged::messaging::StreamStatus* Arena::CreateMaybeMessage<::unhinged::messaging::StreamStatus>(Arena*);
template<> ::unhinged::messaging::SubscribeToMessagesRequest* Arena::CreateMaybeMessage<::unhinged::messaging::SubscribeToMessagesRequest>(Arena*);
template<> ::unhinged::messaging::SystemMessage* Arena::CreateMaybeMessage<::unhinged::messaging::SystemMessage>(Arena*);
template<> ::unhinged::messaging::ToolCall* Arena::CreateMaybeMessage<::unhinged::messaging::ToolCall>(Arena*);
template<> ::unhinged::messaging::ToolError* Arena::CreateMaybeMessage<::unhinged::messaging::ToolError>(Arena*);
template<> ::unhinged::messaging::ToolInvocation* Arena::CreateMaybeMessage<::unhinged::messaging::ToolInvocation>(Arena*);
template<> ::unhinged::messaging::ToolMessage* Arena::CreateMaybeMessage<::unhinged::messaging::ToolMessage>(Arena*);
template<> ::unhinged::messaging::ToolRegistration* Arena::CreateMaybeMessage<::unhinged::messaging::ToolRegistration>(Arena*);
template<> ::unhinged::messaging::ToolResult* Arena::CreateMaybeMessage<::unhinged::messaging::ToolResult>(Arena*);
template<> ::unhinged::messaging::UICommand* Arena::CreateMaybeMessage<::unhinged::messaging::UICommand>(Arena*);
template<> ::unhinged::messaging::UIMessage* Arena::CreateMaybeMessage<::unhinged::messaging::UIMessage>(Arena*);
template<> ::unhinged::messaging::UINotification* Arena::CreateMaybeMessage<::unhinged::messaging::UINotification>(Arena*);
template<> ::unhinged::messaging::UIUpdate* Arena::CreateMaybeMessage<::unhinged::messaging::UIUpdate>(Arena*);
template<> ::unhinged::messaging::WorkflowCompletion* Arena::CreateMaybeMessage<::unhinged::messaging::WorkflowCompletion>(Arena*);
template<> ::unhinged::messaging::WorkflowControl* Arena::CreateMaybeMessage<::unhinged::messaging::WorkflowControl>(Arena*);
template<> ::unhinged::messaging::WorkflowMessage* Arena::CreateMaybeMessage<::unhinged::messaging::WorkflowMessage>(Arena*);
template<> ::unhinged::messaging::WorkflowStepExecution* Arena::CreateMaybeMessage<::unhinged::messaging::WorkflowStepExecution>(Arena*);
template<> ::unhinged::messaging::WorkflowTrigger* Arena::CreateMaybeMessage<::unhinged::messaging::WorkflowTrigger>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace unhinged {
namespace messaging {

enum LLMMessageType : int {
  LLM_PROMPT_REQUEST = 0,
  LLM_PROMPT_RESPONSE = 1,
  LLM_STREAM_CHUNK = 2,
  LLM_ERROR = 3,
  LLM_CANCEL = 4,
  LLMMessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  LLMMessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool LLMMessageType_IsValid(int value);
constexpr LLMMessageType LLMMessageType_MIN = LLM_PROMPT_REQUEST;
constexpr LLMMessageType LLMMessageType_MAX = LLM_CANCEL;
constexpr int LLMMessageType_ARRAYSIZE = LLMMessageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LLMMessageType_descriptor();
template<typename T>
inline const std::string& LLMMessageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LLMMessageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LLMMessageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LLMMessageType_descriptor(), enum_t_value);
}
inline bool LLMMessageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LLMMessageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LLMMessageType>(
    LLMMessageType_descriptor(), name, value);
}
enum AgentMessageType : int {
  AGENT_TASK_REQUEST = 0,
  AGENT_TASK_RESPONSE = 1,
  AGENT_STEP_UPDATE = 2,
  AGENT_COLLABORATION = 3,
  AGENT_ERROR = 4,
  AgentMessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AgentMessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AgentMessageType_IsValid(int value);
constexpr AgentMessageType AgentMessageType_MIN = AGENT_TASK_REQUEST;
constexpr AgentMessageType AgentMessageType_MAX = AGENT_ERROR;
constexpr int AgentMessageType_ARRAYSIZE = AgentMessageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AgentMessageType_descriptor();
template<typename T>
inline const std::string& AgentMessageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AgentMessageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AgentMessageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AgentMessageType_descriptor(), enum_t_value);
}
inline bool AgentMessageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AgentMessageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AgentMessageType>(
    AgentMessageType_descriptor(), name, value);
}
enum ToolMessageType : int {
  TOOL_INVOCATION = 0,
  TOOL_RESULT = 1,
  TOOL_ERROR = 2,
  TOOL_REGISTRATION = 3,
  ToolMessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ToolMessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ToolMessageType_IsValid(int value);
constexpr ToolMessageType ToolMessageType_MIN = TOOL_INVOCATION;
constexpr ToolMessageType ToolMessageType_MAX = TOOL_REGISTRATION;
constexpr int ToolMessageType_ARRAYSIZE = ToolMessageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ToolMessageType_descriptor();
template<typename T>
inline const std::string& ToolMessageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ToolMessageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ToolMessageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ToolMessageType_descriptor(), enum_t_value);
}
inline bool ToolMessageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ToolMessageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ToolMessageType>(
    ToolMessageType_descriptor(), name, value);
}
enum WorkflowMessageType : int {
  WORKFLOW_TRIGGER = 0,
  WORKFLOW_STEP_EXECUTION = 1,
  WORKFLOW_COMPLETION = 2,
  WORKFLOW_CONTROL = 3,
  WorkflowMessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  WorkflowMessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool WorkflowMessageType_IsValid(int value);
constexpr WorkflowMessageType WorkflowMessageType_MIN = WORKFLOW_TRIGGER;
constexpr WorkflowMessageType WorkflowMessageType_MAX = WORKFLOW_CONTROL;
constexpr int WorkflowMessageType_ARRAYSIZE = WorkflowMessageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WorkflowMessageType_descriptor();
template<typename T>
inline const std::string& WorkflowMessageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WorkflowMessageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WorkflowMessageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WorkflowMessageType_descriptor(), enum_t_value);
}
inline bool WorkflowMessageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WorkflowMessageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WorkflowMessageType>(
    WorkflowMessageType_descriptor(), name, value);
}
enum UIMessageType : int {
  UI_UPDATE = 0,
  UI_NOTIFICATION = 1,
  UI_COMMAND = 2,
  UIMessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  UIMessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool UIMessageType_IsValid(int value);
constexpr UIMessageType UIMessageType_MIN = UI_UPDATE;
constexpr UIMessageType UIMessageType_MAX = UI_COMMAND;
constexpr int UIMessageType_ARRAYSIZE = UIMessageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UIMessageType_descriptor();
template<typename T>
inline const std::string& UIMessageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UIMessageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UIMessageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UIMessageType_descriptor(), enum_t_value);
}
inline bool UIMessageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UIMessageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UIMessageType>(
    UIMessageType_descriptor(), name, value);
}
enum SystemMessageType : int {
  SERVICE_DISCOVERY = 0,
  HEALTH_CHECK = 1,
  CONFIG_UPDATE = 2,
  SHUTDOWN_NOTICE = 3,
  SystemMessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SystemMessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SystemMessageType_IsValid(int value);
constexpr SystemMessageType SystemMessageType_MIN = SERVICE_DISCOVERY;
constexpr SystemMessageType SystemMessageType_MAX = SHUTDOWN_NOTICE;
constexpr int SystemMessageType_ARRAYSIZE = SystemMessageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SystemMessageType_descriptor();
template<typename T>
inline const std::string& SystemMessageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SystemMessageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SystemMessageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SystemMessageType_descriptor(), enum_t_value);
}
inline bool SystemMessageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SystemMessageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SystemMessageType>(
    SystemMessageType_descriptor(), name, value);
}
// ===================================================================

class Message final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.messaging.Message) */ {
 public:
  inline Message() : Message(nullptr) {}
  ~Message() override;
  explicit PROTOBUF_CONSTEXPR Message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Message(const Message& from);
  Message(Message&& from) noexcept
    : Message() {
    *this = ::std::move(from);
  }

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }
  inline Message& operator=(Message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Message& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadCase {
    kLlmMessage = 20,
    kAgentMessage = 21,
    kToolMessage = 22,
    kWorkflowMessage = 23,
    kUiMessage = 24,
    kSystemMessage = 25,
    PAYLOAD_NOT_SET = 0,
  };

  static inline const Message* internal_default_instance() {
    return reinterpret_cast<const Message*>(
               &_Message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Message& a, Message& b) {
    a.Swap(&b);
  }
  inline void Swap(Message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Message>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Message& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Message& from) {
    Message::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Message* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.messaging.Message";
  }
  protected:
  explicit Message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageIdFieldNumber = 1,
    kMessageTypeFieldNumber = 2,
    kMessageVersionFieldNumber = 3,
    kFromServiceFieldNumber = 4,
    kToServiceFieldNumber = 5,
    kRoutingKeyFieldNumber = 6,
    kCorrelationIdFieldNumber = 9,
    kReplyToFieldNumber = 10,
    kUserIdFieldNumber = 11,
    kSessionIdFieldNumber = 12,
    kTraceIdFieldNumber = 13,
    kCreatedAtFieldNumber = 7,
    kExpiresAtFieldNumber = 8,
    kOptionsFieldNumber = 30,
    kMetadataFieldNumber = 31,
    kLlmMessageFieldNumber = 20,
    kAgentMessageFieldNumber = 21,
    kToolMessageFieldNumber = 22,
    kWorkflowMessageFieldNumber = 23,
    kUiMessageFieldNumber = 24,
    kSystemMessageFieldNumber = 25,
  };
  // string message_id = 1;
  void clear_message_id();
  const std::string& message_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message_id();
  PROTOBUF_NODISCARD std::string* release_message_id();
  void set_allocated_message_id(std::string* message_id);
  private:
  const std::string& _internal_message_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message_id(const std::string& value);
  std::string* _internal_mutable_message_id();
  public:

  // string message_type = 2;
  void clear_message_type();
  const std::string& message_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message_type();
  PROTOBUF_NODISCARD std::string* release_message_type();
  void set_allocated_message_type(std::string* message_type);
  private:
  const std::string& _internal_message_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message_type(const std::string& value);
  std::string* _internal_mutable_message_type();
  public:

  // string message_version = 3;
  void clear_message_version();
  const std::string& message_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message_version();
  PROTOBUF_NODISCARD std::string* release_message_version();
  void set_allocated_message_version(std::string* message_version);
  private:
  const std::string& _internal_message_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message_version(const std::string& value);
  std::string* _internal_mutable_message_version();
  public:

  // string from_service = 4;
  void clear_from_service();
  const std::string& from_service() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_from_service(ArgT0&& arg0, ArgT... args);
  std::string* mutable_from_service();
  PROTOBUF_NODISCARD std::string* release_from_service();
  void set_allocated_from_service(std::string* from_service);
  private:
  const std::string& _internal_from_service() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_from_service(const std::string& value);
  std::string* _internal_mutable_from_service();
  public:

  // string to_service = 5;
  void clear_to_service();
  const std::string& to_service() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_to_service(ArgT0&& arg0, ArgT... args);
  std::string* mutable_to_service();
  PROTOBUF_NODISCARD std::string* release_to_service();
  void set_allocated_to_service(std::string* to_service);
  private:
  const std::string& _internal_to_service() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to_service(const std::string& value);
  std::string* _internal_mutable_to_service();
  public:

  // string routing_key = 6;
  void clear_routing_key();
  const std::string& routing_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_routing_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_routing_key();
  PROTOBUF_NODISCARD std::string* release_routing_key();
  void set_allocated_routing_key(std::string* routing_key);
  private:
  const std::string& _internal_routing_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_routing_key(const std::string& value);
  std::string* _internal_mutable_routing_key();
  public:

  // string correlation_id = 9;
  void clear_correlation_id();
  const std::string& correlation_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_correlation_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_correlation_id();
  PROTOBUF_NODISCARD std::string* release_correlation_id();
  void set_allocated_correlation_id(std::string* correlation_id);
  private:
  const std::string& _internal_correlation_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_correlation_id(const std::string& value);
  std::string* _internal_mutable_correlation_id();
  public:

  // string reply_to = 10;
  void clear_reply_to();
  const std::string& reply_to() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reply_to(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reply_to();
  PROTOBUF_NODISCARD std::string* release_reply_to();
  void set_allocated_reply_to(std::string* reply_to);
  private:
  const std::string& _internal_reply_to() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reply_to(const std::string& value);
  std::string* _internal_mutable_reply_to();
  public:

  // string user_id = 11;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string session_id = 12;
  void clear_session_id();
  const std::string& session_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // string trace_id = 13;
  void clear_trace_id();
  const std::string& trace_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_trace_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_trace_id();
  PROTOBUF_NODISCARD std::string* release_trace_id();
  void set_allocated_trace_id(std::string* trace_id);
  private:
  const std::string& _internal_trace_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trace_id(const std::string& value);
  std::string* _internal_mutable_trace_id();
  public:

  // .google.protobuf.Timestamp created_at = 7;
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_at();
  void set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_at();

  // .google.protobuf.Timestamp expires_at = 8;
  bool has_expires_at() const;
  private:
  bool _internal_has_expires_at() const;
  public:
  void clear_expires_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& expires_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_expires_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_expires_at();
  void set_allocated_expires_at(::PROTOBUF_NAMESPACE_ID::Timestamp* expires_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_expires_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_expires_at();
  public:
  void unsafe_arena_set_allocated_expires_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* expires_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_expires_at();

  // .unhinged.messaging.MessageOptions options = 30;
  bool has_options() const;
  private:
  bool _internal_has_options() const;
  public:
  void clear_options();
  const ::unhinged::messaging::MessageOptions& options() const;
  PROTOBUF_NODISCARD ::unhinged::messaging::MessageOptions* release_options();
  ::unhinged::messaging::MessageOptions* mutable_options();
  void set_allocated_options(::unhinged::messaging::MessageOptions* options);
  private:
  const ::unhinged::messaging::MessageOptions& _internal_options() const;
  ::unhinged::messaging::MessageOptions* _internal_mutable_options();
  public:
  void unsafe_arena_set_allocated_options(
      ::unhinged::messaging::MessageOptions* options);
  ::unhinged::messaging::MessageOptions* unsafe_arena_release_options();

  // .google.protobuf.Struct metadata = 31;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::PROTOBUF_NAMESPACE_ID::Struct& metadata() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_metadata();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_metadata();
  void set_allocated_metadata(::PROTOBUF_NAMESPACE_ID::Struct* metadata);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::PROTOBUF_NAMESPACE_ID::Struct* metadata);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_metadata();

  // .unhinged.messaging.LLMMessage llm_message = 20;
  bool has_llm_message() const;
  private:
  bool _internal_has_llm_message() const;
  public:
  void clear_llm_message();
  const ::unhinged::messaging::LLMMessage& llm_message() const;
  PROTOBUF_NODISCARD ::unhinged::messaging::LLMMessage* release_llm_message();
  ::unhinged::messaging::LLMMessage* mutable_llm_message();
  void set_allocated_llm_message(::unhinged::messaging::LLMMessage* llm_message);
  private:
  const ::unhinged::messaging::LLMMessage& _internal_llm_message() const;
  ::unhinged::messaging::LLMMessage* _internal_mutable_llm_message();
  public:
  void unsafe_arena_set_allocated_llm_message(
      ::unhinged::messaging::LLMMessage* llm_message);
  ::unhinged::messaging::LLMMessage* unsafe_arena_release_llm_message();

  // .unhinged.messaging.AgentMessage agent_message = 21;
  bool has_agent_message() const;
  private:
  bool _internal_has_agent_message() const;
  public:
  void clear_agent_message();
  const ::unhinged::messaging::AgentMessage& agent_message() const;
  PROTOBUF_NODISCARD ::unhinged::messaging::AgentMessage* release_agent_message();
  ::unhinged::messaging::AgentMessage* mutable_agent_message();
  void set_allocated_agent_message(::unhinged::messaging::AgentMessage* agent_message);
  private:
  const ::unhinged::messaging::AgentMessage& _internal_agent_message() const;
  ::unhinged::messaging::AgentMessage* _internal_mutable_agent_message();
  public:
  void unsafe_arena_set_allocated_agent_message(
      ::unhinged::messaging::AgentMessage* agent_message);
  ::unhinged::messaging::AgentMessage* unsafe_arena_release_agent_message();

  // .unhinged.messaging.ToolMessage tool_message = 22;
  bool has_tool_message() const;
  private:
  bool _internal_has_tool_message() const;
  public:
  void clear_tool_message();
  const ::unhinged::messaging::ToolMessage& tool_message() const;
  PROTOBUF_NODISCARD ::unhinged::messaging::ToolMessage* release_tool_message();
  ::unhinged::messaging::ToolMessage* mutable_tool_message();
  void set_allocated_tool_message(::unhinged::messaging::ToolMessage* tool_message);
  private:
  const ::unhinged::messaging::ToolMessage& _internal_tool_message() const;
  ::unhinged::messaging::ToolMessage* _internal_mutable_tool_message();
  public:
  void unsafe_arena_set_allocated_tool_message(
      ::unhinged::messaging::ToolMessage* tool_message);
  ::unhinged::messaging::ToolMessage* unsafe_arena_release_tool_message();

  // .unhinged.messaging.WorkflowMessage workflow_message = 23;
  bool has_workflow_message() const;
  private:
  bool _internal_has_workflow_message() const;
  public:
  void clear_workflow_message();
  const ::unhinged::messaging::WorkflowMessage& workflow_message() const;
  PROTOBUF_NODISCARD ::unhinged::messaging::WorkflowMessage* release_workflow_message();
  ::unhinged::messaging::WorkflowMessage* mutable_workflow_message();
  void set_allocated_workflow_message(::unhinged::messaging::WorkflowMessage* workflow_message);
  private:
  const ::unhinged::messaging::WorkflowMessage& _internal_workflow_message() const;
  ::unhinged::messaging::WorkflowMessage* _internal_mutable_workflow_message();
  public:
  void unsafe_arena_set_allocated_workflow_message(
      ::unhinged::messaging::WorkflowMessage* workflow_message);
  ::unhinged::messaging::WorkflowMessage* unsafe_arena_release_workflow_message();

  // .unhinged.messaging.UIMessage ui_message = 24;
  bool has_ui_message() const;
  private:
  bool _internal_has_ui_message() const;
  public:
  void clear_ui_message();
  const ::unhinged::messaging::UIMessage& ui_message() const;
  PROTOBUF_NODISCARD ::unhinged::messaging::UIMessage* release_ui_message();
  ::unhinged::messaging::UIMessage* mutable_ui_message();
  void set_allocated_ui_message(::unhinged::messaging::UIMessage* ui_message);
  private:
  const ::unhinged::messaging::UIMessage& _internal_ui_message() const;
  ::unhinged::messaging::UIMessage* _internal_mutable_ui_message();
  public:
  void unsafe_arena_set_allocated_ui_message(
      ::unhinged::messaging::UIMessage* ui_message);
  ::unhinged::messaging::UIMessage* unsafe_arena_release_ui_message();

  // .unhinged.messaging.SystemMessage system_message = 25;
  bool has_system_message() const;
  private:
  bool _internal_has_system_message() const;
  public:
  void clear_system_message();
  const ::unhinged::messaging::SystemMessage& system_message() const;
  PROTOBUF_NODISCARD ::unhinged::messaging::SystemMessage* release_system_message();
  ::unhinged::messaging::SystemMessage* mutable_system_message();
  void set_allocated_system_message(::unhinged::messaging::SystemMessage* system_message);
  private:
  const ::unhinged::messaging::SystemMessage& _internal_system_message() const;
  ::unhinged::messaging::SystemMessage* _internal_mutable_system_message();
  public:
  void unsafe_arena_set_allocated_system_message(
      ::unhinged::messaging::SystemMessage* system_message);
  ::unhinged::messaging::SystemMessage* unsafe_arena_release_system_message();

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:unhinged.messaging.Message)
 private:
  class _Internal;
  void set_has_llm_message();
  void set_has_agent_message();
  void set_has_tool_message();
  void set_has_workflow_message();
  void set_has_ui_message();
  void set_has_system_message();

  inline bool has_payload() const;
  inline void clear_has_payload();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr from_service_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_service_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr routing_key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr correlation_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reply_to_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trace_id_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* expires_at_;
    ::unhinged::messaging::MessageOptions* options_;
    ::PROTOBUF_NAMESPACE_ID::Struct* metadata_;
    union PayloadUnion {
      constexpr PayloadUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::unhinged::messaging::LLMMessage* llm_message_;
      ::unhinged::messaging::AgentMessage* agent_message_;
      ::unhinged::messaging::ToolMessage* tool_message_;
      ::unhinged::messaging::WorkflowMessage* workflow_message_;
      ::unhinged::messaging::UIMessage* ui_message_;
      ::unhinged::messaging::SystemMessage* system_message_;
    } payload_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messaging_2eproto;
};
// -------------------------------------------------------------------

class MessageOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.messaging.MessageOptions) */ {
 public:
  inline MessageOptions() : MessageOptions(nullptr) {}
  ~MessageOptions() override;
  explicit PROTOBUF_CONSTEXPR MessageOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MessageOptions(const MessageOptions& from);
  MessageOptions(MessageOptions&& from) noexcept
    : MessageOptions() {
    *this = ::std::move(from);
  }

  inline MessageOptions& operator=(const MessageOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessageOptions& operator=(MessageOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MessageOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const MessageOptions* internal_default_instance() {
    return reinterpret_cast<const MessageOptions*>(
               &_MessageOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(MessageOptions& a, MessageOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(MessageOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessageOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MessageOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MessageOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MessageOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MessageOptions& from) {
    MessageOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessageOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.messaging.MessageOptions";
  }
  protected:
  explicit MessageOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeliveryModeFieldNumber = 1,
    kRetryAttemptsFieldNumber = 2,
    kRetryDelayMsFieldNumber = 3,
    kPriorityFieldNumber = 4,
    kPreserveOrderFieldNumber = 5,
    kExpectReplyFieldNumber = 6,
    kReplyTimeoutMsFieldNumber = 7,
  };
  // string delivery_mode = 1;
  void clear_delivery_mode();
  const std::string& delivery_mode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_delivery_mode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_delivery_mode();
  PROTOBUF_NODISCARD std::string* release_delivery_mode();
  void set_allocated_delivery_mode(std::string* delivery_mode);
  private:
  const std::string& _internal_delivery_mode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_delivery_mode(const std::string& value);
  std::string* _internal_mutable_delivery_mode();
  public:

  // int32 retry_attempts = 2;
  void clear_retry_attempts();
  int32_t retry_attempts() const;
  void set_retry_attempts(int32_t value);
  private:
  int32_t _internal_retry_attempts() const;
  void _internal_set_retry_attempts(int32_t value);
  public:

  // int32 retry_delay_ms = 3;
  void clear_retry_delay_ms();
  int32_t retry_delay_ms() const;
  void set_retry_delay_ms(int32_t value);
  private:
  int32_t _internal_retry_delay_ms() const;
  void _internal_set_retry_delay_ms(int32_t value);
  public:

  // int32 priority = 4;
  void clear_priority();
  int32_t priority() const;
  void set_priority(int32_t value);
  private:
  int32_t _internal_priority() const;
  void _internal_set_priority(int32_t value);
  public:

  // bool preserve_order = 5;
  void clear_preserve_order();
  bool preserve_order() const;
  void set_preserve_order(bool value);
  private:
  bool _internal_preserve_order() const;
  void _internal_set_preserve_order(bool value);
  public:

  // bool expect_reply = 6;
  void clear_expect_reply();
  bool expect_reply() const;
  void set_expect_reply(bool value);
  private:
  bool _internal_expect_reply() const;
  void _internal_set_expect_reply(bool value);
  public:

  // int32 reply_timeout_ms = 7;
  void clear_reply_timeout_ms();
  int32_t reply_timeout_ms() const;
  void set_reply_timeout_ms(int32_t value);
  private:
  int32_t _internal_reply_timeout_ms() const;
  void _internal_set_reply_timeout_ms(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.messaging.MessageOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr delivery_mode_;
    int32_t retry_attempts_;
    int32_t retry_delay_ms_;
    int32_t priority_;
    bool preserve_order_;
    bool expect_reply_;
    int32_t reply_timeout_ms_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messaging_2eproto;
};
// -------------------------------------------------------------------

class LLMMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.messaging.LLMMessage) */ {
 public:
  inline LLMMessage() : LLMMessage(nullptr) {}
  ~LLMMessage() override;
  explicit PROTOBUF_CONSTEXPR LLMMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LLMMessage(const LLMMessage& from);
  LLMMessage(LLMMessage&& from) noexcept
    : LLMMessage() {
    *this = ::std::move(from);
  }

  inline LLMMessage& operator=(const LLMMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline LLMMessage& operator=(LLMMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LLMMessage& default_instance() {
    return *internal_default_instance();
  }
  enum MessageDataCase {
    kPromptRequest = 10,
    kPromptResponse = 11,
    kStreamChunk = 12,
    kLlmError = 13,
    kCancelRequest = 14,
    MESSAGE_DATA_NOT_SET = 0,
  };

  static inline const LLMMessage* internal_default_instance() {
    return reinterpret_cast<const LLMMessage*>(
               &_LLMMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(LLMMessage& a, LLMMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(LLMMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LLMMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LLMMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LLMMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LLMMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LLMMessage& from) {
    LLMMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LLMMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.messaging.LLMMessage";
  }
  protected:
  explicit LLMMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInteractionIdFieldNumber = 1,
    kMessageTypeFieldNumber = 2,
    kPromptRequestFieldNumber = 10,
    kPromptResponseFieldNumber = 11,
    kStreamChunkFieldNumber = 12,
    kLlmErrorFieldNumber = 13,
    kCancelRequestFieldNumber = 14,
  };
  // string interaction_id = 1;
  void clear_interaction_id();
  const std::string& interaction_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_interaction_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_interaction_id();
  PROTOBUF_NODISCARD std::string* release_interaction_id();
  void set_allocated_interaction_id(std::string* interaction_id);
  private:
  const std::string& _internal_interaction_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_interaction_id(const std::string& value);
  std::string* _internal_mutable_interaction_id();
  public:

  // .unhinged.messaging.LLMMessageType message_type = 2;
  void clear_message_type();
  ::unhinged::messaging::LLMMessageType message_type() const;
  void set_message_type(::unhinged::messaging::LLMMessageType value);
  private:
  ::unhinged::messaging::LLMMessageType _internal_message_type() const;
  void _internal_set_message_type(::unhinged::messaging::LLMMessageType value);
  public:

  // .unhinged.messaging.LLMPromptRequest prompt_request = 10;
  bool has_prompt_request() const;
  private:
  bool _internal_has_prompt_request() const;
  public:
  void clear_prompt_request();
  const ::unhinged::messaging::LLMPromptRequest& prompt_request() const;
  PROTOBUF_NODISCARD ::unhinged::messaging::LLMPromptRequest* release_prompt_request();
  ::unhinged::messaging::LLMPromptRequest* mutable_prompt_request();
  void set_allocated_prompt_request(::unhinged::messaging::LLMPromptRequest* prompt_request);
  private:
  const ::unhinged::messaging::LLMPromptRequest& _internal_prompt_request() const;
  ::unhinged::messaging::LLMPromptRequest* _internal_mutable_prompt_request();
  public:
  void unsafe_arena_set_allocated_prompt_request(
      ::unhinged::messaging::LLMPromptRequest* prompt_request);
  ::unhinged::messaging::LLMPromptRequest* unsafe_arena_release_prompt_request();

  // .unhinged.messaging.LLMPromptResponse prompt_response = 11;
  bool has_prompt_response() const;
  private:
  bool _internal_has_prompt_response() const;
  public:
  void clear_prompt_response();
  const ::unhinged::messaging::LLMPromptResponse& prompt_response() const;
  PROTOBUF_NODISCARD ::unhinged::messaging::LLMPromptResponse* release_prompt_response();
  ::unhinged::messaging::LLMPromptResponse* mutable_prompt_response();
  void set_allocated_prompt_response(::unhinged::messaging::LLMPromptResponse* prompt_response);
  private:
  const ::unhinged::messaging::LLMPromptResponse& _internal_prompt_response() const;
  ::unhinged::messaging::LLMPromptResponse* _internal_mutable_prompt_response();
  public:
  void unsafe_arena_set_allocated_prompt_response(
      ::unhinged::messaging::LLMPromptResponse* prompt_response);
  ::unhinged::messaging::LLMPromptResponse* unsafe_arena_release_prompt_response();

  // .unhinged.messaging.LLMStreamChunk stream_chunk = 12;
  bool has_stream_chunk() const;
  private:
  bool _internal_has_stream_chunk() const;
  public:
  void clear_stream_chunk();
  const ::unhinged::messaging::LLMStreamChunk& stream_chunk() const;
  PROTOBUF_NODISCARD ::unhinged::messaging::LLMStreamChunk* release_stream_chunk();
  ::unhinged::messaging::LLMStreamChunk* mutable_stream_chunk();
  void set_allocated_stream_chunk(::unhinged::messaging::LLMStreamChunk* stream_chunk);
  private:
  const ::unhinged::messaging::LLMStreamChunk& _internal_stream_chunk() const;
  ::unhinged::messaging::LLMStreamChunk* _internal_mutable_stream_chunk();
  public:
  void unsafe_arena_set_allocated_stream_chunk(
      ::unhinged::messaging::LLMStreamChunk* stream_chunk);
  ::unhinged::messaging::LLMStreamChunk* unsafe_arena_release_stream_chunk();

  // .unhinged.messaging.LLMError llm_error = 13;
  bool has_llm_error() const;
  private:
  bool _internal_has_llm_error() const;
  public:
  void clear_llm_error();
  const ::unhinged::messaging::LLMError& llm_error() const;
  PROTOBUF_NODISCARD ::unhinged::messaging::LLMError* release_llm_error();
  ::unhinged::messaging::LLMError* mutable_llm_error();
  void set_allocated_llm_error(::unhinged::messaging::LLMError* llm_error);
  private:
  const ::unhinged::messaging::LLMError& _internal_llm_error() const;
  ::unhinged::messaging::LLMError* _internal_mutable_llm_error();
  public:
  void unsafe_arena_set_allocated_llm_error(
      ::unhinged::messaging::LLMError* llm_error);
  ::unhinged::messaging::LLMError* unsafe_arena_release_llm_error();

  // .unhinged.messaging.LLMCancel cancel_request = 14;
  bool has_cancel_request() const;
  private:
  bool _internal_has_cancel_request() const;
  public:
  void clear_cancel_request();
  const ::unhinged::messaging::LLMCancel& cancel_request() const;
  PROTOBUF_NODISCARD ::unhinged::messaging::LLMCancel* release_cancel_request();
  ::unhinged::messaging::LLMCancel* mutable_cancel_request();
  void set_allocated_cancel_request(::unhinged::messaging::LLMCancel* cancel_request);
  private:
  const ::unhinged::messaging::LLMCancel& _internal_cancel_request() const;
  ::unhinged::messaging::LLMCancel* _internal_mutable_cancel_request();
  public:
  void unsafe_arena_set_allocated_cancel_request(
      ::unhinged::messaging::LLMCancel* cancel_request);
  ::unhinged::messaging::LLMCancel* unsafe_arena_release_cancel_request();

  void clear_message_data();
  MessageDataCase message_data_case() const;
  // @@protoc_insertion_point(class_scope:unhinged.messaging.LLMMessage)
 private:
  class _Internal;
  void set_has_prompt_request();
  void set_has_prompt_response();
  void set_has_stream_chunk();
  void set_has_llm_error();
  void set_has_cancel_request();

  inline bool has_message_data() const;
  inline void clear_has_message_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr interaction_id_;
    int message_type_;
    union MessageDataUnion {
      constexpr MessageDataUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::unhinged::messaging::LLMPromptRequest* prompt_request_;
      ::unhinged::messaging::LLMPromptResponse* prompt_response_;
      ::unhinged::messaging::LLMStreamChunk* stream_chunk_;
      ::unhinged::messaging::LLMError* llm_error_;
      ::unhinged::messaging::LLMCancel* cancel_request_;
    } message_data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messaging_2eproto;
};
// -------------------------------------------------------------------

class LLMPromptRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.messaging.LLMPromptRequest) */ {
 public:
  inline LLMPromptRequest() : LLMPromptRequest(nullptr) {}
  ~LLMPromptRequest() override;
  explicit PROTOBUF_CONSTEXPR LLMPromptRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LLMPromptRequest(const LLMPromptRequest& from);
  LLMPromptRequest(LLMPromptRequest&& from) noexcept
    : LLMPromptRequest() {
    *this = ::std::move(from);
  }

  inline LLMPromptRequest& operator=(const LLMPromptRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LLMPromptRequest& operator=(LLMPromptRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LLMPromptRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LLMPromptRequest* internal_default_instance() {
    return reinterpret_cast<const LLMPromptRequest*>(
               &_LLMPromptRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(LLMPromptRequest& a, LLMPromptRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LLMPromptRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LLMPromptRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LLMPromptRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LLMPromptRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LLMPromptRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LLMPromptRequest& from) {
    LLMPromptRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LLMPromptRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.messaging.LLMPromptRequest";
  }
  protected:
  explicit LLMPromptRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContextDocumentsFieldNumber = 5,
    kStopSequencesFieldNumber = 9,
    kToolsAvailableFieldNumber = 13,
    kModelNameFieldNumber = 1,
    kProviderFieldNumber = 2,
    kSystemPromptFieldNumber = 3,
    kUserPromptFieldNumber = 4,
    kStreamCallbackUrlFieldNumber = 11,
    kPromptMetadataFieldNumber = 12,
    kMaxTokensFieldNumber = 6,
    kTemperatureFieldNumber = 7,
    kTopPFieldNumber = 8,
    kStreamResponseFieldNumber = 10,
  };
  // repeated .unhinged.messaging.ContextDocument context_documents = 5;
  int context_documents_size() const;
  private:
  int _internal_context_documents_size() const;
  public:
  void clear_context_documents();
  ::unhinged::messaging::ContextDocument* mutable_context_documents(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::messaging::ContextDocument >*
      mutable_context_documents();
  private:
  const ::unhinged::messaging::ContextDocument& _internal_context_documents(int index) const;
  ::unhinged::messaging::ContextDocument* _internal_add_context_documents();
  public:
  const ::unhinged::messaging::ContextDocument& context_documents(int index) const;
  ::unhinged::messaging::ContextDocument* add_context_documents();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::messaging::ContextDocument >&
      context_documents() const;

  // repeated string stop_sequences = 9;
  int stop_sequences_size() const;
  private:
  int _internal_stop_sequences_size() const;
  public:
  void clear_stop_sequences();
  const std::string& stop_sequences(int index) const;
  std::string* mutable_stop_sequences(int index);
  void set_stop_sequences(int index, const std::string& value);
  void set_stop_sequences(int index, std::string&& value);
  void set_stop_sequences(int index, const char* value);
  void set_stop_sequences(int index, const char* value, size_t size);
  std::string* add_stop_sequences();
  void add_stop_sequences(const std::string& value);
  void add_stop_sequences(std::string&& value);
  void add_stop_sequences(const char* value);
  void add_stop_sequences(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& stop_sequences() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_stop_sequences();
  private:
  const std::string& _internal_stop_sequences(int index) const;
  std::string* _internal_add_stop_sequences();
  public:

  // repeated string tools_available = 13;
  int tools_available_size() const;
  private:
  int _internal_tools_available_size() const;
  public:
  void clear_tools_available();
  const std::string& tools_available(int index) const;
  std::string* mutable_tools_available(int index);
  void set_tools_available(int index, const std::string& value);
  void set_tools_available(int index, std::string&& value);
  void set_tools_available(int index, const char* value);
  void set_tools_available(int index, const char* value, size_t size);
  std::string* add_tools_available();
  void add_tools_available(const std::string& value);
  void add_tools_available(std::string&& value);
  void add_tools_available(const char* value);
  void add_tools_available(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tools_available() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tools_available();
  private:
  const std::string& _internal_tools_available(int index) const;
  std::string* _internal_add_tools_available();
  public:

  // string model_name = 1;
  void clear_model_name();
  const std::string& model_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_name();
  PROTOBUF_NODISCARD std::string* release_model_name();
  void set_allocated_model_name(std::string* model_name);
  private:
  const std::string& _internal_model_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_name(const std::string& value);
  std::string* _internal_mutable_model_name();
  public:

  // string provider = 2;
  void clear_provider();
  const std::string& provider() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_provider(ArgT0&& arg0, ArgT... args);
  std::string* mutable_provider();
  PROTOBUF_NODISCARD std::string* release_provider();
  void set_allocated_provider(std::string* provider);
  private:
  const std::string& _internal_provider() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_provider(const std::string& value);
  std::string* _internal_mutable_provider();
  public:

  // string system_prompt = 3;
  void clear_system_prompt();
  const std::string& system_prompt() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_system_prompt(ArgT0&& arg0, ArgT... args);
  std::string* mutable_system_prompt();
  PROTOBUF_NODISCARD std::string* release_system_prompt();
  void set_allocated_system_prompt(std::string* system_prompt);
  private:
  const std::string& _internal_system_prompt() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_system_prompt(const std::string& value);
  std::string* _internal_mutable_system_prompt();
  public:

  // string user_prompt = 4;
  void clear_user_prompt();
  const std::string& user_prompt() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_prompt(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_prompt();
  PROTOBUF_NODISCARD std::string* release_user_prompt();
  void set_allocated_user_prompt(std::string* user_prompt);
  private:
  const std::string& _internal_user_prompt() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_prompt(const std::string& value);
  std::string* _internal_mutable_user_prompt();
  public:

  // string stream_callback_url = 11;
  void clear_stream_callback_url();
  const std::string& stream_callback_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stream_callback_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stream_callback_url();
  PROTOBUF_NODISCARD std::string* release_stream_callback_url();
  void set_allocated_stream_callback_url(std::string* stream_callback_url);
  private:
  const std::string& _internal_stream_callback_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stream_callback_url(const std::string& value);
  std::string* _internal_mutable_stream_callback_url();
  public:

  // .google.protobuf.Struct prompt_metadata = 12;
  bool has_prompt_metadata() const;
  private:
  bool _internal_has_prompt_metadata() const;
  public:
  void clear_prompt_metadata();
  const ::PROTOBUF_NAMESPACE_ID::Struct& prompt_metadata() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_prompt_metadata();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_prompt_metadata();
  void set_allocated_prompt_metadata(::PROTOBUF_NAMESPACE_ID::Struct* prompt_metadata);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_prompt_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_prompt_metadata();
  public:
  void unsafe_arena_set_allocated_prompt_metadata(
      ::PROTOBUF_NAMESPACE_ID::Struct* prompt_metadata);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_prompt_metadata();

  // int32 max_tokens = 6;
  void clear_max_tokens();
  int32_t max_tokens() const;
  void set_max_tokens(int32_t value);
  private:
  int32_t _internal_max_tokens() const;
  void _internal_set_max_tokens(int32_t value);
  public:

  // float temperature = 7;
  void clear_temperature();
  float temperature() const;
  void set_temperature(float value);
  private:
  float _internal_temperature() const;
  void _internal_set_temperature(float value);
  public:

  // float top_p = 8;
  void clear_top_p();
  float top_p() const;
  void set_top_p(float value);
  private:
  float _internal_top_p() const;
  void _internal_set_top_p(float value);
  public:

  // bool stream_response = 10;
  void clear_stream_response();
  bool stream_response() const;
  void set_stream_response(bool value);
  private:
  bool _internal_stream_response() const;
  void _internal_set_stream_response(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.messaging.LLMPromptRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::messaging::ContextDocument > context_documents_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> stop_sequences_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tools_available_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr provider_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr system_prompt_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_prompt_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stream_callback_url_;
    ::PROTOBUF_NAMESPACE_ID::Struct* prompt_metadata_;
    int32_t max_tokens_;
    float temperature_;
    float top_p_;
    bool stream_response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messaging_2eproto;
};
// -------------------------------------------------------------------

class ContextDocument final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.messaging.ContextDocument) */ {
 public:
  inline ContextDocument() : ContextDocument(nullptr) {}
  ~ContextDocument() override;
  explicit PROTOBUF_CONSTEXPR ContextDocument(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContextDocument(const ContextDocument& from);
  ContextDocument(ContextDocument&& from) noexcept
    : ContextDocument() {
    *this = ::std::move(from);
  }

  inline ContextDocument& operator=(const ContextDocument& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContextDocument& operator=(ContextDocument&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContextDocument& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContextDocument* internal_default_instance() {
    return reinterpret_cast<const ContextDocument*>(
               &_ContextDocument_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ContextDocument& a, ContextDocument& b) {
    a.Swap(&b);
  }
  inline void Swap(ContextDocument* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContextDocument* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContextDocument* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContextDocument>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ContextDocument& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ContextDocument& from) {
    ContextDocument::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContextDocument* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.messaging.ContextDocument";
  }
  protected:
  explicit ContextDocument(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDocumentIdFieldNumber = 1,
    kDocumentTypeFieldNumber = 2,
    kContentFieldNumber = 3,
    kMetadataFieldNumber = 4,
    kRelevanceScoreFieldNumber = 5,
  };
  // string document_id = 1;
  void clear_document_id();
  const std::string& document_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_document_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_document_id();
  PROTOBUF_NODISCARD std::string* release_document_id();
  void set_allocated_document_id(std::string* document_id);
  private:
  const std::string& _internal_document_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_document_id(const std::string& value);
  std::string* _internal_mutable_document_id();
  public:

  // string document_type = 2;
  void clear_document_type();
  const std::string& document_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_document_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_document_type();
  PROTOBUF_NODISCARD std::string* release_document_type();
  void set_allocated_document_type(std::string* document_type);
  private:
  const std::string& _internal_document_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_document_type(const std::string& value);
  std::string* _internal_mutable_document_type();
  public:

  // string content = 3;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // .google.protobuf.Struct metadata = 4;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::PROTOBUF_NAMESPACE_ID::Struct& metadata() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_metadata();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_metadata();
  void set_allocated_metadata(::PROTOBUF_NAMESPACE_ID::Struct* metadata);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::PROTOBUF_NAMESPACE_ID::Struct* metadata);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_metadata();

  // float relevance_score = 5;
  void clear_relevance_score();
  float relevance_score() const;
  void set_relevance_score(float value);
  private:
  float _internal_relevance_score() const;
  void _internal_set_relevance_score(float value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.messaging.ContextDocument)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr document_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr document_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    ::PROTOBUF_NAMESPACE_ID::Struct* metadata_;
    float relevance_score_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messaging_2eproto;
};
// -------------------------------------------------------------------

class LLMPromptResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.messaging.LLMPromptResponse) */ {
 public:
  inline LLMPromptResponse() : LLMPromptResponse(nullptr) {}
  ~LLMPromptResponse() override;
  explicit PROTOBUF_CONSTEXPR LLMPromptResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LLMPromptResponse(const LLMPromptResponse& from);
  LLMPromptResponse(LLMPromptResponse&& from) noexcept
    : LLMPromptResponse() {
    *this = ::std::move(from);
  }

  inline LLMPromptResponse& operator=(const LLMPromptResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LLMPromptResponse& operator=(LLMPromptResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LLMPromptResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LLMPromptResponse* internal_default_instance() {
    return reinterpret_cast<const LLMPromptResponse*>(
               &_LLMPromptResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(LLMPromptResponse& a, LLMPromptResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LLMPromptResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LLMPromptResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LLMPromptResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LLMPromptResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LLMPromptResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LLMPromptResponse& from) {
    LLMPromptResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LLMPromptResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.messaging.LLMPromptResponse";
  }
  protected:
  explicit LLMPromptResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kToolCallsFieldNumber = 8,
    kResponseTextFieldNumber = 1,
    kFinishReasonFieldNumber = 2,
    kResponseMetadataFieldNumber = 9,
    kPromptTokensFieldNumber = 3,
    kCompletionTokensFieldNumber = 4,
    kTotalTokensFieldNumber = 5,
    kResponseTimeMsFieldNumber = 6,
    kTokensPerSecondFieldNumber = 7,
  };
  // repeated .unhinged.messaging.ToolCall tool_calls = 8;
  int tool_calls_size() const;
  private:
  int _internal_tool_calls_size() const;
  public:
  void clear_tool_calls();
  ::unhinged::messaging::ToolCall* mutable_tool_calls(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::messaging::ToolCall >*
      mutable_tool_calls();
  private:
  const ::unhinged::messaging::ToolCall& _internal_tool_calls(int index) const;
  ::unhinged::messaging::ToolCall* _internal_add_tool_calls();
  public:
  const ::unhinged::messaging::ToolCall& tool_calls(int index) const;
  ::unhinged::messaging::ToolCall* add_tool_calls();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::messaging::ToolCall >&
      tool_calls() const;

  // string response_text = 1;
  void clear_response_text();
  const std::string& response_text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_response_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_response_text();
  PROTOBUF_NODISCARD std::string* release_response_text();
  void set_allocated_response_text(std::string* response_text);
  private:
  const std::string& _internal_response_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_response_text(const std::string& value);
  std::string* _internal_mutable_response_text();
  public:

  // string finish_reason = 2;
  void clear_finish_reason();
  const std::string& finish_reason() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_finish_reason(ArgT0&& arg0, ArgT... args);
  std::string* mutable_finish_reason();
  PROTOBUF_NODISCARD std::string* release_finish_reason();
  void set_allocated_finish_reason(std::string* finish_reason);
  private:
  const std::string& _internal_finish_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_finish_reason(const std::string& value);
  std::string* _internal_mutable_finish_reason();
  public:

  // .google.protobuf.Struct response_metadata = 9;
  bool has_response_metadata() const;
  private:
  bool _internal_has_response_metadata() const;
  public:
  void clear_response_metadata();
  const ::PROTOBUF_NAMESPACE_ID::Struct& response_metadata() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_response_metadata();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_response_metadata();
  void set_allocated_response_metadata(::PROTOBUF_NAMESPACE_ID::Struct* response_metadata);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_response_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_response_metadata();
  public:
  void unsafe_arena_set_allocated_response_metadata(
      ::PROTOBUF_NAMESPACE_ID::Struct* response_metadata);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_response_metadata();

  // int32 prompt_tokens = 3;
  void clear_prompt_tokens();
  int32_t prompt_tokens() const;
  void set_prompt_tokens(int32_t value);
  private:
  int32_t _internal_prompt_tokens() const;
  void _internal_set_prompt_tokens(int32_t value);
  public:

  // int32 completion_tokens = 4;
  void clear_completion_tokens();
  int32_t completion_tokens() const;
  void set_completion_tokens(int32_t value);
  private:
  int32_t _internal_completion_tokens() const;
  void _internal_set_completion_tokens(int32_t value);
  public:

  // int32 total_tokens = 5;
  void clear_total_tokens();
  int32_t total_tokens() const;
  void set_total_tokens(int32_t value);
  private:
  int32_t _internal_total_tokens() const;
  void _internal_set_total_tokens(int32_t value);
  public:

  // float response_time_ms = 6;
  void clear_response_time_ms();
  float response_time_ms() const;
  void set_response_time_ms(float value);
  private:
  float _internal_response_time_ms() const;
  void _internal_set_response_time_ms(float value);
  public:

  // float tokens_per_second = 7;
  void clear_tokens_per_second();
  float tokens_per_second() const;
  void set_tokens_per_second(float value);
  private:
  float _internal_tokens_per_second() const;
  void _internal_set_tokens_per_second(float value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.messaging.LLMPromptResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::messaging::ToolCall > tool_calls_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr response_text_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr finish_reason_;
    ::PROTOBUF_NAMESPACE_ID::Struct* response_metadata_;
    int32_t prompt_tokens_;
    int32_t completion_tokens_;
    int32_t total_tokens_;
    float response_time_ms_;
    float tokens_per_second_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messaging_2eproto;
};
// -------------------------------------------------------------------

class LLMStreamChunk final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.messaging.LLMStreamChunk) */ {
 public:
  inline LLMStreamChunk() : LLMStreamChunk(nullptr) {}
  ~LLMStreamChunk() override;
  explicit PROTOBUF_CONSTEXPR LLMStreamChunk(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LLMStreamChunk(const LLMStreamChunk& from);
  LLMStreamChunk(LLMStreamChunk&& from) noexcept
    : LLMStreamChunk() {
    *this = ::std::move(from);
  }

  inline LLMStreamChunk& operator=(const LLMStreamChunk& from) {
    CopyFrom(from);
    return *this;
  }
  inline LLMStreamChunk& operator=(LLMStreamChunk&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LLMStreamChunk& default_instance() {
    return *internal_default_instance();
  }
  static inline const LLMStreamChunk* internal_default_instance() {
    return reinterpret_cast<const LLMStreamChunk*>(
               &_LLMStreamChunk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(LLMStreamChunk& a, LLMStreamChunk& b) {
    a.Swap(&b);
  }
  inline void Swap(LLMStreamChunk* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LLMStreamChunk* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LLMStreamChunk* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LLMStreamChunk>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LLMStreamChunk& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LLMStreamChunk& from) {
    LLMStreamChunk::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LLMStreamChunk* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.messaging.LLMStreamChunk";
  }
  protected:
  explicit LLMStreamChunk(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartialToolCallsFieldNumber = 4,
    kChunkTextFieldNumber = 1,
    kChunkIndexFieldNumber = 2,
    kIsFinalFieldNumber = 3,
  };
  // repeated .unhinged.messaging.ToolCall partial_tool_calls = 4;
  int partial_tool_calls_size() const;
  private:
  int _internal_partial_tool_calls_size() const;
  public:
  void clear_partial_tool_calls();
  ::unhinged::messaging::ToolCall* mutable_partial_tool_calls(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::messaging::ToolCall >*
      mutable_partial_tool_calls();
  private:
  const ::unhinged::messaging::ToolCall& _internal_partial_tool_calls(int index) const;
  ::unhinged::messaging::ToolCall* _internal_add_partial_tool_calls();
  public:
  const ::unhinged::messaging::ToolCall& partial_tool_calls(int index) const;
  ::unhinged::messaging::ToolCall* add_partial_tool_calls();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::messaging::ToolCall >&
      partial_tool_calls() const;

  // string chunk_text = 1;
  void clear_chunk_text();
  const std::string& chunk_text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chunk_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chunk_text();
  PROTOBUF_NODISCARD std::string* release_chunk_text();
  void set_allocated_chunk_text(std::string* chunk_text);
  private:
  const std::string& _internal_chunk_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chunk_text(const std::string& value);
  std::string* _internal_mutable_chunk_text();
  public:

  // int32 chunk_index = 2;
  void clear_chunk_index();
  int32_t chunk_index() const;
  void set_chunk_index(int32_t value);
  private:
  int32_t _internal_chunk_index() const;
  void _internal_set_chunk_index(int32_t value);
  public:

  // bool is_final = 3;
  void clear_is_final();
  bool is_final() const;
  void set_is_final(bool value);
  private:
  bool _internal_is_final() const;
  void _internal_set_is_final(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.messaging.LLMStreamChunk)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::messaging::ToolCall > partial_tool_calls_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chunk_text_;
    int32_t chunk_index_;
    bool is_final_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messaging_2eproto;
};
// -------------------------------------------------------------------

class LLMError final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.messaging.LLMError) */ {
 public:
  inline LLMError() : LLMError(nullptr) {}
  ~LLMError() override;
  explicit PROTOBUF_CONSTEXPR LLMError(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LLMError(const LLMError& from);
  LLMError(LLMError&& from) noexcept
    : LLMError() {
    *this = ::std::move(from);
  }

  inline LLMError& operator=(const LLMError& from) {
    CopyFrom(from);
    return *this;
  }
  inline LLMError& operator=(LLMError&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LLMError& default_instance() {
    return *internal_default_instance();
  }
  static inline const LLMError* internal_default_instance() {
    return reinterpret_cast<const LLMError*>(
               &_LLMError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(LLMError& a, LLMError& b) {
    a.Swap(&b);
  }
  inline void Swap(LLMError* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LLMError* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LLMError* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LLMError>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LLMError& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LLMError& from) {
    LLMError::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LLMError* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.messaging.LLMError";
  }
  protected:
  explicit LLMError(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorCodeFieldNumber = 1,
    kErrorMessageFieldNumber = 2,
    kErrorTypeFieldNumber = 3,
    kIsRetryableFieldNumber = 4,
    kRetryAfterSecondsFieldNumber = 5,
  };
  // string error_code = 1;
  void clear_error_code();
  const std::string& error_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_code();
  PROTOBUF_NODISCARD std::string* release_error_code();
  void set_allocated_error_code(std::string* error_code);
  private:
  const std::string& _internal_error_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_code(const std::string& value);
  std::string* _internal_mutable_error_code();
  public:

  // string error_message = 2;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // string error_type = 3;
  void clear_error_type();
  const std::string& error_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_type();
  PROTOBUF_NODISCARD std::string* release_error_type();
  void set_allocated_error_type(std::string* error_type);
  private:
  const std::string& _internal_error_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_type(const std::string& value);
  std::string* _internal_mutable_error_type();
  public:

  // bool is_retryable = 4;
  void clear_is_retryable();
  bool is_retryable() const;
  void set_is_retryable(bool value);
  private:
  bool _internal_is_retryable() const;
  void _internal_set_is_retryable(bool value);
  public:

  // int32 retry_after_seconds = 5;
  void clear_retry_after_seconds();
  int32_t retry_after_seconds() const;
  void set_retry_after_seconds(int32_t value);
  private:
  int32_t _internal_retry_after_seconds() const;
  void _internal_set_retry_after_seconds(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.messaging.LLMError)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_code_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_type_;
    bool is_retryable_;
    int32_t retry_after_seconds_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messaging_2eproto;
};
// -------------------------------------------------------------------

class LLMCancel final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.messaging.LLMCancel) */ {
 public:
  inline LLMCancel() : LLMCancel(nullptr) {}
  ~LLMCancel() override;
  explicit PROTOBUF_CONSTEXPR LLMCancel(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LLMCancel(const LLMCancel& from);
  LLMCancel(LLMCancel&& from) noexcept
    : LLMCancel() {
    *this = ::std::move(from);
  }

  inline LLMCancel& operator=(const LLMCancel& from) {
    CopyFrom(from);
    return *this;
  }
  inline LLMCancel& operator=(LLMCancel&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LLMCancel& default_instance() {
    return *internal_default_instance();
  }
  static inline const LLMCancel* internal_default_instance() {
    return reinterpret_cast<const LLMCancel*>(
               &_LLMCancel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(LLMCancel& a, LLMCancel& b) {
    a.Swap(&b);
  }
  inline void Swap(LLMCancel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LLMCancel* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LLMCancel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LLMCancel>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LLMCancel& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LLMCancel& from) {
    LLMCancel::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LLMCancel* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.messaging.LLMCancel";
  }
  protected:
  explicit LLMCancel(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReasonFieldNumber = 1,
  };
  // string reason = 1;
  void clear_reason();
  const std::string& reason() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reason(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reason();
  PROTOBUF_NODISCARD std::string* release_reason();
  void set_allocated_reason(std::string* reason);
  private:
  const std::string& _internal_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reason(const std::string& value);
  std::string* _internal_mutable_reason();
  public:

  // @@protoc_insertion_point(class_scope:unhinged.messaging.LLMCancel)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reason_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messaging_2eproto;
};
// -------------------------------------------------------------------

class ToolCall final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.messaging.ToolCall) */ {
 public:
  inline ToolCall() : ToolCall(nullptr) {}
  ~ToolCall() override;
  explicit PROTOBUF_CONSTEXPR ToolCall(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ToolCall(const ToolCall& from);
  ToolCall(ToolCall&& from) noexcept
    : ToolCall() {
    *this = ::std::move(from);
  }

  inline ToolCall& operator=(const ToolCall& from) {
    CopyFrom(from);
    return *this;
  }
  inline ToolCall& operator=(ToolCall&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ToolCall& default_instance() {
    return *internal_default_instance();
  }
  static inline const ToolCall* internal_default_instance() {
    return reinterpret_cast<const ToolCall*>(
               &_ToolCall_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ToolCall& a, ToolCall& b) {
    a.Swap(&b);
  }
  inline void Swap(ToolCall* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ToolCall* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ToolCall* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ToolCall>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ToolCall& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ToolCall& from) {
    ToolCall::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ToolCall* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.messaging.ToolCall";
  }
  protected:
  explicit ToolCall(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kToolIdFieldNumber = 1,
    kToolNameFieldNumber = 2,
    kToolArgumentsFieldNumber = 3,
  };
  // string tool_id = 1;
  void clear_tool_id();
  const std::string& tool_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tool_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tool_id();
  PROTOBUF_NODISCARD std::string* release_tool_id();
  void set_allocated_tool_id(std::string* tool_id);
  private:
  const std::string& _internal_tool_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tool_id(const std::string& value);
  std::string* _internal_mutable_tool_id();
  public:

  // string tool_name = 2;
  void clear_tool_name();
  const std::string& tool_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tool_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tool_name();
  PROTOBUF_NODISCARD std::string* release_tool_name();
  void set_allocated_tool_name(std::string* tool_name);
  private:
  const std::string& _internal_tool_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tool_name(const std::string& value);
  std::string* _internal_mutable_tool_name();
  public:

  // .google.protobuf.Struct tool_arguments = 3;
  bool has_tool_arguments() const;
  private:
  bool _internal_has_tool_arguments() const;
  public:
  void clear_tool_arguments();
  const ::PROTOBUF_NAMESPACE_ID::Struct& tool_arguments() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_tool_arguments();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_tool_arguments();
  void set_allocated_tool_arguments(::PROTOBUF_NAMESPACE_ID::Struct* tool_arguments);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_tool_arguments() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_tool_arguments();
  public:
  void unsafe_arena_set_allocated_tool_arguments(
      ::PROTOBUF_NAMESPACE_ID::Struct* tool_arguments);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_tool_arguments();

  // @@protoc_insertion_point(class_scope:unhinged.messaging.ToolCall)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tool_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tool_name_;
    ::PROTOBUF_NAMESPACE_ID::Struct* tool_arguments_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messaging_2eproto;
};
// -------------------------------------------------------------------

class AgentMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.messaging.AgentMessage) */ {
 public:
  inline AgentMessage() : AgentMessage(nullptr) {}
  ~AgentMessage() override;
  explicit PROTOBUF_CONSTEXPR AgentMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AgentMessage(const AgentMessage& from);
  AgentMessage(AgentMessage&& from) noexcept
    : AgentMessage() {
    *this = ::std::move(from);
  }

  inline AgentMessage& operator=(const AgentMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AgentMessage& operator=(AgentMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AgentMessage& default_instance() {
    return *internal_default_instance();
  }
  enum MessageDataCase {
    kTaskRequest = 10,
    kTaskResponse = 11,
    kStepUpdate = 12,
    kCollaboration = 13,
    kAgentError = 14,
    MESSAGE_DATA_NOT_SET = 0,
  };

  static inline const AgentMessage* internal_default_instance() {
    return reinterpret_cast<const AgentMessage*>(
               &_AgentMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(AgentMessage& a, AgentMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(AgentMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AgentMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AgentMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AgentMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AgentMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AgentMessage& from) {
    AgentMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AgentMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.messaging.AgentMessage";
  }
  protected:
  explicit AgentMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAgentIdFieldNumber = 1,
    kExecutionIdFieldNumber = 2,
    kMessageTypeFieldNumber = 3,
    kTaskRequestFieldNumber = 10,
    kTaskResponseFieldNumber = 11,
    kStepUpdateFieldNumber = 12,
    kCollaborationFieldNumber = 13,
    kAgentErrorFieldNumber = 14,
  };
  // string agent_id = 1;
  void clear_agent_id();
  const std::string& agent_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_agent_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_agent_id();
  PROTOBUF_NODISCARD std::string* release_agent_id();
  void set_allocated_agent_id(std::string* agent_id);
  private:
  const std::string& _internal_agent_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_agent_id(const std::string& value);
  std::string* _internal_mutable_agent_id();
  public:

  // string execution_id = 2;
  void clear_execution_id();
  const std::string& execution_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_execution_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_execution_id();
  PROTOBUF_NODISCARD std::string* release_execution_id();
  void set_allocated_execution_id(std::string* execution_id);
  private:
  const std::string& _internal_execution_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_execution_id(const std::string& value);
  std::string* _internal_mutable_execution_id();
  public:

  // .unhinged.messaging.AgentMessageType message_type = 3;
  void clear_message_type();
  ::unhinged::messaging::AgentMessageType message_type() const;
  void set_message_type(::unhinged::messaging::AgentMessageType value);
  private:
  ::unhinged::messaging::AgentMessageType _internal_message_type() const;
  void _internal_set_message_type(::unhinged::messaging::AgentMessageType value);
  public:

  // .unhinged.messaging.AgentTaskRequest task_request = 10;
  bool has_task_request() const;
  private:
  bool _internal_has_task_request() const;
  public:
  void clear_task_request();
  const ::unhinged::messaging::AgentTaskRequest& task_request() const;
  PROTOBUF_NODISCARD ::unhinged::messaging::AgentTaskRequest* release_task_request();
  ::unhinged::messaging::AgentTaskRequest* mutable_task_request();
  void set_allocated_task_request(::unhinged::messaging::AgentTaskRequest* task_request);
  private:
  const ::unhinged::messaging::AgentTaskRequest& _internal_task_request() const;
  ::unhinged::messaging::AgentTaskRequest* _internal_mutable_task_request();
  public:
  void unsafe_arena_set_allocated_task_request(
      ::unhinged::messaging::AgentTaskRequest* task_request);
  ::unhinged::messaging::AgentTaskRequest* unsafe_arena_release_task_request();

  // .unhinged.messaging.AgentTaskResponse task_response = 11;
  bool has_task_response() const;
  private:
  bool _internal_has_task_response() const;
  public:
  void clear_task_response();
  const ::unhinged::messaging::AgentTaskResponse& task_response() const;
  PROTOBUF_NODISCARD ::unhinged::messaging::AgentTaskResponse* release_task_response();
  ::unhinged::messaging::AgentTaskResponse* mutable_task_response();
  void set_allocated_task_response(::unhinged::messaging::AgentTaskResponse* task_response);
  private:
  const ::unhinged::messaging::AgentTaskResponse& _internal_task_response() const;
  ::unhinged::messaging::AgentTaskResponse* _internal_mutable_task_response();
  public:
  void unsafe_arena_set_allocated_task_response(
      ::unhinged::messaging::AgentTaskResponse* task_response);
  ::unhinged::messaging::AgentTaskResponse* unsafe_arena_release_task_response();

  // .unhinged.messaging.AgentStepUpdate step_update = 12;
  bool has_step_update() const;
  private:
  bool _internal_has_step_update() const;
  public:
  void clear_step_update();
  const ::unhinged::messaging::AgentStepUpdate& step_update() const;
  PROTOBUF_NODISCARD ::unhinged::messaging::AgentStepUpdate* release_step_update();
  ::unhinged::messaging::AgentStepUpdate* mutable_step_update();
  void set_allocated_step_update(::unhinged::messaging::AgentStepUpdate* step_update);
  private:
  const ::unhinged::messaging::AgentStepUpdate& _internal_step_update() const;
  ::unhinged::messaging::AgentStepUpdate* _internal_mutable_step_update();
  public:
  void unsafe_arena_set_allocated_step_update(
      ::unhinged::messaging::AgentStepUpdate* step_update);
  ::unhinged::messaging::AgentStepUpdate* unsafe_arena_release_step_update();

  // .unhinged.messaging.AgentCollaboration collaboration = 13;
  bool has_collaboration() const;
  private:
  bool _internal_has_collaboration() const;
  public:
  void clear_collaboration();
  const ::unhinged::messaging::AgentCollaboration& collaboration() const;
  PROTOBUF_NODISCARD ::unhinged::messaging::AgentCollaboration* release_collaboration();
  ::unhinged::messaging::AgentCollaboration* mutable_collaboration();
  void set_allocated_collaboration(::unhinged::messaging::AgentCollaboration* collaboration);
  private:
  const ::unhinged::messaging::AgentCollaboration& _internal_collaboration() const;
  ::unhinged::messaging::AgentCollaboration* _internal_mutable_collaboration();
  public:
  void unsafe_arena_set_allocated_collaboration(
      ::unhinged::messaging::AgentCollaboration* collaboration);
  ::unhinged::messaging::AgentCollaboration* unsafe_arena_release_collaboration();

  // .unhinged.messaging.AgentError agent_error = 14;
  bool has_agent_error() const;
  private:
  bool _internal_has_agent_error() const;
  public:
  void clear_agent_error();
  const ::unhinged::messaging::AgentError& agent_error() const;
  PROTOBUF_NODISCARD ::unhinged::messaging::AgentError* release_agent_error();
  ::unhinged::messaging::AgentError* mutable_agent_error();
  void set_allocated_agent_error(::unhinged::messaging::AgentError* agent_error);
  private:
  const ::unhinged::messaging::AgentError& _internal_agent_error() const;
  ::unhinged::messaging::AgentError* _internal_mutable_agent_error();
  public:
  void unsafe_arena_set_allocated_agent_error(
      ::unhinged::messaging::AgentError* agent_error);
  ::unhinged::messaging::AgentError* unsafe_arena_release_agent_error();

  void clear_message_data();
  MessageDataCase message_data_case() const;
  // @@protoc_insertion_point(class_scope:unhinged.messaging.AgentMessage)
 private:
  class _Internal;
  void set_has_task_request();
  void set_has_task_response();
  void set_has_step_update();
  void set_has_collaboration();
  void set_has_agent_error();

  inline bool has_message_data() const;
  inline void clear_has_message_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr agent_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr execution_id_;
    int message_type_;
    union MessageDataUnion {
      constexpr MessageDataUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::unhinged::messaging::AgentTaskRequest* task_request_;
      ::unhinged::messaging::AgentTaskResponse* task_response_;
      ::unhinged::messaging::AgentStepUpdate* step_update_;
      ::unhinged::messaging::AgentCollaboration* collaboration_;
      ::unhinged::messaging::AgentError* agent_error_;
    } message_data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messaging_2eproto;
};
// -------------------------------------------------------------------

class AgentTaskRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.messaging.AgentTaskRequest) */ {
 public:
  inline AgentTaskRequest() : AgentTaskRequest(nullptr) {}
  ~AgentTaskRequest() override;
  explicit PROTOBUF_CONSTEXPR AgentTaskRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AgentTaskRequest(const AgentTaskRequest& from);
  AgentTaskRequest(AgentTaskRequest&& from) noexcept
    : AgentTaskRequest() {
    *this = ::std::move(from);
  }

  inline AgentTaskRequest& operator=(const AgentTaskRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AgentTaskRequest& operator=(AgentTaskRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AgentTaskRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AgentTaskRequest* internal_default_instance() {
    return reinterpret_cast<const AgentTaskRequest*>(
               &_AgentTaskRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(AgentTaskRequest& a, AgentTaskRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AgentTaskRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AgentTaskRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AgentTaskRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AgentTaskRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AgentTaskRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AgentTaskRequest& from) {
    AgentTaskRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AgentTaskRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.messaging.AgentTaskRequest";
  }
  protected:
  explicit AgentTaskRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequiredCapabilitiesFieldNumber = 4,
    kTaskDescriptionFieldNumber = 1,
    kTaskTypeFieldNumber = 2,
    kTaskParametersFieldNumber = 3,
    kContextFieldNumber = 5,
    kDeadlineFieldNumber = 7,
    kPriorityFieldNumber = 6,
  };
  // repeated string required_capabilities = 4;
  int required_capabilities_size() const;
  private:
  int _internal_required_capabilities_size() const;
  public:
  void clear_required_capabilities();
  const std::string& required_capabilities(int index) const;
  std::string* mutable_required_capabilities(int index);
  void set_required_capabilities(int index, const std::string& value);
  void set_required_capabilities(int index, std::string&& value);
  void set_required_capabilities(int index, const char* value);
  void set_required_capabilities(int index, const char* value, size_t size);
  std::string* add_required_capabilities();
  void add_required_capabilities(const std::string& value);
  void add_required_capabilities(std::string&& value);
  void add_required_capabilities(const char* value);
  void add_required_capabilities(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& required_capabilities() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_required_capabilities();
  private:
  const std::string& _internal_required_capabilities(int index) const;
  std::string* _internal_add_required_capabilities();
  public:

  // string task_description = 1;
  void clear_task_description();
  const std::string& task_description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_task_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_task_description();
  PROTOBUF_NODISCARD std::string* release_task_description();
  void set_allocated_task_description(std::string* task_description);
  private:
  const std::string& _internal_task_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_task_description(const std::string& value);
  std::string* _internal_mutable_task_description();
  public:

  // string task_type = 2;
  void clear_task_type();
  const std::string& task_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_task_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_task_type();
  PROTOBUF_NODISCARD std::string* release_task_type();
  void set_allocated_task_type(std::string* task_type);
  private:
  const std::string& _internal_task_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_task_type(const std::string& value);
  std::string* _internal_mutable_task_type();
  public:

  // .google.protobuf.Struct task_parameters = 3;
  bool has_task_parameters() const;
  private:
  bool _internal_has_task_parameters() const;
  public:
  void clear_task_parameters();
  const ::PROTOBUF_NAMESPACE_ID::Struct& task_parameters() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_task_parameters();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_task_parameters();
  void set_allocated_task_parameters(::PROTOBUF_NAMESPACE_ID::Struct* task_parameters);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_task_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_task_parameters();
  public:
  void unsafe_arena_set_allocated_task_parameters(
      ::PROTOBUF_NAMESPACE_ID::Struct* task_parameters);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_task_parameters();

  // .google.protobuf.Struct context = 5;
  bool has_context() const;
  private:
  bool _internal_has_context() const;
  public:
  void clear_context();
  const ::PROTOBUF_NAMESPACE_ID::Struct& context() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_context();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_context();
  void set_allocated_context(::PROTOBUF_NAMESPACE_ID::Struct* context);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_context() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_context();
  public:
  void unsafe_arena_set_allocated_context(
      ::PROTOBUF_NAMESPACE_ID::Struct* context);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_context();

  // .google.protobuf.Timestamp deadline = 7;
  bool has_deadline() const;
  private:
  bool _internal_has_deadline() const;
  public:
  void clear_deadline();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& deadline() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_deadline();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_deadline();
  void set_allocated_deadline(::PROTOBUF_NAMESPACE_ID::Timestamp* deadline);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_deadline() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_deadline();
  public:
  void unsafe_arena_set_allocated_deadline(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* deadline);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_deadline();

  // int32 priority = 6;
  void clear_priority();
  int32_t priority() const;
  void set_priority(int32_t value);
  private:
  int32_t _internal_priority() const;
  void _internal_set_priority(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.messaging.AgentTaskRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> required_capabilities_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr task_description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr task_type_;
    ::PROTOBUF_NAMESPACE_ID::Struct* task_parameters_;
    ::PROTOBUF_NAMESPACE_ID::Struct* context_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* deadline_;
    int32_t priority_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messaging_2eproto;
};
// -------------------------------------------------------------------

class AgentTaskResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.messaging.AgentTaskResponse) */ {
 public:
  inline AgentTaskResponse() : AgentTaskResponse(nullptr) {}
  ~AgentTaskResponse() override;
  explicit PROTOBUF_CONSTEXPR AgentTaskResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AgentTaskResponse(const AgentTaskResponse& from);
  AgentTaskResponse(AgentTaskResponse&& from) noexcept
    : AgentTaskResponse() {
    *this = ::std::move(from);
  }

  inline AgentTaskResponse& operator=(const AgentTaskResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AgentTaskResponse& operator=(AgentTaskResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AgentTaskResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AgentTaskResponse* internal_default_instance() {
    return reinterpret_cast<const AgentTaskResponse*>(
               &_AgentTaskResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(AgentTaskResponse& a, AgentTaskResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AgentTaskResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AgentTaskResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AgentTaskResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AgentTaskResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AgentTaskResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AgentTaskResponse& from) {
    AgentTaskResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AgentTaskResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.messaging.AgentTaskResponse";
  }
  protected:
  explicit AgentTaskResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArtifactsCreatedFieldNumber = 4,
    kStatusFieldNumber = 1,
    kCompletionMessageFieldNumber = 3,
    kResultFieldNumber = 2,
    kExecutionTimeMsFieldNumber = 5,
  };
  // repeated string artifacts_created = 4;
  int artifacts_created_size() const;
  private:
  int _internal_artifacts_created_size() const;
  public:
  void clear_artifacts_created();
  const std::string& artifacts_created(int index) const;
  std::string* mutable_artifacts_created(int index);
  void set_artifacts_created(int index, const std::string& value);
  void set_artifacts_created(int index, std::string&& value);
  void set_artifacts_created(int index, const char* value);
  void set_artifacts_created(int index, const char* value, size_t size);
  std::string* add_artifacts_created();
  void add_artifacts_created(const std::string& value);
  void add_artifacts_created(std::string&& value);
  void add_artifacts_created(const char* value);
  void add_artifacts_created(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& artifacts_created() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_artifacts_created();
  private:
  const std::string& _internal_artifacts_created(int index) const;
  std::string* _internal_add_artifacts_created();
  public:

  // string status = 1;
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // string completion_message = 3;
  void clear_completion_message();
  const std::string& completion_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_completion_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_completion_message();
  PROTOBUF_NODISCARD std::string* release_completion_message();
  void set_allocated_completion_message(std::string* completion_message);
  private:
  const std::string& _internal_completion_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_completion_message(const std::string& value);
  std::string* _internal_mutable_completion_message();
  public:

  // .google.protobuf.Struct result = 2;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::PROTOBUF_NAMESPACE_ID::Struct& result() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_result();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_result();
  void set_allocated_result(::PROTOBUF_NAMESPACE_ID::Struct* result);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_result() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::PROTOBUF_NAMESPACE_ID::Struct* result);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_result();

  // float execution_time_ms = 5;
  void clear_execution_time_ms();
  float execution_time_ms() const;
  void set_execution_time_ms(float value);
  private:
  float _internal_execution_time_ms() const;
  void _internal_set_execution_time_ms(float value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.messaging.AgentTaskResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> artifacts_created_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr completion_message_;
    ::PROTOBUF_NAMESPACE_ID::Struct* result_;
    float execution_time_ms_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messaging_2eproto;
};
// -------------------------------------------------------------------

class AgentStepUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.messaging.AgentStepUpdate) */ {
 public:
  inline AgentStepUpdate() : AgentStepUpdate(nullptr) {}
  ~AgentStepUpdate() override;
  explicit PROTOBUF_CONSTEXPR AgentStepUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AgentStepUpdate(const AgentStepUpdate& from);
  AgentStepUpdate(AgentStepUpdate&& from) noexcept
    : AgentStepUpdate() {
    *this = ::std::move(from);
  }

  inline AgentStepUpdate& operator=(const AgentStepUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline AgentStepUpdate& operator=(AgentStepUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AgentStepUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const AgentStepUpdate* internal_default_instance() {
    return reinterpret_cast<const AgentStepUpdate*>(
               &_AgentStepUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(AgentStepUpdate& a, AgentStepUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(AgentStepUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AgentStepUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AgentStepUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AgentStepUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AgentStepUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AgentStepUpdate& from) {
    AgentStepUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AgentStepUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.messaging.AgentStepUpdate";
  }
  protected:
  explicit AgentStepUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStepDescriptionFieldNumber = 2,
    kStepStatusFieldNumber = 3,
    kStepDataFieldNumber = 4,
    kStepNumberFieldNumber = 1,
    kProgressPercentageFieldNumber = 5,
  };
  // string step_description = 2;
  void clear_step_description();
  const std::string& step_description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_step_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_step_description();
  PROTOBUF_NODISCARD std::string* release_step_description();
  void set_allocated_step_description(std::string* step_description);
  private:
  const std::string& _internal_step_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_step_description(const std::string& value);
  std::string* _internal_mutable_step_description();
  public:

  // string step_status = 3;
  void clear_step_status();
  const std::string& step_status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_step_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_step_status();
  PROTOBUF_NODISCARD std::string* release_step_status();
  void set_allocated_step_status(std::string* step_status);
  private:
  const std::string& _internal_step_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_step_status(const std::string& value);
  std::string* _internal_mutable_step_status();
  public:

  // .google.protobuf.Struct step_data = 4;
  bool has_step_data() const;
  private:
  bool _internal_has_step_data() const;
  public:
  void clear_step_data();
  const ::PROTOBUF_NAMESPACE_ID::Struct& step_data() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_step_data();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_step_data();
  void set_allocated_step_data(::PROTOBUF_NAMESPACE_ID::Struct* step_data);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_step_data() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_step_data();
  public:
  void unsafe_arena_set_allocated_step_data(
      ::PROTOBUF_NAMESPACE_ID::Struct* step_data);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_step_data();

  // int32 step_number = 1;
  void clear_step_number();
  int32_t step_number() const;
  void set_step_number(int32_t value);
  private:
  int32_t _internal_step_number() const;
  void _internal_set_step_number(int32_t value);
  public:

  // float progress_percentage = 5;
  void clear_progress_percentage();
  float progress_percentage() const;
  void set_progress_percentage(float value);
  private:
  float _internal_progress_percentage() const;
  void _internal_set_progress_percentage(float value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.messaging.AgentStepUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr step_description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr step_status_;
    ::PROTOBUF_NAMESPACE_ID::Struct* step_data_;
    int32_t step_number_;
    float progress_percentage_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messaging_2eproto;
};
// -------------------------------------------------------------------

class AgentCollaboration final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.messaging.AgentCollaboration) */ {
 public:
  inline AgentCollaboration() : AgentCollaboration(nullptr) {}
  ~AgentCollaboration() override;
  explicit PROTOBUF_CONSTEXPR AgentCollaboration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AgentCollaboration(const AgentCollaboration& from);
  AgentCollaboration(AgentCollaboration&& from) noexcept
    : AgentCollaboration() {
    *this = ::std::move(from);
  }

  inline AgentCollaboration& operator=(const AgentCollaboration& from) {
    CopyFrom(from);
    return *this;
  }
  inline AgentCollaboration& operator=(AgentCollaboration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AgentCollaboration& default_instance() {
    return *internal_default_instance();
  }
  static inline const AgentCollaboration* internal_default_instance() {
    return reinterpret_cast<const AgentCollaboration*>(
               &_AgentCollaboration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(AgentCollaboration& a, AgentCollaboration& b) {
    a.Swap(&b);
  }
  inline void Swap(AgentCollaboration* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AgentCollaboration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AgentCollaboration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AgentCollaboration>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AgentCollaboration& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AgentCollaboration& from) {
    AgentCollaboration::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AgentCollaboration* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.messaging.AgentCollaboration";
  }
  protected:
  explicit AgentCollaboration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCollaborationTypeFieldNumber = 1,
    kTargetAgentIdFieldNumber = 2,
    kCollaborationDataFieldNumber = 3,
  };
  // string collaboration_type = 1;
  void clear_collaboration_type();
  const std::string& collaboration_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_collaboration_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_collaboration_type();
  PROTOBUF_NODISCARD std::string* release_collaboration_type();
  void set_allocated_collaboration_type(std::string* collaboration_type);
  private:
  const std::string& _internal_collaboration_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_collaboration_type(const std::string& value);
  std::string* _internal_mutable_collaboration_type();
  public:

  // string target_agent_id = 2;
  void clear_target_agent_id();
  const std::string& target_agent_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_target_agent_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_target_agent_id();
  PROTOBUF_NODISCARD std::string* release_target_agent_id();
  void set_allocated_target_agent_id(std::string* target_agent_id);
  private:
  const std::string& _internal_target_agent_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target_agent_id(const std::string& value);
  std::string* _internal_mutable_target_agent_id();
  public:

  // .google.protobuf.Struct collaboration_data = 3;
  bool has_collaboration_data() const;
  private:
  bool _internal_has_collaboration_data() const;
  public:
  void clear_collaboration_data();
  const ::PROTOBUF_NAMESPACE_ID::Struct& collaboration_data() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_collaboration_data();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_collaboration_data();
  void set_allocated_collaboration_data(::PROTOBUF_NAMESPACE_ID::Struct* collaboration_data);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_collaboration_data() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_collaboration_data();
  public:
  void unsafe_arena_set_allocated_collaboration_data(
      ::PROTOBUF_NAMESPACE_ID::Struct* collaboration_data);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_collaboration_data();

  // @@protoc_insertion_point(class_scope:unhinged.messaging.AgentCollaboration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr collaboration_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr target_agent_id_;
    ::PROTOBUF_NAMESPACE_ID::Struct* collaboration_data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messaging_2eproto;
};
// -------------------------------------------------------------------

class AgentError final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.messaging.AgentError) */ {
 public:
  inline AgentError() : AgentError(nullptr) {}
  ~AgentError() override;
  explicit PROTOBUF_CONSTEXPR AgentError(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AgentError(const AgentError& from);
  AgentError(AgentError&& from) noexcept
    : AgentError() {
    *this = ::std::move(from);
  }

  inline AgentError& operator=(const AgentError& from) {
    CopyFrom(from);
    return *this;
  }
  inline AgentError& operator=(AgentError&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AgentError& default_instance() {
    return *internal_default_instance();
  }
  static inline const AgentError* internal_default_instance() {
    return reinterpret_cast<const AgentError*>(
               &_AgentError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(AgentError& a, AgentError& b) {
    a.Swap(&b);
  }
  inline void Swap(AgentError* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AgentError* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AgentError* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AgentError>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AgentError& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AgentError& from) {
    AgentError::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AgentError* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.messaging.AgentError";
  }
  protected:
  explicit AgentError(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorCodeFieldNumber = 1,
    kErrorMessageFieldNumber = 2,
    kErrorContextFieldNumber = 3,
    kIsRecoverableFieldNumber = 4,
  };
  // string error_code = 1;
  void clear_error_code();
  const std::string& error_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_code();
  PROTOBUF_NODISCARD std::string* release_error_code();
  void set_allocated_error_code(std::string* error_code);
  private:
  const std::string& _internal_error_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_code(const std::string& value);
  std::string* _internal_mutable_error_code();
  public:

  // string error_message = 2;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // string error_context = 3;
  void clear_error_context();
  const std::string& error_context() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_context(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_context();
  PROTOBUF_NODISCARD std::string* release_error_context();
  void set_allocated_error_context(std::string* error_context);
  private:
  const std::string& _internal_error_context() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_context(const std::string& value);
  std::string* _internal_mutable_error_context();
  public:

  // bool is_recoverable = 4;
  void clear_is_recoverable();
  bool is_recoverable() const;
  void set_is_recoverable(bool value);
  private:
  bool _internal_is_recoverable() const;
  void _internal_set_is_recoverable(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.messaging.AgentError)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_code_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_context_;
    bool is_recoverable_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messaging_2eproto;
};
// -------------------------------------------------------------------

class ToolMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.messaging.ToolMessage) */ {
 public:
  inline ToolMessage() : ToolMessage(nullptr) {}
  ~ToolMessage() override;
  explicit PROTOBUF_CONSTEXPR ToolMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ToolMessage(const ToolMessage& from);
  ToolMessage(ToolMessage&& from) noexcept
    : ToolMessage() {
    *this = ::std::move(from);
  }

  inline ToolMessage& operator=(const ToolMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ToolMessage& operator=(ToolMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ToolMessage& default_instance() {
    return *internal_default_instance();
  }
  enum MessageDataCase {
    kInvocation = 10,
    kResult = 11,
    kToolError = 12,
    kRegistration = 13,
    MESSAGE_DATA_NOT_SET = 0,
  };

  static inline const ToolMessage* internal_default_instance() {
    return reinterpret_cast<const ToolMessage*>(
               &_ToolMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ToolMessage& a, ToolMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ToolMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ToolMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ToolMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ToolMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ToolMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ToolMessage& from) {
    ToolMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ToolMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.messaging.ToolMessage";
  }
  protected:
  explicit ToolMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kToolIdFieldNumber = 1,
    kToolNameFieldNumber = 2,
    kToolVersionFieldNumber = 3,
    kMessageTypeFieldNumber = 4,
    kInvocationFieldNumber = 10,
    kResultFieldNumber = 11,
    kToolErrorFieldNumber = 12,
    kRegistrationFieldNumber = 13,
  };
  // string tool_id = 1;
  void clear_tool_id();
  const std::string& tool_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tool_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tool_id();
  PROTOBUF_NODISCARD std::string* release_tool_id();
  void set_allocated_tool_id(std::string* tool_id);
  private:
  const std::string& _internal_tool_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tool_id(const std::string& value);
  std::string* _internal_mutable_tool_id();
  public:

  // string tool_name = 2;
  void clear_tool_name();
  const std::string& tool_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tool_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tool_name();
  PROTOBUF_NODISCARD std::string* release_tool_name();
  void set_allocated_tool_name(std::string* tool_name);
  private:
  const std::string& _internal_tool_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tool_name(const std::string& value);
  std::string* _internal_mutable_tool_name();
  public:

  // string tool_version = 3;
  void clear_tool_version();
  const std::string& tool_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tool_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tool_version();
  PROTOBUF_NODISCARD std::string* release_tool_version();
  void set_allocated_tool_version(std::string* tool_version);
  private:
  const std::string& _internal_tool_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tool_version(const std::string& value);
  std::string* _internal_mutable_tool_version();
  public:

  // .unhinged.messaging.ToolMessageType message_type = 4;
  void clear_message_type();
  ::unhinged::messaging::ToolMessageType message_type() const;
  void set_message_type(::unhinged::messaging::ToolMessageType value);
  private:
  ::unhinged::messaging::ToolMessageType _internal_message_type() const;
  void _internal_set_message_type(::unhinged::messaging::ToolMessageType value);
  public:

  // .unhinged.messaging.ToolInvocation invocation = 10;
  bool has_invocation() const;
  private:
  bool _internal_has_invocation() const;
  public:
  void clear_invocation();
  const ::unhinged::messaging::ToolInvocation& invocation() const;
  PROTOBUF_NODISCARD ::unhinged::messaging::ToolInvocation* release_invocation();
  ::unhinged::messaging::ToolInvocation* mutable_invocation();
  void set_allocated_invocation(::unhinged::messaging::ToolInvocation* invocation);
  private:
  const ::unhinged::messaging::ToolInvocation& _internal_invocation() const;
  ::unhinged::messaging::ToolInvocation* _internal_mutable_invocation();
  public:
  void unsafe_arena_set_allocated_invocation(
      ::unhinged::messaging::ToolInvocation* invocation);
  ::unhinged::messaging::ToolInvocation* unsafe_arena_release_invocation();

  // .unhinged.messaging.ToolResult result = 11;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::unhinged::messaging::ToolResult& result() const;
  PROTOBUF_NODISCARD ::unhinged::messaging::ToolResult* release_result();
  ::unhinged::messaging::ToolResult* mutable_result();
  void set_allocated_result(::unhinged::messaging::ToolResult* result);
  private:
  const ::unhinged::messaging::ToolResult& _internal_result() const;
  ::unhinged::messaging::ToolResult* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::unhinged::messaging::ToolResult* result);
  ::unhinged::messaging::ToolResult* unsafe_arena_release_result();

  // .unhinged.messaging.ToolError tool_error = 12;
  bool has_tool_error() const;
  private:
  bool _internal_has_tool_error() const;
  public:
  void clear_tool_error();
  const ::unhinged::messaging::ToolError& tool_error() const;
  PROTOBUF_NODISCARD ::unhinged::messaging::ToolError* release_tool_error();
  ::unhinged::messaging::ToolError* mutable_tool_error();
  void set_allocated_tool_error(::unhinged::messaging::ToolError* tool_error);
  private:
  const ::unhinged::messaging::ToolError& _internal_tool_error() const;
  ::unhinged::messaging::ToolError* _internal_mutable_tool_error();
  public:
  void unsafe_arena_set_allocated_tool_error(
      ::unhinged::messaging::ToolError* tool_error);
  ::unhinged::messaging::ToolError* unsafe_arena_release_tool_error();

  // .unhinged.messaging.ToolRegistration registration = 13;
  bool has_registration() const;
  private:
  bool _internal_has_registration() const;
  public:
  void clear_registration();
  const ::unhinged::messaging::ToolRegistration& registration() const;
  PROTOBUF_NODISCARD ::unhinged::messaging::ToolRegistration* release_registration();
  ::unhinged::messaging::ToolRegistration* mutable_registration();
  void set_allocated_registration(::unhinged::messaging::ToolRegistration* registration);
  private:
  const ::unhinged::messaging::ToolRegistration& _internal_registration() const;
  ::unhinged::messaging::ToolRegistration* _internal_mutable_registration();
  public:
  void unsafe_arena_set_allocated_registration(
      ::unhinged::messaging::ToolRegistration* registration);
  ::unhinged::messaging::ToolRegistration* unsafe_arena_release_registration();

  void clear_message_data();
  MessageDataCase message_data_case() const;
  // @@protoc_insertion_point(class_scope:unhinged.messaging.ToolMessage)
 private:
  class _Internal;
  void set_has_invocation();
  void set_has_result();
  void set_has_tool_error();
  void set_has_registration();

  inline bool has_message_data() const;
  inline void clear_has_message_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tool_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tool_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tool_version_;
    int message_type_;
    union MessageDataUnion {
      constexpr MessageDataUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::unhinged::messaging::ToolInvocation* invocation_;
      ::unhinged::messaging::ToolResult* result_;
      ::unhinged::messaging::ToolError* tool_error_;
      ::unhinged::messaging::ToolRegistration* registration_;
    } message_data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messaging_2eproto;
};
// -------------------------------------------------------------------

class ToolInvocation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.messaging.ToolInvocation) */ {
 public:
  inline ToolInvocation() : ToolInvocation(nullptr) {}
  ~ToolInvocation() override;
  explicit PROTOBUF_CONSTEXPR ToolInvocation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ToolInvocation(const ToolInvocation& from);
  ToolInvocation(ToolInvocation&& from) noexcept
    : ToolInvocation() {
    *this = ::std::move(from);
  }

  inline ToolInvocation& operator=(const ToolInvocation& from) {
    CopyFrom(from);
    return *this;
  }
  inline ToolInvocation& operator=(ToolInvocation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ToolInvocation& default_instance() {
    return *internal_default_instance();
  }
  static inline const ToolInvocation* internal_default_instance() {
    return reinterpret_cast<const ToolInvocation*>(
               &_ToolInvocation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ToolInvocation& a, ToolInvocation& b) {
    a.Swap(&b);
  }
  inline void Swap(ToolInvocation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ToolInvocation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ToolInvocation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ToolInvocation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ToolInvocation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ToolInvocation& from) {
    ToolInvocation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ToolInvocation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.messaging.ToolInvocation";
  }
  protected:
  explicit ToolInvocation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInvocationIdFieldNumber = 1,
    kArgumentsFieldNumber = 2,
    kContextFieldNumber = 3,
    kTimeoutSecondsFieldNumber = 4,
  };
  // string invocation_id = 1;
  void clear_invocation_id();
  const std::string& invocation_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_invocation_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_invocation_id();
  PROTOBUF_NODISCARD std::string* release_invocation_id();
  void set_allocated_invocation_id(std::string* invocation_id);
  private:
  const std::string& _internal_invocation_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_invocation_id(const std::string& value);
  std::string* _internal_mutable_invocation_id();
  public:

  // .google.protobuf.Struct arguments = 2;
  bool has_arguments() const;
  private:
  bool _internal_has_arguments() const;
  public:
  void clear_arguments();
  const ::PROTOBUF_NAMESPACE_ID::Struct& arguments() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_arguments();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_arguments();
  void set_allocated_arguments(::PROTOBUF_NAMESPACE_ID::Struct* arguments);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_arguments() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_arguments();
  public:
  void unsafe_arena_set_allocated_arguments(
      ::PROTOBUF_NAMESPACE_ID::Struct* arguments);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_arguments();

  // .google.protobuf.Struct context = 3;
  bool has_context() const;
  private:
  bool _internal_has_context() const;
  public:
  void clear_context();
  const ::PROTOBUF_NAMESPACE_ID::Struct& context() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_context();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_context();
  void set_allocated_context(::PROTOBUF_NAMESPACE_ID::Struct* context);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_context() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_context();
  public:
  void unsafe_arena_set_allocated_context(
      ::PROTOBUF_NAMESPACE_ID::Struct* context);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_context();

  // int32 timeout_seconds = 4;
  void clear_timeout_seconds();
  int32_t timeout_seconds() const;
  void set_timeout_seconds(int32_t value);
  private:
  int32_t _internal_timeout_seconds() const;
  void _internal_set_timeout_seconds(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.messaging.ToolInvocation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr invocation_id_;
    ::PROTOBUF_NAMESPACE_ID::Struct* arguments_;
    ::PROTOBUF_NAMESPACE_ID::Struct* context_;
    int32_t timeout_seconds_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messaging_2eproto;
};
// -------------------------------------------------------------------

class ToolResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.messaging.ToolResult) */ {
 public:
  inline ToolResult() : ToolResult(nullptr) {}
  ~ToolResult() override;
  explicit PROTOBUF_CONSTEXPR ToolResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ToolResult(const ToolResult& from);
  ToolResult(ToolResult&& from) noexcept
    : ToolResult() {
    *this = ::std::move(from);
  }

  inline ToolResult& operator=(const ToolResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline ToolResult& operator=(ToolResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ToolResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const ToolResult* internal_default_instance() {
    return reinterpret_cast<const ToolResult*>(
               &_ToolResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ToolResult& a, ToolResult& b) {
    a.Swap(&b);
  }
  inline void Swap(ToolResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ToolResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ToolResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ToolResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ToolResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ToolResult& from) {
    ToolResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ToolResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.messaging.ToolResult";
  }
  protected:
  explicit ToolResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArtifactsFieldNumber = 5,
    kInvocationIdFieldNumber = 1,
    kResultTextFieldNumber = 4,
    kResultDataFieldNumber = 3,
    kSuccessFieldNumber = 2,
    kExecutionTimeMsFieldNumber = 6,
  };
  // repeated string artifacts = 5;
  int artifacts_size() const;
  private:
  int _internal_artifacts_size() const;
  public:
  void clear_artifacts();
  const std::string& artifacts(int index) const;
  std::string* mutable_artifacts(int index);
  void set_artifacts(int index, const std::string& value);
  void set_artifacts(int index, std::string&& value);
  void set_artifacts(int index, const char* value);
  void set_artifacts(int index, const char* value, size_t size);
  std::string* add_artifacts();
  void add_artifacts(const std::string& value);
  void add_artifacts(std::string&& value);
  void add_artifacts(const char* value);
  void add_artifacts(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& artifacts() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_artifacts();
  private:
  const std::string& _internal_artifacts(int index) const;
  std::string* _internal_add_artifacts();
  public:

  // string invocation_id = 1;
  void clear_invocation_id();
  const std::string& invocation_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_invocation_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_invocation_id();
  PROTOBUF_NODISCARD std::string* release_invocation_id();
  void set_allocated_invocation_id(std::string* invocation_id);
  private:
  const std::string& _internal_invocation_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_invocation_id(const std::string& value);
  std::string* _internal_mutable_invocation_id();
  public:

  // string result_text = 4;
  void clear_result_text();
  const std::string& result_text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_result_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_result_text();
  PROTOBUF_NODISCARD std::string* release_result_text();
  void set_allocated_result_text(std::string* result_text);
  private:
  const std::string& _internal_result_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_result_text(const std::string& value);
  std::string* _internal_mutable_result_text();
  public:

  // .google.protobuf.Any result_data = 3;
  bool has_result_data() const;
  private:
  bool _internal_has_result_data() const;
  public:
  void clear_result_data();
  const ::PROTOBUF_NAMESPACE_ID::Any& result_data() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Any* release_result_data();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_result_data();
  void set_allocated_result_data(::PROTOBUF_NAMESPACE_ID::Any* result_data);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_result_data() const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_mutable_result_data();
  public:
  void unsafe_arena_set_allocated_result_data(
      ::PROTOBUF_NAMESPACE_ID::Any* result_data);
  ::PROTOBUF_NAMESPACE_ID::Any* unsafe_arena_release_result_data();

  // bool success = 2;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // float execution_time_ms = 6;
  void clear_execution_time_ms();
  float execution_time_ms() const;
  void set_execution_time_ms(float value);
  private:
  float _internal_execution_time_ms() const;
  void _internal_set_execution_time_ms(float value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.messaging.ToolResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> artifacts_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr invocation_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr result_text_;
    ::PROTOBUF_NAMESPACE_ID::Any* result_data_;
    bool success_;
    float execution_time_ms_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messaging_2eproto;
};
// -------------------------------------------------------------------

class ToolError final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.messaging.ToolError) */ {
 public:
  inline ToolError() : ToolError(nullptr) {}
  ~ToolError() override;
  explicit PROTOBUF_CONSTEXPR ToolError(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ToolError(const ToolError& from);
  ToolError(ToolError&& from) noexcept
    : ToolError() {
    *this = ::std::move(from);
  }

  inline ToolError& operator=(const ToolError& from) {
    CopyFrom(from);
    return *this;
  }
  inline ToolError& operator=(ToolError&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ToolError& default_instance() {
    return *internal_default_instance();
  }
  static inline const ToolError* internal_default_instance() {
    return reinterpret_cast<const ToolError*>(
               &_ToolError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ToolError& a, ToolError& b) {
    a.Swap(&b);
  }
  inline void Swap(ToolError* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ToolError* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ToolError* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ToolError>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ToolError& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ToolError& from) {
    ToolError::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ToolError* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.messaging.ToolError";
  }
  protected:
  explicit ToolError(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInvocationIdFieldNumber = 1,
    kErrorCodeFieldNumber = 2,
    kErrorMessageFieldNumber = 3,
    kIsRetryableFieldNumber = 4,
  };
  // string invocation_id = 1;
  void clear_invocation_id();
  const std::string& invocation_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_invocation_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_invocation_id();
  PROTOBUF_NODISCARD std::string* release_invocation_id();
  void set_allocated_invocation_id(std::string* invocation_id);
  private:
  const std::string& _internal_invocation_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_invocation_id(const std::string& value);
  std::string* _internal_mutable_invocation_id();
  public:

  // string error_code = 2;
  void clear_error_code();
  const std::string& error_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_code();
  PROTOBUF_NODISCARD std::string* release_error_code();
  void set_allocated_error_code(std::string* error_code);
  private:
  const std::string& _internal_error_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_code(const std::string& value);
  std::string* _internal_mutable_error_code();
  public:

  // string error_message = 3;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // bool is_retryable = 4;
  void clear_is_retryable();
  bool is_retryable() const;
  void set_is_retryable(bool value);
  private:
  bool _internal_is_retryable() const;
  void _internal_set_is_retryable(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.messaging.ToolError)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr invocation_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_code_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    bool is_retryable_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messaging_2eproto;
};
// -------------------------------------------------------------------

class ToolRegistration final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.messaging.ToolRegistration) */ {
 public:
  inline ToolRegistration() : ToolRegistration(nullptr) {}
  ~ToolRegistration() override;
  explicit PROTOBUF_CONSTEXPR ToolRegistration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ToolRegistration(const ToolRegistration& from);
  ToolRegistration(ToolRegistration&& from) noexcept
    : ToolRegistration() {
    *this = ::std::move(from);
  }

  inline ToolRegistration& operator=(const ToolRegistration& from) {
    CopyFrom(from);
    return *this;
  }
  inline ToolRegistration& operator=(ToolRegistration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ToolRegistration& default_instance() {
    return *internal_default_instance();
  }
  static inline const ToolRegistration* internal_default_instance() {
    return reinterpret_cast<const ToolRegistration*>(
               &_ToolRegistration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(ToolRegistration& a, ToolRegistration& b) {
    a.Swap(&b);
  }
  inline void Swap(ToolRegistration* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ToolRegistration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ToolRegistration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ToolRegistration>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ToolRegistration& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ToolRegistration& from) {
    ToolRegistration::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ToolRegistration* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.messaging.ToolRegistration";
  }
  protected:
  explicit ToolRegistration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCapabilitiesFieldNumber = 5,
    kToolNameFieldNumber = 1,
    kToolVersionFieldNumber = 2,
    kDescriptionFieldNumber = 3,
    kEndpointUrlFieldNumber = 6,
    kSchemaFieldNumber = 4,
  };
  // repeated string capabilities = 5;
  int capabilities_size() const;
  private:
  int _internal_capabilities_size() const;
  public:
  void clear_capabilities();
  const std::string& capabilities(int index) const;
  std::string* mutable_capabilities(int index);
  void set_capabilities(int index, const std::string& value);
  void set_capabilities(int index, std::string&& value);
  void set_capabilities(int index, const char* value);
  void set_capabilities(int index, const char* value, size_t size);
  std::string* add_capabilities();
  void add_capabilities(const std::string& value);
  void add_capabilities(std::string&& value);
  void add_capabilities(const char* value);
  void add_capabilities(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& capabilities() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_capabilities();
  private:
  const std::string& _internal_capabilities(int index) const;
  std::string* _internal_add_capabilities();
  public:

  // string tool_name = 1;
  void clear_tool_name();
  const std::string& tool_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tool_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tool_name();
  PROTOBUF_NODISCARD std::string* release_tool_name();
  void set_allocated_tool_name(std::string* tool_name);
  private:
  const std::string& _internal_tool_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tool_name(const std::string& value);
  std::string* _internal_mutable_tool_name();
  public:

  // string tool_version = 2;
  void clear_tool_version();
  const std::string& tool_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tool_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tool_version();
  PROTOBUF_NODISCARD std::string* release_tool_version();
  void set_allocated_tool_version(std::string* tool_version);
  private:
  const std::string& _internal_tool_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tool_version(const std::string& value);
  std::string* _internal_mutable_tool_version();
  public:

  // string description = 3;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string endpoint_url = 6;
  void clear_endpoint_url();
  const std::string& endpoint_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_endpoint_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_endpoint_url();
  PROTOBUF_NODISCARD std::string* release_endpoint_url();
  void set_allocated_endpoint_url(std::string* endpoint_url);
  private:
  const std::string& _internal_endpoint_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_endpoint_url(const std::string& value);
  std::string* _internal_mutable_endpoint_url();
  public:

  // .google.protobuf.Struct schema = 4;
  bool has_schema() const;
  private:
  bool _internal_has_schema() const;
  public:
  void clear_schema();
  const ::PROTOBUF_NAMESPACE_ID::Struct& schema() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_schema();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_schema();
  void set_allocated_schema(::PROTOBUF_NAMESPACE_ID::Struct* schema);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_schema() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_schema();
  public:
  void unsafe_arena_set_allocated_schema(
      ::PROTOBUF_NAMESPACE_ID::Struct* schema);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_schema();

  // @@protoc_insertion_point(class_scope:unhinged.messaging.ToolRegistration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> capabilities_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tool_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tool_version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr endpoint_url_;
    ::PROTOBUF_NAMESPACE_ID::Struct* schema_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messaging_2eproto;
};
// -------------------------------------------------------------------

class WorkflowMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.messaging.WorkflowMessage) */ {
 public:
  inline WorkflowMessage() : WorkflowMessage(nullptr) {}
  ~WorkflowMessage() override;
  explicit PROTOBUF_CONSTEXPR WorkflowMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WorkflowMessage(const WorkflowMessage& from);
  WorkflowMessage(WorkflowMessage&& from) noexcept
    : WorkflowMessage() {
    *this = ::std::move(from);
  }

  inline WorkflowMessage& operator=(const WorkflowMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkflowMessage& operator=(WorkflowMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkflowMessage& default_instance() {
    return *internal_default_instance();
  }
  enum MessageDataCase {
    kTrigger = 10,
    kStepExecution = 11,
    kCompletion = 12,
    kControl = 13,
    MESSAGE_DATA_NOT_SET = 0,
  };

  static inline const WorkflowMessage* internal_default_instance() {
    return reinterpret_cast<const WorkflowMessage*>(
               &_WorkflowMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(WorkflowMessage& a, WorkflowMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkflowMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkflowMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorkflowMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WorkflowMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WorkflowMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WorkflowMessage& from) {
    WorkflowMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkflowMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.messaging.WorkflowMessage";
  }
  protected:
  explicit WorkflowMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWorkflowIdFieldNumber = 1,
    kExecutionIdFieldNumber = 2,
    kMessageTypeFieldNumber = 3,
    kTriggerFieldNumber = 10,
    kStepExecutionFieldNumber = 11,
    kCompletionFieldNumber = 12,
    kControlFieldNumber = 13,
  };
  // string workflow_id = 1;
  void clear_workflow_id();
  const std::string& workflow_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_workflow_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_workflow_id();
  PROTOBUF_NODISCARD std::string* release_workflow_id();
  void set_allocated_workflow_id(std::string* workflow_id);
  private:
  const std::string& _internal_workflow_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_workflow_id(const std::string& value);
  std::string* _internal_mutable_workflow_id();
  public:

  // string execution_id = 2;
  void clear_execution_id();
  const std::string& execution_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_execution_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_execution_id();
  PROTOBUF_NODISCARD std::string* release_execution_id();
  void set_allocated_execution_id(std::string* execution_id);
  private:
  const std::string& _internal_execution_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_execution_id(const std::string& value);
  std::string* _internal_mutable_execution_id();
  public:

  // .unhinged.messaging.WorkflowMessageType message_type = 3;
  void clear_message_type();
  ::unhinged::messaging::WorkflowMessageType message_type() const;
  void set_message_type(::unhinged::messaging::WorkflowMessageType value);
  private:
  ::unhinged::messaging::WorkflowMessageType _internal_message_type() const;
  void _internal_set_message_type(::unhinged::messaging::WorkflowMessageType value);
  public:

  // .unhinged.messaging.WorkflowTrigger trigger = 10;
  bool has_trigger() const;
  private:
  bool _internal_has_trigger() const;
  public:
  void clear_trigger();
  const ::unhinged::messaging::WorkflowTrigger& trigger() const;
  PROTOBUF_NODISCARD ::unhinged::messaging::WorkflowTrigger* release_trigger();
  ::unhinged::messaging::WorkflowTrigger* mutable_trigger();
  void set_allocated_trigger(::unhinged::messaging::WorkflowTrigger* trigger);
  private:
  const ::unhinged::messaging::WorkflowTrigger& _internal_trigger() const;
  ::unhinged::messaging::WorkflowTrigger* _internal_mutable_trigger();
  public:
  void unsafe_arena_set_allocated_trigger(
      ::unhinged::messaging::WorkflowTrigger* trigger);
  ::unhinged::messaging::WorkflowTrigger* unsafe_arena_release_trigger();

  // .unhinged.messaging.WorkflowStepExecution step_execution = 11;
  bool has_step_execution() const;
  private:
  bool _internal_has_step_execution() const;
  public:
  void clear_step_execution();
  const ::unhinged::messaging::WorkflowStepExecution& step_execution() const;
  PROTOBUF_NODISCARD ::unhinged::messaging::WorkflowStepExecution* release_step_execution();
  ::unhinged::messaging::WorkflowStepExecution* mutable_step_execution();
  void set_allocated_step_execution(::unhinged::messaging::WorkflowStepExecution* step_execution);
  private:
  const ::unhinged::messaging::WorkflowStepExecution& _internal_step_execution() const;
  ::unhinged::messaging::WorkflowStepExecution* _internal_mutable_step_execution();
  public:
  void unsafe_arena_set_allocated_step_execution(
      ::unhinged::messaging::WorkflowStepExecution* step_execution);
  ::unhinged::messaging::WorkflowStepExecution* unsafe_arena_release_step_execution();

  // .unhinged.messaging.WorkflowCompletion completion = 12;
  bool has_completion() const;
  private:
  bool _internal_has_completion() const;
  public:
  void clear_completion();
  const ::unhinged::messaging::WorkflowCompletion& completion() const;
  PROTOBUF_NODISCARD ::unhinged::messaging::WorkflowCompletion* release_completion();
  ::unhinged::messaging::WorkflowCompletion* mutable_completion();
  void set_allocated_completion(::unhinged::messaging::WorkflowCompletion* completion);
  private:
  const ::unhinged::messaging::WorkflowCompletion& _internal_completion() const;
  ::unhinged::messaging::WorkflowCompletion* _internal_mutable_completion();
  public:
  void unsafe_arena_set_allocated_completion(
      ::unhinged::messaging::WorkflowCompletion* completion);
  ::unhinged::messaging::WorkflowCompletion* unsafe_arena_release_completion();

  // .unhinged.messaging.WorkflowControl control = 13;
  bool has_control() const;
  private:
  bool _internal_has_control() const;
  public:
  void clear_control();
  const ::unhinged::messaging::WorkflowControl& control() const;
  PROTOBUF_NODISCARD ::unhinged::messaging::WorkflowControl* release_control();
  ::unhinged::messaging::WorkflowControl* mutable_control();
  void set_allocated_control(::unhinged::messaging::WorkflowControl* control);
  private:
  const ::unhinged::messaging::WorkflowControl& _internal_control() const;
  ::unhinged::messaging::WorkflowControl* _internal_mutable_control();
  public:
  void unsafe_arena_set_allocated_control(
      ::unhinged::messaging::WorkflowControl* control);
  ::unhinged::messaging::WorkflowControl* unsafe_arena_release_control();

  void clear_message_data();
  MessageDataCase message_data_case() const;
  // @@protoc_insertion_point(class_scope:unhinged.messaging.WorkflowMessage)
 private:
  class _Internal;
  void set_has_trigger();
  void set_has_step_execution();
  void set_has_completion();
  void set_has_control();

  inline bool has_message_data() const;
  inline void clear_has_message_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr workflow_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr execution_id_;
    int message_type_;
    union MessageDataUnion {
      constexpr MessageDataUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::unhinged::messaging::WorkflowTrigger* trigger_;
      ::unhinged::messaging::WorkflowStepExecution* step_execution_;
      ::unhinged::messaging::WorkflowCompletion* completion_;
      ::unhinged::messaging::WorkflowControl* control_;
    } message_data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messaging_2eproto;
};
// -------------------------------------------------------------------

class WorkflowTrigger final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.messaging.WorkflowTrigger) */ {
 public:
  inline WorkflowTrigger() : WorkflowTrigger(nullptr) {}
  ~WorkflowTrigger() override;
  explicit PROTOBUF_CONSTEXPR WorkflowTrigger(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WorkflowTrigger(const WorkflowTrigger& from);
  WorkflowTrigger(WorkflowTrigger&& from) noexcept
    : WorkflowTrigger() {
    *this = ::std::move(from);
  }

  inline WorkflowTrigger& operator=(const WorkflowTrigger& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkflowTrigger& operator=(WorkflowTrigger&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkflowTrigger& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorkflowTrigger* internal_default_instance() {
    return reinterpret_cast<const WorkflowTrigger*>(
               &_WorkflowTrigger_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(WorkflowTrigger& a, WorkflowTrigger& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkflowTrigger* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkflowTrigger* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorkflowTrigger* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WorkflowTrigger>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WorkflowTrigger& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WorkflowTrigger& from) {
    WorkflowTrigger::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkflowTrigger* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.messaging.WorkflowTrigger";
  }
  protected:
  explicit WorkflowTrigger(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTriggerTypeFieldNumber = 1,
    kTriggerSourceFieldNumber = 2,
    kTriggerDataFieldNumber = 3,
    kInitialContextFieldNumber = 4,
  };
  // string trigger_type = 1;
  void clear_trigger_type();
  const std::string& trigger_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_trigger_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_trigger_type();
  PROTOBUF_NODISCARD std::string* release_trigger_type();
  void set_allocated_trigger_type(std::string* trigger_type);
  private:
  const std::string& _internal_trigger_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trigger_type(const std::string& value);
  std::string* _internal_mutable_trigger_type();
  public:

  // string trigger_source = 2;
  void clear_trigger_source();
  const std::string& trigger_source() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_trigger_source(ArgT0&& arg0, ArgT... args);
  std::string* mutable_trigger_source();
  PROTOBUF_NODISCARD std::string* release_trigger_source();
  void set_allocated_trigger_source(std::string* trigger_source);
  private:
  const std::string& _internal_trigger_source() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trigger_source(const std::string& value);
  std::string* _internal_mutable_trigger_source();
  public:

  // .google.protobuf.Struct trigger_data = 3;
  bool has_trigger_data() const;
  private:
  bool _internal_has_trigger_data() const;
  public:
  void clear_trigger_data();
  const ::PROTOBUF_NAMESPACE_ID::Struct& trigger_data() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_trigger_data();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_trigger_data();
  void set_allocated_trigger_data(::PROTOBUF_NAMESPACE_ID::Struct* trigger_data);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_trigger_data() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_trigger_data();
  public:
  void unsafe_arena_set_allocated_trigger_data(
      ::PROTOBUF_NAMESPACE_ID::Struct* trigger_data);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_trigger_data();

  // .google.protobuf.Struct initial_context = 4;
  bool has_initial_context() const;
  private:
  bool _internal_has_initial_context() const;
  public:
  void clear_initial_context();
  const ::PROTOBUF_NAMESPACE_ID::Struct& initial_context() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_initial_context();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_initial_context();
  void set_allocated_initial_context(::PROTOBUF_NAMESPACE_ID::Struct* initial_context);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_initial_context() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_initial_context();
  public:
  void unsafe_arena_set_allocated_initial_context(
      ::PROTOBUF_NAMESPACE_ID::Struct* initial_context);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_initial_context();

  // @@protoc_insertion_point(class_scope:unhinged.messaging.WorkflowTrigger)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trigger_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trigger_source_;
    ::PROTOBUF_NAMESPACE_ID::Struct* trigger_data_;
    ::PROTOBUF_NAMESPACE_ID::Struct* initial_context_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messaging_2eproto;
};
// -------------------------------------------------------------------

class WorkflowStepExecution final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.messaging.WorkflowStepExecution) */ {
 public:
  inline WorkflowStepExecution() : WorkflowStepExecution(nullptr) {}
  ~WorkflowStepExecution() override;
  explicit PROTOBUF_CONSTEXPR WorkflowStepExecution(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WorkflowStepExecution(const WorkflowStepExecution& from);
  WorkflowStepExecution(WorkflowStepExecution&& from) noexcept
    : WorkflowStepExecution() {
    *this = ::std::move(from);
  }

  inline WorkflowStepExecution& operator=(const WorkflowStepExecution& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkflowStepExecution& operator=(WorkflowStepExecution&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkflowStepExecution& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorkflowStepExecution* internal_default_instance() {
    return reinterpret_cast<const WorkflowStepExecution*>(
               &_WorkflowStepExecution_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(WorkflowStepExecution& a, WorkflowStepExecution& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkflowStepExecution* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkflowStepExecution* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorkflowStepExecution* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WorkflowStepExecution>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WorkflowStepExecution& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WorkflowStepExecution& from) {
    WorkflowStepExecution::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkflowStepExecution* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.messaging.WorkflowStepExecution";
  }
  protected:
  explicit WorkflowStepExecution(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStepIdFieldNumber = 1,
    kStepTypeFieldNumber = 2,
    kStepStatusFieldNumber = 3,
    kNextStepIdFieldNumber = 6,
    kStepInputFieldNumber = 4,
    kStepOutputFieldNumber = 5,
  };
  // string step_id = 1;
  void clear_step_id();
  const std::string& step_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_step_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_step_id();
  PROTOBUF_NODISCARD std::string* release_step_id();
  void set_allocated_step_id(std::string* step_id);
  private:
  const std::string& _internal_step_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_step_id(const std::string& value);
  std::string* _internal_mutable_step_id();
  public:

  // string step_type = 2;
  void clear_step_type();
  const std::string& step_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_step_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_step_type();
  PROTOBUF_NODISCARD std::string* release_step_type();
  void set_allocated_step_type(std::string* step_type);
  private:
  const std::string& _internal_step_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_step_type(const std::string& value);
  std::string* _internal_mutable_step_type();
  public:

  // string step_status = 3;
  void clear_step_status();
  const std::string& step_status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_step_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_step_status();
  PROTOBUF_NODISCARD std::string* release_step_status();
  void set_allocated_step_status(std::string* step_status);
  private:
  const std::string& _internal_step_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_step_status(const std::string& value);
  std::string* _internal_mutable_step_status();
  public:

  // string next_step_id = 6;
  void clear_next_step_id();
  const std::string& next_step_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_step_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_step_id();
  PROTOBUF_NODISCARD std::string* release_next_step_id();
  void set_allocated_next_step_id(std::string* next_step_id);
  private:
  const std::string& _internal_next_step_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_step_id(const std::string& value);
  std::string* _internal_mutable_next_step_id();
  public:

  // .google.protobuf.Struct step_input = 4;
  bool has_step_input() const;
  private:
  bool _internal_has_step_input() const;
  public:
  void clear_step_input();
  const ::PROTOBUF_NAMESPACE_ID::Struct& step_input() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_step_input();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_step_input();
  void set_allocated_step_input(::PROTOBUF_NAMESPACE_ID::Struct* step_input);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_step_input() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_step_input();
  public:
  void unsafe_arena_set_allocated_step_input(
      ::PROTOBUF_NAMESPACE_ID::Struct* step_input);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_step_input();

  // .google.protobuf.Struct step_output = 5;
  bool has_step_output() const;
  private:
  bool _internal_has_step_output() const;
  public:
  void clear_step_output();
  const ::PROTOBUF_NAMESPACE_ID::Struct& step_output() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_step_output();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_step_output();
  void set_allocated_step_output(::PROTOBUF_NAMESPACE_ID::Struct* step_output);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_step_output() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_step_output();
  public:
  void unsafe_arena_set_allocated_step_output(
      ::PROTOBUF_NAMESPACE_ID::Struct* step_output);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_step_output();

  // @@protoc_insertion_point(class_scope:unhinged.messaging.WorkflowStepExecution)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr step_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr step_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr step_status_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_step_id_;
    ::PROTOBUF_NAMESPACE_ID::Struct* step_input_;
    ::PROTOBUF_NAMESPACE_ID::Struct* step_output_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messaging_2eproto;
};
// -------------------------------------------------------------------

class WorkflowCompletion final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.messaging.WorkflowCompletion) */ {
 public:
  inline WorkflowCompletion() : WorkflowCompletion(nullptr) {}
  ~WorkflowCompletion() override;
  explicit PROTOBUF_CONSTEXPR WorkflowCompletion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WorkflowCompletion(const WorkflowCompletion& from);
  WorkflowCompletion(WorkflowCompletion&& from) noexcept
    : WorkflowCompletion() {
    *this = ::std::move(from);
  }

  inline WorkflowCompletion& operator=(const WorkflowCompletion& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkflowCompletion& operator=(WorkflowCompletion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkflowCompletion& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorkflowCompletion* internal_default_instance() {
    return reinterpret_cast<const WorkflowCompletion*>(
               &_WorkflowCompletion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(WorkflowCompletion& a, WorkflowCompletion& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkflowCompletion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkflowCompletion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorkflowCompletion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WorkflowCompletion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WorkflowCompletion& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WorkflowCompletion& from) {
    WorkflowCompletion::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkflowCompletion* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.messaging.WorkflowCompletion";
  }
  protected:
  explicit WorkflowCompletion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCompletionStatusFieldNumber = 1,
    kCompletionMessageFieldNumber = 3,
    kFinalOutputFieldNumber = 2,
    kTotalStepsExecutedFieldNumber = 4,
  };
  // string completion_status = 1;
  void clear_completion_status();
  const std::string& completion_status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_completion_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_completion_status();
  PROTOBUF_NODISCARD std::string* release_completion_status();
  void set_allocated_completion_status(std::string* completion_status);
  private:
  const std::string& _internal_completion_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_completion_status(const std::string& value);
  std::string* _internal_mutable_completion_status();
  public:

  // string completion_message = 3;
  void clear_completion_message();
  const std::string& completion_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_completion_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_completion_message();
  PROTOBUF_NODISCARD std::string* release_completion_message();
  void set_allocated_completion_message(std::string* completion_message);
  private:
  const std::string& _internal_completion_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_completion_message(const std::string& value);
  std::string* _internal_mutable_completion_message();
  public:

  // .google.protobuf.Struct final_output = 2;
  bool has_final_output() const;
  private:
  bool _internal_has_final_output() const;
  public:
  void clear_final_output();
  const ::PROTOBUF_NAMESPACE_ID::Struct& final_output() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_final_output();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_final_output();
  void set_allocated_final_output(::PROTOBUF_NAMESPACE_ID::Struct* final_output);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_final_output() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_final_output();
  public:
  void unsafe_arena_set_allocated_final_output(
      ::PROTOBUF_NAMESPACE_ID::Struct* final_output);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_final_output();

  // int32 total_steps_executed = 4;
  void clear_total_steps_executed();
  int32_t total_steps_executed() const;
  void set_total_steps_executed(int32_t value);
  private:
  int32_t _internal_total_steps_executed() const;
  void _internal_set_total_steps_executed(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.messaging.WorkflowCompletion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr completion_status_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr completion_message_;
    ::PROTOBUF_NAMESPACE_ID::Struct* final_output_;
    int32_t total_steps_executed_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messaging_2eproto;
};
// -------------------------------------------------------------------

class WorkflowControl final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.messaging.WorkflowControl) */ {
 public:
  inline WorkflowControl() : WorkflowControl(nullptr) {}
  ~WorkflowControl() override;
  explicit PROTOBUF_CONSTEXPR WorkflowControl(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WorkflowControl(const WorkflowControl& from);
  WorkflowControl(WorkflowControl&& from) noexcept
    : WorkflowControl() {
    *this = ::std::move(from);
  }

  inline WorkflowControl& operator=(const WorkflowControl& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkflowControl& operator=(WorkflowControl&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkflowControl& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorkflowControl* internal_default_instance() {
    return reinterpret_cast<const WorkflowControl*>(
               &_WorkflowControl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(WorkflowControl& a, WorkflowControl& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkflowControl* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkflowControl* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorkflowControl* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WorkflowControl>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WorkflowControl& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WorkflowControl& from) {
    WorkflowControl::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkflowControl* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.messaging.WorkflowControl";
  }
  protected:
  explicit WorkflowControl(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kControlActionFieldNumber = 1,
    kControlReasonFieldNumber = 2,
    kControlParametersFieldNumber = 3,
  };
  // string control_action = 1;
  void clear_control_action();
  const std::string& control_action() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_control_action(ArgT0&& arg0, ArgT... args);
  std::string* mutable_control_action();
  PROTOBUF_NODISCARD std::string* release_control_action();
  void set_allocated_control_action(std::string* control_action);
  private:
  const std::string& _internal_control_action() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_control_action(const std::string& value);
  std::string* _internal_mutable_control_action();
  public:

  // string control_reason = 2;
  void clear_control_reason();
  const std::string& control_reason() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_control_reason(ArgT0&& arg0, ArgT... args);
  std::string* mutable_control_reason();
  PROTOBUF_NODISCARD std::string* release_control_reason();
  void set_allocated_control_reason(std::string* control_reason);
  private:
  const std::string& _internal_control_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_control_reason(const std::string& value);
  std::string* _internal_mutable_control_reason();
  public:

  // .google.protobuf.Struct control_parameters = 3;
  bool has_control_parameters() const;
  private:
  bool _internal_has_control_parameters() const;
  public:
  void clear_control_parameters();
  const ::PROTOBUF_NAMESPACE_ID::Struct& control_parameters() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_control_parameters();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_control_parameters();
  void set_allocated_control_parameters(::PROTOBUF_NAMESPACE_ID::Struct* control_parameters);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_control_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_control_parameters();
  public:
  void unsafe_arena_set_allocated_control_parameters(
      ::PROTOBUF_NAMESPACE_ID::Struct* control_parameters);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_control_parameters();

  // @@protoc_insertion_point(class_scope:unhinged.messaging.WorkflowControl)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr control_action_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr control_reason_;
    ::PROTOBUF_NAMESPACE_ID::Struct* control_parameters_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messaging_2eproto;
};
// -------------------------------------------------------------------

class UIMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.messaging.UIMessage) */ {
 public:
  inline UIMessage() : UIMessage(nullptr) {}
  ~UIMessage() override;
  explicit PROTOBUF_CONSTEXPR UIMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UIMessage(const UIMessage& from);
  UIMessage(UIMessage&& from) noexcept
    : UIMessage() {
    *this = ::std::move(from);
  }

  inline UIMessage& operator=(const UIMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline UIMessage& operator=(UIMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UIMessage& default_instance() {
    return *internal_default_instance();
  }
  enum MessageDataCase {
    kUpdate = 10,
    kNotification = 11,
    kCommand = 12,
    MESSAGE_DATA_NOT_SET = 0,
  };

  static inline const UIMessage* internal_default_instance() {
    return reinterpret_cast<const UIMessage*>(
               &_UIMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(UIMessage& a, UIMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(UIMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UIMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UIMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UIMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UIMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UIMessage& from) {
    UIMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UIMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.messaging.UIMessage";
  }
  protected:
  explicit UIMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kComponentIdFieldNumber = 1,
    kMessageTypeFieldNumber = 2,
    kUpdateFieldNumber = 10,
    kNotificationFieldNumber = 11,
    kCommandFieldNumber = 12,
  };
  // string component_id = 1;
  void clear_component_id();
  const std::string& component_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_component_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_component_id();
  PROTOBUF_NODISCARD std::string* release_component_id();
  void set_allocated_component_id(std::string* component_id);
  private:
  const std::string& _internal_component_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_component_id(const std::string& value);
  std::string* _internal_mutable_component_id();
  public:

  // .unhinged.messaging.UIMessageType message_type = 2;
  void clear_message_type();
  ::unhinged::messaging::UIMessageType message_type() const;
  void set_message_type(::unhinged::messaging::UIMessageType value);
  private:
  ::unhinged::messaging::UIMessageType _internal_message_type() const;
  void _internal_set_message_type(::unhinged::messaging::UIMessageType value);
  public:

  // .unhinged.messaging.UIUpdate update = 10;
  bool has_update() const;
  private:
  bool _internal_has_update() const;
  public:
  void clear_update();
  const ::unhinged::messaging::UIUpdate& update() const;
  PROTOBUF_NODISCARD ::unhinged::messaging::UIUpdate* release_update();
  ::unhinged::messaging::UIUpdate* mutable_update();
  void set_allocated_update(::unhinged::messaging::UIUpdate* update);
  private:
  const ::unhinged::messaging::UIUpdate& _internal_update() const;
  ::unhinged::messaging::UIUpdate* _internal_mutable_update();
  public:
  void unsafe_arena_set_allocated_update(
      ::unhinged::messaging::UIUpdate* update);
  ::unhinged::messaging::UIUpdate* unsafe_arena_release_update();

  // .unhinged.messaging.UINotification notification = 11;
  bool has_notification() const;
  private:
  bool _internal_has_notification() const;
  public:
  void clear_notification();
  const ::unhinged::messaging::UINotification& notification() const;
  PROTOBUF_NODISCARD ::unhinged::messaging::UINotification* release_notification();
  ::unhinged::messaging::UINotification* mutable_notification();
  void set_allocated_notification(::unhinged::messaging::UINotification* notification);
  private:
  const ::unhinged::messaging::UINotification& _internal_notification() const;
  ::unhinged::messaging::UINotification* _internal_mutable_notification();
  public:
  void unsafe_arena_set_allocated_notification(
      ::unhinged::messaging::UINotification* notification);
  ::unhinged::messaging::UINotification* unsafe_arena_release_notification();

  // .unhinged.messaging.UICommand command = 12;
  bool has_command() const;
  private:
  bool _internal_has_command() const;
  public:
  void clear_command();
  const ::unhinged::messaging::UICommand& command() const;
  PROTOBUF_NODISCARD ::unhinged::messaging::UICommand* release_command();
  ::unhinged::messaging::UICommand* mutable_command();
  void set_allocated_command(::unhinged::messaging::UICommand* command);
  private:
  const ::unhinged::messaging::UICommand& _internal_command() const;
  ::unhinged::messaging::UICommand* _internal_mutable_command();
  public:
  void unsafe_arena_set_allocated_command(
      ::unhinged::messaging::UICommand* command);
  ::unhinged::messaging::UICommand* unsafe_arena_release_command();

  void clear_message_data();
  MessageDataCase message_data_case() const;
  // @@protoc_insertion_point(class_scope:unhinged.messaging.UIMessage)
 private:
  class _Internal;
  void set_has_update();
  void set_has_notification();
  void set_has_command();

  inline bool has_message_data() const;
  inline void clear_has_message_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr component_id_;
    int message_type_;
    union MessageDataUnion {
      constexpr MessageDataUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::unhinged::messaging::UIUpdate* update_;
      ::unhinged::messaging::UINotification* notification_;
      ::unhinged::messaging::UICommand* command_;
    } message_data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messaging_2eproto;
};
// -------------------------------------------------------------------

class UIUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.messaging.UIUpdate) */ {
 public:
  inline UIUpdate() : UIUpdate(nullptr) {}
  ~UIUpdate() override;
  explicit PROTOBUF_CONSTEXPR UIUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UIUpdate(const UIUpdate& from);
  UIUpdate(UIUpdate&& from) noexcept
    : UIUpdate() {
    *this = ::std::move(from);
  }

  inline UIUpdate& operator=(const UIUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline UIUpdate& operator=(UIUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UIUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const UIUpdate* internal_default_instance() {
    return reinterpret_cast<const UIUpdate*>(
               &_UIUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(UIUpdate& a, UIUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(UIUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UIUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UIUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UIUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UIUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UIUpdate& from) {
    UIUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UIUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.messaging.UIUpdate";
  }
  protected:
  explicit UIUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUpdateTypeFieldNumber = 1,
    kUpdateDataFieldNumber = 2,
    kForceRefreshFieldNumber = 3,
  };
  // string update_type = 1;
  void clear_update_type();
  const std::string& update_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_update_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_update_type();
  PROTOBUF_NODISCARD std::string* release_update_type();
  void set_allocated_update_type(std::string* update_type);
  private:
  const std::string& _internal_update_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_update_type(const std::string& value);
  std::string* _internal_mutable_update_type();
  public:

  // .google.protobuf.Struct update_data = 2;
  bool has_update_data() const;
  private:
  bool _internal_has_update_data() const;
  public:
  void clear_update_data();
  const ::PROTOBUF_NAMESPACE_ID::Struct& update_data() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_update_data();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_update_data();
  void set_allocated_update_data(::PROTOBUF_NAMESPACE_ID::Struct* update_data);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_update_data() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_update_data();
  public:
  void unsafe_arena_set_allocated_update_data(
      ::PROTOBUF_NAMESPACE_ID::Struct* update_data);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_update_data();

  // bool force_refresh = 3;
  void clear_force_refresh();
  bool force_refresh() const;
  void set_force_refresh(bool value);
  private:
  bool _internal_force_refresh() const;
  void _internal_set_force_refresh(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.messaging.UIUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr update_type_;
    ::PROTOBUF_NAMESPACE_ID::Struct* update_data_;
    bool force_refresh_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messaging_2eproto;
};
// -------------------------------------------------------------------

class UINotification final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.messaging.UINotification) */ {
 public:
  inline UINotification() : UINotification(nullptr) {}
  ~UINotification() override;
  explicit PROTOBUF_CONSTEXPR UINotification(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UINotification(const UINotification& from);
  UINotification(UINotification&& from) noexcept
    : UINotification() {
    *this = ::std::move(from);
  }

  inline UINotification& operator=(const UINotification& from) {
    CopyFrom(from);
    return *this;
  }
  inline UINotification& operator=(UINotification&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UINotification& default_instance() {
    return *internal_default_instance();
  }
  static inline const UINotification* internal_default_instance() {
    return reinterpret_cast<const UINotification*>(
               &_UINotification_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(UINotification& a, UINotification& b) {
    a.Swap(&b);
  }
  inline void Swap(UINotification* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UINotification* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UINotification* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UINotification>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UINotification& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UINotification& from) {
    UINotification::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UINotification* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.messaging.UINotification";
  }
  protected:
  explicit UINotification(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNotificationTypeFieldNumber = 1,
    kTitleFieldNumber = 2,
    kMessageFieldNumber = 3,
    kDurationMsFieldNumber = 4,
    kDismissibleFieldNumber = 5,
  };
  // string notification_type = 1;
  void clear_notification_type();
  const std::string& notification_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_notification_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_notification_type();
  PROTOBUF_NODISCARD std::string* release_notification_type();
  void set_allocated_notification_type(std::string* notification_type);
  private:
  const std::string& _internal_notification_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_notification_type(const std::string& value);
  std::string* _internal_mutable_notification_type();
  public:

  // string title = 2;
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // int32 duration_ms = 4;
  void clear_duration_ms();
  int32_t duration_ms() const;
  void set_duration_ms(int32_t value);
  private:
  int32_t _internal_duration_ms() const;
  void _internal_set_duration_ms(int32_t value);
  public:

  // bool dismissible = 5;
  void clear_dismissible();
  bool dismissible() const;
  void set_dismissible(bool value);
  private:
  bool _internal_dismissible() const;
  void _internal_set_dismissible(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.messaging.UINotification)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr notification_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    int32_t duration_ms_;
    bool dismissible_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messaging_2eproto;
};
// -------------------------------------------------------------------

class UICommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.messaging.UICommand) */ {
 public:
  inline UICommand() : UICommand(nullptr) {}
  ~UICommand() override;
  explicit PROTOBUF_CONSTEXPR UICommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UICommand(const UICommand& from);
  UICommand(UICommand&& from) noexcept
    : UICommand() {
    *this = ::std::move(from);
  }

  inline UICommand& operator=(const UICommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline UICommand& operator=(UICommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UICommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const UICommand* internal_default_instance() {
    return reinterpret_cast<const UICommand*>(
               &_UICommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(UICommand& a, UICommand& b) {
    a.Swap(&b);
  }
  inline void Swap(UICommand* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UICommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UICommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UICommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UICommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UICommand& from) {
    UICommand::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UICommand* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.messaging.UICommand";
  }
  protected:
  explicit UICommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommandFieldNumber = 1,
    kCommandParametersFieldNumber = 2,
  };
  // string command = 1;
  void clear_command();
  const std::string& command() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_command(ArgT0&& arg0, ArgT... args);
  std::string* mutable_command();
  PROTOBUF_NODISCARD std::string* release_command();
  void set_allocated_command(std::string* command);
  private:
  const std::string& _internal_command() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_command(const std::string& value);
  std::string* _internal_mutable_command();
  public:

  // .google.protobuf.Struct command_parameters = 2;
  bool has_command_parameters() const;
  private:
  bool _internal_has_command_parameters() const;
  public:
  void clear_command_parameters();
  const ::PROTOBUF_NAMESPACE_ID::Struct& command_parameters() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_command_parameters();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_command_parameters();
  void set_allocated_command_parameters(::PROTOBUF_NAMESPACE_ID::Struct* command_parameters);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_command_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_command_parameters();
  public:
  void unsafe_arena_set_allocated_command_parameters(
      ::PROTOBUF_NAMESPACE_ID::Struct* command_parameters);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_command_parameters();

  // @@protoc_insertion_point(class_scope:unhinged.messaging.UICommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr command_;
    ::PROTOBUF_NAMESPACE_ID::Struct* command_parameters_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messaging_2eproto;
};
// -------------------------------------------------------------------

class SystemMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.messaging.SystemMessage) */ {
 public:
  inline SystemMessage() : SystemMessage(nullptr) {}
  ~SystemMessage() override;
  explicit PROTOBUF_CONSTEXPR SystemMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SystemMessage(const SystemMessage& from);
  SystemMessage(SystemMessage&& from) noexcept
    : SystemMessage() {
    *this = ::std::move(from);
  }

  inline SystemMessage& operator=(const SystemMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline SystemMessage& operator=(SystemMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SystemMessage& default_instance() {
    return *internal_default_instance();
  }
  enum MessageDataCase {
    kServiceDiscovery = 10,
    kHealthCheck = 11,
    kConfigUpdate = 12,
    kShutdownNotice = 13,
    MESSAGE_DATA_NOT_SET = 0,
  };

  static inline const SystemMessage* internal_default_instance() {
    return reinterpret_cast<const SystemMessage*>(
               &_SystemMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(SystemMessage& a, SystemMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(SystemMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SystemMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SystemMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SystemMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SystemMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SystemMessage& from) {
    SystemMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SystemMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.messaging.SystemMessage";
  }
  protected:
  explicit SystemMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageTypeFieldNumber = 1,
    kServiceDiscoveryFieldNumber = 10,
    kHealthCheckFieldNumber = 11,
    kConfigUpdateFieldNumber = 12,
    kShutdownNoticeFieldNumber = 13,
  };
  // .unhinged.messaging.SystemMessageType message_type = 1;
  void clear_message_type();
  ::unhinged::messaging::SystemMessageType message_type() const;
  void set_message_type(::unhinged::messaging::SystemMessageType value);
  private:
  ::unhinged::messaging::SystemMessageType _internal_message_type() const;
  void _internal_set_message_type(::unhinged::messaging::SystemMessageType value);
  public:

  // .unhinged.messaging.ServiceDiscovery service_discovery = 10;
  bool has_service_discovery() const;
  private:
  bool _internal_has_service_discovery() const;
  public:
  void clear_service_discovery();
  const ::unhinged::messaging::ServiceDiscovery& service_discovery() const;
  PROTOBUF_NODISCARD ::unhinged::messaging::ServiceDiscovery* release_service_discovery();
  ::unhinged::messaging::ServiceDiscovery* mutable_service_discovery();
  void set_allocated_service_discovery(::unhinged::messaging::ServiceDiscovery* service_discovery);
  private:
  const ::unhinged::messaging::ServiceDiscovery& _internal_service_discovery() const;
  ::unhinged::messaging::ServiceDiscovery* _internal_mutable_service_discovery();
  public:
  void unsafe_arena_set_allocated_service_discovery(
      ::unhinged::messaging::ServiceDiscovery* service_discovery);
  ::unhinged::messaging::ServiceDiscovery* unsafe_arena_release_service_discovery();

  // .unhinged.messaging.HealthCheck health_check = 11;
  bool has_health_check() const;
  private:
  bool _internal_has_health_check() const;
  public:
  void clear_health_check();
  const ::unhinged::messaging::HealthCheck& health_check() const;
  PROTOBUF_NODISCARD ::unhinged::messaging::HealthCheck* release_health_check();
  ::unhinged::messaging::HealthCheck* mutable_health_check();
  void set_allocated_health_check(::unhinged::messaging::HealthCheck* health_check);
  private:
  const ::unhinged::messaging::HealthCheck& _internal_health_check() const;
  ::unhinged::messaging::HealthCheck* _internal_mutable_health_check();
  public:
  void unsafe_arena_set_allocated_health_check(
      ::unhinged::messaging::HealthCheck* health_check);
  ::unhinged::messaging::HealthCheck* unsafe_arena_release_health_check();

  // .unhinged.messaging.ConfigUpdate config_update = 12;
  bool has_config_update() const;
  private:
  bool _internal_has_config_update() const;
  public:
  void clear_config_update();
  const ::unhinged::messaging::ConfigUpdate& config_update() const;
  PROTOBUF_NODISCARD ::unhinged::messaging::ConfigUpdate* release_config_update();
  ::unhinged::messaging::ConfigUpdate* mutable_config_update();
  void set_allocated_config_update(::unhinged::messaging::ConfigUpdate* config_update);
  private:
  const ::unhinged::messaging::ConfigUpdate& _internal_config_update() const;
  ::unhinged::messaging::ConfigUpdate* _internal_mutable_config_update();
  public:
  void unsafe_arena_set_allocated_config_update(
      ::unhinged::messaging::ConfigUpdate* config_update);
  ::unhinged::messaging::ConfigUpdate* unsafe_arena_release_config_update();

  // .unhinged.messaging.ShutdownNotice shutdown_notice = 13;
  bool has_shutdown_notice() const;
  private:
  bool _internal_has_shutdown_notice() const;
  public:
  void clear_shutdown_notice();
  const ::unhinged::messaging::ShutdownNotice& shutdown_notice() const;
  PROTOBUF_NODISCARD ::unhinged::messaging::ShutdownNotice* release_shutdown_notice();
  ::unhinged::messaging::ShutdownNotice* mutable_shutdown_notice();
  void set_allocated_shutdown_notice(::unhinged::messaging::ShutdownNotice* shutdown_notice);
  private:
  const ::unhinged::messaging::ShutdownNotice& _internal_shutdown_notice() const;
  ::unhinged::messaging::ShutdownNotice* _internal_mutable_shutdown_notice();
  public:
  void unsafe_arena_set_allocated_shutdown_notice(
      ::unhinged::messaging::ShutdownNotice* shutdown_notice);
  ::unhinged::messaging::ShutdownNotice* unsafe_arena_release_shutdown_notice();

  void clear_message_data();
  MessageDataCase message_data_case() const;
  // @@protoc_insertion_point(class_scope:unhinged.messaging.SystemMessage)
 private:
  class _Internal;
  void set_has_service_discovery();
  void set_has_health_check();
  void set_has_config_update();
  void set_has_shutdown_notice();

  inline bool has_message_data() const;
  inline void clear_has_message_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int message_type_;
    union MessageDataUnion {
      constexpr MessageDataUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::unhinged::messaging::ServiceDiscovery* service_discovery_;
      ::unhinged::messaging::HealthCheck* health_check_;
      ::unhinged::messaging::ConfigUpdate* config_update_;
      ::unhinged::messaging::ShutdownNotice* shutdown_notice_;
    } message_data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messaging_2eproto;
};
// -------------------------------------------------------------------

class ServiceDiscovery final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.messaging.ServiceDiscovery) */ {
 public:
  inline ServiceDiscovery() : ServiceDiscovery(nullptr) {}
  ~ServiceDiscovery() override;
  explicit PROTOBUF_CONSTEXPR ServiceDiscovery(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServiceDiscovery(const ServiceDiscovery& from);
  ServiceDiscovery(ServiceDiscovery&& from) noexcept
    : ServiceDiscovery() {
    *this = ::std::move(from);
  }

  inline ServiceDiscovery& operator=(const ServiceDiscovery& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServiceDiscovery& operator=(ServiceDiscovery&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServiceDiscovery& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServiceDiscovery* internal_default_instance() {
    return reinterpret_cast<const ServiceDiscovery*>(
               &_ServiceDiscovery_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(ServiceDiscovery& a, ServiceDiscovery& b) {
    a.Swap(&b);
  }
  inline void Swap(ServiceDiscovery* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServiceDiscovery* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServiceDiscovery* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServiceDiscovery>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServiceDiscovery& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ServiceDiscovery& from) {
    ServiceDiscovery::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServiceDiscovery* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.messaging.ServiceDiscovery";
  }
  protected:
  explicit ServiceDiscovery(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCapabilitiesFieldNumber = 4,
    kServiceNameFieldNumber = 1,
    kServiceVersionFieldNumber = 2,
    kEndpointUrlFieldNumber = 3,
    kStatusFieldNumber = 5,
  };
  // repeated string capabilities = 4;
  int capabilities_size() const;
  private:
  int _internal_capabilities_size() const;
  public:
  void clear_capabilities();
  const std::string& capabilities(int index) const;
  std::string* mutable_capabilities(int index);
  void set_capabilities(int index, const std::string& value);
  void set_capabilities(int index, std::string&& value);
  void set_capabilities(int index, const char* value);
  void set_capabilities(int index, const char* value, size_t size);
  std::string* add_capabilities();
  void add_capabilities(const std::string& value);
  void add_capabilities(std::string&& value);
  void add_capabilities(const char* value);
  void add_capabilities(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& capabilities() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_capabilities();
  private:
  const std::string& _internal_capabilities(int index) const;
  std::string* _internal_add_capabilities();
  public:

  // string service_name = 1;
  void clear_service_name();
  const std::string& service_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // string service_version = 2;
  void clear_service_version();
  const std::string& service_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_version();
  PROTOBUF_NODISCARD std::string* release_service_version();
  void set_allocated_service_version(std::string* service_version);
  private:
  const std::string& _internal_service_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_version(const std::string& value);
  std::string* _internal_mutable_service_version();
  public:

  // string endpoint_url = 3;
  void clear_endpoint_url();
  const std::string& endpoint_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_endpoint_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_endpoint_url();
  PROTOBUF_NODISCARD std::string* release_endpoint_url();
  void set_allocated_endpoint_url(std::string* endpoint_url);
  private:
  const std::string& _internal_endpoint_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_endpoint_url(const std::string& value);
  std::string* _internal_mutable_endpoint_url();
  public:

  // string status = 5;
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // @@protoc_insertion_point(class_scope:unhinged.messaging.ServiceDiscovery)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> capabilities_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr endpoint_url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messaging_2eproto;
};
// -------------------------------------------------------------------

class HealthCheck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.messaging.HealthCheck) */ {
 public:
  inline HealthCheck() : HealthCheck(nullptr) {}
  ~HealthCheck() override;
  explicit PROTOBUF_CONSTEXPR HealthCheck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HealthCheck(const HealthCheck& from);
  HealthCheck(HealthCheck&& from) noexcept
    : HealthCheck() {
    *this = ::std::move(from);
  }

  inline HealthCheck& operator=(const HealthCheck& from) {
    CopyFrom(from);
    return *this;
  }
  inline HealthCheck& operator=(HealthCheck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HealthCheck& default_instance() {
    return *internal_default_instance();
  }
  static inline const HealthCheck* internal_default_instance() {
    return reinterpret_cast<const HealthCheck*>(
               &_HealthCheck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(HealthCheck& a, HealthCheck& b) {
    a.Swap(&b);
  }
  inline void Swap(HealthCheck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HealthCheck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HealthCheck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HealthCheck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HealthCheck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HealthCheck& from) {
    HealthCheck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HealthCheck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.messaging.HealthCheck";
  }
  protected:
  explicit HealthCheck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceNameFieldNumber = 1,
    kStatusMessageFieldNumber = 3,
    kHealthDetailsFieldNumber = 4,
    kIsHealthyFieldNumber = 2,
  };
  // string service_name = 1;
  void clear_service_name();
  const std::string& service_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // string status_message = 3;
  void clear_status_message();
  const std::string& status_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status_message();
  PROTOBUF_NODISCARD std::string* release_status_message();
  void set_allocated_status_message(std::string* status_message);
  private:
  const std::string& _internal_status_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status_message(const std::string& value);
  std::string* _internal_mutable_status_message();
  public:

  // .google.protobuf.Struct health_details = 4;
  bool has_health_details() const;
  private:
  bool _internal_has_health_details() const;
  public:
  void clear_health_details();
  const ::PROTOBUF_NAMESPACE_ID::Struct& health_details() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_health_details();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_health_details();
  void set_allocated_health_details(::PROTOBUF_NAMESPACE_ID::Struct* health_details);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_health_details() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_health_details();
  public:
  void unsafe_arena_set_allocated_health_details(
      ::PROTOBUF_NAMESPACE_ID::Struct* health_details);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_health_details();

  // bool is_healthy = 2;
  void clear_is_healthy();
  bool is_healthy() const;
  void set_is_healthy(bool value);
  private:
  bool _internal_is_healthy() const;
  void _internal_set_is_healthy(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.messaging.HealthCheck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_message_;
    ::PROTOBUF_NAMESPACE_ID::Struct* health_details_;
    bool is_healthy_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messaging_2eproto;
};
// -------------------------------------------------------------------

class ConfigUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.messaging.ConfigUpdate) */ {
 public:
  inline ConfigUpdate() : ConfigUpdate(nullptr) {}
  ~ConfigUpdate() override;
  explicit PROTOBUF_CONSTEXPR ConfigUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfigUpdate(const ConfigUpdate& from);
  ConfigUpdate(ConfigUpdate&& from) noexcept
    : ConfigUpdate() {
    *this = ::std::move(from);
  }

  inline ConfigUpdate& operator=(const ConfigUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigUpdate& operator=(ConfigUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfigUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigUpdate* internal_default_instance() {
    return reinterpret_cast<const ConfigUpdate*>(
               &_ConfigUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(ConfigUpdate& a, ConfigUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfigUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfigUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfigUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConfigUpdate& from) {
    ConfigUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.messaging.ConfigUpdate";
  }
  protected:
  explicit ConfigUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigKeyFieldNumber = 1,
    kUpdateReasonFieldNumber = 3,
    kConfigValueFieldNumber = 2,
  };
  // string config_key = 1;
  void clear_config_key();
  const std::string& config_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_config_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_config_key();
  PROTOBUF_NODISCARD std::string* release_config_key();
  void set_allocated_config_key(std::string* config_key);
  private:
  const std::string& _internal_config_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_config_key(const std::string& value);
  std::string* _internal_mutable_config_key();
  public:

  // string update_reason = 3;
  void clear_update_reason();
  const std::string& update_reason() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_update_reason(ArgT0&& arg0, ArgT... args);
  std::string* mutable_update_reason();
  PROTOBUF_NODISCARD std::string* release_update_reason();
  void set_allocated_update_reason(std::string* update_reason);
  private:
  const std::string& _internal_update_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_update_reason(const std::string& value);
  std::string* _internal_mutable_update_reason();
  public:

  // .google.protobuf.Any config_value = 2;
  bool has_config_value() const;
  private:
  bool _internal_has_config_value() const;
  public:
  void clear_config_value();
  const ::PROTOBUF_NAMESPACE_ID::Any& config_value() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Any* release_config_value();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_config_value();
  void set_allocated_config_value(::PROTOBUF_NAMESPACE_ID::Any* config_value);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_config_value() const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_mutable_config_value();
  public:
  void unsafe_arena_set_allocated_config_value(
      ::PROTOBUF_NAMESPACE_ID::Any* config_value);
  ::PROTOBUF_NAMESPACE_ID::Any* unsafe_arena_release_config_value();

  // @@protoc_insertion_point(class_scope:unhinged.messaging.ConfigUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr config_key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr update_reason_;
    ::PROTOBUF_NAMESPACE_ID::Any* config_value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messaging_2eproto;
};
// -------------------------------------------------------------------

class ShutdownNotice final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.messaging.ShutdownNotice) */ {
 public:
  inline ShutdownNotice() : ShutdownNotice(nullptr) {}
  ~ShutdownNotice() override;
  explicit PROTOBUF_CONSTEXPR ShutdownNotice(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShutdownNotice(const ShutdownNotice& from);
  ShutdownNotice(ShutdownNotice&& from) noexcept
    : ShutdownNotice() {
    *this = ::std::move(from);
  }

  inline ShutdownNotice& operator=(const ShutdownNotice& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShutdownNotice& operator=(ShutdownNotice&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShutdownNotice& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShutdownNotice* internal_default_instance() {
    return reinterpret_cast<const ShutdownNotice*>(
               &_ShutdownNotice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(ShutdownNotice& a, ShutdownNotice& b) {
    a.Swap(&b);
  }
  inline void Swap(ShutdownNotice* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShutdownNotice* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShutdownNotice* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShutdownNotice>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShutdownNotice& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ShutdownNotice& from) {
    ShutdownNotice::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShutdownNotice* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.messaging.ShutdownNotice";
  }
  protected:
  explicit ShutdownNotice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceNameFieldNumber = 1,
    kShutdownReasonFieldNumber = 2,
    kGracefulShutdownSecondsFieldNumber = 3,
  };
  // string service_name = 1;
  void clear_service_name();
  const std::string& service_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // string shutdown_reason = 2;
  void clear_shutdown_reason();
  const std::string& shutdown_reason() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_shutdown_reason(ArgT0&& arg0, ArgT... args);
  std::string* mutable_shutdown_reason();
  PROTOBUF_NODISCARD std::string* release_shutdown_reason();
  void set_allocated_shutdown_reason(std::string* shutdown_reason);
  private:
  const std::string& _internal_shutdown_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_shutdown_reason(const std::string& value);
  std::string* _internal_mutable_shutdown_reason();
  public:

  // int32 graceful_shutdown_seconds = 3;
  void clear_graceful_shutdown_seconds();
  int32_t graceful_shutdown_seconds() const;
  void set_graceful_shutdown_seconds(int32_t value);
  private:
  int32_t _internal_graceful_shutdown_seconds() const;
  void _internal_set_graceful_shutdown_seconds(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.messaging.ShutdownNotice)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr shutdown_reason_;
    int32_t graceful_shutdown_seconds_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messaging_2eproto;
};
// -------------------------------------------------------------------

class SendMessageRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.messaging.SendMessageRequest) */ {
 public:
  inline SendMessageRequest() : SendMessageRequest(nullptr) {}
  ~SendMessageRequest() override;
  explicit PROTOBUF_CONSTEXPR SendMessageRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendMessageRequest(const SendMessageRequest& from);
  SendMessageRequest(SendMessageRequest&& from) noexcept
    : SendMessageRequest() {
    *this = ::std::move(from);
  }

  inline SendMessageRequest& operator=(const SendMessageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendMessageRequest& operator=(SendMessageRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendMessageRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendMessageRequest* internal_default_instance() {
    return reinterpret_cast<const SendMessageRequest*>(
               &_SendMessageRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(SendMessageRequest& a, SendMessageRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SendMessageRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendMessageRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendMessageRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendMessageRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendMessageRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SendMessageRequest& from) {
    SendMessageRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendMessageRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.messaging.SendMessageRequest";
  }
  protected:
  explicit SendMessageRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
  };
  // .unhinged.messaging.Message message = 1;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const ::unhinged::messaging::Message& message() const;
  PROTOBUF_NODISCARD ::unhinged::messaging::Message* release_message();
  ::unhinged::messaging::Message* mutable_message();
  void set_allocated_message(::unhinged::messaging::Message* message);
  private:
  const ::unhinged::messaging::Message& _internal_message() const;
  ::unhinged::messaging::Message* _internal_mutable_message();
  public:
  void unsafe_arena_set_allocated_message(
      ::unhinged::messaging::Message* message);
  ::unhinged::messaging::Message* unsafe_arena_release_message();

  // @@protoc_insertion_point(class_scope:unhinged.messaging.SendMessageRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::unhinged::messaging::Message* message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messaging_2eproto;
};
// -------------------------------------------------------------------

class SendMessageResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.messaging.SendMessageResponse) */ {
 public:
  inline SendMessageResponse() : SendMessageResponse(nullptr) {}
  ~SendMessageResponse() override;
  explicit PROTOBUF_CONSTEXPR SendMessageResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendMessageResponse(const SendMessageResponse& from);
  SendMessageResponse(SendMessageResponse&& from) noexcept
    : SendMessageResponse() {
    *this = ::std::move(from);
  }

  inline SendMessageResponse& operator=(const SendMessageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendMessageResponse& operator=(SendMessageResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendMessageResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendMessageResponse* internal_default_instance() {
    return reinterpret_cast<const SendMessageResponse*>(
               &_SendMessageResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(SendMessageResponse& a, SendMessageResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SendMessageResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendMessageResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendMessageResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendMessageResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendMessageResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SendMessageResponse& from) {
    SendMessageResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendMessageResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.messaging.SendMessageResponse";
  }
  protected:
  explicit SendMessageResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageIdFieldNumber = 2,
    kStatusFieldNumber = 3,
    kErrorMessageFieldNumber = 4,
    kSuccessFieldNumber = 1,
  };
  // string message_id = 2;
  void clear_message_id();
  const std::string& message_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message_id();
  PROTOBUF_NODISCARD std::string* release_message_id();
  void set_allocated_message_id(std::string* message_id);
  private:
  const std::string& _internal_message_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message_id(const std::string& value);
  std::string* _internal_mutable_message_id();
  public:

  // string status = 3;
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // string error_message = 4;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.messaging.SendMessageResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messaging_2eproto;
};
// -------------------------------------------------------------------

class SendMessagesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.messaging.SendMessagesRequest) */ {
 public:
  inline SendMessagesRequest() : SendMessagesRequest(nullptr) {}
  ~SendMessagesRequest() override;
  explicit PROTOBUF_CONSTEXPR SendMessagesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendMessagesRequest(const SendMessagesRequest& from);
  SendMessagesRequest(SendMessagesRequest&& from) noexcept
    : SendMessagesRequest() {
    *this = ::std::move(from);
  }

  inline SendMessagesRequest& operator=(const SendMessagesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendMessagesRequest& operator=(SendMessagesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendMessagesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendMessagesRequest* internal_default_instance() {
    return reinterpret_cast<const SendMessagesRequest*>(
               &_SendMessagesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(SendMessagesRequest& a, SendMessagesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SendMessagesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendMessagesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendMessagesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendMessagesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendMessagesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SendMessagesRequest& from) {
    SendMessagesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendMessagesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.messaging.SendMessagesRequest";
  }
  protected:
  explicit SendMessagesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessagesFieldNumber = 1,
    kAtomicFieldNumber = 2,
  };
  // repeated .unhinged.messaging.Message messages = 1;
  int messages_size() const;
  private:
  int _internal_messages_size() const;
  public:
  void clear_messages();
  ::unhinged::messaging::Message* mutable_messages(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::messaging::Message >*
      mutable_messages();
  private:
  const ::unhinged::messaging::Message& _internal_messages(int index) const;
  ::unhinged::messaging::Message* _internal_add_messages();
  public:
  const ::unhinged::messaging::Message& messages(int index) const;
  ::unhinged::messaging::Message* add_messages();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::messaging::Message >&
      messages() const;

  // bool atomic = 2;
  void clear_atomic();
  bool atomic() const;
  void set_atomic(bool value);
  private:
  bool _internal_atomic() const;
  void _internal_set_atomic(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.messaging.SendMessagesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::messaging::Message > messages_;
    bool atomic_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messaging_2eproto;
};
// -------------------------------------------------------------------

class SendMessageResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.messaging.SendMessageResult) */ {
 public:
  inline SendMessageResult() : SendMessageResult(nullptr) {}
  ~SendMessageResult() override;
  explicit PROTOBUF_CONSTEXPR SendMessageResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendMessageResult(const SendMessageResult& from);
  SendMessageResult(SendMessageResult&& from) noexcept
    : SendMessageResult() {
    *this = ::std::move(from);
  }

  inline SendMessageResult& operator=(const SendMessageResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendMessageResult& operator=(SendMessageResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendMessageResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendMessageResult* internal_default_instance() {
    return reinterpret_cast<const SendMessageResult*>(
               &_SendMessageResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(SendMessageResult& a, SendMessageResult& b) {
    a.Swap(&b);
  }
  inline void Swap(SendMessageResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendMessageResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendMessageResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendMessageResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendMessageResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SendMessageResult& from) {
    SendMessageResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendMessageResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.messaging.SendMessageResult";
  }
  protected:
  explicit SendMessageResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageIdFieldNumber = 1,
    kErrorMessageFieldNumber = 3,
    kSuccessFieldNumber = 2,
  };
  // string message_id = 1;
  void clear_message_id();
  const std::string& message_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message_id();
  PROTOBUF_NODISCARD std::string* release_message_id();
  void set_allocated_message_id(std::string* message_id);
  private:
  const std::string& _internal_message_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message_id(const std::string& value);
  std::string* _internal_mutable_message_id();
  public:

  // string error_message = 3;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // bool success = 2;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.messaging.SendMessageResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messaging_2eproto;
};
// -------------------------------------------------------------------

class SendMessagesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.messaging.SendMessagesResponse) */ {
 public:
  inline SendMessagesResponse() : SendMessagesResponse(nullptr) {}
  ~SendMessagesResponse() override;
  explicit PROTOBUF_CONSTEXPR SendMessagesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendMessagesResponse(const SendMessagesResponse& from);
  SendMessagesResponse(SendMessagesResponse&& from) noexcept
    : SendMessagesResponse() {
    *this = ::std::move(from);
  }

  inline SendMessagesResponse& operator=(const SendMessagesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendMessagesResponse& operator=(SendMessagesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendMessagesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendMessagesResponse* internal_default_instance() {
    return reinterpret_cast<const SendMessagesResponse*>(
               &_SendMessagesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(SendMessagesResponse& a, SendMessagesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SendMessagesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendMessagesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendMessagesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendMessagesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendMessagesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SendMessagesResponse& from) {
    SendMessagesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendMessagesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.messaging.SendMessagesResponse";
  }
  protected:
  explicit SendMessagesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultsFieldNumber = 2,
    kSuccessFieldNumber = 1,
    kSuccessfulCountFieldNumber = 3,
    kFailedCountFieldNumber = 4,
  };
  // repeated .unhinged.messaging.SendMessageResult results = 2;
  int results_size() const;
  private:
  int _internal_results_size() const;
  public:
  void clear_results();
  ::unhinged::messaging::SendMessageResult* mutable_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::messaging::SendMessageResult >*
      mutable_results();
  private:
  const ::unhinged::messaging::SendMessageResult& _internal_results(int index) const;
  ::unhinged::messaging::SendMessageResult* _internal_add_results();
  public:
  const ::unhinged::messaging::SendMessageResult& results(int index) const;
  ::unhinged::messaging::SendMessageResult* add_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::messaging::SendMessageResult >&
      results() const;

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // int32 successful_count = 3;
  void clear_successful_count();
  int32_t successful_count() const;
  void set_successful_count(int32_t value);
  private:
  int32_t _internal_successful_count() const;
  void _internal_set_successful_count(int32_t value);
  public:

  // int32 failed_count = 4;
  void clear_failed_count();
  int32_t failed_count() const;
  void set_failed_count(int32_t value);
  private:
  int32_t _internal_failed_count() const;
  void _internal_set_failed_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.messaging.SendMessagesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::messaging::SendMessageResult > results_;
    bool success_;
    int32_t successful_count_;
    int32_t failed_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messaging_2eproto;
};
// -------------------------------------------------------------------

class ReceiveMessagesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.messaging.ReceiveMessagesRequest) */ {
 public:
  inline ReceiveMessagesRequest() : ReceiveMessagesRequest(nullptr) {}
  ~ReceiveMessagesRequest() override;
  explicit PROTOBUF_CONSTEXPR ReceiveMessagesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReceiveMessagesRequest(const ReceiveMessagesRequest& from);
  ReceiveMessagesRequest(ReceiveMessagesRequest&& from) noexcept
    : ReceiveMessagesRequest() {
    *this = ::std::move(from);
  }

  inline ReceiveMessagesRequest& operator=(const ReceiveMessagesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReceiveMessagesRequest& operator=(ReceiveMessagesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReceiveMessagesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReceiveMessagesRequest* internal_default_instance() {
    return reinterpret_cast<const ReceiveMessagesRequest*>(
               &_ReceiveMessagesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(ReceiveMessagesRequest& a, ReceiveMessagesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ReceiveMessagesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReceiveMessagesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReceiveMessagesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReceiveMessagesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReceiveMessagesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReceiveMessagesRequest& from) {
    ReceiveMessagesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReceiveMessagesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.messaging.ReceiveMessagesRequest";
  }
  protected:
  explicit ReceiveMessagesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageTypesFieldNumber = 2,
    kServiceNameFieldNumber = 1,
    kMaxMessagesFieldNumber = 3,
    kWaitTimeSecondsFieldNumber = 4,
  };
  // repeated string message_types = 2;
  int message_types_size() const;
  private:
  int _internal_message_types_size() const;
  public:
  void clear_message_types();
  const std::string& message_types(int index) const;
  std::string* mutable_message_types(int index);
  void set_message_types(int index, const std::string& value);
  void set_message_types(int index, std::string&& value);
  void set_message_types(int index, const char* value);
  void set_message_types(int index, const char* value, size_t size);
  std::string* add_message_types();
  void add_message_types(const std::string& value);
  void add_message_types(std::string&& value);
  void add_message_types(const char* value);
  void add_message_types(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& message_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_message_types();
  private:
  const std::string& _internal_message_types(int index) const;
  std::string* _internal_add_message_types();
  public:

  // string service_name = 1;
  void clear_service_name();
  const std::string& service_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // int32 max_messages = 3;
  void clear_max_messages();
  int32_t max_messages() const;
  void set_max_messages(int32_t value);
  private:
  int32_t _internal_max_messages() const;
  void _internal_set_max_messages(int32_t value);
  public:

  // int32 wait_time_seconds = 4;
  void clear_wait_time_seconds();
  int32_t wait_time_seconds() const;
  void set_wait_time_seconds(int32_t value);
  private:
  int32_t _internal_wait_time_seconds() const;
  void _internal_set_wait_time_seconds(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.messaging.ReceiveMessagesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> message_types_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
    int32_t max_messages_;
    int32_t wait_time_seconds_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messaging_2eproto;
};
// -------------------------------------------------------------------

class ReceiveMessagesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.messaging.ReceiveMessagesResponse) */ {
 public:
  inline ReceiveMessagesResponse() : ReceiveMessagesResponse(nullptr) {}
  ~ReceiveMessagesResponse() override;
  explicit PROTOBUF_CONSTEXPR ReceiveMessagesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReceiveMessagesResponse(const ReceiveMessagesResponse& from);
  ReceiveMessagesResponse(ReceiveMessagesResponse&& from) noexcept
    : ReceiveMessagesResponse() {
    *this = ::std::move(from);
  }

  inline ReceiveMessagesResponse& operator=(const ReceiveMessagesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReceiveMessagesResponse& operator=(ReceiveMessagesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReceiveMessagesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReceiveMessagesResponse* internal_default_instance() {
    return reinterpret_cast<const ReceiveMessagesResponse*>(
               &_ReceiveMessagesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(ReceiveMessagesResponse& a, ReceiveMessagesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ReceiveMessagesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReceiveMessagesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReceiveMessagesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReceiveMessagesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReceiveMessagesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReceiveMessagesResponse& from) {
    ReceiveMessagesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReceiveMessagesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.messaging.ReceiveMessagesResponse";
  }
  protected:
  explicit ReceiveMessagesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessagesFieldNumber = 1,
    kReceiptHandleFieldNumber = 2,
  };
  // repeated .unhinged.messaging.Message messages = 1;
  int messages_size() const;
  private:
  int _internal_messages_size() const;
  public:
  void clear_messages();
  ::unhinged::messaging::Message* mutable_messages(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::messaging::Message >*
      mutable_messages();
  private:
  const ::unhinged::messaging::Message& _internal_messages(int index) const;
  ::unhinged::messaging::Message* _internal_add_messages();
  public:
  const ::unhinged::messaging::Message& messages(int index) const;
  ::unhinged::messaging::Message* add_messages();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::messaging::Message >&
      messages() const;

  // string receipt_handle = 2;
  void clear_receipt_handle();
  const std::string& receipt_handle() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_receipt_handle(ArgT0&& arg0, ArgT... args);
  std::string* mutable_receipt_handle();
  PROTOBUF_NODISCARD std::string* release_receipt_handle();
  void set_allocated_receipt_handle(std::string* receipt_handle);
  private:
  const std::string& _internal_receipt_handle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_receipt_handle(const std::string& value);
  std::string* _internal_mutable_receipt_handle();
  public:

  // @@protoc_insertion_point(class_scope:unhinged.messaging.ReceiveMessagesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::messaging::Message > messages_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr receipt_handle_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messaging_2eproto;
};
// -------------------------------------------------------------------

class AcknowledgeMessageRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.messaging.AcknowledgeMessageRequest) */ {
 public:
  inline AcknowledgeMessageRequest() : AcknowledgeMessageRequest(nullptr) {}
  ~AcknowledgeMessageRequest() override;
  explicit PROTOBUF_CONSTEXPR AcknowledgeMessageRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AcknowledgeMessageRequest(const AcknowledgeMessageRequest& from);
  AcknowledgeMessageRequest(AcknowledgeMessageRequest&& from) noexcept
    : AcknowledgeMessageRequest() {
    *this = ::std::move(from);
  }

  inline AcknowledgeMessageRequest& operator=(const AcknowledgeMessageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AcknowledgeMessageRequest& operator=(AcknowledgeMessageRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AcknowledgeMessageRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AcknowledgeMessageRequest* internal_default_instance() {
    return reinterpret_cast<const AcknowledgeMessageRequest*>(
               &_AcknowledgeMessageRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(AcknowledgeMessageRequest& a, AcknowledgeMessageRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AcknowledgeMessageRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AcknowledgeMessageRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AcknowledgeMessageRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AcknowledgeMessageRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AcknowledgeMessageRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AcknowledgeMessageRequest& from) {
    AcknowledgeMessageRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AcknowledgeMessageRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.messaging.AcknowledgeMessageRequest";
  }
  protected:
  explicit AcknowledgeMessageRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageIdFieldNumber = 1,
    kReceiptHandleFieldNumber = 2,
    kErrorMessageFieldNumber = 4,
    kSuccessFieldNumber = 3,
  };
  // string message_id = 1;
  void clear_message_id();
  const std::string& message_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message_id();
  PROTOBUF_NODISCARD std::string* release_message_id();
  void set_allocated_message_id(std::string* message_id);
  private:
  const std::string& _internal_message_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message_id(const std::string& value);
  std::string* _internal_mutable_message_id();
  public:

  // string receipt_handle = 2;
  void clear_receipt_handle();
  const std::string& receipt_handle() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_receipt_handle(ArgT0&& arg0, ArgT... args);
  std::string* mutable_receipt_handle();
  PROTOBUF_NODISCARD std::string* release_receipt_handle();
  void set_allocated_receipt_handle(std::string* receipt_handle);
  private:
  const std::string& _internal_receipt_handle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_receipt_handle(const std::string& value);
  std::string* _internal_mutable_receipt_handle();
  public:

  // string error_message = 4;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // bool success = 3;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.messaging.AcknowledgeMessageRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr receipt_handle_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messaging_2eproto;
};
// -------------------------------------------------------------------

class AcknowledgeMessageResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.messaging.AcknowledgeMessageResponse) */ {
 public:
  inline AcknowledgeMessageResponse() : AcknowledgeMessageResponse(nullptr) {}
  ~AcknowledgeMessageResponse() override;
  explicit PROTOBUF_CONSTEXPR AcknowledgeMessageResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AcknowledgeMessageResponse(const AcknowledgeMessageResponse& from);
  AcknowledgeMessageResponse(AcknowledgeMessageResponse&& from) noexcept
    : AcknowledgeMessageResponse() {
    *this = ::std::move(from);
  }

  inline AcknowledgeMessageResponse& operator=(const AcknowledgeMessageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AcknowledgeMessageResponse& operator=(AcknowledgeMessageResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AcknowledgeMessageResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AcknowledgeMessageResponse* internal_default_instance() {
    return reinterpret_cast<const AcknowledgeMessageResponse*>(
               &_AcknowledgeMessageResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(AcknowledgeMessageResponse& a, AcknowledgeMessageResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AcknowledgeMessageResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AcknowledgeMessageResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AcknowledgeMessageResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AcknowledgeMessageResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AcknowledgeMessageResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AcknowledgeMessageResponse& from) {
    AcknowledgeMessageResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AcknowledgeMessageResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.messaging.AcknowledgeMessageResponse";
  }
  protected:
  explicit AcknowledgeMessageResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.messaging.AcknowledgeMessageResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messaging_2eproto;
};
// -------------------------------------------------------------------

class SubscribeToMessagesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.messaging.SubscribeToMessagesRequest) */ {
 public:
  inline SubscribeToMessagesRequest() : SubscribeToMessagesRequest(nullptr) {}
  ~SubscribeToMessagesRequest() override;
  explicit PROTOBUF_CONSTEXPR SubscribeToMessagesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscribeToMessagesRequest(const SubscribeToMessagesRequest& from);
  SubscribeToMessagesRequest(SubscribeToMessagesRequest&& from) noexcept
    : SubscribeToMessagesRequest() {
    *this = ::std::move(from);
  }

  inline SubscribeToMessagesRequest& operator=(const SubscribeToMessagesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeToMessagesRequest& operator=(SubscribeToMessagesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeToMessagesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscribeToMessagesRequest* internal_default_instance() {
    return reinterpret_cast<const SubscribeToMessagesRequest*>(
               &_SubscribeToMessagesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(SubscribeToMessagesRequest& a, SubscribeToMessagesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribeToMessagesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeToMessagesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeToMessagesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscribeToMessagesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubscribeToMessagesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubscribeToMessagesRequest& from) {
    SubscribeToMessagesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscribeToMessagesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.messaging.SubscribeToMessagesRequest";
  }
  protected:
  explicit SubscribeToMessagesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageTypesFieldNumber = 2,
    kServiceNameFieldNumber = 1,
    kFilterFieldNumber = 3,
  };
  // repeated string message_types = 2;
  int message_types_size() const;
  private:
  int _internal_message_types_size() const;
  public:
  void clear_message_types();
  const std::string& message_types(int index) const;
  std::string* mutable_message_types(int index);
  void set_message_types(int index, const std::string& value);
  void set_message_types(int index, std::string&& value);
  void set_message_types(int index, const char* value);
  void set_message_types(int index, const char* value, size_t size);
  std::string* add_message_types();
  void add_message_types(const std::string& value);
  void add_message_types(std::string&& value);
  void add_message_types(const char* value);
  void add_message_types(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& message_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_message_types();
  private:
  const std::string& _internal_message_types(int index) const;
  std::string* _internal_add_message_types();
  public:

  // string service_name = 1;
  void clear_service_name();
  const std::string& service_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // .unhinged.messaging.MessageFilter filter = 3;
  bool has_filter() const;
  private:
  bool _internal_has_filter() const;
  public:
  void clear_filter();
  const ::unhinged::messaging::MessageFilter& filter() const;
  PROTOBUF_NODISCARD ::unhinged::messaging::MessageFilter* release_filter();
  ::unhinged::messaging::MessageFilter* mutable_filter();
  void set_allocated_filter(::unhinged::messaging::MessageFilter* filter);
  private:
  const ::unhinged::messaging::MessageFilter& _internal_filter() const;
  ::unhinged::messaging::MessageFilter* _internal_mutable_filter();
  public:
  void unsafe_arena_set_allocated_filter(
      ::unhinged::messaging::MessageFilter* filter);
  ::unhinged::messaging::MessageFilter* unsafe_arena_release_filter();

  // @@protoc_insertion_point(class_scope:unhinged.messaging.SubscribeToMessagesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> message_types_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
    ::unhinged::messaging::MessageFilter* filter_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messaging_2eproto;
};
// -------------------------------------------------------------------

class MessageFilter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.messaging.MessageFilter) */ {
 public:
  inline MessageFilter() : MessageFilter(nullptr) {}
  ~MessageFilter() override;
  explicit PROTOBUF_CONSTEXPR MessageFilter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MessageFilter(const MessageFilter& from);
  MessageFilter(MessageFilter&& from) noexcept
    : MessageFilter() {
    *this = ::std::move(from);
  }

  inline MessageFilter& operator=(const MessageFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessageFilter& operator=(MessageFilter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MessageFilter& default_instance() {
    return *internal_default_instance();
  }
  static inline const MessageFilter* internal_default_instance() {
    return reinterpret_cast<const MessageFilter*>(
               &_MessageFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(MessageFilter& a, MessageFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(MessageFilter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessageFilter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MessageFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MessageFilter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MessageFilter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MessageFilter& from) {
    MessageFilter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessageFilter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.messaging.MessageFilter";
  }
  protected:
  explicit MessageFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromServicesFieldNumber = 1,
    kUserIdsFieldNumber = 2,
    kSessionIdsFieldNumber = 3,
    kMetadataFilterFieldNumber = 4,
  };
  // repeated string from_services = 1;
  int from_services_size() const;
  private:
  int _internal_from_services_size() const;
  public:
  void clear_from_services();
  const std::string& from_services(int index) const;
  std::string* mutable_from_services(int index);
  void set_from_services(int index, const std::string& value);
  void set_from_services(int index, std::string&& value);
  void set_from_services(int index, const char* value);
  void set_from_services(int index, const char* value, size_t size);
  std::string* add_from_services();
  void add_from_services(const std::string& value);
  void add_from_services(std::string&& value);
  void add_from_services(const char* value);
  void add_from_services(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& from_services() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_from_services();
  private:
  const std::string& _internal_from_services(int index) const;
  std::string* _internal_add_from_services();
  public:

  // repeated string user_ids = 2;
  int user_ids_size() const;
  private:
  int _internal_user_ids_size() const;
  public:
  void clear_user_ids();
  const std::string& user_ids(int index) const;
  std::string* mutable_user_ids(int index);
  void set_user_ids(int index, const std::string& value);
  void set_user_ids(int index, std::string&& value);
  void set_user_ids(int index, const char* value);
  void set_user_ids(int index, const char* value, size_t size);
  std::string* add_user_ids();
  void add_user_ids(const std::string& value);
  void add_user_ids(std::string&& value);
  void add_user_ids(const char* value);
  void add_user_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& user_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_user_ids();
  private:
  const std::string& _internal_user_ids(int index) const;
  std::string* _internal_add_user_ids();
  public:

  // repeated string session_ids = 3;
  int session_ids_size() const;
  private:
  int _internal_session_ids_size() const;
  public:
  void clear_session_ids();
  const std::string& session_ids(int index) const;
  std::string* mutable_session_ids(int index);
  void set_session_ids(int index, const std::string& value);
  void set_session_ids(int index, std::string&& value);
  void set_session_ids(int index, const char* value);
  void set_session_ids(int index, const char* value, size_t size);
  std::string* add_session_ids();
  void add_session_ids(const std::string& value);
  void add_session_ids(std::string&& value);
  void add_session_ids(const char* value);
  void add_session_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& session_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_session_ids();
  private:
  const std::string& _internal_session_ids(int index) const;
  std::string* _internal_add_session_ids();
  public:

  // .google.protobuf.Struct metadata_filter = 4;
  bool has_metadata_filter() const;
  private:
  bool _internal_has_metadata_filter() const;
  public:
  void clear_metadata_filter();
  const ::PROTOBUF_NAMESPACE_ID::Struct& metadata_filter() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_metadata_filter();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_metadata_filter();
  void set_allocated_metadata_filter(::PROTOBUF_NAMESPACE_ID::Struct* metadata_filter);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_metadata_filter() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_metadata_filter();
  public:
  void unsafe_arena_set_allocated_metadata_filter(
      ::PROTOBUF_NAMESPACE_ID::Struct* metadata_filter);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_metadata_filter();

  // @@protoc_insertion_point(class_scope:unhinged.messaging.MessageFilter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> from_services_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> user_ids_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> session_ids_;
    ::PROTOBUF_NAMESPACE_ID::Struct* metadata_filter_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messaging_2eproto;
};
// -------------------------------------------------------------------

class MessageStreamResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.messaging.MessageStreamResponse) */ {
 public:
  inline MessageStreamResponse() : MessageStreamResponse(nullptr) {}
  ~MessageStreamResponse() override;
  explicit PROTOBUF_CONSTEXPR MessageStreamResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MessageStreamResponse(const MessageStreamResponse& from);
  MessageStreamResponse(MessageStreamResponse&& from) noexcept
    : MessageStreamResponse() {
    *this = ::std::move(from);
  }

  inline MessageStreamResponse& operator=(const MessageStreamResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessageStreamResponse& operator=(MessageStreamResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MessageStreamResponse& default_instance() {
    return *internal_default_instance();
  }
  enum ResponseTypeCase {
    kMessage = 1,
    kStatus = 2,
    kError = 3,
    RESPONSE_TYPE_NOT_SET = 0,
  };

  static inline const MessageStreamResponse* internal_default_instance() {
    return reinterpret_cast<const MessageStreamResponse*>(
               &_MessageStreamResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(MessageStreamResponse& a, MessageStreamResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MessageStreamResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessageStreamResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MessageStreamResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MessageStreamResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MessageStreamResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MessageStreamResponse& from) {
    MessageStreamResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessageStreamResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.messaging.MessageStreamResponse";
  }
  protected:
  explicit MessageStreamResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
    kStatusFieldNumber = 2,
    kErrorFieldNumber = 3,
  };
  // .unhinged.messaging.Message message = 1;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const ::unhinged::messaging::Message& message() const;
  PROTOBUF_NODISCARD ::unhinged::messaging::Message* release_message();
  ::unhinged::messaging::Message* mutable_message();
  void set_allocated_message(::unhinged::messaging::Message* message);
  private:
  const ::unhinged::messaging::Message& _internal_message() const;
  ::unhinged::messaging::Message* _internal_mutable_message();
  public:
  void unsafe_arena_set_allocated_message(
      ::unhinged::messaging::Message* message);
  ::unhinged::messaging::Message* unsafe_arena_release_message();

  // .unhinged.messaging.StreamStatus status = 2;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::unhinged::messaging::StreamStatus& status() const;
  PROTOBUF_NODISCARD ::unhinged::messaging::StreamStatus* release_status();
  ::unhinged::messaging::StreamStatus* mutable_status();
  void set_allocated_status(::unhinged::messaging::StreamStatus* status);
  private:
  const ::unhinged::messaging::StreamStatus& _internal_status() const;
  ::unhinged::messaging::StreamStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::unhinged::messaging::StreamStatus* status);
  ::unhinged::messaging::StreamStatus* unsafe_arena_release_status();

  // .unhinged.messaging.StreamError error = 3;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::unhinged::messaging::StreamError& error() const;
  PROTOBUF_NODISCARD ::unhinged::messaging::StreamError* release_error();
  ::unhinged::messaging::StreamError* mutable_error();
  void set_allocated_error(::unhinged::messaging::StreamError* error);
  private:
  const ::unhinged::messaging::StreamError& _internal_error() const;
  ::unhinged::messaging::StreamError* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::unhinged::messaging::StreamError* error);
  ::unhinged::messaging::StreamError* unsafe_arena_release_error();

  void clear_response_type();
  ResponseTypeCase response_type_case() const;
  // @@protoc_insertion_point(class_scope:unhinged.messaging.MessageStreamResponse)
 private:
  class _Internal;
  void set_has_message();
  void set_has_status();
  void set_has_error();

  inline bool has_response_type() const;
  inline void clear_has_response_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ResponseTypeUnion {
      constexpr ResponseTypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::unhinged::messaging::Message* message_;
      ::unhinged::messaging::StreamStatus* status_;
      ::unhinged::messaging::StreamError* error_;
    } response_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messaging_2eproto;
};
// -------------------------------------------------------------------

class StreamStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.messaging.StreamStatus) */ {
 public:
  inline StreamStatus() : StreamStatus(nullptr) {}
  ~StreamStatus() override;
  explicit PROTOBUF_CONSTEXPR StreamStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamStatus(const StreamStatus& from);
  StreamStatus(StreamStatus&& from) noexcept
    : StreamStatus() {
    *this = ::std::move(from);
  }

  inline StreamStatus& operator=(const StreamStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamStatus& operator=(StreamStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamStatus* internal_default_instance() {
    return reinterpret_cast<const StreamStatus*>(
               &_StreamStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(StreamStatus& a, StreamStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamStatus& from) {
    StreamStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.messaging.StreamStatus";
  }
  protected:
  explicit StreamStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kMessagesReceivedFieldNumber = 2,
  };
  // string status = 1;
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // int32 messages_received = 2;
  void clear_messages_received();
  int32_t messages_received() const;
  void set_messages_received(int32_t value);
  private:
  int32_t _internal_messages_received() const;
  void _internal_set_messages_received(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.messaging.StreamStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
    int32_t messages_received_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messaging_2eproto;
};
// -------------------------------------------------------------------

class StreamError final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.messaging.StreamError) */ {
 public:
  inline StreamError() : StreamError(nullptr) {}
  ~StreamError() override;
  explicit PROTOBUF_CONSTEXPR StreamError(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamError(const StreamError& from);
  StreamError(StreamError&& from) noexcept
    : StreamError() {
    *this = ::std::move(from);
  }

  inline StreamError& operator=(const StreamError& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamError& operator=(StreamError&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamError& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamError* internal_default_instance() {
    return reinterpret_cast<const StreamError*>(
               &_StreamError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(StreamError& a, StreamError& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamError* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamError* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamError* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamError>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamError& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamError& from) {
    StreamError::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamError* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.messaging.StreamError";
  }
  protected:
  explicit StreamError(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorCodeFieldNumber = 1,
    kErrorMessageFieldNumber = 2,
    kIsRecoverableFieldNumber = 3,
  };
  // string error_code = 1;
  void clear_error_code();
  const std::string& error_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_code();
  PROTOBUF_NODISCARD std::string* release_error_code();
  void set_allocated_error_code(std::string* error_code);
  private:
  const std::string& _internal_error_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_code(const std::string& value);
  std::string* _internal_mutable_error_code();
  public:

  // string error_message = 2;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // bool is_recoverable = 3;
  void clear_is_recoverable();
  bool is_recoverable() const;
  void set_is_recoverable(bool value);
  private:
  bool _internal_is_recoverable() const;
  void _internal_set_is_recoverable(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.messaging.StreamError)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_code_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    bool is_recoverable_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_messaging_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Message

// string message_id = 1;
inline void Message::clear_message_id() {
  _impl_.message_id_.ClearToEmpty();
}
inline const std::string& Message::message_id() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.Message.message_id)
  return _internal_message_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Message::set_message_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.Message.message_id)
}
inline std::string* Message::mutable_message_id() {
  std::string* _s = _internal_mutable_message_id();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.Message.message_id)
  return _s;
}
inline const std::string& Message::_internal_message_id() const {
  return _impl_.message_id_.Get();
}
inline void Message::_internal_set_message_id(const std::string& value) {
  
  _impl_.message_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Message::_internal_mutable_message_id() {
  
  return _impl_.message_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Message::release_message_id() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.Message.message_id)
  return _impl_.message_id_.Release();
}
inline void Message::set_allocated_message_id(std::string* message_id) {
  if (message_id != nullptr) {
    
  } else {
    
  }
  _impl_.message_id_.SetAllocated(message_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_id_.IsDefault()) {
    _impl_.message_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.Message.message_id)
}

// string message_type = 2;
inline void Message::clear_message_type() {
  _impl_.message_type_.ClearToEmpty();
}
inline const std::string& Message::message_type() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.Message.message_type)
  return _internal_message_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Message::set_message_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.Message.message_type)
}
inline std::string* Message::mutable_message_type() {
  std::string* _s = _internal_mutable_message_type();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.Message.message_type)
  return _s;
}
inline const std::string& Message::_internal_message_type() const {
  return _impl_.message_type_.Get();
}
inline void Message::_internal_set_message_type(const std::string& value) {
  
  _impl_.message_type_.Set(value, GetArenaForAllocation());
}
inline std::string* Message::_internal_mutable_message_type() {
  
  return _impl_.message_type_.Mutable(GetArenaForAllocation());
}
inline std::string* Message::release_message_type() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.Message.message_type)
  return _impl_.message_type_.Release();
}
inline void Message::set_allocated_message_type(std::string* message_type) {
  if (message_type != nullptr) {
    
  } else {
    
  }
  _impl_.message_type_.SetAllocated(message_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_type_.IsDefault()) {
    _impl_.message_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.Message.message_type)
}

// string message_version = 3;
inline void Message::clear_message_version() {
  _impl_.message_version_.ClearToEmpty();
}
inline const std::string& Message::message_version() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.Message.message_version)
  return _internal_message_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Message::set_message_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.Message.message_version)
}
inline std::string* Message::mutable_message_version() {
  std::string* _s = _internal_mutable_message_version();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.Message.message_version)
  return _s;
}
inline const std::string& Message::_internal_message_version() const {
  return _impl_.message_version_.Get();
}
inline void Message::_internal_set_message_version(const std::string& value) {
  
  _impl_.message_version_.Set(value, GetArenaForAllocation());
}
inline std::string* Message::_internal_mutable_message_version() {
  
  return _impl_.message_version_.Mutable(GetArenaForAllocation());
}
inline std::string* Message::release_message_version() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.Message.message_version)
  return _impl_.message_version_.Release();
}
inline void Message::set_allocated_message_version(std::string* message_version) {
  if (message_version != nullptr) {
    
  } else {
    
  }
  _impl_.message_version_.SetAllocated(message_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_version_.IsDefault()) {
    _impl_.message_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.Message.message_version)
}

// string from_service = 4;
inline void Message::clear_from_service() {
  _impl_.from_service_.ClearToEmpty();
}
inline const std::string& Message::from_service() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.Message.from_service)
  return _internal_from_service();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Message::set_from_service(ArgT0&& arg0, ArgT... args) {
 
 _impl_.from_service_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.Message.from_service)
}
inline std::string* Message::mutable_from_service() {
  std::string* _s = _internal_mutable_from_service();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.Message.from_service)
  return _s;
}
inline const std::string& Message::_internal_from_service() const {
  return _impl_.from_service_.Get();
}
inline void Message::_internal_set_from_service(const std::string& value) {
  
  _impl_.from_service_.Set(value, GetArenaForAllocation());
}
inline std::string* Message::_internal_mutable_from_service() {
  
  return _impl_.from_service_.Mutable(GetArenaForAllocation());
}
inline std::string* Message::release_from_service() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.Message.from_service)
  return _impl_.from_service_.Release();
}
inline void Message::set_allocated_from_service(std::string* from_service) {
  if (from_service != nullptr) {
    
  } else {
    
  }
  _impl_.from_service_.SetAllocated(from_service, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.from_service_.IsDefault()) {
    _impl_.from_service_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.Message.from_service)
}

// string to_service = 5;
inline void Message::clear_to_service() {
  _impl_.to_service_.ClearToEmpty();
}
inline const std::string& Message::to_service() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.Message.to_service)
  return _internal_to_service();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Message::set_to_service(ArgT0&& arg0, ArgT... args) {
 
 _impl_.to_service_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.Message.to_service)
}
inline std::string* Message::mutable_to_service() {
  std::string* _s = _internal_mutable_to_service();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.Message.to_service)
  return _s;
}
inline const std::string& Message::_internal_to_service() const {
  return _impl_.to_service_.Get();
}
inline void Message::_internal_set_to_service(const std::string& value) {
  
  _impl_.to_service_.Set(value, GetArenaForAllocation());
}
inline std::string* Message::_internal_mutable_to_service() {
  
  return _impl_.to_service_.Mutable(GetArenaForAllocation());
}
inline std::string* Message::release_to_service() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.Message.to_service)
  return _impl_.to_service_.Release();
}
inline void Message::set_allocated_to_service(std::string* to_service) {
  if (to_service != nullptr) {
    
  } else {
    
  }
  _impl_.to_service_.SetAllocated(to_service, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.to_service_.IsDefault()) {
    _impl_.to_service_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.Message.to_service)
}

// string routing_key = 6;
inline void Message::clear_routing_key() {
  _impl_.routing_key_.ClearToEmpty();
}
inline const std::string& Message::routing_key() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.Message.routing_key)
  return _internal_routing_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Message::set_routing_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.routing_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.Message.routing_key)
}
inline std::string* Message::mutable_routing_key() {
  std::string* _s = _internal_mutable_routing_key();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.Message.routing_key)
  return _s;
}
inline const std::string& Message::_internal_routing_key() const {
  return _impl_.routing_key_.Get();
}
inline void Message::_internal_set_routing_key(const std::string& value) {
  
  _impl_.routing_key_.Set(value, GetArenaForAllocation());
}
inline std::string* Message::_internal_mutable_routing_key() {
  
  return _impl_.routing_key_.Mutable(GetArenaForAllocation());
}
inline std::string* Message::release_routing_key() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.Message.routing_key)
  return _impl_.routing_key_.Release();
}
inline void Message::set_allocated_routing_key(std::string* routing_key) {
  if (routing_key != nullptr) {
    
  } else {
    
  }
  _impl_.routing_key_.SetAllocated(routing_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.routing_key_.IsDefault()) {
    _impl_.routing_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.Message.routing_key)
}

// .google.protobuf.Timestamp created_at = 7;
inline bool Message::_internal_has_created_at() const {
  return this != internal_default_instance() && _impl_.created_at_ != nullptr;
}
inline bool Message::has_created_at() const {
  return _internal_has_created_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Message::_internal_created_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Message::created_at() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.Message.created_at)
  return _internal_created_at();
}
inline void Message::unsafe_arena_set_allocated_created_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.Message.created_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Message::release_created_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Message::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.Message.created_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Message::_internal_mutable_created_at() {
  
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.created_at_ = p;
  }
  return _impl_.created_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Message::mutable_created_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.Message.created_at)
  return _msg;
}
inline void Message::set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at));
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.Message.created_at)
}

// .google.protobuf.Timestamp expires_at = 8;
inline bool Message::_internal_has_expires_at() const {
  return this != internal_default_instance() && _impl_.expires_at_ != nullptr;
}
inline bool Message::has_expires_at() const {
  return _internal_has_expires_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Message::_internal_expires_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.expires_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Message::expires_at() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.Message.expires_at)
  return _internal_expires_at();
}
inline void Message::unsafe_arena_set_allocated_expires_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* expires_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.expires_at_);
  }
  _impl_.expires_at_ = expires_at;
  if (expires_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.Message.expires_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Message::release_expires_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.expires_at_;
  _impl_.expires_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Message::unsafe_arena_release_expires_at() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.Message.expires_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.expires_at_;
  _impl_.expires_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Message::_internal_mutable_expires_at() {
  
  if (_impl_.expires_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.expires_at_ = p;
  }
  return _impl_.expires_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Message::mutable_expires_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_expires_at();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.Message.expires_at)
  return _msg;
}
inline void Message::set_allocated_expires_at(::PROTOBUF_NAMESPACE_ID::Timestamp* expires_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.expires_at_);
  }
  if (expires_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(expires_at));
    if (message_arena != submessage_arena) {
      expires_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, expires_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.expires_at_ = expires_at;
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.Message.expires_at)
}

// string correlation_id = 9;
inline void Message::clear_correlation_id() {
  _impl_.correlation_id_.ClearToEmpty();
}
inline const std::string& Message::correlation_id() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.Message.correlation_id)
  return _internal_correlation_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Message::set_correlation_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.correlation_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.Message.correlation_id)
}
inline std::string* Message::mutable_correlation_id() {
  std::string* _s = _internal_mutable_correlation_id();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.Message.correlation_id)
  return _s;
}
inline const std::string& Message::_internal_correlation_id() const {
  return _impl_.correlation_id_.Get();
}
inline void Message::_internal_set_correlation_id(const std::string& value) {
  
  _impl_.correlation_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Message::_internal_mutable_correlation_id() {
  
  return _impl_.correlation_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Message::release_correlation_id() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.Message.correlation_id)
  return _impl_.correlation_id_.Release();
}
inline void Message::set_allocated_correlation_id(std::string* correlation_id) {
  if (correlation_id != nullptr) {
    
  } else {
    
  }
  _impl_.correlation_id_.SetAllocated(correlation_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.correlation_id_.IsDefault()) {
    _impl_.correlation_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.Message.correlation_id)
}

// string reply_to = 10;
inline void Message::clear_reply_to() {
  _impl_.reply_to_.ClearToEmpty();
}
inline const std::string& Message::reply_to() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.Message.reply_to)
  return _internal_reply_to();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Message::set_reply_to(ArgT0&& arg0, ArgT... args) {
 
 _impl_.reply_to_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.Message.reply_to)
}
inline std::string* Message::mutable_reply_to() {
  std::string* _s = _internal_mutable_reply_to();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.Message.reply_to)
  return _s;
}
inline const std::string& Message::_internal_reply_to() const {
  return _impl_.reply_to_.Get();
}
inline void Message::_internal_set_reply_to(const std::string& value) {
  
  _impl_.reply_to_.Set(value, GetArenaForAllocation());
}
inline std::string* Message::_internal_mutable_reply_to() {
  
  return _impl_.reply_to_.Mutable(GetArenaForAllocation());
}
inline std::string* Message::release_reply_to() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.Message.reply_to)
  return _impl_.reply_to_.Release();
}
inline void Message::set_allocated_reply_to(std::string* reply_to) {
  if (reply_to != nullptr) {
    
  } else {
    
  }
  _impl_.reply_to_.SetAllocated(reply_to, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reply_to_.IsDefault()) {
    _impl_.reply_to_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.Message.reply_to)
}

// string user_id = 11;
inline void Message::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& Message::user_id() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.Message.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Message::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.Message.user_id)
}
inline std::string* Message::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.Message.user_id)
  return _s;
}
inline const std::string& Message::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void Message::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Message::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Message::release_user_id() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.Message.user_id)
  return _impl_.user_id_.Release();
}
inline void Message::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.Message.user_id)
}

// string session_id = 12;
inline void Message::clear_session_id() {
  _impl_.session_id_.ClearToEmpty();
}
inline const std::string& Message::session_id() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.Message.session_id)
  return _internal_session_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Message::set_session_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.session_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.Message.session_id)
}
inline std::string* Message::mutable_session_id() {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.Message.session_id)
  return _s;
}
inline const std::string& Message::_internal_session_id() const {
  return _impl_.session_id_.Get();
}
inline void Message::_internal_set_session_id(const std::string& value) {
  
  _impl_.session_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Message::_internal_mutable_session_id() {
  
  return _impl_.session_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Message::release_session_id() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.Message.session_id)
  return _impl_.session_id_.Release();
}
inline void Message::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  _impl_.session_id_.SetAllocated(session_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.session_id_.IsDefault()) {
    _impl_.session_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.Message.session_id)
}

// string trace_id = 13;
inline void Message::clear_trace_id() {
  _impl_.trace_id_.ClearToEmpty();
}
inline const std::string& Message::trace_id() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.Message.trace_id)
  return _internal_trace_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Message::set_trace_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.trace_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.Message.trace_id)
}
inline std::string* Message::mutable_trace_id() {
  std::string* _s = _internal_mutable_trace_id();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.Message.trace_id)
  return _s;
}
inline const std::string& Message::_internal_trace_id() const {
  return _impl_.trace_id_.Get();
}
inline void Message::_internal_set_trace_id(const std::string& value) {
  
  _impl_.trace_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Message::_internal_mutable_trace_id() {
  
  return _impl_.trace_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Message::release_trace_id() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.Message.trace_id)
  return _impl_.trace_id_.Release();
}
inline void Message::set_allocated_trace_id(std::string* trace_id) {
  if (trace_id != nullptr) {
    
  } else {
    
  }
  _impl_.trace_id_.SetAllocated(trace_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.trace_id_.IsDefault()) {
    _impl_.trace_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.Message.trace_id)
}

// .unhinged.messaging.LLMMessage llm_message = 20;
inline bool Message::_internal_has_llm_message() const {
  return payload_case() == kLlmMessage;
}
inline bool Message::has_llm_message() const {
  return _internal_has_llm_message();
}
inline void Message::set_has_llm_message() {
  _impl_._oneof_case_[0] = kLlmMessage;
}
inline void Message::clear_llm_message() {
  if (_internal_has_llm_message()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.llm_message_;
    }
    clear_has_payload();
  }
}
inline ::unhinged::messaging::LLMMessage* Message::release_llm_message() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.Message.llm_message)
  if (_internal_has_llm_message()) {
    clear_has_payload();
    ::unhinged::messaging::LLMMessage* temp = _impl_.payload_.llm_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.llm_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::messaging::LLMMessage& Message::_internal_llm_message() const {
  return _internal_has_llm_message()
      ? *_impl_.payload_.llm_message_
      : reinterpret_cast< ::unhinged::messaging::LLMMessage&>(::unhinged::messaging::_LLMMessage_default_instance_);
}
inline const ::unhinged::messaging::LLMMessage& Message::llm_message() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.Message.llm_message)
  return _internal_llm_message();
}
inline ::unhinged::messaging::LLMMessage* Message::unsafe_arena_release_llm_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.messaging.Message.llm_message)
  if (_internal_has_llm_message()) {
    clear_has_payload();
    ::unhinged::messaging::LLMMessage* temp = _impl_.payload_.llm_message_;
    _impl_.payload_.llm_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_llm_message(::unhinged::messaging::LLMMessage* llm_message) {
  clear_payload();
  if (llm_message) {
    set_has_llm_message();
    _impl_.payload_.llm_message_ = llm_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.Message.llm_message)
}
inline ::unhinged::messaging::LLMMessage* Message::_internal_mutable_llm_message() {
  if (!_internal_has_llm_message()) {
    clear_payload();
    set_has_llm_message();
    _impl_.payload_.llm_message_ = CreateMaybeMessage< ::unhinged::messaging::LLMMessage >(GetArenaForAllocation());
  }
  return _impl_.payload_.llm_message_;
}
inline ::unhinged::messaging::LLMMessage* Message::mutable_llm_message() {
  ::unhinged::messaging::LLMMessage* _msg = _internal_mutable_llm_message();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.Message.llm_message)
  return _msg;
}

// .unhinged.messaging.AgentMessage agent_message = 21;
inline bool Message::_internal_has_agent_message() const {
  return payload_case() == kAgentMessage;
}
inline bool Message::has_agent_message() const {
  return _internal_has_agent_message();
}
inline void Message::set_has_agent_message() {
  _impl_._oneof_case_[0] = kAgentMessage;
}
inline void Message::clear_agent_message() {
  if (_internal_has_agent_message()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.agent_message_;
    }
    clear_has_payload();
  }
}
inline ::unhinged::messaging::AgentMessage* Message::release_agent_message() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.Message.agent_message)
  if (_internal_has_agent_message()) {
    clear_has_payload();
    ::unhinged::messaging::AgentMessage* temp = _impl_.payload_.agent_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.agent_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::messaging::AgentMessage& Message::_internal_agent_message() const {
  return _internal_has_agent_message()
      ? *_impl_.payload_.agent_message_
      : reinterpret_cast< ::unhinged::messaging::AgentMessage&>(::unhinged::messaging::_AgentMessage_default_instance_);
}
inline const ::unhinged::messaging::AgentMessage& Message::agent_message() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.Message.agent_message)
  return _internal_agent_message();
}
inline ::unhinged::messaging::AgentMessage* Message::unsafe_arena_release_agent_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.messaging.Message.agent_message)
  if (_internal_has_agent_message()) {
    clear_has_payload();
    ::unhinged::messaging::AgentMessage* temp = _impl_.payload_.agent_message_;
    _impl_.payload_.agent_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_agent_message(::unhinged::messaging::AgentMessage* agent_message) {
  clear_payload();
  if (agent_message) {
    set_has_agent_message();
    _impl_.payload_.agent_message_ = agent_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.Message.agent_message)
}
inline ::unhinged::messaging::AgentMessage* Message::_internal_mutable_agent_message() {
  if (!_internal_has_agent_message()) {
    clear_payload();
    set_has_agent_message();
    _impl_.payload_.agent_message_ = CreateMaybeMessage< ::unhinged::messaging::AgentMessage >(GetArenaForAllocation());
  }
  return _impl_.payload_.agent_message_;
}
inline ::unhinged::messaging::AgentMessage* Message::mutable_agent_message() {
  ::unhinged::messaging::AgentMessage* _msg = _internal_mutable_agent_message();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.Message.agent_message)
  return _msg;
}

// .unhinged.messaging.ToolMessage tool_message = 22;
inline bool Message::_internal_has_tool_message() const {
  return payload_case() == kToolMessage;
}
inline bool Message::has_tool_message() const {
  return _internal_has_tool_message();
}
inline void Message::set_has_tool_message() {
  _impl_._oneof_case_[0] = kToolMessage;
}
inline void Message::clear_tool_message() {
  if (_internal_has_tool_message()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.tool_message_;
    }
    clear_has_payload();
  }
}
inline ::unhinged::messaging::ToolMessage* Message::release_tool_message() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.Message.tool_message)
  if (_internal_has_tool_message()) {
    clear_has_payload();
    ::unhinged::messaging::ToolMessage* temp = _impl_.payload_.tool_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.tool_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::messaging::ToolMessage& Message::_internal_tool_message() const {
  return _internal_has_tool_message()
      ? *_impl_.payload_.tool_message_
      : reinterpret_cast< ::unhinged::messaging::ToolMessage&>(::unhinged::messaging::_ToolMessage_default_instance_);
}
inline const ::unhinged::messaging::ToolMessage& Message::tool_message() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.Message.tool_message)
  return _internal_tool_message();
}
inline ::unhinged::messaging::ToolMessage* Message::unsafe_arena_release_tool_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.messaging.Message.tool_message)
  if (_internal_has_tool_message()) {
    clear_has_payload();
    ::unhinged::messaging::ToolMessage* temp = _impl_.payload_.tool_message_;
    _impl_.payload_.tool_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_tool_message(::unhinged::messaging::ToolMessage* tool_message) {
  clear_payload();
  if (tool_message) {
    set_has_tool_message();
    _impl_.payload_.tool_message_ = tool_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.Message.tool_message)
}
inline ::unhinged::messaging::ToolMessage* Message::_internal_mutable_tool_message() {
  if (!_internal_has_tool_message()) {
    clear_payload();
    set_has_tool_message();
    _impl_.payload_.tool_message_ = CreateMaybeMessage< ::unhinged::messaging::ToolMessage >(GetArenaForAllocation());
  }
  return _impl_.payload_.tool_message_;
}
inline ::unhinged::messaging::ToolMessage* Message::mutable_tool_message() {
  ::unhinged::messaging::ToolMessage* _msg = _internal_mutable_tool_message();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.Message.tool_message)
  return _msg;
}

// .unhinged.messaging.WorkflowMessage workflow_message = 23;
inline bool Message::_internal_has_workflow_message() const {
  return payload_case() == kWorkflowMessage;
}
inline bool Message::has_workflow_message() const {
  return _internal_has_workflow_message();
}
inline void Message::set_has_workflow_message() {
  _impl_._oneof_case_[0] = kWorkflowMessage;
}
inline void Message::clear_workflow_message() {
  if (_internal_has_workflow_message()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.workflow_message_;
    }
    clear_has_payload();
  }
}
inline ::unhinged::messaging::WorkflowMessage* Message::release_workflow_message() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.Message.workflow_message)
  if (_internal_has_workflow_message()) {
    clear_has_payload();
    ::unhinged::messaging::WorkflowMessage* temp = _impl_.payload_.workflow_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.workflow_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::messaging::WorkflowMessage& Message::_internal_workflow_message() const {
  return _internal_has_workflow_message()
      ? *_impl_.payload_.workflow_message_
      : reinterpret_cast< ::unhinged::messaging::WorkflowMessage&>(::unhinged::messaging::_WorkflowMessage_default_instance_);
}
inline const ::unhinged::messaging::WorkflowMessage& Message::workflow_message() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.Message.workflow_message)
  return _internal_workflow_message();
}
inline ::unhinged::messaging::WorkflowMessage* Message::unsafe_arena_release_workflow_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.messaging.Message.workflow_message)
  if (_internal_has_workflow_message()) {
    clear_has_payload();
    ::unhinged::messaging::WorkflowMessage* temp = _impl_.payload_.workflow_message_;
    _impl_.payload_.workflow_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_workflow_message(::unhinged::messaging::WorkflowMessage* workflow_message) {
  clear_payload();
  if (workflow_message) {
    set_has_workflow_message();
    _impl_.payload_.workflow_message_ = workflow_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.Message.workflow_message)
}
inline ::unhinged::messaging::WorkflowMessage* Message::_internal_mutable_workflow_message() {
  if (!_internal_has_workflow_message()) {
    clear_payload();
    set_has_workflow_message();
    _impl_.payload_.workflow_message_ = CreateMaybeMessage< ::unhinged::messaging::WorkflowMessage >(GetArenaForAllocation());
  }
  return _impl_.payload_.workflow_message_;
}
inline ::unhinged::messaging::WorkflowMessage* Message::mutable_workflow_message() {
  ::unhinged::messaging::WorkflowMessage* _msg = _internal_mutable_workflow_message();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.Message.workflow_message)
  return _msg;
}

// .unhinged.messaging.UIMessage ui_message = 24;
inline bool Message::_internal_has_ui_message() const {
  return payload_case() == kUiMessage;
}
inline bool Message::has_ui_message() const {
  return _internal_has_ui_message();
}
inline void Message::set_has_ui_message() {
  _impl_._oneof_case_[0] = kUiMessage;
}
inline void Message::clear_ui_message() {
  if (_internal_has_ui_message()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.ui_message_;
    }
    clear_has_payload();
  }
}
inline ::unhinged::messaging::UIMessage* Message::release_ui_message() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.Message.ui_message)
  if (_internal_has_ui_message()) {
    clear_has_payload();
    ::unhinged::messaging::UIMessage* temp = _impl_.payload_.ui_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.ui_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::messaging::UIMessage& Message::_internal_ui_message() const {
  return _internal_has_ui_message()
      ? *_impl_.payload_.ui_message_
      : reinterpret_cast< ::unhinged::messaging::UIMessage&>(::unhinged::messaging::_UIMessage_default_instance_);
}
inline const ::unhinged::messaging::UIMessage& Message::ui_message() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.Message.ui_message)
  return _internal_ui_message();
}
inline ::unhinged::messaging::UIMessage* Message::unsafe_arena_release_ui_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.messaging.Message.ui_message)
  if (_internal_has_ui_message()) {
    clear_has_payload();
    ::unhinged::messaging::UIMessage* temp = _impl_.payload_.ui_message_;
    _impl_.payload_.ui_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_ui_message(::unhinged::messaging::UIMessage* ui_message) {
  clear_payload();
  if (ui_message) {
    set_has_ui_message();
    _impl_.payload_.ui_message_ = ui_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.Message.ui_message)
}
inline ::unhinged::messaging::UIMessage* Message::_internal_mutable_ui_message() {
  if (!_internal_has_ui_message()) {
    clear_payload();
    set_has_ui_message();
    _impl_.payload_.ui_message_ = CreateMaybeMessage< ::unhinged::messaging::UIMessage >(GetArenaForAllocation());
  }
  return _impl_.payload_.ui_message_;
}
inline ::unhinged::messaging::UIMessage* Message::mutable_ui_message() {
  ::unhinged::messaging::UIMessage* _msg = _internal_mutable_ui_message();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.Message.ui_message)
  return _msg;
}

// .unhinged.messaging.SystemMessage system_message = 25;
inline bool Message::_internal_has_system_message() const {
  return payload_case() == kSystemMessage;
}
inline bool Message::has_system_message() const {
  return _internal_has_system_message();
}
inline void Message::set_has_system_message() {
  _impl_._oneof_case_[0] = kSystemMessage;
}
inline void Message::clear_system_message() {
  if (_internal_has_system_message()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.system_message_;
    }
    clear_has_payload();
  }
}
inline ::unhinged::messaging::SystemMessage* Message::release_system_message() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.Message.system_message)
  if (_internal_has_system_message()) {
    clear_has_payload();
    ::unhinged::messaging::SystemMessage* temp = _impl_.payload_.system_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.system_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::messaging::SystemMessage& Message::_internal_system_message() const {
  return _internal_has_system_message()
      ? *_impl_.payload_.system_message_
      : reinterpret_cast< ::unhinged::messaging::SystemMessage&>(::unhinged::messaging::_SystemMessage_default_instance_);
}
inline const ::unhinged::messaging::SystemMessage& Message::system_message() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.Message.system_message)
  return _internal_system_message();
}
inline ::unhinged::messaging::SystemMessage* Message::unsafe_arena_release_system_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.messaging.Message.system_message)
  if (_internal_has_system_message()) {
    clear_has_payload();
    ::unhinged::messaging::SystemMessage* temp = _impl_.payload_.system_message_;
    _impl_.payload_.system_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_system_message(::unhinged::messaging::SystemMessage* system_message) {
  clear_payload();
  if (system_message) {
    set_has_system_message();
    _impl_.payload_.system_message_ = system_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.Message.system_message)
}
inline ::unhinged::messaging::SystemMessage* Message::_internal_mutable_system_message() {
  if (!_internal_has_system_message()) {
    clear_payload();
    set_has_system_message();
    _impl_.payload_.system_message_ = CreateMaybeMessage< ::unhinged::messaging::SystemMessage >(GetArenaForAllocation());
  }
  return _impl_.payload_.system_message_;
}
inline ::unhinged::messaging::SystemMessage* Message::mutable_system_message() {
  ::unhinged::messaging::SystemMessage* _msg = _internal_mutable_system_message();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.Message.system_message)
  return _msg;
}

// .unhinged.messaging.MessageOptions options = 30;
inline bool Message::_internal_has_options() const {
  return this != internal_default_instance() && _impl_.options_ != nullptr;
}
inline bool Message::has_options() const {
  return _internal_has_options();
}
inline void Message::clear_options() {
  if (GetArenaForAllocation() == nullptr && _impl_.options_ != nullptr) {
    delete _impl_.options_;
  }
  _impl_.options_ = nullptr;
}
inline const ::unhinged::messaging::MessageOptions& Message::_internal_options() const {
  const ::unhinged::messaging::MessageOptions* p = _impl_.options_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::messaging::MessageOptions&>(
      ::unhinged::messaging::_MessageOptions_default_instance_);
}
inline const ::unhinged::messaging::MessageOptions& Message::options() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.Message.options)
  return _internal_options();
}
inline void Message::unsafe_arena_set_allocated_options(
    ::unhinged::messaging::MessageOptions* options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.options_);
  }
  _impl_.options_ = options;
  if (options) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.Message.options)
}
inline ::unhinged::messaging::MessageOptions* Message::release_options() {
  
  ::unhinged::messaging::MessageOptions* temp = _impl_.options_;
  _impl_.options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::messaging::MessageOptions* Message::unsafe_arena_release_options() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.Message.options)
  
  ::unhinged::messaging::MessageOptions* temp = _impl_.options_;
  _impl_.options_ = nullptr;
  return temp;
}
inline ::unhinged::messaging::MessageOptions* Message::_internal_mutable_options() {
  
  if (_impl_.options_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::messaging::MessageOptions>(GetArenaForAllocation());
    _impl_.options_ = p;
  }
  return _impl_.options_;
}
inline ::unhinged::messaging::MessageOptions* Message::mutable_options() {
  ::unhinged::messaging::MessageOptions* _msg = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.Message.options)
  return _msg;
}
inline void Message::set_allocated_options(::unhinged::messaging::MessageOptions* options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.options_;
  }
  if (options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(options);
    if (message_arena != submessage_arena) {
      options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.options_ = options;
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.Message.options)
}

// .google.protobuf.Struct metadata = 31;
inline bool Message::_internal_has_metadata() const {
  return this != internal_default_instance() && _impl_.metadata_ != nullptr;
}
inline bool Message::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& Message::_internal_metadata() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& Message::metadata() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.Message.metadata)
  return _internal_metadata();
}
inline void Message::unsafe_arena_set_allocated_metadata(
    ::PROTOBUF_NAMESPACE_ID::Struct* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.Message.metadata)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Message::release_metadata() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Message::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.Message.metadata)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Message::_internal_mutable_metadata() {
  
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Message::mutable_metadata() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.Message.metadata)
  return _msg;
}
inline void Message::set_allocated_metadata(::PROTOBUF_NAMESPACE_ID::Struct* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.Message.metadata)
}

inline bool Message::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void Message::clear_has_payload() {
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline Message::PayloadCase Message::payload_case() const {
  return Message::PayloadCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// MessageOptions

// string delivery_mode = 1;
inline void MessageOptions::clear_delivery_mode() {
  _impl_.delivery_mode_.ClearToEmpty();
}
inline const std::string& MessageOptions::delivery_mode() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.MessageOptions.delivery_mode)
  return _internal_delivery_mode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MessageOptions::set_delivery_mode(ArgT0&& arg0, ArgT... args) {
 
 _impl_.delivery_mode_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.MessageOptions.delivery_mode)
}
inline std::string* MessageOptions::mutable_delivery_mode() {
  std::string* _s = _internal_mutable_delivery_mode();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.MessageOptions.delivery_mode)
  return _s;
}
inline const std::string& MessageOptions::_internal_delivery_mode() const {
  return _impl_.delivery_mode_.Get();
}
inline void MessageOptions::_internal_set_delivery_mode(const std::string& value) {
  
  _impl_.delivery_mode_.Set(value, GetArenaForAllocation());
}
inline std::string* MessageOptions::_internal_mutable_delivery_mode() {
  
  return _impl_.delivery_mode_.Mutable(GetArenaForAllocation());
}
inline std::string* MessageOptions::release_delivery_mode() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.MessageOptions.delivery_mode)
  return _impl_.delivery_mode_.Release();
}
inline void MessageOptions::set_allocated_delivery_mode(std::string* delivery_mode) {
  if (delivery_mode != nullptr) {
    
  } else {
    
  }
  _impl_.delivery_mode_.SetAllocated(delivery_mode, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.delivery_mode_.IsDefault()) {
    _impl_.delivery_mode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.MessageOptions.delivery_mode)
}

// int32 retry_attempts = 2;
inline void MessageOptions::clear_retry_attempts() {
  _impl_.retry_attempts_ = 0;
}
inline int32_t MessageOptions::_internal_retry_attempts() const {
  return _impl_.retry_attempts_;
}
inline int32_t MessageOptions::retry_attempts() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.MessageOptions.retry_attempts)
  return _internal_retry_attempts();
}
inline void MessageOptions::_internal_set_retry_attempts(int32_t value) {
  
  _impl_.retry_attempts_ = value;
}
inline void MessageOptions::set_retry_attempts(int32_t value) {
  _internal_set_retry_attempts(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.MessageOptions.retry_attempts)
}

// int32 retry_delay_ms = 3;
inline void MessageOptions::clear_retry_delay_ms() {
  _impl_.retry_delay_ms_ = 0;
}
inline int32_t MessageOptions::_internal_retry_delay_ms() const {
  return _impl_.retry_delay_ms_;
}
inline int32_t MessageOptions::retry_delay_ms() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.MessageOptions.retry_delay_ms)
  return _internal_retry_delay_ms();
}
inline void MessageOptions::_internal_set_retry_delay_ms(int32_t value) {
  
  _impl_.retry_delay_ms_ = value;
}
inline void MessageOptions::set_retry_delay_ms(int32_t value) {
  _internal_set_retry_delay_ms(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.MessageOptions.retry_delay_ms)
}

// int32 priority = 4;
inline void MessageOptions::clear_priority() {
  _impl_.priority_ = 0;
}
inline int32_t MessageOptions::_internal_priority() const {
  return _impl_.priority_;
}
inline int32_t MessageOptions::priority() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.MessageOptions.priority)
  return _internal_priority();
}
inline void MessageOptions::_internal_set_priority(int32_t value) {
  
  _impl_.priority_ = value;
}
inline void MessageOptions::set_priority(int32_t value) {
  _internal_set_priority(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.MessageOptions.priority)
}

// bool preserve_order = 5;
inline void MessageOptions::clear_preserve_order() {
  _impl_.preserve_order_ = false;
}
inline bool MessageOptions::_internal_preserve_order() const {
  return _impl_.preserve_order_;
}
inline bool MessageOptions::preserve_order() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.MessageOptions.preserve_order)
  return _internal_preserve_order();
}
inline void MessageOptions::_internal_set_preserve_order(bool value) {
  
  _impl_.preserve_order_ = value;
}
inline void MessageOptions::set_preserve_order(bool value) {
  _internal_set_preserve_order(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.MessageOptions.preserve_order)
}

// bool expect_reply = 6;
inline void MessageOptions::clear_expect_reply() {
  _impl_.expect_reply_ = false;
}
inline bool MessageOptions::_internal_expect_reply() const {
  return _impl_.expect_reply_;
}
inline bool MessageOptions::expect_reply() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.MessageOptions.expect_reply)
  return _internal_expect_reply();
}
inline void MessageOptions::_internal_set_expect_reply(bool value) {
  
  _impl_.expect_reply_ = value;
}
inline void MessageOptions::set_expect_reply(bool value) {
  _internal_set_expect_reply(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.MessageOptions.expect_reply)
}

// int32 reply_timeout_ms = 7;
inline void MessageOptions::clear_reply_timeout_ms() {
  _impl_.reply_timeout_ms_ = 0;
}
inline int32_t MessageOptions::_internal_reply_timeout_ms() const {
  return _impl_.reply_timeout_ms_;
}
inline int32_t MessageOptions::reply_timeout_ms() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.MessageOptions.reply_timeout_ms)
  return _internal_reply_timeout_ms();
}
inline void MessageOptions::_internal_set_reply_timeout_ms(int32_t value) {
  
  _impl_.reply_timeout_ms_ = value;
}
inline void MessageOptions::set_reply_timeout_ms(int32_t value) {
  _internal_set_reply_timeout_ms(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.MessageOptions.reply_timeout_ms)
}

// -------------------------------------------------------------------

// LLMMessage

// string interaction_id = 1;
inline void LLMMessage::clear_interaction_id() {
  _impl_.interaction_id_.ClearToEmpty();
}
inline const std::string& LLMMessage::interaction_id() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.LLMMessage.interaction_id)
  return _internal_interaction_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LLMMessage::set_interaction_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.interaction_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.LLMMessage.interaction_id)
}
inline std::string* LLMMessage::mutable_interaction_id() {
  std::string* _s = _internal_mutable_interaction_id();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.LLMMessage.interaction_id)
  return _s;
}
inline const std::string& LLMMessage::_internal_interaction_id() const {
  return _impl_.interaction_id_.Get();
}
inline void LLMMessage::_internal_set_interaction_id(const std::string& value) {
  
  _impl_.interaction_id_.Set(value, GetArenaForAllocation());
}
inline std::string* LLMMessage::_internal_mutable_interaction_id() {
  
  return _impl_.interaction_id_.Mutable(GetArenaForAllocation());
}
inline std::string* LLMMessage::release_interaction_id() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.LLMMessage.interaction_id)
  return _impl_.interaction_id_.Release();
}
inline void LLMMessage::set_allocated_interaction_id(std::string* interaction_id) {
  if (interaction_id != nullptr) {
    
  } else {
    
  }
  _impl_.interaction_id_.SetAllocated(interaction_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.interaction_id_.IsDefault()) {
    _impl_.interaction_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.LLMMessage.interaction_id)
}

// .unhinged.messaging.LLMMessageType message_type = 2;
inline void LLMMessage::clear_message_type() {
  _impl_.message_type_ = 0;
}
inline ::unhinged::messaging::LLMMessageType LLMMessage::_internal_message_type() const {
  return static_cast< ::unhinged::messaging::LLMMessageType >(_impl_.message_type_);
}
inline ::unhinged::messaging::LLMMessageType LLMMessage::message_type() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.LLMMessage.message_type)
  return _internal_message_type();
}
inline void LLMMessage::_internal_set_message_type(::unhinged::messaging::LLMMessageType value) {
  
  _impl_.message_type_ = value;
}
inline void LLMMessage::set_message_type(::unhinged::messaging::LLMMessageType value) {
  _internal_set_message_type(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.LLMMessage.message_type)
}

// .unhinged.messaging.LLMPromptRequest prompt_request = 10;
inline bool LLMMessage::_internal_has_prompt_request() const {
  return message_data_case() == kPromptRequest;
}
inline bool LLMMessage::has_prompt_request() const {
  return _internal_has_prompt_request();
}
inline void LLMMessage::set_has_prompt_request() {
  _impl_._oneof_case_[0] = kPromptRequest;
}
inline void LLMMessage::clear_prompt_request() {
  if (_internal_has_prompt_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_data_.prompt_request_;
    }
    clear_has_message_data();
  }
}
inline ::unhinged::messaging::LLMPromptRequest* LLMMessage::release_prompt_request() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.LLMMessage.prompt_request)
  if (_internal_has_prompt_request()) {
    clear_has_message_data();
    ::unhinged::messaging::LLMPromptRequest* temp = _impl_.message_data_.prompt_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_data_.prompt_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::messaging::LLMPromptRequest& LLMMessage::_internal_prompt_request() const {
  return _internal_has_prompt_request()
      ? *_impl_.message_data_.prompt_request_
      : reinterpret_cast< ::unhinged::messaging::LLMPromptRequest&>(::unhinged::messaging::_LLMPromptRequest_default_instance_);
}
inline const ::unhinged::messaging::LLMPromptRequest& LLMMessage::prompt_request() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.LLMMessage.prompt_request)
  return _internal_prompt_request();
}
inline ::unhinged::messaging::LLMPromptRequest* LLMMessage::unsafe_arena_release_prompt_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.messaging.LLMMessage.prompt_request)
  if (_internal_has_prompt_request()) {
    clear_has_message_data();
    ::unhinged::messaging::LLMPromptRequest* temp = _impl_.message_data_.prompt_request_;
    _impl_.message_data_.prompt_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LLMMessage::unsafe_arena_set_allocated_prompt_request(::unhinged::messaging::LLMPromptRequest* prompt_request) {
  clear_message_data();
  if (prompt_request) {
    set_has_prompt_request();
    _impl_.message_data_.prompt_request_ = prompt_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.LLMMessage.prompt_request)
}
inline ::unhinged::messaging::LLMPromptRequest* LLMMessage::_internal_mutable_prompt_request() {
  if (!_internal_has_prompt_request()) {
    clear_message_data();
    set_has_prompt_request();
    _impl_.message_data_.prompt_request_ = CreateMaybeMessage< ::unhinged::messaging::LLMPromptRequest >(GetArenaForAllocation());
  }
  return _impl_.message_data_.prompt_request_;
}
inline ::unhinged::messaging::LLMPromptRequest* LLMMessage::mutable_prompt_request() {
  ::unhinged::messaging::LLMPromptRequest* _msg = _internal_mutable_prompt_request();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.LLMMessage.prompt_request)
  return _msg;
}

// .unhinged.messaging.LLMPromptResponse prompt_response = 11;
inline bool LLMMessage::_internal_has_prompt_response() const {
  return message_data_case() == kPromptResponse;
}
inline bool LLMMessage::has_prompt_response() const {
  return _internal_has_prompt_response();
}
inline void LLMMessage::set_has_prompt_response() {
  _impl_._oneof_case_[0] = kPromptResponse;
}
inline void LLMMessage::clear_prompt_response() {
  if (_internal_has_prompt_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_data_.prompt_response_;
    }
    clear_has_message_data();
  }
}
inline ::unhinged::messaging::LLMPromptResponse* LLMMessage::release_prompt_response() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.LLMMessage.prompt_response)
  if (_internal_has_prompt_response()) {
    clear_has_message_data();
    ::unhinged::messaging::LLMPromptResponse* temp = _impl_.message_data_.prompt_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_data_.prompt_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::messaging::LLMPromptResponse& LLMMessage::_internal_prompt_response() const {
  return _internal_has_prompt_response()
      ? *_impl_.message_data_.prompt_response_
      : reinterpret_cast< ::unhinged::messaging::LLMPromptResponse&>(::unhinged::messaging::_LLMPromptResponse_default_instance_);
}
inline const ::unhinged::messaging::LLMPromptResponse& LLMMessage::prompt_response() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.LLMMessage.prompt_response)
  return _internal_prompt_response();
}
inline ::unhinged::messaging::LLMPromptResponse* LLMMessage::unsafe_arena_release_prompt_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.messaging.LLMMessage.prompt_response)
  if (_internal_has_prompt_response()) {
    clear_has_message_data();
    ::unhinged::messaging::LLMPromptResponse* temp = _impl_.message_data_.prompt_response_;
    _impl_.message_data_.prompt_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LLMMessage::unsafe_arena_set_allocated_prompt_response(::unhinged::messaging::LLMPromptResponse* prompt_response) {
  clear_message_data();
  if (prompt_response) {
    set_has_prompt_response();
    _impl_.message_data_.prompt_response_ = prompt_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.LLMMessage.prompt_response)
}
inline ::unhinged::messaging::LLMPromptResponse* LLMMessage::_internal_mutable_prompt_response() {
  if (!_internal_has_prompt_response()) {
    clear_message_data();
    set_has_prompt_response();
    _impl_.message_data_.prompt_response_ = CreateMaybeMessage< ::unhinged::messaging::LLMPromptResponse >(GetArenaForAllocation());
  }
  return _impl_.message_data_.prompt_response_;
}
inline ::unhinged::messaging::LLMPromptResponse* LLMMessage::mutable_prompt_response() {
  ::unhinged::messaging::LLMPromptResponse* _msg = _internal_mutable_prompt_response();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.LLMMessage.prompt_response)
  return _msg;
}

// .unhinged.messaging.LLMStreamChunk stream_chunk = 12;
inline bool LLMMessage::_internal_has_stream_chunk() const {
  return message_data_case() == kStreamChunk;
}
inline bool LLMMessage::has_stream_chunk() const {
  return _internal_has_stream_chunk();
}
inline void LLMMessage::set_has_stream_chunk() {
  _impl_._oneof_case_[0] = kStreamChunk;
}
inline void LLMMessage::clear_stream_chunk() {
  if (_internal_has_stream_chunk()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_data_.stream_chunk_;
    }
    clear_has_message_data();
  }
}
inline ::unhinged::messaging::LLMStreamChunk* LLMMessage::release_stream_chunk() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.LLMMessage.stream_chunk)
  if (_internal_has_stream_chunk()) {
    clear_has_message_data();
    ::unhinged::messaging::LLMStreamChunk* temp = _impl_.message_data_.stream_chunk_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_data_.stream_chunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::messaging::LLMStreamChunk& LLMMessage::_internal_stream_chunk() const {
  return _internal_has_stream_chunk()
      ? *_impl_.message_data_.stream_chunk_
      : reinterpret_cast< ::unhinged::messaging::LLMStreamChunk&>(::unhinged::messaging::_LLMStreamChunk_default_instance_);
}
inline const ::unhinged::messaging::LLMStreamChunk& LLMMessage::stream_chunk() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.LLMMessage.stream_chunk)
  return _internal_stream_chunk();
}
inline ::unhinged::messaging::LLMStreamChunk* LLMMessage::unsafe_arena_release_stream_chunk() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.messaging.LLMMessage.stream_chunk)
  if (_internal_has_stream_chunk()) {
    clear_has_message_data();
    ::unhinged::messaging::LLMStreamChunk* temp = _impl_.message_data_.stream_chunk_;
    _impl_.message_data_.stream_chunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LLMMessage::unsafe_arena_set_allocated_stream_chunk(::unhinged::messaging::LLMStreamChunk* stream_chunk) {
  clear_message_data();
  if (stream_chunk) {
    set_has_stream_chunk();
    _impl_.message_data_.stream_chunk_ = stream_chunk;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.LLMMessage.stream_chunk)
}
inline ::unhinged::messaging::LLMStreamChunk* LLMMessage::_internal_mutable_stream_chunk() {
  if (!_internal_has_stream_chunk()) {
    clear_message_data();
    set_has_stream_chunk();
    _impl_.message_data_.stream_chunk_ = CreateMaybeMessage< ::unhinged::messaging::LLMStreamChunk >(GetArenaForAllocation());
  }
  return _impl_.message_data_.stream_chunk_;
}
inline ::unhinged::messaging::LLMStreamChunk* LLMMessage::mutable_stream_chunk() {
  ::unhinged::messaging::LLMStreamChunk* _msg = _internal_mutable_stream_chunk();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.LLMMessage.stream_chunk)
  return _msg;
}

// .unhinged.messaging.LLMError llm_error = 13;
inline bool LLMMessage::_internal_has_llm_error() const {
  return message_data_case() == kLlmError;
}
inline bool LLMMessage::has_llm_error() const {
  return _internal_has_llm_error();
}
inline void LLMMessage::set_has_llm_error() {
  _impl_._oneof_case_[0] = kLlmError;
}
inline void LLMMessage::clear_llm_error() {
  if (_internal_has_llm_error()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_data_.llm_error_;
    }
    clear_has_message_data();
  }
}
inline ::unhinged::messaging::LLMError* LLMMessage::release_llm_error() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.LLMMessage.llm_error)
  if (_internal_has_llm_error()) {
    clear_has_message_data();
    ::unhinged::messaging::LLMError* temp = _impl_.message_data_.llm_error_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_data_.llm_error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::messaging::LLMError& LLMMessage::_internal_llm_error() const {
  return _internal_has_llm_error()
      ? *_impl_.message_data_.llm_error_
      : reinterpret_cast< ::unhinged::messaging::LLMError&>(::unhinged::messaging::_LLMError_default_instance_);
}
inline const ::unhinged::messaging::LLMError& LLMMessage::llm_error() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.LLMMessage.llm_error)
  return _internal_llm_error();
}
inline ::unhinged::messaging::LLMError* LLMMessage::unsafe_arena_release_llm_error() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.messaging.LLMMessage.llm_error)
  if (_internal_has_llm_error()) {
    clear_has_message_data();
    ::unhinged::messaging::LLMError* temp = _impl_.message_data_.llm_error_;
    _impl_.message_data_.llm_error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LLMMessage::unsafe_arena_set_allocated_llm_error(::unhinged::messaging::LLMError* llm_error) {
  clear_message_data();
  if (llm_error) {
    set_has_llm_error();
    _impl_.message_data_.llm_error_ = llm_error;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.LLMMessage.llm_error)
}
inline ::unhinged::messaging::LLMError* LLMMessage::_internal_mutable_llm_error() {
  if (!_internal_has_llm_error()) {
    clear_message_data();
    set_has_llm_error();
    _impl_.message_data_.llm_error_ = CreateMaybeMessage< ::unhinged::messaging::LLMError >(GetArenaForAllocation());
  }
  return _impl_.message_data_.llm_error_;
}
inline ::unhinged::messaging::LLMError* LLMMessage::mutable_llm_error() {
  ::unhinged::messaging::LLMError* _msg = _internal_mutable_llm_error();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.LLMMessage.llm_error)
  return _msg;
}

// .unhinged.messaging.LLMCancel cancel_request = 14;
inline bool LLMMessage::_internal_has_cancel_request() const {
  return message_data_case() == kCancelRequest;
}
inline bool LLMMessage::has_cancel_request() const {
  return _internal_has_cancel_request();
}
inline void LLMMessage::set_has_cancel_request() {
  _impl_._oneof_case_[0] = kCancelRequest;
}
inline void LLMMessage::clear_cancel_request() {
  if (_internal_has_cancel_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_data_.cancel_request_;
    }
    clear_has_message_data();
  }
}
inline ::unhinged::messaging::LLMCancel* LLMMessage::release_cancel_request() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.LLMMessage.cancel_request)
  if (_internal_has_cancel_request()) {
    clear_has_message_data();
    ::unhinged::messaging::LLMCancel* temp = _impl_.message_data_.cancel_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_data_.cancel_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::messaging::LLMCancel& LLMMessage::_internal_cancel_request() const {
  return _internal_has_cancel_request()
      ? *_impl_.message_data_.cancel_request_
      : reinterpret_cast< ::unhinged::messaging::LLMCancel&>(::unhinged::messaging::_LLMCancel_default_instance_);
}
inline const ::unhinged::messaging::LLMCancel& LLMMessage::cancel_request() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.LLMMessage.cancel_request)
  return _internal_cancel_request();
}
inline ::unhinged::messaging::LLMCancel* LLMMessage::unsafe_arena_release_cancel_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.messaging.LLMMessage.cancel_request)
  if (_internal_has_cancel_request()) {
    clear_has_message_data();
    ::unhinged::messaging::LLMCancel* temp = _impl_.message_data_.cancel_request_;
    _impl_.message_data_.cancel_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LLMMessage::unsafe_arena_set_allocated_cancel_request(::unhinged::messaging::LLMCancel* cancel_request) {
  clear_message_data();
  if (cancel_request) {
    set_has_cancel_request();
    _impl_.message_data_.cancel_request_ = cancel_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.LLMMessage.cancel_request)
}
inline ::unhinged::messaging::LLMCancel* LLMMessage::_internal_mutable_cancel_request() {
  if (!_internal_has_cancel_request()) {
    clear_message_data();
    set_has_cancel_request();
    _impl_.message_data_.cancel_request_ = CreateMaybeMessage< ::unhinged::messaging::LLMCancel >(GetArenaForAllocation());
  }
  return _impl_.message_data_.cancel_request_;
}
inline ::unhinged::messaging::LLMCancel* LLMMessage::mutable_cancel_request() {
  ::unhinged::messaging::LLMCancel* _msg = _internal_mutable_cancel_request();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.LLMMessage.cancel_request)
  return _msg;
}

inline bool LLMMessage::has_message_data() const {
  return message_data_case() != MESSAGE_DATA_NOT_SET;
}
inline void LLMMessage::clear_has_message_data() {
  _impl_._oneof_case_[0] = MESSAGE_DATA_NOT_SET;
}
inline LLMMessage::MessageDataCase LLMMessage::message_data_case() const {
  return LLMMessage::MessageDataCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// LLMPromptRequest

// string model_name = 1;
inline void LLMPromptRequest::clear_model_name() {
  _impl_.model_name_.ClearToEmpty();
}
inline const std::string& LLMPromptRequest::model_name() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.LLMPromptRequest.model_name)
  return _internal_model_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LLMPromptRequest::set_model_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.LLMPromptRequest.model_name)
}
inline std::string* LLMPromptRequest::mutable_model_name() {
  std::string* _s = _internal_mutable_model_name();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.LLMPromptRequest.model_name)
  return _s;
}
inline const std::string& LLMPromptRequest::_internal_model_name() const {
  return _impl_.model_name_.Get();
}
inline void LLMPromptRequest::_internal_set_model_name(const std::string& value) {
  
  _impl_.model_name_.Set(value, GetArenaForAllocation());
}
inline std::string* LLMPromptRequest::_internal_mutable_model_name() {
  
  return _impl_.model_name_.Mutable(GetArenaForAllocation());
}
inline std::string* LLMPromptRequest::release_model_name() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.LLMPromptRequest.model_name)
  return _impl_.model_name_.Release();
}
inline void LLMPromptRequest::set_allocated_model_name(std::string* model_name) {
  if (model_name != nullptr) {
    
  } else {
    
  }
  _impl_.model_name_.SetAllocated(model_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_name_.IsDefault()) {
    _impl_.model_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.LLMPromptRequest.model_name)
}

// string provider = 2;
inline void LLMPromptRequest::clear_provider() {
  _impl_.provider_.ClearToEmpty();
}
inline const std::string& LLMPromptRequest::provider() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.LLMPromptRequest.provider)
  return _internal_provider();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LLMPromptRequest::set_provider(ArgT0&& arg0, ArgT... args) {
 
 _impl_.provider_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.LLMPromptRequest.provider)
}
inline std::string* LLMPromptRequest::mutable_provider() {
  std::string* _s = _internal_mutable_provider();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.LLMPromptRequest.provider)
  return _s;
}
inline const std::string& LLMPromptRequest::_internal_provider() const {
  return _impl_.provider_.Get();
}
inline void LLMPromptRequest::_internal_set_provider(const std::string& value) {
  
  _impl_.provider_.Set(value, GetArenaForAllocation());
}
inline std::string* LLMPromptRequest::_internal_mutable_provider() {
  
  return _impl_.provider_.Mutable(GetArenaForAllocation());
}
inline std::string* LLMPromptRequest::release_provider() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.LLMPromptRequest.provider)
  return _impl_.provider_.Release();
}
inline void LLMPromptRequest::set_allocated_provider(std::string* provider) {
  if (provider != nullptr) {
    
  } else {
    
  }
  _impl_.provider_.SetAllocated(provider, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.provider_.IsDefault()) {
    _impl_.provider_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.LLMPromptRequest.provider)
}

// string system_prompt = 3;
inline void LLMPromptRequest::clear_system_prompt() {
  _impl_.system_prompt_.ClearToEmpty();
}
inline const std::string& LLMPromptRequest::system_prompt() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.LLMPromptRequest.system_prompt)
  return _internal_system_prompt();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LLMPromptRequest::set_system_prompt(ArgT0&& arg0, ArgT... args) {
 
 _impl_.system_prompt_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.LLMPromptRequest.system_prompt)
}
inline std::string* LLMPromptRequest::mutable_system_prompt() {
  std::string* _s = _internal_mutable_system_prompt();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.LLMPromptRequest.system_prompt)
  return _s;
}
inline const std::string& LLMPromptRequest::_internal_system_prompt() const {
  return _impl_.system_prompt_.Get();
}
inline void LLMPromptRequest::_internal_set_system_prompt(const std::string& value) {
  
  _impl_.system_prompt_.Set(value, GetArenaForAllocation());
}
inline std::string* LLMPromptRequest::_internal_mutable_system_prompt() {
  
  return _impl_.system_prompt_.Mutable(GetArenaForAllocation());
}
inline std::string* LLMPromptRequest::release_system_prompt() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.LLMPromptRequest.system_prompt)
  return _impl_.system_prompt_.Release();
}
inline void LLMPromptRequest::set_allocated_system_prompt(std::string* system_prompt) {
  if (system_prompt != nullptr) {
    
  } else {
    
  }
  _impl_.system_prompt_.SetAllocated(system_prompt, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.system_prompt_.IsDefault()) {
    _impl_.system_prompt_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.LLMPromptRequest.system_prompt)
}

// string user_prompt = 4;
inline void LLMPromptRequest::clear_user_prompt() {
  _impl_.user_prompt_.ClearToEmpty();
}
inline const std::string& LLMPromptRequest::user_prompt() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.LLMPromptRequest.user_prompt)
  return _internal_user_prompt();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LLMPromptRequest::set_user_prompt(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_prompt_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.LLMPromptRequest.user_prompt)
}
inline std::string* LLMPromptRequest::mutable_user_prompt() {
  std::string* _s = _internal_mutable_user_prompt();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.LLMPromptRequest.user_prompt)
  return _s;
}
inline const std::string& LLMPromptRequest::_internal_user_prompt() const {
  return _impl_.user_prompt_.Get();
}
inline void LLMPromptRequest::_internal_set_user_prompt(const std::string& value) {
  
  _impl_.user_prompt_.Set(value, GetArenaForAllocation());
}
inline std::string* LLMPromptRequest::_internal_mutable_user_prompt() {
  
  return _impl_.user_prompt_.Mutable(GetArenaForAllocation());
}
inline std::string* LLMPromptRequest::release_user_prompt() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.LLMPromptRequest.user_prompt)
  return _impl_.user_prompt_.Release();
}
inline void LLMPromptRequest::set_allocated_user_prompt(std::string* user_prompt) {
  if (user_prompt != nullptr) {
    
  } else {
    
  }
  _impl_.user_prompt_.SetAllocated(user_prompt, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_prompt_.IsDefault()) {
    _impl_.user_prompt_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.LLMPromptRequest.user_prompt)
}

// repeated .unhinged.messaging.ContextDocument context_documents = 5;
inline int LLMPromptRequest::_internal_context_documents_size() const {
  return _impl_.context_documents_.size();
}
inline int LLMPromptRequest::context_documents_size() const {
  return _internal_context_documents_size();
}
inline void LLMPromptRequest::clear_context_documents() {
  _impl_.context_documents_.Clear();
}
inline ::unhinged::messaging::ContextDocument* LLMPromptRequest::mutable_context_documents(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.LLMPromptRequest.context_documents)
  return _impl_.context_documents_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::messaging::ContextDocument >*
LLMPromptRequest::mutable_context_documents() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.messaging.LLMPromptRequest.context_documents)
  return &_impl_.context_documents_;
}
inline const ::unhinged::messaging::ContextDocument& LLMPromptRequest::_internal_context_documents(int index) const {
  return _impl_.context_documents_.Get(index);
}
inline const ::unhinged::messaging::ContextDocument& LLMPromptRequest::context_documents(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.LLMPromptRequest.context_documents)
  return _internal_context_documents(index);
}
inline ::unhinged::messaging::ContextDocument* LLMPromptRequest::_internal_add_context_documents() {
  return _impl_.context_documents_.Add();
}
inline ::unhinged::messaging::ContextDocument* LLMPromptRequest::add_context_documents() {
  ::unhinged::messaging::ContextDocument* _add = _internal_add_context_documents();
  // @@protoc_insertion_point(field_add:unhinged.messaging.LLMPromptRequest.context_documents)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::messaging::ContextDocument >&
LLMPromptRequest::context_documents() const {
  // @@protoc_insertion_point(field_list:unhinged.messaging.LLMPromptRequest.context_documents)
  return _impl_.context_documents_;
}

// int32 max_tokens = 6;
inline void LLMPromptRequest::clear_max_tokens() {
  _impl_.max_tokens_ = 0;
}
inline int32_t LLMPromptRequest::_internal_max_tokens() const {
  return _impl_.max_tokens_;
}
inline int32_t LLMPromptRequest::max_tokens() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.LLMPromptRequest.max_tokens)
  return _internal_max_tokens();
}
inline void LLMPromptRequest::_internal_set_max_tokens(int32_t value) {
  
  _impl_.max_tokens_ = value;
}
inline void LLMPromptRequest::set_max_tokens(int32_t value) {
  _internal_set_max_tokens(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.LLMPromptRequest.max_tokens)
}

// float temperature = 7;
inline void LLMPromptRequest::clear_temperature() {
  _impl_.temperature_ = 0;
}
inline float LLMPromptRequest::_internal_temperature() const {
  return _impl_.temperature_;
}
inline float LLMPromptRequest::temperature() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.LLMPromptRequest.temperature)
  return _internal_temperature();
}
inline void LLMPromptRequest::_internal_set_temperature(float value) {
  
  _impl_.temperature_ = value;
}
inline void LLMPromptRequest::set_temperature(float value) {
  _internal_set_temperature(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.LLMPromptRequest.temperature)
}

// float top_p = 8;
inline void LLMPromptRequest::clear_top_p() {
  _impl_.top_p_ = 0;
}
inline float LLMPromptRequest::_internal_top_p() const {
  return _impl_.top_p_;
}
inline float LLMPromptRequest::top_p() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.LLMPromptRequest.top_p)
  return _internal_top_p();
}
inline void LLMPromptRequest::_internal_set_top_p(float value) {
  
  _impl_.top_p_ = value;
}
inline void LLMPromptRequest::set_top_p(float value) {
  _internal_set_top_p(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.LLMPromptRequest.top_p)
}

// repeated string stop_sequences = 9;
inline int LLMPromptRequest::_internal_stop_sequences_size() const {
  return _impl_.stop_sequences_.size();
}
inline int LLMPromptRequest::stop_sequences_size() const {
  return _internal_stop_sequences_size();
}
inline void LLMPromptRequest::clear_stop_sequences() {
  _impl_.stop_sequences_.Clear();
}
inline std::string* LLMPromptRequest::add_stop_sequences() {
  std::string* _s = _internal_add_stop_sequences();
  // @@protoc_insertion_point(field_add_mutable:unhinged.messaging.LLMPromptRequest.stop_sequences)
  return _s;
}
inline const std::string& LLMPromptRequest::_internal_stop_sequences(int index) const {
  return _impl_.stop_sequences_.Get(index);
}
inline const std::string& LLMPromptRequest::stop_sequences(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.LLMPromptRequest.stop_sequences)
  return _internal_stop_sequences(index);
}
inline std::string* LLMPromptRequest::mutable_stop_sequences(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.LLMPromptRequest.stop_sequences)
  return _impl_.stop_sequences_.Mutable(index);
}
inline void LLMPromptRequest::set_stop_sequences(int index, const std::string& value) {
  _impl_.stop_sequences_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.LLMPromptRequest.stop_sequences)
}
inline void LLMPromptRequest::set_stop_sequences(int index, std::string&& value) {
  _impl_.stop_sequences_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.messaging.LLMPromptRequest.stop_sequences)
}
inline void LLMPromptRequest::set_stop_sequences(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.stop_sequences_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.messaging.LLMPromptRequest.stop_sequences)
}
inline void LLMPromptRequest::set_stop_sequences(int index, const char* value, size_t size) {
  _impl_.stop_sequences_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.messaging.LLMPromptRequest.stop_sequences)
}
inline std::string* LLMPromptRequest::_internal_add_stop_sequences() {
  return _impl_.stop_sequences_.Add();
}
inline void LLMPromptRequest::add_stop_sequences(const std::string& value) {
  _impl_.stop_sequences_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.messaging.LLMPromptRequest.stop_sequences)
}
inline void LLMPromptRequest::add_stop_sequences(std::string&& value) {
  _impl_.stop_sequences_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.messaging.LLMPromptRequest.stop_sequences)
}
inline void LLMPromptRequest::add_stop_sequences(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.stop_sequences_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.messaging.LLMPromptRequest.stop_sequences)
}
inline void LLMPromptRequest::add_stop_sequences(const char* value, size_t size) {
  _impl_.stop_sequences_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.messaging.LLMPromptRequest.stop_sequences)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
LLMPromptRequest::stop_sequences() const {
  // @@protoc_insertion_point(field_list:unhinged.messaging.LLMPromptRequest.stop_sequences)
  return _impl_.stop_sequences_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
LLMPromptRequest::mutable_stop_sequences() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.messaging.LLMPromptRequest.stop_sequences)
  return &_impl_.stop_sequences_;
}

// bool stream_response = 10;
inline void LLMPromptRequest::clear_stream_response() {
  _impl_.stream_response_ = false;
}
inline bool LLMPromptRequest::_internal_stream_response() const {
  return _impl_.stream_response_;
}
inline bool LLMPromptRequest::stream_response() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.LLMPromptRequest.stream_response)
  return _internal_stream_response();
}
inline void LLMPromptRequest::_internal_set_stream_response(bool value) {
  
  _impl_.stream_response_ = value;
}
inline void LLMPromptRequest::set_stream_response(bool value) {
  _internal_set_stream_response(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.LLMPromptRequest.stream_response)
}

// string stream_callback_url = 11;
inline void LLMPromptRequest::clear_stream_callback_url() {
  _impl_.stream_callback_url_.ClearToEmpty();
}
inline const std::string& LLMPromptRequest::stream_callback_url() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.LLMPromptRequest.stream_callback_url)
  return _internal_stream_callback_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LLMPromptRequest::set_stream_callback_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.stream_callback_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.LLMPromptRequest.stream_callback_url)
}
inline std::string* LLMPromptRequest::mutable_stream_callback_url() {
  std::string* _s = _internal_mutable_stream_callback_url();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.LLMPromptRequest.stream_callback_url)
  return _s;
}
inline const std::string& LLMPromptRequest::_internal_stream_callback_url() const {
  return _impl_.stream_callback_url_.Get();
}
inline void LLMPromptRequest::_internal_set_stream_callback_url(const std::string& value) {
  
  _impl_.stream_callback_url_.Set(value, GetArenaForAllocation());
}
inline std::string* LLMPromptRequest::_internal_mutable_stream_callback_url() {
  
  return _impl_.stream_callback_url_.Mutable(GetArenaForAllocation());
}
inline std::string* LLMPromptRequest::release_stream_callback_url() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.LLMPromptRequest.stream_callback_url)
  return _impl_.stream_callback_url_.Release();
}
inline void LLMPromptRequest::set_allocated_stream_callback_url(std::string* stream_callback_url) {
  if (stream_callback_url != nullptr) {
    
  } else {
    
  }
  _impl_.stream_callback_url_.SetAllocated(stream_callback_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stream_callback_url_.IsDefault()) {
    _impl_.stream_callback_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.LLMPromptRequest.stream_callback_url)
}

// .google.protobuf.Struct prompt_metadata = 12;
inline bool LLMPromptRequest::_internal_has_prompt_metadata() const {
  return this != internal_default_instance() && _impl_.prompt_metadata_ != nullptr;
}
inline bool LLMPromptRequest::has_prompt_metadata() const {
  return _internal_has_prompt_metadata();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& LLMPromptRequest::_internal_prompt_metadata() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.prompt_metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& LLMPromptRequest::prompt_metadata() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.LLMPromptRequest.prompt_metadata)
  return _internal_prompt_metadata();
}
inline void LLMPromptRequest::unsafe_arena_set_allocated_prompt_metadata(
    ::PROTOBUF_NAMESPACE_ID::Struct* prompt_metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.prompt_metadata_);
  }
  _impl_.prompt_metadata_ = prompt_metadata;
  if (prompt_metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.LLMPromptRequest.prompt_metadata)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* LLMPromptRequest::release_prompt_metadata() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.prompt_metadata_;
  _impl_.prompt_metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* LLMPromptRequest::unsafe_arena_release_prompt_metadata() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.LLMPromptRequest.prompt_metadata)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.prompt_metadata_;
  _impl_.prompt_metadata_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* LLMPromptRequest::_internal_mutable_prompt_metadata() {
  
  if (_impl_.prompt_metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.prompt_metadata_ = p;
  }
  return _impl_.prompt_metadata_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* LLMPromptRequest::mutable_prompt_metadata() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_prompt_metadata();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.LLMPromptRequest.prompt_metadata)
  return _msg;
}
inline void LLMPromptRequest::set_allocated_prompt_metadata(::PROTOBUF_NAMESPACE_ID::Struct* prompt_metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.prompt_metadata_);
  }
  if (prompt_metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(prompt_metadata));
    if (message_arena != submessage_arena) {
      prompt_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, prompt_metadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.prompt_metadata_ = prompt_metadata;
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.LLMPromptRequest.prompt_metadata)
}

// repeated string tools_available = 13;
inline int LLMPromptRequest::_internal_tools_available_size() const {
  return _impl_.tools_available_.size();
}
inline int LLMPromptRequest::tools_available_size() const {
  return _internal_tools_available_size();
}
inline void LLMPromptRequest::clear_tools_available() {
  _impl_.tools_available_.Clear();
}
inline std::string* LLMPromptRequest::add_tools_available() {
  std::string* _s = _internal_add_tools_available();
  // @@protoc_insertion_point(field_add_mutable:unhinged.messaging.LLMPromptRequest.tools_available)
  return _s;
}
inline const std::string& LLMPromptRequest::_internal_tools_available(int index) const {
  return _impl_.tools_available_.Get(index);
}
inline const std::string& LLMPromptRequest::tools_available(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.LLMPromptRequest.tools_available)
  return _internal_tools_available(index);
}
inline std::string* LLMPromptRequest::mutable_tools_available(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.LLMPromptRequest.tools_available)
  return _impl_.tools_available_.Mutable(index);
}
inline void LLMPromptRequest::set_tools_available(int index, const std::string& value) {
  _impl_.tools_available_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.LLMPromptRequest.tools_available)
}
inline void LLMPromptRequest::set_tools_available(int index, std::string&& value) {
  _impl_.tools_available_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.messaging.LLMPromptRequest.tools_available)
}
inline void LLMPromptRequest::set_tools_available(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tools_available_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.messaging.LLMPromptRequest.tools_available)
}
inline void LLMPromptRequest::set_tools_available(int index, const char* value, size_t size) {
  _impl_.tools_available_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.messaging.LLMPromptRequest.tools_available)
}
inline std::string* LLMPromptRequest::_internal_add_tools_available() {
  return _impl_.tools_available_.Add();
}
inline void LLMPromptRequest::add_tools_available(const std::string& value) {
  _impl_.tools_available_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.messaging.LLMPromptRequest.tools_available)
}
inline void LLMPromptRequest::add_tools_available(std::string&& value) {
  _impl_.tools_available_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.messaging.LLMPromptRequest.tools_available)
}
inline void LLMPromptRequest::add_tools_available(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tools_available_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.messaging.LLMPromptRequest.tools_available)
}
inline void LLMPromptRequest::add_tools_available(const char* value, size_t size) {
  _impl_.tools_available_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.messaging.LLMPromptRequest.tools_available)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
LLMPromptRequest::tools_available() const {
  // @@protoc_insertion_point(field_list:unhinged.messaging.LLMPromptRequest.tools_available)
  return _impl_.tools_available_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
LLMPromptRequest::mutable_tools_available() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.messaging.LLMPromptRequest.tools_available)
  return &_impl_.tools_available_;
}

// -------------------------------------------------------------------

// ContextDocument

// string document_id = 1;
inline void ContextDocument::clear_document_id() {
  _impl_.document_id_.ClearToEmpty();
}
inline const std::string& ContextDocument::document_id() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.ContextDocument.document_id)
  return _internal_document_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContextDocument::set_document_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.document_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.ContextDocument.document_id)
}
inline std::string* ContextDocument::mutable_document_id() {
  std::string* _s = _internal_mutable_document_id();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.ContextDocument.document_id)
  return _s;
}
inline const std::string& ContextDocument::_internal_document_id() const {
  return _impl_.document_id_.Get();
}
inline void ContextDocument::_internal_set_document_id(const std::string& value) {
  
  _impl_.document_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ContextDocument::_internal_mutable_document_id() {
  
  return _impl_.document_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ContextDocument::release_document_id() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.ContextDocument.document_id)
  return _impl_.document_id_.Release();
}
inline void ContextDocument::set_allocated_document_id(std::string* document_id) {
  if (document_id != nullptr) {
    
  } else {
    
  }
  _impl_.document_id_.SetAllocated(document_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.document_id_.IsDefault()) {
    _impl_.document_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.ContextDocument.document_id)
}

// string document_type = 2;
inline void ContextDocument::clear_document_type() {
  _impl_.document_type_.ClearToEmpty();
}
inline const std::string& ContextDocument::document_type() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.ContextDocument.document_type)
  return _internal_document_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContextDocument::set_document_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.document_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.ContextDocument.document_type)
}
inline std::string* ContextDocument::mutable_document_type() {
  std::string* _s = _internal_mutable_document_type();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.ContextDocument.document_type)
  return _s;
}
inline const std::string& ContextDocument::_internal_document_type() const {
  return _impl_.document_type_.Get();
}
inline void ContextDocument::_internal_set_document_type(const std::string& value) {
  
  _impl_.document_type_.Set(value, GetArenaForAllocation());
}
inline std::string* ContextDocument::_internal_mutable_document_type() {
  
  return _impl_.document_type_.Mutable(GetArenaForAllocation());
}
inline std::string* ContextDocument::release_document_type() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.ContextDocument.document_type)
  return _impl_.document_type_.Release();
}
inline void ContextDocument::set_allocated_document_type(std::string* document_type) {
  if (document_type != nullptr) {
    
  } else {
    
  }
  _impl_.document_type_.SetAllocated(document_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.document_type_.IsDefault()) {
    _impl_.document_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.ContextDocument.document_type)
}

// string content = 3;
inline void ContextDocument::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& ContextDocument::content() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.ContextDocument.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContextDocument::set_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.ContextDocument.content)
}
inline std::string* ContextDocument::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.ContextDocument.content)
  return _s;
}
inline const std::string& ContextDocument::_internal_content() const {
  return _impl_.content_.Get();
}
inline void ContextDocument::_internal_set_content(const std::string& value) {
  
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* ContextDocument::_internal_mutable_content() {
  
  return _impl_.content_.Mutable(GetArenaForAllocation());
}
inline std::string* ContextDocument::release_content() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.ContextDocument.content)
  return _impl_.content_.Release();
}
inline void ContextDocument::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.ContextDocument.content)
}

// .google.protobuf.Struct metadata = 4;
inline bool ContextDocument::_internal_has_metadata() const {
  return this != internal_default_instance() && _impl_.metadata_ != nullptr;
}
inline bool ContextDocument::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& ContextDocument::_internal_metadata() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& ContextDocument::metadata() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.ContextDocument.metadata)
  return _internal_metadata();
}
inline void ContextDocument::unsafe_arena_set_allocated_metadata(
    ::PROTOBUF_NAMESPACE_ID::Struct* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.ContextDocument.metadata)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ContextDocument::release_metadata() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ContextDocument::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.ContextDocument.metadata)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ContextDocument::_internal_mutable_metadata() {
  
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ContextDocument::mutable_metadata() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.ContextDocument.metadata)
  return _msg;
}
inline void ContextDocument::set_allocated_metadata(::PROTOBUF_NAMESPACE_ID::Struct* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.ContextDocument.metadata)
}

// float relevance_score = 5;
inline void ContextDocument::clear_relevance_score() {
  _impl_.relevance_score_ = 0;
}
inline float ContextDocument::_internal_relevance_score() const {
  return _impl_.relevance_score_;
}
inline float ContextDocument::relevance_score() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.ContextDocument.relevance_score)
  return _internal_relevance_score();
}
inline void ContextDocument::_internal_set_relevance_score(float value) {
  
  _impl_.relevance_score_ = value;
}
inline void ContextDocument::set_relevance_score(float value) {
  _internal_set_relevance_score(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.ContextDocument.relevance_score)
}

// -------------------------------------------------------------------

// LLMPromptResponse

// string response_text = 1;
inline void LLMPromptResponse::clear_response_text() {
  _impl_.response_text_.ClearToEmpty();
}
inline const std::string& LLMPromptResponse::response_text() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.LLMPromptResponse.response_text)
  return _internal_response_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LLMPromptResponse::set_response_text(ArgT0&& arg0, ArgT... args) {
 
 _impl_.response_text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.LLMPromptResponse.response_text)
}
inline std::string* LLMPromptResponse::mutable_response_text() {
  std::string* _s = _internal_mutable_response_text();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.LLMPromptResponse.response_text)
  return _s;
}
inline const std::string& LLMPromptResponse::_internal_response_text() const {
  return _impl_.response_text_.Get();
}
inline void LLMPromptResponse::_internal_set_response_text(const std::string& value) {
  
  _impl_.response_text_.Set(value, GetArenaForAllocation());
}
inline std::string* LLMPromptResponse::_internal_mutable_response_text() {
  
  return _impl_.response_text_.Mutable(GetArenaForAllocation());
}
inline std::string* LLMPromptResponse::release_response_text() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.LLMPromptResponse.response_text)
  return _impl_.response_text_.Release();
}
inline void LLMPromptResponse::set_allocated_response_text(std::string* response_text) {
  if (response_text != nullptr) {
    
  } else {
    
  }
  _impl_.response_text_.SetAllocated(response_text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.response_text_.IsDefault()) {
    _impl_.response_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.LLMPromptResponse.response_text)
}

// string finish_reason = 2;
inline void LLMPromptResponse::clear_finish_reason() {
  _impl_.finish_reason_.ClearToEmpty();
}
inline const std::string& LLMPromptResponse::finish_reason() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.LLMPromptResponse.finish_reason)
  return _internal_finish_reason();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LLMPromptResponse::set_finish_reason(ArgT0&& arg0, ArgT... args) {
 
 _impl_.finish_reason_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.LLMPromptResponse.finish_reason)
}
inline std::string* LLMPromptResponse::mutable_finish_reason() {
  std::string* _s = _internal_mutable_finish_reason();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.LLMPromptResponse.finish_reason)
  return _s;
}
inline const std::string& LLMPromptResponse::_internal_finish_reason() const {
  return _impl_.finish_reason_.Get();
}
inline void LLMPromptResponse::_internal_set_finish_reason(const std::string& value) {
  
  _impl_.finish_reason_.Set(value, GetArenaForAllocation());
}
inline std::string* LLMPromptResponse::_internal_mutable_finish_reason() {
  
  return _impl_.finish_reason_.Mutable(GetArenaForAllocation());
}
inline std::string* LLMPromptResponse::release_finish_reason() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.LLMPromptResponse.finish_reason)
  return _impl_.finish_reason_.Release();
}
inline void LLMPromptResponse::set_allocated_finish_reason(std::string* finish_reason) {
  if (finish_reason != nullptr) {
    
  } else {
    
  }
  _impl_.finish_reason_.SetAllocated(finish_reason, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.finish_reason_.IsDefault()) {
    _impl_.finish_reason_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.LLMPromptResponse.finish_reason)
}

// int32 prompt_tokens = 3;
inline void LLMPromptResponse::clear_prompt_tokens() {
  _impl_.prompt_tokens_ = 0;
}
inline int32_t LLMPromptResponse::_internal_prompt_tokens() const {
  return _impl_.prompt_tokens_;
}
inline int32_t LLMPromptResponse::prompt_tokens() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.LLMPromptResponse.prompt_tokens)
  return _internal_prompt_tokens();
}
inline void LLMPromptResponse::_internal_set_prompt_tokens(int32_t value) {
  
  _impl_.prompt_tokens_ = value;
}
inline void LLMPromptResponse::set_prompt_tokens(int32_t value) {
  _internal_set_prompt_tokens(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.LLMPromptResponse.prompt_tokens)
}

// int32 completion_tokens = 4;
inline void LLMPromptResponse::clear_completion_tokens() {
  _impl_.completion_tokens_ = 0;
}
inline int32_t LLMPromptResponse::_internal_completion_tokens() const {
  return _impl_.completion_tokens_;
}
inline int32_t LLMPromptResponse::completion_tokens() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.LLMPromptResponse.completion_tokens)
  return _internal_completion_tokens();
}
inline void LLMPromptResponse::_internal_set_completion_tokens(int32_t value) {
  
  _impl_.completion_tokens_ = value;
}
inline void LLMPromptResponse::set_completion_tokens(int32_t value) {
  _internal_set_completion_tokens(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.LLMPromptResponse.completion_tokens)
}

// int32 total_tokens = 5;
inline void LLMPromptResponse::clear_total_tokens() {
  _impl_.total_tokens_ = 0;
}
inline int32_t LLMPromptResponse::_internal_total_tokens() const {
  return _impl_.total_tokens_;
}
inline int32_t LLMPromptResponse::total_tokens() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.LLMPromptResponse.total_tokens)
  return _internal_total_tokens();
}
inline void LLMPromptResponse::_internal_set_total_tokens(int32_t value) {
  
  _impl_.total_tokens_ = value;
}
inline void LLMPromptResponse::set_total_tokens(int32_t value) {
  _internal_set_total_tokens(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.LLMPromptResponse.total_tokens)
}

// float response_time_ms = 6;
inline void LLMPromptResponse::clear_response_time_ms() {
  _impl_.response_time_ms_ = 0;
}
inline float LLMPromptResponse::_internal_response_time_ms() const {
  return _impl_.response_time_ms_;
}
inline float LLMPromptResponse::response_time_ms() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.LLMPromptResponse.response_time_ms)
  return _internal_response_time_ms();
}
inline void LLMPromptResponse::_internal_set_response_time_ms(float value) {
  
  _impl_.response_time_ms_ = value;
}
inline void LLMPromptResponse::set_response_time_ms(float value) {
  _internal_set_response_time_ms(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.LLMPromptResponse.response_time_ms)
}

// float tokens_per_second = 7;
inline void LLMPromptResponse::clear_tokens_per_second() {
  _impl_.tokens_per_second_ = 0;
}
inline float LLMPromptResponse::_internal_tokens_per_second() const {
  return _impl_.tokens_per_second_;
}
inline float LLMPromptResponse::tokens_per_second() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.LLMPromptResponse.tokens_per_second)
  return _internal_tokens_per_second();
}
inline void LLMPromptResponse::_internal_set_tokens_per_second(float value) {
  
  _impl_.tokens_per_second_ = value;
}
inline void LLMPromptResponse::set_tokens_per_second(float value) {
  _internal_set_tokens_per_second(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.LLMPromptResponse.tokens_per_second)
}

// repeated .unhinged.messaging.ToolCall tool_calls = 8;
inline int LLMPromptResponse::_internal_tool_calls_size() const {
  return _impl_.tool_calls_.size();
}
inline int LLMPromptResponse::tool_calls_size() const {
  return _internal_tool_calls_size();
}
inline void LLMPromptResponse::clear_tool_calls() {
  _impl_.tool_calls_.Clear();
}
inline ::unhinged::messaging::ToolCall* LLMPromptResponse::mutable_tool_calls(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.LLMPromptResponse.tool_calls)
  return _impl_.tool_calls_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::messaging::ToolCall >*
LLMPromptResponse::mutable_tool_calls() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.messaging.LLMPromptResponse.tool_calls)
  return &_impl_.tool_calls_;
}
inline const ::unhinged::messaging::ToolCall& LLMPromptResponse::_internal_tool_calls(int index) const {
  return _impl_.tool_calls_.Get(index);
}
inline const ::unhinged::messaging::ToolCall& LLMPromptResponse::tool_calls(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.LLMPromptResponse.tool_calls)
  return _internal_tool_calls(index);
}
inline ::unhinged::messaging::ToolCall* LLMPromptResponse::_internal_add_tool_calls() {
  return _impl_.tool_calls_.Add();
}
inline ::unhinged::messaging::ToolCall* LLMPromptResponse::add_tool_calls() {
  ::unhinged::messaging::ToolCall* _add = _internal_add_tool_calls();
  // @@protoc_insertion_point(field_add:unhinged.messaging.LLMPromptResponse.tool_calls)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::messaging::ToolCall >&
LLMPromptResponse::tool_calls() const {
  // @@protoc_insertion_point(field_list:unhinged.messaging.LLMPromptResponse.tool_calls)
  return _impl_.tool_calls_;
}

// .google.protobuf.Struct response_metadata = 9;
inline bool LLMPromptResponse::_internal_has_response_metadata() const {
  return this != internal_default_instance() && _impl_.response_metadata_ != nullptr;
}
inline bool LLMPromptResponse::has_response_metadata() const {
  return _internal_has_response_metadata();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& LLMPromptResponse::_internal_response_metadata() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.response_metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& LLMPromptResponse::response_metadata() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.LLMPromptResponse.response_metadata)
  return _internal_response_metadata();
}
inline void LLMPromptResponse::unsafe_arena_set_allocated_response_metadata(
    ::PROTOBUF_NAMESPACE_ID::Struct* response_metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_metadata_);
  }
  _impl_.response_metadata_ = response_metadata;
  if (response_metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.LLMPromptResponse.response_metadata)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* LLMPromptResponse::release_response_metadata() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.response_metadata_;
  _impl_.response_metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* LLMPromptResponse::unsafe_arena_release_response_metadata() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.LLMPromptResponse.response_metadata)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.response_metadata_;
  _impl_.response_metadata_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* LLMPromptResponse::_internal_mutable_response_metadata() {
  
  if (_impl_.response_metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.response_metadata_ = p;
  }
  return _impl_.response_metadata_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* LLMPromptResponse::mutable_response_metadata() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_response_metadata();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.LLMPromptResponse.response_metadata)
  return _msg;
}
inline void LLMPromptResponse::set_allocated_response_metadata(::PROTOBUF_NAMESPACE_ID::Struct* response_metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_metadata_);
  }
  if (response_metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response_metadata));
    if (message_arena != submessage_arena) {
      response_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response_metadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_metadata_ = response_metadata;
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.LLMPromptResponse.response_metadata)
}

// -------------------------------------------------------------------

// LLMStreamChunk

// string chunk_text = 1;
inline void LLMStreamChunk::clear_chunk_text() {
  _impl_.chunk_text_.ClearToEmpty();
}
inline const std::string& LLMStreamChunk::chunk_text() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.LLMStreamChunk.chunk_text)
  return _internal_chunk_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LLMStreamChunk::set_chunk_text(ArgT0&& arg0, ArgT... args) {
 
 _impl_.chunk_text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.LLMStreamChunk.chunk_text)
}
inline std::string* LLMStreamChunk::mutable_chunk_text() {
  std::string* _s = _internal_mutable_chunk_text();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.LLMStreamChunk.chunk_text)
  return _s;
}
inline const std::string& LLMStreamChunk::_internal_chunk_text() const {
  return _impl_.chunk_text_.Get();
}
inline void LLMStreamChunk::_internal_set_chunk_text(const std::string& value) {
  
  _impl_.chunk_text_.Set(value, GetArenaForAllocation());
}
inline std::string* LLMStreamChunk::_internal_mutable_chunk_text() {
  
  return _impl_.chunk_text_.Mutable(GetArenaForAllocation());
}
inline std::string* LLMStreamChunk::release_chunk_text() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.LLMStreamChunk.chunk_text)
  return _impl_.chunk_text_.Release();
}
inline void LLMStreamChunk::set_allocated_chunk_text(std::string* chunk_text) {
  if (chunk_text != nullptr) {
    
  } else {
    
  }
  _impl_.chunk_text_.SetAllocated(chunk_text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.chunk_text_.IsDefault()) {
    _impl_.chunk_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.LLMStreamChunk.chunk_text)
}

// int32 chunk_index = 2;
inline void LLMStreamChunk::clear_chunk_index() {
  _impl_.chunk_index_ = 0;
}
inline int32_t LLMStreamChunk::_internal_chunk_index() const {
  return _impl_.chunk_index_;
}
inline int32_t LLMStreamChunk::chunk_index() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.LLMStreamChunk.chunk_index)
  return _internal_chunk_index();
}
inline void LLMStreamChunk::_internal_set_chunk_index(int32_t value) {
  
  _impl_.chunk_index_ = value;
}
inline void LLMStreamChunk::set_chunk_index(int32_t value) {
  _internal_set_chunk_index(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.LLMStreamChunk.chunk_index)
}

// bool is_final = 3;
inline void LLMStreamChunk::clear_is_final() {
  _impl_.is_final_ = false;
}
inline bool LLMStreamChunk::_internal_is_final() const {
  return _impl_.is_final_;
}
inline bool LLMStreamChunk::is_final() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.LLMStreamChunk.is_final)
  return _internal_is_final();
}
inline void LLMStreamChunk::_internal_set_is_final(bool value) {
  
  _impl_.is_final_ = value;
}
inline void LLMStreamChunk::set_is_final(bool value) {
  _internal_set_is_final(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.LLMStreamChunk.is_final)
}

// repeated .unhinged.messaging.ToolCall partial_tool_calls = 4;
inline int LLMStreamChunk::_internal_partial_tool_calls_size() const {
  return _impl_.partial_tool_calls_.size();
}
inline int LLMStreamChunk::partial_tool_calls_size() const {
  return _internal_partial_tool_calls_size();
}
inline void LLMStreamChunk::clear_partial_tool_calls() {
  _impl_.partial_tool_calls_.Clear();
}
inline ::unhinged::messaging::ToolCall* LLMStreamChunk::mutable_partial_tool_calls(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.LLMStreamChunk.partial_tool_calls)
  return _impl_.partial_tool_calls_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::messaging::ToolCall >*
LLMStreamChunk::mutable_partial_tool_calls() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.messaging.LLMStreamChunk.partial_tool_calls)
  return &_impl_.partial_tool_calls_;
}
inline const ::unhinged::messaging::ToolCall& LLMStreamChunk::_internal_partial_tool_calls(int index) const {
  return _impl_.partial_tool_calls_.Get(index);
}
inline const ::unhinged::messaging::ToolCall& LLMStreamChunk::partial_tool_calls(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.LLMStreamChunk.partial_tool_calls)
  return _internal_partial_tool_calls(index);
}
inline ::unhinged::messaging::ToolCall* LLMStreamChunk::_internal_add_partial_tool_calls() {
  return _impl_.partial_tool_calls_.Add();
}
inline ::unhinged::messaging::ToolCall* LLMStreamChunk::add_partial_tool_calls() {
  ::unhinged::messaging::ToolCall* _add = _internal_add_partial_tool_calls();
  // @@protoc_insertion_point(field_add:unhinged.messaging.LLMStreamChunk.partial_tool_calls)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::messaging::ToolCall >&
LLMStreamChunk::partial_tool_calls() const {
  // @@protoc_insertion_point(field_list:unhinged.messaging.LLMStreamChunk.partial_tool_calls)
  return _impl_.partial_tool_calls_;
}

// -------------------------------------------------------------------

// LLMError

// string error_code = 1;
inline void LLMError::clear_error_code() {
  _impl_.error_code_.ClearToEmpty();
}
inline const std::string& LLMError::error_code() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.LLMError.error_code)
  return _internal_error_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LLMError::set_error_code(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.LLMError.error_code)
}
inline std::string* LLMError::mutable_error_code() {
  std::string* _s = _internal_mutable_error_code();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.LLMError.error_code)
  return _s;
}
inline const std::string& LLMError::_internal_error_code() const {
  return _impl_.error_code_.Get();
}
inline void LLMError::_internal_set_error_code(const std::string& value) {
  
  _impl_.error_code_.Set(value, GetArenaForAllocation());
}
inline std::string* LLMError::_internal_mutable_error_code() {
  
  return _impl_.error_code_.Mutable(GetArenaForAllocation());
}
inline std::string* LLMError::release_error_code() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.LLMError.error_code)
  return _impl_.error_code_.Release();
}
inline void LLMError::set_allocated_error_code(std::string* error_code) {
  if (error_code != nullptr) {
    
  } else {
    
  }
  _impl_.error_code_.SetAllocated(error_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_code_.IsDefault()) {
    _impl_.error_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.LLMError.error_code)
}

// string error_message = 2;
inline void LLMError::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& LLMError::error_message() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.LLMError.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LLMError::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.LLMError.error_message)
}
inline std::string* LLMError::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.LLMError.error_message)
  return _s;
}
inline const std::string& LLMError::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void LLMError::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* LLMError::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* LLMError::release_error_message() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.LLMError.error_message)
  return _impl_.error_message_.Release();
}
inline void LLMError::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.LLMError.error_message)
}

// string error_type = 3;
inline void LLMError::clear_error_type() {
  _impl_.error_type_.ClearToEmpty();
}
inline const std::string& LLMError::error_type() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.LLMError.error_type)
  return _internal_error_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LLMError::set_error_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.LLMError.error_type)
}
inline std::string* LLMError::mutable_error_type() {
  std::string* _s = _internal_mutable_error_type();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.LLMError.error_type)
  return _s;
}
inline const std::string& LLMError::_internal_error_type() const {
  return _impl_.error_type_.Get();
}
inline void LLMError::_internal_set_error_type(const std::string& value) {
  
  _impl_.error_type_.Set(value, GetArenaForAllocation());
}
inline std::string* LLMError::_internal_mutable_error_type() {
  
  return _impl_.error_type_.Mutable(GetArenaForAllocation());
}
inline std::string* LLMError::release_error_type() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.LLMError.error_type)
  return _impl_.error_type_.Release();
}
inline void LLMError::set_allocated_error_type(std::string* error_type) {
  if (error_type != nullptr) {
    
  } else {
    
  }
  _impl_.error_type_.SetAllocated(error_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_type_.IsDefault()) {
    _impl_.error_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.LLMError.error_type)
}

// bool is_retryable = 4;
inline void LLMError::clear_is_retryable() {
  _impl_.is_retryable_ = false;
}
inline bool LLMError::_internal_is_retryable() const {
  return _impl_.is_retryable_;
}
inline bool LLMError::is_retryable() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.LLMError.is_retryable)
  return _internal_is_retryable();
}
inline void LLMError::_internal_set_is_retryable(bool value) {
  
  _impl_.is_retryable_ = value;
}
inline void LLMError::set_is_retryable(bool value) {
  _internal_set_is_retryable(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.LLMError.is_retryable)
}

// int32 retry_after_seconds = 5;
inline void LLMError::clear_retry_after_seconds() {
  _impl_.retry_after_seconds_ = 0;
}
inline int32_t LLMError::_internal_retry_after_seconds() const {
  return _impl_.retry_after_seconds_;
}
inline int32_t LLMError::retry_after_seconds() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.LLMError.retry_after_seconds)
  return _internal_retry_after_seconds();
}
inline void LLMError::_internal_set_retry_after_seconds(int32_t value) {
  
  _impl_.retry_after_seconds_ = value;
}
inline void LLMError::set_retry_after_seconds(int32_t value) {
  _internal_set_retry_after_seconds(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.LLMError.retry_after_seconds)
}

// -------------------------------------------------------------------

// LLMCancel

// string reason = 1;
inline void LLMCancel::clear_reason() {
  _impl_.reason_.ClearToEmpty();
}
inline const std::string& LLMCancel::reason() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.LLMCancel.reason)
  return _internal_reason();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LLMCancel::set_reason(ArgT0&& arg0, ArgT... args) {
 
 _impl_.reason_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.LLMCancel.reason)
}
inline std::string* LLMCancel::mutable_reason() {
  std::string* _s = _internal_mutable_reason();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.LLMCancel.reason)
  return _s;
}
inline const std::string& LLMCancel::_internal_reason() const {
  return _impl_.reason_.Get();
}
inline void LLMCancel::_internal_set_reason(const std::string& value) {
  
  _impl_.reason_.Set(value, GetArenaForAllocation());
}
inline std::string* LLMCancel::_internal_mutable_reason() {
  
  return _impl_.reason_.Mutable(GetArenaForAllocation());
}
inline std::string* LLMCancel::release_reason() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.LLMCancel.reason)
  return _impl_.reason_.Release();
}
inline void LLMCancel::set_allocated_reason(std::string* reason) {
  if (reason != nullptr) {
    
  } else {
    
  }
  _impl_.reason_.SetAllocated(reason, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reason_.IsDefault()) {
    _impl_.reason_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.LLMCancel.reason)
}

// -------------------------------------------------------------------

// ToolCall

// string tool_id = 1;
inline void ToolCall::clear_tool_id() {
  _impl_.tool_id_.ClearToEmpty();
}
inline const std::string& ToolCall::tool_id() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.ToolCall.tool_id)
  return _internal_tool_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ToolCall::set_tool_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tool_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.ToolCall.tool_id)
}
inline std::string* ToolCall::mutable_tool_id() {
  std::string* _s = _internal_mutable_tool_id();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.ToolCall.tool_id)
  return _s;
}
inline const std::string& ToolCall::_internal_tool_id() const {
  return _impl_.tool_id_.Get();
}
inline void ToolCall::_internal_set_tool_id(const std::string& value) {
  
  _impl_.tool_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ToolCall::_internal_mutable_tool_id() {
  
  return _impl_.tool_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ToolCall::release_tool_id() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.ToolCall.tool_id)
  return _impl_.tool_id_.Release();
}
inline void ToolCall::set_allocated_tool_id(std::string* tool_id) {
  if (tool_id != nullptr) {
    
  } else {
    
  }
  _impl_.tool_id_.SetAllocated(tool_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tool_id_.IsDefault()) {
    _impl_.tool_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.ToolCall.tool_id)
}

// string tool_name = 2;
inline void ToolCall::clear_tool_name() {
  _impl_.tool_name_.ClearToEmpty();
}
inline const std::string& ToolCall::tool_name() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.ToolCall.tool_name)
  return _internal_tool_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ToolCall::set_tool_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tool_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.ToolCall.tool_name)
}
inline std::string* ToolCall::mutable_tool_name() {
  std::string* _s = _internal_mutable_tool_name();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.ToolCall.tool_name)
  return _s;
}
inline const std::string& ToolCall::_internal_tool_name() const {
  return _impl_.tool_name_.Get();
}
inline void ToolCall::_internal_set_tool_name(const std::string& value) {
  
  _impl_.tool_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ToolCall::_internal_mutable_tool_name() {
  
  return _impl_.tool_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ToolCall::release_tool_name() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.ToolCall.tool_name)
  return _impl_.tool_name_.Release();
}
inline void ToolCall::set_allocated_tool_name(std::string* tool_name) {
  if (tool_name != nullptr) {
    
  } else {
    
  }
  _impl_.tool_name_.SetAllocated(tool_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tool_name_.IsDefault()) {
    _impl_.tool_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.ToolCall.tool_name)
}

// .google.protobuf.Struct tool_arguments = 3;
inline bool ToolCall::_internal_has_tool_arguments() const {
  return this != internal_default_instance() && _impl_.tool_arguments_ != nullptr;
}
inline bool ToolCall::has_tool_arguments() const {
  return _internal_has_tool_arguments();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& ToolCall::_internal_tool_arguments() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.tool_arguments_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& ToolCall::tool_arguments() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.ToolCall.tool_arguments)
  return _internal_tool_arguments();
}
inline void ToolCall::unsafe_arena_set_allocated_tool_arguments(
    ::PROTOBUF_NAMESPACE_ID::Struct* tool_arguments) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tool_arguments_);
  }
  _impl_.tool_arguments_ = tool_arguments;
  if (tool_arguments) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.ToolCall.tool_arguments)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ToolCall::release_tool_arguments() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.tool_arguments_;
  _impl_.tool_arguments_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ToolCall::unsafe_arena_release_tool_arguments() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.ToolCall.tool_arguments)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.tool_arguments_;
  _impl_.tool_arguments_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ToolCall::_internal_mutable_tool_arguments() {
  
  if (_impl_.tool_arguments_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.tool_arguments_ = p;
  }
  return _impl_.tool_arguments_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ToolCall::mutable_tool_arguments() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_tool_arguments();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.ToolCall.tool_arguments)
  return _msg;
}
inline void ToolCall::set_allocated_tool_arguments(::PROTOBUF_NAMESPACE_ID::Struct* tool_arguments) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tool_arguments_);
  }
  if (tool_arguments) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tool_arguments));
    if (message_arena != submessage_arena) {
      tool_arguments = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tool_arguments, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.tool_arguments_ = tool_arguments;
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.ToolCall.tool_arguments)
}

// -------------------------------------------------------------------

// AgentMessage

// string agent_id = 1;
inline void AgentMessage::clear_agent_id() {
  _impl_.agent_id_.ClearToEmpty();
}
inline const std::string& AgentMessage::agent_id() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.AgentMessage.agent_id)
  return _internal_agent_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AgentMessage::set_agent_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.agent_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.AgentMessage.agent_id)
}
inline std::string* AgentMessage::mutable_agent_id() {
  std::string* _s = _internal_mutable_agent_id();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.AgentMessage.agent_id)
  return _s;
}
inline const std::string& AgentMessage::_internal_agent_id() const {
  return _impl_.agent_id_.Get();
}
inline void AgentMessage::_internal_set_agent_id(const std::string& value) {
  
  _impl_.agent_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AgentMessage::_internal_mutable_agent_id() {
  
  return _impl_.agent_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AgentMessage::release_agent_id() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.AgentMessage.agent_id)
  return _impl_.agent_id_.Release();
}
inline void AgentMessage::set_allocated_agent_id(std::string* agent_id) {
  if (agent_id != nullptr) {
    
  } else {
    
  }
  _impl_.agent_id_.SetAllocated(agent_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.agent_id_.IsDefault()) {
    _impl_.agent_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.AgentMessage.agent_id)
}

// string execution_id = 2;
inline void AgentMessage::clear_execution_id() {
  _impl_.execution_id_.ClearToEmpty();
}
inline const std::string& AgentMessage::execution_id() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.AgentMessage.execution_id)
  return _internal_execution_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AgentMessage::set_execution_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.execution_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.AgentMessage.execution_id)
}
inline std::string* AgentMessage::mutable_execution_id() {
  std::string* _s = _internal_mutable_execution_id();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.AgentMessage.execution_id)
  return _s;
}
inline const std::string& AgentMessage::_internal_execution_id() const {
  return _impl_.execution_id_.Get();
}
inline void AgentMessage::_internal_set_execution_id(const std::string& value) {
  
  _impl_.execution_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AgentMessage::_internal_mutable_execution_id() {
  
  return _impl_.execution_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AgentMessage::release_execution_id() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.AgentMessage.execution_id)
  return _impl_.execution_id_.Release();
}
inline void AgentMessage::set_allocated_execution_id(std::string* execution_id) {
  if (execution_id != nullptr) {
    
  } else {
    
  }
  _impl_.execution_id_.SetAllocated(execution_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.execution_id_.IsDefault()) {
    _impl_.execution_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.AgentMessage.execution_id)
}

// .unhinged.messaging.AgentMessageType message_type = 3;
inline void AgentMessage::clear_message_type() {
  _impl_.message_type_ = 0;
}
inline ::unhinged::messaging::AgentMessageType AgentMessage::_internal_message_type() const {
  return static_cast< ::unhinged::messaging::AgentMessageType >(_impl_.message_type_);
}
inline ::unhinged::messaging::AgentMessageType AgentMessage::message_type() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.AgentMessage.message_type)
  return _internal_message_type();
}
inline void AgentMessage::_internal_set_message_type(::unhinged::messaging::AgentMessageType value) {
  
  _impl_.message_type_ = value;
}
inline void AgentMessage::set_message_type(::unhinged::messaging::AgentMessageType value) {
  _internal_set_message_type(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.AgentMessage.message_type)
}

// .unhinged.messaging.AgentTaskRequest task_request = 10;
inline bool AgentMessage::_internal_has_task_request() const {
  return message_data_case() == kTaskRequest;
}
inline bool AgentMessage::has_task_request() const {
  return _internal_has_task_request();
}
inline void AgentMessage::set_has_task_request() {
  _impl_._oneof_case_[0] = kTaskRequest;
}
inline void AgentMessage::clear_task_request() {
  if (_internal_has_task_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_data_.task_request_;
    }
    clear_has_message_data();
  }
}
inline ::unhinged::messaging::AgentTaskRequest* AgentMessage::release_task_request() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.AgentMessage.task_request)
  if (_internal_has_task_request()) {
    clear_has_message_data();
    ::unhinged::messaging::AgentTaskRequest* temp = _impl_.message_data_.task_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_data_.task_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::messaging::AgentTaskRequest& AgentMessage::_internal_task_request() const {
  return _internal_has_task_request()
      ? *_impl_.message_data_.task_request_
      : reinterpret_cast< ::unhinged::messaging::AgentTaskRequest&>(::unhinged::messaging::_AgentTaskRequest_default_instance_);
}
inline const ::unhinged::messaging::AgentTaskRequest& AgentMessage::task_request() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.AgentMessage.task_request)
  return _internal_task_request();
}
inline ::unhinged::messaging::AgentTaskRequest* AgentMessage::unsafe_arena_release_task_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.messaging.AgentMessage.task_request)
  if (_internal_has_task_request()) {
    clear_has_message_data();
    ::unhinged::messaging::AgentTaskRequest* temp = _impl_.message_data_.task_request_;
    _impl_.message_data_.task_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AgentMessage::unsafe_arena_set_allocated_task_request(::unhinged::messaging::AgentTaskRequest* task_request) {
  clear_message_data();
  if (task_request) {
    set_has_task_request();
    _impl_.message_data_.task_request_ = task_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.AgentMessage.task_request)
}
inline ::unhinged::messaging::AgentTaskRequest* AgentMessage::_internal_mutable_task_request() {
  if (!_internal_has_task_request()) {
    clear_message_data();
    set_has_task_request();
    _impl_.message_data_.task_request_ = CreateMaybeMessage< ::unhinged::messaging::AgentTaskRequest >(GetArenaForAllocation());
  }
  return _impl_.message_data_.task_request_;
}
inline ::unhinged::messaging::AgentTaskRequest* AgentMessage::mutable_task_request() {
  ::unhinged::messaging::AgentTaskRequest* _msg = _internal_mutable_task_request();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.AgentMessage.task_request)
  return _msg;
}

// .unhinged.messaging.AgentTaskResponse task_response = 11;
inline bool AgentMessage::_internal_has_task_response() const {
  return message_data_case() == kTaskResponse;
}
inline bool AgentMessage::has_task_response() const {
  return _internal_has_task_response();
}
inline void AgentMessage::set_has_task_response() {
  _impl_._oneof_case_[0] = kTaskResponse;
}
inline void AgentMessage::clear_task_response() {
  if (_internal_has_task_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_data_.task_response_;
    }
    clear_has_message_data();
  }
}
inline ::unhinged::messaging::AgentTaskResponse* AgentMessage::release_task_response() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.AgentMessage.task_response)
  if (_internal_has_task_response()) {
    clear_has_message_data();
    ::unhinged::messaging::AgentTaskResponse* temp = _impl_.message_data_.task_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_data_.task_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::messaging::AgentTaskResponse& AgentMessage::_internal_task_response() const {
  return _internal_has_task_response()
      ? *_impl_.message_data_.task_response_
      : reinterpret_cast< ::unhinged::messaging::AgentTaskResponse&>(::unhinged::messaging::_AgentTaskResponse_default_instance_);
}
inline const ::unhinged::messaging::AgentTaskResponse& AgentMessage::task_response() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.AgentMessage.task_response)
  return _internal_task_response();
}
inline ::unhinged::messaging::AgentTaskResponse* AgentMessage::unsafe_arena_release_task_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.messaging.AgentMessage.task_response)
  if (_internal_has_task_response()) {
    clear_has_message_data();
    ::unhinged::messaging::AgentTaskResponse* temp = _impl_.message_data_.task_response_;
    _impl_.message_data_.task_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AgentMessage::unsafe_arena_set_allocated_task_response(::unhinged::messaging::AgentTaskResponse* task_response) {
  clear_message_data();
  if (task_response) {
    set_has_task_response();
    _impl_.message_data_.task_response_ = task_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.AgentMessage.task_response)
}
inline ::unhinged::messaging::AgentTaskResponse* AgentMessage::_internal_mutable_task_response() {
  if (!_internal_has_task_response()) {
    clear_message_data();
    set_has_task_response();
    _impl_.message_data_.task_response_ = CreateMaybeMessage< ::unhinged::messaging::AgentTaskResponse >(GetArenaForAllocation());
  }
  return _impl_.message_data_.task_response_;
}
inline ::unhinged::messaging::AgentTaskResponse* AgentMessage::mutable_task_response() {
  ::unhinged::messaging::AgentTaskResponse* _msg = _internal_mutable_task_response();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.AgentMessage.task_response)
  return _msg;
}

// .unhinged.messaging.AgentStepUpdate step_update = 12;
inline bool AgentMessage::_internal_has_step_update() const {
  return message_data_case() == kStepUpdate;
}
inline bool AgentMessage::has_step_update() const {
  return _internal_has_step_update();
}
inline void AgentMessage::set_has_step_update() {
  _impl_._oneof_case_[0] = kStepUpdate;
}
inline void AgentMessage::clear_step_update() {
  if (_internal_has_step_update()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_data_.step_update_;
    }
    clear_has_message_data();
  }
}
inline ::unhinged::messaging::AgentStepUpdate* AgentMessage::release_step_update() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.AgentMessage.step_update)
  if (_internal_has_step_update()) {
    clear_has_message_data();
    ::unhinged::messaging::AgentStepUpdate* temp = _impl_.message_data_.step_update_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_data_.step_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::messaging::AgentStepUpdate& AgentMessage::_internal_step_update() const {
  return _internal_has_step_update()
      ? *_impl_.message_data_.step_update_
      : reinterpret_cast< ::unhinged::messaging::AgentStepUpdate&>(::unhinged::messaging::_AgentStepUpdate_default_instance_);
}
inline const ::unhinged::messaging::AgentStepUpdate& AgentMessage::step_update() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.AgentMessage.step_update)
  return _internal_step_update();
}
inline ::unhinged::messaging::AgentStepUpdate* AgentMessage::unsafe_arena_release_step_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.messaging.AgentMessage.step_update)
  if (_internal_has_step_update()) {
    clear_has_message_data();
    ::unhinged::messaging::AgentStepUpdate* temp = _impl_.message_data_.step_update_;
    _impl_.message_data_.step_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AgentMessage::unsafe_arena_set_allocated_step_update(::unhinged::messaging::AgentStepUpdate* step_update) {
  clear_message_data();
  if (step_update) {
    set_has_step_update();
    _impl_.message_data_.step_update_ = step_update;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.AgentMessage.step_update)
}
inline ::unhinged::messaging::AgentStepUpdate* AgentMessage::_internal_mutable_step_update() {
  if (!_internal_has_step_update()) {
    clear_message_data();
    set_has_step_update();
    _impl_.message_data_.step_update_ = CreateMaybeMessage< ::unhinged::messaging::AgentStepUpdate >(GetArenaForAllocation());
  }
  return _impl_.message_data_.step_update_;
}
inline ::unhinged::messaging::AgentStepUpdate* AgentMessage::mutable_step_update() {
  ::unhinged::messaging::AgentStepUpdate* _msg = _internal_mutable_step_update();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.AgentMessage.step_update)
  return _msg;
}

// .unhinged.messaging.AgentCollaboration collaboration = 13;
inline bool AgentMessage::_internal_has_collaboration() const {
  return message_data_case() == kCollaboration;
}
inline bool AgentMessage::has_collaboration() const {
  return _internal_has_collaboration();
}
inline void AgentMessage::set_has_collaboration() {
  _impl_._oneof_case_[0] = kCollaboration;
}
inline void AgentMessage::clear_collaboration() {
  if (_internal_has_collaboration()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_data_.collaboration_;
    }
    clear_has_message_data();
  }
}
inline ::unhinged::messaging::AgentCollaboration* AgentMessage::release_collaboration() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.AgentMessage.collaboration)
  if (_internal_has_collaboration()) {
    clear_has_message_data();
    ::unhinged::messaging::AgentCollaboration* temp = _impl_.message_data_.collaboration_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_data_.collaboration_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::messaging::AgentCollaboration& AgentMessage::_internal_collaboration() const {
  return _internal_has_collaboration()
      ? *_impl_.message_data_.collaboration_
      : reinterpret_cast< ::unhinged::messaging::AgentCollaboration&>(::unhinged::messaging::_AgentCollaboration_default_instance_);
}
inline const ::unhinged::messaging::AgentCollaboration& AgentMessage::collaboration() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.AgentMessage.collaboration)
  return _internal_collaboration();
}
inline ::unhinged::messaging::AgentCollaboration* AgentMessage::unsafe_arena_release_collaboration() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.messaging.AgentMessage.collaboration)
  if (_internal_has_collaboration()) {
    clear_has_message_data();
    ::unhinged::messaging::AgentCollaboration* temp = _impl_.message_data_.collaboration_;
    _impl_.message_data_.collaboration_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AgentMessage::unsafe_arena_set_allocated_collaboration(::unhinged::messaging::AgentCollaboration* collaboration) {
  clear_message_data();
  if (collaboration) {
    set_has_collaboration();
    _impl_.message_data_.collaboration_ = collaboration;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.AgentMessage.collaboration)
}
inline ::unhinged::messaging::AgentCollaboration* AgentMessage::_internal_mutable_collaboration() {
  if (!_internal_has_collaboration()) {
    clear_message_data();
    set_has_collaboration();
    _impl_.message_data_.collaboration_ = CreateMaybeMessage< ::unhinged::messaging::AgentCollaboration >(GetArenaForAllocation());
  }
  return _impl_.message_data_.collaboration_;
}
inline ::unhinged::messaging::AgentCollaboration* AgentMessage::mutable_collaboration() {
  ::unhinged::messaging::AgentCollaboration* _msg = _internal_mutable_collaboration();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.AgentMessage.collaboration)
  return _msg;
}

// .unhinged.messaging.AgentError agent_error = 14;
inline bool AgentMessage::_internal_has_agent_error() const {
  return message_data_case() == kAgentError;
}
inline bool AgentMessage::has_agent_error() const {
  return _internal_has_agent_error();
}
inline void AgentMessage::set_has_agent_error() {
  _impl_._oneof_case_[0] = kAgentError;
}
inline void AgentMessage::clear_agent_error() {
  if (_internal_has_agent_error()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_data_.agent_error_;
    }
    clear_has_message_data();
  }
}
inline ::unhinged::messaging::AgentError* AgentMessage::release_agent_error() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.AgentMessage.agent_error)
  if (_internal_has_agent_error()) {
    clear_has_message_data();
    ::unhinged::messaging::AgentError* temp = _impl_.message_data_.agent_error_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_data_.agent_error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::messaging::AgentError& AgentMessage::_internal_agent_error() const {
  return _internal_has_agent_error()
      ? *_impl_.message_data_.agent_error_
      : reinterpret_cast< ::unhinged::messaging::AgentError&>(::unhinged::messaging::_AgentError_default_instance_);
}
inline const ::unhinged::messaging::AgentError& AgentMessage::agent_error() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.AgentMessage.agent_error)
  return _internal_agent_error();
}
inline ::unhinged::messaging::AgentError* AgentMessage::unsafe_arena_release_agent_error() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.messaging.AgentMessage.agent_error)
  if (_internal_has_agent_error()) {
    clear_has_message_data();
    ::unhinged::messaging::AgentError* temp = _impl_.message_data_.agent_error_;
    _impl_.message_data_.agent_error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AgentMessage::unsafe_arena_set_allocated_agent_error(::unhinged::messaging::AgentError* agent_error) {
  clear_message_data();
  if (agent_error) {
    set_has_agent_error();
    _impl_.message_data_.agent_error_ = agent_error;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.AgentMessage.agent_error)
}
inline ::unhinged::messaging::AgentError* AgentMessage::_internal_mutable_agent_error() {
  if (!_internal_has_agent_error()) {
    clear_message_data();
    set_has_agent_error();
    _impl_.message_data_.agent_error_ = CreateMaybeMessage< ::unhinged::messaging::AgentError >(GetArenaForAllocation());
  }
  return _impl_.message_data_.agent_error_;
}
inline ::unhinged::messaging::AgentError* AgentMessage::mutable_agent_error() {
  ::unhinged::messaging::AgentError* _msg = _internal_mutable_agent_error();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.AgentMessage.agent_error)
  return _msg;
}

inline bool AgentMessage::has_message_data() const {
  return message_data_case() != MESSAGE_DATA_NOT_SET;
}
inline void AgentMessage::clear_has_message_data() {
  _impl_._oneof_case_[0] = MESSAGE_DATA_NOT_SET;
}
inline AgentMessage::MessageDataCase AgentMessage::message_data_case() const {
  return AgentMessage::MessageDataCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// AgentTaskRequest

// string task_description = 1;
inline void AgentTaskRequest::clear_task_description() {
  _impl_.task_description_.ClearToEmpty();
}
inline const std::string& AgentTaskRequest::task_description() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.AgentTaskRequest.task_description)
  return _internal_task_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AgentTaskRequest::set_task_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.task_description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.AgentTaskRequest.task_description)
}
inline std::string* AgentTaskRequest::mutable_task_description() {
  std::string* _s = _internal_mutable_task_description();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.AgentTaskRequest.task_description)
  return _s;
}
inline const std::string& AgentTaskRequest::_internal_task_description() const {
  return _impl_.task_description_.Get();
}
inline void AgentTaskRequest::_internal_set_task_description(const std::string& value) {
  
  _impl_.task_description_.Set(value, GetArenaForAllocation());
}
inline std::string* AgentTaskRequest::_internal_mutable_task_description() {
  
  return _impl_.task_description_.Mutable(GetArenaForAllocation());
}
inline std::string* AgentTaskRequest::release_task_description() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.AgentTaskRequest.task_description)
  return _impl_.task_description_.Release();
}
inline void AgentTaskRequest::set_allocated_task_description(std::string* task_description) {
  if (task_description != nullptr) {
    
  } else {
    
  }
  _impl_.task_description_.SetAllocated(task_description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.task_description_.IsDefault()) {
    _impl_.task_description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.AgentTaskRequest.task_description)
}

// string task_type = 2;
inline void AgentTaskRequest::clear_task_type() {
  _impl_.task_type_.ClearToEmpty();
}
inline const std::string& AgentTaskRequest::task_type() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.AgentTaskRequest.task_type)
  return _internal_task_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AgentTaskRequest::set_task_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.task_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.AgentTaskRequest.task_type)
}
inline std::string* AgentTaskRequest::mutable_task_type() {
  std::string* _s = _internal_mutable_task_type();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.AgentTaskRequest.task_type)
  return _s;
}
inline const std::string& AgentTaskRequest::_internal_task_type() const {
  return _impl_.task_type_.Get();
}
inline void AgentTaskRequest::_internal_set_task_type(const std::string& value) {
  
  _impl_.task_type_.Set(value, GetArenaForAllocation());
}
inline std::string* AgentTaskRequest::_internal_mutable_task_type() {
  
  return _impl_.task_type_.Mutable(GetArenaForAllocation());
}
inline std::string* AgentTaskRequest::release_task_type() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.AgentTaskRequest.task_type)
  return _impl_.task_type_.Release();
}
inline void AgentTaskRequest::set_allocated_task_type(std::string* task_type) {
  if (task_type != nullptr) {
    
  } else {
    
  }
  _impl_.task_type_.SetAllocated(task_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.task_type_.IsDefault()) {
    _impl_.task_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.AgentTaskRequest.task_type)
}

// .google.protobuf.Struct task_parameters = 3;
inline bool AgentTaskRequest::_internal_has_task_parameters() const {
  return this != internal_default_instance() && _impl_.task_parameters_ != nullptr;
}
inline bool AgentTaskRequest::has_task_parameters() const {
  return _internal_has_task_parameters();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& AgentTaskRequest::_internal_task_parameters() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.task_parameters_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& AgentTaskRequest::task_parameters() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.AgentTaskRequest.task_parameters)
  return _internal_task_parameters();
}
inline void AgentTaskRequest::unsafe_arena_set_allocated_task_parameters(
    ::PROTOBUF_NAMESPACE_ID::Struct* task_parameters) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.task_parameters_);
  }
  _impl_.task_parameters_ = task_parameters;
  if (task_parameters) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.AgentTaskRequest.task_parameters)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AgentTaskRequest::release_task_parameters() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.task_parameters_;
  _impl_.task_parameters_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AgentTaskRequest::unsafe_arena_release_task_parameters() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.AgentTaskRequest.task_parameters)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.task_parameters_;
  _impl_.task_parameters_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AgentTaskRequest::_internal_mutable_task_parameters() {
  
  if (_impl_.task_parameters_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.task_parameters_ = p;
  }
  return _impl_.task_parameters_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AgentTaskRequest::mutable_task_parameters() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_task_parameters();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.AgentTaskRequest.task_parameters)
  return _msg;
}
inline void AgentTaskRequest::set_allocated_task_parameters(::PROTOBUF_NAMESPACE_ID::Struct* task_parameters) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.task_parameters_);
  }
  if (task_parameters) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(task_parameters));
    if (message_arena != submessage_arena) {
      task_parameters = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, task_parameters, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.task_parameters_ = task_parameters;
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.AgentTaskRequest.task_parameters)
}

// repeated string required_capabilities = 4;
inline int AgentTaskRequest::_internal_required_capabilities_size() const {
  return _impl_.required_capabilities_.size();
}
inline int AgentTaskRequest::required_capabilities_size() const {
  return _internal_required_capabilities_size();
}
inline void AgentTaskRequest::clear_required_capabilities() {
  _impl_.required_capabilities_.Clear();
}
inline std::string* AgentTaskRequest::add_required_capabilities() {
  std::string* _s = _internal_add_required_capabilities();
  // @@protoc_insertion_point(field_add_mutable:unhinged.messaging.AgentTaskRequest.required_capabilities)
  return _s;
}
inline const std::string& AgentTaskRequest::_internal_required_capabilities(int index) const {
  return _impl_.required_capabilities_.Get(index);
}
inline const std::string& AgentTaskRequest::required_capabilities(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.AgentTaskRequest.required_capabilities)
  return _internal_required_capabilities(index);
}
inline std::string* AgentTaskRequest::mutable_required_capabilities(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.AgentTaskRequest.required_capabilities)
  return _impl_.required_capabilities_.Mutable(index);
}
inline void AgentTaskRequest::set_required_capabilities(int index, const std::string& value) {
  _impl_.required_capabilities_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.AgentTaskRequest.required_capabilities)
}
inline void AgentTaskRequest::set_required_capabilities(int index, std::string&& value) {
  _impl_.required_capabilities_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.messaging.AgentTaskRequest.required_capabilities)
}
inline void AgentTaskRequest::set_required_capabilities(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.required_capabilities_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.messaging.AgentTaskRequest.required_capabilities)
}
inline void AgentTaskRequest::set_required_capabilities(int index, const char* value, size_t size) {
  _impl_.required_capabilities_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.messaging.AgentTaskRequest.required_capabilities)
}
inline std::string* AgentTaskRequest::_internal_add_required_capabilities() {
  return _impl_.required_capabilities_.Add();
}
inline void AgentTaskRequest::add_required_capabilities(const std::string& value) {
  _impl_.required_capabilities_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.messaging.AgentTaskRequest.required_capabilities)
}
inline void AgentTaskRequest::add_required_capabilities(std::string&& value) {
  _impl_.required_capabilities_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.messaging.AgentTaskRequest.required_capabilities)
}
inline void AgentTaskRequest::add_required_capabilities(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.required_capabilities_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.messaging.AgentTaskRequest.required_capabilities)
}
inline void AgentTaskRequest::add_required_capabilities(const char* value, size_t size) {
  _impl_.required_capabilities_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.messaging.AgentTaskRequest.required_capabilities)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AgentTaskRequest::required_capabilities() const {
  // @@protoc_insertion_point(field_list:unhinged.messaging.AgentTaskRequest.required_capabilities)
  return _impl_.required_capabilities_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AgentTaskRequest::mutable_required_capabilities() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.messaging.AgentTaskRequest.required_capabilities)
  return &_impl_.required_capabilities_;
}

// .google.protobuf.Struct context = 5;
inline bool AgentTaskRequest::_internal_has_context() const {
  return this != internal_default_instance() && _impl_.context_ != nullptr;
}
inline bool AgentTaskRequest::has_context() const {
  return _internal_has_context();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& AgentTaskRequest::_internal_context() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.context_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& AgentTaskRequest::context() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.AgentTaskRequest.context)
  return _internal_context();
}
inline void AgentTaskRequest::unsafe_arena_set_allocated_context(
    ::PROTOBUF_NAMESPACE_ID::Struct* context) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.context_);
  }
  _impl_.context_ = context;
  if (context) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.AgentTaskRequest.context)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AgentTaskRequest::release_context() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.context_;
  _impl_.context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AgentTaskRequest::unsafe_arena_release_context() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.AgentTaskRequest.context)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.context_;
  _impl_.context_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AgentTaskRequest::_internal_mutable_context() {
  
  if (_impl_.context_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.context_ = p;
  }
  return _impl_.context_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AgentTaskRequest::mutable_context() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_context();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.AgentTaskRequest.context)
  return _msg;
}
inline void AgentTaskRequest::set_allocated_context(::PROTOBUF_NAMESPACE_ID::Struct* context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.context_);
  }
  if (context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(context));
    if (message_arena != submessage_arena) {
      context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, context, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.context_ = context;
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.AgentTaskRequest.context)
}

// int32 priority = 6;
inline void AgentTaskRequest::clear_priority() {
  _impl_.priority_ = 0;
}
inline int32_t AgentTaskRequest::_internal_priority() const {
  return _impl_.priority_;
}
inline int32_t AgentTaskRequest::priority() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.AgentTaskRequest.priority)
  return _internal_priority();
}
inline void AgentTaskRequest::_internal_set_priority(int32_t value) {
  
  _impl_.priority_ = value;
}
inline void AgentTaskRequest::set_priority(int32_t value) {
  _internal_set_priority(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.AgentTaskRequest.priority)
}

// .google.protobuf.Timestamp deadline = 7;
inline bool AgentTaskRequest::_internal_has_deadline() const {
  return this != internal_default_instance() && _impl_.deadline_ != nullptr;
}
inline bool AgentTaskRequest::has_deadline() const {
  return _internal_has_deadline();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& AgentTaskRequest::_internal_deadline() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.deadline_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& AgentTaskRequest::deadline() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.AgentTaskRequest.deadline)
  return _internal_deadline();
}
inline void AgentTaskRequest::unsafe_arena_set_allocated_deadline(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* deadline) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.deadline_);
  }
  _impl_.deadline_ = deadline;
  if (deadline) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.AgentTaskRequest.deadline)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* AgentTaskRequest::release_deadline() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.deadline_;
  _impl_.deadline_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* AgentTaskRequest::unsafe_arena_release_deadline() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.AgentTaskRequest.deadline)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.deadline_;
  _impl_.deadline_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* AgentTaskRequest::_internal_mutable_deadline() {
  
  if (_impl_.deadline_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.deadline_ = p;
  }
  return _impl_.deadline_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* AgentTaskRequest::mutable_deadline() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_deadline();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.AgentTaskRequest.deadline)
  return _msg;
}
inline void AgentTaskRequest::set_allocated_deadline(::PROTOBUF_NAMESPACE_ID::Timestamp* deadline) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.deadline_);
  }
  if (deadline) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(deadline));
    if (message_arena != submessage_arena) {
      deadline = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, deadline, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.deadline_ = deadline;
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.AgentTaskRequest.deadline)
}

// -------------------------------------------------------------------

// AgentTaskResponse

// string status = 1;
inline void AgentTaskResponse::clear_status() {
  _impl_.status_.ClearToEmpty();
}
inline const std::string& AgentTaskResponse::status() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.AgentTaskResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AgentTaskResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 _impl_.status_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.AgentTaskResponse.status)
}
inline std::string* AgentTaskResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.AgentTaskResponse.status)
  return _s;
}
inline const std::string& AgentTaskResponse::_internal_status() const {
  return _impl_.status_.Get();
}
inline void AgentTaskResponse::_internal_set_status(const std::string& value) {
  
  _impl_.status_.Set(value, GetArenaForAllocation());
}
inline std::string* AgentTaskResponse::_internal_mutable_status() {
  
  return _impl_.status_.Mutable(GetArenaForAllocation());
}
inline std::string* AgentTaskResponse::release_status() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.AgentTaskResponse.status)
  return _impl_.status_.Release();
}
inline void AgentTaskResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  _impl_.status_.SetAllocated(status, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.AgentTaskResponse.status)
}

// .google.protobuf.Struct result = 2;
inline bool AgentTaskResponse::_internal_has_result() const {
  return this != internal_default_instance() && _impl_.result_ != nullptr;
}
inline bool AgentTaskResponse::has_result() const {
  return _internal_has_result();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& AgentTaskResponse::_internal_result() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.result_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& AgentTaskResponse::result() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.AgentTaskResponse.result)
  return _internal_result();
}
inline void AgentTaskResponse::unsafe_arena_set_allocated_result(
    ::PROTOBUF_NAMESPACE_ID::Struct* result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.result_);
  }
  _impl_.result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.AgentTaskResponse.result)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AgentTaskResponse::release_result() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.result_;
  _impl_.result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AgentTaskResponse::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.AgentTaskResponse.result)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.result_;
  _impl_.result_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AgentTaskResponse::_internal_mutable_result() {
  
  if (_impl_.result_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.result_ = p;
  }
  return _impl_.result_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AgentTaskResponse::mutable_result() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.AgentTaskResponse.result)
  return _msg;
}
inline void AgentTaskResponse::set_allocated_result(::PROTOBUF_NAMESPACE_ID::Struct* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.result_);
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result));
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.result_ = result;
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.AgentTaskResponse.result)
}

// string completion_message = 3;
inline void AgentTaskResponse::clear_completion_message() {
  _impl_.completion_message_.ClearToEmpty();
}
inline const std::string& AgentTaskResponse::completion_message() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.AgentTaskResponse.completion_message)
  return _internal_completion_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AgentTaskResponse::set_completion_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.completion_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.AgentTaskResponse.completion_message)
}
inline std::string* AgentTaskResponse::mutable_completion_message() {
  std::string* _s = _internal_mutable_completion_message();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.AgentTaskResponse.completion_message)
  return _s;
}
inline const std::string& AgentTaskResponse::_internal_completion_message() const {
  return _impl_.completion_message_.Get();
}
inline void AgentTaskResponse::_internal_set_completion_message(const std::string& value) {
  
  _impl_.completion_message_.Set(value, GetArenaForAllocation());
}
inline std::string* AgentTaskResponse::_internal_mutable_completion_message() {
  
  return _impl_.completion_message_.Mutable(GetArenaForAllocation());
}
inline std::string* AgentTaskResponse::release_completion_message() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.AgentTaskResponse.completion_message)
  return _impl_.completion_message_.Release();
}
inline void AgentTaskResponse::set_allocated_completion_message(std::string* completion_message) {
  if (completion_message != nullptr) {
    
  } else {
    
  }
  _impl_.completion_message_.SetAllocated(completion_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.completion_message_.IsDefault()) {
    _impl_.completion_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.AgentTaskResponse.completion_message)
}

// repeated string artifacts_created = 4;
inline int AgentTaskResponse::_internal_artifacts_created_size() const {
  return _impl_.artifacts_created_.size();
}
inline int AgentTaskResponse::artifacts_created_size() const {
  return _internal_artifacts_created_size();
}
inline void AgentTaskResponse::clear_artifacts_created() {
  _impl_.artifacts_created_.Clear();
}
inline std::string* AgentTaskResponse::add_artifacts_created() {
  std::string* _s = _internal_add_artifacts_created();
  // @@protoc_insertion_point(field_add_mutable:unhinged.messaging.AgentTaskResponse.artifacts_created)
  return _s;
}
inline const std::string& AgentTaskResponse::_internal_artifacts_created(int index) const {
  return _impl_.artifacts_created_.Get(index);
}
inline const std::string& AgentTaskResponse::artifacts_created(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.AgentTaskResponse.artifacts_created)
  return _internal_artifacts_created(index);
}
inline std::string* AgentTaskResponse::mutable_artifacts_created(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.AgentTaskResponse.artifacts_created)
  return _impl_.artifacts_created_.Mutable(index);
}
inline void AgentTaskResponse::set_artifacts_created(int index, const std::string& value) {
  _impl_.artifacts_created_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.AgentTaskResponse.artifacts_created)
}
inline void AgentTaskResponse::set_artifacts_created(int index, std::string&& value) {
  _impl_.artifacts_created_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.messaging.AgentTaskResponse.artifacts_created)
}
inline void AgentTaskResponse::set_artifacts_created(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.artifacts_created_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.messaging.AgentTaskResponse.artifacts_created)
}
inline void AgentTaskResponse::set_artifacts_created(int index, const char* value, size_t size) {
  _impl_.artifacts_created_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.messaging.AgentTaskResponse.artifacts_created)
}
inline std::string* AgentTaskResponse::_internal_add_artifacts_created() {
  return _impl_.artifacts_created_.Add();
}
inline void AgentTaskResponse::add_artifacts_created(const std::string& value) {
  _impl_.artifacts_created_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.messaging.AgentTaskResponse.artifacts_created)
}
inline void AgentTaskResponse::add_artifacts_created(std::string&& value) {
  _impl_.artifacts_created_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.messaging.AgentTaskResponse.artifacts_created)
}
inline void AgentTaskResponse::add_artifacts_created(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.artifacts_created_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.messaging.AgentTaskResponse.artifacts_created)
}
inline void AgentTaskResponse::add_artifacts_created(const char* value, size_t size) {
  _impl_.artifacts_created_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.messaging.AgentTaskResponse.artifacts_created)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AgentTaskResponse::artifacts_created() const {
  // @@protoc_insertion_point(field_list:unhinged.messaging.AgentTaskResponse.artifacts_created)
  return _impl_.artifacts_created_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AgentTaskResponse::mutable_artifacts_created() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.messaging.AgentTaskResponse.artifacts_created)
  return &_impl_.artifacts_created_;
}

// float execution_time_ms = 5;
inline void AgentTaskResponse::clear_execution_time_ms() {
  _impl_.execution_time_ms_ = 0;
}
inline float AgentTaskResponse::_internal_execution_time_ms() const {
  return _impl_.execution_time_ms_;
}
inline float AgentTaskResponse::execution_time_ms() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.AgentTaskResponse.execution_time_ms)
  return _internal_execution_time_ms();
}
inline void AgentTaskResponse::_internal_set_execution_time_ms(float value) {
  
  _impl_.execution_time_ms_ = value;
}
inline void AgentTaskResponse::set_execution_time_ms(float value) {
  _internal_set_execution_time_ms(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.AgentTaskResponse.execution_time_ms)
}

// -------------------------------------------------------------------

// AgentStepUpdate

// int32 step_number = 1;
inline void AgentStepUpdate::clear_step_number() {
  _impl_.step_number_ = 0;
}
inline int32_t AgentStepUpdate::_internal_step_number() const {
  return _impl_.step_number_;
}
inline int32_t AgentStepUpdate::step_number() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.AgentStepUpdate.step_number)
  return _internal_step_number();
}
inline void AgentStepUpdate::_internal_set_step_number(int32_t value) {
  
  _impl_.step_number_ = value;
}
inline void AgentStepUpdate::set_step_number(int32_t value) {
  _internal_set_step_number(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.AgentStepUpdate.step_number)
}

// string step_description = 2;
inline void AgentStepUpdate::clear_step_description() {
  _impl_.step_description_.ClearToEmpty();
}
inline const std::string& AgentStepUpdate::step_description() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.AgentStepUpdate.step_description)
  return _internal_step_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AgentStepUpdate::set_step_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.step_description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.AgentStepUpdate.step_description)
}
inline std::string* AgentStepUpdate::mutable_step_description() {
  std::string* _s = _internal_mutable_step_description();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.AgentStepUpdate.step_description)
  return _s;
}
inline const std::string& AgentStepUpdate::_internal_step_description() const {
  return _impl_.step_description_.Get();
}
inline void AgentStepUpdate::_internal_set_step_description(const std::string& value) {
  
  _impl_.step_description_.Set(value, GetArenaForAllocation());
}
inline std::string* AgentStepUpdate::_internal_mutable_step_description() {
  
  return _impl_.step_description_.Mutable(GetArenaForAllocation());
}
inline std::string* AgentStepUpdate::release_step_description() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.AgentStepUpdate.step_description)
  return _impl_.step_description_.Release();
}
inline void AgentStepUpdate::set_allocated_step_description(std::string* step_description) {
  if (step_description != nullptr) {
    
  } else {
    
  }
  _impl_.step_description_.SetAllocated(step_description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.step_description_.IsDefault()) {
    _impl_.step_description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.AgentStepUpdate.step_description)
}

// string step_status = 3;
inline void AgentStepUpdate::clear_step_status() {
  _impl_.step_status_.ClearToEmpty();
}
inline const std::string& AgentStepUpdate::step_status() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.AgentStepUpdate.step_status)
  return _internal_step_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AgentStepUpdate::set_step_status(ArgT0&& arg0, ArgT... args) {
 
 _impl_.step_status_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.AgentStepUpdate.step_status)
}
inline std::string* AgentStepUpdate::mutable_step_status() {
  std::string* _s = _internal_mutable_step_status();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.AgentStepUpdate.step_status)
  return _s;
}
inline const std::string& AgentStepUpdate::_internal_step_status() const {
  return _impl_.step_status_.Get();
}
inline void AgentStepUpdate::_internal_set_step_status(const std::string& value) {
  
  _impl_.step_status_.Set(value, GetArenaForAllocation());
}
inline std::string* AgentStepUpdate::_internal_mutable_step_status() {
  
  return _impl_.step_status_.Mutable(GetArenaForAllocation());
}
inline std::string* AgentStepUpdate::release_step_status() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.AgentStepUpdate.step_status)
  return _impl_.step_status_.Release();
}
inline void AgentStepUpdate::set_allocated_step_status(std::string* step_status) {
  if (step_status != nullptr) {
    
  } else {
    
  }
  _impl_.step_status_.SetAllocated(step_status, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.step_status_.IsDefault()) {
    _impl_.step_status_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.AgentStepUpdate.step_status)
}

// .google.protobuf.Struct step_data = 4;
inline bool AgentStepUpdate::_internal_has_step_data() const {
  return this != internal_default_instance() && _impl_.step_data_ != nullptr;
}
inline bool AgentStepUpdate::has_step_data() const {
  return _internal_has_step_data();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& AgentStepUpdate::_internal_step_data() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.step_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& AgentStepUpdate::step_data() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.AgentStepUpdate.step_data)
  return _internal_step_data();
}
inline void AgentStepUpdate::unsafe_arena_set_allocated_step_data(
    ::PROTOBUF_NAMESPACE_ID::Struct* step_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.step_data_);
  }
  _impl_.step_data_ = step_data;
  if (step_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.AgentStepUpdate.step_data)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AgentStepUpdate::release_step_data() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.step_data_;
  _impl_.step_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AgentStepUpdate::unsafe_arena_release_step_data() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.AgentStepUpdate.step_data)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.step_data_;
  _impl_.step_data_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AgentStepUpdate::_internal_mutable_step_data() {
  
  if (_impl_.step_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.step_data_ = p;
  }
  return _impl_.step_data_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AgentStepUpdate::mutable_step_data() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_step_data();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.AgentStepUpdate.step_data)
  return _msg;
}
inline void AgentStepUpdate::set_allocated_step_data(::PROTOBUF_NAMESPACE_ID::Struct* step_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.step_data_);
  }
  if (step_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(step_data));
    if (message_arena != submessage_arena) {
      step_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, step_data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.step_data_ = step_data;
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.AgentStepUpdate.step_data)
}

// float progress_percentage = 5;
inline void AgentStepUpdate::clear_progress_percentage() {
  _impl_.progress_percentage_ = 0;
}
inline float AgentStepUpdate::_internal_progress_percentage() const {
  return _impl_.progress_percentage_;
}
inline float AgentStepUpdate::progress_percentage() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.AgentStepUpdate.progress_percentage)
  return _internal_progress_percentage();
}
inline void AgentStepUpdate::_internal_set_progress_percentage(float value) {
  
  _impl_.progress_percentage_ = value;
}
inline void AgentStepUpdate::set_progress_percentage(float value) {
  _internal_set_progress_percentage(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.AgentStepUpdate.progress_percentage)
}

// -------------------------------------------------------------------

// AgentCollaboration

// string collaboration_type = 1;
inline void AgentCollaboration::clear_collaboration_type() {
  _impl_.collaboration_type_.ClearToEmpty();
}
inline const std::string& AgentCollaboration::collaboration_type() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.AgentCollaboration.collaboration_type)
  return _internal_collaboration_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AgentCollaboration::set_collaboration_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.collaboration_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.AgentCollaboration.collaboration_type)
}
inline std::string* AgentCollaboration::mutable_collaboration_type() {
  std::string* _s = _internal_mutable_collaboration_type();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.AgentCollaboration.collaboration_type)
  return _s;
}
inline const std::string& AgentCollaboration::_internal_collaboration_type() const {
  return _impl_.collaboration_type_.Get();
}
inline void AgentCollaboration::_internal_set_collaboration_type(const std::string& value) {
  
  _impl_.collaboration_type_.Set(value, GetArenaForAllocation());
}
inline std::string* AgentCollaboration::_internal_mutable_collaboration_type() {
  
  return _impl_.collaboration_type_.Mutable(GetArenaForAllocation());
}
inline std::string* AgentCollaboration::release_collaboration_type() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.AgentCollaboration.collaboration_type)
  return _impl_.collaboration_type_.Release();
}
inline void AgentCollaboration::set_allocated_collaboration_type(std::string* collaboration_type) {
  if (collaboration_type != nullptr) {
    
  } else {
    
  }
  _impl_.collaboration_type_.SetAllocated(collaboration_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.collaboration_type_.IsDefault()) {
    _impl_.collaboration_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.AgentCollaboration.collaboration_type)
}

// string target_agent_id = 2;
inline void AgentCollaboration::clear_target_agent_id() {
  _impl_.target_agent_id_.ClearToEmpty();
}
inline const std::string& AgentCollaboration::target_agent_id() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.AgentCollaboration.target_agent_id)
  return _internal_target_agent_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AgentCollaboration::set_target_agent_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.target_agent_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.AgentCollaboration.target_agent_id)
}
inline std::string* AgentCollaboration::mutable_target_agent_id() {
  std::string* _s = _internal_mutable_target_agent_id();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.AgentCollaboration.target_agent_id)
  return _s;
}
inline const std::string& AgentCollaboration::_internal_target_agent_id() const {
  return _impl_.target_agent_id_.Get();
}
inline void AgentCollaboration::_internal_set_target_agent_id(const std::string& value) {
  
  _impl_.target_agent_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AgentCollaboration::_internal_mutable_target_agent_id() {
  
  return _impl_.target_agent_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AgentCollaboration::release_target_agent_id() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.AgentCollaboration.target_agent_id)
  return _impl_.target_agent_id_.Release();
}
inline void AgentCollaboration::set_allocated_target_agent_id(std::string* target_agent_id) {
  if (target_agent_id != nullptr) {
    
  } else {
    
  }
  _impl_.target_agent_id_.SetAllocated(target_agent_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.target_agent_id_.IsDefault()) {
    _impl_.target_agent_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.AgentCollaboration.target_agent_id)
}

// .google.protobuf.Struct collaboration_data = 3;
inline bool AgentCollaboration::_internal_has_collaboration_data() const {
  return this != internal_default_instance() && _impl_.collaboration_data_ != nullptr;
}
inline bool AgentCollaboration::has_collaboration_data() const {
  return _internal_has_collaboration_data();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& AgentCollaboration::_internal_collaboration_data() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.collaboration_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& AgentCollaboration::collaboration_data() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.AgentCollaboration.collaboration_data)
  return _internal_collaboration_data();
}
inline void AgentCollaboration::unsafe_arena_set_allocated_collaboration_data(
    ::PROTOBUF_NAMESPACE_ID::Struct* collaboration_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.collaboration_data_);
  }
  _impl_.collaboration_data_ = collaboration_data;
  if (collaboration_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.AgentCollaboration.collaboration_data)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AgentCollaboration::release_collaboration_data() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.collaboration_data_;
  _impl_.collaboration_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AgentCollaboration::unsafe_arena_release_collaboration_data() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.AgentCollaboration.collaboration_data)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.collaboration_data_;
  _impl_.collaboration_data_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AgentCollaboration::_internal_mutable_collaboration_data() {
  
  if (_impl_.collaboration_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.collaboration_data_ = p;
  }
  return _impl_.collaboration_data_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AgentCollaboration::mutable_collaboration_data() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_collaboration_data();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.AgentCollaboration.collaboration_data)
  return _msg;
}
inline void AgentCollaboration::set_allocated_collaboration_data(::PROTOBUF_NAMESPACE_ID::Struct* collaboration_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.collaboration_data_);
  }
  if (collaboration_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(collaboration_data));
    if (message_arena != submessage_arena) {
      collaboration_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, collaboration_data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.collaboration_data_ = collaboration_data;
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.AgentCollaboration.collaboration_data)
}

// -------------------------------------------------------------------

// AgentError

// string error_code = 1;
inline void AgentError::clear_error_code() {
  _impl_.error_code_.ClearToEmpty();
}
inline const std::string& AgentError::error_code() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.AgentError.error_code)
  return _internal_error_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AgentError::set_error_code(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.AgentError.error_code)
}
inline std::string* AgentError::mutable_error_code() {
  std::string* _s = _internal_mutable_error_code();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.AgentError.error_code)
  return _s;
}
inline const std::string& AgentError::_internal_error_code() const {
  return _impl_.error_code_.Get();
}
inline void AgentError::_internal_set_error_code(const std::string& value) {
  
  _impl_.error_code_.Set(value, GetArenaForAllocation());
}
inline std::string* AgentError::_internal_mutable_error_code() {
  
  return _impl_.error_code_.Mutable(GetArenaForAllocation());
}
inline std::string* AgentError::release_error_code() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.AgentError.error_code)
  return _impl_.error_code_.Release();
}
inline void AgentError::set_allocated_error_code(std::string* error_code) {
  if (error_code != nullptr) {
    
  } else {
    
  }
  _impl_.error_code_.SetAllocated(error_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_code_.IsDefault()) {
    _impl_.error_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.AgentError.error_code)
}

// string error_message = 2;
inline void AgentError::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& AgentError::error_message() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.AgentError.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AgentError::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.AgentError.error_message)
}
inline std::string* AgentError::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.AgentError.error_message)
  return _s;
}
inline const std::string& AgentError::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void AgentError::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* AgentError::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* AgentError::release_error_message() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.AgentError.error_message)
  return _impl_.error_message_.Release();
}
inline void AgentError::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.AgentError.error_message)
}

// string error_context = 3;
inline void AgentError::clear_error_context() {
  _impl_.error_context_.ClearToEmpty();
}
inline const std::string& AgentError::error_context() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.AgentError.error_context)
  return _internal_error_context();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AgentError::set_error_context(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_context_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.AgentError.error_context)
}
inline std::string* AgentError::mutable_error_context() {
  std::string* _s = _internal_mutable_error_context();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.AgentError.error_context)
  return _s;
}
inline const std::string& AgentError::_internal_error_context() const {
  return _impl_.error_context_.Get();
}
inline void AgentError::_internal_set_error_context(const std::string& value) {
  
  _impl_.error_context_.Set(value, GetArenaForAllocation());
}
inline std::string* AgentError::_internal_mutable_error_context() {
  
  return _impl_.error_context_.Mutable(GetArenaForAllocation());
}
inline std::string* AgentError::release_error_context() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.AgentError.error_context)
  return _impl_.error_context_.Release();
}
inline void AgentError::set_allocated_error_context(std::string* error_context) {
  if (error_context != nullptr) {
    
  } else {
    
  }
  _impl_.error_context_.SetAllocated(error_context, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_context_.IsDefault()) {
    _impl_.error_context_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.AgentError.error_context)
}

// bool is_recoverable = 4;
inline void AgentError::clear_is_recoverable() {
  _impl_.is_recoverable_ = false;
}
inline bool AgentError::_internal_is_recoverable() const {
  return _impl_.is_recoverable_;
}
inline bool AgentError::is_recoverable() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.AgentError.is_recoverable)
  return _internal_is_recoverable();
}
inline void AgentError::_internal_set_is_recoverable(bool value) {
  
  _impl_.is_recoverable_ = value;
}
inline void AgentError::set_is_recoverable(bool value) {
  _internal_set_is_recoverable(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.AgentError.is_recoverable)
}

// -------------------------------------------------------------------

// ToolMessage

// string tool_id = 1;
inline void ToolMessage::clear_tool_id() {
  _impl_.tool_id_.ClearToEmpty();
}
inline const std::string& ToolMessage::tool_id() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.ToolMessage.tool_id)
  return _internal_tool_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ToolMessage::set_tool_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tool_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.ToolMessage.tool_id)
}
inline std::string* ToolMessage::mutable_tool_id() {
  std::string* _s = _internal_mutable_tool_id();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.ToolMessage.tool_id)
  return _s;
}
inline const std::string& ToolMessage::_internal_tool_id() const {
  return _impl_.tool_id_.Get();
}
inline void ToolMessage::_internal_set_tool_id(const std::string& value) {
  
  _impl_.tool_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ToolMessage::_internal_mutable_tool_id() {
  
  return _impl_.tool_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ToolMessage::release_tool_id() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.ToolMessage.tool_id)
  return _impl_.tool_id_.Release();
}
inline void ToolMessage::set_allocated_tool_id(std::string* tool_id) {
  if (tool_id != nullptr) {
    
  } else {
    
  }
  _impl_.tool_id_.SetAllocated(tool_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tool_id_.IsDefault()) {
    _impl_.tool_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.ToolMessage.tool_id)
}

// string tool_name = 2;
inline void ToolMessage::clear_tool_name() {
  _impl_.tool_name_.ClearToEmpty();
}
inline const std::string& ToolMessage::tool_name() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.ToolMessage.tool_name)
  return _internal_tool_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ToolMessage::set_tool_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tool_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.ToolMessage.tool_name)
}
inline std::string* ToolMessage::mutable_tool_name() {
  std::string* _s = _internal_mutable_tool_name();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.ToolMessage.tool_name)
  return _s;
}
inline const std::string& ToolMessage::_internal_tool_name() const {
  return _impl_.tool_name_.Get();
}
inline void ToolMessage::_internal_set_tool_name(const std::string& value) {
  
  _impl_.tool_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ToolMessage::_internal_mutable_tool_name() {
  
  return _impl_.tool_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ToolMessage::release_tool_name() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.ToolMessage.tool_name)
  return _impl_.tool_name_.Release();
}
inline void ToolMessage::set_allocated_tool_name(std::string* tool_name) {
  if (tool_name != nullptr) {
    
  } else {
    
  }
  _impl_.tool_name_.SetAllocated(tool_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tool_name_.IsDefault()) {
    _impl_.tool_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.ToolMessage.tool_name)
}

// string tool_version = 3;
inline void ToolMessage::clear_tool_version() {
  _impl_.tool_version_.ClearToEmpty();
}
inline const std::string& ToolMessage::tool_version() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.ToolMessage.tool_version)
  return _internal_tool_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ToolMessage::set_tool_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tool_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.ToolMessage.tool_version)
}
inline std::string* ToolMessage::mutable_tool_version() {
  std::string* _s = _internal_mutable_tool_version();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.ToolMessage.tool_version)
  return _s;
}
inline const std::string& ToolMessage::_internal_tool_version() const {
  return _impl_.tool_version_.Get();
}
inline void ToolMessage::_internal_set_tool_version(const std::string& value) {
  
  _impl_.tool_version_.Set(value, GetArenaForAllocation());
}
inline std::string* ToolMessage::_internal_mutable_tool_version() {
  
  return _impl_.tool_version_.Mutable(GetArenaForAllocation());
}
inline std::string* ToolMessage::release_tool_version() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.ToolMessage.tool_version)
  return _impl_.tool_version_.Release();
}
inline void ToolMessage::set_allocated_tool_version(std::string* tool_version) {
  if (tool_version != nullptr) {
    
  } else {
    
  }
  _impl_.tool_version_.SetAllocated(tool_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tool_version_.IsDefault()) {
    _impl_.tool_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.ToolMessage.tool_version)
}

// .unhinged.messaging.ToolMessageType message_type = 4;
inline void ToolMessage::clear_message_type() {
  _impl_.message_type_ = 0;
}
inline ::unhinged::messaging::ToolMessageType ToolMessage::_internal_message_type() const {
  return static_cast< ::unhinged::messaging::ToolMessageType >(_impl_.message_type_);
}
inline ::unhinged::messaging::ToolMessageType ToolMessage::message_type() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.ToolMessage.message_type)
  return _internal_message_type();
}
inline void ToolMessage::_internal_set_message_type(::unhinged::messaging::ToolMessageType value) {
  
  _impl_.message_type_ = value;
}
inline void ToolMessage::set_message_type(::unhinged::messaging::ToolMessageType value) {
  _internal_set_message_type(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.ToolMessage.message_type)
}

// .unhinged.messaging.ToolInvocation invocation = 10;
inline bool ToolMessage::_internal_has_invocation() const {
  return message_data_case() == kInvocation;
}
inline bool ToolMessage::has_invocation() const {
  return _internal_has_invocation();
}
inline void ToolMessage::set_has_invocation() {
  _impl_._oneof_case_[0] = kInvocation;
}
inline void ToolMessage::clear_invocation() {
  if (_internal_has_invocation()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_data_.invocation_;
    }
    clear_has_message_data();
  }
}
inline ::unhinged::messaging::ToolInvocation* ToolMessage::release_invocation() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.ToolMessage.invocation)
  if (_internal_has_invocation()) {
    clear_has_message_data();
    ::unhinged::messaging::ToolInvocation* temp = _impl_.message_data_.invocation_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_data_.invocation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::messaging::ToolInvocation& ToolMessage::_internal_invocation() const {
  return _internal_has_invocation()
      ? *_impl_.message_data_.invocation_
      : reinterpret_cast< ::unhinged::messaging::ToolInvocation&>(::unhinged::messaging::_ToolInvocation_default_instance_);
}
inline const ::unhinged::messaging::ToolInvocation& ToolMessage::invocation() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.ToolMessage.invocation)
  return _internal_invocation();
}
inline ::unhinged::messaging::ToolInvocation* ToolMessage::unsafe_arena_release_invocation() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.messaging.ToolMessage.invocation)
  if (_internal_has_invocation()) {
    clear_has_message_data();
    ::unhinged::messaging::ToolInvocation* temp = _impl_.message_data_.invocation_;
    _impl_.message_data_.invocation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ToolMessage::unsafe_arena_set_allocated_invocation(::unhinged::messaging::ToolInvocation* invocation) {
  clear_message_data();
  if (invocation) {
    set_has_invocation();
    _impl_.message_data_.invocation_ = invocation;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.ToolMessage.invocation)
}
inline ::unhinged::messaging::ToolInvocation* ToolMessage::_internal_mutable_invocation() {
  if (!_internal_has_invocation()) {
    clear_message_data();
    set_has_invocation();
    _impl_.message_data_.invocation_ = CreateMaybeMessage< ::unhinged::messaging::ToolInvocation >(GetArenaForAllocation());
  }
  return _impl_.message_data_.invocation_;
}
inline ::unhinged::messaging::ToolInvocation* ToolMessage::mutable_invocation() {
  ::unhinged::messaging::ToolInvocation* _msg = _internal_mutable_invocation();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.ToolMessage.invocation)
  return _msg;
}

// .unhinged.messaging.ToolResult result = 11;
inline bool ToolMessage::_internal_has_result() const {
  return message_data_case() == kResult;
}
inline bool ToolMessage::has_result() const {
  return _internal_has_result();
}
inline void ToolMessage::set_has_result() {
  _impl_._oneof_case_[0] = kResult;
}
inline void ToolMessage::clear_result() {
  if (_internal_has_result()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_data_.result_;
    }
    clear_has_message_data();
  }
}
inline ::unhinged::messaging::ToolResult* ToolMessage::release_result() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.ToolMessage.result)
  if (_internal_has_result()) {
    clear_has_message_data();
    ::unhinged::messaging::ToolResult* temp = _impl_.message_data_.result_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_data_.result_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::messaging::ToolResult& ToolMessage::_internal_result() const {
  return _internal_has_result()
      ? *_impl_.message_data_.result_
      : reinterpret_cast< ::unhinged::messaging::ToolResult&>(::unhinged::messaging::_ToolResult_default_instance_);
}
inline const ::unhinged::messaging::ToolResult& ToolMessage::result() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.ToolMessage.result)
  return _internal_result();
}
inline ::unhinged::messaging::ToolResult* ToolMessage::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.messaging.ToolMessage.result)
  if (_internal_has_result()) {
    clear_has_message_data();
    ::unhinged::messaging::ToolResult* temp = _impl_.message_data_.result_;
    _impl_.message_data_.result_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ToolMessage::unsafe_arena_set_allocated_result(::unhinged::messaging::ToolResult* result) {
  clear_message_data();
  if (result) {
    set_has_result();
    _impl_.message_data_.result_ = result;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.ToolMessage.result)
}
inline ::unhinged::messaging::ToolResult* ToolMessage::_internal_mutable_result() {
  if (!_internal_has_result()) {
    clear_message_data();
    set_has_result();
    _impl_.message_data_.result_ = CreateMaybeMessage< ::unhinged::messaging::ToolResult >(GetArenaForAllocation());
  }
  return _impl_.message_data_.result_;
}
inline ::unhinged::messaging::ToolResult* ToolMessage::mutable_result() {
  ::unhinged::messaging::ToolResult* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.ToolMessage.result)
  return _msg;
}

// .unhinged.messaging.ToolError tool_error = 12;
inline bool ToolMessage::_internal_has_tool_error() const {
  return message_data_case() == kToolError;
}
inline bool ToolMessage::has_tool_error() const {
  return _internal_has_tool_error();
}
inline void ToolMessage::set_has_tool_error() {
  _impl_._oneof_case_[0] = kToolError;
}
inline void ToolMessage::clear_tool_error() {
  if (_internal_has_tool_error()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_data_.tool_error_;
    }
    clear_has_message_data();
  }
}
inline ::unhinged::messaging::ToolError* ToolMessage::release_tool_error() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.ToolMessage.tool_error)
  if (_internal_has_tool_error()) {
    clear_has_message_data();
    ::unhinged::messaging::ToolError* temp = _impl_.message_data_.tool_error_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_data_.tool_error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::messaging::ToolError& ToolMessage::_internal_tool_error() const {
  return _internal_has_tool_error()
      ? *_impl_.message_data_.tool_error_
      : reinterpret_cast< ::unhinged::messaging::ToolError&>(::unhinged::messaging::_ToolError_default_instance_);
}
inline const ::unhinged::messaging::ToolError& ToolMessage::tool_error() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.ToolMessage.tool_error)
  return _internal_tool_error();
}
inline ::unhinged::messaging::ToolError* ToolMessage::unsafe_arena_release_tool_error() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.messaging.ToolMessage.tool_error)
  if (_internal_has_tool_error()) {
    clear_has_message_data();
    ::unhinged::messaging::ToolError* temp = _impl_.message_data_.tool_error_;
    _impl_.message_data_.tool_error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ToolMessage::unsafe_arena_set_allocated_tool_error(::unhinged::messaging::ToolError* tool_error) {
  clear_message_data();
  if (tool_error) {
    set_has_tool_error();
    _impl_.message_data_.tool_error_ = tool_error;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.ToolMessage.tool_error)
}
inline ::unhinged::messaging::ToolError* ToolMessage::_internal_mutable_tool_error() {
  if (!_internal_has_tool_error()) {
    clear_message_data();
    set_has_tool_error();
    _impl_.message_data_.tool_error_ = CreateMaybeMessage< ::unhinged::messaging::ToolError >(GetArenaForAllocation());
  }
  return _impl_.message_data_.tool_error_;
}
inline ::unhinged::messaging::ToolError* ToolMessage::mutable_tool_error() {
  ::unhinged::messaging::ToolError* _msg = _internal_mutable_tool_error();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.ToolMessage.tool_error)
  return _msg;
}

// .unhinged.messaging.ToolRegistration registration = 13;
inline bool ToolMessage::_internal_has_registration() const {
  return message_data_case() == kRegistration;
}
inline bool ToolMessage::has_registration() const {
  return _internal_has_registration();
}
inline void ToolMessage::set_has_registration() {
  _impl_._oneof_case_[0] = kRegistration;
}
inline void ToolMessage::clear_registration() {
  if (_internal_has_registration()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_data_.registration_;
    }
    clear_has_message_data();
  }
}
inline ::unhinged::messaging::ToolRegistration* ToolMessage::release_registration() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.ToolMessage.registration)
  if (_internal_has_registration()) {
    clear_has_message_data();
    ::unhinged::messaging::ToolRegistration* temp = _impl_.message_data_.registration_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_data_.registration_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::messaging::ToolRegistration& ToolMessage::_internal_registration() const {
  return _internal_has_registration()
      ? *_impl_.message_data_.registration_
      : reinterpret_cast< ::unhinged::messaging::ToolRegistration&>(::unhinged::messaging::_ToolRegistration_default_instance_);
}
inline const ::unhinged::messaging::ToolRegistration& ToolMessage::registration() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.ToolMessage.registration)
  return _internal_registration();
}
inline ::unhinged::messaging::ToolRegistration* ToolMessage::unsafe_arena_release_registration() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.messaging.ToolMessage.registration)
  if (_internal_has_registration()) {
    clear_has_message_data();
    ::unhinged::messaging::ToolRegistration* temp = _impl_.message_data_.registration_;
    _impl_.message_data_.registration_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ToolMessage::unsafe_arena_set_allocated_registration(::unhinged::messaging::ToolRegistration* registration) {
  clear_message_data();
  if (registration) {
    set_has_registration();
    _impl_.message_data_.registration_ = registration;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.ToolMessage.registration)
}
inline ::unhinged::messaging::ToolRegistration* ToolMessage::_internal_mutable_registration() {
  if (!_internal_has_registration()) {
    clear_message_data();
    set_has_registration();
    _impl_.message_data_.registration_ = CreateMaybeMessage< ::unhinged::messaging::ToolRegistration >(GetArenaForAllocation());
  }
  return _impl_.message_data_.registration_;
}
inline ::unhinged::messaging::ToolRegistration* ToolMessage::mutable_registration() {
  ::unhinged::messaging::ToolRegistration* _msg = _internal_mutable_registration();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.ToolMessage.registration)
  return _msg;
}

inline bool ToolMessage::has_message_data() const {
  return message_data_case() != MESSAGE_DATA_NOT_SET;
}
inline void ToolMessage::clear_has_message_data() {
  _impl_._oneof_case_[0] = MESSAGE_DATA_NOT_SET;
}
inline ToolMessage::MessageDataCase ToolMessage::message_data_case() const {
  return ToolMessage::MessageDataCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ToolInvocation

// string invocation_id = 1;
inline void ToolInvocation::clear_invocation_id() {
  _impl_.invocation_id_.ClearToEmpty();
}
inline const std::string& ToolInvocation::invocation_id() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.ToolInvocation.invocation_id)
  return _internal_invocation_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ToolInvocation::set_invocation_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.invocation_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.ToolInvocation.invocation_id)
}
inline std::string* ToolInvocation::mutable_invocation_id() {
  std::string* _s = _internal_mutable_invocation_id();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.ToolInvocation.invocation_id)
  return _s;
}
inline const std::string& ToolInvocation::_internal_invocation_id() const {
  return _impl_.invocation_id_.Get();
}
inline void ToolInvocation::_internal_set_invocation_id(const std::string& value) {
  
  _impl_.invocation_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ToolInvocation::_internal_mutable_invocation_id() {
  
  return _impl_.invocation_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ToolInvocation::release_invocation_id() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.ToolInvocation.invocation_id)
  return _impl_.invocation_id_.Release();
}
inline void ToolInvocation::set_allocated_invocation_id(std::string* invocation_id) {
  if (invocation_id != nullptr) {
    
  } else {
    
  }
  _impl_.invocation_id_.SetAllocated(invocation_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.invocation_id_.IsDefault()) {
    _impl_.invocation_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.ToolInvocation.invocation_id)
}

// .google.protobuf.Struct arguments = 2;
inline bool ToolInvocation::_internal_has_arguments() const {
  return this != internal_default_instance() && _impl_.arguments_ != nullptr;
}
inline bool ToolInvocation::has_arguments() const {
  return _internal_has_arguments();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& ToolInvocation::_internal_arguments() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.arguments_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& ToolInvocation::arguments() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.ToolInvocation.arguments)
  return _internal_arguments();
}
inline void ToolInvocation::unsafe_arena_set_allocated_arguments(
    ::PROTOBUF_NAMESPACE_ID::Struct* arguments) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.arguments_);
  }
  _impl_.arguments_ = arguments;
  if (arguments) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.ToolInvocation.arguments)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ToolInvocation::release_arguments() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.arguments_;
  _impl_.arguments_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ToolInvocation::unsafe_arena_release_arguments() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.ToolInvocation.arguments)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.arguments_;
  _impl_.arguments_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ToolInvocation::_internal_mutable_arguments() {
  
  if (_impl_.arguments_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.arguments_ = p;
  }
  return _impl_.arguments_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ToolInvocation::mutable_arguments() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_arguments();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.ToolInvocation.arguments)
  return _msg;
}
inline void ToolInvocation::set_allocated_arguments(::PROTOBUF_NAMESPACE_ID::Struct* arguments) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.arguments_);
  }
  if (arguments) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(arguments));
    if (message_arena != submessage_arena) {
      arguments = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, arguments, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.arguments_ = arguments;
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.ToolInvocation.arguments)
}

// .google.protobuf.Struct context = 3;
inline bool ToolInvocation::_internal_has_context() const {
  return this != internal_default_instance() && _impl_.context_ != nullptr;
}
inline bool ToolInvocation::has_context() const {
  return _internal_has_context();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& ToolInvocation::_internal_context() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.context_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& ToolInvocation::context() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.ToolInvocation.context)
  return _internal_context();
}
inline void ToolInvocation::unsafe_arena_set_allocated_context(
    ::PROTOBUF_NAMESPACE_ID::Struct* context) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.context_);
  }
  _impl_.context_ = context;
  if (context) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.ToolInvocation.context)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ToolInvocation::release_context() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.context_;
  _impl_.context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ToolInvocation::unsafe_arena_release_context() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.ToolInvocation.context)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.context_;
  _impl_.context_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ToolInvocation::_internal_mutable_context() {
  
  if (_impl_.context_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.context_ = p;
  }
  return _impl_.context_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ToolInvocation::mutable_context() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_context();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.ToolInvocation.context)
  return _msg;
}
inline void ToolInvocation::set_allocated_context(::PROTOBUF_NAMESPACE_ID::Struct* context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.context_);
  }
  if (context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(context));
    if (message_arena != submessage_arena) {
      context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, context, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.context_ = context;
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.ToolInvocation.context)
}

// int32 timeout_seconds = 4;
inline void ToolInvocation::clear_timeout_seconds() {
  _impl_.timeout_seconds_ = 0;
}
inline int32_t ToolInvocation::_internal_timeout_seconds() const {
  return _impl_.timeout_seconds_;
}
inline int32_t ToolInvocation::timeout_seconds() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.ToolInvocation.timeout_seconds)
  return _internal_timeout_seconds();
}
inline void ToolInvocation::_internal_set_timeout_seconds(int32_t value) {
  
  _impl_.timeout_seconds_ = value;
}
inline void ToolInvocation::set_timeout_seconds(int32_t value) {
  _internal_set_timeout_seconds(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.ToolInvocation.timeout_seconds)
}

// -------------------------------------------------------------------

// ToolResult

// string invocation_id = 1;
inline void ToolResult::clear_invocation_id() {
  _impl_.invocation_id_.ClearToEmpty();
}
inline const std::string& ToolResult::invocation_id() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.ToolResult.invocation_id)
  return _internal_invocation_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ToolResult::set_invocation_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.invocation_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.ToolResult.invocation_id)
}
inline std::string* ToolResult::mutable_invocation_id() {
  std::string* _s = _internal_mutable_invocation_id();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.ToolResult.invocation_id)
  return _s;
}
inline const std::string& ToolResult::_internal_invocation_id() const {
  return _impl_.invocation_id_.Get();
}
inline void ToolResult::_internal_set_invocation_id(const std::string& value) {
  
  _impl_.invocation_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ToolResult::_internal_mutable_invocation_id() {
  
  return _impl_.invocation_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ToolResult::release_invocation_id() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.ToolResult.invocation_id)
  return _impl_.invocation_id_.Release();
}
inline void ToolResult::set_allocated_invocation_id(std::string* invocation_id) {
  if (invocation_id != nullptr) {
    
  } else {
    
  }
  _impl_.invocation_id_.SetAllocated(invocation_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.invocation_id_.IsDefault()) {
    _impl_.invocation_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.ToolResult.invocation_id)
}

// bool success = 2;
inline void ToolResult::clear_success() {
  _impl_.success_ = false;
}
inline bool ToolResult::_internal_success() const {
  return _impl_.success_;
}
inline bool ToolResult::success() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.ToolResult.success)
  return _internal_success();
}
inline void ToolResult::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void ToolResult::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.ToolResult.success)
}

// .google.protobuf.Any result_data = 3;
inline bool ToolResult::_internal_has_result_data() const {
  return this != internal_default_instance() && _impl_.result_data_ != nullptr;
}
inline bool ToolResult::has_result_data() const {
  return _internal_has_result_data();
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& ToolResult::_internal_result_data() const {
  const ::PROTOBUF_NAMESPACE_ID::Any* p = _impl_.result_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Any&>(
      ::PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& ToolResult::result_data() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.ToolResult.result_data)
  return _internal_result_data();
}
inline void ToolResult::unsafe_arena_set_allocated_result_data(
    ::PROTOBUF_NAMESPACE_ID::Any* result_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.result_data_);
  }
  _impl_.result_data_ = result_data;
  if (result_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.ToolResult.result_data)
}
inline ::PROTOBUF_NAMESPACE_ID::Any* ToolResult::release_result_data() {
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.result_data_;
  _impl_.result_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* ToolResult::unsafe_arena_release_result_data() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.ToolResult.result_data)
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.result_data_;
  _impl_.result_data_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* ToolResult::_internal_mutable_result_data() {
  
  if (_impl_.result_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Any>(GetArenaForAllocation());
    _impl_.result_data_ = p;
  }
  return _impl_.result_data_;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* ToolResult::mutable_result_data() {
  ::PROTOBUF_NAMESPACE_ID::Any* _msg = _internal_mutable_result_data();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.ToolResult.result_data)
  return _msg;
}
inline void ToolResult::set_allocated_result_data(::PROTOBUF_NAMESPACE_ID::Any* result_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.result_data_);
  }
  if (result_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_data));
    if (message_arena != submessage_arena) {
      result_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.result_data_ = result_data;
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.ToolResult.result_data)
}

// string result_text = 4;
inline void ToolResult::clear_result_text() {
  _impl_.result_text_.ClearToEmpty();
}
inline const std::string& ToolResult::result_text() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.ToolResult.result_text)
  return _internal_result_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ToolResult::set_result_text(ArgT0&& arg0, ArgT... args) {
 
 _impl_.result_text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.ToolResult.result_text)
}
inline std::string* ToolResult::mutable_result_text() {
  std::string* _s = _internal_mutable_result_text();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.ToolResult.result_text)
  return _s;
}
inline const std::string& ToolResult::_internal_result_text() const {
  return _impl_.result_text_.Get();
}
inline void ToolResult::_internal_set_result_text(const std::string& value) {
  
  _impl_.result_text_.Set(value, GetArenaForAllocation());
}
inline std::string* ToolResult::_internal_mutable_result_text() {
  
  return _impl_.result_text_.Mutable(GetArenaForAllocation());
}
inline std::string* ToolResult::release_result_text() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.ToolResult.result_text)
  return _impl_.result_text_.Release();
}
inline void ToolResult::set_allocated_result_text(std::string* result_text) {
  if (result_text != nullptr) {
    
  } else {
    
  }
  _impl_.result_text_.SetAllocated(result_text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.result_text_.IsDefault()) {
    _impl_.result_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.ToolResult.result_text)
}

// repeated string artifacts = 5;
inline int ToolResult::_internal_artifacts_size() const {
  return _impl_.artifacts_.size();
}
inline int ToolResult::artifacts_size() const {
  return _internal_artifacts_size();
}
inline void ToolResult::clear_artifacts() {
  _impl_.artifacts_.Clear();
}
inline std::string* ToolResult::add_artifacts() {
  std::string* _s = _internal_add_artifacts();
  // @@protoc_insertion_point(field_add_mutable:unhinged.messaging.ToolResult.artifacts)
  return _s;
}
inline const std::string& ToolResult::_internal_artifacts(int index) const {
  return _impl_.artifacts_.Get(index);
}
inline const std::string& ToolResult::artifacts(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.ToolResult.artifacts)
  return _internal_artifacts(index);
}
inline std::string* ToolResult::mutable_artifacts(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.ToolResult.artifacts)
  return _impl_.artifacts_.Mutable(index);
}
inline void ToolResult::set_artifacts(int index, const std::string& value) {
  _impl_.artifacts_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.ToolResult.artifacts)
}
inline void ToolResult::set_artifacts(int index, std::string&& value) {
  _impl_.artifacts_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.messaging.ToolResult.artifacts)
}
inline void ToolResult::set_artifacts(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.artifacts_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.messaging.ToolResult.artifacts)
}
inline void ToolResult::set_artifacts(int index, const char* value, size_t size) {
  _impl_.artifacts_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.messaging.ToolResult.artifacts)
}
inline std::string* ToolResult::_internal_add_artifacts() {
  return _impl_.artifacts_.Add();
}
inline void ToolResult::add_artifacts(const std::string& value) {
  _impl_.artifacts_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.messaging.ToolResult.artifacts)
}
inline void ToolResult::add_artifacts(std::string&& value) {
  _impl_.artifacts_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.messaging.ToolResult.artifacts)
}
inline void ToolResult::add_artifacts(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.artifacts_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.messaging.ToolResult.artifacts)
}
inline void ToolResult::add_artifacts(const char* value, size_t size) {
  _impl_.artifacts_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.messaging.ToolResult.artifacts)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ToolResult::artifacts() const {
  // @@protoc_insertion_point(field_list:unhinged.messaging.ToolResult.artifacts)
  return _impl_.artifacts_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ToolResult::mutable_artifacts() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.messaging.ToolResult.artifacts)
  return &_impl_.artifacts_;
}

// float execution_time_ms = 6;
inline void ToolResult::clear_execution_time_ms() {
  _impl_.execution_time_ms_ = 0;
}
inline float ToolResult::_internal_execution_time_ms() const {
  return _impl_.execution_time_ms_;
}
inline float ToolResult::execution_time_ms() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.ToolResult.execution_time_ms)
  return _internal_execution_time_ms();
}
inline void ToolResult::_internal_set_execution_time_ms(float value) {
  
  _impl_.execution_time_ms_ = value;
}
inline void ToolResult::set_execution_time_ms(float value) {
  _internal_set_execution_time_ms(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.ToolResult.execution_time_ms)
}

// -------------------------------------------------------------------

// ToolError

// string invocation_id = 1;
inline void ToolError::clear_invocation_id() {
  _impl_.invocation_id_.ClearToEmpty();
}
inline const std::string& ToolError::invocation_id() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.ToolError.invocation_id)
  return _internal_invocation_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ToolError::set_invocation_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.invocation_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.ToolError.invocation_id)
}
inline std::string* ToolError::mutable_invocation_id() {
  std::string* _s = _internal_mutable_invocation_id();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.ToolError.invocation_id)
  return _s;
}
inline const std::string& ToolError::_internal_invocation_id() const {
  return _impl_.invocation_id_.Get();
}
inline void ToolError::_internal_set_invocation_id(const std::string& value) {
  
  _impl_.invocation_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ToolError::_internal_mutable_invocation_id() {
  
  return _impl_.invocation_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ToolError::release_invocation_id() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.ToolError.invocation_id)
  return _impl_.invocation_id_.Release();
}
inline void ToolError::set_allocated_invocation_id(std::string* invocation_id) {
  if (invocation_id != nullptr) {
    
  } else {
    
  }
  _impl_.invocation_id_.SetAllocated(invocation_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.invocation_id_.IsDefault()) {
    _impl_.invocation_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.ToolError.invocation_id)
}

// string error_code = 2;
inline void ToolError::clear_error_code() {
  _impl_.error_code_.ClearToEmpty();
}
inline const std::string& ToolError::error_code() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.ToolError.error_code)
  return _internal_error_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ToolError::set_error_code(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.ToolError.error_code)
}
inline std::string* ToolError::mutable_error_code() {
  std::string* _s = _internal_mutable_error_code();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.ToolError.error_code)
  return _s;
}
inline const std::string& ToolError::_internal_error_code() const {
  return _impl_.error_code_.Get();
}
inline void ToolError::_internal_set_error_code(const std::string& value) {
  
  _impl_.error_code_.Set(value, GetArenaForAllocation());
}
inline std::string* ToolError::_internal_mutable_error_code() {
  
  return _impl_.error_code_.Mutable(GetArenaForAllocation());
}
inline std::string* ToolError::release_error_code() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.ToolError.error_code)
  return _impl_.error_code_.Release();
}
inline void ToolError::set_allocated_error_code(std::string* error_code) {
  if (error_code != nullptr) {
    
  } else {
    
  }
  _impl_.error_code_.SetAllocated(error_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_code_.IsDefault()) {
    _impl_.error_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.ToolError.error_code)
}

// string error_message = 3;
inline void ToolError::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& ToolError::error_message() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.ToolError.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ToolError::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.ToolError.error_message)
}
inline std::string* ToolError::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.ToolError.error_message)
  return _s;
}
inline const std::string& ToolError::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void ToolError::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* ToolError::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* ToolError::release_error_message() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.ToolError.error_message)
  return _impl_.error_message_.Release();
}
inline void ToolError::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.ToolError.error_message)
}

// bool is_retryable = 4;
inline void ToolError::clear_is_retryable() {
  _impl_.is_retryable_ = false;
}
inline bool ToolError::_internal_is_retryable() const {
  return _impl_.is_retryable_;
}
inline bool ToolError::is_retryable() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.ToolError.is_retryable)
  return _internal_is_retryable();
}
inline void ToolError::_internal_set_is_retryable(bool value) {
  
  _impl_.is_retryable_ = value;
}
inline void ToolError::set_is_retryable(bool value) {
  _internal_set_is_retryable(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.ToolError.is_retryable)
}

// -------------------------------------------------------------------

// ToolRegistration

// string tool_name = 1;
inline void ToolRegistration::clear_tool_name() {
  _impl_.tool_name_.ClearToEmpty();
}
inline const std::string& ToolRegistration::tool_name() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.ToolRegistration.tool_name)
  return _internal_tool_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ToolRegistration::set_tool_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tool_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.ToolRegistration.tool_name)
}
inline std::string* ToolRegistration::mutable_tool_name() {
  std::string* _s = _internal_mutable_tool_name();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.ToolRegistration.tool_name)
  return _s;
}
inline const std::string& ToolRegistration::_internal_tool_name() const {
  return _impl_.tool_name_.Get();
}
inline void ToolRegistration::_internal_set_tool_name(const std::string& value) {
  
  _impl_.tool_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ToolRegistration::_internal_mutable_tool_name() {
  
  return _impl_.tool_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ToolRegistration::release_tool_name() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.ToolRegistration.tool_name)
  return _impl_.tool_name_.Release();
}
inline void ToolRegistration::set_allocated_tool_name(std::string* tool_name) {
  if (tool_name != nullptr) {
    
  } else {
    
  }
  _impl_.tool_name_.SetAllocated(tool_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tool_name_.IsDefault()) {
    _impl_.tool_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.ToolRegistration.tool_name)
}

// string tool_version = 2;
inline void ToolRegistration::clear_tool_version() {
  _impl_.tool_version_.ClearToEmpty();
}
inline const std::string& ToolRegistration::tool_version() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.ToolRegistration.tool_version)
  return _internal_tool_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ToolRegistration::set_tool_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tool_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.ToolRegistration.tool_version)
}
inline std::string* ToolRegistration::mutable_tool_version() {
  std::string* _s = _internal_mutable_tool_version();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.ToolRegistration.tool_version)
  return _s;
}
inline const std::string& ToolRegistration::_internal_tool_version() const {
  return _impl_.tool_version_.Get();
}
inline void ToolRegistration::_internal_set_tool_version(const std::string& value) {
  
  _impl_.tool_version_.Set(value, GetArenaForAllocation());
}
inline std::string* ToolRegistration::_internal_mutable_tool_version() {
  
  return _impl_.tool_version_.Mutable(GetArenaForAllocation());
}
inline std::string* ToolRegistration::release_tool_version() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.ToolRegistration.tool_version)
  return _impl_.tool_version_.Release();
}
inline void ToolRegistration::set_allocated_tool_version(std::string* tool_version) {
  if (tool_version != nullptr) {
    
  } else {
    
  }
  _impl_.tool_version_.SetAllocated(tool_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tool_version_.IsDefault()) {
    _impl_.tool_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.ToolRegistration.tool_version)
}

// string description = 3;
inline void ToolRegistration::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& ToolRegistration::description() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.ToolRegistration.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ToolRegistration::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.ToolRegistration.description)
}
inline std::string* ToolRegistration::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.ToolRegistration.description)
  return _s;
}
inline const std::string& ToolRegistration::_internal_description() const {
  return _impl_.description_.Get();
}
inline void ToolRegistration::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* ToolRegistration::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* ToolRegistration::release_description() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.ToolRegistration.description)
  return _impl_.description_.Release();
}
inline void ToolRegistration::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.ToolRegistration.description)
}

// .google.protobuf.Struct schema = 4;
inline bool ToolRegistration::_internal_has_schema() const {
  return this != internal_default_instance() && _impl_.schema_ != nullptr;
}
inline bool ToolRegistration::has_schema() const {
  return _internal_has_schema();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& ToolRegistration::_internal_schema() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.schema_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& ToolRegistration::schema() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.ToolRegistration.schema)
  return _internal_schema();
}
inline void ToolRegistration::unsafe_arena_set_allocated_schema(
    ::PROTOBUF_NAMESPACE_ID::Struct* schema) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.schema_);
  }
  _impl_.schema_ = schema;
  if (schema) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.ToolRegistration.schema)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ToolRegistration::release_schema() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.schema_;
  _impl_.schema_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ToolRegistration::unsafe_arena_release_schema() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.ToolRegistration.schema)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.schema_;
  _impl_.schema_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ToolRegistration::_internal_mutable_schema() {
  
  if (_impl_.schema_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.schema_ = p;
  }
  return _impl_.schema_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ToolRegistration::mutable_schema() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_schema();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.ToolRegistration.schema)
  return _msg;
}
inline void ToolRegistration::set_allocated_schema(::PROTOBUF_NAMESPACE_ID::Struct* schema) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.schema_);
  }
  if (schema) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(schema));
    if (message_arena != submessage_arena) {
      schema = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, schema, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.schema_ = schema;
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.ToolRegistration.schema)
}

// repeated string capabilities = 5;
inline int ToolRegistration::_internal_capabilities_size() const {
  return _impl_.capabilities_.size();
}
inline int ToolRegistration::capabilities_size() const {
  return _internal_capabilities_size();
}
inline void ToolRegistration::clear_capabilities() {
  _impl_.capabilities_.Clear();
}
inline std::string* ToolRegistration::add_capabilities() {
  std::string* _s = _internal_add_capabilities();
  // @@protoc_insertion_point(field_add_mutable:unhinged.messaging.ToolRegistration.capabilities)
  return _s;
}
inline const std::string& ToolRegistration::_internal_capabilities(int index) const {
  return _impl_.capabilities_.Get(index);
}
inline const std::string& ToolRegistration::capabilities(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.ToolRegistration.capabilities)
  return _internal_capabilities(index);
}
inline std::string* ToolRegistration::mutable_capabilities(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.ToolRegistration.capabilities)
  return _impl_.capabilities_.Mutable(index);
}
inline void ToolRegistration::set_capabilities(int index, const std::string& value) {
  _impl_.capabilities_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.ToolRegistration.capabilities)
}
inline void ToolRegistration::set_capabilities(int index, std::string&& value) {
  _impl_.capabilities_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.messaging.ToolRegistration.capabilities)
}
inline void ToolRegistration::set_capabilities(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.capabilities_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.messaging.ToolRegistration.capabilities)
}
inline void ToolRegistration::set_capabilities(int index, const char* value, size_t size) {
  _impl_.capabilities_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.messaging.ToolRegistration.capabilities)
}
inline std::string* ToolRegistration::_internal_add_capabilities() {
  return _impl_.capabilities_.Add();
}
inline void ToolRegistration::add_capabilities(const std::string& value) {
  _impl_.capabilities_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.messaging.ToolRegistration.capabilities)
}
inline void ToolRegistration::add_capabilities(std::string&& value) {
  _impl_.capabilities_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.messaging.ToolRegistration.capabilities)
}
inline void ToolRegistration::add_capabilities(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.capabilities_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.messaging.ToolRegistration.capabilities)
}
inline void ToolRegistration::add_capabilities(const char* value, size_t size) {
  _impl_.capabilities_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.messaging.ToolRegistration.capabilities)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ToolRegistration::capabilities() const {
  // @@protoc_insertion_point(field_list:unhinged.messaging.ToolRegistration.capabilities)
  return _impl_.capabilities_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ToolRegistration::mutable_capabilities() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.messaging.ToolRegistration.capabilities)
  return &_impl_.capabilities_;
}

// string endpoint_url = 6;
inline void ToolRegistration::clear_endpoint_url() {
  _impl_.endpoint_url_.ClearToEmpty();
}
inline const std::string& ToolRegistration::endpoint_url() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.ToolRegistration.endpoint_url)
  return _internal_endpoint_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ToolRegistration::set_endpoint_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.endpoint_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.ToolRegistration.endpoint_url)
}
inline std::string* ToolRegistration::mutable_endpoint_url() {
  std::string* _s = _internal_mutable_endpoint_url();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.ToolRegistration.endpoint_url)
  return _s;
}
inline const std::string& ToolRegistration::_internal_endpoint_url() const {
  return _impl_.endpoint_url_.Get();
}
inline void ToolRegistration::_internal_set_endpoint_url(const std::string& value) {
  
  _impl_.endpoint_url_.Set(value, GetArenaForAllocation());
}
inline std::string* ToolRegistration::_internal_mutable_endpoint_url() {
  
  return _impl_.endpoint_url_.Mutable(GetArenaForAllocation());
}
inline std::string* ToolRegistration::release_endpoint_url() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.ToolRegistration.endpoint_url)
  return _impl_.endpoint_url_.Release();
}
inline void ToolRegistration::set_allocated_endpoint_url(std::string* endpoint_url) {
  if (endpoint_url != nullptr) {
    
  } else {
    
  }
  _impl_.endpoint_url_.SetAllocated(endpoint_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.endpoint_url_.IsDefault()) {
    _impl_.endpoint_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.ToolRegistration.endpoint_url)
}

// -------------------------------------------------------------------

// WorkflowMessage

// string workflow_id = 1;
inline void WorkflowMessage::clear_workflow_id() {
  _impl_.workflow_id_.ClearToEmpty();
}
inline const std::string& WorkflowMessage::workflow_id() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.WorkflowMessage.workflow_id)
  return _internal_workflow_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WorkflowMessage::set_workflow_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.workflow_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.WorkflowMessage.workflow_id)
}
inline std::string* WorkflowMessage::mutable_workflow_id() {
  std::string* _s = _internal_mutable_workflow_id();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.WorkflowMessage.workflow_id)
  return _s;
}
inline const std::string& WorkflowMessage::_internal_workflow_id() const {
  return _impl_.workflow_id_.Get();
}
inline void WorkflowMessage::_internal_set_workflow_id(const std::string& value) {
  
  _impl_.workflow_id_.Set(value, GetArenaForAllocation());
}
inline std::string* WorkflowMessage::_internal_mutable_workflow_id() {
  
  return _impl_.workflow_id_.Mutable(GetArenaForAllocation());
}
inline std::string* WorkflowMessage::release_workflow_id() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.WorkflowMessage.workflow_id)
  return _impl_.workflow_id_.Release();
}
inline void WorkflowMessage::set_allocated_workflow_id(std::string* workflow_id) {
  if (workflow_id != nullptr) {
    
  } else {
    
  }
  _impl_.workflow_id_.SetAllocated(workflow_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.workflow_id_.IsDefault()) {
    _impl_.workflow_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.WorkflowMessage.workflow_id)
}

// string execution_id = 2;
inline void WorkflowMessage::clear_execution_id() {
  _impl_.execution_id_.ClearToEmpty();
}
inline const std::string& WorkflowMessage::execution_id() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.WorkflowMessage.execution_id)
  return _internal_execution_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WorkflowMessage::set_execution_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.execution_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.WorkflowMessage.execution_id)
}
inline std::string* WorkflowMessage::mutable_execution_id() {
  std::string* _s = _internal_mutable_execution_id();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.WorkflowMessage.execution_id)
  return _s;
}
inline const std::string& WorkflowMessage::_internal_execution_id() const {
  return _impl_.execution_id_.Get();
}
inline void WorkflowMessage::_internal_set_execution_id(const std::string& value) {
  
  _impl_.execution_id_.Set(value, GetArenaForAllocation());
}
inline std::string* WorkflowMessage::_internal_mutable_execution_id() {
  
  return _impl_.execution_id_.Mutable(GetArenaForAllocation());
}
inline std::string* WorkflowMessage::release_execution_id() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.WorkflowMessage.execution_id)
  return _impl_.execution_id_.Release();
}
inline void WorkflowMessage::set_allocated_execution_id(std::string* execution_id) {
  if (execution_id != nullptr) {
    
  } else {
    
  }
  _impl_.execution_id_.SetAllocated(execution_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.execution_id_.IsDefault()) {
    _impl_.execution_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.WorkflowMessage.execution_id)
}

// .unhinged.messaging.WorkflowMessageType message_type = 3;
inline void WorkflowMessage::clear_message_type() {
  _impl_.message_type_ = 0;
}
inline ::unhinged::messaging::WorkflowMessageType WorkflowMessage::_internal_message_type() const {
  return static_cast< ::unhinged::messaging::WorkflowMessageType >(_impl_.message_type_);
}
inline ::unhinged::messaging::WorkflowMessageType WorkflowMessage::message_type() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.WorkflowMessage.message_type)
  return _internal_message_type();
}
inline void WorkflowMessage::_internal_set_message_type(::unhinged::messaging::WorkflowMessageType value) {
  
  _impl_.message_type_ = value;
}
inline void WorkflowMessage::set_message_type(::unhinged::messaging::WorkflowMessageType value) {
  _internal_set_message_type(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.WorkflowMessage.message_type)
}

// .unhinged.messaging.WorkflowTrigger trigger = 10;
inline bool WorkflowMessage::_internal_has_trigger() const {
  return message_data_case() == kTrigger;
}
inline bool WorkflowMessage::has_trigger() const {
  return _internal_has_trigger();
}
inline void WorkflowMessage::set_has_trigger() {
  _impl_._oneof_case_[0] = kTrigger;
}
inline void WorkflowMessage::clear_trigger() {
  if (_internal_has_trigger()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_data_.trigger_;
    }
    clear_has_message_data();
  }
}
inline ::unhinged::messaging::WorkflowTrigger* WorkflowMessage::release_trigger() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.WorkflowMessage.trigger)
  if (_internal_has_trigger()) {
    clear_has_message_data();
    ::unhinged::messaging::WorkflowTrigger* temp = _impl_.message_data_.trigger_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_data_.trigger_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::messaging::WorkflowTrigger& WorkflowMessage::_internal_trigger() const {
  return _internal_has_trigger()
      ? *_impl_.message_data_.trigger_
      : reinterpret_cast< ::unhinged::messaging::WorkflowTrigger&>(::unhinged::messaging::_WorkflowTrigger_default_instance_);
}
inline const ::unhinged::messaging::WorkflowTrigger& WorkflowMessage::trigger() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.WorkflowMessage.trigger)
  return _internal_trigger();
}
inline ::unhinged::messaging::WorkflowTrigger* WorkflowMessage::unsafe_arena_release_trigger() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.messaging.WorkflowMessage.trigger)
  if (_internal_has_trigger()) {
    clear_has_message_data();
    ::unhinged::messaging::WorkflowTrigger* temp = _impl_.message_data_.trigger_;
    _impl_.message_data_.trigger_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WorkflowMessage::unsafe_arena_set_allocated_trigger(::unhinged::messaging::WorkflowTrigger* trigger) {
  clear_message_data();
  if (trigger) {
    set_has_trigger();
    _impl_.message_data_.trigger_ = trigger;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.WorkflowMessage.trigger)
}
inline ::unhinged::messaging::WorkflowTrigger* WorkflowMessage::_internal_mutable_trigger() {
  if (!_internal_has_trigger()) {
    clear_message_data();
    set_has_trigger();
    _impl_.message_data_.trigger_ = CreateMaybeMessage< ::unhinged::messaging::WorkflowTrigger >(GetArenaForAllocation());
  }
  return _impl_.message_data_.trigger_;
}
inline ::unhinged::messaging::WorkflowTrigger* WorkflowMessage::mutable_trigger() {
  ::unhinged::messaging::WorkflowTrigger* _msg = _internal_mutable_trigger();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.WorkflowMessage.trigger)
  return _msg;
}

// .unhinged.messaging.WorkflowStepExecution step_execution = 11;
inline bool WorkflowMessage::_internal_has_step_execution() const {
  return message_data_case() == kStepExecution;
}
inline bool WorkflowMessage::has_step_execution() const {
  return _internal_has_step_execution();
}
inline void WorkflowMessage::set_has_step_execution() {
  _impl_._oneof_case_[0] = kStepExecution;
}
inline void WorkflowMessage::clear_step_execution() {
  if (_internal_has_step_execution()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_data_.step_execution_;
    }
    clear_has_message_data();
  }
}
inline ::unhinged::messaging::WorkflowStepExecution* WorkflowMessage::release_step_execution() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.WorkflowMessage.step_execution)
  if (_internal_has_step_execution()) {
    clear_has_message_data();
    ::unhinged::messaging::WorkflowStepExecution* temp = _impl_.message_data_.step_execution_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_data_.step_execution_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::messaging::WorkflowStepExecution& WorkflowMessage::_internal_step_execution() const {
  return _internal_has_step_execution()
      ? *_impl_.message_data_.step_execution_
      : reinterpret_cast< ::unhinged::messaging::WorkflowStepExecution&>(::unhinged::messaging::_WorkflowStepExecution_default_instance_);
}
inline const ::unhinged::messaging::WorkflowStepExecution& WorkflowMessage::step_execution() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.WorkflowMessage.step_execution)
  return _internal_step_execution();
}
inline ::unhinged::messaging::WorkflowStepExecution* WorkflowMessage::unsafe_arena_release_step_execution() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.messaging.WorkflowMessage.step_execution)
  if (_internal_has_step_execution()) {
    clear_has_message_data();
    ::unhinged::messaging::WorkflowStepExecution* temp = _impl_.message_data_.step_execution_;
    _impl_.message_data_.step_execution_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WorkflowMessage::unsafe_arena_set_allocated_step_execution(::unhinged::messaging::WorkflowStepExecution* step_execution) {
  clear_message_data();
  if (step_execution) {
    set_has_step_execution();
    _impl_.message_data_.step_execution_ = step_execution;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.WorkflowMessage.step_execution)
}
inline ::unhinged::messaging::WorkflowStepExecution* WorkflowMessage::_internal_mutable_step_execution() {
  if (!_internal_has_step_execution()) {
    clear_message_data();
    set_has_step_execution();
    _impl_.message_data_.step_execution_ = CreateMaybeMessage< ::unhinged::messaging::WorkflowStepExecution >(GetArenaForAllocation());
  }
  return _impl_.message_data_.step_execution_;
}
inline ::unhinged::messaging::WorkflowStepExecution* WorkflowMessage::mutable_step_execution() {
  ::unhinged::messaging::WorkflowStepExecution* _msg = _internal_mutable_step_execution();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.WorkflowMessage.step_execution)
  return _msg;
}

// .unhinged.messaging.WorkflowCompletion completion = 12;
inline bool WorkflowMessage::_internal_has_completion() const {
  return message_data_case() == kCompletion;
}
inline bool WorkflowMessage::has_completion() const {
  return _internal_has_completion();
}
inline void WorkflowMessage::set_has_completion() {
  _impl_._oneof_case_[0] = kCompletion;
}
inline void WorkflowMessage::clear_completion() {
  if (_internal_has_completion()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_data_.completion_;
    }
    clear_has_message_data();
  }
}
inline ::unhinged::messaging::WorkflowCompletion* WorkflowMessage::release_completion() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.WorkflowMessage.completion)
  if (_internal_has_completion()) {
    clear_has_message_data();
    ::unhinged::messaging::WorkflowCompletion* temp = _impl_.message_data_.completion_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_data_.completion_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::messaging::WorkflowCompletion& WorkflowMessage::_internal_completion() const {
  return _internal_has_completion()
      ? *_impl_.message_data_.completion_
      : reinterpret_cast< ::unhinged::messaging::WorkflowCompletion&>(::unhinged::messaging::_WorkflowCompletion_default_instance_);
}
inline const ::unhinged::messaging::WorkflowCompletion& WorkflowMessage::completion() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.WorkflowMessage.completion)
  return _internal_completion();
}
inline ::unhinged::messaging::WorkflowCompletion* WorkflowMessage::unsafe_arena_release_completion() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.messaging.WorkflowMessage.completion)
  if (_internal_has_completion()) {
    clear_has_message_data();
    ::unhinged::messaging::WorkflowCompletion* temp = _impl_.message_data_.completion_;
    _impl_.message_data_.completion_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WorkflowMessage::unsafe_arena_set_allocated_completion(::unhinged::messaging::WorkflowCompletion* completion) {
  clear_message_data();
  if (completion) {
    set_has_completion();
    _impl_.message_data_.completion_ = completion;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.WorkflowMessage.completion)
}
inline ::unhinged::messaging::WorkflowCompletion* WorkflowMessage::_internal_mutable_completion() {
  if (!_internal_has_completion()) {
    clear_message_data();
    set_has_completion();
    _impl_.message_data_.completion_ = CreateMaybeMessage< ::unhinged::messaging::WorkflowCompletion >(GetArenaForAllocation());
  }
  return _impl_.message_data_.completion_;
}
inline ::unhinged::messaging::WorkflowCompletion* WorkflowMessage::mutable_completion() {
  ::unhinged::messaging::WorkflowCompletion* _msg = _internal_mutable_completion();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.WorkflowMessage.completion)
  return _msg;
}

// .unhinged.messaging.WorkflowControl control = 13;
inline bool WorkflowMessage::_internal_has_control() const {
  return message_data_case() == kControl;
}
inline bool WorkflowMessage::has_control() const {
  return _internal_has_control();
}
inline void WorkflowMessage::set_has_control() {
  _impl_._oneof_case_[0] = kControl;
}
inline void WorkflowMessage::clear_control() {
  if (_internal_has_control()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_data_.control_;
    }
    clear_has_message_data();
  }
}
inline ::unhinged::messaging::WorkflowControl* WorkflowMessage::release_control() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.WorkflowMessage.control)
  if (_internal_has_control()) {
    clear_has_message_data();
    ::unhinged::messaging::WorkflowControl* temp = _impl_.message_data_.control_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_data_.control_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::messaging::WorkflowControl& WorkflowMessage::_internal_control() const {
  return _internal_has_control()
      ? *_impl_.message_data_.control_
      : reinterpret_cast< ::unhinged::messaging::WorkflowControl&>(::unhinged::messaging::_WorkflowControl_default_instance_);
}
inline const ::unhinged::messaging::WorkflowControl& WorkflowMessage::control() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.WorkflowMessage.control)
  return _internal_control();
}
inline ::unhinged::messaging::WorkflowControl* WorkflowMessage::unsafe_arena_release_control() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.messaging.WorkflowMessage.control)
  if (_internal_has_control()) {
    clear_has_message_data();
    ::unhinged::messaging::WorkflowControl* temp = _impl_.message_data_.control_;
    _impl_.message_data_.control_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WorkflowMessage::unsafe_arena_set_allocated_control(::unhinged::messaging::WorkflowControl* control) {
  clear_message_data();
  if (control) {
    set_has_control();
    _impl_.message_data_.control_ = control;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.WorkflowMessage.control)
}
inline ::unhinged::messaging::WorkflowControl* WorkflowMessage::_internal_mutable_control() {
  if (!_internal_has_control()) {
    clear_message_data();
    set_has_control();
    _impl_.message_data_.control_ = CreateMaybeMessage< ::unhinged::messaging::WorkflowControl >(GetArenaForAllocation());
  }
  return _impl_.message_data_.control_;
}
inline ::unhinged::messaging::WorkflowControl* WorkflowMessage::mutable_control() {
  ::unhinged::messaging::WorkflowControl* _msg = _internal_mutable_control();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.WorkflowMessage.control)
  return _msg;
}

inline bool WorkflowMessage::has_message_data() const {
  return message_data_case() != MESSAGE_DATA_NOT_SET;
}
inline void WorkflowMessage::clear_has_message_data() {
  _impl_._oneof_case_[0] = MESSAGE_DATA_NOT_SET;
}
inline WorkflowMessage::MessageDataCase WorkflowMessage::message_data_case() const {
  return WorkflowMessage::MessageDataCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// WorkflowTrigger

// string trigger_type = 1;
inline void WorkflowTrigger::clear_trigger_type() {
  _impl_.trigger_type_.ClearToEmpty();
}
inline const std::string& WorkflowTrigger::trigger_type() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.WorkflowTrigger.trigger_type)
  return _internal_trigger_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WorkflowTrigger::set_trigger_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.trigger_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.WorkflowTrigger.trigger_type)
}
inline std::string* WorkflowTrigger::mutable_trigger_type() {
  std::string* _s = _internal_mutable_trigger_type();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.WorkflowTrigger.trigger_type)
  return _s;
}
inline const std::string& WorkflowTrigger::_internal_trigger_type() const {
  return _impl_.trigger_type_.Get();
}
inline void WorkflowTrigger::_internal_set_trigger_type(const std::string& value) {
  
  _impl_.trigger_type_.Set(value, GetArenaForAllocation());
}
inline std::string* WorkflowTrigger::_internal_mutable_trigger_type() {
  
  return _impl_.trigger_type_.Mutable(GetArenaForAllocation());
}
inline std::string* WorkflowTrigger::release_trigger_type() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.WorkflowTrigger.trigger_type)
  return _impl_.trigger_type_.Release();
}
inline void WorkflowTrigger::set_allocated_trigger_type(std::string* trigger_type) {
  if (trigger_type != nullptr) {
    
  } else {
    
  }
  _impl_.trigger_type_.SetAllocated(trigger_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.trigger_type_.IsDefault()) {
    _impl_.trigger_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.WorkflowTrigger.trigger_type)
}

// string trigger_source = 2;
inline void WorkflowTrigger::clear_trigger_source() {
  _impl_.trigger_source_.ClearToEmpty();
}
inline const std::string& WorkflowTrigger::trigger_source() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.WorkflowTrigger.trigger_source)
  return _internal_trigger_source();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WorkflowTrigger::set_trigger_source(ArgT0&& arg0, ArgT... args) {
 
 _impl_.trigger_source_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.WorkflowTrigger.trigger_source)
}
inline std::string* WorkflowTrigger::mutable_trigger_source() {
  std::string* _s = _internal_mutable_trigger_source();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.WorkflowTrigger.trigger_source)
  return _s;
}
inline const std::string& WorkflowTrigger::_internal_trigger_source() const {
  return _impl_.trigger_source_.Get();
}
inline void WorkflowTrigger::_internal_set_trigger_source(const std::string& value) {
  
  _impl_.trigger_source_.Set(value, GetArenaForAllocation());
}
inline std::string* WorkflowTrigger::_internal_mutable_trigger_source() {
  
  return _impl_.trigger_source_.Mutable(GetArenaForAllocation());
}
inline std::string* WorkflowTrigger::release_trigger_source() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.WorkflowTrigger.trigger_source)
  return _impl_.trigger_source_.Release();
}
inline void WorkflowTrigger::set_allocated_trigger_source(std::string* trigger_source) {
  if (trigger_source != nullptr) {
    
  } else {
    
  }
  _impl_.trigger_source_.SetAllocated(trigger_source, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.trigger_source_.IsDefault()) {
    _impl_.trigger_source_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.WorkflowTrigger.trigger_source)
}

// .google.protobuf.Struct trigger_data = 3;
inline bool WorkflowTrigger::_internal_has_trigger_data() const {
  return this != internal_default_instance() && _impl_.trigger_data_ != nullptr;
}
inline bool WorkflowTrigger::has_trigger_data() const {
  return _internal_has_trigger_data();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& WorkflowTrigger::_internal_trigger_data() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.trigger_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& WorkflowTrigger::trigger_data() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.WorkflowTrigger.trigger_data)
  return _internal_trigger_data();
}
inline void WorkflowTrigger::unsafe_arena_set_allocated_trigger_data(
    ::PROTOBUF_NAMESPACE_ID::Struct* trigger_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.trigger_data_);
  }
  _impl_.trigger_data_ = trigger_data;
  if (trigger_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.WorkflowTrigger.trigger_data)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* WorkflowTrigger::release_trigger_data() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.trigger_data_;
  _impl_.trigger_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* WorkflowTrigger::unsafe_arena_release_trigger_data() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.WorkflowTrigger.trigger_data)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.trigger_data_;
  _impl_.trigger_data_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* WorkflowTrigger::_internal_mutable_trigger_data() {
  
  if (_impl_.trigger_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.trigger_data_ = p;
  }
  return _impl_.trigger_data_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* WorkflowTrigger::mutable_trigger_data() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_trigger_data();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.WorkflowTrigger.trigger_data)
  return _msg;
}
inline void WorkflowTrigger::set_allocated_trigger_data(::PROTOBUF_NAMESPACE_ID::Struct* trigger_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.trigger_data_);
  }
  if (trigger_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(trigger_data));
    if (message_arena != submessage_arena) {
      trigger_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trigger_data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.trigger_data_ = trigger_data;
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.WorkflowTrigger.trigger_data)
}

// .google.protobuf.Struct initial_context = 4;
inline bool WorkflowTrigger::_internal_has_initial_context() const {
  return this != internal_default_instance() && _impl_.initial_context_ != nullptr;
}
inline bool WorkflowTrigger::has_initial_context() const {
  return _internal_has_initial_context();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& WorkflowTrigger::_internal_initial_context() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.initial_context_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& WorkflowTrigger::initial_context() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.WorkflowTrigger.initial_context)
  return _internal_initial_context();
}
inline void WorkflowTrigger::unsafe_arena_set_allocated_initial_context(
    ::PROTOBUF_NAMESPACE_ID::Struct* initial_context) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.initial_context_);
  }
  _impl_.initial_context_ = initial_context;
  if (initial_context) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.WorkflowTrigger.initial_context)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* WorkflowTrigger::release_initial_context() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.initial_context_;
  _impl_.initial_context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* WorkflowTrigger::unsafe_arena_release_initial_context() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.WorkflowTrigger.initial_context)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.initial_context_;
  _impl_.initial_context_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* WorkflowTrigger::_internal_mutable_initial_context() {
  
  if (_impl_.initial_context_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.initial_context_ = p;
  }
  return _impl_.initial_context_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* WorkflowTrigger::mutable_initial_context() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_initial_context();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.WorkflowTrigger.initial_context)
  return _msg;
}
inline void WorkflowTrigger::set_allocated_initial_context(::PROTOBUF_NAMESPACE_ID::Struct* initial_context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.initial_context_);
  }
  if (initial_context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(initial_context));
    if (message_arena != submessage_arena) {
      initial_context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, initial_context, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.initial_context_ = initial_context;
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.WorkflowTrigger.initial_context)
}

// -------------------------------------------------------------------

// WorkflowStepExecution

// string step_id = 1;
inline void WorkflowStepExecution::clear_step_id() {
  _impl_.step_id_.ClearToEmpty();
}
inline const std::string& WorkflowStepExecution::step_id() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.WorkflowStepExecution.step_id)
  return _internal_step_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WorkflowStepExecution::set_step_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.step_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.WorkflowStepExecution.step_id)
}
inline std::string* WorkflowStepExecution::mutable_step_id() {
  std::string* _s = _internal_mutable_step_id();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.WorkflowStepExecution.step_id)
  return _s;
}
inline const std::string& WorkflowStepExecution::_internal_step_id() const {
  return _impl_.step_id_.Get();
}
inline void WorkflowStepExecution::_internal_set_step_id(const std::string& value) {
  
  _impl_.step_id_.Set(value, GetArenaForAllocation());
}
inline std::string* WorkflowStepExecution::_internal_mutable_step_id() {
  
  return _impl_.step_id_.Mutable(GetArenaForAllocation());
}
inline std::string* WorkflowStepExecution::release_step_id() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.WorkflowStepExecution.step_id)
  return _impl_.step_id_.Release();
}
inline void WorkflowStepExecution::set_allocated_step_id(std::string* step_id) {
  if (step_id != nullptr) {
    
  } else {
    
  }
  _impl_.step_id_.SetAllocated(step_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.step_id_.IsDefault()) {
    _impl_.step_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.WorkflowStepExecution.step_id)
}

// string step_type = 2;
inline void WorkflowStepExecution::clear_step_type() {
  _impl_.step_type_.ClearToEmpty();
}
inline const std::string& WorkflowStepExecution::step_type() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.WorkflowStepExecution.step_type)
  return _internal_step_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WorkflowStepExecution::set_step_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.step_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.WorkflowStepExecution.step_type)
}
inline std::string* WorkflowStepExecution::mutable_step_type() {
  std::string* _s = _internal_mutable_step_type();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.WorkflowStepExecution.step_type)
  return _s;
}
inline const std::string& WorkflowStepExecution::_internal_step_type() const {
  return _impl_.step_type_.Get();
}
inline void WorkflowStepExecution::_internal_set_step_type(const std::string& value) {
  
  _impl_.step_type_.Set(value, GetArenaForAllocation());
}
inline std::string* WorkflowStepExecution::_internal_mutable_step_type() {
  
  return _impl_.step_type_.Mutable(GetArenaForAllocation());
}
inline std::string* WorkflowStepExecution::release_step_type() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.WorkflowStepExecution.step_type)
  return _impl_.step_type_.Release();
}
inline void WorkflowStepExecution::set_allocated_step_type(std::string* step_type) {
  if (step_type != nullptr) {
    
  } else {
    
  }
  _impl_.step_type_.SetAllocated(step_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.step_type_.IsDefault()) {
    _impl_.step_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.WorkflowStepExecution.step_type)
}

// string step_status = 3;
inline void WorkflowStepExecution::clear_step_status() {
  _impl_.step_status_.ClearToEmpty();
}
inline const std::string& WorkflowStepExecution::step_status() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.WorkflowStepExecution.step_status)
  return _internal_step_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WorkflowStepExecution::set_step_status(ArgT0&& arg0, ArgT... args) {
 
 _impl_.step_status_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.WorkflowStepExecution.step_status)
}
inline std::string* WorkflowStepExecution::mutable_step_status() {
  std::string* _s = _internal_mutable_step_status();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.WorkflowStepExecution.step_status)
  return _s;
}
inline const std::string& WorkflowStepExecution::_internal_step_status() const {
  return _impl_.step_status_.Get();
}
inline void WorkflowStepExecution::_internal_set_step_status(const std::string& value) {
  
  _impl_.step_status_.Set(value, GetArenaForAllocation());
}
inline std::string* WorkflowStepExecution::_internal_mutable_step_status() {
  
  return _impl_.step_status_.Mutable(GetArenaForAllocation());
}
inline std::string* WorkflowStepExecution::release_step_status() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.WorkflowStepExecution.step_status)
  return _impl_.step_status_.Release();
}
inline void WorkflowStepExecution::set_allocated_step_status(std::string* step_status) {
  if (step_status != nullptr) {
    
  } else {
    
  }
  _impl_.step_status_.SetAllocated(step_status, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.step_status_.IsDefault()) {
    _impl_.step_status_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.WorkflowStepExecution.step_status)
}

// .google.protobuf.Struct step_input = 4;
inline bool WorkflowStepExecution::_internal_has_step_input() const {
  return this != internal_default_instance() && _impl_.step_input_ != nullptr;
}
inline bool WorkflowStepExecution::has_step_input() const {
  return _internal_has_step_input();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& WorkflowStepExecution::_internal_step_input() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.step_input_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& WorkflowStepExecution::step_input() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.WorkflowStepExecution.step_input)
  return _internal_step_input();
}
inline void WorkflowStepExecution::unsafe_arena_set_allocated_step_input(
    ::PROTOBUF_NAMESPACE_ID::Struct* step_input) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.step_input_);
  }
  _impl_.step_input_ = step_input;
  if (step_input) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.WorkflowStepExecution.step_input)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* WorkflowStepExecution::release_step_input() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.step_input_;
  _impl_.step_input_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* WorkflowStepExecution::unsafe_arena_release_step_input() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.WorkflowStepExecution.step_input)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.step_input_;
  _impl_.step_input_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* WorkflowStepExecution::_internal_mutable_step_input() {
  
  if (_impl_.step_input_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.step_input_ = p;
  }
  return _impl_.step_input_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* WorkflowStepExecution::mutable_step_input() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_step_input();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.WorkflowStepExecution.step_input)
  return _msg;
}
inline void WorkflowStepExecution::set_allocated_step_input(::PROTOBUF_NAMESPACE_ID::Struct* step_input) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.step_input_);
  }
  if (step_input) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(step_input));
    if (message_arena != submessage_arena) {
      step_input = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, step_input, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.step_input_ = step_input;
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.WorkflowStepExecution.step_input)
}

// .google.protobuf.Struct step_output = 5;
inline bool WorkflowStepExecution::_internal_has_step_output() const {
  return this != internal_default_instance() && _impl_.step_output_ != nullptr;
}
inline bool WorkflowStepExecution::has_step_output() const {
  return _internal_has_step_output();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& WorkflowStepExecution::_internal_step_output() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.step_output_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& WorkflowStepExecution::step_output() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.WorkflowStepExecution.step_output)
  return _internal_step_output();
}
inline void WorkflowStepExecution::unsafe_arena_set_allocated_step_output(
    ::PROTOBUF_NAMESPACE_ID::Struct* step_output) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.step_output_);
  }
  _impl_.step_output_ = step_output;
  if (step_output) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.WorkflowStepExecution.step_output)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* WorkflowStepExecution::release_step_output() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.step_output_;
  _impl_.step_output_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* WorkflowStepExecution::unsafe_arena_release_step_output() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.WorkflowStepExecution.step_output)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.step_output_;
  _impl_.step_output_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* WorkflowStepExecution::_internal_mutable_step_output() {
  
  if (_impl_.step_output_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.step_output_ = p;
  }
  return _impl_.step_output_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* WorkflowStepExecution::mutable_step_output() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_step_output();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.WorkflowStepExecution.step_output)
  return _msg;
}
inline void WorkflowStepExecution::set_allocated_step_output(::PROTOBUF_NAMESPACE_ID::Struct* step_output) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.step_output_);
  }
  if (step_output) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(step_output));
    if (message_arena != submessage_arena) {
      step_output = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, step_output, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.step_output_ = step_output;
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.WorkflowStepExecution.step_output)
}

// string next_step_id = 6;
inline void WorkflowStepExecution::clear_next_step_id() {
  _impl_.next_step_id_.ClearToEmpty();
}
inline const std::string& WorkflowStepExecution::next_step_id() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.WorkflowStepExecution.next_step_id)
  return _internal_next_step_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WorkflowStepExecution::set_next_step_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.next_step_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.WorkflowStepExecution.next_step_id)
}
inline std::string* WorkflowStepExecution::mutable_next_step_id() {
  std::string* _s = _internal_mutable_next_step_id();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.WorkflowStepExecution.next_step_id)
  return _s;
}
inline const std::string& WorkflowStepExecution::_internal_next_step_id() const {
  return _impl_.next_step_id_.Get();
}
inline void WorkflowStepExecution::_internal_set_next_step_id(const std::string& value) {
  
  _impl_.next_step_id_.Set(value, GetArenaForAllocation());
}
inline std::string* WorkflowStepExecution::_internal_mutable_next_step_id() {
  
  return _impl_.next_step_id_.Mutable(GetArenaForAllocation());
}
inline std::string* WorkflowStepExecution::release_next_step_id() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.WorkflowStepExecution.next_step_id)
  return _impl_.next_step_id_.Release();
}
inline void WorkflowStepExecution::set_allocated_next_step_id(std::string* next_step_id) {
  if (next_step_id != nullptr) {
    
  } else {
    
  }
  _impl_.next_step_id_.SetAllocated(next_step_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.next_step_id_.IsDefault()) {
    _impl_.next_step_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.WorkflowStepExecution.next_step_id)
}

// -------------------------------------------------------------------

// WorkflowCompletion

// string completion_status = 1;
inline void WorkflowCompletion::clear_completion_status() {
  _impl_.completion_status_.ClearToEmpty();
}
inline const std::string& WorkflowCompletion::completion_status() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.WorkflowCompletion.completion_status)
  return _internal_completion_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WorkflowCompletion::set_completion_status(ArgT0&& arg0, ArgT... args) {
 
 _impl_.completion_status_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.WorkflowCompletion.completion_status)
}
inline std::string* WorkflowCompletion::mutable_completion_status() {
  std::string* _s = _internal_mutable_completion_status();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.WorkflowCompletion.completion_status)
  return _s;
}
inline const std::string& WorkflowCompletion::_internal_completion_status() const {
  return _impl_.completion_status_.Get();
}
inline void WorkflowCompletion::_internal_set_completion_status(const std::string& value) {
  
  _impl_.completion_status_.Set(value, GetArenaForAllocation());
}
inline std::string* WorkflowCompletion::_internal_mutable_completion_status() {
  
  return _impl_.completion_status_.Mutable(GetArenaForAllocation());
}
inline std::string* WorkflowCompletion::release_completion_status() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.WorkflowCompletion.completion_status)
  return _impl_.completion_status_.Release();
}
inline void WorkflowCompletion::set_allocated_completion_status(std::string* completion_status) {
  if (completion_status != nullptr) {
    
  } else {
    
  }
  _impl_.completion_status_.SetAllocated(completion_status, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.completion_status_.IsDefault()) {
    _impl_.completion_status_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.WorkflowCompletion.completion_status)
}

// .google.protobuf.Struct final_output = 2;
inline bool WorkflowCompletion::_internal_has_final_output() const {
  return this != internal_default_instance() && _impl_.final_output_ != nullptr;
}
inline bool WorkflowCompletion::has_final_output() const {
  return _internal_has_final_output();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& WorkflowCompletion::_internal_final_output() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.final_output_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& WorkflowCompletion::final_output() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.WorkflowCompletion.final_output)
  return _internal_final_output();
}
inline void WorkflowCompletion::unsafe_arena_set_allocated_final_output(
    ::PROTOBUF_NAMESPACE_ID::Struct* final_output) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.final_output_);
  }
  _impl_.final_output_ = final_output;
  if (final_output) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.WorkflowCompletion.final_output)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* WorkflowCompletion::release_final_output() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.final_output_;
  _impl_.final_output_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* WorkflowCompletion::unsafe_arena_release_final_output() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.WorkflowCompletion.final_output)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.final_output_;
  _impl_.final_output_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* WorkflowCompletion::_internal_mutable_final_output() {
  
  if (_impl_.final_output_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.final_output_ = p;
  }
  return _impl_.final_output_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* WorkflowCompletion::mutable_final_output() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_final_output();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.WorkflowCompletion.final_output)
  return _msg;
}
inline void WorkflowCompletion::set_allocated_final_output(::PROTOBUF_NAMESPACE_ID::Struct* final_output) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.final_output_);
  }
  if (final_output) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(final_output));
    if (message_arena != submessage_arena) {
      final_output = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, final_output, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.final_output_ = final_output;
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.WorkflowCompletion.final_output)
}

// string completion_message = 3;
inline void WorkflowCompletion::clear_completion_message() {
  _impl_.completion_message_.ClearToEmpty();
}
inline const std::string& WorkflowCompletion::completion_message() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.WorkflowCompletion.completion_message)
  return _internal_completion_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WorkflowCompletion::set_completion_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.completion_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.WorkflowCompletion.completion_message)
}
inline std::string* WorkflowCompletion::mutable_completion_message() {
  std::string* _s = _internal_mutable_completion_message();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.WorkflowCompletion.completion_message)
  return _s;
}
inline const std::string& WorkflowCompletion::_internal_completion_message() const {
  return _impl_.completion_message_.Get();
}
inline void WorkflowCompletion::_internal_set_completion_message(const std::string& value) {
  
  _impl_.completion_message_.Set(value, GetArenaForAllocation());
}
inline std::string* WorkflowCompletion::_internal_mutable_completion_message() {
  
  return _impl_.completion_message_.Mutable(GetArenaForAllocation());
}
inline std::string* WorkflowCompletion::release_completion_message() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.WorkflowCompletion.completion_message)
  return _impl_.completion_message_.Release();
}
inline void WorkflowCompletion::set_allocated_completion_message(std::string* completion_message) {
  if (completion_message != nullptr) {
    
  } else {
    
  }
  _impl_.completion_message_.SetAllocated(completion_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.completion_message_.IsDefault()) {
    _impl_.completion_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.WorkflowCompletion.completion_message)
}

// int32 total_steps_executed = 4;
inline void WorkflowCompletion::clear_total_steps_executed() {
  _impl_.total_steps_executed_ = 0;
}
inline int32_t WorkflowCompletion::_internal_total_steps_executed() const {
  return _impl_.total_steps_executed_;
}
inline int32_t WorkflowCompletion::total_steps_executed() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.WorkflowCompletion.total_steps_executed)
  return _internal_total_steps_executed();
}
inline void WorkflowCompletion::_internal_set_total_steps_executed(int32_t value) {
  
  _impl_.total_steps_executed_ = value;
}
inline void WorkflowCompletion::set_total_steps_executed(int32_t value) {
  _internal_set_total_steps_executed(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.WorkflowCompletion.total_steps_executed)
}

// -------------------------------------------------------------------

// WorkflowControl

// string control_action = 1;
inline void WorkflowControl::clear_control_action() {
  _impl_.control_action_.ClearToEmpty();
}
inline const std::string& WorkflowControl::control_action() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.WorkflowControl.control_action)
  return _internal_control_action();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WorkflowControl::set_control_action(ArgT0&& arg0, ArgT... args) {
 
 _impl_.control_action_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.WorkflowControl.control_action)
}
inline std::string* WorkflowControl::mutable_control_action() {
  std::string* _s = _internal_mutable_control_action();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.WorkflowControl.control_action)
  return _s;
}
inline const std::string& WorkflowControl::_internal_control_action() const {
  return _impl_.control_action_.Get();
}
inline void WorkflowControl::_internal_set_control_action(const std::string& value) {
  
  _impl_.control_action_.Set(value, GetArenaForAllocation());
}
inline std::string* WorkflowControl::_internal_mutable_control_action() {
  
  return _impl_.control_action_.Mutable(GetArenaForAllocation());
}
inline std::string* WorkflowControl::release_control_action() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.WorkflowControl.control_action)
  return _impl_.control_action_.Release();
}
inline void WorkflowControl::set_allocated_control_action(std::string* control_action) {
  if (control_action != nullptr) {
    
  } else {
    
  }
  _impl_.control_action_.SetAllocated(control_action, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.control_action_.IsDefault()) {
    _impl_.control_action_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.WorkflowControl.control_action)
}

// string control_reason = 2;
inline void WorkflowControl::clear_control_reason() {
  _impl_.control_reason_.ClearToEmpty();
}
inline const std::string& WorkflowControl::control_reason() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.WorkflowControl.control_reason)
  return _internal_control_reason();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WorkflowControl::set_control_reason(ArgT0&& arg0, ArgT... args) {
 
 _impl_.control_reason_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.WorkflowControl.control_reason)
}
inline std::string* WorkflowControl::mutable_control_reason() {
  std::string* _s = _internal_mutable_control_reason();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.WorkflowControl.control_reason)
  return _s;
}
inline const std::string& WorkflowControl::_internal_control_reason() const {
  return _impl_.control_reason_.Get();
}
inline void WorkflowControl::_internal_set_control_reason(const std::string& value) {
  
  _impl_.control_reason_.Set(value, GetArenaForAllocation());
}
inline std::string* WorkflowControl::_internal_mutable_control_reason() {
  
  return _impl_.control_reason_.Mutable(GetArenaForAllocation());
}
inline std::string* WorkflowControl::release_control_reason() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.WorkflowControl.control_reason)
  return _impl_.control_reason_.Release();
}
inline void WorkflowControl::set_allocated_control_reason(std::string* control_reason) {
  if (control_reason != nullptr) {
    
  } else {
    
  }
  _impl_.control_reason_.SetAllocated(control_reason, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.control_reason_.IsDefault()) {
    _impl_.control_reason_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.WorkflowControl.control_reason)
}

// .google.protobuf.Struct control_parameters = 3;
inline bool WorkflowControl::_internal_has_control_parameters() const {
  return this != internal_default_instance() && _impl_.control_parameters_ != nullptr;
}
inline bool WorkflowControl::has_control_parameters() const {
  return _internal_has_control_parameters();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& WorkflowControl::_internal_control_parameters() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.control_parameters_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& WorkflowControl::control_parameters() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.WorkflowControl.control_parameters)
  return _internal_control_parameters();
}
inline void WorkflowControl::unsafe_arena_set_allocated_control_parameters(
    ::PROTOBUF_NAMESPACE_ID::Struct* control_parameters) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.control_parameters_);
  }
  _impl_.control_parameters_ = control_parameters;
  if (control_parameters) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.WorkflowControl.control_parameters)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* WorkflowControl::release_control_parameters() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.control_parameters_;
  _impl_.control_parameters_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* WorkflowControl::unsafe_arena_release_control_parameters() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.WorkflowControl.control_parameters)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.control_parameters_;
  _impl_.control_parameters_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* WorkflowControl::_internal_mutable_control_parameters() {
  
  if (_impl_.control_parameters_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.control_parameters_ = p;
  }
  return _impl_.control_parameters_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* WorkflowControl::mutable_control_parameters() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_control_parameters();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.WorkflowControl.control_parameters)
  return _msg;
}
inline void WorkflowControl::set_allocated_control_parameters(::PROTOBUF_NAMESPACE_ID::Struct* control_parameters) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.control_parameters_);
  }
  if (control_parameters) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(control_parameters));
    if (message_arena != submessage_arena) {
      control_parameters = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, control_parameters, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.control_parameters_ = control_parameters;
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.WorkflowControl.control_parameters)
}

// -------------------------------------------------------------------

// UIMessage

// string component_id = 1;
inline void UIMessage::clear_component_id() {
  _impl_.component_id_.ClearToEmpty();
}
inline const std::string& UIMessage::component_id() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.UIMessage.component_id)
  return _internal_component_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UIMessage::set_component_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.component_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.UIMessage.component_id)
}
inline std::string* UIMessage::mutable_component_id() {
  std::string* _s = _internal_mutable_component_id();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.UIMessage.component_id)
  return _s;
}
inline const std::string& UIMessage::_internal_component_id() const {
  return _impl_.component_id_.Get();
}
inline void UIMessage::_internal_set_component_id(const std::string& value) {
  
  _impl_.component_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UIMessage::_internal_mutable_component_id() {
  
  return _impl_.component_id_.Mutable(GetArenaForAllocation());
}
inline std::string* UIMessage::release_component_id() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.UIMessage.component_id)
  return _impl_.component_id_.Release();
}
inline void UIMessage::set_allocated_component_id(std::string* component_id) {
  if (component_id != nullptr) {
    
  } else {
    
  }
  _impl_.component_id_.SetAllocated(component_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.component_id_.IsDefault()) {
    _impl_.component_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.UIMessage.component_id)
}

// .unhinged.messaging.UIMessageType message_type = 2;
inline void UIMessage::clear_message_type() {
  _impl_.message_type_ = 0;
}
inline ::unhinged::messaging::UIMessageType UIMessage::_internal_message_type() const {
  return static_cast< ::unhinged::messaging::UIMessageType >(_impl_.message_type_);
}
inline ::unhinged::messaging::UIMessageType UIMessage::message_type() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.UIMessage.message_type)
  return _internal_message_type();
}
inline void UIMessage::_internal_set_message_type(::unhinged::messaging::UIMessageType value) {
  
  _impl_.message_type_ = value;
}
inline void UIMessage::set_message_type(::unhinged::messaging::UIMessageType value) {
  _internal_set_message_type(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.UIMessage.message_type)
}

// .unhinged.messaging.UIUpdate update = 10;
inline bool UIMessage::_internal_has_update() const {
  return message_data_case() == kUpdate;
}
inline bool UIMessage::has_update() const {
  return _internal_has_update();
}
inline void UIMessage::set_has_update() {
  _impl_._oneof_case_[0] = kUpdate;
}
inline void UIMessage::clear_update() {
  if (_internal_has_update()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_data_.update_;
    }
    clear_has_message_data();
  }
}
inline ::unhinged::messaging::UIUpdate* UIMessage::release_update() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.UIMessage.update)
  if (_internal_has_update()) {
    clear_has_message_data();
    ::unhinged::messaging::UIUpdate* temp = _impl_.message_data_.update_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_data_.update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::messaging::UIUpdate& UIMessage::_internal_update() const {
  return _internal_has_update()
      ? *_impl_.message_data_.update_
      : reinterpret_cast< ::unhinged::messaging::UIUpdate&>(::unhinged::messaging::_UIUpdate_default_instance_);
}
inline const ::unhinged::messaging::UIUpdate& UIMessage::update() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.UIMessage.update)
  return _internal_update();
}
inline ::unhinged::messaging::UIUpdate* UIMessage::unsafe_arena_release_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.messaging.UIMessage.update)
  if (_internal_has_update()) {
    clear_has_message_data();
    ::unhinged::messaging::UIUpdate* temp = _impl_.message_data_.update_;
    _impl_.message_data_.update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UIMessage::unsafe_arena_set_allocated_update(::unhinged::messaging::UIUpdate* update) {
  clear_message_data();
  if (update) {
    set_has_update();
    _impl_.message_data_.update_ = update;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.UIMessage.update)
}
inline ::unhinged::messaging::UIUpdate* UIMessage::_internal_mutable_update() {
  if (!_internal_has_update()) {
    clear_message_data();
    set_has_update();
    _impl_.message_data_.update_ = CreateMaybeMessage< ::unhinged::messaging::UIUpdate >(GetArenaForAllocation());
  }
  return _impl_.message_data_.update_;
}
inline ::unhinged::messaging::UIUpdate* UIMessage::mutable_update() {
  ::unhinged::messaging::UIUpdate* _msg = _internal_mutable_update();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.UIMessage.update)
  return _msg;
}

// .unhinged.messaging.UINotification notification = 11;
inline bool UIMessage::_internal_has_notification() const {
  return message_data_case() == kNotification;
}
inline bool UIMessage::has_notification() const {
  return _internal_has_notification();
}
inline void UIMessage::set_has_notification() {
  _impl_._oneof_case_[0] = kNotification;
}
inline void UIMessage::clear_notification() {
  if (_internal_has_notification()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_data_.notification_;
    }
    clear_has_message_data();
  }
}
inline ::unhinged::messaging::UINotification* UIMessage::release_notification() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.UIMessage.notification)
  if (_internal_has_notification()) {
    clear_has_message_data();
    ::unhinged::messaging::UINotification* temp = _impl_.message_data_.notification_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_data_.notification_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::messaging::UINotification& UIMessage::_internal_notification() const {
  return _internal_has_notification()
      ? *_impl_.message_data_.notification_
      : reinterpret_cast< ::unhinged::messaging::UINotification&>(::unhinged::messaging::_UINotification_default_instance_);
}
inline const ::unhinged::messaging::UINotification& UIMessage::notification() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.UIMessage.notification)
  return _internal_notification();
}
inline ::unhinged::messaging::UINotification* UIMessage::unsafe_arena_release_notification() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.messaging.UIMessage.notification)
  if (_internal_has_notification()) {
    clear_has_message_data();
    ::unhinged::messaging::UINotification* temp = _impl_.message_data_.notification_;
    _impl_.message_data_.notification_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UIMessage::unsafe_arena_set_allocated_notification(::unhinged::messaging::UINotification* notification) {
  clear_message_data();
  if (notification) {
    set_has_notification();
    _impl_.message_data_.notification_ = notification;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.UIMessage.notification)
}
inline ::unhinged::messaging::UINotification* UIMessage::_internal_mutable_notification() {
  if (!_internal_has_notification()) {
    clear_message_data();
    set_has_notification();
    _impl_.message_data_.notification_ = CreateMaybeMessage< ::unhinged::messaging::UINotification >(GetArenaForAllocation());
  }
  return _impl_.message_data_.notification_;
}
inline ::unhinged::messaging::UINotification* UIMessage::mutable_notification() {
  ::unhinged::messaging::UINotification* _msg = _internal_mutable_notification();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.UIMessage.notification)
  return _msg;
}

// .unhinged.messaging.UICommand command = 12;
inline bool UIMessage::_internal_has_command() const {
  return message_data_case() == kCommand;
}
inline bool UIMessage::has_command() const {
  return _internal_has_command();
}
inline void UIMessage::set_has_command() {
  _impl_._oneof_case_[0] = kCommand;
}
inline void UIMessage::clear_command() {
  if (_internal_has_command()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_data_.command_;
    }
    clear_has_message_data();
  }
}
inline ::unhinged::messaging::UICommand* UIMessage::release_command() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.UIMessage.command)
  if (_internal_has_command()) {
    clear_has_message_data();
    ::unhinged::messaging::UICommand* temp = _impl_.message_data_.command_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_data_.command_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::messaging::UICommand& UIMessage::_internal_command() const {
  return _internal_has_command()
      ? *_impl_.message_data_.command_
      : reinterpret_cast< ::unhinged::messaging::UICommand&>(::unhinged::messaging::_UICommand_default_instance_);
}
inline const ::unhinged::messaging::UICommand& UIMessage::command() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.UIMessage.command)
  return _internal_command();
}
inline ::unhinged::messaging::UICommand* UIMessage::unsafe_arena_release_command() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.messaging.UIMessage.command)
  if (_internal_has_command()) {
    clear_has_message_data();
    ::unhinged::messaging::UICommand* temp = _impl_.message_data_.command_;
    _impl_.message_data_.command_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UIMessage::unsafe_arena_set_allocated_command(::unhinged::messaging::UICommand* command) {
  clear_message_data();
  if (command) {
    set_has_command();
    _impl_.message_data_.command_ = command;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.UIMessage.command)
}
inline ::unhinged::messaging::UICommand* UIMessage::_internal_mutable_command() {
  if (!_internal_has_command()) {
    clear_message_data();
    set_has_command();
    _impl_.message_data_.command_ = CreateMaybeMessage< ::unhinged::messaging::UICommand >(GetArenaForAllocation());
  }
  return _impl_.message_data_.command_;
}
inline ::unhinged::messaging::UICommand* UIMessage::mutable_command() {
  ::unhinged::messaging::UICommand* _msg = _internal_mutable_command();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.UIMessage.command)
  return _msg;
}

inline bool UIMessage::has_message_data() const {
  return message_data_case() != MESSAGE_DATA_NOT_SET;
}
inline void UIMessage::clear_has_message_data() {
  _impl_._oneof_case_[0] = MESSAGE_DATA_NOT_SET;
}
inline UIMessage::MessageDataCase UIMessage::message_data_case() const {
  return UIMessage::MessageDataCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// UIUpdate

// string update_type = 1;
inline void UIUpdate::clear_update_type() {
  _impl_.update_type_.ClearToEmpty();
}
inline const std::string& UIUpdate::update_type() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.UIUpdate.update_type)
  return _internal_update_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UIUpdate::set_update_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.update_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.UIUpdate.update_type)
}
inline std::string* UIUpdate::mutable_update_type() {
  std::string* _s = _internal_mutable_update_type();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.UIUpdate.update_type)
  return _s;
}
inline const std::string& UIUpdate::_internal_update_type() const {
  return _impl_.update_type_.Get();
}
inline void UIUpdate::_internal_set_update_type(const std::string& value) {
  
  _impl_.update_type_.Set(value, GetArenaForAllocation());
}
inline std::string* UIUpdate::_internal_mutable_update_type() {
  
  return _impl_.update_type_.Mutable(GetArenaForAllocation());
}
inline std::string* UIUpdate::release_update_type() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.UIUpdate.update_type)
  return _impl_.update_type_.Release();
}
inline void UIUpdate::set_allocated_update_type(std::string* update_type) {
  if (update_type != nullptr) {
    
  } else {
    
  }
  _impl_.update_type_.SetAllocated(update_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.update_type_.IsDefault()) {
    _impl_.update_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.UIUpdate.update_type)
}

// .google.protobuf.Struct update_data = 2;
inline bool UIUpdate::_internal_has_update_data() const {
  return this != internal_default_instance() && _impl_.update_data_ != nullptr;
}
inline bool UIUpdate::has_update_data() const {
  return _internal_has_update_data();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& UIUpdate::_internal_update_data() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.update_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& UIUpdate::update_data() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.UIUpdate.update_data)
  return _internal_update_data();
}
inline void UIUpdate::unsafe_arena_set_allocated_update_data(
    ::PROTOBUF_NAMESPACE_ID::Struct* update_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.update_data_);
  }
  _impl_.update_data_ = update_data;
  if (update_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.UIUpdate.update_data)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* UIUpdate::release_update_data() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.update_data_;
  _impl_.update_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* UIUpdate::unsafe_arena_release_update_data() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.UIUpdate.update_data)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.update_data_;
  _impl_.update_data_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* UIUpdate::_internal_mutable_update_data() {
  
  if (_impl_.update_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.update_data_ = p;
  }
  return _impl_.update_data_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* UIUpdate::mutable_update_data() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_update_data();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.UIUpdate.update_data)
  return _msg;
}
inline void UIUpdate::set_allocated_update_data(::PROTOBUF_NAMESPACE_ID::Struct* update_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.update_data_);
  }
  if (update_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(update_data));
    if (message_arena != submessage_arena) {
      update_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, update_data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.update_data_ = update_data;
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.UIUpdate.update_data)
}

// bool force_refresh = 3;
inline void UIUpdate::clear_force_refresh() {
  _impl_.force_refresh_ = false;
}
inline bool UIUpdate::_internal_force_refresh() const {
  return _impl_.force_refresh_;
}
inline bool UIUpdate::force_refresh() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.UIUpdate.force_refresh)
  return _internal_force_refresh();
}
inline void UIUpdate::_internal_set_force_refresh(bool value) {
  
  _impl_.force_refresh_ = value;
}
inline void UIUpdate::set_force_refresh(bool value) {
  _internal_set_force_refresh(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.UIUpdate.force_refresh)
}

// -------------------------------------------------------------------

// UINotification

// string notification_type = 1;
inline void UINotification::clear_notification_type() {
  _impl_.notification_type_.ClearToEmpty();
}
inline const std::string& UINotification::notification_type() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.UINotification.notification_type)
  return _internal_notification_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UINotification::set_notification_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.notification_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.UINotification.notification_type)
}
inline std::string* UINotification::mutable_notification_type() {
  std::string* _s = _internal_mutable_notification_type();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.UINotification.notification_type)
  return _s;
}
inline const std::string& UINotification::_internal_notification_type() const {
  return _impl_.notification_type_.Get();
}
inline void UINotification::_internal_set_notification_type(const std::string& value) {
  
  _impl_.notification_type_.Set(value, GetArenaForAllocation());
}
inline std::string* UINotification::_internal_mutable_notification_type() {
  
  return _impl_.notification_type_.Mutable(GetArenaForAllocation());
}
inline std::string* UINotification::release_notification_type() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.UINotification.notification_type)
  return _impl_.notification_type_.Release();
}
inline void UINotification::set_allocated_notification_type(std::string* notification_type) {
  if (notification_type != nullptr) {
    
  } else {
    
  }
  _impl_.notification_type_.SetAllocated(notification_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.notification_type_.IsDefault()) {
    _impl_.notification_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.UINotification.notification_type)
}

// string title = 2;
inline void UINotification::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& UINotification::title() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.UINotification.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UINotification::set_title(ArgT0&& arg0, ArgT... args) {
 
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.UINotification.title)
}
inline std::string* UINotification::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.UINotification.title)
  return _s;
}
inline const std::string& UINotification::_internal_title() const {
  return _impl_.title_.Get();
}
inline void UINotification::_internal_set_title(const std::string& value) {
  
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* UINotification::_internal_mutable_title() {
  
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* UINotification::release_title() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.UINotification.title)
  return _impl_.title_.Release();
}
inline void UINotification::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.UINotification.title)
}

// string message = 3;
inline void UINotification::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& UINotification::message() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.UINotification.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UINotification::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.UINotification.message)
}
inline std::string* UINotification::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.UINotification.message)
  return _s;
}
inline const std::string& UINotification::_internal_message() const {
  return _impl_.message_.Get();
}
inline void UINotification::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* UINotification::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* UINotification::release_message() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.UINotification.message)
  return _impl_.message_.Release();
}
inline void UINotification::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.UINotification.message)
}

// int32 duration_ms = 4;
inline void UINotification::clear_duration_ms() {
  _impl_.duration_ms_ = 0;
}
inline int32_t UINotification::_internal_duration_ms() const {
  return _impl_.duration_ms_;
}
inline int32_t UINotification::duration_ms() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.UINotification.duration_ms)
  return _internal_duration_ms();
}
inline void UINotification::_internal_set_duration_ms(int32_t value) {
  
  _impl_.duration_ms_ = value;
}
inline void UINotification::set_duration_ms(int32_t value) {
  _internal_set_duration_ms(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.UINotification.duration_ms)
}

// bool dismissible = 5;
inline void UINotification::clear_dismissible() {
  _impl_.dismissible_ = false;
}
inline bool UINotification::_internal_dismissible() const {
  return _impl_.dismissible_;
}
inline bool UINotification::dismissible() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.UINotification.dismissible)
  return _internal_dismissible();
}
inline void UINotification::_internal_set_dismissible(bool value) {
  
  _impl_.dismissible_ = value;
}
inline void UINotification::set_dismissible(bool value) {
  _internal_set_dismissible(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.UINotification.dismissible)
}

// -------------------------------------------------------------------

// UICommand

// string command = 1;
inline void UICommand::clear_command() {
  _impl_.command_.ClearToEmpty();
}
inline const std::string& UICommand::command() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.UICommand.command)
  return _internal_command();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UICommand::set_command(ArgT0&& arg0, ArgT... args) {
 
 _impl_.command_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.UICommand.command)
}
inline std::string* UICommand::mutable_command() {
  std::string* _s = _internal_mutable_command();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.UICommand.command)
  return _s;
}
inline const std::string& UICommand::_internal_command() const {
  return _impl_.command_.Get();
}
inline void UICommand::_internal_set_command(const std::string& value) {
  
  _impl_.command_.Set(value, GetArenaForAllocation());
}
inline std::string* UICommand::_internal_mutable_command() {
  
  return _impl_.command_.Mutable(GetArenaForAllocation());
}
inline std::string* UICommand::release_command() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.UICommand.command)
  return _impl_.command_.Release();
}
inline void UICommand::set_allocated_command(std::string* command) {
  if (command != nullptr) {
    
  } else {
    
  }
  _impl_.command_.SetAllocated(command, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.command_.IsDefault()) {
    _impl_.command_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.UICommand.command)
}

// .google.protobuf.Struct command_parameters = 2;
inline bool UICommand::_internal_has_command_parameters() const {
  return this != internal_default_instance() && _impl_.command_parameters_ != nullptr;
}
inline bool UICommand::has_command_parameters() const {
  return _internal_has_command_parameters();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& UICommand::_internal_command_parameters() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.command_parameters_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& UICommand::command_parameters() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.UICommand.command_parameters)
  return _internal_command_parameters();
}
inline void UICommand::unsafe_arena_set_allocated_command_parameters(
    ::PROTOBUF_NAMESPACE_ID::Struct* command_parameters) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.command_parameters_);
  }
  _impl_.command_parameters_ = command_parameters;
  if (command_parameters) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.UICommand.command_parameters)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* UICommand::release_command_parameters() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.command_parameters_;
  _impl_.command_parameters_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* UICommand::unsafe_arena_release_command_parameters() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.UICommand.command_parameters)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.command_parameters_;
  _impl_.command_parameters_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* UICommand::_internal_mutable_command_parameters() {
  
  if (_impl_.command_parameters_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.command_parameters_ = p;
  }
  return _impl_.command_parameters_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* UICommand::mutable_command_parameters() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_command_parameters();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.UICommand.command_parameters)
  return _msg;
}
inline void UICommand::set_allocated_command_parameters(::PROTOBUF_NAMESPACE_ID::Struct* command_parameters) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.command_parameters_);
  }
  if (command_parameters) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(command_parameters));
    if (message_arena != submessage_arena) {
      command_parameters = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, command_parameters, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.command_parameters_ = command_parameters;
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.UICommand.command_parameters)
}

// -------------------------------------------------------------------

// SystemMessage

// .unhinged.messaging.SystemMessageType message_type = 1;
inline void SystemMessage::clear_message_type() {
  _impl_.message_type_ = 0;
}
inline ::unhinged::messaging::SystemMessageType SystemMessage::_internal_message_type() const {
  return static_cast< ::unhinged::messaging::SystemMessageType >(_impl_.message_type_);
}
inline ::unhinged::messaging::SystemMessageType SystemMessage::message_type() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.SystemMessage.message_type)
  return _internal_message_type();
}
inline void SystemMessage::_internal_set_message_type(::unhinged::messaging::SystemMessageType value) {
  
  _impl_.message_type_ = value;
}
inline void SystemMessage::set_message_type(::unhinged::messaging::SystemMessageType value) {
  _internal_set_message_type(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.SystemMessage.message_type)
}

// .unhinged.messaging.ServiceDiscovery service_discovery = 10;
inline bool SystemMessage::_internal_has_service_discovery() const {
  return message_data_case() == kServiceDiscovery;
}
inline bool SystemMessage::has_service_discovery() const {
  return _internal_has_service_discovery();
}
inline void SystemMessage::set_has_service_discovery() {
  _impl_._oneof_case_[0] = kServiceDiscovery;
}
inline void SystemMessage::clear_service_discovery() {
  if (_internal_has_service_discovery()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_data_.service_discovery_;
    }
    clear_has_message_data();
  }
}
inline ::unhinged::messaging::ServiceDiscovery* SystemMessage::release_service_discovery() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.SystemMessage.service_discovery)
  if (_internal_has_service_discovery()) {
    clear_has_message_data();
    ::unhinged::messaging::ServiceDiscovery* temp = _impl_.message_data_.service_discovery_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_data_.service_discovery_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::messaging::ServiceDiscovery& SystemMessage::_internal_service_discovery() const {
  return _internal_has_service_discovery()
      ? *_impl_.message_data_.service_discovery_
      : reinterpret_cast< ::unhinged::messaging::ServiceDiscovery&>(::unhinged::messaging::_ServiceDiscovery_default_instance_);
}
inline const ::unhinged::messaging::ServiceDiscovery& SystemMessage::service_discovery() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.SystemMessage.service_discovery)
  return _internal_service_discovery();
}
inline ::unhinged::messaging::ServiceDiscovery* SystemMessage::unsafe_arena_release_service_discovery() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.messaging.SystemMessage.service_discovery)
  if (_internal_has_service_discovery()) {
    clear_has_message_data();
    ::unhinged::messaging::ServiceDiscovery* temp = _impl_.message_data_.service_discovery_;
    _impl_.message_data_.service_discovery_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SystemMessage::unsafe_arena_set_allocated_service_discovery(::unhinged::messaging::ServiceDiscovery* service_discovery) {
  clear_message_data();
  if (service_discovery) {
    set_has_service_discovery();
    _impl_.message_data_.service_discovery_ = service_discovery;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.SystemMessage.service_discovery)
}
inline ::unhinged::messaging::ServiceDiscovery* SystemMessage::_internal_mutable_service_discovery() {
  if (!_internal_has_service_discovery()) {
    clear_message_data();
    set_has_service_discovery();
    _impl_.message_data_.service_discovery_ = CreateMaybeMessage< ::unhinged::messaging::ServiceDiscovery >(GetArenaForAllocation());
  }
  return _impl_.message_data_.service_discovery_;
}
inline ::unhinged::messaging::ServiceDiscovery* SystemMessage::mutable_service_discovery() {
  ::unhinged::messaging::ServiceDiscovery* _msg = _internal_mutable_service_discovery();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.SystemMessage.service_discovery)
  return _msg;
}

// .unhinged.messaging.HealthCheck health_check = 11;
inline bool SystemMessage::_internal_has_health_check() const {
  return message_data_case() == kHealthCheck;
}
inline bool SystemMessage::has_health_check() const {
  return _internal_has_health_check();
}
inline void SystemMessage::set_has_health_check() {
  _impl_._oneof_case_[0] = kHealthCheck;
}
inline void SystemMessage::clear_health_check() {
  if (_internal_has_health_check()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_data_.health_check_;
    }
    clear_has_message_data();
  }
}
inline ::unhinged::messaging::HealthCheck* SystemMessage::release_health_check() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.SystemMessage.health_check)
  if (_internal_has_health_check()) {
    clear_has_message_data();
    ::unhinged::messaging::HealthCheck* temp = _impl_.message_data_.health_check_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_data_.health_check_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::messaging::HealthCheck& SystemMessage::_internal_health_check() const {
  return _internal_has_health_check()
      ? *_impl_.message_data_.health_check_
      : reinterpret_cast< ::unhinged::messaging::HealthCheck&>(::unhinged::messaging::_HealthCheck_default_instance_);
}
inline const ::unhinged::messaging::HealthCheck& SystemMessage::health_check() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.SystemMessage.health_check)
  return _internal_health_check();
}
inline ::unhinged::messaging::HealthCheck* SystemMessage::unsafe_arena_release_health_check() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.messaging.SystemMessage.health_check)
  if (_internal_has_health_check()) {
    clear_has_message_data();
    ::unhinged::messaging::HealthCheck* temp = _impl_.message_data_.health_check_;
    _impl_.message_data_.health_check_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SystemMessage::unsafe_arena_set_allocated_health_check(::unhinged::messaging::HealthCheck* health_check) {
  clear_message_data();
  if (health_check) {
    set_has_health_check();
    _impl_.message_data_.health_check_ = health_check;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.SystemMessage.health_check)
}
inline ::unhinged::messaging::HealthCheck* SystemMessage::_internal_mutable_health_check() {
  if (!_internal_has_health_check()) {
    clear_message_data();
    set_has_health_check();
    _impl_.message_data_.health_check_ = CreateMaybeMessage< ::unhinged::messaging::HealthCheck >(GetArenaForAllocation());
  }
  return _impl_.message_data_.health_check_;
}
inline ::unhinged::messaging::HealthCheck* SystemMessage::mutable_health_check() {
  ::unhinged::messaging::HealthCheck* _msg = _internal_mutable_health_check();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.SystemMessage.health_check)
  return _msg;
}

// .unhinged.messaging.ConfigUpdate config_update = 12;
inline bool SystemMessage::_internal_has_config_update() const {
  return message_data_case() == kConfigUpdate;
}
inline bool SystemMessage::has_config_update() const {
  return _internal_has_config_update();
}
inline void SystemMessage::set_has_config_update() {
  _impl_._oneof_case_[0] = kConfigUpdate;
}
inline void SystemMessage::clear_config_update() {
  if (_internal_has_config_update()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_data_.config_update_;
    }
    clear_has_message_data();
  }
}
inline ::unhinged::messaging::ConfigUpdate* SystemMessage::release_config_update() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.SystemMessage.config_update)
  if (_internal_has_config_update()) {
    clear_has_message_data();
    ::unhinged::messaging::ConfigUpdate* temp = _impl_.message_data_.config_update_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_data_.config_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::messaging::ConfigUpdate& SystemMessage::_internal_config_update() const {
  return _internal_has_config_update()
      ? *_impl_.message_data_.config_update_
      : reinterpret_cast< ::unhinged::messaging::ConfigUpdate&>(::unhinged::messaging::_ConfigUpdate_default_instance_);
}
inline const ::unhinged::messaging::ConfigUpdate& SystemMessage::config_update() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.SystemMessage.config_update)
  return _internal_config_update();
}
inline ::unhinged::messaging::ConfigUpdate* SystemMessage::unsafe_arena_release_config_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.messaging.SystemMessage.config_update)
  if (_internal_has_config_update()) {
    clear_has_message_data();
    ::unhinged::messaging::ConfigUpdate* temp = _impl_.message_data_.config_update_;
    _impl_.message_data_.config_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SystemMessage::unsafe_arena_set_allocated_config_update(::unhinged::messaging::ConfigUpdate* config_update) {
  clear_message_data();
  if (config_update) {
    set_has_config_update();
    _impl_.message_data_.config_update_ = config_update;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.SystemMessage.config_update)
}
inline ::unhinged::messaging::ConfigUpdate* SystemMessage::_internal_mutable_config_update() {
  if (!_internal_has_config_update()) {
    clear_message_data();
    set_has_config_update();
    _impl_.message_data_.config_update_ = CreateMaybeMessage< ::unhinged::messaging::ConfigUpdate >(GetArenaForAllocation());
  }
  return _impl_.message_data_.config_update_;
}
inline ::unhinged::messaging::ConfigUpdate* SystemMessage::mutable_config_update() {
  ::unhinged::messaging::ConfigUpdate* _msg = _internal_mutable_config_update();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.SystemMessage.config_update)
  return _msg;
}

// .unhinged.messaging.ShutdownNotice shutdown_notice = 13;
inline bool SystemMessage::_internal_has_shutdown_notice() const {
  return message_data_case() == kShutdownNotice;
}
inline bool SystemMessage::has_shutdown_notice() const {
  return _internal_has_shutdown_notice();
}
inline void SystemMessage::set_has_shutdown_notice() {
  _impl_._oneof_case_[0] = kShutdownNotice;
}
inline void SystemMessage::clear_shutdown_notice() {
  if (_internal_has_shutdown_notice()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_data_.shutdown_notice_;
    }
    clear_has_message_data();
  }
}
inline ::unhinged::messaging::ShutdownNotice* SystemMessage::release_shutdown_notice() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.SystemMessage.shutdown_notice)
  if (_internal_has_shutdown_notice()) {
    clear_has_message_data();
    ::unhinged::messaging::ShutdownNotice* temp = _impl_.message_data_.shutdown_notice_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_data_.shutdown_notice_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::messaging::ShutdownNotice& SystemMessage::_internal_shutdown_notice() const {
  return _internal_has_shutdown_notice()
      ? *_impl_.message_data_.shutdown_notice_
      : reinterpret_cast< ::unhinged::messaging::ShutdownNotice&>(::unhinged::messaging::_ShutdownNotice_default_instance_);
}
inline const ::unhinged::messaging::ShutdownNotice& SystemMessage::shutdown_notice() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.SystemMessage.shutdown_notice)
  return _internal_shutdown_notice();
}
inline ::unhinged::messaging::ShutdownNotice* SystemMessage::unsafe_arena_release_shutdown_notice() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.messaging.SystemMessage.shutdown_notice)
  if (_internal_has_shutdown_notice()) {
    clear_has_message_data();
    ::unhinged::messaging::ShutdownNotice* temp = _impl_.message_data_.shutdown_notice_;
    _impl_.message_data_.shutdown_notice_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SystemMessage::unsafe_arena_set_allocated_shutdown_notice(::unhinged::messaging::ShutdownNotice* shutdown_notice) {
  clear_message_data();
  if (shutdown_notice) {
    set_has_shutdown_notice();
    _impl_.message_data_.shutdown_notice_ = shutdown_notice;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.SystemMessage.shutdown_notice)
}
inline ::unhinged::messaging::ShutdownNotice* SystemMessage::_internal_mutable_shutdown_notice() {
  if (!_internal_has_shutdown_notice()) {
    clear_message_data();
    set_has_shutdown_notice();
    _impl_.message_data_.shutdown_notice_ = CreateMaybeMessage< ::unhinged::messaging::ShutdownNotice >(GetArenaForAllocation());
  }
  return _impl_.message_data_.shutdown_notice_;
}
inline ::unhinged::messaging::ShutdownNotice* SystemMessage::mutable_shutdown_notice() {
  ::unhinged::messaging::ShutdownNotice* _msg = _internal_mutable_shutdown_notice();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.SystemMessage.shutdown_notice)
  return _msg;
}

inline bool SystemMessage::has_message_data() const {
  return message_data_case() != MESSAGE_DATA_NOT_SET;
}
inline void SystemMessage::clear_has_message_data() {
  _impl_._oneof_case_[0] = MESSAGE_DATA_NOT_SET;
}
inline SystemMessage::MessageDataCase SystemMessage::message_data_case() const {
  return SystemMessage::MessageDataCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ServiceDiscovery

// string service_name = 1;
inline void ServiceDiscovery::clear_service_name() {
  _impl_.service_name_.ClearToEmpty();
}
inline const std::string& ServiceDiscovery::service_name() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.ServiceDiscovery.service_name)
  return _internal_service_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceDiscovery::set_service_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.ServiceDiscovery.service_name)
}
inline std::string* ServiceDiscovery::mutable_service_name() {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.ServiceDiscovery.service_name)
  return _s;
}
inline const std::string& ServiceDiscovery::_internal_service_name() const {
  return _impl_.service_name_.Get();
}
inline void ServiceDiscovery::_internal_set_service_name(const std::string& value) {
  
  _impl_.service_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceDiscovery::_internal_mutable_service_name() {
  
  return _impl_.service_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ServiceDiscovery::release_service_name() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.ServiceDiscovery.service_name)
  return _impl_.service_name_.Release();
}
inline void ServiceDiscovery::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  _impl_.service_name_.SetAllocated(service_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_name_.IsDefault()) {
    _impl_.service_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.ServiceDiscovery.service_name)
}

// string service_version = 2;
inline void ServiceDiscovery::clear_service_version() {
  _impl_.service_version_.ClearToEmpty();
}
inline const std::string& ServiceDiscovery::service_version() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.ServiceDiscovery.service_version)
  return _internal_service_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceDiscovery::set_service_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.ServiceDiscovery.service_version)
}
inline std::string* ServiceDiscovery::mutable_service_version() {
  std::string* _s = _internal_mutable_service_version();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.ServiceDiscovery.service_version)
  return _s;
}
inline const std::string& ServiceDiscovery::_internal_service_version() const {
  return _impl_.service_version_.Get();
}
inline void ServiceDiscovery::_internal_set_service_version(const std::string& value) {
  
  _impl_.service_version_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceDiscovery::_internal_mutable_service_version() {
  
  return _impl_.service_version_.Mutable(GetArenaForAllocation());
}
inline std::string* ServiceDiscovery::release_service_version() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.ServiceDiscovery.service_version)
  return _impl_.service_version_.Release();
}
inline void ServiceDiscovery::set_allocated_service_version(std::string* service_version) {
  if (service_version != nullptr) {
    
  } else {
    
  }
  _impl_.service_version_.SetAllocated(service_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_version_.IsDefault()) {
    _impl_.service_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.ServiceDiscovery.service_version)
}

// string endpoint_url = 3;
inline void ServiceDiscovery::clear_endpoint_url() {
  _impl_.endpoint_url_.ClearToEmpty();
}
inline const std::string& ServiceDiscovery::endpoint_url() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.ServiceDiscovery.endpoint_url)
  return _internal_endpoint_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceDiscovery::set_endpoint_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.endpoint_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.ServiceDiscovery.endpoint_url)
}
inline std::string* ServiceDiscovery::mutable_endpoint_url() {
  std::string* _s = _internal_mutable_endpoint_url();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.ServiceDiscovery.endpoint_url)
  return _s;
}
inline const std::string& ServiceDiscovery::_internal_endpoint_url() const {
  return _impl_.endpoint_url_.Get();
}
inline void ServiceDiscovery::_internal_set_endpoint_url(const std::string& value) {
  
  _impl_.endpoint_url_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceDiscovery::_internal_mutable_endpoint_url() {
  
  return _impl_.endpoint_url_.Mutable(GetArenaForAllocation());
}
inline std::string* ServiceDiscovery::release_endpoint_url() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.ServiceDiscovery.endpoint_url)
  return _impl_.endpoint_url_.Release();
}
inline void ServiceDiscovery::set_allocated_endpoint_url(std::string* endpoint_url) {
  if (endpoint_url != nullptr) {
    
  } else {
    
  }
  _impl_.endpoint_url_.SetAllocated(endpoint_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.endpoint_url_.IsDefault()) {
    _impl_.endpoint_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.ServiceDiscovery.endpoint_url)
}

// repeated string capabilities = 4;
inline int ServiceDiscovery::_internal_capabilities_size() const {
  return _impl_.capabilities_.size();
}
inline int ServiceDiscovery::capabilities_size() const {
  return _internal_capabilities_size();
}
inline void ServiceDiscovery::clear_capabilities() {
  _impl_.capabilities_.Clear();
}
inline std::string* ServiceDiscovery::add_capabilities() {
  std::string* _s = _internal_add_capabilities();
  // @@protoc_insertion_point(field_add_mutable:unhinged.messaging.ServiceDiscovery.capabilities)
  return _s;
}
inline const std::string& ServiceDiscovery::_internal_capabilities(int index) const {
  return _impl_.capabilities_.Get(index);
}
inline const std::string& ServiceDiscovery::capabilities(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.ServiceDiscovery.capabilities)
  return _internal_capabilities(index);
}
inline std::string* ServiceDiscovery::mutable_capabilities(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.ServiceDiscovery.capabilities)
  return _impl_.capabilities_.Mutable(index);
}
inline void ServiceDiscovery::set_capabilities(int index, const std::string& value) {
  _impl_.capabilities_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.ServiceDiscovery.capabilities)
}
inline void ServiceDiscovery::set_capabilities(int index, std::string&& value) {
  _impl_.capabilities_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.messaging.ServiceDiscovery.capabilities)
}
inline void ServiceDiscovery::set_capabilities(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.capabilities_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.messaging.ServiceDiscovery.capabilities)
}
inline void ServiceDiscovery::set_capabilities(int index, const char* value, size_t size) {
  _impl_.capabilities_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.messaging.ServiceDiscovery.capabilities)
}
inline std::string* ServiceDiscovery::_internal_add_capabilities() {
  return _impl_.capabilities_.Add();
}
inline void ServiceDiscovery::add_capabilities(const std::string& value) {
  _impl_.capabilities_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.messaging.ServiceDiscovery.capabilities)
}
inline void ServiceDiscovery::add_capabilities(std::string&& value) {
  _impl_.capabilities_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.messaging.ServiceDiscovery.capabilities)
}
inline void ServiceDiscovery::add_capabilities(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.capabilities_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.messaging.ServiceDiscovery.capabilities)
}
inline void ServiceDiscovery::add_capabilities(const char* value, size_t size) {
  _impl_.capabilities_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.messaging.ServiceDiscovery.capabilities)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ServiceDiscovery::capabilities() const {
  // @@protoc_insertion_point(field_list:unhinged.messaging.ServiceDiscovery.capabilities)
  return _impl_.capabilities_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ServiceDiscovery::mutable_capabilities() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.messaging.ServiceDiscovery.capabilities)
  return &_impl_.capabilities_;
}

// string status = 5;
inline void ServiceDiscovery::clear_status() {
  _impl_.status_.ClearToEmpty();
}
inline const std::string& ServiceDiscovery::status() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.ServiceDiscovery.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceDiscovery::set_status(ArgT0&& arg0, ArgT... args) {
 
 _impl_.status_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.ServiceDiscovery.status)
}
inline std::string* ServiceDiscovery::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.ServiceDiscovery.status)
  return _s;
}
inline const std::string& ServiceDiscovery::_internal_status() const {
  return _impl_.status_.Get();
}
inline void ServiceDiscovery::_internal_set_status(const std::string& value) {
  
  _impl_.status_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceDiscovery::_internal_mutable_status() {
  
  return _impl_.status_.Mutable(GetArenaForAllocation());
}
inline std::string* ServiceDiscovery::release_status() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.ServiceDiscovery.status)
  return _impl_.status_.Release();
}
inline void ServiceDiscovery::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  _impl_.status_.SetAllocated(status, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.ServiceDiscovery.status)
}

// -------------------------------------------------------------------

// HealthCheck

// string service_name = 1;
inline void HealthCheck::clear_service_name() {
  _impl_.service_name_.ClearToEmpty();
}
inline const std::string& HealthCheck::service_name() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.HealthCheck.service_name)
  return _internal_service_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HealthCheck::set_service_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.HealthCheck.service_name)
}
inline std::string* HealthCheck::mutable_service_name() {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.HealthCheck.service_name)
  return _s;
}
inline const std::string& HealthCheck::_internal_service_name() const {
  return _impl_.service_name_.Get();
}
inline void HealthCheck::_internal_set_service_name(const std::string& value) {
  
  _impl_.service_name_.Set(value, GetArenaForAllocation());
}
inline std::string* HealthCheck::_internal_mutable_service_name() {
  
  return _impl_.service_name_.Mutable(GetArenaForAllocation());
}
inline std::string* HealthCheck::release_service_name() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.HealthCheck.service_name)
  return _impl_.service_name_.Release();
}
inline void HealthCheck::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  _impl_.service_name_.SetAllocated(service_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_name_.IsDefault()) {
    _impl_.service_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.HealthCheck.service_name)
}

// bool is_healthy = 2;
inline void HealthCheck::clear_is_healthy() {
  _impl_.is_healthy_ = false;
}
inline bool HealthCheck::_internal_is_healthy() const {
  return _impl_.is_healthy_;
}
inline bool HealthCheck::is_healthy() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.HealthCheck.is_healthy)
  return _internal_is_healthy();
}
inline void HealthCheck::_internal_set_is_healthy(bool value) {
  
  _impl_.is_healthy_ = value;
}
inline void HealthCheck::set_is_healthy(bool value) {
  _internal_set_is_healthy(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.HealthCheck.is_healthy)
}

// string status_message = 3;
inline void HealthCheck::clear_status_message() {
  _impl_.status_message_.ClearToEmpty();
}
inline const std::string& HealthCheck::status_message() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.HealthCheck.status_message)
  return _internal_status_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HealthCheck::set_status_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.status_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.HealthCheck.status_message)
}
inline std::string* HealthCheck::mutable_status_message() {
  std::string* _s = _internal_mutable_status_message();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.HealthCheck.status_message)
  return _s;
}
inline const std::string& HealthCheck::_internal_status_message() const {
  return _impl_.status_message_.Get();
}
inline void HealthCheck::_internal_set_status_message(const std::string& value) {
  
  _impl_.status_message_.Set(value, GetArenaForAllocation());
}
inline std::string* HealthCheck::_internal_mutable_status_message() {
  
  return _impl_.status_message_.Mutable(GetArenaForAllocation());
}
inline std::string* HealthCheck::release_status_message() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.HealthCheck.status_message)
  return _impl_.status_message_.Release();
}
inline void HealthCheck::set_allocated_status_message(std::string* status_message) {
  if (status_message != nullptr) {
    
  } else {
    
  }
  _impl_.status_message_.SetAllocated(status_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_message_.IsDefault()) {
    _impl_.status_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.HealthCheck.status_message)
}

// .google.protobuf.Struct health_details = 4;
inline bool HealthCheck::_internal_has_health_details() const {
  return this != internal_default_instance() && _impl_.health_details_ != nullptr;
}
inline bool HealthCheck::has_health_details() const {
  return _internal_has_health_details();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& HealthCheck::_internal_health_details() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.health_details_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& HealthCheck::health_details() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.HealthCheck.health_details)
  return _internal_health_details();
}
inline void HealthCheck::unsafe_arena_set_allocated_health_details(
    ::PROTOBUF_NAMESPACE_ID::Struct* health_details) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.health_details_);
  }
  _impl_.health_details_ = health_details;
  if (health_details) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.HealthCheck.health_details)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* HealthCheck::release_health_details() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.health_details_;
  _impl_.health_details_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* HealthCheck::unsafe_arena_release_health_details() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.HealthCheck.health_details)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.health_details_;
  _impl_.health_details_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* HealthCheck::_internal_mutable_health_details() {
  
  if (_impl_.health_details_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.health_details_ = p;
  }
  return _impl_.health_details_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* HealthCheck::mutable_health_details() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_health_details();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.HealthCheck.health_details)
  return _msg;
}
inline void HealthCheck::set_allocated_health_details(::PROTOBUF_NAMESPACE_ID::Struct* health_details) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.health_details_);
  }
  if (health_details) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(health_details));
    if (message_arena != submessage_arena) {
      health_details = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, health_details, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.health_details_ = health_details;
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.HealthCheck.health_details)
}

// -------------------------------------------------------------------

// ConfigUpdate

// string config_key = 1;
inline void ConfigUpdate::clear_config_key() {
  _impl_.config_key_.ClearToEmpty();
}
inline const std::string& ConfigUpdate::config_key() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.ConfigUpdate.config_key)
  return _internal_config_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigUpdate::set_config_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.config_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.ConfigUpdate.config_key)
}
inline std::string* ConfigUpdate::mutable_config_key() {
  std::string* _s = _internal_mutable_config_key();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.ConfigUpdate.config_key)
  return _s;
}
inline const std::string& ConfigUpdate::_internal_config_key() const {
  return _impl_.config_key_.Get();
}
inline void ConfigUpdate::_internal_set_config_key(const std::string& value) {
  
  _impl_.config_key_.Set(value, GetArenaForAllocation());
}
inline std::string* ConfigUpdate::_internal_mutable_config_key() {
  
  return _impl_.config_key_.Mutable(GetArenaForAllocation());
}
inline std::string* ConfigUpdate::release_config_key() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.ConfigUpdate.config_key)
  return _impl_.config_key_.Release();
}
inline void ConfigUpdate::set_allocated_config_key(std::string* config_key) {
  if (config_key != nullptr) {
    
  } else {
    
  }
  _impl_.config_key_.SetAllocated(config_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.config_key_.IsDefault()) {
    _impl_.config_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.ConfigUpdate.config_key)
}

// .google.protobuf.Any config_value = 2;
inline bool ConfigUpdate::_internal_has_config_value() const {
  return this != internal_default_instance() && _impl_.config_value_ != nullptr;
}
inline bool ConfigUpdate::has_config_value() const {
  return _internal_has_config_value();
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& ConfigUpdate::_internal_config_value() const {
  const ::PROTOBUF_NAMESPACE_ID::Any* p = _impl_.config_value_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Any&>(
      ::PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& ConfigUpdate::config_value() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.ConfigUpdate.config_value)
  return _internal_config_value();
}
inline void ConfigUpdate::unsafe_arena_set_allocated_config_value(
    ::PROTOBUF_NAMESPACE_ID::Any* config_value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.config_value_);
  }
  _impl_.config_value_ = config_value;
  if (config_value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.ConfigUpdate.config_value)
}
inline ::PROTOBUF_NAMESPACE_ID::Any* ConfigUpdate::release_config_value() {
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.config_value_;
  _impl_.config_value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* ConfigUpdate::unsafe_arena_release_config_value() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.ConfigUpdate.config_value)
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.config_value_;
  _impl_.config_value_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* ConfigUpdate::_internal_mutable_config_value() {
  
  if (_impl_.config_value_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Any>(GetArenaForAllocation());
    _impl_.config_value_ = p;
  }
  return _impl_.config_value_;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* ConfigUpdate::mutable_config_value() {
  ::PROTOBUF_NAMESPACE_ID::Any* _msg = _internal_mutable_config_value();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.ConfigUpdate.config_value)
  return _msg;
}
inline void ConfigUpdate::set_allocated_config_value(::PROTOBUF_NAMESPACE_ID::Any* config_value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.config_value_);
  }
  if (config_value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(config_value));
    if (message_arena != submessage_arena) {
      config_value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config_value, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.config_value_ = config_value;
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.ConfigUpdate.config_value)
}

// string update_reason = 3;
inline void ConfigUpdate::clear_update_reason() {
  _impl_.update_reason_.ClearToEmpty();
}
inline const std::string& ConfigUpdate::update_reason() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.ConfigUpdate.update_reason)
  return _internal_update_reason();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigUpdate::set_update_reason(ArgT0&& arg0, ArgT... args) {
 
 _impl_.update_reason_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.ConfigUpdate.update_reason)
}
inline std::string* ConfigUpdate::mutable_update_reason() {
  std::string* _s = _internal_mutable_update_reason();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.ConfigUpdate.update_reason)
  return _s;
}
inline const std::string& ConfigUpdate::_internal_update_reason() const {
  return _impl_.update_reason_.Get();
}
inline void ConfigUpdate::_internal_set_update_reason(const std::string& value) {
  
  _impl_.update_reason_.Set(value, GetArenaForAllocation());
}
inline std::string* ConfigUpdate::_internal_mutable_update_reason() {
  
  return _impl_.update_reason_.Mutable(GetArenaForAllocation());
}
inline std::string* ConfigUpdate::release_update_reason() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.ConfigUpdate.update_reason)
  return _impl_.update_reason_.Release();
}
inline void ConfigUpdate::set_allocated_update_reason(std::string* update_reason) {
  if (update_reason != nullptr) {
    
  } else {
    
  }
  _impl_.update_reason_.SetAllocated(update_reason, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.update_reason_.IsDefault()) {
    _impl_.update_reason_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.ConfigUpdate.update_reason)
}

// -------------------------------------------------------------------

// ShutdownNotice

// string service_name = 1;
inline void ShutdownNotice::clear_service_name() {
  _impl_.service_name_.ClearToEmpty();
}
inline const std::string& ShutdownNotice::service_name() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.ShutdownNotice.service_name)
  return _internal_service_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShutdownNotice::set_service_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.ShutdownNotice.service_name)
}
inline std::string* ShutdownNotice::mutable_service_name() {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.ShutdownNotice.service_name)
  return _s;
}
inline const std::string& ShutdownNotice::_internal_service_name() const {
  return _impl_.service_name_.Get();
}
inline void ShutdownNotice::_internal_set_service_name(const std::string& value) {
  
  _impl_.service_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ShutdownNotice::_internal_mutable_service_name() {
  
  return _impl_.service_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ShutdownNotice::release_service_name() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.ShutdownNotice.service_name)
  return _impl_.service_name_.Release();
}
inline void ShutdownNotice::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  _impl_.service_name_.SetAllocated(service_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_name_.IsDefault()) {
    _impl_.service_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.ShutdownNotice.service_name)
}

// string shutdown_reason = 2;
inline void ShutdownNotice::clear_shutdown_reason() {
  _impl_.shutdown_reason_.ClearToEmpty();
}
inline const std::string& ShutdownNotice::shutdown_reason() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.ShutdownNotice.shutdown_reason)
  return _internal_shutdown_reason();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShutdownNotice::set_shutdown_reason(ArgT0&& arg0, ArgT... args) {
 
 _impl_.shutdown_reason_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.ShutdownNotice.shutdown_reason)
}
inline std::string* ShutdownNotice::mutable_shutdown_reason() {
  std::string* _s = _internal_mutable_shutdown_reason();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.ShutdownNotice.shutdown_reason)
  return _s;
}
inline const std::string& ShutdownNotice::_internal_shutdown_reason() const {
  return _impl_.shutdown_reason_.Get();
}
inline void ShutdownNotice::_internal_set_shutdown_reason(const std::string& value) {
  
  _impl_.shutdown_reason_.Set(value, GetArenaForAllocation());
}
inline std::string* ShutdownNotice::_internal_mutable_shutdown_reason() {
  
  return _impl_.shutdown_reason_.Mutable(GetArenaForAllocation());
}
inline std::string* ShutdownNotice::release_shutdown_reason() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.ShutdownNotice.shutdown_reason)
  return _impl_.shutdown_reason_.Release();
}
inline void ShutdownNotice::set_allocated_shutdown_reason(std::string* shutdown_reason) {
  if (shutdown_reason != nullptr) {
    
  } else {
    
  }
  _impl_.shutdown_reason_.SetAllocated(shutdown_reason, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.shutdown_reason_.IsDefault()) {
    _impl_.shutdown_reason_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.ShutdownNotice.shutdown_reason)
}

// int32 graceful_shutdown_seconds = 3;
inline void ShutdownNotice::clear_graceful_shutdown_seconds() {
  _impl_.graceful_shutdown_seconds_ = 0;
}
inline int32_t ShutdownNotice::_internal_graceful_shutdown_seconds() const {
  return _impl_.graceful_shutdown_seconds_;
}
inline int32_t ShutdownNotice::graceful_shutdown_seconds() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.ShutdownNotice.graceful_shutdown_seconds)
  return _internal_graceful_shutdown_seconds();
}
inline void ShutdownNotice::_internal_set_graceful_shutdown_seconds(int32_t value) {
  
  _impl_.graceful_shutdown_seconds_ = value;
}
inline void ShutdownNotice::set_graceful_shutdown_seconds(int32_t value) {
  _internal_set_graceful_shutdown_seconds(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.ShutdownNotice.graceful_shutdown_seconds)
}

// -------------------------------------------------------------------

// SendMessageRequest

// .unhinged.messaging.Message message = 1;
inline bool SendMessageRequest::_internal_has_message() const {
  return this != internal_default_instance() && _impl_.message_ != nullptr;
}
inline bool SendMessageRequest::has_message() const {
  return _internal_has_message();
}
inline void SendMessageRequest::clear_message() {
  if (GetArenaForAllocation() == nullptr && _impl_.message_ != nullptr) {
    delete _impl_.message_;
  }
  _impl_.message_ = nullptr;
}
inline const ::unhinged::messaging::Message& SendMessageRequest::_internal_message() const {
  const ::unhinged::messaging::Message* p = _impl_.message_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::messaging::Message&>(
      ::unhinged::messaging::_Message_default_instance_);
}
inline const ::unhinged::messaging::Message& SendMessageRequest::message() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.SendMessageRequest.message)
  return _internal_message();
}
inline void SendMessageRequest::unsafe_arena_set_allocated_message(
    ::unhinged::messaging::Message* message) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.message_);
  }
  _impl_.message_ = message;
  if (message) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.SendMessageRequest.message)
}
inline ::unhinged::messaging::Message* SendMessageRequest::release_message() {
  
  ::unhinged::messaging::Message* temp = _impl_.message_;
  _impl_.message_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::messaging::Message* SendMessageRequest::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.SendMessageRequest.message)
  
  ::unhinged::messaging::Message* temp = _impl_.message_;
  _impl_.message_ = nullptr;
  return temp;
}
inline ::unhinged::messaging::Message* SendMessageRequest::_internal_mutable_message() {
  
  if (_impl_.message_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::messaging::Message>(GetArenaForAllocation());
    _impl_.message_ = p;
  }
  return _impl_.message_;
}
inline ::unhinged::messaging::Message* SendMessageRequest::mutable_message() {
  ::unhinged::messaging::Message* _msg = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.SendMessageRequest.message)
  return _msg;
}
inline void SendMessageRequest::set_allocated_message(::unhinged::messaging::Message* message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.message_;
  }
  if (message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(message);
    if (message_arena != submessage_arena) {
      message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, message, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.message_ = message;
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.SendMessageRequest.message)
}

// -------------------------------------------------------------------

// SendMessageResponse

// bool success = 1;
inline void SendMessageResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool SendMessageResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool SendMessageResponse::success() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.SendMessageResponse.success)
  return _internal_success();
}
inline void SendMessageResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void SendMessageResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.SendMessageResponse.success)
}

// string message_id = 2;
inline void SendMessageResponse::clear_message_id() {
  _impl_.message_id_.ClearToEmpty();
}
inline const std::string& SendMessageResponse::message_id() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.SendMessageResponse.message_id)
  return _internal_message_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendMessageResponse::set_message_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.SendMessageResponse.message_id)
}
inline std::string* SendMessageResponse::mutable_message_id() {
  std::string* _s = _internal_mutable_message_id();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.SendMessageResponse.message_id)
  return _s;
}
inline const std::string& SendMessageResponse::_internal_message_id() const {
  return _impl_.message_id_.Get();
}
inline void SendMessageResponse::_internal_set_message_id(const std::string& value) {
  
  _impl_.message_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SendMessageResponse::_internal_mutable_message_id() {
  
  return _impl_.message_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SendMessageResponse::release_message_id() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.SendMessageResponse.message_id)
  return _impl_.message_id_.Release();
}
inline void SendMessageResponse::set_allocated_message_id(std::string* message_id) {
  if (message_id != nullptr) {
    
  } else {
    
  }
  _impl_.message_id_.SetAllocated(message_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_id_.IsDefault()) {
    _impl_.message_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.SendMessageResponse.message_id)
}

// string status = 3;
inline void SendMessageResponse::clear_status() {
  _impl_.status_.ClearToEmpty();
}
inline const std::string& SendMessageResponse::status() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.SendMessageResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendMessageResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 _impl_.status_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.SendMessageResponse.status)
}
inline std::string* SendMessageResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.SendMessageResponse.status)
  return _s;
}
inline const std::string& SendMessageResponse::_internal_status() const {
  return _impl_.status_.Get();
}
inline void SendMessageResponse::_internal_set_status(const std::string& value) {
  
  _impl_.status_.Set(value, GetArenaForAllocation());
}
inline std::string* SendMessageResponse::_internal_mutable_status() {
  
  return _impl_.status_.Mutable(GetArenaForAllocation());
}
inline std::string* SendMessageResponse::release_status() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.SendMessageResponse.status)
  return _impl_.status_.Release();
}
inline void SendMessageResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  _impl_.status_.SetAllocated(status, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.SendMessageResponse.status)
}

// string error_message = 4;
inline void SendMessageResponse::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& SendMessageResponse::error_message() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.SendMessageResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendMessageResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.SendMessageResponse.error_message)
}
inline std::string* SendMessageResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.SendMessageResponse.error_message)
  return _s;
}
inline const std::string& SendMessageResponse::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void SendMessageResponse::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* SendMessageResponse::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* SendMessageResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.SendMessageResponse.error_message)
  return _impl_.error_message_.Release();
}
inline void SendMessageResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.SendMessageResponse.error_message)
}

// -------------------------------------------------------------------

// SendMessagesRequest

// repeated .unhinged.messaging.Message messages = 1;
inline int SendMessagesRequest::_internal_messages_size() const {
  return _impl_.messages_.size();
}
inline int SendMessagesRequest::messages_size() const {
  return _internal_messages_size();
}
inline void SendMessagesRequest::clear_messages() {
  _impl_.messages_.Clear();
}
inline ::unhinged::messaging::Message* SendMessagesRequest::mutable_messages(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.SendMessagesRequest.messages)
  return _impl_.messages_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::messaging::Message >*
SendMessagesRequest::mutable_messages() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.messaging.SendMessagesRequest.messages)
  return &_impl_.messages_;
}
inline const ::unhinged::messaging::Message& SendMessagesRequest::_internal_messages(int index) const {
  return _impl_.messages_.Get(index);
}
inline const ::unhinged::messaging::Message& SendMessagesRequest::messages(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.SendMessagesRequest.messages)
  return _internal_messages(index);
}
inline ::unhinged::messaging::Message* SendMessagesRequest::_internal_add_messages() {
  return _impl_.messages_.Add();
}
inline ::unhinged::messaging::Message* SendMessagesRequest::add_messages() {
  ::unhinged::messaging::Message* _add = _internal_add_messages();
  // @@protoc_insertion_point(field_add:unhinged.messaging.SendMessagesRequest.messages)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::messaging::Message >&
SendMessagesRequest::messages() const {
  // @@protoc_insertion_point(field_list:unhinged.messaging.SendMessagesRequest.messages)
  return _impl_.messages_;
}

// bool atomic = 2;
inline void SendMessagesRequest::clear_atomic() {
  _impl_.atomic_ = false;
}
inline bool SendMessagesRequest::_internal_atomic() const {
  return _impl_.atomic_;
}
inline bool SendMessagesRequest::atomic() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.SendMessagesRequest.atomic)
  return _internal_atomic();
}
inline void SendMessagesRequest::_internal_set_atomic(bool value) {
  
  _impl_.atomic_ = value;
}
inline void SendMessagesRequest::set_atomic(bool value) {
  _internal_set_atomic(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.SendMessagesRequest.atomic)
}

// -------------------------------------------------------------------

// SendMessageResult

// string message_id = 1;
inline void SendMessageResult::clear_message_id() {
  _impl_.message_id_.ClearToEmpty();
}
inline const std::string& SendMessageResult::message_id() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.SendMessageResult.message_id)
  return _internal_message_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendMessageResult::set_message_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.SendMessageResult.message_id)
}
inline std::string* SendMessageResult::mutable_message_id() {
  std::string* _s = _internal_mutable_message_id();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.SendMessageResult.message_id)
  return _s;
}
inline const std::string& SendMessageResult::_internal_message_id() const {
  return _impl_.message_id_.Get();
}
inline void SendMessageResult::_internal_set_message_id(const std::string& value) {
  
  _impl_.message_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SendMessageResult::_internal_mutable_message_id() {
  
  return _impl_.message_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SendMessageResult::release_message_id() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.SendMessageResult.message_id)
  return _impl_.message_id_.Release();
}
inline void SendMessageResult::set_allocated_message_id(std::string* message_id) {
  if (message_id != nullptr) {
    
  } else {
    
  }
  _impl_.message_id_.SetAllocated(message_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_id_.IsDefault()) {
    _impl_.message_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.SendMessageResult.message_id)
}

// bool success = 2;
inline void SendMessageResult::clear_success() {
  _impl_.success_ = false;
}
inline bool SendMessageResult::_internal_success() const {
  return _impl_.success_;
}
inline bool SendMessageResult::success() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.SendMessageResult.success)
  return _internal_success();
}
inline void SendMessageResult::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void SendMessageResult::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.SendMessageResult.success)
}

// string error_message = 3;
inline void SendMessageResult::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& SendMessageResult::error_message() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.SendMessageResult.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendMessageResult::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.SendMessageResult.error_message)
}
inline std::string* SendMessageResult::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.SendMessageResult.error_message)
  return _s;
}
inline const std::string& SendMessageResult::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void SendMessageResult::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* SendMessageResult::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* SendMessageResult::release_error_message() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.SendMessageResult.error_message)
  return _impl_.error_message_.Release();
}
inline void SendMessageResult::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.SendMessageResult.error_message)
}

// -------------------------------------------------------------------

// SendMessagesResponse

// bool success = 1;
inline void SendMessagesResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool SendMessagesResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool SendMessagesResponse::success() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.SendMessagesResponse.success)
  return _internal_success();
}
inline void SendMessagesResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void SendMessagesResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.SendMessagesResponse.success)
}

// repeated .unhinged.messaging.SendMessageResult results = 2;
inline int SendMessagesResponse::_internal_results_size() const {
  return _impl_.results_.size();
}
inline int SendMessagesResponse::results_size() const {
  return _internal_results_size();
}
inline void SendMessagesResponse::clear_results() {
  _impl_.results_.Clear();
}
inline ::unhinged::messaging::SendMessageResult* SendMessagesResponse::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.SendMessagesResponse.results)
  return _impl_.results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::messaging::SendMessageResult >*
SendMessagesResponse::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.messaging.SendMessagesResponse.results)
  return &_impl_.results_;
}
inline const ::unhinged::messaging::SendMessageResult& SendMessagesResponse::_internal_results(int index) const {
  return _impl_.results_.Get(index);
}
inline const ::unhinged::messaging::SendMessageResult& SendMessagesResponse::results(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.SendMessagesResponse.results)
  return _internal_results(index);
}
inline ::unhinged::messaging::SendMessageResult* SendMessagesResponse::_internal_add_results() {
  return _impl_.results_.Add();
}
inline ::unhinged::messaging::SendMessageResult* SendMessagesResponse::add_results() {
  ::unhinged::messaging::SendMessageResult* _add = _internal_add_results();
  // @@protoc_insertion_point(field_add:unhinged.messaging.SendMessagesResponse.results)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::messaging::SendMessageResult >&
SendMessagesResponse::results() const {
  // @@protoc_insertion_point(field_list:unhinged.messaging.SendMessagesResponse.results)
  return _impl_.results_;
}

// int32 successful_count = 3;
inline void SendMessagesResponse::clear_successful_count() {
  _impl_.successful_count_ = 0;
}
inline int32_t SendMessagesResponse::_internal_successful_count() const {
  return _impl_.successful_count_;
}
inline int32_t SendMessagesResponse::successful_count() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.SendMessagesResponse.successful_count)
  return _internal_successful_count();
}
inline void SendMessagesResponse::_internal_set_successful_count(int32_t value) {
  
  _impl_.successful_count_ = value;
}
inline void SendMessagesResponse::set_successful_count(int32_t value) {
  _internal_set_successful_count(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.SendMessagesResponse.successful_count)
}

// int32 failed_count = 4;
inline void SendMessagesResponse::clear_failed_count() {
  _impl_.failed_count_ = 0;
}
inline int32_t SendMessagesResponse::_internal_failed_count() const {
  return _impl_.failed_count_;
}
inline int32_t SendMessagesResponse::failed_count() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.SendMessagesResponse.failed_count)
  return _internal_failed_count();
}
inline void SendMessagesResponse::_internal_set_failed_count(int32_t value) {
  
  _impl_.failed_count_ = value;
}
inline void SendMessagesResponse::set_failed_count(int32_t value) {
  _internal_set_failed_count(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.SendMessagesResponse.failed_count)
}

// -------------------------------------------------------------------

// ReceiveMessagesRequest

// string service_name = 1;
inline void ReceiveMessagesRequest::clear_service_name() {
  _impl_.service_name_.ClearToEmpty();
}
inline const std::string& ReceiveMessagesRequest::service_name() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.ReceiveMessagesRequest.service_name)
  return _internal_service_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReceiveMessagesRequest::set_service_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.ReceiveMessagesRequest.service_name)
}
inline std::string* ReceiveMessagesRequest::mutable_service_name() {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.ReceiveMessagesRequest.service_name)
  return _s;
}
inline const std::string& ReceiveMessagesRequest::_internal_service_name() const {
  return _impl_.service_name_.Get();
}
inline void ReceiveMessagesRequest::_internal_set_service_name(const std::string& value) {
  
  _impl_.service_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ReceiveMessagesRequest::_internal_mutable_service_name() {
  
  return _impl_.service_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ReceiveMessagesRequest::release_service_name() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.ReceiveMessagesRequest.service_name)
  return _impl_.service_name_.Release();
}
inline void ReceiveMessagesRequest::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  _impl_.service_name_.SetAllocated(service_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_name_.IsDefault()) {
    _impl_.service_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.ReceiveMessagesRequest.service_name)
}

// repeated string message_types = 2;
inline int ReceiveMessagesRequest::_internal_message_types_size() const {
  return _impl_.message_types_.size();
}
inline int ReceiveMessagesRequest::message_types_size() const {
  return _internal_message_types_size();
}
inline void ReceiveMessagesRequest::clear_message_types() {
  _impl_.message_types_.Clear();
}
inline std::string* ReceiveMessagesRequest::add_message_types() {
  std::string* _s = _internal_add_message_types();
  // @@protoc_insertion_point(field_add_mutable:unhinged.messaging.ReceiveMessagesRequest.message_types)
  return _s;
}
inline const std::string& ReceiveMessagesRequest::_internal_message_types(int index) const {
  return _impl_.message_types_.Get(index);
}
inline const std::string& ReceiveMessagesRequest::message_types(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.ReceiveMessagesRequest.message_types)
  return _internal_message_types(index);
}
inline std::string* ReceiveMessagesRequest::mutable_message_types(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.ReceiveMessagesRequest.message_types)
  return _impl_.message_types_.Mutable(index);
}
inline void ReceiveMessagesRequest::set_message_types(int index, const std::string& value) {
  _impl_.message_types_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.ReceiveMessagesRequest.message_types)
}
inline void ReceiveMessagesRequest::set_message_types(int index, std::string&& value) {
  _impl_.message_types_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.messaging.ReceiveMessagesRequest.message_types)
}
inline void ReceiveMessagesRequest::set_message_types(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.message_types_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.messaging.ReceiveMessagesRequest.message_types)
}
inline void ReceiveMessagesRequest::set_message_types(int index, const char* value, size_t size) {
  _impl_.message_types_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.messaging.ReceiveMessagesRequest.message_types)
}
inline std::string* ReceiveMessagesRequest::_internal_add_message_types() {
  return _impl_.message_types_.Add();
}
inline void ReceiveMessagesRequest::add_message_types(const std::string& value) {
  _impl_.message_types_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.messaging.ReceiveMessagesRequest.message_types)
}
inline void ReceiveMessagesRequest::add_message_types(std::string&& value) {
  _impl_.message_types_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.messaging.ReceiveMessagesRequest.message_types)
}
inline void ReceiveMessagesRequest::add_message_types(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.message_types_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.messaging.ReceiveMessagesRequest.message_types)
}
inline void ReceiveMessagesRequest::add_message_types(const char* value, size_t size) {
  _impl_.message_types_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.messaging.ReceiveMessagesRequest.message_types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ReceiveMessagesRequest::message_types() const {
  // @@protoc_insertion_point(field_list:unhinged.messaging.ReceiveMessagesRequest.message_types)
  return _impl_.message_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ReceiveMessagesRequest::mutable_message_types() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.messaging.ReceiveMessagesRequest.message_types)
  return &_impl_.message_types_;
}

// int32 max_messages = 3;
inline void ReceiveMessagesRequest::clear_max_messages() {
  _impl_.max_messages_ = 0;
}
inline int32_t ReceiveMessagesRequest::_internal_max_messages() const {
  return _impl_.max_messages_;
}
inline int32_t ReceiveMessagesRequest::max_messages() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.ReceiveMessagesRequest.max_messages)
  return _internal_max_messages();
}
inline void ReceiveMessagesRequest::_internal_set_max_messages(int32_t value) {
  
  _impl_.max_messages_ = value;
}
inline void ReceiveMessagesRequest::set_max_messages(int32_t value) {
  _internal_set_max_messages(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.ReceiveMessagesRequest.max_messages)
}

// int32 wait_time_seconds = 4;
inline void ReceiveMessagesRequest::clear_wait_time_seconds() {
  _impl_.wait_time_seconds_ = 0;
}
inline int32_t ReceiveMessagesRequest::_internal_wait_time_seconds() const {
  return _impl_.wait_time_seconds_;
}
inline int32_t ReceiveMessagesRequest::wait_time_seconds() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.ReceiveMessagesRequest.wait_time_seconds)
  return _internal_wait_time_seconds();
}
inline void ReceiveMessagesRequest::_internal_set_wait_time_seconds(int32_t value) {
  
  _impl_.wait_time_seconds_ = value;
}
inline void ReceiveMessagesRequest::set_wait_time_seconds(int32_t value) {
  _internal_set_wait_time_seconds(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.ReceiveMessagesRequest.wait_time_seconds)
}

// -------------------------------------------------------------------

// ReceiveMessagesResponse

// repeated .unhinged.messaging.Message messages = 1;
inline int ReceiveMessagesResponse::_internal_messages_size() const {
  return _impl_.messages_.size();
}
inline int ReceiveMessagesResponse::messages_size() const {
  return _internal_messages_size();
}
inline void ReceiveMessagesResponse::clear_messages() {
  _impl_.messages_.Clear();
}
inline ::unhinged::messaging::Message* ReceiveMessagesResponse::mutable_messages(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.ReceiveMessagesResponse.messages)
  return _impl_.messages_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::messaging::Message >*
ReceiveMessagesResponse::mutable_messages() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.messaging.ReceiveMessagesResponse.messages)
  return &_impl_.messages_;
}
inline const ::unhinged::messaging::Message& ReceiveMessagesResponse::_internal_messages(int index) const {
  return _impl_.messages_.Get(index);
}
inline const ::unhinged::messaging::Message& ReceiveMessagesResponse::messages(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.ReceiveMessagesResponse.messages)
  return _internal_messages(index);
}
inline ::unhinged::messaging::Message* ReceiveMessagesResponse::_internal_add_messages() {
  return _impl_.messages_.Add();
}
inline ::unhinged::messaging::Message* ReceiveMessagesResponse::add_messages() {
  ::unhinged::messaging::Message* _add = _internal_add_messages();
  // @@protoc_insertion_point(field_add:unhinged.messaging.ReceiveMessagesResponse.messages)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::messaging::Message >&
ReceiveMessagesResponse::messages() const {
  // @@protoc_insertion_point(field_list:unhinged.messaging.ReceiveMessagesResponse.messages)
  return _impl_.messages_;
}

// string receipt_handle = 2;
inline void ReceiveMessagesResponse::clear_receipt_handle() {
  _impl_.receipt_handle_.ClearToEmpty();
}
inline const std::string& ReceiveMessagesResponse::receipt_handle() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.ReceiveMessagesResponse.receipt_handle)
  return _internal_receipt_handle();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReceiveMessagesResponse::set_receipt_handle(ArgT0&& arg0, ArgT... args) {
 
 _impl_.receipt_handle_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.ReceiveMessagesResponse.receipt_handle)
}
inline std::string* ReceiveMessagesResponse::mutable_receipt_handle() {
  std::string* _s = _internal_mutable_receipt_handle();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.ReceiveMessagesResponse.receipt_handle)
  return _s;
}
inline const std::string& ReceiveMessagesResponse::_internal_receipt_handle() const {
  return _impl_.receipt_handle_.Get();
}
inline void ReceiveMessagesResponse::_internal_set_receipt_handle(const std::string& value) {
  
  _impl_.receipt_handle_.Set(value, GetArenaForAllocation());
}
inline std::string* ReceiveMessagesResponse::_internal_mutable_receipt_handle() {
  
  return _impl_.receipt_handle_.Mutable(GetArenaForAllocation());
}
inline std::string* ReceiveMessagesResponse::release_receipt_handle() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.ReceiveMessagesResponse.receipt_handle)
  return _impl_.receipt_handle_.Release();
}
inline void ReceiveMessagesResponse::set_allocated_receipt_handle(std::string* receipt_handle) {
  if (receipt_handle != nullptr) {
    
  } else {
    
  }
  _impl_.receipt_handle_.SetAllocated(receipt_handle, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.receipt_handle_.IsDefault()) {
    _impl_.receipt_handle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.ReceiveMessagesResponse.receipt_handle)
}

// -------------------------------------------------------------------

// AcknowledgeMessageRequest

// string message_id = 1;
inline void AcknowledgeMessageRequest::clear_message_id() {
  _impl_.message_id_.ClearToEmpty();
}
inline const std::string& AcknowledgeMessageRequest::message_id() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.AcknowledgeMessageRequest.message_id)
  return _internal_message_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AcknowledgeMessageRequest::set_message_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.AcknowledgeMessageRequest.message_id)
}
inline std::string* AcknowledgeMessageRequest::mutable_message_id() {
  std::string* _s = _internal_mutable_message_id();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.AcknowledgeMessageRequest.message_id)
  return _s;
}
inline const std::string& AcknowledgeMessageRequest::_internal_message_id() const {
  return _impl_.message_id_.Get();
}
inline void AcknowledgeMessageRequest::_internal_set_message_id(const std::string& value) {
  
  _impl_.message_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AcknowledgeMessageRequest::_internal_mutable_message_id() {
  
  return _impl_.message_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AcknowledgeMessageRequest::release_message_id() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.AcknowledgeMessageRequest.message_id)
  return _impl_.message_id_.Release();
}
inline void AcknowledgeMessageRequest::set_allocated_message_id(std::string* message_id) {
  if (message_id != nullptr) {
    
  } else {
    
  }
  _impl_.message_id_.SetAllocated(message_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_id_.IsDefault()) {
    _impl_.message_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.AcknowledgeMessageRequest.message_id)
}

// string receipt_handle = 2;
inline void AcknowledgeMessageRequest::clear_receipt_handle() {
  _impl_.receipt_handle_.ClearToEmpty();
}
inline const std::string& AcknowledgeMessageRequest::receipt_handle() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.AcknowledgeMessageRequest.receipt_handle)
  return _internal_receipt_handle();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AcknowledgeMessageRequest::set_receipt_handle(ArgT0&& arg0, ArgT... args) {
 
 _impl_.receipt_handle_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.AcknowledgeMessageRequest.receipt_handle)
}
inline std::string* AcknowledgeMessageRequest::mutable_receipt_handle() {
  std::string* _s = _internal_mutable_receipt_handle();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.AcknowledgeMessageRequest.receipt_handle)
  return _s;
}
inline const std::string& AcknowledgeMessageRequest::_internal_receipt_handle() const {
  return _impl_.receipt_handle_.Get();
}
inline void AcknowledgeMessageRequest::_internal_set_receipt_handle(const std::string& value) {
  
  _impl_.receipt_handle_.Set(value, GetArenaForAllocation());
}
inline std::string* AcknowledgeMessageRequest::_internal_mutable_receipt_handle() {
  
  return _impl_.receipt_handle_.Mutable(GetArenaForAllocation());
}
inline std::string* AcknowledgeMessageRequest::release_receipt_handle() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.AcknowledgeMessageRequest.receipt_handle)
  return _impl_.receipt_handle_.Release();
}
inline void AcknowledgeMessageRequest::set_allocated_receipt_handle(std::string* receipt_handle) {
  if (receipt_handle != nullptr) {
    
  } else {
    
  }
  _impl_.receipt_handle_.SetAllocated(receipt_handle, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.receipt_handle_.IsDefault()) {
    _impl_.receipt_handle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.AcknowledgeMessageRequest.receipt_handle)
}

// bool success = 3;
inline void AcknowledgeMessageRequest::clear_success() {
  _impl_.success_ = false;
}
inline bool AcknowledgeMessageRequest::_internal_success() const {
  return _impl_.success_;
}
inline bool AcknowledgeMessageRequest::success() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.AcknowledgeMessageRequest.success)
  return _internal_success();
}
inline void AcknowledgeMessageRequest::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void AcknowledgeMessageRequest::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.AcknowledgeMessageRequest.success)
}

// string error_message = 4;
inline void AcknowledgeMessageRequest::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& AcknowledgeMessageRequest::error_message() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.AcknowledgeMessageRequest.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AcknowledgeMessageRequest::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.AcknowledgeMessageRequest.error_message)
}
inline std::string* AcknowledgeMessageRequest::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.AcknowledgeMessageRequest.error_message)
  return _s;
}
inline const std::string& AcknowledgeMessageRequest::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void AcknowledgeMessageRequest::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* AcknowledgeMessageRequest::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* AcknowledgeMessageRequest::release_error_message() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.AcknowledgeMessageRequest.error_message)
  return _impl_.error_message_.Release();
}
inline void AcknowledgeMessageRequest::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.AcknowledgeMessageRequest.error_message)
}

// -------------------------------------------------------------------

// AcknowledgeMessageResponse

// bool success = 1;
inline void AcknowledgeMessageResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool AcknowledgeMessageResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool AcknowledgeMessageResponse::success() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.AcknowledgeMessageResponse.success)
  return _internal_success();
}
inline void AcknowledgeMessageResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void AcknowledgeMessageResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.AcknowledgeMessageResponse.success)
}

// string message = 2;
inline void AcknowledgeMessageResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& AcknowledgeMessageResponse::message() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.AcknowledgeMessageResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AcknowledgeMessageResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.AcknowledgeMessageResponse.message)
}
inline std::string* AcknowledgeMessageResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.AcknowledgeMessageResponse.message)
  return _s;
}
inline const std::string& AcknowledgeMessageResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void AcknowledgeMessageResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* AcknowledgeMessageResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* AcknowledgeMessageResponse::release_message() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.AcknowledgeMessageResponse.message)
  return _impl_.message_.Release();
}
inline void AcknowledgeMessageResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.AcknowledgeMessageResponse.message)
}

// -------------------------------------------------------------------

// SubscribeToMessagesRequest

// string service_name = 1;
inline void SubscribeToMessagesRequest::clear_service_name() {
  _impl_.service_name_.ClearToEmpty();
}
inline const std::string& SubscribeToMessagesRequest::service_name() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.SubscribeToMessagesRequest.service_name)
  return _internal_service_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubscribeToMessagesRequest::set_service_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.SubscribeToMessagesRequest.service_name)
}
inline std::string* SubscribeToMessagesRequest::mutable_service_name() {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.SubscribeToMessagesRequest.service_name)
  return _s;
}
inline const std::string& SubscribeToMessagesRequest::_internal_service_name() const {
  return _impl_.service_name_.Get();
}
inline void SubscribeToMessagesRequest::_internal_set_service_name(const std::string& value) {
  
  _impl_.service_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SubscribeToMessagesRequest::_internal_mutable_service_name() {
  
  return _impl_.service_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SubscribeToMessagesRequest::release_service_name() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.SubscribeToMessagesRequest.service_name)
  return _impl_.service_name_.Release();
}
inline void SubscribeToMessagesRequest::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  _impl_.service_name_.SetAllocated(service_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_name_.IsDefault()) {
    _impl_.service_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.SubscribeToMessagesRequest.service_name)
}

// repeated string message_types = 2;
inline int SubscribeToMessagesRequest::_internal_message_types_size() const {
  return _impl_.message_types_.size();
}
inline int SubscribeToMessagesRequest::message_types_size() const {
  return _internal_message_types_size();
}
inline void SubscribeToMessagesRequest::clear_message_types() {
  _impl_.message_types_.Clear();
}
inline std::string* SubscribeToMessagesRequest::add_message_types() {
  std::string* _s = _internal_add_message_types();
  // @@protoc_insertion_point(field_add_mutable:unhinged.messaging.SubscribeToMessagesRequest.message_types)
  return _s;
}
inline const std::string& SubscribeToMessagesRequest::_internal_message_types(int index) const {
  return _impl_.message_types_.Get(index);
}
inline const std::string& SubscribeToMessagesRequest::message_types(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.SubscribeToMessagesRequest.message_types)
  return _internal_message_types(index);
}
inline std::string* SubscribeToMessagesRequest::mutable_message_types(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.SubscribeToMessagesRequest.message_types)
  return _impl_.message_types_.Mutable(index);
}
inline void SubscribeToMessagesRequest::set_message_types(int index, const std::string& value) {
  _impl_.message_types_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.SubscribeToMessagesRequest.message_types)
}
inline void SubscribeToMessagesRequest::set_message_types(int index, std::string&& value) {
  _impl_.message_types_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.messaging.SubscribeToMessagesRequest.message_types)
}
inline void SubscribeToMessagesRequest::set_message_types(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.message_types_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.messaging.SubscribeToMessagesRequest.message_types)
}
inline void SubscribeToMessagesRequest::set_message_types(int index, const char* value, size_t size) {
  _impl_.message_types_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.messaging.SubscribeToMessagesRequest.message_types)
}
inline std::string* SubscribeToMessagesRequest::_internal_add_message_types() {
  return _impl_.message_types_.Add();
}
inline void SubscribeToMessagesRequest::add_message_types(const std::string& value) {
  _impl_.message_types_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.messaging.SubscribeToMessagesRequest.message_types)
}
inline void SubscribeToMessagesRequest::add_message_types(std::string&& value) {
  _impl_.message_types_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.messaging.SubscribeToMessagesRequest.message_types)
}
inline void SubscribeToMessagesRequest::add_message_types(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.message_types_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.messaging.SubscribeToMessagesRequest.message_types)
}
inline void SubscribeToMessagesRequest::add_message_types(const char* value, size_t size) {
  _impl_.message_types_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.messaging.SubscribeToMessagesRequest.message_types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SubscribeToMessagesRequest::message_types() const {
  // @@protoc_insertion_point(field_list:unhinged.messaging.SubscribeToMessagesRequest.message_types)
  return _impl_.message_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SubscribeToMessagesRequest::mutable_message_types() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.messaging.SubscribeToMessagesRequest.message_types)
  return &_impl_.message_types_;
}

// .unhinged.messaging.MessageFilter filter = 3;
inline bool SubscribeToMessagesRequest::_internal_has_filter() const {
  return this != internal_default_instance() && _impl_.filter_ != nullptr;
}
inline bool SubscribeToMessagesRequest::has_filter() const {
  return _internal_has_filter();
}
inline void SubscribeToMessagesRequest::clear_filter() {
  if (GetArenaForAllocation() == nullptr && _impl_.filter_ != nullptr) {
    delete _impl_.filter_;
  }
  _impl_.filter_ = nullptr;
}
inline const ::unhinged::messaging::MessageFilter& SubscribeToMessagesRequest::_internal_filter() const {
  const ::unhinged::messaging::MessageFilter* p = _impl_.filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::messaging::MessageFilter&>(
      ::unhinged::messaging::_MessageFilter_default_instance_);
}
inline const ::unhinged::messaging::MessageFilter& SubscribeToMessagesRequest::filter() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.SubscribeToMessagesRequest.filter)
  return _internal_filter();
}
inline void SubscribeToMessagesRequest::unsafe_arena_set_allocated_filter(
    ::unhinged::messaging::MessageFilter* filter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.filter_);
  }
  _impl_.filter_ = filter;
  if (filter) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.SubscribeToMessagesRequest.filter)
}
inline ::unhinged::messaging::MessageFilter* SubscribeToMessagesRequest::release_filter() {
  
  ::unhinged::messaging::MessageFilter* temp = _impl_.filter_;
  _impl_.filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::messaging::MessageFilter* SubscribeToMessagesRequest::unsafe_arena_release_filter() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.SubscribeToMessagesRequest.filter)
  
  ::unhinged::messaging::MessageFilter* temp = _impl_.filter_;
  _impl_.filter_ = nullptr;
  return temp;
}
inline ::unhinged::messaging::MessageFilter* SubscribeToMessagesRequest::_internal_mutable_filter() {
  
  if (_impl_.filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::messaging::MessageFilter>(GetArenaForAllocation());
    _impl_.filter_ = p;
  }
  return _impl_.filter_;
}
inline ::unhinged::messaging::MessageFilter* SubscribeToMessagesRequest::mutable_filter() {
  ::unhinged::messaging::MessageFilter* _msg = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.SubscribeToMessagesRequest.filter)
  return _msg;
}
inline void SubscribeToMessagesRequest::set_allocated_filter(::unhinged::messaging::MessageFilter* filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.filter_;
  }
  if (filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(filter);
    if (message_arena != submessage_arena) {
      filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, filter, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.filter_ = filter;
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.SubscribeToMessagesRequest.filter)
}

// -------------------------------------------------------------------

// MessageFilter

// repeated string from_services = 1;
inline int MessageFilter::_internal_from_services_size() const {
  return _impl_.from_services_.size();
}
inline int MessageFilter::from_services_size() const {
  return _internal_from_services_size();
}
inline void MessageFilter::clear_from_services() {
  _impl_.from_services_.Clear();
}
inline std::string* MessageFilter::add_from_services() {
  std::string* _s = _internal_add_from_services();
  // @@protoc_insertion_point(field_add_mutable:unhinged.messaging.MessageFilter.from_services)
  return _s;
}
inline const std::string& MessageFilter::_internal_from_services(int index) const {
  return _impl_.from_services_.Get(index);
}
inline const std::string& MessageFilter::from_services(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.MessageFilter.from_services)
  return _internal_from_services(index);
}
inline std::string* MessageFilter::mutable_from_services(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.MessageFilter.from_services)
  return _impl_.from_services_.Mutable(index);
}
inline void MessageFilter::set_from_services(int index, const std::string& value) {
  _impl_.from_services_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.MessageFilter.from_services)
}
inline void MessageFilter::set_from_services(int index, std::string&& value) {
  _impl_.from_services_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.messaging.MessageFilter.from_services)
}
inline void MessageFilter::set_from_services(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.from_services_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.messaging.MessageFilter.from_services)
}
inline void MessageFilter::set_from_services(int index, const char* value, size_t size) {
  _impl_.from_services_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.messaging.MessageFilter.from_services)
}
inline std::string* MessageFilter::_internal_add_from_services() {
  return _impl_.from_services_.Add();
}
inline void MessageFilter::add_from_services(const std::string& value) {
  _impl_.from_services_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.messaging.MessageFilter.from_services)
}
inline void MessageFilter::add_from_services(std::string&& value) {
  _impl_.from_services_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.messaging.MessageFilter.from_services)
}
inline void MessageFilter::add_from_services(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.from_services_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.messaging.MessageFilter.from_services)
}
inline void MessageFilter::add_from_services(const char* value, size_t size) {
  _impl_.from_services_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.messaging.MessageFilter.from_services)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MessageFilter::from_services() const {
  // @@protoc_insertion_point(field_list:unhinged.messaging.MessageFilter.from_services)
  return _impl_.from_services_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
MessageFilter::mutable_from_services() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.messaging.MessageFilter.from_services)
  return &_impl_.from_services_;
}

// repeated string user_ids = 2;
inline int MessageFilter::_internal_user_ids_size() const {
  return _impl_.user_ids_.size();
}
inline int MessageFilter::user_ids_size() const {
  return _internal_user_ids_size();
}
inline void MessageFilter::clear_user_ids() {
  _impl_.user_ids_.Clear();
}
inline std::string* MessageFilter::add_user_ids() {
  std::string* _s = _internal_add_user_ids();
  // @@protoc_insertion_point(field_add_mutable:unhinged.messaging.MessageFilter.user_ids)
  return _s;
}
inline const std::string& MessageFilter::_internal_user_ids(int index) const {
  return _impl_.user_ids_.Get(index);
}
inline const std::string& MessageFilter::user_ids(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.MessageFilter.user_ids)
  return _internal_user_ids(index);
}
inline std::string* MessageFilter::mutable_user_ids(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.MessageFilter.user_ids)
  return _impl_.user_ids_.Mutable(index);
}
inline void MessageFilter::set_user_ids(int index, const std::string& value) {
  _impl_.user_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.MessageFilter.user_ids)
}
inline void MessageFilter::set_user_ids(int index, std::string&& value) {
  _impl_.user_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.messaging.MessageFilter.user_ids)
}
inline void MessageFilter::set_user_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.user_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.messaging.MessageFilter.user_ids)
}
inline void MessageFilter::set_user_ids(int index, const char* value, size_t size) {
  _impl_.user_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.messaging.MessageFilter.user_ids)
}
inline std::string* MessageFilter::_internal_add_user_ids() {
  return _impl_.user_ids_.Add();
}
inline void MessageFilter::add_user_ids(const std::string& value) {
  _impl_.user_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.messaging.MessageFilter.user_ids)
}
inline void MessageFilter::add_user_ids(std::string&& value) {
  _impl_.user_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.messaging.MessageFilter.user_ids)
}
inline void MessageFilter::add_user_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.user_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.messaging.MessageFilter.user_ids)
}
inline void MessageFilter::add_user_ids(const char* value, size_t size) {
  _impl_.user_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.messaging.MessageFilter.user_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MessageFilter::user_ids() const {
  // @@protoc_insertion_point(field_list:unhinged.messaging.MessageFilter.user_ids)
  return _impl_.user_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
MessageFilter::mutable_user_ids() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.messaging.MessageFilter.user_ids)
  return &_impl_.user_ids_;
}

// repeated string session_ids = 3;
inline int MessageFilter::_internal_session_ids_size() const {
  return _impl_.session_ids_.size();
}
inline int MessageFilter::session_ids_size() const {
  return _internal_session_ids_size();
}
inline void MessageFilter::clear_session_ids() {
  _impl_.session_ids_.Clear();
}
inline std::string* MessageFilter::add_session_ids() {
  std::string* _s = _internal_add_session_ids();
  // @@protoc_insertion_point(field_add_mutable:unhinged.messaging.MessageFilter.session_ids)
  return _s;
}
inline const std::string& MessageFilter::_internal_session_ids(int index) const {
  return _impl_.session_ids_.Get(index);
}
inline const std::string& MessageFilter::session_ids(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.MessageFilter.session_ids)
  return _internal_session_ids(index);
}
inline std::string* MessageFilter::mutable_session_ids(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.MessageFilter.session_ids)
  return _impl_.session_ids_.Mutable(index);
}
inline void MessageFilter::set_session_ids(int index, const std::string& value) {
  _impl_.session_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.MessageFilter.session_ids)
}
inline void MessageFilter::set_session_ids(int index, std::string&& value) {
  _impl_.session_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.messaging.MessageFilter.session_ids)
}
inline void MessageFilter::set_session_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.session_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.messaging.MessageFilter.session_ids)
}
inline void MessageFilter::set_session_ids(int index, const char* value, size_t size) {
  _impl_.session_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.messaging.MessageFilter.session_ids)
}
inline std::string* MessageFilter::_internal_add_session_ids() {
  return _impl_.session_ids_.Add();
}
inline void MessageFilter::add_session_ids(const std::string& value) {
  _impl_.session_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.messaging.MessageFilter.session_ids)
}
inline void MessageFilter::add_session_ids(std::string&& value) {
  _impl_.session_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.messaging.MessageFilter.session_ids)
}
inline void MessageFilter::add_session_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.session_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.messaging.MessageFilter.session_ids)
}
inline void MessageFilter::add_session_ids(const char* value, size_t size) {
  _impl_.session_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.messaging.MessageFilter.session_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MessageFilter::session_ids() const {
  // @@protoc_insertion_point(field_list:unhinged.messaging.MessageFilter.session_ids)
  return _impl_.session_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
MessageFilter::mutable_session_ids() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.messaging.MessageFilter.session_ids)
  return &_impl_.session_ids_;
}

// .google.protobuf.Struct metadata_filter = 4;
inline bool MessageFilter::_internal_has_metadata_filter() const {
  return this != internal_default_instance() && _impl_.metadata_filter_ != nullptr;
}
inline bool MessageFilter::has_metadata_filter() const {
  return _internal_has_metadata_filter();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& MessageFilter::_internal_metadata_filter() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.metadata_filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& MessageFilter::metadata_filter() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.MessageFilter.metadata_filter)
  return _internal_metadata_filter();
}
inline void MessageFilter::unsafe_arena_set_allocated_metadata_filter(
    ::PROTOBUF_NAMESPACE_ID::Struct* metadata_filter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_filter_);
  }
  _impl_.metadata_filter_ = metadata_filter;
  if (metadata_filter) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.MessageFilter.metadata_filter)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* MessageFilter::release_metadata_filter() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.metadata_filter_;
  _impl_.metadata_filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* MessageFilter::unsafe_arena_release_metadata_filter() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.MessageFilter.metadata_filter)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.metadata_filter_;
  _impl_.metadata_filter_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* MessageFilter::_internal_mutable_metadata_filter() {
  
  if (_impl_.metadata_filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.metadata_filter_ = p;
  }
  return _impl_.metadata_filter_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* MessageFilter::mutable_metadata_filter() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_metadata_filter();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.MessageFilter.metadata_filter)
  return _msg;
}
inline void MessageFilter::set_allocated_metadata_filter(::PROTOBUF_NAMESPACE_ID::Struct* metadata_filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_filter_);
  }
  if (metadata_filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_filter));
    if (message_arena != submessage_arena) {
      metadata_filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata_filter, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.metadata_filter_ = metadata_filter;
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.MessageFilter.metadata_filter)
}

// -------------------------------------------------------------------

// MessageStreamResponse

// .unhinged.messaging.Message message = 1;
inline bool MessageStreamResponse::_internal_has_message() const {
  return response_type_case() == kMessage;
}
inline bool MessageStreamResponse::has_message() const {
  return _internal_has_message();
}
inline void MessageStreamResponse::set_has_message() {
  _impl_._oneof_case_[0] = kMessage;
}
inline void MessageStreamResponse::clear_message() {
  if (_internal_has_message()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_type_.message_;
    }
    clear_has_response_type();
  }
}
inline ::unhinged::messaging::Message* MessageStreamResponse::release_message() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.MessageStreamResponse.message)
  if (_internal_has_message()) {
    clear_has_response_type();
    ::unhinged::messaging::Message* temp = _impl_.response_type_.message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::messaging::Message& MessageStreamResponse::_internal_message() const {
  return _internal_has_message()
      ? *_impl_.response_type_.message_
      : reinterpret_cast< ::unhinged::messaging::Message&>(::unhinged::messaging::_Message_default_instance_);
}
inline const ::unhinged::messaging::Message& MessageStreamResponse::message() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.MessageStreamResponse.message)
  return _internal_message();
}
inline ::unhinged::messaging::Message* MessageStreamResponse::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.messaging.MessageStreamResponse.message)
  if (_internal_has_message()) {
    clear_has_response_type();
    ::unhinged::messaging::Message* temp = _impl_.response_type_.message_;
    _impl_.response_type_.message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageStreamResponse::unsafe_arena_set_allocated_message(::unhinged::messaging::Message* message) {
  clear_response_type();
  if (message) {
    set_has_message();
    _impl_.response_type_.message_ = message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.MessageStreamResponse.message)
}
inline ::unhinged::messaging::Message* MessageStreamResponse::_internal_mutable_message() {
  if (!_internal_has_message()) {
    clear_response_type();
    set_has_message();
    _impl_.response_type_.message_ = CreateMaybeMessage< ::unhinged::messaging::Message >(GetArenaForAllocation());
  }
  return _impl_.response_type_.message_;
}
inline ::unhinged::messaging::Message* MessageStreamResponse::mutable_message() {
  ::unhinged::messaging::Message* _msg = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.MessageStreamResponse.message)
  return _msg;
}

// .unhinged.messaging.StreamStatus status = 2;
inline bool MessageStreamResponse::_internal_has_status() const {
  return response_type_case() == kStatus;
}
inline bool MessageStreamResponse::has_status() const {
  return _internal_has_status();
}
inline void MessageStreamResponse::set_has_status() {
  _impl_._oneof_case_[0] = kStatus;
}
inline void MessageStreamResponse::clear_status() {
  if (_internal_has_status()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_type_.status_;
    }
    clear_has_response_type();
  }
}
inline ::unhinged::messaging::StreamStatus* MessageStreamResponse::release_status() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.MessageStreamResponse.status)
  if (_internal_has_status()) {
    clear_has_response_type();
    ::unhinged::messaging::StreamStatus* temp = _impl_.response_type_.status_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.status_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::messaging::StreamStatus& MessageStreamResponse::_internal_status() const {
  return _internal_has_status()
      ? *_impl_.response_type_.status_
      : reinterpret_cast< ::unhinged::messaging::StreamStatus&>(::unhinged::messaging::_StreamStatus_default_instance_);
}
inline const ::unhinged::messaging::StreamStatus& MessageStreamResponse::status() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.MessageStreamResponse.status)
  return _internal_status();
}
inline ::unhinged::messaging::StreamStatus* MessageStreamResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.messaging.MessageStreamResponse.status)
  if (_internal_has_status()) {
    clear_has_response_type();
    ::unhinged::messaging::StreamStatus* temp = _impl_.response_type_.status_;
    _impl_.response_type_.status_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageStreamResponse::unsafe_arena_set_allocated_status(::unhinged::messaging::StreamStatus* status) {
  clear_response_type();
  if (status) {
    set_has_status();
    _impl_.response_type_.status_ = status;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.MessageStreamResponse.status)
}
inline ::unhinged::messaging::StreamStatus* MessageStreamResponse::_internal_mutable_status() {
  if (!_internal_has_status()) {
    clear_response_type();
    set_has_status();
    _impl_.response_type_.status_ = CreateMaybeMessage< ::unhinged::messaging::StreamStatus >(GetArenaForAllocation());
  }
  return _impl_.response_type_.status_;
}
inline ::unhinged::messaging::StreamStatus* MessageStreamResponse::mutable_status() {
  ::unhinged::messaging::StreamStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.MessageStreamResponse.status)
  return _msg;
}

// .unhinged.messaging.StreamError error = 3;
inline bool MessageStreamResponse::_internal_has_error() const {
  return response_type_case() == kError;
}
inline bool MessageStreamResponse::has_error() const {
  return _internal_has_error();
}
inline void MessageStreamResponse::set_has_error() {
  _impl_._oneof_case_[0] = kError;
}
inline void MessageStreamResponse::clear_error() {
  if (_internal_has_error()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_type_.error_;
    }
    clear_has_response_type();
  }
}
inline ::unhinged::messaging::StreamError* MessageStreamResponse::release_error() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.MessageStreamResponse.error)
  if (_internal_has_error()) {
    clear_has_response_type();
    ::unhinged::messaging::StreamError* temp = _impl_.response_type_.error_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::messaging::StreamError& MessageStreamResponse::_internal_error() const {
  return _internal_has_error()
      ? *_impl_.response_type_.error_
      : reinterpret_cast< ::unhinged::messaging::StreamError&>(::unhinged::messaging::_StreamError_default_instance_);
}
inline const ::unhinged::messaging::StreamError& MessageStreamResponse::error() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.MessageStreamResponse.error)
  return _internal_error();
}
inline ::unhinged::messaging::StreamError* MessageStreamResponse::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.messaging.MessageStreamResponse.error)
  if (_internal_has_error()) {
    clear_has_response_type();
    ::unhinged::messaging::StreamError* temp = _impl_.response_type_.error_;
    _impl_.response_type_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageStreamResponse::unsafe_arena_set_allocated_error(::unhinged::messaging::StreamError* error) {
  clear_response_type();
  if (error) {
    set_has_error();
    _impl_.response_type_.error_ = error;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.messaging.MessageStreamResponse.error)
}
inline ::unhinged::messaging::StreamError* MessageStreamResponse::_internal_mutable_error() {
  if (!_internal_has_error()) {
    clear_response_type();
    set_has_error();
    _impl_.response_type_.error_ = CreateMaybeMessage< ::unhinged::messaging::StreamError >(GetArenaForAllocation());
  }
  return _impl_.response_type_.error_;
}
inline ::unhinged::messaging::StreamError* MessageStreamResponse::mutable_error() {
  ::unhinged::messaging::StreamError* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.MessageStreamResponse.error)
  return _msg;
}

inline bool MessageStreamResponse::has_response_type() const {
  return response_type_case() != RESPONSE_TYPE_NOT_SET;
}
inline void MessageStreamResponse::clear_has_response_type() {
  _impl_._oneof_case_[0] = RESPONSE_TYPE_NOT_SET;
}
inline MessageStreamResponse::ResponseTypeCase MessageStreamResponse::response_type_case() const {
  return MessageStreamResponse::ResponseTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// StreamStatus

// string status = 1;
inline void StreamStatus::clear_status() {
  _impl_.status_.ClearToEmpty();
}
inline const std::string& StreamStatus::status() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.StreamStatus.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamStatus::set_status(ArgT0&& arg0, ArgT... args) {
 
 _impl_.status_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.StreamStatus.status)
}
inline std::string* StreamStatus::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.StreamStatus.status)
  return _s;
}
inline const std::string& StreamStatus::_internal_status() const {
  return _impl_.status_.Get();
}
inline void StreamStatus::_internal_set_status(const std::string& value) {
  
  _impl_.status_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamStatus::_internal_mutable_status() {
  
  return _impl_.status_.Mutable(GetArenaForAllocation());
}
inline std::string* StreamStatus::release_status() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.StreamStatus.status)
  return _impl_.status_.Release();
}
inline void StreamStatus::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  _impl_.status_.SetAllocated(status, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.StreamStatus.status)
}

// int32 messages_received = 2;
inline void StreamStatus::clear_messages_received() {
  _impl_.messages_received_ = 0;
}
inline int32_t StreamStatus::_internal_messages_received() const {
  return _impl_.messages_received_;
}
inline int32_t StreamStatus::messages_received() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.StreamStatus.messages_received)
  return _internal_messages_received();
}
inline void StreamStatus::_internal_set_messages_received(int32_t value) {
  
  _impl_.messages_received_ = value;
}
inline void StreamStatus::set_messages_received(int32_t value) {
  _internal_set_messages_received(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.StreamStatus.messages_received)
}

// -------------------------------------------------------------------

// StreamError

// string error_code = 1;
inline void StreamError::clear_error_code() {
  _impl_.error_code_.ClearToEmpty();
}
inline const std::string& StreamError::error_code() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.StreamError.error_code)
  return _internal_error_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamError::set_error_code(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.StreamError.error_code)
}
inline std::string* StreamError::mutable_error_code() {
  std::string* _s = _internal_mutable_error_code();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.StreamError.error_code)
  return _s;
}
inline const std::string& StreamError::_internal_error_code() const {
  return _impl_.error_code_.Get();
}
inline void StreamError::_internal_set_error_code(const std::string& value) {
  
  _impl_.error_code_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamError::_internal_mutable_error_code() {
  
  return _impl_.error_code_.Mutable(GetArenaForAllocation());
}
inline std::string* StreamError::release_error_code() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.StreamError.error_code)
  return _impl_.error_code_.Release();
}
inline void StreamError::set_allocated_error_code(std::string* error_code) {
  if (error_code != nullptr) {
    
  } else {
    
  }
  _impl_.error_code_.SetAllocated(error_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_code_.IsDefault()) {
    _impl_.error_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.StreamError.error_code)
}

// string error_message = 2;
inline void StreamError::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& StreamError::error_message() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.StreamError.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamError::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.messaging.StreamError.error_message)
}
inline std::string* StreamError::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:unhinged.messaging.StreamError.error_message)
  return _s;
}
inline const std::string& StreamError::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void StreamError::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamError::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* StreamError::release_error_message() {
  // @@protoc_insertion_point(field_release:unhinged.messaging.StreamError.error_message)
  return _impl_.error_message_.Release();
}
inline void StreamError::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.messaging.StreamError.error_message)
}

// bool is_recoverable = 3;
inline void StreamError::clear_is_recoverable() {
  _impl_.is_recoverable_ = false;
}
inline bool StreamError::_internal_is_recoverable() const {
  return _impl_.is_recoverable_;
}
inline bool StreamError::is_recoverable() const {
  // @@protoc_insertion_point(field_get:unhinged.messaging.StreamError.is_recoverable)
  return _internal_is_recoverable();
}
inline void StreamError::_internal_set_is_recoverable(bool value) {
  
  _impl_.is_recoverable_ = value;
}
inline void StreamError::set_is_recoverable(bool value) {
  _internal_set_is_recoverable(value);
  // @@protoc_insertion_point(field_set:unhinged.messaging.StreamError.is_recoverable)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace messaging
}  // namespace unhinged

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::unhinged::messaging::LLMMessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::unhinged::messaging::LLMMessageType>() {
  return ::unhinged::messaging::LLMMessageType_descriptor();
}
template <> struct is_proto_enum< ::unhinged::messaging::AgentMessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::unhinged::messaging::AgentMessageType>() {
  return ::unhinged::messaging::AgentMessageType_descriptor();
}
template <> struct is_proto_enum< ::unhinged::messaging::ToolMessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::unhinged::messaging::ToolMessageType>() {
  return ::unhinged::messaging::ToolMessageType_descriptor();
}
template <> struct is_proto_enum< ::unhinged::messaging::WorkflowMessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::unhinged::messaging::WorkflowMessageType>() {
  return ::unhinged::messaging::WorkflowMessageType_descriptor();
}
template <> struct is_proto_enum< ::unhinged::messaging::UIMessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::unhinged::messaging::UIMessageType>() {
  return ::unhinged::messaging::UIMessageType_descriptor();
}
template <> struct is_proto_enum< ::unhinged::messaging::SystemMessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::unhinged::messaging::SystemMessageType>() {
  return ::unhinged::messaging::SystemMessageType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_messaging_2eproto
