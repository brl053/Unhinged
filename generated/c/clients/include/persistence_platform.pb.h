// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: persistence_platform.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_persistence_5fplatform_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_persistence_5fplatform_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
#include <google/protobuf/struct.pb.h>
#include <google/protobuf/any.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_persistence_5fplatform_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_persistence_5fplatform_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_persistence_5fplatform_2eproto;
namespace unhinged {
namespace persistence {
class AndFilter;
struct AndFilterDefaultTypeInternal;
extern AndFilterDefaultTypeInternal _AndFilter_default_instance_;
class DeleteRequest;
struct DeleteRequestDefaultTypeInternal;
extern DeleteRequestDefaultTypeInternal _DeleteRequest_default_instance_;
class DeleteResponse;
struct DeleteResponseDefaultTypeInternal;
extern DeleteResponseDefaultTypeInternal _DeleteResponse_default_instance_;
class EqualsFilter;
struct EqualsFilterDefaultTypeInternal;
extern EqualsFilterDefaultTypeInternal _EqualsFilter_default_instance_;
class ExecuteOperationRequest;
struct ExecuteOperationRequestDefaultTypeInternal;
extern ExecuteOperationRequestDefaultTypeInternal _ExecuteOperationRequest_default_instance_;
class ExecuteOperationResponse;
struct ExecuteOperationResponseDefaultTypeInternal;
extern ExecuteOperationResponseDefaultTypeInternal _ExecuteOperationResponse_default_instance_;
class ExecuteQueryRequest;
struct ExecuteQueryRequestDefaultTypeInternal;
extern ExecuteQueryRequestDefaultTypeInternal _ExecuteQueryRequest_default_instance_;
class ExecuteQueryResponse;
struct ExecuteQueryResponseDefaultTypeInternal;
extern ExecuteQueryResponseDefaultTypeInternal _ExecuteQueryResponse_default_instance_;
class ExecuteRawQueryRequest;
struct ExecuteRawQueryRequestDefaultTypeInternal;
extern ExecuteRawQueryRequestDefaultTypeInternal _ExecuteRawQueryRequest_default_instance_;
class ExecuteRawQueryResponse;
struct ExecuteRawQueryResponseDefaultTypeInternal;
extern ExecuteRawQueryResponseDefaultTypeInternal _ExecuteRawQueryResponse_default_instance_;
class ExecutionContext;
struct ExecutionContextDefaultTypeInternal;
extern ExecutionContextDefaultTypeInternal _ExecutionContext_default_instance_;
class GetMetricsRequest;
struct GetMetricsRequestDefaultTypeInternal;
extern GetMetricsRequestDefaultTypeInternal _GetMetricsRequest_default_instance_;
class GetMetricsResponse;
struct GetMetricsResponseDefaultTypeInternal;
extern GetMetricsResponseDefaultTypeInternal _GetMetricsResponse_default_instance_;
class GetPlatformInfoRequest;
struct GetPlatformInfoRequestDefaultTypeInternal;
extern GetPlatformInfoRequestDefaultTypeInternal _GetPlatformInfoRequest_default_instance_;
class GetPlatformInfoResponse;
struct GetPlatformInfoResponseDefaultTypeInternal;
extern GetPlatformInfoResponseDefaultTypeInternal _GetPlatformInfoResponse_default_instance_;
class GraphEdge;
struct GraphEdgeDefaultTypeInternal;
extern GraphEdgeDefaultTypeInternal _GraphEdge_default_instance_;
class GraphNode;
struct GraphNodeDefaultTypeInternal;
extern GraphNodeDefaultTypeInternal _GraphNode_default_instance_;
class GraphTraversalSpec;
struct GraphTraversalSpecDefaultTypeInternal;
extern GraphTraversalSpecDefaultTypeInternal _GraphTraversalSpec_default_instance_;
class GraphTraverseRequest;
struct GraphTraverseRequestDefaultTypeInternal;
extern GraphTraverseRequestDefaultTypeInternal _GraphTraverseRequest_default_instance_;
class GraphTraverseResponse;
struct GraphTraverseResponseDefaultTypeInternal;
extern GraphTraverseResponseDefaultTypeInternal _GraphTraverseResponse_default_instance_;
class GreaterThanFilter;
struct GreaterThanFilterDefaultTypeInternal;
extern GreaterThanFilterDefaultTypeInternal _GreaterThanFilter_default_instance_;
class HealthCheckRequest;
struct HealthCheckRequestDefaultTypeInternal;
extern HealthCheckRequestDefaultTypeInternal _HealthCheckRequest_default_instance_;
class HealthCheckResponse;
struct HealthCheckResponseDefaultTypeInternal;
extern HealthCheckResponseDefaultTypeInternal _HealthCheckResponse_default_instance_;
class InFilter;
struct InFilterDefaultTypeInternal;
extern InFilterDefaultTypeInternal _InFilter_default_instance_;
class InsertBatchRequest;
struct InsertBatchRequestDefaultTypeInternal;
extern InsertBatchRequestDefaultTypeInternal _InsertBatchRequest_default_instance_;
class InsertBatchResponse;
struct InsertBatchResponseDefaultTypeInternal;
extern InsertBatchResponseDefaultTypeInternal _InsertBatchResponse_default_instance_;
class InsertRequest;
struct InsertRequestDefaultTypeInternal;
extern InsertRequestDefaultTypeInternal _InsertRequest_default_instance_;
class InsertResponse;
struct InsertResponseDefaultTypeInternal;
extern InsertResponseDefaultTypeInternal _InsertResponse_default_instance_;
class LessThanFilter;
struct LessThanFilterDefaultTypeInternal;
extern LessThanFilterDefaultTypeInternal _LessThanFilter_default_instance_;
class OrFilter;
struct OrFilterDefaultTypeInternal;
extern OrFilterDefaultTypeInternal _OrFilter_default_instance_;
class OrderBy;
struct OrderByDefaultTypeInternal;
extern OrderByDefaultTypeInternal _OrderBy_default_instance_;
class QueryCriteria;
struct QueryCriteriaDefaultTypeInternal;
extern QueryCriteriaDefaultTypeInternal _QueryCriteria_default_instance_;
class QuerySpec;
struct QuerySpecDefaultTypeInternal;
extern QuerySpecDefaultTypeInternal _QuerySpec_default_instance_;
class RangeFilter;
struct RangeFilterDefaultTypeInternal;
extern RangeFilterDefaultTypeInternal _RangeFilter_default_instance_;
class Record;
struct RecordDefaultTypeInternal;
extern RecordDefaultTypeInternal _Record_default_instance_;
class TechnologyHealth;
struct TechnologyHealthDefaultTypeInternal;
extern TechnologyHealthDefaultTypeInternal _TechnologyHealth_default_instance_;
class TextSearchFilter;
struct TextSearchFilterDefaultTypeInternal;
extern TextSearchFilterDefaultTypeInternal _TextSearchFilter_default_instance_;
class UpdateRequest;
struct UpdateRequestDefaultTypeInternal;
extern UpdateRequestDefaultTypeInternal _UpdateRequest_default_instance_;
class UpdateResponse;
struct UpdateResponseDefaultTypeInternal;
extern UpdateResponseDefaultTypeInternal _UpdateResponse_default_instance_;
class VectorSearchFilter;
struct VectorSearchFilterDefaultTypeInternal;
extern VectorSearchFilterDefaultTypeInternal _VectorSearchFilter_default_instance_;
class VectorSearchRequest;
struct VectorSearchRequestDefaultTypeInternal;
extern VectorSearchRequestDefaultTypeInternal _VectorSearchRequest_default_instance_;
class VectorSearchResponse;
struct VectorSearchResponseDefaultTypeInternal;
extern VectorSearchResponseDefaultTypeInternal _VectorSearchResponse_default_instance_;
class VectorSearchResult;
struct VectorSearchResultDefaultTypeInternal;
extern VectorSearchResultDefaultTypeInternal _VectorSearchResult_default_instance_;
}  // namespace persistence
}  // namespace unhinged
PROTOBUF_NAMESPACE_OPEN
template<> ::unhinged::persistence::AndFilter* Arena::CreateMaybeMessage<::unhinged::persistence::AndFilter>(Arena*);
template<> ::unhinged::persistence::DeleteRequest* Arena::CreateMaybeMessage<::unhinged::persistence::DeleteRequest>(Arena*);
template<> ::unhinged::persistence::DeleteResponse* Arena::CreateMaybeMessage<::unhinged::persistence::DeleteResponse>(Arena*);
template<> ::unhinged::persistence::EqualsFilter* Arena::CreateMaybeMessage<::unhinged::persistence::EqualsFilter>(Arena*);
template<> ::unhinged::persistence::ExecuteOperationRequest* Arena::CreateMaybeMessage<::unhinged::persistence::ExecuteOperationRequest>(Arena*);
template<> ::unhinged::persistence::ExecuteOperationResponse* Arena::CreateMaybeMessage<::unhinged::persistence::ExecuteOperationResponse>(Arena*);
template<> ::unhinged::persistence::ExecuteQueryRequest* Arena::CreateMaybeMessage<::unhinged::persistence::ExecuteQueryRequest>(Arena*);
template<> ::unhinged::persistence::ExecuteQueryResponse* Arena::CreateMaybeMessage<::unhinged::persistence::ExecuteQueryResponse>(Arena*);
template<> ::unhinged::persistence::ExecuteRawQueryRequest* Arena::CreateMaybeMessage<::unhinged::persistence::ExecuteRawQueryRequest>(Arena*);
template<> ::unhinged::persistence::ExecuteRawQueryResponse* Arena::CreateMaybeMessage<::unhinged::persistence::ExecuteRawQueryResponse>(Arena*);
template<> ::unhinged::persistence::ExecutionContext* Arena::CreateMaybeMessage<::unhinged::persistence::ExecutionContext>(Arena*);
template<> ::unhinged::persistence::GetMetricsRequest* Arena::CreateMaybeMessage<::unhinged::persistence::GetMetricsRequest>(Arena*);
template<> ::unhinged::persistence::GetMetricsResponse* Arena::CreateMaybeMessage<::unhinged::persistence::GetMetricsResponse>(Arena*);
template<> ::unhinged::persistence::GetPlatformInfoRequest* Arena::CreateMaybeMessage<::unhinged::persistence::GetPlatformInfoRequest>(Arena*);
template<> ::unhinged::persistence::GetPlatformInfoResponse* Arena::CreateMaybeMessage<::unhinged::persistence::GetPlatformInfoResponse>(Arena*);
template<> ::unhinged::persistence::GraphEdge* Arena::CreateMaybeMessage<::unhinged::persistence::GraphEdge>(Arena*);
template<> ::unhinged::persistence::GraphNode* Arena::CreateMaybeMessage<::unhinged::persistence::GraphNode>(Arena*);
template<> ::unhinged::persistence::GraphTraversalSpec* Arena::CreateMaybeMessage<::unhinged::persistence::GraphTraversalSpec>(Arena*);
template<> ::unhinged::persistence::GraphTraverseRequest* Arena::CreateMaybeMessage<::unhinged::persistence::GraphTraverseRequest>(Arena*);
template<> ::unhinged::persistence::GraphTraverseResponse* Arena::CreateMaybeMessage<::unhinged::persistence::GraphTraverseResponse>(Arena*);
template<> ::unhinged::persistence::GreaterThanFilter* Arena::CreateMaybeMessage<::unhinged::persistence::GreaterThanFilter>(Arena*);
template<> ::unhinged::persistence::HealthCheckRequest* Arena::CreateMaybeMessage<::unhinged::persistence::HealthCheckRequest>(Arena*);
template<> ::unhinged::persistence::HealthCheckResponse* Arena::CreateMaybeMessage<::unhinged::persistence::HealthCheckResponse>(Arena*);
template<> ::unhinged::persistence::InFilter* Arena::CreateMaybeMessage<::unhinged::persistence::InFilter>(Arena*);
template<> ::unhinged::persistence::InsertBatchRequest* Arena::CreateMaybeMessage<::unhinged::persistence::InsertBatchRequest>(Arena*);
template<> ::unhinged::persistence::InsertBatchResponse* Arena::CreateMaybeMessage<::unhinged::persistence::InsertBatchResponse>(Arena*);
template<> ::unhinged::persistence::InsertRequest* Arena::CreateMaybeMessage<::unhinged::persistence::InsertRequest>(Arena*);
template<> ::unhinged::persistence::InsertResponse* Arena::CreateMaybeMessage<::unhinged::persistence::InsertResponse>(Arena*);
template<> ::unhinged::persistence::LessThanFilter* Arena::CreateMaybeMessage<::unhinged::persistence::LessThanFilter>(Arena*);
template<> ::unhinged::persistence::OrFilter* Arena::CreateMaybeMessage<::unhinged::persistence::OrFilter>(Arena*);
template<> ::unhinged::persistence::OrderBy* Arena::CreateMaybeMessage<::unhinged::persistence::OrderBy>(Arena*);
template<> ::unhinged::persistence::QueryCriteria* Arena::CreateMaybeMessage<::unhinged::persistence::QueryCriteria>(Arena*);
template<> ::unhinged::persistence::QuerySpec* Arena::CreateMaybeMessage<::unhinged::persistence::QuerySpec>(Arena*);
template<> ::unhinged::persistence::RangeFilter* Arena::CreateMaybeMessage<::unhinged::persistence::RangeFilter>(Arena*);
template<> ::unhinged::persistence::Record* Arena::CreateMaybeMessage<::unhinged::persistence::Record>(Arena*);
template<> ::unhinged::persistence::TechnologyHealth* Arena::CreateMaybeMessage<::unhinged::persistence::TechnologyHealth>(Arena*);
template<> ::unhinged::persistence::TextSearchFilter* Arena::CreateMaybeMessage<::unhinged::persistence::TextSearchFilter>(Arena*);
template<> ::unhinged::persistence::UpdateRequest* Arena::CreateMaybeMessage<::unhinged::persistence::UpdateRequest>(Arena*);
template<> ::unhinged::persistence::UpdateResponse* Arena::CreateMaybeMessage<::unhinged::persistence::UpdateResponse>(Arena*);
template<> ::unhinged::persistence::VectorSearchFilter* Arena::CreateMaybeMessage<::unhinged::persistence::VectorSearchFilter>(Arena*);
template<> ::unhinged::persistence::VectorSearchRequest* Arena::CreateMaybeMessage<::unhinged::persistence::VectorSearchRequest>(Arena*);
template<> ::unhinged::persistence::VectorSearchResponse* Arena::CreateMaybeMessage<::unhinged::persistence::VectorSearchResponse>(Arena*);
template<> ::unhinged::persistence::VectorSearchResult* Arena::CreateMaybeMessage<::unhinged::persistence::VectorSearchResult>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace unhinged {
namespace persistence {

enum QueryType : int {
  POINT_LOOKUP = 0,
  RANGE_SCAN = 1,
  FULL_TEXT_SEARCH = 2,
  VECTOR_SIMILARITY = 3,
  GRAPH_TRAVERSAL = 4,
  AGGREGATION = 5,
  TIME_SERIES = 6,
  GEOSPATIAL = 7,
  DOCUMENT_QUERY = 8,
  QueryType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  QueryType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool QueryType_IsValid(int value);
constexpr QueryType QueryType_MIN = POINT_LOOKUP;
constexpr QueryType QueryType_MAX = DOCUMENT_QUERY;
constexpr int QueryType_ARRAYSIZE = QueryType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* QueryType_descriptor();
template<typename T>
inline const std::string& QueryType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, QueryType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function QueryType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    QueryType_descriptor(), enum_t_value);
}
inline bool QueryType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, QueryType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<QueryType>(
    QueryType_descriptor(), name, value);
}
enum GraphTraversalType : int {
  BREADTH_FIRST = 0,
  DEPTH_FIRST = 1,
  SHORTEST_PATH = 2,
  ALL_PATHS = 3,
  GraphTraversalType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  GraphTraversalType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool GraphTraversalType_IsValid(int value);
constexpr GraphTraversalType GraphTraversalType_MIN = BREADTH_FIRST;
constexpr GraphTraversalType GraphTraversalType_MAX = ALL_PATHS;
constexpr int GraphTraversalType_ARRAYSIZE = GraphTraversalType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GraphTraversalType_descriptor();
template<typename T>
inline const std::string& GraphTraversalType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GraphTraversalType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GraphTraversalType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GraphTraversalType_descriptor(), enum_t_value);
}
inline bool GraphTraversalType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GraphTraversalType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GraphTraversalType>(
    GraphTraversalType_descriptor(), name, value);
}
// ===================================================================

class ExecutionContext final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.persistence.ExecutionContext) */ {
 public:
  inline ExecutionContext() : ExecutionContext(nullptr) {}
  ~ExecutionContext() override;
  explicit PROTOBUF_CONSTEXPR ExecutionContext(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecutionContext(const ExecutionContext& from);
  ExecutionContext(ExecutionContext&& from) noexcept
    : ExecutionContext() {
    *this = ::std::move(from);
  }

  inline ExecutionContext& operator=(const ExecutionContext& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecutionContext& operator=(ExecutionContext&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecutionContext& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecutionContext* internal_default_instance() {
    return reinterpret_cast<const ExecutionContext*>(
               &_ExecutionContext_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ExecutionContext& a, ExecutionContext& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecutionContext* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecutionContext* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExecutionContext* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExecutionContext>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExecutionContext& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExecutionContext& from) {
    ExecutionContext::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecutionContext* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.persistence.ExecutionContext";
  }
  protected:
  explicit ExecutionContext(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestIdFieldNumber = 1,
    kUserIdFieldNumber = 2,
    kSessionIdFieldNumber = 3,
    kTraceIdFieldNumber = 4,
    kSpanIdFieldNumber = 5,
    kTimestampFieldNumber = 6,
    kMetadataFieldNumber = 7,
  };
  // string request_id = 1;
  void clear_request_id();
  const std::string& request_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_request_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_request_id();
  PROTOBUF_NODISCARD std::string* release_request_id();
  void set_allocated_request_id(std::string* request_id);
  private:
  const std::string& _internal_request_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_id(const std::string& value);
  std::string* _internal_mutable_request_id();
  public:

  // string user_id = 2;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string session_id = 3;
  void clear_session_id();
  const std::string& session_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // string trace_id = 4;
  void clear_trace_id();
  const std::string& trace_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_trace_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_trace_id();
  PROTOBUF_NODISCARD std::string* release_trace_id();
  void set_allocated_trace_id(std::string* trace_id);
  private:
  const std::string& _internal_trace_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trace_id(const std::string& value);
  std::string* _internal_mutable_trace_id();
  public:

  // string span_id = 5;
  void clear_span_id();
  const std::string& span_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_span_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_span_id();
  PROTOBUF_NODISCARD std::string* release_span_id();
  void set_allocated_span_id(std::string* span_id);
  private:
  const std::string& _internal_span_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_span_id(const std::string& value);
  std::string* _internal_mutable_span_id();
  public:

  // .google.protobuf.Timestamp timestamp = 6;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // .google.protobuf.Struct metadata = 7;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::PROTOBUF_NAMESPACE_ID::Struct& metadata() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_metadata();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_metadata();
  void set_allocated_metadata(::PROTOBUF_NAMESPACE_ID::Struct* metadata);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::PROTOBUF_NAMESPACE_ID::Struct* metadata);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_metadata();

  // @@protoc_insertion_point(class_scope:unhinged.persistence.ExecutionContext)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trace_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr span_id_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
    ::PROTOBUF_NAMESPACE_ID::Struct* metadata_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_persistence_5fplatform_2eproto;
};
// -------------------------------------------------------------------

class Record final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.persistence.Record) */ {
 public:
  inline Record() : Record(nullptr) {}
  ~Record() override;
  explicit PROTOBUF_CONSTEXPR Record(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Record(const Record& from);
  Record(Record&& from) noexcept
    : Record() {
    *this = ::std::move(from);
  }

  inline Record& operator=(const Record& from) {
    CopyFrom(from);
    return *this;
  }
  inline Record& operator=(Record&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Record& default_instance() {
    return *internal_default_instance();
  }
  static inline const Record* internal_default_instance() {
    return reinterpret_cast<const Record*>(
               &_Record_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Record& a, Record& b) {
    a.Swap(&b);
  }
  inline void Swap(Record* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Record* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Record* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Record>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Record& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Record& from) {
    Record::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Record* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.persistence.Record";
  }
  protected:
  explicit Record(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kVersionFieldNumber = 5,
    kDataFieldNumber = 2,
    kCreatedAtFieldNumber = 3,
    kUpdatedAtFieldNumber = 4,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string version = 5;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // .google.protobuf.Struct data = 2;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::PROTOBUF_NAMESPACE_ID::Struct& data() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_data();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_data();
  void set_allocated_data(::PROTOBUF_NAMESPACE_ID::Struct* data);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_data() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::PROTOBUF_NAMESPACE_ID::Struct* data);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_data();

  // .google.protobuf.Timestamp created_at = 3;
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_at();
  void set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_at();

  // .google.protobuf.Timestamp updated_at = 4;
  bool has_updated_at() const;
  private:
  bool _internal_has_updated_at() const;
  public:
  void clear_updated_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& updated_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_updated_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_updated_at();
  void set_allocated_updated_at(::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_updated_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_updated_at();
  public:
  void unsafe_arena_set_allocated_updated_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_updated_at();

  // @@protoc_insertion_point(class_scope:unhinged.persistence.Record)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::Struct* data_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_persistence_5fplatform_2eproto;
};
// -------------------------------------------------------------------

class QueryCriteria final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.persistence.QueryCriteria) */ {
 public:
  inline QueryCriteria() : QueryCriteria(nullptr) {}
  ~QueryCriteria() override;
  explicit PROTOBUF_CONSTEXPR QueryCriteria(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryCriteria(const QueryCriteria& from);
  QueryCriteria(QueryCriteria&& from) noexcept
    : QueryCriteria() {
    *this = ::std::move(from);
  }

  inline QueryCriteria& operator=(const QueryCriteria& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryCriteria& operator=(QueryCriteria&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryCriteria& default_instance() {
    return *internal_default_instance();
  }
  enum CriteriaCase {
    kEquals = 1,
    kGreaterThan = 2,
    kLessThan = 3,
    kInFilter = 4,
    kRange = 5,
    kTextSearch = 6,
    kVectorSearch = 7,
    kAndFilter = 8,
    kOrFilter = 9,
    CRITERIA_NOT_SET = 0,
  };

  static inline const QueryCriteria* internal_default_instance() {
    return reinterpret_cast<const QueryCriteria*>(
               &_QueryCriteria_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(QueryCriteria& a, QueryCriteria& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryCriteria* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryCriteria* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryCriteria* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryCriteria>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryCriteria& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryCriteria& from) {
    QueryCriteria::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryCriteria* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.persistence.QueryCriteria";
  }
  protected:
  explicit QueryCriteria(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEqualsFieldNumber = 1,
    kGreaterThanFieldNumber = 2,
    kLessThanFieldNumber = 3,
    kInFilterFieldNumber = 4,
    kRangeFieldNumber = 5,
    kTextSearchFieldNumber = 6,
    kVectorSearchFieldNumber = 7,
    kAndFilterFieldNumber = 8,
    kOrFilterFieldNumber = 9,
  };
  // .unhinged.persistence.EqualsFilter equals = 1;
  bool has_equals() const;
  private:
  bool _internal_has_equals() const;
  public:
  void clear_equals();
  const ::unhinged::persistence::EqualsFilter& equals() const;
  PROTOBUF_NODISCARD ::unhinged::persistence::EqualsFilter* release_equals();
  ::unhinged::persistence::EqualsFilter* mutable_equals();
  void set_allocated_equals(::unhinged::persistence::EqualsFilter* equals);
  private:
  const ::unhinged::persistence::EqualsFilter& _internal_equals() const;
  ::unhinged::persistence::EqualsFilter* _internal_mutable_equals();
  public:
  void unsafe_arena_set_allocated_equals(
      ::unhinged::persistence::EqualsFilter* equals);
  ::unhinged::persistence::EqualsFilter* unsafe_arena_release_equals();

  // .unhinged.persistence.GreaterThanFilter greater_than = 2;
  bool has_greater_than() const;
  private:
  bool _internal_has_greater_than() const;
  public:
  void clear_greater_than();
  const ::unhinged::persistence::GreaterThanFilter& greater_than() const;
  PROTOBUF_NODISCARD ::unhinged::persistence::GreaterThanFilter* release_greater_than();
  ::unhinged::persistence::GreaterThanFilter* mutable_greater_than();
  void set_allocated_greater_than(::unhinged::persistence::GreaterThanFilter* greater_than);
  private:
  const ::unhinged::persistence::GreaterThanFilter& _internal_greater_than() const;
  ::unhinged::persistence::GreaterThanFilter* _internal_mutable_greater_than();
  public:
  void unsafe_arena_set_allocated_greater_than(
      ::unhinged::persistence::GreaterThanFilter* greater_than);
  ::unhinged::persistence::GreaterThanFilter* unsafe_arena_release_greater_than();

  // .unhinged.persistence.LessThanFilter less_than = 3;
  bool has_less_than() const;
  private:
  bool _internal_has_less_than() const;
  public:
  void clear_less_than();
  const ::unhinged::persistence::LessThanFilter& less_than() const;
  PROTOBUF_NODISCARD ::unhinged::persistence::LessThanFilter* release_less_than();
  ::unhinged::persistence::LessThanFilter* mutable_less_than();
  void set_allocated_less_than(::unhinged::persistence::LessThanFilter* less_than);
  private:
  const ::unhinged::persistence::LessThanFilter& _internal_less_than() const;
  ::unhinged::persistence::LessThanFilter* _internal_mutable_less_than();
  public:
  void unsafe_arena_set_allocated_less_than(
      ::unhinged::persistence::LessThanFilter* less_than);
  ::unhinged::persistence::LessThanFilter* unsafe_arena_release_less_than();

  // .unhinged.persistence.InFilter in_filter = 4;
  bool has_in_filter() const;
  private:
  bool _internal_has_in_filter() const;
  public:
  void clear_in_filter();
  const ::unhinged::persistence::InFilter& in_filter() const;
  PROTOBUF_NODISCARD ::unhinged::persistence::InFilter* release_in_filter();
  ::unhinged::persistence::InFilter* mutable_in_filter();
  void set_allocated_in_filter(::unhinged::persistence::InFilter* in_filter);
  private:
  const ::unhinged::persistence::InFilter& _internal_in_filter() const;
  ::unhinged::persistence::InFilter* _internal_mutable_in_filter();
  public:
  void unsafe_arena_set_allocated_in_filter(
      ::unhinged::persistence::InFilter* in_filter);
  ::unhinged::persistence::InFilter* unsafe_arena_release_in_filter();

  // .unhinged.persistence.RangeFilter range = 5;
  bool has_range() const;
  private:
  bool _internal_has_range() const;
  public:
  void clear_range();
  const ::unhinged::persistence::RangeFilter& range() const;
  PROTOBUF_NODISCARD ::unhinged::persistence::RangeFilter* release_range();
  ::unhinged::persistence::RangeFilter* mutable_range();
  void set_allocated_range(::unhinged::persistence::RangeFilter* range);
  private:
  const ::unhinged::persistence::RangeFilter& _internal_range() const;
  ::unhinged::persistence::RangeFilter* _internal_mutable_range();
  public:
  void unsafe_arena_set_allocated_range(
      ::unhinged::persistence::RangeFilter* range);
  ::unhinged::persistence::RangeFilter* unsafe_arena_release_range();

  // .unhinged.persistence.TextSearchFilter text_search = 6;
  bool has_text_search() const;
  private:
  bool _internal_has_text_search() const;
  public:
  void clear_text_search();
  const ::unhinged::persistence::TextSearchFilter& text_search() const;
  PROTOBUF_NODISCARD ::unhinged::persistence::TextSearchFilter* release_text_search();
  ::unhinged::persistence::TextSearchFilter* mutable_text_search();
  void set_allocated_text_search(::unhinged::persistence::TextSearchFilter* text_search);
  private:
  const ::unhinged::persistence::TextSearchFilter& _internal_text_search() const;
  ::unhinged::persistence::TextSearchFilter* _internal_mutable_text_search();
  public:
  void unsafe_arena_set_allocated_text_search(
      ::unhinged::persistence::TextSearchFilter* text_search);
  ::unhinged::persistence::TextSearchFilter* unsafe_arena_release_text_search();

  // .unhinged.persistence.VectorSearchFilter vector_search = 7;
  bool has_vector_search() const;
  private:
  bool _internal_has_vector_search() const;
  public:
  void clear_vector_search();
  const ::unhinged::persistence::VectorSearchFilter& vector_search() const;
  PROTOBUF_NODISCARD ::unhinged::persistence::VectorSearchFilter* release_vector_search();
  ::unhinged::persistence::VectorSearchFilter* mutable_vector_search();
  void set_allocated_vector_search(::unhinged::persistence::VectorSearchFilter* vector_search);
  private:
  const ::unhinged::persistence::VectorSearchFilter& _internal_vector_search() const;
  ::unhinged::persistence::VectorSearchFilter* _internal_mutable_vector_search();
  public:
  void unsafe_arena_set_allocated_vector_search(
      ::unhinged::persistence::VectorSearchFilter* vector_search);
  ::unhinged::persistence::VectorSearchFilter* unsafe_arena_release_vector_search();

  // .unhinged.persistence.AndFilter and_filter = 8;
  bool has_and_filter() const;
  private:
  bool _internal_has_and_filter() const;
  public:
  void clear_and_filter();
  const ::unhinged::persistence::AndFilter& and_filter() const;
  PROTOBUF_NODISCARD ::unhinged::persistence::AndFilter* release_and_filter();
  ::unhinged::persistence::AndFilter* mutable_and_filter();
  void set_allocated_and_filter(::unhinged::persistence::AndFilter* and_filter);
  private:
  const ::unhinged::persistence::AndFilter& _internal_and_filter() const;
  ::unhinged::persistence::AndFilter* _internal_mutable_and_filter();
  public:
  void unsafe_arena_set_allocated_and_filter(
      ::unhinged::persistence::AndFilter* and_filter);
  ::unhinged::persistence::AndFilter* unsafe_arena_release_and_filter();

  // .unhinged.persistence.OrFilter or_filter = 9;
  bool has_or_filter() const;
  private:
  bool _internal_has_or_filter() const;
  public:
  void clear_or_filter();
  const ::unhinged::persistence::OrFilter& or_filter() const;
  PROTOBUF_NODISCARD ::unhinged::persistence::OrFilter* release_or_filter();
  ::unhinged::persistence::OrFilter* mutable_or_filter();
  void set_allocated_or_filter(::unhinged::persistence::OrFilter* or_filter);
  private:
  const ::unhinged::persistence::OrFilter& _internal_or_filter() const;
  ::unhinged::persistence::OrFilter* _internal_mutable_or_filter();
  public:
  void unsafe_arena_set_allocated_or_filter(
      ::unhinged::persistence::OrFilter* or_filter);
  ::unhinged::persistence::OrFilter* unsafe_arena_release_or_filter();

  void clear_criteria();
  CriteriaCase criteria_case() const;
  // @@protoc_insertion_point(class_scope:unhinged.persistence.QueryCriteria)
 private:
  class _Internal;
  void set_has_equals();
  void set_has_greater_than();
  void set_has_less_than();
  void set_has_in_filter();
  void set_has_range();
  void set_has_text_search();
  void set_has_vector_search();
  void set_has_and_filter();
  void set_has_or_filter();

  inline bool has_criteria() const;
  inline void clear_has_criteria();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union CriteriaUnion {
      constexpr CriteriaUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::unhinged::persistence::EqualsFilter* equals_;
      ::unhinged::persistence::GreaterThanFilter* greater_than_;
      ::unhinged::persistence::LessThanFilter* less_than_;
      ::unhinged::persistence::InFilter* in_filter_;
      ::unhinged::persistence::RangeFilter* range_;
      ::unhinged::persistence::TextSearchFilter* text_search_;
      ::unhinged::persistence::VectorSearchFilter* vector_search_;
      ::unhinged::persistence::AndFilter* and_filter_;
      ::unhinged::persistence::OrFilter* or_filter_;
    } criteria_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_persistence_5fplatform_2eproto;
};
// -------------------------------------------------------------------

class EqualsFilter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.persistence.EqualsFilter) */ {
 public:
  inline EqualsFilter() : EqualsFilter(nullptr) {}
  ~EqualsFilter() override;
  explicit PROTOBUF_CONSTEXPR EqualsFilter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EqualsFilter(const EqualsFilter& from);
  EqualsFilter(EqualsFilter&& from) noexcept
    : EqualsFilter() {
    *this = ::std::move(from);
  }

  inline EqualsFilter& operator=(const EqualsFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline EqualsFilter& operator=(EqualsFilter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EqualsFilter& default_instance() {
    return *internal_default_instance();
  }
  static inline const EqualsFilter* internal_default_instance() {
    return reinterpret_cast<const EqualsFilter*>(
               &_EqualsFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(EqualsFilter& a, EqualsFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(EqualsFilter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EqualsFilter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EqualsFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EqualsFilter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EqualsFilter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EqualsFilter& from) {
    EqualsFilter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EqualsFilter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.persistence.EqualsFilter";
  }
  protected:
  explicit EqualsFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string field = 1;
  void clear_field();
  const std::string& field() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field();
  PROTOBUF_NODISCARD std::string* release_field();
  void set_allocated_field(std::string* field);
  private:
  const std::string& _internal_field() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field(const std::string& value);
  std::string* _internal_mutable_field();
  public:

  // .google.protobuf.Any value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::PROTOBUF_NAMESPACE_ID::Any& value() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Any* release_value();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_value();
  void set_allocated_value(::PROTOBUF_NAMESPACE_ID::Any* value);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_value() const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::PROTOBUF_NAMESPACE_ID::Any* value);
  ::PROTOBUF_NAMESPACE_ID::Any* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:unhinged.persistence.EqualsFilter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field_;
    ::PROTOBUF_NAMESPACE_ID::Any* value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_persistence_5fplatform_2eproto;
};
// -------------------------------------------------------------------

class GreaterThanFilter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.persistence.GreaterThanFilter) */ {
 public:
  inline GreaterThanFilter() : GreaterThanFilter(nullptr) {}
  ~GreaterThanFilter() override;
  explicit PROTOBUF_CONSTEXPR GreaterThanFilter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GreaterThanFilter(const GreaterThanFilter& from);
  GreaterThanFilter(GreaterThanFilter&& from) noexcept
    : GreaterThanFilter() {
    *this = ::std::move(from);
  }

  inline GreaterThanFilter& operator=(const GreaterThanFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline GreaterThanFilter& operator=(GreaterThanFilter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GreaterThanFilter& default_instance() {
    return *internal_default_instance();
  }
  static inline const GreaterThanFilter* internal_default_instance() {
    return reinterpret_cast<const GreaterThanFilter*>(
               &_GreaterThanFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GreaterThanFilter& a, GreaterThanFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(GreaterThanFilter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GreaterThanFilter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GreaterThanFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GreaterThanFilter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GreaterThanFilter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GreaterThanFilter& from) {
    GreaterThanFilter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GreaterThanFilter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.persistence.GreaterThanFilter";
  }
  protected:
  explicit GreaterThanFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string field = 1;
  void clear_field();
  const std::string& field() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field();
  PROTOBUF_NODISCARD std::string* release_field();
  void set_allocated_field(std::string* field);
  private:
  const std::string& _internal_field() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field(const std::string& value);
  std::string* _internal_mutable_field();
  public:

  // .google.protobuf.Any value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::PROTOBUF_NAMESPACE_ID::Any& value() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Any* release_value();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_value();
  void set_allocated_value(::PROTOBUF_NAMESPACE_ID::Any* value);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_value() const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::PROTOBUF_NAMESPACE_ID::Any* value);
  ::PROTOBUF_NAMESPACE_ID::Any* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:unhinged.persistence.GreaterThanFilter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field_;
    ::PROTOBUF_NAMESPACE_ID::Any* value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_persistence_5fplatform_2eproto;
};
// -------------------------------------------------------------------

class LessThanFilter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.persistence.LessThanFilter) */ {
 public:
  inline LessThanFilter() : LessThanFilter(nullptr) {}
  ~LessThanFilter() override;
  explicit PROTOBUF_CONSTEXPR LessThanFilter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LessThanFilter(const LessThanFilter& from);
  LessThanFilter(LessThanFilter&& from) noexcept
    : LessThanFilter() {
    *this = ::std::move(from);
  }

  inline LessThanFilter& operator=(const LessThanFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline LessThanFilter& operator=(LessThanFilter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LessThanFilter& default_instance() {
    return *internal_default_instance();
  }
  static inline const LessThanFilter* internal_default_instance() {
    return reinterpret_cast<const LessThanFilter*>(
               &_LessThanFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(LessThanFilter& a, LessThanFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(LessThanFilter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LessThanFilter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LessThanFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LessThanFilter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LessThanFilter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LessThanFilter& from) {
    LessThanFilter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LessThanFilter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.persistence.LessThanFilter";
  }
  protected:
  explicit LessThanFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string field = 1;
  void clear_field();
  const std::string& field() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field();
  PROTOBUF_NODISCARD std::string* release_field();
  void set_allocated_field(std::string* field);
  private:
  const std::string& _internal_field() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field(const std::string& value);
  std::string* _internal_mutable_field();
  public:

  // .google.protobuf.Any value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::PROTOBUF_NAMESPACE_ID::Any& value() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Any* release_value();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_value();
  void set_allocated_value(::PROTOBUF_NAMESPACE_ID::Any* value);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_value() const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::PROTOBUF_NAMESPACE_ID::Any* value);
  ::PROTOBUF_NAMESPACE_ID::Any* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:unhinged.persistence.LessThanFilter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field_;
    ::PROTOBUF_NAMESPACE_ID::Any* value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_persistence_5fplatform_2eproto;
};
// -------------------------------------------------------------------

class InFilter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.persistence.InFilter) */ {
 public:
  inline InFilter() : InFilter(nullptr) {}
  ~InFilter() override;
  explicit PROTOBUF_CONSTEXPR InFilter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InFilter(const InFilter& from);
  InFilter(InFilter&& from) noexcept
    : InFilter() {
    *this = ::std::move(from);
  }

  inline InFilter& operator=(const InFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline InFilter& operator=(InFilter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InFilter& default_instance() {
    return *internal_default_instance();
  }
  static inline const InFilter* internal_default_instance() {
    return reinterpret_cast<const InFilter*>(
               &_InFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(InFilter& a, InFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(InFilter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InFilter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InFilter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InFilter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InFilter& from) {
    InFilter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InFilter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.persistence.InFilter";
  }
  protected:
  explicit InFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 2,
    kFieldFieldNumber = 1,
  };
  // repeated .google.protobuf.Any values = 2;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_values(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any >*
      mutable_values();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_values(int index) const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_add_values();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Any& values(int index) const;
  ::PROTOBUF_NAMESPACE_ID::Any* add_values();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any >&
      values() const;

  // string field = 1;
  void clear_field();
  const std::string& field() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field();
  PROTOBUF_NODISCARD std::string* release_field();
  void set_allocated_field(std::string* field);
  private:
  const std::string& _internal_field() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field(const std::string& value);
  std::string* _internal_mutable_field();
  public:

  // @@protoc_insertion_point(class_scope:unhinged.persistence.InFilter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any > values_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_persistence_5fplatform_2eproto;
};
// -------------------------------------------------------------------

class RangeFilter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.persistence.RangeFilter) */ {
 public:
  inline RangeFilter() : RangeFilter(nullptr) {}
  ~RangeFilter() override;
  explicit PROTOBUF_CONSTEXPR RangeFilter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RangeFilter(const RangeFilter& from);
  RangeFilter(RangeFilter&& from) noexcept
    : RangeFilter() {
    *this = ::std::move(from);
  }

  inline RangeFilter& operator=(const RangeFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline RangeFilter& operator=(RangeFilter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RangeFilter& default_instance() {
    return *internal_default_instance();
  }
  static inline const RangeFilter* internal_default_instance() {
    return reinterpret_cast<const RangeFilter*>(
               &_RangeFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(RangeFilter& a, RangeFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(RangeFilter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RangeFilter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RangeFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RangeFilter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RangeFilter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RangeFilter& from) {
    RangeFilter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RangeFilter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.persistence.RangeFilter";
  }
  protected:
  explicit RangeFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldFieldNumber = 1,
    kMinValueFieldNumber = 2,
    kMaxValueFieldNumber = 3,
  };
  // string field = 1;
  void clear_field();
  const std::string& field() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field();
  PROTOBUF_NODISCARD std::string* release_field();
  void set_allocated_field(std::string* field);
  private:
  const std::string& _internal_field() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field(const std::string& value);
  std::string* _internal_mutable_field();
  public:

  // .google.protobuf.Any min_value = 2;
  bool has_min_value() const;
  private:
  bool _internal_has_min_value() const;
  public:
  void clear_min_value();
  const ::PROTOBUF_NAMESPACE_ID::Any& min_value() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Any* release_min_value();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_min_value();
  void set_allocated_min_value(::PROTOBUF_NAMESPACE_ID::Any* min_value);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_min_value() const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_mutable_min_value();
  public:
  void unsafe_arena_set_allocated_min_value(
      ::PROTOBUF_NAMESPACE_ID::Any* min_value);
  ::PROTOBUF_NAMESPACE_ID::Any* unsafe_arena_release_min_value();

  // .google.protobuf.Any max_value = 3;
  bool has_max_value() const;
  private:
  bool _internal_has_max_value() const;
  public:
  void clear_max_value();
  const ::PROTOBUF_NAMESPACE_ID::Any& max_value() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Any* release_max_value();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_max_value();
  void set_allocated_max_value(::PROTOBUF_NAMESPACE_ID::Any* max_value);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_max_value() const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_mutable_max_value();
  public:
  void unsafe_arena_set_allocated_max_value(
      ::PROTOBUF_NAMESPACE_ID::Any* max_value);
  ::PROTOBUF_NAMESPACE_ID::Any* unsafe_arena_release_max_value();

  // @@protoc_insertion_point(class_scope:unhinged.persistence.RangeFilter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field_;
    ::PROTOBUF_NAMESPACE_ID::Any* min_value_;
    ::PROTOBUF_NAMESPACE_ID::Any* max_value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_persistence_5fplatform_2eproto;
};
// -------------------------------------------------------------------

class TextSearchFilter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.persistence.TextSearchFilter) */ {
 public:
  inline TextSearchFilter() : TextSearchFilter(nullptr) {}
  ~TextSearchFilter() override;
  explicit PROTOBUF_CONSTEXPR TextSearchFilter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TextSearchFilter(const TextSearchFilter& from);
  TextSearchFilter(TextSearchFilter&& from) noexcept
    : TextSearchFilter() {
    *this = ::std::move(from);
  }

  inline TextSearchFilter& operator=(const TextSearchFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline TextSearchFilter& operator=(TextSearchFilter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TextSearchFilter& default_instance() {
    return *internal_default_instance();
  }
  static inline const TextSearchFilter* internal_default_instance() {
    return reinterpret_cast<const TextSearchFilter*>(
               &_TextSearchFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(TextSearchFilter& a, TextSearchFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(TextSearchFilter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TextSearchFilter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TextSearchFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TextSearchFilter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TextSearchFilter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TextSearchFilter& from) {
    TextSearchFilter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TextSearchFilter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.persistence.TextSearchFilter";
  }
  protected:
  explicit TextSearchFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldsFieldNumber = 1,
    kQueryFieldNumber = 2,
    kAnalyzerFieldNumber = 3,
  };
  // repeated string fields = 1;
  int fields_size() const;
  private:
  int _internal_fields_size() const;
  public:
  void clear_fields();
  const std::string& fields(int index) const;
  std::string* mutable_fields(int index);
  void set_fields(int index, const std::string& value);
  void set_fields(int index, std::string&& value);
  void set_fields(int index, const char* value);
  void set_fields(int index, const char* value, size_t size);
  std::string* add_fields();
  void add_fields(const std::string& value);
  void add_fields(std::string&& value);
  void add_fields(const char* value);
  void add_fields(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& fields() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_fields();
  private:
  const std::string& _internal_fields(int index) const;
  std::string* _internal_add_fields();
  public:

  // string query = 2;
  void clear_query();
  const std::string& query() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_query(ArgT0&& arg0, ArgT... args);
  std::string* mutable_query();
  PROTOBUF_NODISCARD std::string* release_query();
  void set_allocated_query(std::string* query);
  private:
  const std::string& _internal_query() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_query(const std::string& value);
  std::string* _internal_mutable_query();
  public:

  // string analyzer = 3;
  void clear_analyzer();
  const std::string& analyzer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_analyzer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_analyzer();
  PROTOBUF_NODISCARD std::string* release_analyzer();
  void set_allocated_analyzer(std::string* analyzer);
  private:
  const std::string& _internal_analyzer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_analyzer(const std::string& value);
  std::string* _internal_mutable_analyzer();
  public:

  // @@protoc_insertion_point(class_scope:unhinged.persistence.TextSearchFilter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> fields_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr query_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr analyzer_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_persistence_5fplatform_2eproto;
};
// -------------------------------------------------------------------

class VectorSearchFilter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.persistence.VectorSearchFilter) */ {
 public:
  inline VectorSearchFilter() : VectorSearchFilter(nullptr) {}
  ~VectorSearchFilter() override;
  explicit PROTOBUF_CONSTEXPR VectorSearchFilter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VectorSearchFilter(const VectorSearchFilter& from);
  VectorSearchFilter(VectorSearchFilter&& from) noexcept
    : VectorSearchFilter() {
    *this = ::std::move(from);
  }

  inline VectorSearchFilter& operator=(const VectorSearchFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorSearchFilter& operator=(VectorSearchFilter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VectorSearchFilter& default_instance() {
    return *internal_default_instance();
  }
  static inline const VectorSearchFilter* internal_default_instance() {
    return reinterpret_cast<const VectorSearchFilter*>(
               &_VectorSearchFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(VectorSearchFilter& a, VectorSearchFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(VectorSearchFilter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VectorSearchFilter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VectorSearchFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VectorSearchFilter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VectorSearchFilter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VectorSearchFilter& from) {
    VectorSearchFilter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VectorSearchFilter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.persistence.VectorSearchFilter";
  }
  protected:
  explicit VectorSearchFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQueryVectorFieldNumber = 2,
    kFieldFieldNumber = 1,
    kDistanceMetricFieldNumber = 5,
    kThresholdFieldNumber = 4,
    kLimitFieldNumber = 3,
  };
  // repeated float query_vector = 2;
  int query_vector_size() const;
  private:
  int _internal_query_vector_size() const;
  public:
  void clear_query_vector();
  private:
  float _internal_query_vector(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_query_vector() const;
  void _internal_add_query_vector(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_query_vector();
  public:
  float query_vector(int index) const;
  void set_query_vector(int index, float value);
  void add_query_vector(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      query_vector() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_query_vector();

  // string field = 1;
  void clear_field();
  const std::string& field() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field();
  PROTOBUF_NODISCARD std::string* release_field();
  void set_allocated_field(std::string* field);
  private:
  const std::string& _internal_field() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field(const std::string& value);
  std::string* _internal_mutable_field();
  public:

  // string distance_metric = 5;
  void clear_distance_metric();
  const std::string& distance_metric() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_distance_metric(ArgT0&& arg0, ArgT... args);
  std::string* mutable_distance_metric();
  PROTOBUF_NODISCARD std::string* release_distance_metric();
  void set_allocated_distance_metric(std::string* distance_metric);
  private:
  const std::string& _internal_distance_metric() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_distance_metric(const std::string& value);
  std::string* _internal_mutable_distance_metric();
  public:

  // double threshold = 4;
  void clear_threshold();
  double threshold() const;
  void set_threshold(double value);
  private:
  double _internal_threshold() const;
  void _internal_set_threshold(double value);
  public:

  // int32 limit = 3;
  void clear_limit();
  int32_t limit() const;
  void set_limit(int32_t value);
  private:
  int32_t _internal_limit() const;
  void _internal_set_limit(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.persistence.VectorSearchFilter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > query_vector_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr distance_metric_;
    double threshold_;
    int32_t limit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_persistence_5fplatform_2eproto;
};
// -------------------------------------------------------------------

class AndFilter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.persistence.AndFilter) */ {
 public:
  inline AndFilter() : AndFilter(nullptr) {}
  ~AndFilter() override;
  explicit PROTOBUF_CONSTEXPR AndFilter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AndFilter(const AndFilter& from);
  AndFilter(AndFilter&& from) noexcept
    : AndFilter() {
    *this = ::std::move(from);
  }

  inline AndFilter& operator=(const AndFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline AndFilter& operator=(AndFilter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AndFilter& default_instance() {
    return *internal_default_instance();
  }
  static inline const AndFilter* internal_default_instance() {
    return reinterpret_cast<const AndFilter*>(
               &_AndFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(AndFilter& a, AndFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(AndFilter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AndFilter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AndFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AndFilter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AndFilter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AndFilter& from) {
    AndFilter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AndFilter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.persistence.AndFilter";
  }
  protected:
  explicit AndFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFiltersFieldNumber = 1,
  };
  // repeated .unhinged.persistence.QueryCriteria filters = 1;
  int filters_size() const;
  private:
  int _internal_filters_size() const;
  public:
  void clear_filters();
  ::unhinged::persistence::QueryCriteria* mutable_filters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::persistence::QueryCriteria >*
      mutable_filters();
  private:
  const ::unhinged::persistence::QueryCriteria& _internal_filters(int index) const;
  ::unhinged::persistence::QueryCriteria* _internal_add_filters();
  public:
  const ::unhinged::persistence::QueryCriteria& filters(int index) const;
  ::unhinged::persistence::QueryCriteria* add_filters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::persistence::QueryCriteria >&
      filters() const;

  // @@protoc_insertion_point(class_scope:unhinged.persistence.AndFilter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::persistence::QueryCriteria > filters_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_persistence_5fplatform_2eproto;
};
// -------------------------------------------------------------------

class OrFilter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.persistence.OrFilter) */ {
 public:
  inline OrFilter() : OrFilter(nullptr) {}
  ~OrFilter() override;
  explicit PROTOBUF_CONSTEXPR OrFilter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrFilter(const OrFilter& from);
  OrFilter(OrFilter&& from) noexcept
    : OrFilter() {
    *this = ::std::move(from);
  }

  inline OrFilter& operator=(const OrFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrFilter& operator=(OrFilter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrFilter& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrFilter* internal_default_instance() {
    return reinterpret_cast<const OrFilter*>(
               &_OrFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(OrFilter& a, OrFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(OrFilter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrFilter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrFilter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrFilter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OrFilter& from) {
    OrFilter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrFilter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.persistence.OrFilter";
  }
  protected:
  explicit OrFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFiltersFieldNumber = 1,
  };
  // repeated .unhinged.persistence.QueryCriteria filters = 1;
  int filters_size() const;
  private:
  int _internal_filters_size() const;
  public:
  void clear_filters();
  ::unhinged::persistence::QueryCriteria* mutable_filters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::persistence::QueryCriteria >*
      mutable_filters();
  private:
  const ::unhinged::persistence::QueryCriteria& _internal_filters(int index) const;
  ::unhinged::persistence::QueryCriteria* _internal_add_filters();
  public:
  const ::unhinged::persistence::QueryCriteria& filters(int index) const;
  ::unhinged::persistence::QueryCriteria* add_filters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::persistence::QueryCriteria >&
      filters() const;

  // @@protoc_insertion_point(class_scope:unhinged.persistence.OrFilter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::persistence::QueryCriteria > filters_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_persistence_5fplatform_2eproto;
};
// -------------------------------------------------------------------

class OrderBy final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.persistence.OrderBy) */ {
 public:
  inline OrderBy() : OrderBy(nullptr) {}
  ~OrderBy() override;
  explicit PROTOBUF_CONSTEXPR OrderBy(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrderBy(const OrderBy& from);
  OrderBy(OrderBy&& from) noexcept
    : OrderBy() {
    *this = ::std::move(from);
  }

  inline OrderBy& operator=(const OrderBy& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderBy& operator=(OrderBy&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrderBy& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrderBy* internal_default_instance() {
    return reinterpret_cast<const OrderBy*>(
               &_OrderBy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(OrderBy& a, OrderBy& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderBy* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderBy* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrderBy* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrderBy>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrderBy& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OrderBy& from) {
    OrderBy::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderBy* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.persistence.OrderBy";
  }
  protected:
  explicit OrderBy(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldFieldNumber = 1,
    kAscendingFieldNumber = 2,
  };
  // string field = 1;
  void clear_field();
  const std::string& field() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field();
  PROTOBUF_NODISCARD std::string* release_field();
  void set_allocated_field(std::string* field);
  private:
  const std::string& _internal_field() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field(const std::string& value);
  std::string* _internal_mutable_field();
  public:

  // bool ascending = 2;
  void clear_ascending();
  bool ascending() const;
  void set_ascending(bool value);
  private:
  bool _internal_ascending() const;
  void _internal_set_ascending(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.persistence.OrderBy)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field_;
    bool ascending_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_persistence_5fplatform_2eproto;
};
// -------------------------------------------------------------------

class QuerySpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.persistence.QuerySpec) */ {
 public:
  inline QuerySpec() : QuerySpec(nullptr) {}
  ~QuerySpec() override;
  explicit PROTOBUF_CONSTEXPR QuerySpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QuerySpec(const QuerySpec& from);
  QuerySpec(QuerySpec&& from) noexcept
    : QuerySpec() {
    *this = ::std::move(from);
  }

  inline QuerySpec& operator=(const QuerySpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuerySpec& operator=(QuerySpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuerySpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const QuerySpec* internal_default_instance() {
    return reinterpret_cast<const QuerySpec*>(
               &_QuerySpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(QuerySpec& a, QuerySpec& b) {
    a.Swap(&b);
  }
  inline void Swap(QuerySpec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuerySpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QuerySpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QuerySpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QuerySpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QuerySpec& from) {
    QuerySpec::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QuerySpec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.persistence.QuerySpec";
  }
  protected:
  explicit QuerySpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProjectionsFieldNumber = 4,
    kOrderByFieldNumber = 5,
    kTableNameFieldNumber = 1,
    kCriteriaFieldNumber = 3,
    kQueryTypeFieldNumber = 2,
    kLimitFieldNumber = 6,
    kOffsetFieldNumber = 7,
  };
  // repeated string projections = 4;
  int projections_size() const;
  private:
  int _internal_projections_size() const;
  public:
  void clear_projections();
  const std::string& projections(int index) const;
  std::string* mutable_projections(int index);
  void set_projections(int index, const std::string& value);
  void set_projections(int index, std::string&& value);
  void set_projections(int index, const char* value);
  void set_projections(int index, const char* value, size_t size);
  std::string* add_projections();
  void add_projections(const std::string& value);
  void add_projections(std::string&& value);
  void add_projections(const char* value);
  void add_projections(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& projections() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_projections();
  private:
  const std::string& _internal_projections(int index) const;
  std::string* _internal_add_projections();
  public:

  // repeated .unhinged.persistence.OrderBy order_by = 5;
  int order_by_size() const;
  private:
  int _internal_order_by_size() const;
  public:
  void clear_order_by();
  ::unhinged::persistence::OrderBy* mutable_order_by(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::persistence::OrderBy >*
      mutable_order_by();
  private:
  const ::unhinged::persistence::OrderBy& _internal_order_by(int index) const;
  ::unhinged::persistence::OrderBy* _internal_add_order_by();
  public:
  const ::unhinged::persistence::OrderBy& order_by(int index) const;
  ::unhinged::persistence::OrderBy* add_order_by();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::persistence::OrderBy >&
      order_by() const;

  // string table_name = 1;
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_NODISCARD std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // .unhinged.persistence.QueryCriteria criteria = 3;
  bool has_criteria() const;
  private:
  bool _internal_has_criteria() const;
  public:
  void clear_criteria();
  const ::unhinged::persistence::QueryCriteria& criteria() const;
  PROTOBUF_NODISCARD ::unhinged::persistence::QueryCriteria* release_criteria();
  ::unhinged::persistence::QueryCriteria* mutable_criteria();
  void set_allocated_criteria(::unhinged::persistence::QueryCriteria* criteria);
  private:
  const ::unhinged::persistence::QueryCriteria& _internal_criteria() const;
  ::unhinged::persistence::QueryCriteria* _internal_mutable_criteria();
  public:
  void unsafe_arena_set_allocated_criteria(
      ::unhinged::persistence::QueryCriteria* criteria);
  ::unhinged::persistence::QueryCriteria* unsafe_arena_release_criteria();

  // .unhinged.persistence.QueryType query_type = 2;
  void clear_query_type();
  ::unhinged::persistence::QueryType query_type() const;
  void set_query_type(::unhinged::persistence::QueryType value);
  private:
  ::unhinged::persistence::QueryType _internal_query_type() const;
  void _internal_set_query_type(::unhinged::persistence::QueryType value);
  public:

  // int32 limit = 6;
  void clear_limit();
  int32_t limit() const;
  void set_limit(int32_t value);
  private:
  int32_t _internal_limit() const;
  void _internal_set_limit(int32_t value);
  public:

  // int32 offset = 7;
  void clear_offset();
  int32_t offset() const;
  void set_offset(int32_t value);
  private:
  int32_t _internal_offset() const;
  void _internal_set_offset(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.persistence.QuerySpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> projections_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::persistence::OrderBy > order_by_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
    ::unhinged::persistence::QueryCriteria* criteria_;
    int query_type_;
    int32_t limit_;
    int32_t offset_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_persistence_5fplatform_2eproto;
};
// -------------------------------------------------------------------

class InsertRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.persistence.InsertRequest) */ {
 public:
  inline InsertRequest() : InsertRequest(nullptr) {}
  ~InsertRequest() override;
  explicit PROTOBUF_CONSTEXPR InsertRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InsertRequest(const InsertRequest& from);
  InsertRequest(InsertRequest&& from) noexcept
    : InsertRequest() {
    *this = ::std::move(from);
  }

  inline InsertRequest& operator=(const InsertRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertRequest& operator=(InsertRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InsertRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const InsertRequest* internal_default_instance() {
    return reinterpret_cast<const InsertRequest*>(
               &_InsertRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(InsertRequest& a, InsertRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(InsertRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsertRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InsertRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InsertRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InsertRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InsertRequest& from) {
    InsertRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InsertRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.persistence.InsertRequest";
  }
  protected:
  explicit InsertRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTableNameFieldNumber = 1,
    kRecordFieldNumber = 2,
    kContextFieldNumber = 3,
  };
  // string table_name = 1;
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_NODISCARD std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // .unhinged.persistence.Record record = 2;
  bool has_record() const;
  private:
  bool _internal_has_record() const;
  public:
  void clear_record();
  const ::unhinged::persistence::Record& record() const;
  PROTOBUF_NODISCARD ::unhinged::persistence::Record* release_record();
  ::unhinged::persistence::Record* mutable_record();
  void set_allocated_record(::unhinged::persistence::Record* record);
  private:
  const ::unhinged::persistence::Record& _internal_record() const;
  ::unhinged::persistence::Record* _internal_mutable_record();
  public:
  void unsafe_arena_set_allocated_record(
      ::unhinged::persistence::Record* record);
  ::unhinged::persistence::Record* unsafe_arena_release_record();

  // .unhinged.persistence.ExecutionContext context = 3;
  bool has_context() const;
  private:
  bool _internal_has_context() const;
  public:
  void clear_context();
  const ::unhinged::persistence::ExecutionContext& context() const;
  PROTOBUF_NODISCARD ::unhinged::persistence::ExecutionContext* release_context();
  ::unhinged::persistence::ExecutionContext* mutable_context();
  void set_allocated_context(::unhinged::persistence::ExecutionContext* context);
  private:
  const ::unhinged::persistence::ExecutionContext& _internal_context() const;
  ::unhinged::persistence::ExecutionContext* _internal_mutable_context();
  public:
  void unsafe_arena_set_allocated_context(
      ::unhinged::persistence::ExecutionContext* context);
  ::unhinged::persistence::ExecutionContext* unsafe_arena_release_context();

  // @@protoc_insertion_point(class_scope:unhinged.persistence.InsertRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
    ::unhinged::persistence::Record* record_;
    ::unhinged::persistence::ExecutionContext* context_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_persistence_5fplatform_2eproto;
};
// -------------------------------------------------------------------

class InsertResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.persistence.InsertResponse) */ {
 public:
  inline InsertResponse() : InsertResponse(nullptr) {}
  ~InsertResponse() override;
  explicit PROTOBUF_CONSTEXPR InsertResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InsertResponse(const InsertResponse& from);
  InsertResponse(InsertResponse&& from) noexcept
    : InsertResponse() {
    *this = ::std::move(from);
  }

  inline InsertResponse& operator=(const InsertResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertResponse& operator=(InsertResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InsertResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const InsertResponse* internal_default_instance() {
    return reinterpret_cast<const InsertResponse*>(
               &_InsertResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(InsertResponse& a, InsertResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(InsertResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsertResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InsertResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InsertResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InsertResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InsertResponse& from) {
    InsertResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InsertResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.persistence.InsertResponse";
  }
  protected:
  explicit InsertResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 3,
    kRecordFieldNumber = 2,
    kExecutionTimeMsFieldNumber = 4,
    kSuccessFieldNumber = 1,
  };
  // string error_message = 3;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // .unhinged.persistence.Record record = 2;
  bool has_record() const;
  private:
  bool _internal_has_record() const;
  public:
  void clear_record();
  const ::unhinged::persistence::Record& record() const;
  PROTOBUF_NODISCARD ::unhinged::persistence::Record* release_record();
  ::unhinged::persistence::Record* mutable_record();
  void set_allocated_record(::unhinged::persistence::Record* record);
  private:
  const ::unhinged::persistence::Record& _internal_record() const;
  ::unhinged::persistence::Record* _internal_mutable_record();
  public:
  void unsafe_arena_set_allocated_record(
      ::unhinged::persistence::Record* record);
  ::unhinged::persistence::Record* unsafe_arena_release_record();

  // int64 execution_time_ms = 4;
  void clear_execution_time_ms();
  int64_t execution_time_ms() const;
  void set_execution_time_ms(int64_t value);
  private:
  int64_t _internal_execution_time_ms() const;
  void _internal_set_execution_time_ms(int64_t value);
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.persistence.InsertResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    ::unhinged::persistence::Record* record_;
    int64_t execution_time_ms_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_persistence_5fplatform_2eproto;
};
// -------------------------------------------------------------------

class InsertBatchRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.persistence.InsertBatchRequest) */ {
 public:
  inline InsertBatchRequest() : InsertBatchRequest(nullptr) {}
  ~InsertBatchRequest() override;
  explicit PROTOBUF_CONSTEXPR InsertBatchRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InsertBatchRequest(const InsertBatchRequest& from);
  InsertBatchRequest(InsertBatchRequest&& from) noexcept
    : InsertBatchRequest() {
    *this = ::std::move(from);
  }

  inline InsertBatchRequest& operator=(const InsertBatchRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertBatchRequest& operator=(InsertBatchRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InsertBatchRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const InsertBatchRequest* internal_default_instance() {
    return reinterpret_cast<const InsertBatchRequest*>(
               &_InsertBatchRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(InsertBatchRequest& a, InsertBatchRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(InsertBatchRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsertBatchRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InsertBatchRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InsertBatchRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InsertBatchRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InsertBatchRequest& from) {
    InsertBatchRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InsertBatchRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.persistence.InsertBatchRequest";
  }
  protected:
  explicit InsertBatchRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRecordsFieldNumber = 2,
    kTableNameFieldNumber = 1,
    kContextFieldNumber = 3,
  };
  // repeated .unhinged.persistence.Record records = 2;
  int records_size() const;
  private:
  int _internal_records_size() const;
  public:
  void clear_records();
  ::unhinged::persistence::Record* mutable_records(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::persistence::Record >*
      mutable_records();
  private:
  const ::unhinged::persistence::Record& _internal_records(int index) const;
  ::unhinged::persistence::Record* _internal_add_records();
  public:
  const ::unhinged::persistence::Record& records(int index) const;
  ::unhinged::persistence::Record* add_records();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::persistence::Record >&
      records() const;

  // string table_name = 1;
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_NODISCARD std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // .unhinged.persistence.ExecutionContext context = 3;
  bool has_context() const;
  private:
  bool _internal_has_context() const;
  public:
  void clear_context();
  const ::unhinged::persistence::ExecutionContext& context() const;
  PROTOBUF_NODISCARD ::unhinged::persistence::ExecutionContext* release_context();
  ::unhinged::persistence::ExecutionContext* mutable_context();
  void set_allocated_context(::unhinged::persistence::ExecutionContext* context);
  private:
  const ::unhinged::persistence::ExecutionContext& _internal_context() const;
  ::unhinged::persistence::ExecutionContext* _internal_mutable_context();
  public:
  void unsafe_arena_set_allocated_context(
      ::unhinged::persistence::ExecutionContext* context);
  ::unhinged::persistence::ExecutionContext* unsafe_arena_release_context();

  // @@protoc_insertion_point(class_scope:unhinged.persistence.InsertBatchRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::persistence::Record > records_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
    ::unhinged::persistence::ExecutionContext* context_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_persistence_5fplatform_2eproto;
};
// -------------------------------------------------------------------

class InsertBatchResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.persistence.InsertBatchResponse) */ {
 public:
  inline InsertBatchResponse() : InsertBatchResponse(nullptr) {}
  ~InsertBatchResponse() override;
  explicit PROTOBUF_CONSTEXPR InsertBatchResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InsertBatchResponse(const InsertBatchResponse& from);
  InsertBatchResponse(InsertBatchResponse&& from) noexcept
    : InsertBatchResponse() {
    *this = ::std::move(from);
  }

  inline InsertBatchResponse& operator=(const InsertBatchResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertBatchResponse& operator=(InsertBatchResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InsertBatchResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const InsertBatchResponse* internal_default_instance() {
    return reinterpret_cast<const InsertBatchResponse*>(
               &_InsertBatchResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(InsertBatchResponse& a, InsertBatchResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(InsertBatchResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsertBatchResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InsertBatchResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InsertBatchResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InsertBatchResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InsertBatchResponse& from) {
    InsertBatchResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InsertBatchResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.persistence.InsertBatchResponse";
  }
  protected:
  explicit InsertBatchResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRecordsFieldNumber = 2,
    kErrorMessageFieldNumber = 4,
    kSuccessFieldNumber = 1,
    kInsertedCountFieldNumber = 3,
    kExecutionTimeMsFieldNumber = 5,
  };
  // repeated .unhinged.persistence.Record records = 2;
  int records_size() const;
  private:
  int _internal_records_size() const;
  public:
  void clear_records();
  ::unhinged::persistence::Record* mutable_records(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::persistence::Record >*
      mutable_records();
  private:
  const ::unhinged::persistence::Record& _internal_records(int index) const;
  ::unhinged::persistence::Record* _internal_add_records();
  public:
  const ::unhinged::persistence::Record& records(int index) const;
  ::unhinged::persistence::Record* add_records();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::persistence::Record >&
      records() const;

  // string error_message = 4;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // int32 inserted_count = 3;
  void clear_inserted_count();
  int32_t inserted_count() const;
  void set_inserted_count(int32_t value);
  private:
  int32_t _internal_inserted_count() const;
  void _internal_set_inserted_count(int32_t value);
  public:

  // int64 execution_time_ms = 5;
  void clear_execution_time_ms();
  int64_t execution_time_ms() const;
  void set_execution_time_ms(int64_t value);
  private:
  int64_t _internal_execution_time_ms() const;
  void _internal_set_execution_time_ms(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.persistence.InsertBatchResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::persistence::Record > records_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    bool success_;
    int32_t inserted_count_;
    int64_t execution_time_ms_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_persistence_5fplatform_2eproto;
};
// -------------------------------------------------------------------

class UpdateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.persistence.UpdateRequest) */ {
 public:
  inline UpdateRequest() : UpdateRequest(nullptr) {}
  ~UpdateRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateRequest(const UpdateRequest& from);
  UpdateRequest(UpdateRequest&& from) noexcept
    : UpdateRequest() {
    *this = ::std::move(from);
  }

  inline UpdateRequest& operator=(const UpdateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateRequest& operator=(UpdateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateRequest*>(
               &_UpdateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(UpdateRequest& a, UpdateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateRequest& from) {
    UpdateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.persistence.UpdateRequest";
  }
  protected:
  explicit UpdateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTableNameFieldNumber = 1,
    kIdFieldNumber = 2,
    kUpdatesFieldNumber = 3,
    kContextFieldNumber = 4,
  };
  // string table_name = 1;
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_NODISCARD std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // string id = 2;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .google.protobuf.Struct updates = 3;
  bool has_updates() const;
  private:
  bool _internal_has_updates() const;
  public:
  void clear_updates();
  const ::PROTOBUF_NAMESPACE_ID::Struct& updates() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_updates();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_updates();
  void set_allocated_updates(::PROTOBUF_NAMESPACE_ID::Struct* updates);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_updates() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_updates();
  public:
  void unsafe_arena_set_allocated_updates(
      ::PROTOBUF_NAMESPACE_ID::Struct* updates);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_updates();

  // .unhinged.persistence.ExecutionContext context = 4;
  bool has_context() const;
  private:
  bool _internal_has_context() const;
  public:
  void clear_context();
  const ::unhinged::persistence::ExecutionContext& context() const;
  PROTOBUF_NODISCARD ::unhinged::persistence::ExecutionContext* release_context();
  ::unhinged::persistence::ExecutionContext* mutable_context();
  void set_allocated_context(::unhinged::persistence::ExecutionContext* context);
  private:
  const ::unhinged::persistence::ExecutionContext& _internal_context() const;
  ::unhinged::persistence::ExecutionContext* _internal_mutable_context();
  public:
  void unsafe_arena_set_allocated_context(
      ::unhinged::persistence::ExecutionContext* context);
  ::unhinged::persistence::ExecutionContext* unsafe_arena_release_context();

  // @@protoc_insertion_point(class_scope:unhinged.persistence.UpdateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::Struct* updates_;
    ::unhinged::persistence::ExecutionContext* context_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_persistence_5fplatform_2eproto;
};
// -------------------------------------------------------------------

class UpdateResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.persistence.UpdateResponse) */ {
 public:
  inline UpdateResponse() : UpdateResponse(nullptr) {}
  ~UpdateResponse() override;
  explicit PROTOBUF_CONSTEXPR UpdateResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateResponse(const UpdateResponse& from);
  UpdateResponse(UpdateResponse&& from) noexcept
    : UpdateResponse() {
    *this = ::std::move(from);
  }

  inline UpdateResponse& operator=(const UpdateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateResponse& operator=(UpdateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateResponse*>(
               &_UpdateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(UpdateResponse& a, UpdateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateResponse& from) {
    UpdateResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.persistence.UpdateResponse";
  }
  protected:
  explicit UpdateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 3,
    kRecordFieldNumber = 2,
    kExecutionTimeMsFieldNumber = 4,
    kSuccessFieldNumber = 1,
  };
  // string error_message = 3;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // .unhinged.persistence.Record record = 2;
  bool has_record() const;
  private:
  bool _internal_has_record() const;
  public:
  void clear_record();
  const ::unhinged::persistence::Record& record() const;
  PROTOBUF_NODISCARD ::unhinged::persistence::Record* release_record();
  ::unhinged::persistence::Record* mutable_record();
  void set_allocated_record(::unhinged::persistence::Record* record);
  private:
  const ::unhinged::persistence::Record& _internal_record() const;
  ::unhinged::persistence::Record* _internal_mutable_record();
  public:
  void unsafe_arena_set_allocated_record(
      ::unhinged::persistence::Record* record);
  ::unhinged::persistence::Record* unsafe_arena_release_record();

  // int64 execution_time_ms = 4;
  void clear_execution_time_ms();
  int64_t execution_time_ms() const;
  void set_execution_time_ms(int64_t value);
  private:
  int64_t _internal_execution_time_ms() const;
  void _internal_set_execution_time_ms(int64_t value);
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.persistence.UpdateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    ::unhinged::persistence::Record* record_;
    int64_t execution_time_ms_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_persistence_5fplatform_2eproto;
};
// -------------------------------------------------------------------

class DeleteRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.persistence.DeleteRequest) */ {
 public:
  inline DeleteRequest() : DeleteRequest(nullptr) {}
  ~DeleteRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteRequest(const DeleteRequest& from);
  DeleteRequest(DeleteRequest&& from) noexcept
    : DeleteRequest() {
    *this = ::std::move(from);
  }

  inline DeleteRequest& operator=(const DeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteRequest& operator=(DeleteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteRequest*>(
               &_DeleteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(DeleteRequest& a, DeleteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteRequest& from) {
    DeleteRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.persistence.DeleteRequest";
  }
  protected:
  explicit DeleteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTableNameFieldNumber = 1,
    kCriteriaFieldNumber = 2,
    kContextFieldNumber = 3,
  };
  // string table_name = 1;
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_NODISCARD std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // .unhinged.persistence.QueryCriteria criteria = 2;
  bool has_criteria() const;
  private:
  bool _internal_has_criteria() const;
  public:
  void clear_criteria();
  const ::unhinged::persistence::QueryCriteria& criteria() const;
  PROTOBUF_NODISCARD ::unhinged::persistence::QueryCriteria* release_criteria();
  ::unhinged::persistence::QueryCriteria* mutable_criteria();
  void set_allocated_criteria(::unhinged::persistence::QueryCriteria* criteria);
  private:
  const ::unhinged::persistence::QueryCriteria& _internal_criteria() const;
  ::unhinged::persistence::QueryCriteria* _internal_mutable_criteria();
  public:
  void unsafe_arena_set_allocated_criteria(
      ::unhinged::persistence::QueryCriteria* criteria);
  ::unhinged::persistence::QueryCriteria* unsafe_arena_release_criteria();

  // .unhinged.persistence.ExecutionContext context = 3;
  bool has_context() const;
  private:
  bool _internal_has_context() const;
  public:
  void clear_context();
  const ::unhinged::persistence::ExecutionContext& context() const;
  PROTOBUF_NODISCARD ::unhinged::persistence::ExecutionContext* release_context();
  ::unhinged::persistence::ExecutionContext* mutable_context();
  void set_allocated_context(::unhinged::persistence::ExecutionContext* context);
  private:
  const ::unhinged::persistence::ExecutionContext& _internal_context() const;
  ::unhinged::persistence::ExecutionContext* _internal_mutable_context();
  public:
  void unsafe_arena_set_allocated_context(
      ::unhinged::persistence::ExecutionContext* context);
  ::unhinged::persistence::ExecutionContext* unsafe_arena_release_context();

  // @@protoc_insertion_point(class_scope:unhinged.persistence.DeleteRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
    ::unhinged::persistence::QueryCriteria* criteria_;
    ::unhinged::persistence::ExecutionContext* context_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_persistence_5fplatform_2eproto;
};
// -------------------------------------------------------------------

class DeleteResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.persistence.DeleteResponse) */ {
 public:
  inline DeleteResponse() : DeleteResponse(nullptr) {}
  ~DeleteResponse() override;
  explicit PROTOBUF_CONSTEXPR DeleteResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteResponse(const DeleteResponse& from);
  DeleteResponse(DeleteResponse&& from) noexcept
    : DeleteResponse() {
    *this = ::std::move(from);
  }

  inline DeleteResponse& operator=(const DeleteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteResponse& operator=(DeleteResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteResponse*>(
               &_DeleteResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(DeleteResponse& a, DeleteResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteResponse& from) {
    DeleteResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.persistence.DeleteResponse";
  }
  protected:
  explicit DeleteResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 3,
    kDeletedCountFieldNumber = 2,
    kExecutionTimeMsFieldNumber = 4,
    kSuccessFieldNumber = 1,
  };
  // string error_message = 3;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // int64 deleted_count = 2;
  void clear_deleted_count();
  int64_t deleted_count() const;
  void set_deleted_count(int64_t value);
  private:
  int64_t _internal_deleted_count() const;
  void _internal_set_deleted_count(int64_t value);
  public:

  // int64 execution_time_ms = 4;
  void clear_execution_time_ms();
  int64_t execution_time_ms() const;
  void set_execution_time_ms(int64_t value);
  private:
  int64_t _internal_execution_time_ms() const;
  void _internal_set_execution_time_ms(int64_t value);
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.persistence.DeleteResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    int64_t deleted_count_;
    int64_t execution_time_ms_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_persistence_5fplatform_2eproto;
};
// -------------------------------------------------------------------

class ExecuteQueryRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.persistence.ExecuteQueryRequest) */ {
 public:
  inline ExecuteQueryRequest() : ExecuteQueryRequest(nullptr) {}
  ~ExecuteQueryRequest() override;
  explicit PROTOBUF_CONSTEXPR ExecuteQueryRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecuteQueryRequest(const ExecuteQueryRequest& from);
  ExecuteQueryRequest(ExecuteQueryRequest&& from) noexcept
    : ExecuteQueryRequest() {
    *this = ::std::move(from);
  }

  inline ExecuteQueryRequest& operator=(const ExecuteQueryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecuteQueryRequest& operator=(ExecuteQueryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecuteQueryRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecuteQueryRequest* internal_default_instance() {
    return reinterpret_cast<const ExecuteQueryRequest*>(
               &_ExecuteQueryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(ExecuteQueryRequest& a, ExecuteQueryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecuteQueryRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecuteQueryRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExecuteQueryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExecuteQueryRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExecuteQueryRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExecuteQueryRequest& from) {
    ExecuteQueryRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecuteQueryRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.persistence.ExecuteQueryRequest";
  }
  protected:
  explicit ExecuteQueryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQueryNameFieldNumber = 1,
    kParametersFieldNumber = 2,
    kContextFieldNumber = 3,
  };
  // string query_name = 1;
  void clear_query_name();
  const std::string& query_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_query_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_query_name();
  PROTOBUF_NODISCARD std::string* release_query_name();
  void set_allocated_query_name(std::string* query_name);
  private:
  const std::string& _internal_query_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_query_name(const std::string& value);
  std::string* _internal_mutable_query_name();
  public:

  // .google.protobuf.Struct parameters = 2;
  bool has_parameters() const;
  private:
  bool _internal_has_parameters() const;
  public:
  void clear_parameters();
  const ::PROTOBUF_NAMESPACE_ID::Struct& parameters() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_parameters();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_parameters();
  void set_allocated_parameters(::PROTOBUF_NAMESPACE_ID::Struct* parameters);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_parameters();
  public:
  void unsafe_arena_set_allocated_parameters(
      ::PROTOBUF_NAMESPACE_ID::Struct* parameters);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_parameters();

  // .unhinged.persistence.ExecutionContext context = 3;
  bool has_context() const;
  private:
  bool _internal_has_context() const;
  public:
  void clear_context();
  const ::unhinged::persistence::ExecutionContext& context() const;
  PROTOBUF_NODISCARD ::unhinged::persistence::ExecutionContext* release_context();
  ::unhinged::persistence::ExecutionContext* mutable_context();
  void set_allocated_context(::unhinged::persistence::ExecutionContext* context);
  private:
  const ::unhinged::persistence::ExecutionContext& _internal_context() const;
  ::unhinged::persistence::ExecutionContext* _internal_mutable_context();
  public:
  void unsafe_arena_set_allocated_context(
      ::unhinged::persistence::ExecutionContext* context);
  ::unhinged::persistence::ExecutionContext* unsafe_arena_release_context();

  // @@protoc_insertion_point(class_scope:unhinged.persistence.ExecuteQueryRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr query_name_;
    ::PROTOBUF_NAMESPACE_ID::Struct* parameters_;
    ::unhinged::persistence::ExecutionContext* context_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_persistence_5fplatform_2eproto;
};
// -------------------------------------------------------------------

class ExecuteQueryResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.persistence.ExecuteQueryResponse) */ {
 public:
  inline ExecuteQueryResponse() : ExecuteQueryResponse(nullptr) {}
  ~ExecuteQueryResponse() override;
  explicit PROTOBUF_CONSTEXPR ExecuteQueryResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecuteQueryResponse(const ExecuteQueryResponse& from);
  ExecuteQueryResponse(ExecuteQueryResponse&& from) noexcept
    : ExecuteQueryResponse() {
    *this = ::std::move(from);
  }

  inline ExecuteQueryResponse& operator=(const ExecuteQueryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecuteQueryResponse& operator=(ExecuteQueryResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecuteQueryResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecuteQueryResponse* internal_default_instance() {
    return reinterpret_cast<const ExecuteQueryResponse*>(
               &_ExecuteQueryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(ExecuteQueryResponse& a, ExecuteQueryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecuteQueryResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecuteQueryResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExecuteQueryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExecuteQueryResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExecuteQueryResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExecuteQueryResponse& from) {
    ExecuteQueryResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecuteQueryResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.persistence.ExecuteQueryResponse";
  }
  protected:
  explicit ExecuteQueryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultsFieldNumber = 2,
    kErrorMessageFieldNumber = 4,
    kCountFieldNumber = 3,
    kSuccessFieldNumber = 1,
    kFromCacheFieldNumber = 6,
    kExecutionTimeMsFieldNumber = 5,
  };
  // repeated .unhinged.persistence.Record results = 2;
  int results_size() const;
  private:
  int _internal_results_size() const;
  public:
  void clear_results();
  ::unhinged::persistence::Record* mutable_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::persistence::Record >*
      mutable_results();
  private:
  const ::unhinged::persistence::Record& _internal_results(int index) const;
  ::unhinged::persistence::Record* _internal_add_results();
  public:
  const ::unhinged::persistence::Record& results(int index) const;
  ::unhinged::persistence::Record* add_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::persistence::Record >&
      results() const;

  // string error_message = 4;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // int32 count = 3;
  void clear_count();
  int32_t count() const;
  void set_count(int32_t value);
  private:
  int32_t _internal_count() const;
  void _internal_set_count(int32_t value);
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // bool from_cache = 6;
  void clear_from_cache();
  bool from_cache() const;
  void set_from_cache(bool value);
  private:
  bool _internal_from_cache() const;
  void _internal_set_from_cache(bool value);
  public:

  // int64 execution_time_ms = 5;
  void clear_execution_time_ms();
  int64_t execution_time_ms() const;
  void set_execution_time_ms(int64_t value);
  private:
  int64_t _internal_execution_time_ms() const;
  void _internal_set_execution_time_ms(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.persistence.ExecuteQueryResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::persistence::Record > results_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    int32_t count_;
    bool success_;
    bool from_cache_;
    int64_t execution_time_ms_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_persistence_5fplatform_2eproto;
};
// -------------------------------------------------------------------

class ExecuteRawQueryRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.persistence.ExecuteRawQueryRequest) */ {
 public:
  inline ExecuteRawQueryRequest() : ExecuteRawQueryRequest(nullptr) {}
  ~ExecuteRawQueryRequest() override;
  explicit PROTOBUF_CONSTEXPR ExecuteRawQueryRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecuteRawQueryRequest(const ExecuteRawQueryRequest& from);
  ExecuteRawQueryRequest(ExecuteRawQueryRequest&& from) noexcept
    : ExecuteRawQueryRequest() {
    *this = ::std::move(from);
  }

  inline ExecuteRawQueryRequest& operator=(const ExecuteRawQueryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecuteRawQueryRequest& operator=(ExecuteRawQueryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecuteRawQueryRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecuteRawQueryRequest* internal_default_instance() {
    return reinterpret_cast<const ExecuteRawQueryRequest*>(
               &_ExecuteRawQueryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(ExecuteRawQueryRequest& a, ExecuteRawQueryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecuteRawQueryRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecuteRawQueryRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExecuteRawQueryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExecuteRawQueryRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExecuteRawQueryRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExecuteRawQueryRequest& from) {
    ExecuteRawQueryRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecuteRawQueryRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.persistence.ExecuteRawQueryRequest";
  }
  protected:
  explicit ExecuteRawQueryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQuerySpecFieldNumber = 1,
    kContextFieldNumber = 2,
  };
  // .unhinged.persistence.QuerySpec query_spec = 1;
  bool has_query_spec() const;
  private:
  bool _internal_has_query_spec() const;
  public:
  void clear_query_spec();
  const ::unhinged::persistence::QuerySpec& query_spec() const;
  PROTOBUF_NODISCARD ::unhinged::persistence::QuerySpec* release_query_spec();
  ::unhinged::persistence::QuerySpec* mutable_query_spec();
  void set_allocated_query_spec(::unhinged::persistence::QuerySpec* query_spec);
  private:
  const ::unhinged::persistence::QuerySpec& _internal_query_spec() const;
  ::unhinged::persistence::QuerySpec* _internal_mutable_query_spec();
  public:
  void unsafe_arena_set_allocated_query_spec(
      ::unhinged::persistence::QuerySpec* query_spec);
  ::unhinged::persistence::QuerySpec* unsafe_arena_release_query_spec();

  // .unhinged.persistence.ExecutionContext context = 2;
  bool has_context() const;
  private:
  bool _internal_has_context() const;
  public:
  void clear_context();
  const ::unhinged::persistence::ExecutionContext& context() const;
  PROTOBUF_NODISCARD ::unhinged::persistence::ExecutionContext* release_context();
  ::unhinged::persistence::ExecutionContext* mutable_context();
  void set_allocated_context(::unhinged::persistence::ExecutionContext* context);
  private:
  const ::unhinged::persistence::ExecutionContext& _internal_context() const;
  ::unhinged::persistence::ExecutionContext* _internal_mutable_context();
  public:
  void unsafe_arena_set_allocated_context(
      ::unhinged::persistence::ExecutionContext* context);
  ::unhinged::persistence::ExecutionContext* unsafe_arena_release_context();

  // @@protoc_insertion_point(class_scope:unhinged.persistence.ExecuteRawQueryRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::unhinged::persistence::QuerySpec* query_spec_;
    ::unhinged::persistence::ExecutionContext* context_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_persistence_5fplatform_2eproto;
};
// -------------------------------------------------------------------

class ExecuteRawQueryResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.persistence.ExecuteRawQueryResponse) */ {
 public:
  inline ExecuteRawQueryResponse() : ExecuteRawQueryResponse(nullptr) {}
  ~ExecuteRawQueryResponse() override;
  explicit PROTOBUF_CONSTEXPR ExecuteRawQueryResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecuteRawQueryResponse(const ExecuteRawQueryResponse& from);
  ExecuteRawQueryResponse(ExecuteRawQueryResponse&& from) noexcept
    : ExecuteRawQueryResponse() {
    *this = ::std::move(from);
  }

  inline ExecuteRawQueryResponse& operator=(const ExecuteRawQueryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecuteRawQueryResponse& operator=(ExecuteRawQueryResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecuteRawQueryResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecuteRawQueryResponse* internal_default_instance() {
    return reinterpret_cast<const ExecuteRawQueryResponse*>(
               &_ExecuteRawQueryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(ExecuteRawQueryResponse& a, ExecuteRawQueryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecuteRawQueryResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecuteRawQueryResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExecuteRawQueryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExecuteRawQueryResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExecuteRawQueryResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExecuteRawQueryResponse& from) {
    ExecuteRawQueryResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecuteRawQueryResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.persistence.ExecuteRawQueryResponse";
  }
  protected:
  explicit ExecuteRawQueryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultsFieldNumber = 2,
    kErrorMessageFieldNumber = 4,
    kSuccessFieldNumber = 1,
    kCountFieldNumber = 3,
    kExecutionTimeMsFieldNumber = 5,
  };
  // repeated .unhinged.persistence.Record results = 2;
  int results_size() const;
  private:
  int _internal_results_size() const;
  public:
  void clear_results();
  ::unhinged::persistence::Record* mutable_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::persistence::Record >*
      mutable_results();
  private:
  const ::unhinged::persistence::Record& _internal_results(int index) const;
  ::unhinged::persistence::Record* _internal_add_results();
  public:
  const ::unhinged::persistence::Record& results(int index) const;
  ::unhinged::persistence::Record* add_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::persistence::Record >&
      results() const;

  // string error_message = 4;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // int32 count = 3;
  void clear_count();
  int32_t count() const;
  void set_count(int32_t value);
  private:
  int32_t _internal_count() const;
  void _internal_set_count(int32_t value);
  public:

  // int64 execution_time_ms = 5;
  void clear_execution_time_ms();
  int64_t execution_time_ms() const;
  void set_execution_time_ms(int64_t value);
  private:
  int64_t _internal_execution_time_ms() const;
  void _internal_set_execution_time_ms(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.persistence.ExecuteRawQueryResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::persistence::Record > results_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    bool success_;
    int32_t count_;
    int64_t execution_time_ms_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_persistence_5fplatform_2eproto;
};
// -------------------------------------------------------------------

class VectorSearchRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.persistence.VectorSearchRequest) */ {
 public:
  inline VectorSearchRequest() : VectorSearchRequest(nullptr) {}
  ~VectorSearchRequest() override;
  explicit PROTOBUF_CONSTEXPR VectorSearchRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VectorSearchRequest(const VectorSearchRequest& from);
  VectorSearchRequest(VectorSearchRequest&& from) noexcept
    : VectorSearchRequest() {
    *this = ::std::move(from);
  }

  inline VectorSearchRequest& operator=(const VectorSearchRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorSearchRequest& operator=(VectorSearchRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VectorSearchRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const VectorSearchRequest* internal_default_instance() {
    return reinterpret_cast<const VectorSearchRequest*>(
               &_VectorSearchRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(VectorSearchRequest& a, VectorSearchRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(VectorSearchRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VectorSearchRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VectorSearchRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VectorSearchRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VectorSearchRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VectorSearchRequest& from) {
    VectorSearchRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VectorSearchRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.persistence.VectorSearchRequest";
  }
  protected:
  explicit VectorSearchRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQueryVectorFieldNumber = 2,
    kTableNameFieldNumber = 1,
    kDistanceMetricFieldNumber = 5,
    kContextFieldNumber = 6,
    kThresholdFieldNumber = 4,
    kLimitFieldNumber = 3,
  };
  // repeated float query_vector = 2;
  int query_vector_size() const;
  private:
  int _internal_query_vector_size() const;
  public:
  void clear_query_vector();
  private:
  float _internal_query_vector(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_query_vector() const;
  void _internal_add_query_vector(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_query_vector();
  public:
  float query_vector(int index) const;
  void set_query_vector(int index, float value);
  void add_query_vector(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      query_vector() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_query_vector();

  // string table_name = 1;
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_NODISCARD std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // string distance_metric = 5;
  void clear_distance_metric();
  const std::string& distance_metric() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_distance_metric(ArgT0&& arg0, ArgT... args);
  std::string* mutable_distance_metric();
  PROTOBUF_NODISCARD std::string* release_distance_metric();
  void set_allocated_distance_metric(std::string* distance_metric);
  private:
  const std::string& _internal_distance_metric() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_distance_metric(const std::string& value);
  std::string* _internal_mutable_distance_metric();
  public:

  // .unhinged.persistence.ExecutionContext context = 6;
  bool has_context() const;
  private:
  bool _internal_has_context() const;
  public:
  void clear_context();
  const ::unhinged::persistence::ExecutionContext& context() const;
  PROTOBUF_NODISCARD ::unhinged::persistence::ExecutionContext* release_context();
  ::unhinged::persistence::ExecutionContext* mutable_context();
  void set_allocated_context(::unhinged::persistence::ExecutionContext* context);
  private:
  const ::unhinged::persistence::ExecutionContext& _internal_context() const;
  ::unhinged::persistence::ExecutionContext* _internal_mutable_context();
  public:
  void unsafe_arena_set_allocated_context(
      ::unhinged::persistence::ExecutionContext* context);
  ::unhinged::persistence::ExecutionContext* unsafe_arena_release_context();

  // double threshold = 4;
  void clear_threshold();
  double threshold() const;
  void set_threshold(double value);
  private:
  double _internal_threshold() const;
  void _internal_set_threshold(double value);
  public:

  // int32 limit = 3;
  void clear_limit();
  int32_t limit() const;
  void set_limit(int32_t value);
  private:
  int32_t _internal_limit() const;
  void _internal_set_limit(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.persistence.VectorSearchRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > query_vector_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr distance_metric_;
    ::unhinged::persistence::ExecutionContext* context_;
    double threshold_;
    int32_t limit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_persistence_5fplatform_2eproto;
};
// -------------------------------------------------------------------

class VectorSearchResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.persistence.VectorSearchResponse) */ {
 public:
  inline VectorSearchResponse() : VectorSearchResponse(nullptr) {}
  ~VectorSearchResponse() override;
  explicit PROTOBUF_CONSTEXPR VectorSearchResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VectorSearchResponse(const VectorSearchResponse& from);
  VectorSearchResponse(VectorSearchResponse&& from) noexcept
    : VectorSearchResponse() {
    *this = ::std::move(from);
  }

  inline VectorSearchResponse& operator=(const VectorSearchResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorSearchResponse& operator=(VectorSearchResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VectorSearchResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const VectorSearchResponse* internal_default_instance() {
    return reinterpret_cast<const VectorSearchResponse*>(
               &_VectorSearchResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(VectorSearchResponse& a, VectorSearchResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(VectorSearchResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VectorSearchResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VectorSearchResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VectorSearchResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VectorSearchResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VectorSearchResponse& from) {
    VectorSearchResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VectorSearchResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.persistence.VectorSearchResponse";
  }
  protected:
  explicit VectorSearchResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultsFieldNumber = 2,
    kErrorMessageFieldNumber = 3,
    kExecutionTimeMsFieldNumber = 4,
    kSuccessFieldNumber = 1,
  };
  // repeated .unhinged.persistence.VectorSearchResult results = 2;
  int results_size() const;
  private:
  int _internal_results_size() const;
  public:
  void clear_results();
  ::unhinged::persistence::VectorSearchResult* mutable_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::persistence::VectorSearchResult >*
      mutable_results();
  private:
  const ::unhinged::persistence::VectorSearchResult& _internal_results(int index) const;
  ::unhinged::persistence::VectorSearchResult* _internal_add_results();
  public:
  const ::unhinged::persistence::VectorSearchResult& results(int index) const;
  ::unhinged::persistence::VectorSearchResult* add_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::persistence::VectorSearchResult >&
      results() const;

  // string error_message = 3;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // int64 execution_time_ms = 4;
  void clear_execution_time_ms();
  int64_t execution_time_ms() const;
  void set_execution_time_ms(int64_t value);
  private:
  int64_t _internal_execution_time_ms() const;
  void _internal_set_execution_time_ms(int64_t value);
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.persistence.VectorSearchResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::persistence::VectorSearchResult > results_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    int64_t execution_time_ms_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_persistence_5fplatform_2eproto;
};
// -------------------------------------------------------------------

class VectorSearchResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.persistence.VectorSearchResult) */ {
 public:
  inline VectorSearchResult() : VectorSearchResult(nullptr) {}
  ~VectorSearchResult() override;
  explicit PROTOBUF_CONSTEXPR VectorSearchResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VectorSearchResult(const VectorSearchResult& from);
  VectorSearchResult(VectorSearchResult&& from) noexcept
    : VectorSearchResult() {
    *this = ::std::move(from);
  }

  inline VectorSearchResult& operator=(const VectorSearchResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorSearchResult& operator=(VectorSearchResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VectorSearchResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const VectorSearchResult* internal_default_instance() {
    return reinterpret_cast<const VectorSearchResult*>(
               &_VectorSearchResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(VectorSearchResult& a, VectorSearchResult& b) {
    a.Swap(&b);
  }
  inline void Swap(VectorSearchResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VectorSearchResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VectorSearchResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VectorSearchResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VectorSearchResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VectorSearchResult& from) {
    VectorSearchResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VectorSearchResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.persistence.VectorSearchResult";
  }
  protected:
  explicit VectorSearchResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRecordFieldNumber = 1,
    kSimilarityScoreFieldNumber = 2,
    kDistanceFieldNumber = 3,
  };
  // .unhinged.persistence.Record record = 1;
  bool has_record() const;
  private:
  bool _internal_has_record() const;
  public:
  void clear_record();
  const ::unhinged::persistence::Record& record() const;
  PROTOBUF_NODISCARD ::unhinged::persistence::Record* release_record();
  ::unhinged::persistence::Record* mutable_record();
  void set_allocated_record(::unhinged::persistence::Record* record);
  private:
  const ::unhinged::persistence::Record& _internal_record() const;
  ::unhinged::persistence::Record* _internal_mutable_record();
  public:
  void unsafe_arena_set_allocated_record(
      ::unhinged::persistence::Record* record);
  ::unhinged::persistence::Record* unsafe_arena_release_record();

  // double similarity_score = 2;
  void clear_similarity_score();
  double similarity_score() const;
  void set_similarity_score(double value);
  private:
  double _internal_similarity_score() const;
  void _internal_set_similarity_score(double value);
  public:

  // double distance = 3;
  void clear_distance();
  double distance() const;
  void set_distance(double value);
  private:
  double _internal_distance() const;
  void _internal_set_distance(double value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.persistence.VectorSearchResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::unhinged::persistence::Record* record_;
    double similarity_score_;
    double distance_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_persistence_5fplatform_2eproto;
};
// -------------------------------------------------------------------

class GraphTraverseRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.persistence.GraphTraverseRequest) */ {
 public:
  inline GraphTraverseRequest() : GraphTraverseRequest(nullptr) {}
  ~GraphTraverseRequest() override;
  explicit PROTOBUF_CONSTEXPR GraphTraverseRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GraphTraverseRequest(const GraphTraverseRequest& from);
  GraphTraverseRequest(GraphTraverseRequest&& from) noexcept
    : GraphTraverseRequest() {
    *this = ::std::move(from);
  }

  inline GraphTraverseRequest& operator=(const GraphTraverseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GraphTraverseRequest& operator=(GraphTraverseRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GraphTraverseRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GraphTraverseRequest* internal_default_instance() {
    return reinterpret_cast<const GraphTraverseRequest*>(
               &_GraphTraverseRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(GraphTraverseRequest& a, GraphTraverseRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GraphTraverseRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GraphTraverseRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GraphTraverseRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GraphTraverseRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GraphTraverseRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GraphTraverseRequest& from) {
    GraphTraverseRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GraphTraverseRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.persistence.GraphTraverseRequest";
  }
  protected:
  explicit GraphTraverseRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTableNameFieldNumber = 1,
    kStartNodeFieldNumber = 2,
    kTraversalSpecFieldNumber = 3,
    kContextFieldNumber = 4,
  };
  // string table_name = 1;
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_NODISCARD std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // string start_node = 2;
  void clear_start_node();
  const std::string& start_node() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_start_node(ArgT0&& arg0, ArgT... args);
  std::string* mutable_start_node();
  PROTOBUF_NODISCARD std::string* release_start_node();
  void set_allocated_start_node(std::string* start_node);
  private:
  const std::string& _internal_start_node() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_start_node(const std::string& value);
  std::string* _internal_mutable_start_node();
  public:

  // .unhinged.persistence.GraphTraversalSpec traversal_spec = 3;
  bool has_traversal_spec() const;
  private:
  bool _internal_has_traversal_spec() const;
  public:
  void clear_traversal_spec();
  const ::unhinged::persistence::GraphTraversalSpec& traversal_spec() const;
  PROTOBUF_NODISCARD ::unhinged::persistence::GraphTraversalSpec* release_traversal_spec();
  ::unhinged::persistence::GraphTraversalSpec* mutable_traversal_spec();
  void set_allocated_traversal_spec(::unhinged::persistence::GraphTraversalSpec* traversal_spec);
  private:
  const ::unhinged::persistence::GraphTraversalSpec& _internal_traversal_spec() const;
  ::unhinged::persistence::GraphTraversalSpec* _internal_mutable_traversal_spec();
  public:
  void unsafe_arena_set_allocated_traversal_spec(
      ::unhinged::persistence::GraphTraversalSpec* traversal_spec);
  ::unhinged::persistence::GraphTraversalSpec* unsafe_arena_release_traversal_spec();

  // .unhinged.persistence.ExecutionContext context = 4;
  bool has_context() const;
  private:
  bool _internal_has_context() const;
  public:
  void clear_context();
  const ::unhinged::persistence::ExecutionContext& context() const;
  PROTOBUF_NODISCARD ::unhinged::persistence::ExecutionContext* release_context();
  ::unhinged::persistence::ExecutionContext* mutable_context();
  void set_allocated_context(::unhinged::persistence::ExecutionContext* context);
  private:
  const ::unhinged::persistence::ExecutionContext& _internal_context() const;
  ::unhinged::persistence::ExecutionContext* _internal_mutable_context();
  public:
  void unsafe_arena_set_allocated_context(
      ::unhinged::persistence::ExecutionContext* context);
  ::unhinged::persistence::ExecutionContext* unsafe_arena_release_context();

  // @@protoc_insertion_point(class_scope:unhinged.persistence.GraphTraverseRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr start_node_;
    ::unhinged::persistence::GraphTraversalSpec* traversal_spec_;
    ::unhinged::persistence::ExecutionContext* context_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_persistence_5fplatform_2eproto;
};
// -------------------------------------------------------------------

class GraphTraverseResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.persistence.GraphTraverseResponse) */ {
 public:
  inline GraphTraverseResponse() : GraphTraverseResponse(nullptr) {}
  ~GraphTraverseResponse() override;
  explicit PROTOBUF_CONSTEXPR GraphTraverseResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GraphTraverseResponse(const GraphTraverseResponse& from);
  GraphTraverseResponse(GraphTraverseResponse&& from) noexcept
    : GraphTraverseResponse() {
    *this = ::std::move(from);
  }

  inline GraphTraverseResponse& operator=(const GraphTraverseResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GraphTraverseResponse& operator=(GraphTraverseResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GraphTraverseResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GraphTraverseResponse* internal_default_instance() {
    return reinterpret_cast<const GraphTraverseResponse*>(
               &_GraphTraverseResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(GraphTraverseResponse& a, GraphTraverseResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GraphTraverseResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GraphTraverseResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GraphTraverseResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GraphTraverseResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GraphTraverseResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GraphTraverseResponse& from) {
    GraphTraverseResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GraphTraverseResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.persistence.GraphTraverseResponse";
  }
  protected:
  explicit GraphTraverseResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodesFieldNumber = 2,
    kEdgesFieldNumber = 3,
    kErrorMessageFieldNumber = 4,
    kExecutionTimeMsFieldNumber = 5,
    kSuccessFieldNumber = 1,
  };
  // repeated .unhinged.persistence.GraphNode nodes = 2;
  int nodes_size() const;
  private:
  int _internal_nodes_size() const;
  public:
  void clear_nodes();
  ::unhinged::persistence::GraphNode* mutable_nodes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::persistence::GraphNode >*
      mutable_nodes();
  private:
  const ::unhinged::persistence::GraphNode& _internal_nodes(int index) const;
  ::unhinged::persistence::GraphNode* _internal_add_nodes();
  public:
  const ::unhinged::persistence::GraphNode& nodes(int index) const;
  ::unhinged::persistence::GraphNode* add_nodes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::persistence::GraphNode >&
      nodes() const;

  // repeated .unhinged.persistence.GraphEdge edges = 3;
  int edges_size() const;
  private:
  int _internal_edges_size() const;
  public:
  void clear_edges();
  ::unhinged::persistence::GraphEdge* mutable_edges(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::persistence::GraphEdge >*
      mutable_edges();
  private:
  const ::unhinged::persistence::GraphEdge& _internal_edges(int index) const;
  ::unhinged::persistence::GraphEdge* _internal_add_edges();
  public:
  const ::unhinged::persistence::GraphEdge& edges(int index) const;
  ::unhinged::persistence::GraphEdge* add_edges();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::persistence::GraphEdge >&
      edges() const;

  // string error_message = 4;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // int64 execution_time_ms = 5;
  void clear_execution_time_ms();
  int64_t execution_time_ms() const;
  void set_execution_time_ms(int64_t value);
  private:
  int64_t _internal_execution_time_ms() const;
  void _internal_set_execution_time_ms(int64_t value);
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.persistence.GraphTraverseResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::persistence::GraphNode > nodes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::persistence::GraphEdge > edges_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    int64_t execution_time_ms_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_persistence_5fplatform_2eproto;
};
// -------------------------------------------------------------------

class GraphTraversalSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.persistence.GraphTraversalSpec) */ {
 public:
  inline GraphTraversalSpec() : GraphTraversalSpec(nullptr) {}
  ~GraphTraversalSpec() override;
  explicit PROTOBUF_CONSTEXPR GraphTraversalSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GraphTraversalSpec(const GraphTraversalSpec& from);
  GraphTraversalSpec(GraphTraversalSpec&& from) noexcept
    : GraphTraversalSpec() {
    *this = ::std::move(from);
  }

  inline GraphTraversalSpec& operator=(const GraphTraversalSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline GraphTraversalSpec& operator=(GraphTraversalSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GraphTraversalSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const GraphTraversalSpec* internal_default_instance() {
    return reinterpret_cast<const GraphTraversalSpec*>(
               &_GraphTraversalSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(GraphTraversalSpec& a, GraphTraversalSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(GraphTraversalSpec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GraphTraversalSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GraphTraversalSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GraphTraversalSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GraphTraversalSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GraphTraversalSpec& from) {
    GraphTraversalSpec::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GraphTraversalSpec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.persistence.GraphTraversalSpec";
  }
  protected:
  explicit GraphTraversalSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRelationshipTypesFieldNumber = 3,
    kNodeFilterFieldNumber = 4,
    kEdgeFilterFieldNumber = 5,
    kTraversalTypeFieldNumber = 1,
    kMaxDepthFieldNumber = 2,
  };
  // repeated string relationship_types = 3;
  int relationship_types_size() const;
  private:
  int _internal_relationship_types_size() const;
  public:
  void clear_relationship_types();
  const std::string& relationship_types(int index) const;
  std::string* mutable_relationship_types(int index);
  void set_relationship_types(int index, const std::string& value);
  void set_relationship_types(int index, std::string&& value);
  void set_relationship_types(int index, const char* value);
  void set_relationship_types(int index, const char* value, size_t size);
  std::string* add_relationship_types();
  void add_relationship_types(const std::string& value);
  void add_relationship_types(std::string&& value);
  void add_relationship_types(const char* value);
  void add_relationship_types(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& relationship_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_relationship_types();
  private:
  const std::string& _internal_relationship_types(int index) const;
  std::string* _internal_add_relationship_types();
  public:

  // .unhinged.persistence.QueryCriteria node_filter = 4;
  bool has_node_filter() const;
  private:
  bool _internal_has_node_filter() const;
  public:
  void clear_node_filter();
  const ::unhinged::persistence::QueryCriteria& node_filter() const;
  PROTOBUF_NODISCARD ::unhinged::persistence::QueryCriteria* release_node_filter();
  ::unhinged::persistence::QueryCriteria* mutable_node_filter();
  void set_allocated_node_filter(::unhinged::persistence::QueryCriteria* node_filter);
  private:
  const ::unhinged::persistence::QueryCriteria& _internal_node_filter() const;
  ::unhinged::persistence::QueryCriteria* _internal_mutable_node_filter();
  public:
  void unsafe_arena_set_allocated_node_filter(
      ::unhinged::persistence::QueryCriteria* node_filter);
  ::unhinged::persistence::QueryCriteria* unsafe_arena_release_node_filter();

  // .unhinged.persistence.QueryCriteria edge_filter = 5;
  bool has_edge_filter() const;
  private:
  bool _internal_has_edge_filter() const;
  public:
  void clear_edge_filter();
  const ::unhinged::persistence::QueryCriteria& edge_filter() const;
  PROTOBUF_NODISCARD ::unhinged::persistence::QueryCriteria* release_edge_filter();
  ::unhinged::persistence::QueryCriteria* mutable_edge_filter();
  void set_allocated_edge_filter(::unhinged::persistence::QueryCriteria* edge_filter);
  private:
  const ::unhinged::persistence::QueryCriteria& _internal_edge_filter() const;
  ::unhinged::persistence::QueryCriteria* _internal_mutable_edge_filter();
  public:
  void unsafe_arena_set_allocated_edge_filter(
      ::unhinged::persistence::QueryCriteria* edge_filter);
  ::unhinged::persistence::QueryCriteria* unsafe_arena_release_edge_filter();

  // .unhinged.persistence.GraphTraversalType traversal_type = 1;
  void clear_traversal_type();
  ::unhinged::persistence::GraphTraversalType traversal_type() const;
  void set_traversal_type(::unhinged::persistence::GraphTraversalType value);
  private:
  ::unhinged::persistence::GraphTraversalType _internal_traversal_type() const;
  void _internal_set_traversal_type(::unhinged::persistence::GraphTraversalType value);
  public:

  // int32 max_depth = 2;
  void clear_max_depth();
  int32_t max_depth() const;
  void set_max_depth(int32_t value);
  private:
  int32_t _internal_max_depth() const;
  void _internal_set_max_depth(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.persistence.GraphTraversalSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> relationship_types_;
    ::unhinged::persistence::QueryCriteria* node_filter_;
    ::unhinged::persistence::QueryCriteria* edge_filter_;
    int traversal_type_;
    int32_t max_depth_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_persistence_5fplatform_2eproto;
};
// -------------------------------------------------------------------

class GraphNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.persistence.GraphNode) */ {
 public:
  inline GraphNode() : GraphNode(nullptr) {}
  ~GraphNode() override;
  explicit PROTOBUF_CONSTEXPR GraphNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GraphNode(const GraphNode& from);
  GraphNode(GraphNode&& from) noexcept
    : GraphNode() {
    *this = ::std::move(from);
  }

  inline GraphNode& operator=(const GraphNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline GraphNode& operator=(GraphNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GraphNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const GraphNode* internal_default_instance() {
    return reinterpret_cast<const GraphNode*>(
               &_GraphNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(GraphNode& a, GraphNode& b) {
    a.Swap(&b);
  }
  inline void Swap(GraphNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GraphNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GraphNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GraphNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GraphNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GraphNode& from) {
    GraphNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GraphNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.persistence.GraphNode";
  }
  protected:
  explicit GraphNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kLabelFieldNumber = 2,
    kPropertiesFieldNumber = 3,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string label = 2;
  void clear_label();
  const std::string& label() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_label(ArgT0&& arg0, ArgT... args);
  std::string* mutable_label();
  PROTOBUF_NODISCARD std::string* release_label();
  void set_allocated_label(std::string* label);
  private:
  const std::string& _internal_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_label(const std::string& value);
  std::string* _internal_mutable_label();
  public:

  // .google.protobuf.Struct properties = 3;
  bool has_properties() const;
  private:
  bool _internal_has_properties() const;
  public:
  void clear_properties();
  const ::PROTOBUF_NAMESPACE_ID::Struct& properties() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_properties();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_properties();
  void set_allocated_properties(::PROTOBUF_NAMESPACE_ID::Struct* properties);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_properties() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_properties();
  public:
  void unsafe_arena_set_allocated_properties(
      ::PROTOBUF_NAMESPACE_ID::Struct* properties);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_properties();

  // @@protoc_insertion_point(class_scope:unhinged.persistence.GraphNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr label_;
    ::PROTOBUF_NAMESPACE_ID::Struct* properties_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_persistence_5fplatform_2eproto;
};
// -------------------------------------------------------------------

class GraphEdge final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.persistence.GraphEdge) */ {
 public:
  inline GraphEdge() : GraphEdge(nullptr) {}
  ~GraphEdge() override;
  explicit PROTOBUF_CONSTEXPR GraphEdge(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GraphEdge(const GraphEdge& from);
  GraphEdge(GraphEdge&& from) noexcept
    : GraphEdge() {
    *this = ::std::move(from);
  }

  inline GraphEdge& operator=(const GraphEdge& from) {
    CopyFrom(from);
    return *this;
  }
  inline GraphEdge& operator=(GraphEdge&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GraphEdge& default_instance() {
    return *internal_default_instance();
  }
  static inline const GraphEdge* internal_default_instance() {
    return reinterpret_cast<const GraphEdge*>(
               &_GraphEdge_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(GraphEdge& a, GraphEdge& b) {
    a.Swap(&b);
  }
  inline void Swap(GraphEdge* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GraphEdge* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GraphEdge* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GraphEdge>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GraphEdge& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GraphEdge& from) {
    GraphEdge::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GraphEdge* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.persistence.GraphEdge";
  }
  protected:
  explicit GraphEdge(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kSourceIdFieldNumber = 2,
    kTargetIdFieldNumber = 3,
    kRelationshipTypeFieldNumber = 4,
    kPropertiesFieldNumber = 5,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string source_id = 2;
  void clear_source_id();
  const std::string& source_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_source_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_source_id();
  PROTOBUF_NODISCARD std::string* release_source_id();
  void set_allocated_source_id(std::string* source_id);
  private:
  const std::string& _internal_source_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source_id(const std::string& value);
  std::string* _internal_mutable_source_id();
  public:

  // string target_id = 3;
  void clear_target_id();
  const std::string& target_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_target_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_target_id();
  PROTOBUF_NODISCARD std::string* release_target_id();
  void set_allocated_target_id(std::string* target_id);
  private:
  const std::string& _internal_target_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target_id(const std::string& value);
  std::string* _internal_mutable_target_id();
  public:

  // string relationship_type = 4;
  void clear_relationship_type();
  const std::string& relationship_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_relationship_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_relationship_type();
  PROTOBUF_NODISCARD std::string* release_relationship_type();
  void set_allocated_relationship_type(std::string* relationship_type);
  private:
  const std::string& _internal_relationship_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_relationship_type(const std::string& value);
  std::string* _internal_mutable_relationship_type();
  public:

  // .google.protobuf.Struct properties = 5;
  bool has_properties() const;
  private:
  bool _internal_has_properties() const;
  public:
  void clear_properties();
  const ::PROTOBUF_NAMESPACE_ID::Struct& properties() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_properties();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_properties();
  void set_allocated_properties(::PROTOBUF_NAMESPACE_ID::Struct* properties);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_properties() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_properties();
  public:
  void unsafe_arena_set_allocated_properties(
      ::PROTOBUF_NAMESPACE_ID::Struct* properties);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_properties();

  // @@protoc_insertion_point(class_scope:unhinged.persistence.GraphEdge)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr target_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr relationship_type_;
    ::PROTOBUF_NAMESPACE_ID::Struct* properties_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_persistence_5fplatform_2eproto;
};
// -------------------------------------------------------------------

class ExecuteOperationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.persistence.ExecuteOperationRequest) */ {
 public:
  inline ExecuteOperationRequest() : ExecuteOperationRequest(nullptr) {}
  ~ExecuteOperationRequest() override;
  explicit PROTOBUF_CONSTEXPR ExecuteOperationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecuteOperationRequest(const ExecuteOperationRequest& from);
  ExecuteOperationRequest(ExecuteOperationRequest&& from) noexcept
    : ExecuteOperationRequest() {
    *this = ::std::move(from);
  }

  inline ExecuteOperationRequest& operator=(const ExecuteOperationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecuteOperationRequest& operator=(ExecuteOperationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecuteOperationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecuteOperationRequest* internal_default_instance() {
    return reinterpret_cast<const ExecuteOperationRequest*>(
               &_ExecuteOperationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(ExecuteOperationRequest& a, ExecuteOperationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecuteOperationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecuteOperationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExecuteOperationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExecuteOperationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExecuteOperationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExecuteOperationRequest& from) {
    ExecuteOperationRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecuteOperationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.persistence.ExecuteOperationRequest";
  }
  protected:
  explicit ExecuteOperationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOperationNameFieldNumber = 1,
    kParametersFieldNumber = 2,
    kContextFieldNumber = 3,
  };
  // string operation_name = 1;
  void clear_operation_name();
  const std::string& operation_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_operation_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_operation_name();
  PROTOBUF_NODISCARD std::string* release_operation_name();
  void set_allocated_operation_name(std::string* operation_name);
  private:
  const std::string& _internal_operation_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operation_name(const std::string& value);
  std::string* _internal_mutable_operation_name();
  public:

  // .google.protobuf.Struct parameters = 2;
  bool has_parameters() const;
  private:
  bool _internal_has_parameters() const;
  public:
  void clear_parameters();
  const ::PROTOBUF_NAMESPACE_ID::Struct& parameters() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_parameters();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_parameters();
  void set_allocated_parameters(::PROTOBUF_NAMESPACE_ID::Struct* parameters);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_parameters();
  public:
  void unsafe_arena_set_allocated_parameters(
      ::PROTOBUF_NAMESPACE_ID::Struct* parameters);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_parameters();

  // .unhinged.persistence.ExecutionContext context = 3;
  bool has_context() const;
  private:
  bool _internal_has_context() const;
  public:
  void clear_context();
  const ::unhinged::persistence::ExecutionContext& context() const;
  PROTOBUF_NODISCARD ::unhinged::persistence::ExecutionContext* release_context();
  ::unhinged::persistence::ExecutionContext* mutable_context();
  void set_allocated_context(::unhinged::persistence::ExecutionContext* context);
  private:
  const ::unhinged::persistence::ExecutionContext& _internal_context() const;
  ::unhinged::persistence::ExecutionContext* _internal_mutable_context();
  public:
  void unsafe_arena_set_allocated_context(
      ::unhinged::persistence::ExecutionContext* context);
  ::unhinged::persistence::ExecutionContext* unsafe_arena_release_context();

  // @@protoc_insertion_point(class_scope:unhinged.persistence.ExecuteOperationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr operation_name_;
    ::PROTOBUF_NAMESPACE_ID::Struct* parameters_;
    ::unhinged::persistence::ExecutionContext* context_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_persistence_5fplatform_2eproto;
};
// -------------------------------------------------------------------

class ExecuteOperationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.persistence.ExecuteOperationResponse) */ {
 public:
  inline ExecuteOperationResponse() : ExecuteOperationResponse(nullptr) {}
  ~ExecuteOperationResponse() override;
  explicit PROTOBUF_CONSTEXPR ExecuteOperationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecuteOperationResponse(const ExecuteOperationResponse& from);
  ExecuteOperationResponse(ExecuteOperationResponse&& from) noexcept
    : ExecuteOperationResponse() {
    *this = ::std::move(from);
  }

  inline ExecuteOperationResponse& operator=(const ExecuteOperationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecuteOperationResponse& operator=(ExecuteOperationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecuteOperationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecuteOperationResponse* internal_default_instance() {
    return reinterpret_cast<const ExecuteOperationResponse*>(
               &_ExecuteOperationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(ExecuteOperationResponse& a, ExecuteOperationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecuteOperationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecuteOperationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExecuteOperationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExecuteOperationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExecuteOperationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExecuteOperationResponse& from) {
    ExecuteOperationResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecuteOperationResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.persistence.ExecuteOperationResponse";
  }
  protected:
  explicit ExecuteOperationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAffectedTablesFieldNumber = 5,
    kErrorMessageFieldNumber = 3,
    kResultFieldNumber = 2,
    kExecutionTimeMsFieldNumber = 4,
    kSuccessFieldNumber = 1,
  };
  // repeated string affected_tables = 5;
  int affected_tables_size() const;
  private:
  int _internal_affected_tables_size() const;
  public:
  void clear_affected_tables();
  const std::string& affected_tables(int index) const;
  std::string* mutable_affected_tables(int index);
  void set_affected_tables(int index, const std::string& value);
  void set_affected_tables(int index, std::string&& value);
  void set_affected_tables(int index, const char* value);
  void set_affected_tables(int index, const char* value, size_t size);
  std::string* add_affected_tables();
  void add_affected_tables(const std::string& value);
  void add_affected_tables(std::string&& value);
  void add_affected_tables(const char* value);
  void add_affected_tables(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& affected_tables() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_affected_tables();
  private:
  const std::string& _internal_affected_tables(int index) const;
  std::string* _internal_add_affected_tables();
  public:

  // string error_message = 3;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // .google.protobuf.Any result = 2;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::PROTOBUF_NAMESPACE_ID::Any& result() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Any* release_result();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_result();
  void set_allocated_result(::PROTOBUF_NAMESPACE_ID::Any* result);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_result() const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::PROTOBUF_NAMESPACE_ID::Any* result);
  ::PROTOBUF_NAMESPACE_ID::Any* unsafe_arena_release_result();

  // int64 execution_time_ms = 4;
  void clear_execution_time_ms();
  int64_t execution_time_ms() const;
  void set_execution_time_ms(int64_t value);
  private:
  int64_t _internal_execution_time_ms() const;
  void _internal_set_execution_time_ms(int64_t value);
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.persistence.ExecuteOperationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> affected_tables_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    ::PROTOBUF_NAMESPACE_ID::Any* result_;
    int64_t execution_time_ms_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_persistence_5fplatform_2eproto;
};
// -------------------------------------------------------------------

class HealthCheckRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.persistence.HealthCheckRequest) */ {
 public:
  inline HealthCheckRequest() : HealthCheckRequest(nullptr) {}
  ~HealthCheckRequest() override;
  explicit PROTOBUF_CONSTEXPR HealthCheckRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HealthCheckRequest(const HealthCheckRequest& from);
  HealthCheckRequest(HealthCheckRequest&& from) noexcept
    : HealthCheckRequest() {
    *this = ::std::move(from);
  }

  inline HealthCheckRequest& operator=(const HealthCheckRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HealthCheckRequest& operator=(HealthCheckRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HealthCheckRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HealthCheckRequest* internal_default_instance() {
    return reinterpret_cast<const HealthCheckRequest*>(
               &_HealthCheckRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(HealthCheckRequest& a, HealthCheckRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HealthCheckRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HealthCheckRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HealthCheckRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HealthCheckRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HealthCheckRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HealthCheckRequest& from) {
    HealthCheckRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HealthCheckRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.persistence.HealthCheckRequest";
  }
  protected:
  explicit HealthCheckRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIncludeDetailsFieldNumber = 1,
  };
  // bool include_details = 1;
  void clear_include_details();
  bool include_details() const;
  void set_include_details(bool value);
  private:
  bool _internal_include_details() const;
  void _internal_set_include_details(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.persistence.HealthCheckRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool include_details_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_persistence_5fplatform_2eproto;
};
// -------------------------------------------------------------------

class HealthCheckResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.persistence.HealthCheckResponse) */ {
 public:
  inline HealthCheckResponse() : HealthCheckResponse(nullptr) {}
  ~HealthCheckResponse() override;
  explicit PROTOBUF_CONSTEXPR HealthCheckResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HealthCheckResponse(const HealthCheckResponse& from);
  HealthCheckResponse(HealthCheckResponse&& from) noexcept
    : HealthCheckResponse() {
    *this = ::std::move(from);
  }

  inline HealthCheckResponse& operator=(const HealthCheckResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline HealthCheckResponse& operator=(HealthCheckResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HealthCheckResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const HealthCheckResponse* internal_default_instance() {
    return reinterpret_cast<const HealthCheckResponse*>(
               &_HealthCheckResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(HealthCheckResponse& a, HealthCheckResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(HealthCheckResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HealthCheckResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HealthCheckResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HealthCheckResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HealthCheckResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HealthCheckResponse& from) {
    HealthCheckResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HealthCheckResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.persistence.HealthCheckResponse";
  }
  protected:
  explicit HealthCheckResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTechnologyHealthFieldNumber = 4,
    kVersionFieldNumber = 2,
    kUptimeSecondsFieldNumber = 3,
    kHealthyFieldNumber = 1,
  };
  // repeated .unhinged.persistence.TechnologyHealth technology_health = 4;
  int technology_health_size() const;
  private:
  int _internal_technology_health_size() const;
  public:
  void clear_technology_health();
  ::unhinged::persistence::TechnologyHealth* mutable_technology_health(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::persistence::TechnologyHealth >*
      mutable_technology_health();
  private:
  const ::unhinged::persistence::TechnologyHealth& _internal_technology_health(int index) const;
  ::unhinged::persistence::TechnologyHealth* _internal_add_technology_health();
  public:
  const ::unhinged::persistence::TechnologyHealth& technology_health(int index) const;
  ::unhinged::persistence::TechnologyHealth* add_technology_health();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::persistence::TechnologyHealth >&
      technology_health() const;

  // string version = 2;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // int64 uptime_seconds = 3;
  void clear_uptime_seconds();
  int64_t uptime_seconds() const;
  void set_uptime_seconds(int64_t value);
  private:
  int64_t _internal_uptime_seconds() const;
  void _internal_set_uptime_seconds(int64_t value);
  public:

  // bool healthy = 1;
  void clear_healthy();
  bool healthy() const;
  void set_healthy(bool value);
  private:
  bool _internal_healthy() const;
  void _internal_set_healthy(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.persistence.HealthCheckResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::persistence::TechnologyHealth > technology_health_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    int64_t uptime_seconds_;
    bool healthy_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_persistence_5fplatform_2eproto;
};
// -------------------------------------------------------------------

class TechnologyHealth final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.persistence.TechnologyHealth) */ {
 public:
  inline TechnologyHealth() : TechnologyHealth(nullptr) {}
  ~TechnologyHealth() override;
  explicit PROTOBUF_CONSTEXPR TechnologyHealth(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TechnologyHealth(const TechnologyHealth& from);
  TechnologyHealth(TechnologyHealth&& from) noexcept
    : TechnologyHealth() {
    *this = ::std::move(from);
  }

  inline TechnologyHealth& operator=(const TechnologyHealth& from) {
    CopyFrom(from);
    return *this;
  }
  inline TechnologyHealth& operator=(TechnologyHealth&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TechnologyHealth& default_instance() {
    return *internal_default_instance();
  }
  static inline const TechnologyHealth* internal_default_instance() {
    return reinterpret_cast<const TechnologyHealth*>(
               &_TechnologyHealth_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(TechnologyHealth& a, TechnologyHealth& b) {
    a.Swap(&b);
  }
  inline void Swap(TechnologyHealth* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TechnologyHealth* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TechnologyHealth* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TechnologyHealth>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TechnologyHealth& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TechnologyHealth& from) {
    TechnologyHealth::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TechnologyHealth* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.persistence.TechnologyHealth";
  }
  protected:
  explicit TechnologyHealth(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTechnologyFieldNumber = 1,
    kStatusFieldNumber = 3,
    kErrorMessageFieldNumber = 5,
    kResponseTimeMsFieldNumber = 4,
    kHealthyFieldNumber = 2,
  };
  // string technology = 1;
  void clear_technology();
  const std::string& technology() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_technology(ArgT0&& arg0, ArgT... args);
  std::string* mutable_technology();
  PROTOBUF_NODISCARD std::string* release_technology();
  void set_allocated_technology(std::string* technology);
  private:
  const std::string& _internal_technology() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_technology(const std::string& value);
  std::string* _internal_mutable_technology();
  public:

  // string status = 3;
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // string error_message = 5;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // int64 response_time_ms = 4;
  void clear_response_time_ms();
  int64_t response_time_ms() const;
  void set_response_time_ms(int64_t value);
  private:
  int64_t _internal_response_time_ms() const;
  void _internal_set_response_time_ms(int64_t value);
  public:

  // bool healthy = 2;
  void clear_healthy();
  bool healthy() const;
  void set_healthy(bool value);
  private:
  bool _internal_healthy() const;
  void _internal_set_healthy(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.persistence.TechnologyHealth)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr technology_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    int64_t response_time_ms_;
    bool healthy_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_persistence_5fplatform_2eproto;
};
// -------------------------------------------------------------------

class GetPlatformInfoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:unhinged.persistence.GetPlatformInfoRequest) */ {
 public:
  inline GetPlatformInfoRequest() : GetPlatformInfoRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetPlatformInfoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetPlatformInfoRequest(const GetPlatformInfoRequest& from);
  GetPlatformInfoRequest(GetPlatformInfoRequest&& from) noexcept
    : GetPlatformInfoRequest() {
    *this = ::std::move(from);
  }

  inline GetPlatformInfoRequest& operator=(const GetPlatformInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPlatformInfoRequest& operator=(GetPlatformInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPlatformInfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPlatformInfoRequest* internal_default_instance() {
    return reinterpret_cast<const GetPlatformInfoRequest*>(
               &_GetPlatformInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(GetPlatformInfoRequest& a, GetPlatformInfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPlatformInfoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPlatformInfoRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPlatformInfoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetPlatformInfoRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetPlatformInfoRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetPlatformInfoRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.persistence.GetPlatformInfoRequest";
  }
  protected:
  explicit GetPlatformInfoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:unhinged.persistence.GetPlatformInfoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_persistence_5fplatform_2eproto;
};
// -------------------------------------------------------------------

class GetPlatformInfoResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.persistence.GetPlatformInfoResponse) */ {
 public:
  inline GetPlatformInfoResponse() : GetPlatformInfoResponse(nullptr) {}
  ~GetPlatformInfoResponse() override;
  explicit PROTOBUF_CONSTEXPR GetPlatformInfoResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetPlatformInfoResponse(const GetPlatformInfoResponse& from);
  GetPlatformInfoResponse(GetPlatformInfoResponse&& from) noexcept
    : GetPlatformInfoResponse() {
    *this = ::std::move(from);
  }

  inline GetPlatformInfoResponse& operator=(const GetPlatformInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPlatformInfoResponse& operator=(GetPlatformInfoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPlatformInfoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPlatformInfoResponse* internal_default_instance() {
    return reinterpret_cast<const GetPlatformInfoResponse*>(
               &_GetPlatformInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(GetPlatformInfoResponse& a, GetPlatformInfoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPlatformInfoResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPlatformInfoResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPlatformInfoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetPlatformInfoResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetPlatformInfoResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetPlatformInfoResponse& from) {
    GetPlatformInfoResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetPlatformInfoResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.persistence.GetPlatformInfoResponse";
  }
  protected:
  explicit GetPlatformInfoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSupportedTechnologiesFieldNumber = 3,
    kSupportedFeaturesFieldNumber = 4,
    kPlatformNameFieldNumber = 1,
    kVersionFieldNumber = 2,
    kConfigurationFieldNumber = 5,
  };
  // repeated string supported_technologies = 3;
  int supported_technologies_size() const;
  private:
  int _internal_supported_technologies_size() const;
  public:
  void clear_supported_technologies();
  const std::string& supported_technologies(int index) const;
  std::string* mutable_supported_technologies(int index);
  void set_supported_technologies(int index, const std::string& value);
  void set_supported_technologies(int index, std::string&& value);
  void set_supported_technologies(int index, const char* value);
  void set_supported_technologies(int index, const char* value, size_t size);
  std::string* add_supported_technologies();
  void add_supported_technologies(const std::string& value);
  void add_supported_technologies(std::string&& value);
  void add_supported_technologies(const char* value);
  void add_supported_technologies(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& supported_technologies() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_supported_technologies();
  private:
  const std::string& _internal_supported_technologies(int index) const;
  std::string* _internal_add_supported_technologies();
  public:

  // repeated string supported_features = 4;
  int supported_features_size() const;
  private:
  int _internal_supported_features_size() const;
  public:
  void clear_supported_features();
  const std::string& supported_features(int index) const;
  std::string* mutable_supported_features(int index);
  void set_supported_features(int index, const std::string& value);
  void set_supported_features(int index, std::string&& value);
  void set_supported_features(int index, const char* value);
  void set_supported_features(int index, const char* value, size_t size);
  std::string* add_supported_features();
  void add_supported_features(const std::string& value);
  void add_supported_features(std::string&& value);
  void add_supported_features(const char* value);
  void add_supported_features(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& supported_features() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_supported_features();
  private:
  const std::string& _internal_supported_features(int index) const;
  std::string* _internal_add_supported_features();
  public:

  // string platform_name = 1;
  void clear_platform_name();
  const std::string& platform_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_platform_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_platform_name();
  PROTOBUF_NODISCARD std::string* release_platform_name();
  void set_allocated_platform_name(std::string* platform_name);
  private:
  const std::string& _internal_platform_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_platform_name(const std::string& value);
  std::string* _internal_mutable_platform_name();
  public:

  // string version = 2;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // .google.protobuf.Struct configuration = 5;
  bool has_configuration() const;
  private:
  bool _internal_has_configuration() const;
  public:
  void clear_configuration();
  const ::PROTOBUF_NAMESPACE_ID::Struct& configuration() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_configuration();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_configuration();
  void set_allocated_configuration(::PROTOBUF_NAMESPACE_ID::Struct* configuration);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_configuration() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_configuration();
  public:
  void unsafe_arena_set_allocated_configuration(
      ::PROTOBUF_NAMESPACE_ID::Struct* configuration);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_configuration();

  // @@protoc_insertion_point(class_scope:unhinged.persistence.GetPlatformInfoResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> supported_technologies_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> supported_features_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr platform_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::Struct* configuration_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_persistence_5fplatform_2eproto;
};
// -------------------------------------------------------------------

class GetMetricsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.persistence.GetMetricsRequest) */ {
 public:
  inline GetMetricsRequest() : GetMetricsRequest(nullptr) {}
  ~GetMetricsRequest() override;
  explicit PROTOBUF_CONSTEXPR GetMetricsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetMetricsRequest(const GetMetricsRequest& from);
  GetMetricsRequest(GetMetricsRequest&& from) noexcept
    : GetMetricsRequest() {
    *this = ::std::move(from);
  }

  inline GetMetricsRequest& operator=(const GetMetricsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetMetricsRequest& operator=(GetMetricsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetMetricsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetMetricsRequest* internal_default_instance() {
    return reinterpret_cast<const GetMetricsRequest*>(
               &_GetMetricsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(GetMetricsRequest& a, GetMetricsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetMetricsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetMetricsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetMetricsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetMetricsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetMetricsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetMetricsRequest& from) {
    GetMetricsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetMetricsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.persistence.GetMetricsRequest";
  }
  protected:
  explicit GetMetricsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFormatFieldNumber = 1,
  };
  // string format = 1;
  void clear_format();
  const std::string& format() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_format(ArgT0&& arg0, ArgT... args);
  std::string* mutable_format();
  PROTOBUF_NODISCARD std::string* release_format();
  void set_allocated_format(std::string* format);
  private:
  const std::string& _internal_format() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_format(const std::string& value);
  std::string* _internal_mutable_format();
  public:

  // @@protoc_insertion_point(class_scope:unhinged.persistence.GetMetricsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr format_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_persistence_5fplatform_2eproto;
};
// -------------------------------------------------------------------

class GetMetricsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.persistence.GetMetricsResponse) */ {
 public:
  inline GetMetricsResponse() : GetMetricsResponse(nullptr) {}
  ~GetMetricsResponse() override;
  explicit PROTOBUF_CONSTEXPR GetMetricsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetMetricsResponse(const GetMetricsResponse& from);
  GetMetricsResponse(GetMetricsResponse&& from) noexcept
    : GetMetricsResponse() {
    *this = ::std::move(from);
  }

  inline GetMetricsResponse& operator=(const GetMetricsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetMetricsResponse& operator=(GetMetricsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetMetricsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetMetricsResponse* internal_default_instance() {
    return reinterpret_cast<const GetMetricsResponse*>(
               &_GetMetricsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(GetMetricsResponse& a, GetMetricsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetMetricsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetMetricsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetMetricsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetMetricsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetMetricsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetMetricsResponse& from) {
    GetMetricsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetMetricsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.persistence.GetMetricsResponse";
  }
  protected:
  explicit GetMetricsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFormatFieldNumber = 1,
    kMetricsDataFieldNumber = 2,
    kCollectedAtFieldNumber = 3,
  };
  // string format = 1;
  void clear_format();
  const std::string& format() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_format(ArgT0&& arg0, ArgT... args);
  std::string* mutable_format();
  PROTOBUF_NODISCARD std::string* release_format();
  void set_allocated_format(std::string* format);
  private:
  const std::string& _internal_format() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_format(const std::string& value);
  std::string* _internal_mutable_format();
  public:

  // string metrics_data = 2;
  void clear_metrics_data();
  const std::string& metrics_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_metrics_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_metrics_data();
  PROTOBUF_NODISCARD std::string* release_metrics_data();
  void set_allocated_metrics_data(std::string* metrics_data);
  private:
  const std::string& _internal_metrics_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_metrics_data(const std::string& value);
  std::string* _internal_mutable_metrics_data();
  public:

  // .google.protobuf.Timestamp collected_at = 3;
  bool has_collected_at() const;
  private:
  bool _internal_has_collected_at() const;
  public:
  void clear_collected_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& collected_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_collected_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_collected_at();
  void set_allocated_collected_at(::PROTOBUF_NAMESPACE_ID::Timestamp* collected_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_collected_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_collected_at();
  public:
  void unsafe_arena_set_allocated_collected_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* collected_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_collected_at();

  // @@protoc_insertion_point(class_scope:unhinged.persistence.GetMetricsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr format_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr metrics_data_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* collected_at_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_persistence_5fplatform_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ExecutionContext

// string request_id = 1;
inline void ExecutionContext::clear_request_id() {
  _impl_.request_id_.ClearToEmpty();
}
inline const std::string& ExecutionContext::request_id() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.ExecutionContext.request_id)
  return _internal_request_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecutionContext::set_request_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.request_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.persistence.ExecutionContext.request_id)
}
inline std::string* ExecutionContext::mutable_request_id() {
  std::string* _s = _internal_mutable_request_id();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.ExecutionContext.request_id)
  return _s;
}
inline const std::string& ExecutionContext::_internal_request_id() const {
  return _impl_.request_id_.Get();
}
inline void ExecutionContext::_internal_set_request_id(const std::string& value) {
  
  _impl_.request_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ExecutionContext::_internal_mutable_request_id() {
  
  return _impl_.request_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ExecutionContext::release_request_id() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.ExecutionContext.request_id)
  return _impl_.request_id_.Release();
}
inline void ExecutionContext::set_allocated_request_id(std::string* request_id) {
  if (request_id != nullptr) {
    
  } else {
    
  }
  _impl_.request_id_.SetAllocated(request_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.request_id_.IsDefault()) {
    _impl_.request_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.ExecutionContext.request_id)
}

// string user_id = 2;
inline void ExecutionContext::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& ExecutionContext::user_id() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.ExecutionContext.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecutionContext::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.persistence.ExecutionContext.user_id)
}
inline std::string* ExecutionContext::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.ExecutionContext.user_id)
  return _s;
}
inline const std::string& ExecutionContext::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void ExecutionContext::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ExecutionContext::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ExecutionContext::release_user_id() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.ExecutionContext.user_id)
  return _impl_.user_id_.Release();
}
inline void ExecutionContext::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.ExecutionContext.user_id)
}

// string session_id = 3;
inline void ExecutionContext::clear_session_id() {
  _impl_.session_id_.ClearToEmpty();
}
inline const std::string& ExecutionContext::session_id() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.ExecutionContext.session_id)
  return _internal_session_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecutionContext::set_session_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.session_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.persistence.ExecutionContext.session_id)
}
inline std::string* ExecutionContext::mutable_session_id() {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.ExecutionContext.session_id)
  return _s;
}
inline const std::string& ExecutionContext::_internal_session_id() const {
  return _impl_.session_id_.Get();
}
inline void ExecutionContext::_internal_set_session_id(const std::string& value) {
  
  _impl_.session_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ExecutionContext::_internal_mutable_session_id() {
  
  return _impl_.session_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ExecutionContext::release_session_id() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.ExecutionContext.session_id)
  return _impl_.session_id_.Release();
}
inline void ExecutionContext::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  _impl_.session_id_.SetAllocated(session_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.session_id_.IsDefault()) {
    _impl_.session_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.ExecutionContext.session_id)
}

// string trace_id = 4;
inline void ExecutionContext::clear_trace_id() {
  _impl_.trace_id_.ClearToEmpty();
}
inline const std::string& ExecutionContext::trace_id() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.ExecutionContext.trace_id)
  return _internal_trace_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecutionContext::set_trace_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.trace_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.persistence.ExecutionContext.trace_id)
}
inline std::string* ExecutionContext::mutable_trace_id() {
  std::string* _s = _internal_mutable_trace_id();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.ExecutionContext.trace_id)
  return _s;
}
inline const std::string& ExecutionContext::_internal_trace_id() const {
  return _impl_.trace_id_.Get();
}
inline void ExecutionContext::_internal_set_trace_id(const std::string& value) {
  
  _impl_.trace_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ExecutionContext::_internal_mutable_trace_id() {
  
  return _impl_.trace_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ExecutionContext::release_trace_id() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.ExecutionContext.trace_id)
  return _impl_.trace_id_.Release();
}
inline void ExecutionContext::set_allocated_trace_id(std::string* trace_id) {
  if (trace_id != nullptr) {
    
  } else {
    
  }
  _impl_.trace_id_.SetAllocated(trace_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.trace_id_.IsDefault()) {
    _impl_.trace_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.ExecutionContext.trace_id)
}

// string span_id = 5;
inline void ExecutionContext::clear_span_id() {
  _impl_.span_id_.ClearToEmpty();
}
inline const std::string& ExecutionContext::span_id() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.ExecutionContext.span_id)
  return _internal_span_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecutionContext::set_span_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.span_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.persistence.ExecutionContext.span_id)
}
inline std::string* ExecutionContext::mutable_span_id() {
  std::string* _s = _internal_mutable_span_id();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.ExecutionContext.span_id)
  return _s;
}
inline const std::string& ExecutionContext::_internal_span_id() const {
  return _impl_.span_id_.Get();
}
inline void ExecutionContext::_internal_set_span_id(const std::string& value) {
  
  _impl_.span_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ExecutionContext::_internal_mutable_span_id() {
  
  return _impl_.span_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ExecutionContext::release_span_id() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.ExecutionContext.span_id)
  return _impl_.span_id_.Release();
}
inline void ExecutionContext::set_allocated_span_id(std::string* span_id) {
  if (span_id != nullptr) {
    
  } else {
    
  }
  _impl_.span_id_.SetAllocated(span_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.span_id_.IsDefault()) {
    _impl_.span_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.ExecutionContext.span_id)
}

// .google.protobuf.Timestamp timestamp = 6;
inline bool ExecutionContext::_internal_has_timestamp() const {
  return this != internal_default_instance() && _impl_.timestamp_ != nullptr;
}
inline bool ExecutionContext::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ExecutionContext::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ExecutionContext::timestamp() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.ExecutionContext.timestamp)
  return _internal_timestamp();
}
inline void ExecutionContext::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.persistence.ExecutionContext.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ExecutionContext::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ExecutionContext::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.ExecutionContext.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ExecutionContext::_internal_mutable_timestamp() {
  
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ExecutionContext::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.ExecutionContext.timestamp)
  return _msg;
}
inline void ExecutionContext::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.ExecutionContext.timestamp)
}

// .google.protobuf.Struct metadata = 7;
inline bool ExecutionContext::_internal_has_metadata() const {
  return this != internal_default_instance() && _impl_.metadata_ != nullptr;
}
inline bool ExecutionContext::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& ExecutionContext::_internal_metadata() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& ExecutionContext::metadata() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.ExecutionContext.metadata)
  return _internal_metadata();
}
inline void ExecutionContext::unsafe_arena_set_allocated_metadata(
    ::PROTOBUF_NAMESPACE_ID::Struct* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.persistence.ExecutionContext.metadata)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ExecutionContext::release_metadata() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ExecutionContext::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.ExecutionContext.metadata)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ExecutionContext::_internal_mutable_metadata() {
  
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ExecutionContext::mutable_metadata() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.ExecutionContext.metadata)
  return _msg;
}
inline void ExecutionContext::set_allocated_metadata(::PROTOBUF_NAMESPACE_ID::Struct* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.ExecutionContext.metadata)
}

// -------------------------------------------------------------------

// Record

// string id = 1;
inline void Record::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Record::id() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.Record.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Record::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.persistence.Record.id)
}
inline std::string* Record::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.Record.id)
  return _s;
}
inline const std::string& Record::_internal_id() const {
  return _impl_.id_.Get();
}
inline void Record::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Record::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* Record::release_id() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.Record.id)
  return _impl_.id_.Release();
}
inline void Record::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.Record.id)
}

// .google.protobuf.Struct data = 2;
inline bool Record::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool Record::has_data() const {
  return _internal_has_data();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& Record::_internal_data() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& Record::data() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.Record.data)
  return _internal_data();
}
inline void Record::unsafe_arena_set_allocated_data(
    ::PROTOBUF_NAMESPACE_ID::Struct* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.persistence.Record.data)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Record::release_data() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Record::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.Record.data)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Record::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Record::mutable_data() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.Record.data)
  return _msg;
}
inline void Record::set_allocated_data(::PROTOBUF_NAMESPACE_ID::Struct* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.Record.data)
}

// .google.protobuf.Timestamp created_at = 3;
inline bool Record::_internal_has_created_at() const {
  return this != internal_default_instance() && _impl_.created_at_ != nullptr;
}
inline bool Record::has_created_at() const {
  return _internal_has_created_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Record::_internal_created_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Record::created_at() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.Record.created_at)
  return _internal_created_at();
}
inline void Record::unsafe_arena_set_allocated_created_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.persistence.Record.created_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Record::release_created_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Record::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.Record.created_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Record::_internal_mutable_created_at() {
  
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.created_at_ = p;
  }
  return _impl_.created_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Record::mutable_created_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.Record.created_at)
  return _msg;
}
inline void Record::set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at));
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.Record.created_at)
}

// .google.protobuf.Timestamp updated_at = 4;
inline bool Record::_internal_has_updated_at() const {
  return this != internal_default_instance() && _impl_.updated_at_ != nullptr;
}
inline bool Record::has_updated_at() const {
  return _internal_has_updated_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Record::_internal_updated_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.updated_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Record::updated_at() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.Record.updated_at)
  return _internal_updated_at();
}
inline void Record::unsafe_arena_set_allocated_updated_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.updated_at_);
  }
  _impl_.updated_at_ = updated_at;
  if (updated_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.persistence.Record.updated_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Record::release_updated_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.updated_at_;
  _impl_.updated_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Record::unsafe_arena_release_updated_at() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.Record.updated_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.updated_at_;
  _impl_.updated_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Record::_internal_mutable_updated_at() {
  
  if (_impl_.updated_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.updated_at_ = p;
  }
  return _impl_.updated_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Record::mutable_updated_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_updated_at();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.Record.updated_at)
  return _msg;
}
inline void Record::set_allocated_updated_at(::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.updated_at_);
  }
  if (updated_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(updated_at));
    if (message_arena != submessage_arena) {
      updated_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, updated_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.updated_at_ = updated_at;
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.Record.updated_at)
}

// string version = 5;
inline void Record::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& Record::version() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.Record.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Record::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.persistence.Record.version)
}
inline std::string* Record::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.Record.version)
  return _s;
}
inline const std::string& Record::_internal_version() const {
  return _impl_.version_.Get();
}
inline void Record::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* Record::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* Record::release_version() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.Record.version)
  return _impl_.version_.Release();
}
inline void Record::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.Record.version)
}

// -------------------------------------------------------------------

// QueryCriteria

// .unhinged.persistence.EqualsFilter equals = 1;
inline bool QueryCriteria::_internal_has_equals() const {
  return criteria_case() == kEquals;
}
inline bool QueryCriteria::has_equals() const {
  return _internal_has_equals();
}
inline void QueryCriteria::set_has_equals() {
  _impl_._oneof_case_[0] = kEquals;
}
inline void QueryCriteria::clear_equals() {
  if (_internal_has_equals()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.criteria_.equals_;
    }
    clear_has_criteria();
  }
}
inline ::unhinged::persistence::EqualsFilter* QueryCriteria::release_equals() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.QueryCriteria.equals)
  if (_internal_has_equals()) {
    clear_has_criteria();
    ::unhinged::persistence::EqualsFilter* temp = _impl_.criteria_.equals_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.criteria_.equals_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::persistence::EqualsFilter& QueryCriteria::_internal_equals() const {
  return _internal_has_equals()
      ? *_impl_.criteria_.equals_
      : reinterpret_cast< ::unhinged::persistence::EqualsFilter&>(::unhinged::persistence::_EqualsFilter_default_instance_);
}
inline const ::unhinged::persistence::EqualsFilter& QueryCriteria::equals() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.QueryCriteria.equals)
  return _internal_equals();
}
inline ::unhinged::persistence::EqualsFilter* QueryCriteria::unsafe_arena_release_equals() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.persistence.QueryCriteria.equals)
  if (_internal_has_equals()) {
    clear_has_criteria();
    ::unhinged::persistence::EqualsFilter* temp = _impl_.criteria_.equals_;
    _impl_.criteria_.equals_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void QueryCriteria::unsafe_arena_set_allocated_equals(::unhinged::persistence::EqualsFilter* equals) {
  clear_criteria();
  if (equals) {
    set_has_equals();
    _impl_.criteria_.equals_ = equals;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.persistence.QueryCriteria.equals)
}
inline ::unhinged::persistence::EqualsFilter* QueryCriteria::_internal_mutable_equals() {
  if (!_internal_has_equals()) {
    clear_criteria();
    set_has_equals();
    _impl_.criteria_.equals_ = CreateMaybeMessage< ::unhinged::persistence::EqualsFilter >(GetArenaForAllocation());
  }
  return _impl_.criteria_.equals_;
}
inline ::unhinged::persistence::EqualsFilter* QueryCriteria::mutable_equals() {
  ::unhinged::persistence::EqualsFilter* _msg = _internal_mutable_equals();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.QueryCriteria.equals)
  return _msg;
}

// .unhinged.persistence.GreaterThanFilter greater_than = 2;
inline bool QueryCriteria::_internal_has_greater_than() const {
  return criteria_case() == kGreaterThan;
}
inline bool QueryCriteria::has_greater_than() const {
  return _internal_has_greater_than();
}
inline void QueryCriteria::set_has_greater_than() {
  _impl_._oneof_case_[0] = kGreaterThan;
}
inline void QueryCriteria::clear_greater_than() {
  if (_internal_has_greater_than()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.criteria_.greater_than_;
    }
    clear_has_criteria();
  }
}
inline ::unhinged::persistence::GreaterThanFilter* QueryCriteria::release_greater_than() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.QueryCriteria.greater_than)
  if (_internal_has_greater_than()) {
    clear_has_criteria();
    ::unhinged::persistence::GreaterThanFilter* temp = _impl_.criteria_.greater_than_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.criteria_.greater_than_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::persistence::GreaterThanFilter& QueryCriteria::_internal_greater_than() const {
  return _internal_has_greater_than()
      ? *_impl_.criteria_.greater_than_
      : reinterpret_cast< ::unhinged::persistence::GreaterThanFilter&>(::unhinged::persistence::_GreaterThanFilter_default_instance_);
}
inline const ::unhinged::persistence::GreaterThanFilter& QueryCriteria::greater_than() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.QueryCriteria.greater_than)
  return _internal_greater_than();
}
inline ::unhinged::persistence::GreaterThanFilter* QueryCriteria::unsafe_arena_release_greater_than() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.persistence.QueryCriteria.greater_than)
  if (_internal_has_greater_than()) {
    clear_has_criteria();
    ::unhinged::persistence::GreaterThanFilter* temp = _impl_.criteria_.greater_than_;
    _impl_.criteria_.greater_than_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void QueryCriteria::unsafe_arena_set_allocated_greater_than(::unhinged::persistence::GreaterThanFilter* greater_than) {
  clear_criteria();
  if (greater_than) {
    set_has_greater_than();
    _impl_.criteria_.greater_than_ = greater_than;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.persistence.QueryCriteria.greater_than)
}
inline ::unhinged::persistence::GreaterThanFilter* QueryCriteria::_internal_mutable_greater_than() {
  if (!_internal_has_greater_than()) {
    clear_criteria();
    set_has_greater_than();
    _impl_.criteria_.greater_than_ = CreateMaybeMessage< ::unhinged::persistence::GreaterThanFilter >(GetArenaForAllocation());
  }
  return _impl_.criteria_.greater_than_;
}
inline ::unhinged::persistence::GreaterThanFilter* QueryCriteria::mutable_greater_than() {
  ::unhinged::persistence::GreaterThanFilter* _msg = _internal_mutable_greater_than();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.QueryCriteria.greater_than)
  return _msg;
}

// .unhinged.persistence.LessThanFilter less_than = 3;
inline bool QueryCriteria::_internal_has_less_than() const {
  return criteria_case() == kLessThan;
}
inline bool QueryCriteria::has_less_than() const {
  return _internal_has_less_than();
}
inline void QueryCriteria::set_has_less_than() {
  _impl_._oneof_case_[0] = kLessThan;
}
inline void QueryCriteria::clear_less_than() {
  if (_internal_has_less_than()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.criteria_.less_than_;
    }
    clear_has_criteria();
  }
}
inline ::unhinged::persistence::LessThanFilter* QueryCriteria::release_less_than() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.QueryCriteria.less_than)
  if (_internal_has_less_than()) {
    clear_has_criteria();
    ::unhinged::persistence::LessThanFilter* temp = _impl_.criteria_.less_than_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.criteria_.less_than_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::persistence::LessThanFilter& QueryCriteria::_internal_less_than() const {
  return _internal_has_less_than()
      ? *_impl_.criteria_.less_than_
      : reinterpret_cast< ::unhinged::persistence::LessThanFilter&>(::unhinged::persistence::_LessThanFilter_default_instance_);
}
inline const ::unhinged::persistence::LessThanFilter& QueryCriteria::less_than() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.QueryCriteria.less_than)
  return _internal_less_than();
}
inline ::unhinged::persistence::LessThanFilter* QueryCriteria::unsafe_arena_release_less_than() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.persistence.QueryCriteria.less_than)
  if (_internal_has_less_than()) {
    clear_has_criteria();
    ::unhinged::persistence::LessThanFilter* temp = _impl_.criteria_.less_than_;
    _impl_.criteria_.less_than_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void QueryCriteria::unsafe_arena_set_allocated_less_than(::unhinged::persistence::LessThanFilter* less_than) {
  clear_criteria();
  if (less_than) {
    set_has_less_than();
    _impl_.criteria_.less_than_ = less_than;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.persistence.QueryCriteria.less_than)
}
inline ::unhinged::persistence::LessThanFilter* QueryCriteria::_internal_mutable_less_than() {
  if (!_internal_has_less_than()) {
    clear_criteria();
    set_has_less_than();
    _impl_.criteria_.less_than_ = CreateMaybeMessage< ::unhinged::persistence::LessThanFilter >(GetArenaForAllocation());
  }
  return _impl_.criteria_.less_than_;
}
inline ::unhinged::persistence::LessThanFilter* QueryCriteria::mutable_less_than() {
  ::unhinged::persistence::LessThanFilter* _msg = _internal_mutable_less_than();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.QueryCriteria.less_than)
  return _msg;
}

// .unhinged.persistence.InFilter in_filter = 4;
inline bool QueryCriteria::_internal_has_in_filter() const {
  return criteria_case() == kInFilter;
}
inline bool QueryCriteria::has_in_filter() const {
  return _internal_has_in_filter();
}
inline void QueryCriteria::set_has_in_filter() {
  _impl_._oneof_case_[0] = kInFilter;
}
inline void QueryCriteria::clear_in_filter() {
  if (_internal_has_in_filter()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.criteria_.in_filter_;
    }
    clear_has_criteria();
  }
}
inline ::unhinged::persistence::InFilter* QueryCriteria::release_in_filter() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.QueryCriteria.in_filter)
  if (_internal_has_in_filter()) {
    clear_has_criteria();
    ::unhinged::persistence::InFilter* temp = _impl_.criteria_.in_filter_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.criteria_.in_filter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::persistence::InFilter& QueryCriteria::_internal_in_filter() const {
  return _internal_has_in_filter()
      ? *_impl_.criteria_.in_filter_
      : reinterpret_cast< ::unhinged::persistence::InFilter&>(::unhinged::persistence::_InFilter_default_instance_);
}
inline const ::unhinged::persistence::InFilter& QueryCriteria::in_filter() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.QueryCriteria.in_filter)
  return _internal_in_filter();
}
inline ::unhinged::persistence::InFilter* QueryCriteria::unsafe_arena_release_in_filter() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.persistence.QueryCriteria.in_filter)
  if (_internal_has_in_filter()) {
    clear_has_criteria();
    ::unhinged::persistence::InFilter* temp = _impl_.criteria_.in_filter_;
    _impl_.criteria_.in_filter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void QueryCriteria::unsafe_arena_set_allocated_in_filter(::unhinged::persistence::InFilter* in_filter) {
  clear_criteria();
  if (in_filter) {
    set_has_in_filter();
    _impl_.criteria_.in_filter_ = in_filter;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.persistence.QueryCriteria.in_filter)
}
inline ::unhinged::persistence::InFilter* QueryCriteria::_internal_mutable_in_filter() {
  if (!_internal_has_in_filter()) {
    clear_criteria();
    set_has_in_filter();
    _impl_.criteria_.in_filter_ = CreateMaybeMessage< ::unhinged::persistence::InFilter >(GetArenaForAllocation());
  }
  return _impl_.criteria_.in_filter_;
}
inline ::unhinged::persistence::InFilter* QueryCriteria::mutable_in_filter() {
  ::unhinged::persistence::InFilter* _msg = _internal_mutable_in_filter();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.QueryCriteria.in_filter)
  return _msg;
}

// .unhinged.persistence.RangeFilter range = 5;
inline bool QueryCriteria::_internal_has_range() const {
  return criteria_case() == kRange;
}
inline bool QueryCriteria::has_range() const {
  return _internal_has_range();
}
inline void QueryCriteria::set_has_range() {
  _impl_._oneof_case_[0] = kRange;
}
inline void QueryCriteria::clear_range() {
  if (_internal_has_range()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.criteria_.range_;
    }
    clear_has_criteria();
  }
}
inline ::unhinged::persistence::RangeFilter* QueryCriteria::release_range() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.QueryCriteria.range)
  if (_internal_has_range()) {
    clear_has_criteria();
    ::unhinged::persistence::RangeFilter* temp = _impl_.criteria_.range_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.criteria_.range_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::persistence::RangeFilter& QueryCriteria::_internal_range() const {
  return _internal_has_range()
      ? *_impl_.criteria_.range_
      : reinterpret_cast< ::unhinged::persistence::RangeFilter&>(::unhinged::persistence::_RangeFilter_default_instance_);
}
inline const ::unhinged::persistence::RangeFilter& QueryCriteria::range() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.QueryCriteria.range)
  return _internal_range();
}
inline ::unhinged::persistence::RangeFilter* QueryCriteria::unsafe_arena_release_range() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.persistence.QueryCriteria.range)
  if (_internal_has_range()) {
    clear_has_criteria();
    ::unhinged::persistence::RangeFilter* temp = _impl_.criteria_.range_;
    _impl_.criteria_.range_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void QueryCriteria::unsafe_arena_set_allocated_range(::unhinged::persistence::RangeFilter* range) {
  clear_criteria();
  if (range) {
    set_has_range();
    _impl_.criteria_.range_ = range;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.persistence.QueryCriteria.range)
}
inline ::unhinged::persistence::RangeFilter* QueryCriteria::_internal_mutable_range() {
  if (!_internal_has_range()) {
    clear_criteria();
    set_has_range();
    _impl_.criteria_.range_ = CreateMaybeMessage< ::unhinged::persistence::RangeFilter >(GetArenaForAllocation());
  }
  return _impl_.criteria_.range_;
}
inline ::unhinged::persistence::RangeFilter* QueryCriteria::mutable_range() {
  ::unhinged::persistence::RangeFilter* _msg = _internal_mutable_range();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.QueryCriteria.range)
  return _msg;
}

// .unhinged.persistence.TextSearchFilter text_search = 6;
inline bool QueryCriteria::_internal_has_text_search() const {
  return criteria_case() == kTextSearch;
}
inline bool QueryCriteria::has_text_search() const {
  return _internal_has_text_search();
}
inline void QueryCriteria::set_has_text_search() {
  _impl_._oneof_case_[0] = kTextSearch;
}
inline void QueryCriteria::clear_text_search() {
  if (_internal_has_text_search()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.criteria_.text_search_;
    }
    clear_has_criteria();
  }
}
inline ::unhinged::persistence::TextSearchFilter* QueryCriteria::release_text_search() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.QueryCriteria.text_search)
  if (_internal_has_text_search()) {
    clear_has_criteria();
    ::unhinged::persistence::TextSearchFilter* temp = _impl_.criteria_.text_search_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.criteria_.text_search_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::persistence::TextSearchFilter& QueryCriteria::_internal_text_search() const {
  return _internal_has_text_search()
      ? *_impl_.criteria_.text_search_
      : reinterpret_cast< ::unhinged::persistence::TextSearchFilter&>(::unhinged::persistence::_TextSearchFilter_default_instance_);
}
inline const ::unhinged::persistence::TextSearchFilter& QueryCriteria::text_search() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.QueryCriteria.text_search)
  return _internal_text_search();
}
inline ::unhinged::persistence::TextSearchFilter* QueryCriteria::unsafe_arena_release_text_search() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.persistence.QueryCriteria.text_search)
  if (_internal_has_text_search()) {
    clear_has_criteria();
    ::unhinged::persistence::TextSearchFilter* temp = _impl_.criteria_.text_search_;
    _impl_.criteria_.text_search_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void QueryCriteria::unsafe_arena_set_allocated_text_search(::unhinged::persistence::TextSearchFilter* text_search) {
  clear_criteria();
  if (text_search) {
    set_has_text_search();
    _impl_.criteria_.text_search_ = text_search;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.persistence.QueryCriteria.text_search)
}
inline ::unhinged::persistence::TextSearchFilter* QueryCriteria::_internal_mutable_text_search() {
  if (!_internal_has_text_search()) {
    clear_criteria();
    set_has_text_search();
    _impl_.criteria_.text_search_ = CreateMaybeMessage< ::unhinged::persistence::TextSearchFilter >(GetArenaForAllocation());
  }
  return _impl_.criteria_.text_search_;
}
inline ::unhinged::persistence::TextSearchFilter* QueryCriteria::mutable_text_search() {
  ::unhinged::persistence::TextSearchFilter* _msg = _internal_mutable_text_search();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.QueryCriteria.text_search)
  return _msg;
}

// .unhinged.persistence.VectorSearchFilter vector_search = 7;
inline bool QueryCriteria::_internal_has_vector_search() const {
  return criteria_case() == kVectorSearch;
}
inline bool QueryCriteria::has_vector_search() const {
  return _internal_has_vector_search();
}
inline void QueryCriteria::set_has_vector_search() {
  _impl_._oneof_case_[0] = kVectorSearch;
}
inline void QueryCriteria::clear_vector_search() {
  if (_internal_has_vector_search()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.criteria_.vector_search_;
    }
    clear_has_criteria();
  }
}
inline ::unhinged::persistence::VectorSearchFilter* QueryCriteria::release_vector_search() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.QueryCriteria.vector_search)
  if (_internal_has_vector_search()) {
    clear_has_criteria();
    ::unhinged::persistence::VectorSearchFilter* temp = _impl_.criteria_.vector_search_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.criteria_.vector_search_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::persistence::VectorSearchFilter& QueryCriteria::_internal_vector_search() const {
  return _internal_has_vector_search()
      ? *_impl_.criteria_.vector_search_
      : reinterpret_cast< ::unhinged::persistence::VectorSearchFilter&>(::unhinged::persistence::_VectorSearchFilter_default_instance_);
}
inline const ::unhinged::persistence::VectorSearchFilter& QueryCriteria::vector_search() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.QueryCriteria.vector_search)
  return _internal_vector_search();
}
inline ::unhinged::persistence::VectorSearchFilter* QueryCriteria::unsafe_arena_release_vector_search() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.persistence.QueryCriteria.vector_search)
  if (_internal_has_vector_search()) {
    clear_has_criteria();
    ::unhinged::persistence::VectorSearchFilter* temp = _impl_.criteria_.vector_search_;
    _impl_.criteria_.vector_search_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void QueryCriteria::unsafe_arena_set_allocated_vector_search(::unhinged::persistence::VectorSearchFilter* vector_search) {
  clear_criteria();
  if (vector_search) {
    set_has_vector_search();
    _impl_.criteria_.vector_search_ = vector_search;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.persistence.QueryCriteria.vector_search)
}
inline ::unhinged::persistence::VectorSearchFilter* QueryCriteria::_internal_mutable_vector_search() {
  if (!_internal_has_vector_search()) {
    clear_criteria();
    set_has_vector_search();
    _impl_.criteria_.vector_search_ = CreateMaybeMessage< ::unhinged::persistence::VectorSearchFilter >(GetArenaForAllocation());
  }
  return _impl_.criteria_.vector_search_;
}
inline ::unhinged::persistence::VectorSearchFilter* QueryCriteria::mutable_vector_search() {
  ::unhinged::persistence::VectorSearchFilter* _msg = _internal_mutable_vector_search();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.QueryCriteria.vector_search)
  return _msg;
}

// .unhinged.persistence.AndFilter and_filter = 8;
inline bool QueryCriteria::_internal_has_and_filter() const {
  return criteria_case() == kAndFilter;
}
inline bool QueryCriteria::has_and_filter() const {
  return _internal_has_and_filter();
}
inline void QueryCriteria::set_has_and_filter() {
  _impl_._oneof_case_[0] = kAndFilter;
}
inline void QueryCriteria::clear_and_filter() {
  if (_internal_has_and_filter()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.criteria_.and_filter_;
    }
    clear_has_criteria();
  }
}
inline ::unhinged::persistence::AndFilter* QueryCriteria::release_and_filter() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.QueryCriteria.and_filter)
  if (_internal_has_and_filter()) {
    clear_has_criteria();
    ::unhinged::persistence::AndFilter* temp = _impl_.criteria_.and_filter_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.criteria_.and_filter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::persistence::AndFilter& QueryCriteria::_internal_and_filter() const {
  return _internal_has_and_filter()
      ? *_impl_.criteria_.and_filter_
      : reinterpret_cast< ::unhinged::persistence::AndFilter&>(::unhinged::persistence::_AndFilter_default_instance_);
}
inline const ::unhinged::persistence::AndFilter& QueryCriteria::and_filter() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.QueryCriteria.and_filter)
  return _internal_and_filter();
}
inline ::unhinged::persistence::AndFilter* QueryCriteria::unsafe_arena_release_and_filter() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.persistence.QueryCriteria.and_filter)
  if (_internal_has_and_filter()) {
    clear_has_criteria();
    ::unhinged::persistence::AndFilter* temp = _impl_.criteria_.and_filter_;
    _impl_.criteria_.and_filter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void QueryCriteria::unsafe_arena_set_allocated_and_filter(::unhinged::persistence::AndFilter* and_filter) {
  clear_criteria();
  if (and_filter) {
    set_has_and_filter();
    _impl_.criteria_.and_filter_ = and_filter;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.persistence.QueryCriteria.and_filter)
}
inline ::unhinged::persistence::AndFilter* QueryCriteria::_internal_mutable_and_filter() {
  if (!_internal_has_and_filter()) {
    clear_criteria();
    set_has_and_filter();
    _impl_.criteria_.and_filter_ = CreateMaybeMessage< ::unhinged::persistence::AndFilter >(GetArenaForAllocation());
  }
  return _impl_.criteria_.and_filter_;
}
inline ::unhinged::persistence::AndFilter* QueryCriteria::mutable_and_filter() {
  ::unhinged::persistence::AndFilter* _msg = _internal_mutable_and_filter();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.QueryCriteria.and_filter)
  return _msg;
}

// .unhinged.persistence.OrFilter or_filter = 9;
inline bool QueryCriteria::_internal_has_or_filter() const {
  return criteria_case() == kOrFilter;
}
inline bool QueryCriteria::has_or_filter() const {
  return _internal_has_or_filter();
}
inline void QueryCriteria::set_has_or_filter() {
  _impl_._oneof_case_[0] = kOrFilter;
}
inline void QueryCriteria::clear_or_filter() {
  if (_internal_has_or_filter()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.criteria_.or_filter_;
    }
    clear_has_criteria();
  }
}
inline ::unhinged::persistence::OrFilter* QueryCriteria::release_or_filter() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.QueryCriteria.or_filter)
  if (_internal_has_or_filter()) {
    clear_has_criteria();
    ::unhinged::persistence::OrFilter* temp = _impl_.criteria_.or_filter_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.criteria_.or_filter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::persistence::OrFilter& QueryCriteria::_internal_or_filter() const {
  return _internal_has_or_filter()
      ? *_impl_.criteria_.or_filter_
      : reinterpret_cast< ::unhinged::persistence::OrFilter&>(::unhinged::persistence::_OrFilter_default_instance_);
}
inline const ::unhinged::persistence::OrFilter& QueryCriteria::or_filter() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.QueryCriteria.or_filter)
  return _internal_or_filter();
}
inline ::unhinged::persistence::OrFilter* QueryCriteria::unsafe_arena_release_or_filter() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.persistence.QueryCriteria.or_filter)
  if (_internal_has_or_filter()) {
    clear_has_criteria();
    ::unhinged::persistence::OrFilter* temp = _impl_.criteria_.or_filter_;
    _impl_.criteria_.or_filter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void QueryCriteria::unsafe_arena_set_allocated_or_filter(::unhinged::persistence::OrFilter* or_filter) {
  clear_criteria();
  if (or_filter) {
    set_has_or_filter();
    _impl_.criteria_.or_filter_ = or_filter;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.persistence.QueryCriteria.or_filter)
}
inline ::unhinged::persistence::OrFilter* QueryCriteria::_internal_mutable_or_filter() {
  if (!_internal_has_or_filter()) {
    clear_criteria();
    set_has_or_filter();
    _impl_.criteria_.or_filter_ = CreateMaybeMessage< ::unhinged::persistence::OrFilter >(GetArenaForAllocation());
  }
  return _impl_.criteria_.or_filter_;
}
inline ::unhinged::persistence::OrFilter* QueryCriteria::mutable_or_filter() {
  ::unhinged::persistence::OrFilter* _msg = _internal_mutable_or_filter();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.QueryCriteria.or_filter)
  return _msg;
}

inline bool QueryCriteria::has_criteria() const {
  return criteria_case() != CRITERIA_NOT_SET;
}
inline void QueryCriteria::clear_has_criteria() {
  _impl_._oneof_case_[0] = CRITERIA_NOT_SET;
}
inline QueryCriteria::CriteriaCase QueryCriteria::criteria_case() const {
  return QueryCriteria::CriteriaCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// EqualsFilter

// string field = 1;
inline void EqualsFilter::clear_field() {
  _impl_.field_.ClearToEmpty();
}
inline const std::string& EqualsFilter::field() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.EqualsFilter.field)
  return _internal_field();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EqualsFilter::set_field(ArgT0&& arg0, ArgT... args) {
 
 _impl_.field_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.persistence.EqualsFilter.field)
}
inline std::string* EqualsFilter::mutable_field() {
  std::string* _s = _internal_mutable_field();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.EqualsFilter.field)
  return _s;
}
inline const std::string& EqualsFilter::_internal_field() const {
  return _impl_.field_.Get();
}
inline void EqualsFilter::_internal_set_field(const std::string& value) {
  
  _impl_.field_.Set(value, GetArenaForAllocation());
}
inline std::string* EqualsFilter::_internal_mutable_field() {
  
  return _impl_.field_.Mutable(GetArenaForAllocation());
}
inline std::string* EqualsFilter::release_field() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.EqualsFilter.field)
  return _impl_.field_.Release();
}
inline void EqualsFilter::set_allocated_field(std::string* field) {
  if (field != nullptr) {
    
  } else {
    
  }
  _impl_.field_.SetAllocated(field, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field_.IsDefault()) {
    _impl_.field_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.EqualsFilter.field)
}

// .google.protobuf.Any value = 2;
inline bool EqualsFilter::_internal_has_value() const {
  return this != internal_default_instance() && _impl_.value_ != nullptr;
}
inline bool EqualsFilter::has_value() const {
  return _internal_has_value();
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& EqualsFilter::_internal_value() const {
  const ::PROTOBUF_NAMESPACE_ID::Any* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Any&>(
      ::PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& EqualsFilter::value() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.EqualsFilter.value)
  return _internal_value();
}
inline void EqualsFilter::unsafe_arena_set_allocated_value(
    ::PROTOBUF_NAMESPACE_ID::Any* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.persistence.EqualsFilter.value)
}
inline ::PROTOBUF_NAMESPACE_ID::Any* EqualsFilter::release_value() {
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.value_;
  _impl_.value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* EqualsFilter::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.EqualsFilter.value)
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* EqualsFilter::_internal_mutable_value() {
  
  if (_impl_.value_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Any>(GetArenaForAllocation());
    _impl_.value_ = p;
  }
  return _impl_.value_;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* EqualsFilter::mutable_value() {
  ::PROTOBUF_NAMESPACE_ID::Any* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.EqualsFilter.value)
  return _msg;
}
inline void EqualsFilter::set_allocated_value(::PROTOBUF_NAMESPACE_ID::Any* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.value_);
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.value_ = value;
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.EqualsFilter.value)
}

// -------------------------------------------------------------------

// GreaterThanFilter

// string field = 1;
inline void GreaterThanFilter::clear_field() {
  _impl_.field_.ClearToEmpty();
}
inline const std::string& GreaterThanFilter::field() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.GreaterThanFilter.field)
  return _internal_field();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GreaterThanFilter::set_field(ArgT0&& arg0, ArgT... args) {
 
 _impl_.field_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.persistence.GreaterThanFilter.field)
}
inline std::string* GreaterThanFilter::mutable_field() {
  std::string* _s = _internal_mutable_field();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.GreaterThanFilter.field)
  return _s;
}
inline const std::string& GreaterThanFilter::_internal_field() const {
  return _impl_.field_.Get();
}
inline void GreaterThanFilter::_internal_set_field(const std::string& value) {
  
  _impl_.field_.Set(value, GetArenaForAllocation());
}
inline std::string* GreaterThanFilter::_internal_mutable_field() {
  
  return _impl_.field_.Mutable(GetArenaForAllocation());
}
inline std::string* GreaterThanFilter::release_field() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.GreaterThanFilter.field)
  return _impl_.field_.Release();
}
inline void GreaterThanFilter::set_allocated_field(std::string* field) {
  if (field != nullptr) {
    
  } else {
    
  }
  _impl_.field_.SetAllocated(field, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field_.IsDefault()) {
    _impl_.field_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.GreaterThanFilter.field)
}

// .google.protobuf.Any value = 2;
inline bool GreaterThanFilter::_internal_has_value() const {
  return this != internal_default_instance() && _impl_.value_ != nullptr;
}
inline bool GreaterThanFilter::has_value() const {
  return _internal_has_value();
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& GreaterThanFilter::_internal_value() const {
  const ::PROTOBUF_NAMESPACE_ID::Any* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Any&>(
      ::PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& GreaterThanFilter::value() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.GreaterThanFilter.value)
  return _internal_value();
}
inline void GreaterThanFilter::unsafe_arena_set_allocated_value(
    ::PROTOBUF_NAMESPACE_ID::Any* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.persistence.GreaterThanFilter.value)
}
inline ::PROTOBUF_NAMESPACE_ID::Any* GreaterThanFilter::release_value() {
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.value_;
  _impl_.value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* GreaterThanFilter::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.GreaterThanFilter.value)
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* GreaterThanFilter::_internal_mutable_value() {
  
  if (_impl_.value_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Any>(GetArenaForAllocation());
    _impl_.value_ = p;
  }
  return _impl_.value_;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* GreaterThanFilter::mutable_value() {
  ::PROTOBUF_NAMESPACE_ID::Any* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.GreaterThanFilter.value)
  return _msg;
}
inline void GreaterThanFilter::set_allocated_value(::PROTOBUF_NAMESPACE_ID::Any* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.value_);
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.value_ = value;
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.GreaterThanFilter.value)
}

// -------------------------------------------------------------------

// LessThanFilter

// string field = 1;
inline void LessThanFilter::clear_field() {
  _impl_.field_.ClearToEmpty();
}
inline const std::string& LessThanFilter::field() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.LessThanFilter.field)
  return _internal_field();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LessThanFilter::set_field(ArgT0&& arg0, ArgT... args) {
 
 _impl_.field_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.persistence.LessThanFilter.field)
}
inline std::string* LessThanFilter::mutable_field() {
  std::string* _s = _internal_mutable_field();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.LessThanFilter.field)
  return _s;
}
inline const std::string& LessThanFilter::_internal_field() const {
  return _impl_.field_.Get();
}
inline void LessThanFilter::_internal_set_field(const std::string& value) {
  
  _impl_.field_.Set(value, GetArenaForAllocation());
}
inline std::string* LessThanFilter::_internal_mutable_field() {
  
  return _impl_.field_.Mutable(GetArenaForAllocation());
}
inline std::string* LessThanFilter::release_field() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.LessThanFilter.field)
  return _impl_.field_.Release();
}
inline void LessThanFilter::set_allocated_field(std::string* field) {
  if (field != nullptr) {
    
  } else {
    
  }
  _impl_.field_.SetAllocated(field, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field_.IsDefault()) {
    _impl_.field_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.LessThanFilter.field)
}

// .google.protobuf.Any value = 2;
inline bool LessThanFilter::_internal_has_value() const {
  return this != internal_default_instance() && _impl_.value_ != nullptr;
}
inline bool LessThanFilter::has_value() const {
  return _internal_has_value();
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& LessThanFilter::_internal_value() const {
  const ::PROTOBUF_NAMESPACE_ID::Any* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Any&>(
      ::PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& LessThanFilter::value() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.LessThanFilter.value)
  return _internal_value();
}
inline void LessThanFilter::unsafe_arena_set_allocated_value(
    ::PROTOBUF_NAMESPACE_ID::Any* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.persistence.LessThanFilter.value)
}
inline ::PROTOBUF_NAMESPACE_ID::Any* LessThanFilter::release_value() {
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.value_;
  _impl_.value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* LessThanFilter::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.LessThanFilter.value)
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* LessThanFilter::_internal_mutable_value() {
  
  if (_impl_.value_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Any>(GetArenaForAllocation());
    _impl_.value_ = p;
  }
  return _impl_.value_;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* LessThanFilter::mutable_value() {
  ::PROTOBUF_NAMESPACE_ID::Any* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.LessThanFilter.value)
  return _msg;
}
inline void LessThanFilter::set_allocated_value(::PROTOBUF_NAMESPACE_ID::Any* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.value_);
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.value_ = value;
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.LessThanFilter.value)
}

// -------------------------------------------------------------------

// InFilter

// string field = 1;
inline void InFilter::clear_field() {
  _impl_.field_.ClearToEmpty();
}
inline const std::string& InFilter::field() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.InFilter.field)
  return _internal_field();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InFilter::set_field(ArgT0&& arg0, ArgT... args) {
 
 _impl_.field_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.persistence.InFilter.field)
}
inline std::string* InFilter::mutable_field() {
  std::string* _s = _internal_mutable_field();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.InFilter.field)
  return _s;
}
inline const std::string& InFilter::_internal_field() const {
  return _impl_.field_.Get();
}
inline void InFilter::_internal_set_field(const std::string& value) {
  
  _impl_.field_.Set(value, GetArenaForAllocation());
}
inline std::string* InFilter::_internal_mutable_field() {
  
  return _impl_.field_.Mutable(GetArenaForAllocation());
}
inline std::string* InFilter::release_field() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.InFilter.field)
  return _impl_.field_.Release();
}
inline void InFilter::set_allocated_field(std::string* field) {
  if (field != nullptr) {
    
  } else {
    
  }
  _impl_.field_.SetAllocated(field, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field_.IsDefault()) {
    _impl_.field_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.InFilter.field)
}

// repeated .google.protobuf.Any values = 2;
inline int InFilter::_internal_values_size() const {
  return _impl_.values_.size();
}
inline int InFilter::values_size() const {
  return _internal_values_size();
}
inline ::PROTOBUF_NAMESPACE_ID::Any* InFilter::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.InFilter.values)
  return _impl_.values_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any >*
InFilter::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.persistence.InFilter.values)
  return &_impl_.values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& InFilter::_internal_values(int index) const {
  return _impl_.values_.Get(index);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& InFilter::values(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.InFilter.values)
  return _internal_values(index);
}
inline ::PROTOBUF_NAMESPACE_ID::Any* InFilter::_internal_add_values() {
  return _impl_.values_.Add();
}
inline ::PROTOBUF_NAMESPACE_ID::Any* InFilter::add_values() {
  ::PROTOBUF_NAMESPACE_ID::Any* _add = _internal_add_values();
  // @@protoc_insertion_point(field_add:unhinged.persistence.InFilter.values)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any >&
InFilter::values() const {
  // @@protoc_insertion_point(field_list:unhinged.persistence.InFilter.values)
  return _impl_.values_;
}

// -------------------------------------------------------------------

// RangeFilter

// string field = 1;
inline void RangeFilter::clear_field() {
  _impl_.field_.ClearToEmpty();
}
inline const std::string& RangeFilter::field() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.RangeFilter.field)
  return _internal_field();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RangeFilter::set_field(ArgT0&& arg0, ArgT... args) {
 
 _impl_.field_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.persistence.RangeFilter.field)
}
inline std::string* RangeFilter::mutable_field() {
  std::string* _s = _internal_mutable_field();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.RangeFilter.field)
  return _s;
}
inline const std::string& RangeFilter::_internal_field() const {
  return _impl_.field_.Get();
}
inline void RangeFilter::_internal_set_field(const std::string& value) {
  
  _impl_.field_.Set(value, GetArenaForAllocation());
}
inline std::string* RangeFilter::_internal_mutable_field() {
  
  return _impl_.field_.Mutable(GetArenaForAllocation());
}
inline std::string* RangeFilter::release_field() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.RangeFilter.field)
  return _impl_.field_.Release();
}
inline void RangeFilter::set_allocated_field(std::string* field) {
  if (field != nullptr) {
    
  } else {
    
  }
  _impl_.field_.SetAllocated(field, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field_.IsDefault()) {
    _impl_.field_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.RangeFilter.field)
}

// .google.protobuf.Any min_value = 2;
inline bool RangeFilter::_internal_has_min_value() const {
  return this != internal_default_instance() && _impl_.min_value_ != nullptr;
}
inline bool RangeFilter::has_min_value() const {
  return _internal_has_min_value();
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& RangeFilter::_internal_min_value() const {
  const ::PROTOBUF_NAMESPACE_ID::Any* p = _impl_.min_value_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Any&>(
      ::PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& RangeFilter::min_value() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.RangeFilter.min_value)
  return _internal_min_value();
}
inline void RangeFilter::unsafe_arena_set_allocated_min_value(
    ::PROTOBUF_NAMESPACE_ID::Any* min_value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.min_value_);
  }
  _impl_.min_value_ = min_value;
  if (min_value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.persistence.RangeFilter.min_value)
}
inline ::PROTOBUF_NAMESPACE_ID::Any* RangeFilter::release_min_value() {
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.min_value_;
  _impl_.min_value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* RangeFilter::unsafe_arena_release_min_value() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.RangeFilter.min_value)
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.min_value_;
  _impl_.min_value_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* RangeFilter::_internal_mutable_min_value() {
  
  if (_impl_.min_value_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Any>(GetArenaForAllocation());
    _impl_.min_value_ = p;
  }
  return _impl_.min_value_;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* RangeFilter::mutable_min_value() {
  ::PROTOBUF_NAMESPACE_ID::Any* _msg = _internal_mutable_min_value();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.RangeFilter.min_value)
  return _msg;
}
inline void RangeFilter::set_allocated_min_value(::PROTOBUF_NAMESPACE_ID::Any* min_value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.min_value_);
  }
  if (min_value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(min_value));
    if (message_arena != submessage_arena) {
      min_value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, min_value, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.min_value_ = min_value;
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.RangeFilter.min_value)
}

// .google.protobuf.Any max_value = 3;
inline bool RangeFilter::_internal_has_max_value() const {
  return this != internal_default_instance() && _impl_.max_value_ != nullptr;
}
inline bool RangeFilter::has_max_value() const {
  return _internal_has_max_value();
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& RangeFilter::_internal_max_value() const {
  const ::PROTOBUF_NAMESPACE_ID::Any* p = _impl_.max_value_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Any&>(
      ::PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& RangeFilter::max_value() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.RangeFilter.max_value)
  return _internal_max_value();
}
inline void RangeFilter::unsafe_arena_set_allocated_max_value(
    ::PROTOBUF_NAMESPACE_ID::Any* max_value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.max_value_);
  }
  _impl_.max_value_ = max_value;
  if (max_value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.persistence.RangeFilter.max_value)
}
inline ::PROTOBUF_NAMESPACE_ID::Any* RangeFilter::release_max_value() {
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.max_value_;
  _impl_.max_value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* RangeFilter::unsafe_arena_release_max_value() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.RangeFilter.max_value)
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.max_value_;
  _impl_.max_value_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* RangeFilter::_internal_mutable_max_value() {
  
  if (_impl_.max_value_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Any>(GetArenaForAllocation());
    _impl_.max_value_ = p;
  }
  return _impl_.max_value_;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* RangeFilter::mutable_max_value() {
  ::PROTOBUF_NAMESPACE_ID::Any* _msg = _internal_mutable_max_value();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.RangeFilter.max_value)
  return _msg;
}
inline void RangeFilter::set_allocated_max_value(::PROTOBUF_NAMESPACE_ID::Any* max_value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.max_value_);
  }
  if (max_value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(max_value));
    if (message_arena != submessage_arena) {
      max_value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, max_value, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.max_value_ = max_value;
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.RangeFilter.max_value)
}

// -------------------------------------------------------------------

// TextSearchFilter

// repeated string fields = 1;
inline int TextSearchFilter::_internal_fields_size() const {
  return _impl_.fields_.size();
}
inline int TextSearchFilter::fields_size() const {
  return _internal_fields_size();
}
inline void TextSearchFilter::clear_fields() {
  _impl_.fields_.Clear();
}
inline std::string* TextSearchFilter::add_fields() {
  std::string* _s = _internal_add_fields();
  // @@protoc_insertion_point(field_add_mutable:unhinged.persistence.TextSearchFilter.fields)
  return _s;
}
inline const std::string& TextSearchFilter::_internal_fields(int index) const {
  return _impl_.fields_.Get(index);
}
inline const std::string& TextSearchFilter::fields(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.TextSearchFilter.fields)
  return _internal_fields(index);
}
inline std::string* TextSearchFilter::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.TextSearchFilter.fields)
  return _impl_.fields_.Mutable(index);
}
inline void TextSearchFilter::set_fields(int index, const std::string& value) {
  _impl_.fields_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.persistence.TextSearchFilter.fields)
}
inline void TextSearchFilter::set_fields(int index, std::string&& value) {
  _impl_.fields_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.persistence.TextSearchFilter.fields)
}
inline void TextSearchFilter::set_fields(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.fields_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.persistence.TextSearchFilter.fields)
}
inline void TextSearchFilter::set_fields(int index, const char* value, size_t size) {
  _impl_.fields_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.persistence.TextSearchFilter.fields)
}
inline std::string* TextSearchFilter::_internal_add_fields() {
  return _impl_.fields_.Add();
}
inline void TextSearchFilter::add_fields(const std::string& value) {
  _impl_.fields_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.persistence.TextSearchFilter.fields)
}
inline void TextSearchFilter::add_fields(std::string&& value) {
  _impl_.fields_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.persistence.TextSearchFilter.fields)
}
inline void TextSearchFilter::add_fields(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.fields_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.persistence.TextSearchFilter.fields)
}
inline void TextSearchFilter::add_fields(const char* value, size_t size) {
  _impl_.fields_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.persistence.TextSearchFilter.fields)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TextSearchFilter::fields() const {
  // @@protoc_insertion_point(field_list:unhinged.persistence.TextSearchFilter.fields)
  return _impl_.fields_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TextSearchFilter::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.persistence.TextSearchFilter.fields)
  return &_impl_.fields_;
}

// string query = 2;
inline void TextSearchFilter::clear_query() {
  _impl_.query_.ClearToEmpty();
}
inline const std::string& TextSearchFilter::query() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.TextSearchFilter.query)
  return _internal_query();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TextSearchFilter::set_query(ArgT0&& arg0, ArgT... args) {
 
 _impl_.query_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.persistence.TextSearchFilter.query)
}
inline std::string* TextSearchFilter::mutable_query() {
  std::string* _s = _internal_mutable_query();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.TextSearchFilter.query)
  return _s;
}
inline const std::string& TextSearchFilter::_internal_query() const {
  return _impl_.query_.Get();
}
inline void TextSearchFilter::_internal_set_query(const std::string& value) {
  
  _impl_.query_.Set(value, GetArenaForAllocation());
}
inline std::string* TextSearchFilter::_internal_mutable_query() {
  
  return _impl_.query_.Mutable(GetArenaForAllocation());
}
inline std::string* TextSearchFilter::release_query() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.TextSearchFilter.query)
  return _impl_.query_.Release();
}
inline void TextSearchFilter::set_allocated_query(std::string* query) {
  if (query != nullptr) {
    
  } else {
    
  }
  _impl_.query_.SetAllocated(query, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.query_.IsDefault()) {
    _impl_.query_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.TextSearchFilter.query)
}

// string analyzer = 3;
inline void TextSearchFilter::clear_analyzer() {
  _impl_.analyzer_.ClearToEmpty();
}
inline const std::string& TextSearchFilter::analyzer() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.TextSearchFilter.analyzer)
  return _internal_analyzer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TextSearchFilter::set_analyzer(ArgT0&& arg0, ArgT... args) {
 
 _impl_.analyzer_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.persistence.TextSearchFilter.analyzer)
}
inline std::string* TextSearchFilter::mutable_analyzer() {
  std::string* _s = _internal_mutable_analyzer();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.TextSearchFilter.analyzer)
  return _s;
}
inline const std::string& TextSearchFilter::_internal_analyzer() const {
  return _impl_.analyzer_.Get();
}
inline void TextSearchFilter::_internal_set_analyzer(const std::string& value) {
  
  _impl_.analyzer_.Set(value, GetArenaForAllocation());
}
inline std::string* TextSearchFilter::_internal_mutable_analyzer() {
  
  return _impl_.analyzer_.Mutable(GetArenaForAllocation());
}
inline std::string* TextSearchFilter::release_analyzer() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.TextSearchFilter.analyzer)
  return _impl_.analyzer_.Release();
}
inline void TextSearchFilter::set_allocated_analyzer(std::string* analyzer) {
  if (analyzer != nullptr) {
    
  } else {
    
  }
  _impl_.analyzer_.SetAllocated(analyzer, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.analyzer_.IsDefault()) {
    _impl_.analyzer_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.TextSearchFilter.analyzer)
}

// -------------------------------------------------------------------

// VectorSearchFilter

// string field = 1;
inline void VectorSearchFilter::clear_field() {
  _impl_.field_.ClearToEmpty();
}
inline const std::string& VectorSearchFilter::field() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.VectorSearchFilter.field)
  return _internal_field();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VectorSearchFilter::set_field(ArgT0&& arg0, ArgT... args) {
 
 _impl_.field_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.persistence.VectorSearchFilter.field)
}
inline std::string* VectorSearchFilter::mutable_field() {
  std::string* _s = _internal_mutable_field();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.VectorSearchFilter.field)
  return _s;
}
inline const std::string& VectorSearchFilter::_internal_field() const {
  return _impl_.field_.Get();
}
inline void VectorSearchFilter::_internal_set_field(const std::string& value) {
  
  _impl_.field_.Set(value, GetArenaForAllocation());
}
inline std::string* VectorSearchFilter::_internal_mutable_field() {
  
  return _impl_.field_.Mutable(GetArenaForAllocation());
}
inline std::string* VectorSearchFilter::release_field() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.VectorSearchFilter.field)
  return _impl_.field_.Release();
}
inline void VectorSearchFilter::set_allocated_field(std::string* field) {
  if (field != nullptr) {
    
  } else {
    
  }
  _impl_.field_.SetAllocated(field, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field_.IsDefault()) {
    _impl_.field_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.VectorSearchFilter.field)
}

// repeated float query_vector = 2;
inline int VectorSearchFilter::_internal_query_vector_size() const {
  return _impl_.query_vector_.size();
}
inline int VectorSearchFilter::query_vector_size() const {
  return _internal_query_vector_size();
}
inline void VectorSearchFilter::clear_query_vector() {
  _impl_.query_vector_.Clear();
}
inline float VectorSearchFilter::_internal_query_vector(int index) const {
  return _impl_.query_vector_.Get(index);
}
inline float VectorSearchFilter::query_vector(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.VectorSearchFilter.query_vector)
  return _internal_query_vector(index);
}
inline void VectorSearchFilter::set_query_vector(int index, float value) {
  _impl_.query_vector_.Set(index, value);
  // @@protoc_insertion_point(field_set:unhinged.persistence.VectorSearchFilter.query_vector)
}
inline void VectorSearchFilter::_internal_add_query_vector(float value) {
  _impl_.query_vector_.Add(value);
}
inline void VectorSearchFilter::add_query_vector(float value) {
  _internal_add_query_vector(value);
  // @@protoc_insertion_point(field_add:unhinged.persistence.VectorSearchFilter.query_vector)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
VectorSearchFilter::_internal_query_vector() const {
  return _impl_.query_vector_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
VectorSearchFilter::query_vector() const {
  // @@protoc_insertion_point(field_list:unhinged.persistence.VectorSearchFilter.query_vector)
  return _internal_query_vector();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
VectorSearchFilter::_internal_mutable_query_vector() {
  return &_impl_.query_vector_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
VectorSearchFilter::mutable_query_vector() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.persistence.VectorSearchFilter.query_vector)
  return _internal_mutable_query_vector();
}

// int32 limit = 3;
inline void VectorSearchFilter::clear_limit() {
  _impl_.limit_ = 0;
}
inline int32_t VectorSearchFilter::_internal_limit() const {
  return _impl_.limit_;
}
inline int32_t VectorSearchFilter::limit() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.VectorSearchFilter.limit)
  return _internal_limit();
}
inline void VectorSearchFilter::_internal_set_limit(int32_t value) {
  
  _impl_.limit_ = value;
}
inline void VectorSearchFilter::set_limit(int32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:unhinged.persistence.VectorSearchFilter.limit)
}

// double threshold = 4;
inline void VectorSearchFilter::clear_threshold() {
  _impl_.threshold_ = 0;
}
inline double VectorSearchFilter::_internal_threshold() const {
  return _impl_.threshold_;
}
inline double VectorSearchFilter::threshold() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.VectorSearchFilter.threshold)
  return _internal_threshold();
}
inline void VectorSearchFilter::_internal_set_threshold(double value) {
  
  _impl_.threshold_ = value;
}
inline void VectorSearchFilter::set_threshold(double value) {
  _internal_set_threshold(value);
  // @@protoc_insertion_point(field_set:unhinged.persistence.VectorSearchFilter.threshold)
}

// string distance_metric = 5;
inline void VectorSearchFilter::clear_distance_metric() {
  _impl_.distance_metric_.ClearToEmpty();
}
inline const std::string& VectorSearchFilter::distance_metric() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.VectorSearchFilter.distance_metric)
  return _internal_distance_metric();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VectorSearchFilter::set_distance_metric(ArgT0&& arg0, ArgT... args) {
 
 _impl_.distance_metric_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.persistence.VectorSearchFilter.distance_metric)
}
inline std::string* VectorSearchFilter::mutable_distance_metric() {
  std::string* _s = _internal_mutable_distance_metric();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.VectorSearchFilter.distance_metric)
  return _s;
}
inline const std::string& VectorSearchFilter::_internal_distance_metric() const {
  return _impl_.distance_metric_.Get();
}
inline void VectorSearchFilter::_internal_set_distance_metric(const std::string& value) {
  
  _impl_.distance_metric_.Set(value, GetArenaForAllocation());
}
inline std::string* VectorSearchFilter::_internal_mutable_distance_metric() {
  
  return _impl_.distance_metric_.Mutable(GetArenaForAllocation());
}
inline std::string* VectorSearchFilter::release_distance_metric() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.VectorSearchFilter.distance_metric)
  return _impl_.distance_metric_.Release();
}
inline void VectorSearchFilter::set_allocated_distance_metric(std::string* distance_metric) {
  if (distance_metric != nullptr) {
    
  } else {
    
  }
  _impl_.distance_metric_.SetAllocated(distance_metric, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.distance_metric_.IsDefault()) {
    _impl_.distance_metric_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.VectorSearchFilter.distance_metric)
}

// -------------------------------------------------------------------

// AndFilter

// repeated .unhinged.persistence.QueryCriteria filters = 1;
inline int AndFilter::_internal_filters_size() const {
  return _impl_.filters_.size();
}
inline int AndFilter::filters_size() const {
  return _internal_filters_size();
}
inline void AndFilter::clear_filters() {
  _impl_.filters_.Clear();
}
inline ::unhinged::persistence::QueryCriteria* AndFilter::mutable_filters(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.AndFilter.filters)
  return _impl_.filters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::persistence::QueryCriteria >*
AndFilter::mutable_filters() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.persistence.AndFilter.filters)
  return &_impl_.filters_;
}
inline const ::unhinged::persistence::QueryCriteria& AndFilter::_internal_filters(int index) const {
  return _impl_.filters_.Get(index);
}
inline const ::unhinged::persistence::QueryCriteria& AndFilter::filters(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.AndFilter.filters)
  return _internal_filters(index);
}
inline ::unhinged::persistence::QueryCriteria* AndFilter::_internal_add_filters() {
  return _impl_.filters_.Add();
}
inline ::unhinged::persistence::QueryCriteria* AndFilter::add_filters() {
  ::unhinged::persistence::QueryCriteria* _add = _internal_add_filters();
  // @@protoc_insertion_point(field_add:unhinged.persistence.AndFilter.filters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::persistence::QueryCriteria >&
AndFilter::filters() const {
  // @@protoc_insertion_point(field_list:unhinged.persistence.AndFilter.filters)
  return _impl_.filters_;
}

// -------------------------------------------------------------------

// OrFilter

// repeated .unhinged.persistence.QueryCriteria filters = 1;
inline int OrFilter::_internal_filters_size() const {
  return _impl_.filters_.size();
}
inline int OrFilter::filters_size() const {
  return _internal_filters_size();
}
inline void OrFilter::clear_filters() {
  _impl_.filters_.Clear();
}
inline ::unhinged::persistence::QueryCriteria* OrFilter::mutable_filters(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.OrFilter.filters)
  return _impl_.filters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::persistence::QueryCriteria >*
OrFilter::mutable_filters() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.persistence.OrFilter.filters)
  return &_impl_.filters_;
}
inline const ::unhinged::persistence::QueryCriteria& OrFilter::_internal_filters(int index) const {
  return _impl_.filters_.Get(index);
}
inline const ::unhinged::persistence::QueryCriteria& OrFilter::filters(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.OrFilter.filters)
  return _internal_filters(index);
}
inline ::unhinged::persistence::QueryCriteria* OrFilter::_internal_add_filters() {
  return _impl_.filters_.Add();
}
inline ::unhinged::persistence::QueryCriteria* OrFilter::add_filters() {
  ::unhinged::persistence::QueryCriteria* _add = _internal_add_filters();
  // @@protoc_insertion_point(field_add:unhinged.persistence.OrFilter.filters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::persistence::QueryCriteria >&
OrFilter::filters() const {
  // @@protoc_insertion_point(field_list:unhinged.persistence.OrFilter.filters)
  return _impl_.filters_;
}

// -------------------------------------------------------------------

// OrderBy

// string field = 1;
inline void OrderBy::clear_field() {
  _impl_.field_.ClearToEmpty();
}
inline const std::string& OrderBy::field() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.OrderBy.field)
  return _internal_field();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrderBy::set_field(ArgT0&& arg0, ArgT... args) {
 
 _impl_.field_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.persistence.OrderBy.field)
}
inline std::string* OrderBy::mutable_field() {
  std::string* _s = _internal_mutable_field();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.OrderBy.field)
  return _s;
}
inline const std::string& OrderBy::_internal_field() const {
  return _impl_.field_.Get();
}
inline void OrderBy::_internal_set_field(const std::string& value) {
  
  _impl_.field_.Set(value, GetArenaForAllocation());
}
inline std::string* OrderBy::_internal_mutable_field() {
  
  return _impl_.field_.Mutable(GetArenaForAllocation());
}
inline std::string* OrderBy::release_field() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.OrderBy.field)
  return _impl_.field_.Release();
}
inline void OrderBy::set_allocated_field(std::string* field) {
  if (field != nullptr) {
    
  } else {
    
  }
  _impl_.field_.SetAllocated(field, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field_.IsDefault()) {
    _impl_.field_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.OrderBy.field)
}

// bool ascending = 2;
inline void OrderBy::clear_ascending() {
  _impl_.ascending_ = false;
}
inline bool OrderBy::_internal_ascending() const {
  return _impl_.ascending_;
}
inline bool OrderBy::ascending() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.OrderBy.ascending)
  return _internal_ascending();
}
inline void OrderBy::_internal_set_ascending(bool value) {
  
  _impl_.ascending_ = value;
}
inline void OrderBy::set_ascending(bool value) {
  _internal_set_ascending(value);
  // @@protoc_insertion_point(field_set:unhinged.persistence.OrderBy.ascending)
}

// -------------------------------------------------------------------

// QuerySpec

// string table_name = 1;
inline void QuerySpec::clear_table_name() {
  _impl_.table_name_.ClearToEmpty();
}
inline const std::string& QuerySpec::table_name() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.QuerySpec.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QuerySpec::set_table_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.table_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.persistence.QuerySpec.table_name)
}
inline std::string* QuerySpec::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.QuerySpec.table_name)
  return _s;
}
inline const std::string& QuerySpec::_internal_table_name() const {
  return _impl_.table_name_.Get();
}
inline void QuerySpec::_internal_set_table_name(const std::string& value) {
  
  _impl_.table_name_.Set(value, GetArenaForAllocation());
}
inline std::string* QuerySpec::_internal_mutable_table_name() {
  
  return _impl_.table_name_.Mutable(GetArenaForAllocation());
}
inline std::string* QuerySpec::release_table_name() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.QuerySpec.table_name)
  return _impl_.table_name_.Release();
}
inline void QuerySpec::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    
  } else {
    
  }
  _impl_.table_name_.SetAllocated(table_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.table_name_.IsDefault()) {
    _impl_.table_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.QuerySpec.table_name)
}

// .unhinged.persistence.QueryType query_type = 2;
inline void QuerySpec::clear_query_type() {
  _impl_.query_type_ = 0;
}
inline ::unhinged::persistence::QueryType QuerySpec::_internal_query_type() const {
  return static_cast< ::unhinged::persistence::QueryType >(_impl_.query_type_);
}
inline ::unhinged::persistence::QueryType QuerySpec::query_type() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.QuerySpec.query_type)
  return _internal_query_type();
}
inline void QuerySpec::_internal_set_query_type(::unhinged::persistence::QueryType value) {
  
  _impl_.query_type_ = value;
}
inline void QuerySpec::set_query_type(::unhinged::persistence::QueryType value) {
  _internal_set_query_type(value);
  // @@protoc_insertion_point(field_set:unhinged.persistence.QuerySpec.query_type)
}

// .unhinged.persistence.QueryCriteria criteria = 3;
inline bool QuerySpec::_internal_has_criteria() const {
  return this != internal_default_instance() && _impl_.criteria_ != nullptr;
}
inline bool QuerySpec::has_criteria() const {
  return _internal_has_criteria();
}
inline void QuerySpec::clear_criteria() {
  if (GetArenaForAllocation() == nullptr && _impl_.criteria_ != nullptr) {
    delete _impl_.criteria_;
  }
  _impl_.criteria_ = nullptr;
}
inline const ::unhinged::persistence::QueryCriteria& QuerySpec::_internal_criteria() const {
  const ::unhinged::persistence::QueryCriteria* p = _impl_.criteria_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::persistence::QueryCriteria&>(
      ::unhinged::persistence::_QueryCriteria_default_instance_);
}
inline const ::unhinged::persistence::QueryCriteria& QuerySpec::criteria() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.QuerySpec.criteria)
  return _internal_criteria();
}
inline void QuerySpec::unsafe_arena_set_allocated_criteria(
    ::unhinged::persistence::QueryCriteria* criteria) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.criteria_);
  }
  _impl_.criteria_ = criteria;
  if (criteria) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.persistence.QuerySpec.criteria)
}
inline ::unhinged::persistence::QueryCriteria* QuerySpec::release_criteria() {
  
  ::unhinged::persistence::QueryCriteria* temp = _impl_.criteria_;
  _impl_.criteria_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::persistence::QueryCriteria* QuerySpec::unsafe_arena_release_criteria() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.QuerySpec.criteria)
  
  ::unhinged::persistence::QueryCriteria* temp = _impl_.criteria_;
  _impl_.criteria_ = nullptr;
  return temp;
}
inline ::unhinged::persistence::QueryCriteria* QuerySpec::_internal_mutable_criteria() {
  
  if (_impl_.criteria_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::persistence::QueryCriteria>(GetArenaForAllocation());
    _impl_.criteria_ = p;
  }
  return _impl_.criteria_;
}
inline ::unhinged::persistence::QueryCriteria* QuerySpec::mutable_criteria() {
  ::unhinged::persistence::QueryCriteria* _msg = _internal_mutable_criteria();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.QuerySpec.criteria)
  return _msg;
}
inline void QuerySpec::set_allocated_criteria(::unhinged::persistence::QueryCriteria* criteria) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.criteria_;
  }
  if (criteria) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(criteria);
    if (message_arena != submessage_arena) {
      criteria = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, criteria, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.criteria_ = criteria;
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.QuerySpec.criteria)
}

// repeated string projections = 4;
inline int QuerySpec::_internal_projections_size() const {
  return _impl_.projections_.size();
}
inline int QuerySpec::projections_size() const {
  return _internal_projections_size();
}
inline void QuerySpec::clear_projections() {
  _impl_.projections_.Clear();
}
inline std::string* QuerySpec::add_projections() {
  std::string* _s = _internal_add_projections();
  // @@protoc_insertion_point(field_add_mutable:unhinged.persistence.QuerySpec.projections)
  return _s;
}
inline const std::string& QuerySpec::_internal_projections(int index) const {
  return _impl_.projections_.Get(index);
}
inline const std::string& QuerySpec::projections(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.QuerySpec.projections)
  return _internal_projections(index);
}
inline std::string* QuerySpec::mutable_projections(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.QuerySpec.projections)
  return _impl_.projections_.Mutable(index);
}
inline void QuerySpec::set_projections(int index, const std::string& value) {
  _impl_.projections_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.persistence.QuerySpec.projections)
}
inline void QuerySpec::set_projections(int index, std::string&& value) {
  _impl_.projections_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.persistence.QuerySpec.projections)
}
inline void QuerySpec::set_projections(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.projections_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.persistence.QuerySpec.projections)
}
inline void QuerySpec::set_projections(int index, const char* value, size_t size) {
  _impl_.projections_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.persistence.QuerySpec.projections)
}
inline std::string* QuerySpec::_internal_add_projections() {
  return _impl_.projections_.Add();
}
inline void QuerySpec::add_projections(const std::string& value) {
  _impl_.projections_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.persistence.QuerySpec.projections)
}
inline void QuerySpec::add_projections(std::string&& value) {
  _impl_.projections_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.persistence.QuerySpec.projections)
}
inline void QuerySpec::add_projections(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.projections_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.persistence.QuerySpec.projections)
}
inline void QuerySpec::add_projections(const char* value, size_t size) {
  _impl_.projections_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.persistence.QuerySpec.projections)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
QuerySpec::projections() const {
  // @@protoc_insertion_point(field_list:unhinged.persistence.QuerySpec.projections)
  return _impl_.projections_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
QuerySpec::mutable_projections() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.persistence.QuerySpec.projections)
  return &_impl_.projections_;
}

// repeated .unhinged.persistence.OrderBy order_by = 5;
inline int QuerySpec::_internal_order_by_size() const {
  return _impl_.order_by_.size();
}
inline int QuerySpec::order_by_size() const {
  return _internal_order_by_size();
}
inline void QuerySpec::clear_order_by() {
  _impl_.order_by_.Clear();
}
inline ::unhinged::persistence::OrderBy* QuerySpec::mutable_order_by(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.QuerySpec.order_by)
  return _impl_.order_by_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::persistence::OrderBy >*
QuerySpec::mutable_order_by() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.persistence.QuerySpec.order_by)
  return &_impl_.order_by_;
}
inline const ::unhinged::persistence::OrderBy& QuerySpec::_internal_order_by(int index) const {
  return _impl_.order_by_.Get(index);
}
inline const ::unhinged::persistence::OrderBy& QuerySpec::order_by(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.QuerySpec.order_by)
  return _internal_order_by(index);
}
inline ::unhinged::persistence::OrderBy* QuerySpec::_internal_add_order_by() {
  return _impl_.order_by_.Add();
}
inline ::unhinged::persistence::OrderBy* QuerySpec::add_order_by() {
  ::unhinged::persistence::OrderBy* _add = _internal_add_order_by();
  // @@protoc_insertion_point(field_add:unhinged.persistence.QuerySpec.order_by)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::persistence::OrderBy >&
QuerySpec::order_by() const {
  // @@protoc_insertion_point(field_list:unhinged.persistence.QuerySpec.order_by)
  return _impl_.order_by_;
}

// int32 limit = 6;
inline void QuerySpec::clear_limit() {
  _impl_.limit_ = 0;
}
inline int32_t QuerySpec::_internal_limit() const {
  return _impl_.limit_;
}
inline int32_t QuerySpec::limit() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.QuerySpec.limit)
  return _internal_limit();
}
inline void QuerySpec::_internal_set_limit(int32_t value) {
  
  _impl_.limit_ = value;
}
inline void QuerySpec::set_limit(int32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:unhinged.persistence.QuerySpec.limit)
}

// int32 offset = 7;
inline void QuerySpec::clear_offset() {
  _impl_.offset_ = 0;
}
inline int32_t QuerySpec::_internal_offset() const {
  return _impl_.offset_;
}
inline int32_t QuerySpec::offset() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.QuerySpec.offset)
  return _internal_offset();
}
inline void QuerySpec::_internal_set_offset(int32_t value) {
  
  _impl_.offset_ = value;
}
inline void QuerySpec::set_offset(int32_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:unhinged.persistence.QuerySpec.offset)
}

// -------------------------------------------------------------------

// InsertRequest

// string table_name = 1;
inline void InsertRequest::clear_table_name() {
  _impl_.table_name_.ClearToEmpty();
}
inline const std::string& InsertRequest::table_name() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.InsertRequest.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InsertRequest::set_table_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.table_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.persistence.InsertRequest.table_name)
}
inline std::string* InsertRequest::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.InsertRequest.table_name)
  return _s;
}
inline const std::string& InsertRequest::_internal_table_name() const {
  return _impl_.table_name_.Get();
}
inline void InsertRequest::_internal_set_table_name(const std::string& value) {
  
  _impl_.table_name_.Set(value, GetArenaForAllocation());
}
inline std::string* InsertRequest::_internal_mutable_table_name() {
  
  return _impl_.table_name_.Mutable(GetArenaForAllocation());
}
inline std::string* InsertRequest::release_table_name() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.InsertRequest.table_name)
  return _impl_.table_name_.Release();
}
inline void InsertRequest::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    
  } else {
    
  }
  _impl_.table_name_.SetAllocated(table_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.table_name_.IsDefault()) {
    _impl_.table_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.InsertRequest.table_name)
}

// .unhinged.persistence.Record record = 2;
inline bool InsertRequest::_internal_has_record() const {
  return this != internal_default_instance() && _impl_.record_ != nullptr;
}
inline bool InsertRequest::has_record() const {
  return _internal_has_record();
}
inline void InsertRequest::clear_record() {
  if (GetArenaForAllocation() == nullptr && _impl_.record_ != nullptr) {
    delete _impl_.record_;
  }
  _impl_.record_ = nullptr;
}
inline const ::unhinged::persistence::Record& InsertRequest::_internal_record() const {
  const ::unhinged::persistence::Record* p = _impl_.record_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::persistence::Record&>(
      ::unhinged::persistence::_Record_default_instance_);
}
inline const ::unhinged::persistence::Record& InsertRequest::record() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.InsertRequest.record)
  return _internal_record();
}
inline void InsertRequest::unsafe_arena_set_allocated_record(
    ::unhinged::persistence::Record* record) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.record_);
  }
  _impl_.record_ = record;
  if (record) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.persistence.InsertRequest.record)
}
inline ::unhinged::persistence::Record* InsertRequest::release_record() {
  
  ::unhinged::persistence::Record* temp = _impl_.record_;
  _impl_.record_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::persistence::Record* InsertRequest::unsafe_arena_release_record() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.InsertRequest.record)
  
  ::unhinged::persistence::Record* temp = _impl_.record_;
  _impl_.record_ = nullptr;
  return temp;
}
inline ::unhinged::persistence::Record* InsertRequest::_internal_mutable_record() {
  
  if (_impl_.record_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::persistence::Record>(GetArenaForAllocation());
    _impl_.record_ = p;
  }
  return _impl_.record_;
}
inline ::unhinged::persistence::Record* InsertRequest::mutable_record() {
  ::unhinged::persistence::Record* _msg = _internal_mutable_record();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.InsertRequest.record)
  return _msg;
}
inline void InsertRequest::set_allocated_record(::unhinged::persistence::Record* record) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.record_;
  }
  if (record) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(record);
    if (message_arena != submessage_arena) {
      record = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, record, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.record_ = record;
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.InsertRequest.record)
}

// .unhinged.persistence.ExecutionContext context = 3;
inline bool InsertRequest::_internal_has_context() const {
  return this != internal_default_instance() && _impl_.context_ != nullptr;
}
inline bool InsertRequest::has_context() const {
  return _internal_has_context();
}
inline void InsertRequest::clear_context() {
  if (GetArenaForAllocation() == nullptr && _impl_.context_ != nullptr) {
    delete _impl_.context_;
  }
  _impl_.context_ = nullptr;
}
inline const ::unhinged::persistence::ExecutionContext& InsertRequest::_internal_context() const {
  const ::unhinged::persistence::ExecutionContext* p = _impl_.context_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::persistence::ExecutionContext&>(
      ::unhinged::persistence::_ExecutionContext_default_instance_);
}
inline const ::unhinged::persistence::ExecutionContext& InsertRequest::context() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.InsertRequest.context)
  return _internal_context();
}
inline void InsertRequest::unsafe_arena_set_allocated_context(
    ::unhinged::persistence::ExecutionContext* context) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.context_);
  }
  _impl_.context_ = context;
  if (context) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.persistence.InsertRequest.context)
}
inline ::unhinged::persistence::ExecutionContext* InsertRequest::release_context() {
  
  ::unhinged::persistence::ExecutionContext* temp = _impl_.context_;
  _impl_.context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::persistence::ExecutionContext* InsertRequest::unsafe_arena_release_context() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.InsertRequest.context)
  
  ::unhinged::persistence::ExecutionContext* temp = _impl_.context_;
  _impl_.context_ = nullptr;
  return temp;
}
inline ::unhinged::persistence::ExecutionContext* InsertRequest::_internal_mutable_context() {
  
  if (_impl_.context_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::persistence::ExecutionContext>(GetArenaForAllocation());
    _impl_.context_ = p;
  }
  return _impl_.context_;
}
inline ::unhinged::persistence::ExecutionContext* InsertRequest::mutable_context() {
  ::unhinged::persistence::ExecutionContext* _msg = _internal_mutable_context();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.InsertRequest.context)
  return _msg;
}
inline void InsertRequest::set_allocated_context(::unhinged::persistence::ExecutionContext* context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.context_;
  }
  if (context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(context);
    if (message_arena != submessage_arena) {
      context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, context, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.context_ = context;
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.InsertRequest.context)
}

// -------------------------------------------------------------------

// InsertResponse

// bool success = 1;
inline void InsertResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool InsertResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool InsertResponse::success() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.InsertResponse.success)
  return _internal_success();
}
inline void InsertResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void InsertResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:unhinged.persistence.InsertResponse.success)
}

// .unhinged.persistence.Record record = 2;
inline bool InsertResponse::_internal_has_record() const {
  return this != internal_default_instance() && _impl_.record_ != nullptr;
}
inline bool InsertResponse::has_record() const {
  return _internal_has_record();
}
inline void InsertResponse::clear_record() {
  if (GetArenaForAllocation() == nullptr && _impl_.record_ != nullptr) {
    delete _impl_.record_;
  }
  _impl_.record_ = nullptr;
}
inline const ::unhinged::persistence::Record& InsertResponse::_internal_record() const {
  const ::unhinged::persistence::Record* p = _impl_.record_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::persistence::Record&>(
      ::unhinged::persistence::_Record_default_instance_);
}
inline const ::unhinged::persistence::Record& InsertResponse::record() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.InsertResponse.record)
  return _internal_record();
}
inline void InsertResponse::unsafe_arena_set_allocated_record(
    ::unhinged::persistence::Record* record) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.record_);
  }
  _impl_.record_ = record;
  if (record) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.persistence.InsertResponse.record)
}
inline ::unhinged::persistence::Record* InsertResponse::release_record() {
  
  ::unhinged::persistence::Record* temp = _impl_.record_;
  _impl_.record_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::persistence::Record* InsertResponse::unsafe_arena_release_record() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.InsertResponse.record)
  
  ::unhinged::persistence::Record* temp = _impl_.record_;
  _impl_.record_ = nullptr;
  return temp;
}
inline ::unhinged::persistence::Record* InsertResponse::_internal_mutable_record() {
  
  if (_impl_.record_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::persistence::Record>(GetArenaForAllocation());
    _impl_.record_ = p;
  }
  return _impl_.record_;
}
inline ::unhinged::persistence::Record* InsertResponse::mutable_record() {
  ::unhinged::persistence::Record* _msg = _internal_mutable_record();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.InsertResponse.record)
  return _msg;
}
inline void InsertResponse::set_allocated_record(::unhinged::persistence::Record* record) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.record_;
  }
  if (record) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(record);
    if (message_arena != submessage_arena) {
      record = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, record, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.record_ = record;
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.InsertResponse.record)
}

// string error_message = 3;
inline void InsertResponse::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& InsertResponse::error_message() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.InsertResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InsertResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.persistence.InsertResponse.error_message)
}
inline std::string* InsertResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.InsertResponse.error_message)
  return _s;
}
inline const std::string& InsertResponse::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void InsertResponse::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* InsertResponse::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* InsertResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.InsertResponse.error_message)
  return _impl_.error_message_.Release();
}
inline void InsertResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.InsertResponse.error_message)
}

// int64 execution_time_ms = 4;
inline void InsertResponse::clear_execution_time_ms() {
  _impl_.execution_time_ms_ = int64_t{0};
}
inline int64_t InsertResponse::_internal_execution_time_ms() const {
  return _impl_.execution_time_ms_;
}
inline int64_t InsertResponse::execution_time_ms() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.InsertResponse.execution_time_ms)
  return _internal_execution_time_ms();
}
inline void InsertResponse::_internal_set_execution_time_ms(int64_t value) {
  
  _impl_.execution_time_ms_ = value;
}
inline void InsertResponse::set_execution_time_ms(int64_t value) {
  _internal_set_execution_time_ms(value);
  // @@protoc_insertion_point(field_set:unhinged.persistence.InsertResponse.execution_time_ms)
}

// -------------------------------------------------------------------

// InsertBatchRequest

// string table_name = 1;
inline void InsertBatchRequest::clear_table_name() {
  _impl_.table_name_.ClearToEmpty();
}
inline const std::string& InsertBatchRequest::table_name() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.InsertBatchRequest.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InsertBatchRequest::set_table_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.table_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.persistence.InsertBatchRequest.table_name)
}
inline std::string* InsertBatchRequest::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.InsertBatchRequest.table_name)
  return _s;
}
inline const std::string& InsertBatchRequest::_internal_table_name() const {
  return _impl_.table_name_.Get();
}
inline void InsertBatchRequest::_internal_set_table_name(const std::string& value) {
  
  _impl_.table_name_.Set(value, GetArenaForAllocation());
}
inline std::string* InsertBatchRequest::_internal_mutable_table_name() {
  
  return _impl_.table_name_.Mutable(GetArenaForAllocation());
}
inline std::string* InsertBatchRequest::release_table_name() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.InsertBatchRequest.table_name)
  return _impl_.table_name_.Release();
}
inline void InsertBatchRequest::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    
  } else {
    
  }
  _impl_.table_name_.SetAllocated(table_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.table_name_.IsDefault()) {
    _impl_.table_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.InsertBatchRequest.table_name)
}

// repeated .unhinged.persistence.Record records = 2;
inline int InsertBatchRequest::_internal_records_size() const {
  return _impl_.records_.size();
}
inline int InsertBatchRequest::records_size() const {
  return _internal_records_size();
}
inline void InsertBatchRequest::clear_records() {
  _impl_.records_.Clear();
}
inline ::unhinged::persistence::Record* InsertBatchRequest::mutable_records(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.InsertBatchRequest.records)
  return _impl_.records_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::persistence::Record >*
InsertBatchRequest::mutable_records() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.persistence.InsertBatchRequest.records)
  return &_impl_.records_;
}
inline const ::unhinged::persistence::Record& InsertBatchRequest::_internal_records(int index) const {
  return _impl_.records_.Get(index);
}
inline const ::unhinged::persistence::Record& InsertBatchRequest::records(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.InsertBatchRequest.records)
  return _internal_records(index);
}
inline ::unhinged::persistence::Record* InsertBatchRequest::_internal_add_records() {
  return _impl_.records_.Add();
}
inline ::unhinged::persistence::Record* InsertBatchRequest::add_records() {
  ::unhinged::persistence::Record* _add = _internal_add_records();
  // @@protoc_insertion_point(field_add:unhinged.persistence.InsertBatchRequest.records)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::persistence::Record >&
InsertBatchRequest::records() const {
  // @@protoc_insertion_point(field_list:unhinged.persistence.InsertBatchRequest.records)
  return _impl_.records_;
}

// .unhinged.persistence.ExecutionContext context = 3;
inline bool InsertBatchRequest::_internal_has_context() const {
  return this != internal_default_instance() && _impl_.context_ != nullptr;
}
inline bool InsertBatchRequest::has_context() const {
  return _internal_has_context();
}
inline void InsertBatchRequest::clear_context() {
  if (GetArenaForAllocation() == nullptr && _impl_.context_ != nullptr) {
    delete _impl_.context_;
  }
  _impl_.context_ = nullptr;
}
inline const ::unhinged::persistence::ExecutionContext& InsertBatchRequest::_internal_context() const {
  const ::unhinged::persistence::ExecutionContext* p = _impl_.context_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::persistence::ExecutionContext&>(
      ::unhinged::persistence::_ExecutionContext_default_instance_);
}
inline const ::unhinged::persistence::ExecutionContext& InsertBatchRequest::context() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.InsertBatchRequest.context)
  return _internal_context();
}
inline void InsertBatchRequest::unsafe_arena_set_allocated_context(
    ::unhinged::persistence::ExecutionContext* context) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.context_);
  }
  _impl_.context_ = context;
  if (context) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.persistence.InsertBatchRequest.context)
}
inline ::unhinged::persistence::ExecutionContext* InsertBatchRequest::release_context() {
  
  ::unhinged::persistence::ExecutionContext* temp = _impl_.context_;
  _impl_.context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::persistence::ExecutionContext* InsertBatchRequest::unsafe_arena_release_context() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.InsertBatchRequest.context)
  
  ::unhinged::persistence::ExecutionContext* temp = _impl_.context_;
  _impl_.context_ = nullptr;
  return temp;
}
inline ::unhinged::persistence::ExecutionContext* InsertBatchRequest::_internal_mutable_context() {
  
  if (_impl_.context_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::persistence::ExecutionContext>(GetArenaForAllocation());
    _impl_.context_ = p;
  }
  return _impl_.context_;
}
inline ::unhinged::persistence::ExecutionContext* InsertBatchRequest::mutable_context() {
  ::unhinged::persistence::ExecutionContext* _msg = _internal_mutable_context();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.InsertBatchRequest.context)
  return _msg;
}
inline void InsertBatchRequest::set_allocated_context(::unhinged::persistence::ExecutionContext* context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.context_;
  }
  if (context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(context);
    if (message_arena != submessage_arena) {
      context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, context, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.context_ = context;
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.InsertBatchRequest.context)
}

// -------------------------------------------------------------------

// InsertBatchResponse

// bool success = 1;
inline void InsertBatchResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool InsertBatchResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool InsertBatchResponse::success() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.InsertBatchResponse.success)
  return _internal_success();
}
inline void InsertBatchResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void InsertBatchResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:unhinged.persistence.InsertBatchResponse.success)
}

// repeated .unhinged.persistence.Record records = 2;
inline int InsertBatchResponse::_internal_records_size() const {
  return _impl_.records_.size();
}
inline int InsertBatchResponse::records_size() const {
  return _internal_records_size();
}
inline void InsertBatchResponse::clear_records() {
  _impl_.records_.Clear();
}
inline ::unhinged::persistence::Record* InsertBatchResponse::mutable_records(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.InsertBatchResponse.records)
  return _impl_.records_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::persistence::Record >*
InsertBatchResponse::mutable_records() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.persistence.InsertBatchResponse.records)
  return &_impl_.records_;
}
inline const ::unhinged::persistence::Record& InsertBatchResponse::_internal_records(int index) const {
  return _impl_.records_.Get(index);
}
inline const ::unhinged::persistence::Record& InsertBatchResponse::records(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.InsertBatchResponse.records)
  return _internal_records(index);
}
inline ::unhinged::persistence::Record* InsertBatchResponse::_internal_add_records() {
  return _impl_.records_.Add();
}
inline ::unhinged::persistence::Record* InsertBatchResponse::add_records() {
  ::unhinged::persistence::Record* _add = _internal_add_records();
  // @@protoc_insertion_point(field_add:unhinged.persistence.InsertBatchResponse.records)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::persistence::Record >&
InsertBatchResponse::records() const {
  // @@protoc_insertion_point(field_list:unhinged.persistence.InsertBatchResponse.records)
  return _impl_.records_;
}

// int32 inserted_count = 3;
inline void InsertBatchResponse::clear_inserted_count() {
  _impl_.inserted_count_ = 0;
}
inline int32_t InsertBatchResponse::_internal_inserted_count() const {
  return _impl_.inserted_count_;
}
inline int32_t InsertBatchResponse::inserted_count() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.InsertBatchResponse.inserted_count)
  return _internal_inserted_count();
}
inline void InsertBatchResponse::_internal_set_inserted_count(int32_t value) {
  
  _impl_.inserted_count_ = value;
}
inline void InsertBatchResponse::set_inserted_count(int32_t value) {
  _internal_set_inserted_count(value);
  // @@protoc_insertion_point(field_set:unhinged.persistence.InsertBatchResponse.inserted_count)
}

// string error_message = 4;
inline void InsertBatchResponse::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& InsertBatchResponse::error_message() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.InsertBatchResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InsertBatchResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.persistence.InsertBatchResponse.error_message)
}
inline std::string* InsertBatchResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.InsertBatchResponse.error_message)
  return _s;
}
inline const std::string& InsertBatchResponse::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void InsertBatchResponse::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* InsertBatchResponse::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* InsertBatchResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.InsertBatchResponse.error_message)
  return _impl_.error_message_.Release();
}
inline void InsertBatchResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.InsertBatchResponse.error_message)
}

// int64 execution_time_ms = 5;
inline void InsertBatchResponse::clear_execution_time_ms() {
  _impl_.execution_time_ms_ = int64_t{0};
}
inline int64_t InsertBatchResponse::_internal_execution_time_ms() const {
  return _impl_.execution_time_ms_;
}
inline int64_t InsertBatchResponse::execution_time_ms() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.InsertBatchResponse.execution_time_ms)
  return _internal_execution_time_ms();
}
inline void InsertBatchResponse::_internal_set_execution_time_ms(int64_t value) {
  
  _impl_.execution_time_ms_ = value;
}
inline void InsertBatchResponse::set_execution_time_ms(int64_t value) {
  _internal_set_execution_time_ms(value);
  // @@protoc_insertion_point(field_set:unhinged.persistence.InsertBatchResponse.execution_time_ms)
}

// -------------------------------------------------------------------

// UpdateRequest

// string table_name = 1;
inline void UpdateRequest::clear_table_name() {
  _impl_.table_name_.ClearToEmpty();
}
inline const std::string& UpdateRequest::table_name() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.UpdateRequest.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateRequest::set_table_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.table_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.persistence.UpdateRequest.table_name)
}
inline std::string* UpdateRequest::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.UpdateRequest.table_name)
  return _s;
}
inline const std::string& UpdateRequest::_internal_table_name() const {
  return _impl_.table_name_.Get();
}
inline void UpdateRequest::_internal_set_table_name(const std::string& value) {
  
  _impl_.table_name_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateRequest::_internal_mutable_table_name() {
  
  return _impl_.table_name_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateRequest::release_table_name() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.UpdateRequest.table_name)
  return _impl_.table_name_.Release();
}
inline void UpdateRequest::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    
  } else {
    
  }
  _impl_.table_name_.SetAllocated(table_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.table_name_.IsDefault()) {
    _impl_.table_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.UpdateRequest.table_name)
}

// string id = 2;
inline void UpdateRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& UpdateRequest::id() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.UpdateRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.persistence.UpdateRequest.id)
}
inline std::string* UpdateRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.UpdateRequest.id)
  return _s;
}
inline const std::string& UpdateRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void UpdateRequest::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateRequest::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateRequest::release_id() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.UpdateRequest.id)
  return _impl_.id_.Release();
}
inline void UpdateRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.UpdateRequest.id)
}

// .google.protobuf.Struct updates = 3;
inline bool UpdateRequest::_internal_has_updates() const {
  return this != internal_default_instance() && _impl_.updates_ != nullptr;
}
inline bool UpdateRequest::has_updates() const {
  return _internal_has_updates();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& UpdateRequest::_internal_updates() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.updates_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& UpdateRequest::updates() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.UpdateRequest.updates)
  return _internal_updates();
}
inline void UpdateRequest::unsafe_arena_set_allocated_updates(
    ::PROTOBUF_NAMESPACE_ID::Struct* updates) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.updates_);
  }
  _impl_.updates_ = updates;
  if (updates) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.persistence.UpdateRequest.updates)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* UpdateRequest::release_updates() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.updates_;
  _impl_.updates_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* UpdateRequest::unsafe_arena_release_updates() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.UpdateRequest.updates)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.updates_;
  _impl_.updates_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* UpdateRequest::_internal_mutable_updates() {
  
  if (_impl_.updates_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.updates_ = p;
  }
  return _impl_.updates_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* UpdateRequest::mutable_updates() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_updates();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.UpdateRequest.updates)
  return _msg;
}
inline void UpdateRequest::set_allocated_updates(::PROTOBUF_NAMESPACE_ID::Struct* updates) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.updates_);
  }
  if (updates) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(updates));
    if (message_arena != submessage_arena) {
      updates = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, updates, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.updates_ = updates;
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.UpdateRequest.updates)
}

// .unhinged.persistence.ExecutionContext context = 4;
inline bool UpdateRequest::_internal_has_context() const {
  return this != internal_default_instance() && _impl_.context_ != nullptr;
}
inline bool UpdateRequest::has_context() const {
  return _internal_has_context();
}
inline void UpdateRequest::clear_context() {
  if (GetArenaForAllocation() == nullptr && _impl_.context_ != nullptr) {
    delete _impl_.context_;
  }
  _impl_.context_ = nullptr;
}
inline const ::unhinged::persistence::ExecutionContext& UpdateRequest::_internal_context() const {
  const ::unhinged::persistence::ExecutionContext* p = _impl_.context_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::persistence::ExecutionContext&>(
      ::unhinged::persistence::_ExecutionContext_default_instance_);
}
inline const ::unhinged::persistence::ExecutionContext& UpdateRequest::context() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.UpdateRequest.context)
  return _internal_context();
}
inline void UpdateRequest::unsafe_arena_set_allocated_context(
    ::unhinged::persistence::ExecutionContext* context) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.context_);
  }
  _impl_.context_ = context;
  if (context) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.persistence.UpdateRequest.context)
}
inline ::unhinged::persistence::ExecutionContext* UpdateRequest::release_context() {
  
  ::unhinged::persistence::ExecutionContext* temp = _impl_.context_;
  _impl_.context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::persistence::ExecutionContext* UpdateRequest::unsafe_arena_release_context() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.UpdateRequest.context)
  
  ::unhinged::persistence::ExecutionContext* temp = _impl_.context_;
  _impl_.context_ = nullptr;
  return temp;
}
inline ::unhinged::persistence::ExecutionContext* UpdateRequest::_internal_mutable_context() {
  
  if (_impl_.context_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::persistence::ExecutionContext>(GetArenaForAllocation());
    _impl_.context_ = p;
  }
  return _impl_.context_;
}
inline ::unhinged::persistence::ExecutionContext* UpdateRequest::mutable_context() {
  ::unhinged::persistence::ExecutionContext* _msg = _internal_mutable_context();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.UpdateRequest.context)
  return _msg;
}
inline void UpdateRequest::set_allocated_context(::unhinged::persistence::ExecutionContext* context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.context_;
  }
  if (context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(context);
    if (message_arena != submessage_arena) {
      context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, context, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.context_ = context;
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.UpdateRequest.context)
}

// -------------------------------------------------------------------

// UpdateResponse

// bool success = 1;
inline void UpdateResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool UpdateResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool UpdateResponse::success() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.UpdateResponse.success)
  return _internal_success();
}
inline void UpdateResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void UpdateResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:unhinged.persistence.UpdateResponse.success)
}

// .unhinged.persistence.Record record = 2;
inline bool UpdateResponse::_internal_has_record() const {
  return this != internal_default_instance() && _impl_.record_ != nullptr;
}
inline bool UpdateResponse::has_record() const {
  return _internal_has_record();
}
inline void UpdateResponse::clear_record() {
  if (GetArenaForAllocation() == nullptr && _impl_.record_ != nullptr) {
    delete _impl_.record_;
  }
  _impl_.record_ = nullptr;
}
inline const ::unhinged::persistence::Record& UpdateResponse::_internal_record() const {
  const ::unhinged::persistence::Record* p = _impl_.record_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::persistence::Record&>(
      ::unhinged::persistence::_Record_default_instance_);
}
inline const ::unhinged::persistence::Record& UpdateResponse::record() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.UpdateResponse.record)
  return _internal_record();
}
inline void UpdateResponse::unsafe_arena_set_allocated_record(
    ::unhinged::persistence::Record* record) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.record_);
  }
  _impl_.record_ = record;
  if (record) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.persistence.UpdateResponse.record)
}
inline ::unhinged::persistence::Record* UpdateResponse::release_record() {
  
  ::unhinged::persistence::Record* temp = _impl_.record_;
  _impl_.record_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::persistence::Record* UpdateResponse::unsafe_arena_release_record() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.UpdateResponse.record)
  
  ::unhinged::persistence::Record* temp = _impl_.record_;
  _impl_.record_ = nullptr;
  return temp;
}
inline ::unhinged::persistence::Record* UpdateResponse::_internal_mutable_record() {
  
  if (_impl_.record_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::persistence::Record>(GetArenaForAllocation());
    _impl_.record_ = p;
  }
  return _impl_.record_;
}
inline ::unhinged::persistence::Record* UpdateResponse::mutable_record() {
  ::unhinged::persistence::Record* _msg = _internal_mutable_record();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.UpdateResponse.record)
  return _msg;
}
inline void UpdateResponse::set_allocated_record(::unhinged::persistence::Record* record) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.record_;
  }
  if (record) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(record);
    if (message_arena != submessage_arena) {
      record = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, record, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.record_ = record;
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.UpdateResponse.record)
}

// string error_message = 3;
inline void UpdateResponse::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& UpdateResponse::error_message() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.UpdateResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.persistence.UpdateResponse.error_message)
}
inline std::string* UpdateResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.UpdateResponse.error_message)
  return _s;
}
inline const std::string& UpdateResponse::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void UpdateResponse::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateResponse::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.UpdateResponse.error_message)
  return _impl_.error_message_.Release();
}
inline void UpdateResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.UpdateResponse.error_message)
}

// int64 execution_time_ms = 4;
inline void UpdateResponse::clear_execution_time_ms() {
  _impl_.execution_time_ms_ = int64_t{0};
}
inline int64_t UpdateResponse::_internal_execution_time_ms() const {
  return _impl_.execution_time_ms_;
}
inline int64_t UpdateResponse::execution_time_ms() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.UpdateResponse.execution_time_ms)
  return _internal_execution_time_ms();
}
inline void UpdateResponse::_internal_set_execution_time_ms(int64_t value) {
  
  _impl_.execution_time_ms_ = value;
}
inline void UpdateResponse::set_execution_time_ms(int64_t value) {
  _internal_set_execution_time_ms(value);
  // @@protoc_insertion_point(field_set:unhinged.persistence.UpdateResponse.execution_time_ms)
}

// -------------------------------------------------------------------

// DeleteRequest

// string table_name = 1;
inline void DeleteRequest::clear_table_name() {
  _impl_.table_name_.ClearToEmpty();
}
inline const std::string& DeleteRequest::table_name() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.DeleteRequest.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteRequest::set_table_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.table_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.persistence.DeleteRequest.table_name)
}
inline std::string* DeleteRequest::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.DeleteRequest.table_name)
  return _s;
}
inline const std::string& DeleteRequest::_internal_table_name() const {
  return _impl_.table_name_.Get();
}
inline void DeleteRequest::_internal_set_table_name(const std::string& value) {
  
  _impl_.table_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteRequest::_internal_mutable_table_name() {
  
  return _impl_.table_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteRequest::release_table_name() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.DeleteRequest.table_name)
  return _impl_.table_name_.Release();
}
inline void DeleteRequest::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    
  } else {
    
  }
  _impl_.table_name_.SetAllocated(table_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.table_name_.IsDefault()) {
    _impl_.table_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.DeleteRequest.table_name)
}

// .unhinged.persistence.QueryCriteria criteria = 2;
inline bool DeleteRequest::_internal_has_criteria() const {
  return this != internal_default_instance() && _impl_.criteria_ != nullptr;
}
inline bool DeleteRequest::has_criteria() const {
  return _internal_has_criteria();
}
inline void DeleteRequest::clear_criteria() {
  if (GetArenaForAllocation() == nullptr && _impl_.criteria_ != nullptr) {
    delete _impl_.criteria_;
  }
  _impl_.criteria_ = nullptr;
}
inline const ::unhinged::persistence::QueryCriteria& DeleteRequest::_internal_criteria() const {
  const ::unhinged::persistence::QueryCriteria* p = _impl_.criteria_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::persistence::QueryCriteria&>(
      ::unhinged::persistence::_QueryCriteria_default_instance_);
}
inline const ::unhinged::persistence::QueryCriteria& DeleteRequest::criteria() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.DeleteRequest.criteria)
  return _internal_criteria();
}
inline void DeleteRequest::unsafe_arena_set_allocated_criteria(
    ::unhinged::persistence::QueryCriteria* criteria) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.criteria_);
  }
  _impl_.criteria_ = criteria;
  if (criteria) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.persistence.DeleteRequest.criteria)
}
inline ::unhinged::persistence::QueryCriteria* DeleteRequest::release_criteria() {
  
  ::unhinged::persistence::QueryCriteria* temp = _impl_.criteria_;
  _impl_.criteria_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::persistence::QueryCriteria* DeleteRequest::unsafe_arena_release_criteria() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.DeleteRequest.criteria)
  
  ::unhinged::persistence::QueryCriteria* temp = _impl_.criteria_;
  _impl_.criteria_ = nullptr;
  return temp;
}
inline ::unhinged::persistence::QueryCriteria* DeleteRequest::_internal_mutable_criteria() {
  
  if (_impl_.criteria_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::persistence::QueryCriteria>(GetArenaForAllocation());
    _impl_.criteria_ = p;
  }
  return _impl_.criteria_;
}
inline ::unhinged::persistence::QueryCriteria* DeleteRequest::mutable_criteria() {
  ::unhinged::persistence::QueryCriteria* _msg = _internal_mutable_criteria();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.DeleteRequest.criteria)
  return _msg;
}
inline void DeleteRequest::set_allocated_criteria(::unhinged::persistence::QueryCriteria* criteria) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.criteria_;
  }
  if (criteria) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(criteria);
    if (message_arena != submessage_arena) {
      criteria = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, criteria, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.criteria_ = criteria;
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.DeleteRequest.criteria)
}

// .unhinged.persistence.ExecutionContext context = 3;
inline bool DeleteRequest::_internal_has_context() const {
  return this != internal_default_instance() && _impl_.context_ != nullptr;
}
inline bool DeleteRequest::has_context() const {
  return _internal_has_context();
}
inline void DeleteRequest::clear_context() {
  if (GetArenaForAllocation() == nullptr && _impl_.context_ != nullptr) {
    delete _impl_.context_;
  }
  _impl_.context_ = nullptr;
}
inline const ::unhinged::persistence::ExecutionContext& DeleteRequest::_internal_context() const {
  const ::unhinged::persistence::ExecutionContext* p = _impl_.context_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::persistence::ExecutionContext&>(
      ::unhinged::persistence::_ExecutionContext_default_instance_);
}
inline const ::unhinged::persistence::ExecutionContext& DeleteRequest::context() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.DeleteRequest.context)
  return _internal_context();
}
inline void DeleteRequest::unsafe_arena_set_allocated_context(
    ::unhinged::persistence::ExecutionContext* context) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.context_);
  }
  _impl_.context_ = context;
  if (context) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.persistence.DeleteRequest.context)
}
inline ::unhinged::persistence::ExecutionContext* DeleteRequest::release_context() {
  
  ::unhinged::persistence::ExecutionContext* temp = _impl_.context_;
  _impl_.context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::persistence::ExecutionContext* DeleteRequest::unsafe_arena_release_context() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.DeleteRequest.context)
  
  ::unhinged::persistence::ExecutionContext* temp = _impl_.context_;
  _impl_.context_ = nullptr;
  return temp;
}
inline ::unhinged::persistence::ExecutionContext* DeleteRequest::_internal_mutable_context() {
  
  if (_impl_.context_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::persistence::ExecutionContext>(GetArenaForAllocation());
    _impl_.context_ = p;
  }
  return _impl_.context_;
}
inline ::unhinged::persistence::ExecutionContext* DeleteRequest::mutable_context() {
  ::unhinged::persistence::ExecutionContext* _msg = _internal_mutable_context();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.DeleteRequest.context)
  return _msg;
}
inline void DeleteRequest::set_allocated_context(::unhinged::persistence::ExecutionContext* context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.context_;
  }
  if (context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(context);
    if (message_arena != submessage_arena) {
      context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, context, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.context_ = context;
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.DeleteRequest.context)
}

// -------------------------------------------------------------------

// DeleteResponse

// bool success = 1;
inline void DeleteResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool DeleteResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool DeleteResponse::success() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.DeleteResponse.success)
  return _internal_success();
}
inline void DeleteResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void DeleteResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:unhinged.persistence.DeleteResponse.success)
}

// int64 deleted_count = 2;
inline void DeleteResponse::clear_deleted_count() {
  _impl_.deleted_count_ = int64_t{0};
}
inline int64_t DeleteResponse::_internal_deleted_count() const {
  return _impl_.deleted_count_;
}
inline int64_t DeleteResponse::deleted_count() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.DeleteResponse.deleted_count)
  return _internal_deleted_count();
}
inline void DeleteResponse::_internal_set_deleted_count(int64_t value) {
  
  _impl_.deleted_count_ = value;
}
inline void DeleteResponse::set_deleted_count(int64_t value) {
  _internal_set_deleted_count(value);
  // @@protoc_insertion_point(field_set:unhinged.persistence.DeleteResponse.deleted_count)
}

// string error_message = 3;
inline void DeleteResponse::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& DeleteResponse::error_message() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.DeleteResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.persistence.DeleteResponse.error_message)
}
inline std::string* DeleteResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.DeleteResponse.error_message)
  return _s;
}
inline const std::string& DeleteResponse::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void DeleteResponse::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteResponse::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.DeleteResponse.error_message)
  return _impl_.error_message_.Release();
}
inline void DeleteResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.DeleteResponse.error_message)
}

// int64 execution_time_ms = 4;
inline void DeleteResponse::clear_execution_time_ms() {
  _impl_.execution_time_ms_ = int64_t{0};
}
inline int64_t DeleteResponse::_internal_execution_time_ms() const {
  return _impl_.execution_time_ms_;
}
inline int64_t DeleteResponse::execution_time_ms() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.DeleteResponse.execution_time_ms)
  return _internal_execution_time_ms();
}
inline void DeleteResponse::_internal_set_execution_time_ms(int64_t value) {
  
  _impl_.execution_time_ms_ = value;
}
inline void DeleteResponse::set_execution_time_ms(int64_t value) {
  _internal_set_execution_time_ms(value);
  // @@protoc_insertion_point(field_set:unhinged.persistence.DeleteResponse.execution_time_ms)
}

// -------------------------------------------------------------------

// ExecuteQueryRequest

// string query_name = 1;
inline void ExecuteQueryRequest::clear_query_name() {
  _impl_.query_name_.ClearToEmpty();
}
inline const std::string& ExecuteQueryRequest::query_name() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.ExecuteQueryRequest.query_name)
  return _internal_query_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecuteQueryRequest::set_query_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.query_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.persistence.ExecuteQueryRequest.query_name)
}
inline std::string* ExecuteQueryRequest::mutable_query_name() {
  std::string* _s = _internal_mutable_query_name();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.ExecuteQueryRequest.query_name)
  return _s;
}
inline const std::string& ExecuteQueryRequest::_internal_query_name() const {
  return _impl_.query_name_.Get();
}
inline void ExecuteQueryRequest::_internal_set_query_name(const std::string& value) {
  
  _impl_.query_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ExecuteQueryRequest::_internal_mutable_query_name() {
  
  return _impl_.query_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ExecuteQueryRequest::release_query_name() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.ExecuteQueryRequest.query_name)
  return _impl_.query_name_.Release();
}
inline void ExecuteQueryRequest::set_allocated_query_name(std::string* query_name) {
  if (query_name != nullptr) {
    
  } else {
    
  }
  _impl_.query_name_.SetAllocated(query_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.query_name_.IsDefault()) {
    _impl_.query_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.ExecuteQueryRequest.query_name)
}

// .google.protobuf.Struct parameters = 2;
inline bool ExecuteQueryRequest::_internal_has_parameters() const {
  return this != internal_default_instance() && _impl_.parameters_ != nullptr;
}
inline bool ExecuteQueryRequest::has_parameters() const {
  return _internal_has_parameters();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& ExecuteQueryRequest::_internal_parameters() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.parameters_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& ExecuteQueryRequest::parameters() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.ExecuteQueryRequest.parameters)
  return _internal_parameters();
}
inline void ExecuteQueryRequest::unsafe_arena_set_allocated_parameters(
    ::PROTOBUF_NAMESPACE_ID::Struct* parameters) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.parameters_);
  }
  _impl_.parameters_ = parameters;
  if (parameters) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.persistence.ExecuteQueryRequest.parameters)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ExecuteQueryRequest::release_parameters() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.parameters_;
  _impl_.parameters_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ExecuteQueryRequest::unsafe_arena_release_parameters() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.ExecuteQueryRequest.parameters)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.parameters_;
  _impl_.parameters_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ExecuteQueryRequest::_internal_mutable_parameters() {
  
  if (_impl_.parameters_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.parameters_ = p;
  }
  return _impl_.parameters_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ExecuteQueryRequest::mutable_parameters() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_parameters();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.ExecuteQueryRequest.parameters)
  return _msg;
}
inline void ExecuteQueryRequest::set_allocated_parameters(::PROTOBUF_NAMESPACE_ID::Struct* parameters) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.parameters_);
  }
  if (parameters) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(parameters));
    if (message_arena != submessage_arena) {
      parameters = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parameters, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.parameters_ = parameters;
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.ExecuteQueryRequest.parameters)
}

// .unhinged.persistence.ExecutionContext context = 3;
inline bool ExecuteQueryRequest::_internal_has_context() const {
  return this != internal_default_instance() && _impl_.context_ != nullptr;
}
inline bool ExecuteQueryRequest::has_context() const {
  return _internal_has_context();
}
inline void ExecuteQueryRequest::clear_context() {
  if (GetArenaForAllocation() == nullptr && _impl_.context_ != nullptr) {
    delete _impl_.context_;
  }
  _impl_.context_ = nullptr;
}
inline const ::unhinged::persistence::ExecutionContext& ExecuteQueryRequest::_internal_context() const {
  const ::unhinged::persistence::ExecutionContext* p = _impl_.context_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::persistence::ExecutionContext&>(
      ::unhinged::persistence::_ExecutionContext_default_instance_);
}
inline const ::unhinged::persistence::ExecutionContext& ExecuteQueryRequest::context() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.ExecuteQueryRequest.context)
  return _internal_context();
}
inline void ExecuteQueryRequest::unsafe_arena_set_allocated_context(
    ::unhinged::persistence::ExecutionContext* context) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.context_);
  }
  _impl_.context_ = context;
  if (context) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.persistence.ExecuteQueryRequest.context)
}
inline ::unhinged::persistence::ExecutionContext* ExecuteQueryRequest::release_context() {
  
  ::unhinged::persistence::ExecutionContext* temp = _impl_.context_;
  _impl_.context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::persistence::ExecutionContext* ExecuteQueryRequest::unsafe_arena_release_context() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.ExecuteQueryRequest.context)
  
  ::unhinged::persistence::ExecutionContext* temp = _impl_.context_;
  _impl_.context_ = nullptr;
  return temp;
}
inline ::unhinged::persistence::ExecutionContext* ExecuteQueryRequest::_internal_mutable_context() {
  
  if (_impl_.context_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::persistence::ExecutionContext>(GetArenaForAllocation());
    _impl_.context_ = p;
  }
  return _impl_.context_;
}
inline ::unhinged::persistence::ExecutionContext* ExecuteQueryRequest::mutable_context() {
  ::unhinged::persistence::ExecutionContext* _msg = _internal_mutable_context();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.ExecuteQueryRequest.context)
  return _msg;
}
inline void ExecuteQueryRequest::set_allocated_context(::unhinged::persistence::ExecutionContext* context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.context_;
  }
  if (context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(context);
    if (message_arena != submessage_arena) {
      context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, context, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.context_ = context;
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.ExecuteQueryRequest.context)
}

// -------------------------------------------------------------------

// ExecuteQueryResponse

// bool success = 1;
inline void ExecuteQueryResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool ExecuteQueryResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool ExecuteQueryResponse::success() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.ExecuteQueryResponse.success)
  return _internal_success();
}
inline void ExecuteQueryResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void ExecuteQueryResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:unhinged.persistence.ExecuteQueryResponse.success)
}

// repeated .unhinged.persistence.Record results = 2;
inline int ExecuteQueryResponse::_internal_results_size() const {
  return _impl_.results_.size();
}
inline int ExecuteQueryResponse::results_size() const {
  return _internal_results_size();
}
inline void ExecuteQueryResponse::clear_results() {
  _impl_.results_.Clear();
}
inline ::unhinged::persistence::Record* ExecuteQueryResponse::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.ExecuteQueryResponse.results)
  return _impl_.results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::persistence::Record >*
ExecuteQueryResponse::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.persistence.ExecuteQueryResponse.results)
  return &_impl_.results_;
}
inline const ::unhinged::persistence::Record& ExecuteQueryResponse::_internal_results(int index) const {
  return _impl_.results_.Get(index);
}
inline const ::unhinged::persistence::Record& ExecuteQueryResponse::results(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.ExecuteQueryResponse.results)
  return _internal_results(index);
}
inline ::unhinged::persistence::Record* ExecuteQueryResponse::_internal_add_results() {
  return _impl_.results_.Add();
}
inline ::unhinged::persistence::Record* ExecuteQueryResponse::add_results() {
  ::unhinged::persistence::Record* _add = _internal_add_results();
  // @@protoc_insertion_point(field_add:unhinged.persistence.ExecuteQueryResponse.results)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::persistence::Record >&
ExecuteQueryResponse::results() const {
  // @@protoc_insertion_point(field_list:unhinged.persistence.ExecuteQueryResponse.results)
  return _impl_.results_;
}

// int32 count = 3;
inline void ExecuteQueryResponse::clear_count() {
  _impl_.count_ = 0;
}
inline int32_t ExecuteQueryResponse::_internal_count() const {
  return _impl_.count_;
}
inline int32_t ExecuteQueryResponse::count() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.ExecuteQueryResponse.count)
  return _internal_count();
}
inline void ExecuteQueryResponse::_internal_set_count(int32_t value) {
  
  _impl_.count_ = value;
}
inline void ExecuteQueryResponse::set_count(int32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:unhinged.persistence.ExecuteQueryResponse.count)
}

// string error_message = 4;
inline void ExecuteQueryResponse::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& ExecuteQueryResponse::error_message() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.ExecuteQueryResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecuteQueryResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.persistence.ExecuteQueryResponse.error_message)
}
inline std::string* ExecuteQueryResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.ExecuteQueryResponse.error_message)
  return _s;
}
inline const std::string& ExecuteQueryResponse::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void ExecuteQueryResponse::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* ExecuteQueryResponse::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* ExecuteQueryResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.ExecuteQueryResponse.error_message)
  return _impl_.error_message_.Release();
}
inline void ExecuteQueryResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.ExecuteQueryResponse.error_message)
}

// int64 execution_time_ms = 5;
inline void ExecuteQueryResponse::clear_execution_time_ms() {
  _impl_.execution_time_ms_ = int64_t{0};
}
inline int64_t ExecuteQueryResponse::_internal_execution_time_ms() const {
  return _impl_.execution_time_ms_;
}
inline int64_t ExecuteQueryResponse::execution_time_ms() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.ExecuteQueryResponse.execution_time_ms)
  return _internal_execution_time_ms();
}
inline void ExecuteQueryResponse::_internal_set_execution_time_ms(int64_t value) {
  
  _impl_.execution_time_ms_ = value;
}
inline void ExecuteQueryResponse::set_execution_time_ms(int64_t value) {
  _internal_set_execution_time_ms(value);
  // @@protoc_insertion_point(field_set:unhinged.persistence.ExecuteQueryResponse.execution_time_ms)
}

// bool from_cache = 6;
inline void ExecuteQueryResponse::clear_from_cache() {
  _impl_.from_cache_ = false;
}
inline bool ExecuteQueryResponse::_internal_from_cache() const {
  return _impl_.from_cache_;
}
inline bool ExecuteQueryResponse::from_cache() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.ExecuteQueryResponse.from_cache)
  return _internal_from_cache();
}
inline void ExecuteQueryResponse::_internal_set_from_cache(bool value) {
  
  _impl_.from_cache_ = value;
}
inline void ExecuteQueryResponse::set_from_cache(bool value) {
  _internal_set_from_cache(value);
  // @@protoc_insertion_point(field_set:unhinged.persistence.ExecuteQueryResponse.from_cache)
}

// -------------------------------------------------------------------

// ExecuteRawQueryRequest

// .unhinged.persistence.QuerySpec query_spec = 1;
inline bool ExecuteRawQueryRequest::_internal_has_query_spec() const {
  return this != internal_default_instance() && _impl_.query_spec_ != nullptr;
}
inline bool ExecuteRawQueryRequest::has_query_spec() const {
  return _internal_has_query_spec();
}
inline void ExecuteRawQueryRequest::clear_query_spec() {
  if (GetArenaForAllocation() == nullptr && _impl_.query_spec_ != nullptr) {
    delete _impl_.query_spec_;
  }
  _impl_.query_spec_ = nullptr;
}
inline const ::unhinged::persistence::QuerySpec& ExecuteRawQueryRequest::_internal_query_spec() const {
  const ::unhinged::persistence::QuerySpec* p = _impl_.query_spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::persistence::QuerySpec&>(
      ::unhinged::persistence::_QuerySpec_default_instance_);
}
inline const ::unhinged::persistence::QuerySpec& ExecuteRawQueryRequest::query_spec() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.ExecuteRawQueryRequest.query_spec)
  return _internal_query_spec();
}
inline void ExecuteRawQueryRequest::unsafe_arena_set_allocated_query_spec(
    ::unhinged::persistence::QuerySpec* query_spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.query_spec_);
  }
  _impl_.query_spec_ = query_spec;
  if (query_spec) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.persistence.ExecuteRawQueryRequest.query_spec)
}
inline ::unhinged::persistence::QuerySpec* ExecuteRawQueryRequest::release_query_spec() {
  
  ::unhinged::persistence::QuerySpec* temp = _impl_.query_spec_;
  _impl_.query_spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::persistence::QuerySpec* ExecuteRawQueryRequest::unsafe_arena_release_query_spec() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.ExecuteRawQueryRequest.query_spec)
  
  ::unhinged::persistence::QuerySpec* temp = _impl_.query_spec_;
  _impl_.query_spec_ = nullptr;
  return temp;
}
inline ::unhinged::persistence::QuerySpec* ExecuteRawQueryRequest::_internal_mutable_query_spec() {
  
  if (_impl_.query_spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::persistence::QuerySpec>(GetArenaForAllocation());
    _impl_.query_spec_ = p;
  }
  return _impl_.query_spec_;
}
inline ::unhinged::persistence::QuerySpec* ExecuteRawQueryRequest::mutable_query_spec() {
  ::unhinged::persistence::QuerySpec* _msg = _internal_mutable_query_spec();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.ExecuteRawQueryRequest.query_spec)
  return _msg;
}
inline void ExecuteRawQueryRequest::set_allocated_query_spec(::unhinged::persistence::QuerySpec* query_spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.query_spec_;
  }
  if (query_spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(query_spec);
    if (message_arena != submessage_arena) {
      query_spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, query_spec, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.query_spec_ = query_spec;
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.ExecuteRawQueryRequest.query_spec)
}

// .unhinged.persistence.ExecutionContext context = 2;
inline bool ExecuteRawQueryRequest::_internal_has_context() const {
  return this != internal_default_instance() && _impl_.context_ != nullptr;
}
inline bool ExecuteRawQueryRequest::has_context() const {
  return _internal_has_context();
}
inline void ExecuteRawQueryRequest::clear_context() {
  if (GetArenaForAllocation() == nullptr && _impl_.context_ != nullptr) {
    delete _impl_.context_;
  }
  _impl_.context_ = nullptr;
}
inline const ::unhinged::persistence::ExecutionContext& ExecuteRawQueryRequest::_internal_context() const {
  const ::unhinged::persistence::ExecutionContext* p = _impl_.context_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::persistence::ExecutionContext&>(
      ::unhinged::persistence::_ExecutionContext_default_instance_);
}
inline const ::unhinged::persistence::ExecutionContext& ExecuteRawQueryRequest::context() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.ExecuteRawQueryRequest.context)
  return _internal_context();
}
inline void ExecuteRawQueryRequest::unsafe_arena_set_allocated_context(
    ::unhinged::persistence::ExecutionContext* context) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.context_);
  }
  _impl_.context_ = context;
  if (context) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.persistence.ExecuteRawQueryRequest.context)
}
inline ::unhinged::persistence::ExecutionContext* ExecuteRawQueryRequest::release_context() {
  
  ::unhinged::persistence::ExecutionContext* temp = _impl_.context_;
  _impl_.context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::persistence::ExecutionContext* ExecuteRawQueryRequest::unsafe_arena_release_context() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.ExecuteRawQueryRequest.context)
  
  ::unhinged::persistence::ExecutionContext* temp = _impl_.context_;
  _impl_.context_ = nullptr;
  return temp;
}
inline ::unhinged::persistence::ExecutionContext* ExecuteRawQueryRequest::_internal_mutable_context() {
  
  if (_impl_.context_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::persistence::ExecutionContext>(GetArenaForAllocation());
    _impl_.context_ = p;
  }
  return _impl_.context_;
}
inline ::unhinged::persistence::ExecutionContext* ExecuteRawQueryRequest::mutable_context() {
  ::unhinged::persistence::ExecutionContext* _msg = _internal_mutable_context();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.ExecuteRawQueryRequest.context)
  return _msg;
}
inline void ExecuteRawQueryRequest::set_allocated_context(::unhinged::persistence::ExecutionContext* context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.context_;
  }
  if (context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(context);
    if (message_arena != submessage_arena) {
      context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, context, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.context_ = context;
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.ExecuteRawQueryRequest.context)
}

// -------------------------------------------------------------------

// ExecuteRawQueryResponse

// bool success = 1;
inline void ExecuteRawQueryResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool ExecuteRawQueryResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool ExecuteRawQueryResponse::success() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.ExecuteRawQueryResponse.success)
  return _internal_success();
}
inline void ExecuteRawQueryResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void ExecuteRawQueryResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:unhinged.persistence.ExecuteRawQueryResponse.success)
}

// repeated .unhinged.persistence.Record results = 2;
inline int ExecuteRawQueryResponse::_internal_results_size() const {
  return _impl_.results_.size();
}
inline int ExecuteRawQueryResponse::results_size() const {
  return _internal_results_size();
}
inline void ExecuteRawQueryResponse::clear_results() {
  _impl_.results_.Clear();
}
inline ::unhinged::persistence::Record* ExecuteRawQueryResponse::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.ExecuteRawQueryResponse.results)
  return _impl_.results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::persistence::Record >*
ExecuteRawQueryResponse::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.persistence.ExecuteRawQueryResponse.results)
  return &_impl_.results_;
}
inline const ::unhinged::persistence::Record& ExecuteRawQueryResponse::_internal_results(int index) const {
  return _impl_.results_.Get(index);
}
inline const ::unhinged::persistence::Record& ExecuteRawQueryResponse::results(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.ExecuteRawQueryResponse.results)
  return _internal_results(index);
}
inline ::unhinged::persistence::Record* ExecuteRawQueryResponse::_internal_add_results() {
  return _impl_.results_.Add();
}
inline ::unhinged::persistence::Record* ExecuteRawQueryResponse::add_results() {
  ::unhinged::persistence::Record* _add = _internal_add_results();
  // @@protoc_insertion_point(field_add:unhinged.persistence.ExecuteRawQueryResponse.results)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::persistence::Record >&
ExecuteRawQueryResponse::results() const {
  // @@protoc_insertion_point(field_list:unhinged.persistence.ExecuteRawQueryResponse.results)
  return _impl_.results_;
}

// int32 count = 3;
inline void ExecuteRawQueryResponse::clear_count() {
  _impl_.count_ = 0;
}
inline int32_t ExecuteRawQueryResponse::_internal_count() const {
  return _impl_.count_;
}
inline int32_t ExecuteRawQueryResponse::count() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.ExecuteRawQueryResponse.count)
  return _internal_count();
}
inline void ExecuteRawQueryResponse::_internal_set_count(int32_t value) {
  
  _impl_.count_ = value;
}
inline void ExecuteRawQueryResponse::set_count(int32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:unhinged.persistence.ExecuteRawQueryResponse.count)
}

// string error_message = 4;
inline void ExecuteRawQueryResponse::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& ExecuteRawQueryResponse::error_message() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.ExecuteRawQueryResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecuteRawQueryResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.persistence.ExecuteRawQueryResponse.error_message)
}
inline std::string* ExecuteRawQueryResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.ExecuteRawQueryResponse.error_message)
  return _s;
}
inline const std::string& ExecuteRawQueryResponse::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void ExecuteRawQueryResponse::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* ExecuteRawQueryResponse::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* ExecuteRawQueryResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.ExecuteRawQueryResponse.error_message)
  return _impl_.error_message_.Release();
}
inline void ExecuteRawQueryResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.ExecuteRawQueryResponse.error_message)
}

// int64 execution_time_ms = 5;
inline void ExecuteRawQueryResponse::clear_execution_time_ms() {
  _impl_.execution_time_ms_ = int64_t{0};
}
inline int64_t ExecuteRawQueryResponse::_internal_execution_time_ms() const {
  return _impl_.execution_time_ms_;
}
inline int64_t ExecuteRawQueryResponse::execution_time_ms() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.ExecuteRawQueryResponse.execution_time_ms)
  return _internal_execution_time_ms();
}
inline void ExecuteRawQueryResponse::_internal_set_execution_time_ms(int64_t value) {
  
  _impl_.execution_time_ms_ = value;
}
inline void ExecuteRawQueryResponse::set_execution_time_ms(int64_t value) {
  _internal_set_execution_time_ms(value);
  // @@protoc_insertion_point(field_set:unhinged.persistence.ExecuteRawQueryResponse.execution_time_ms)
}

// -------------------------------------------------------------------

// VectorSearchRequest

// string table_name = 1;
inline void VectorSearchRequest::clear_table_name() {
  _impl_.table_name_.ClearToEmpty();
}
inline const std::string& VectorSearchRequest::table_name() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.VectorSearchRequest.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VectorSearchRequest::set_table_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.table_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.persistence.VectorSearchRequest.table_name)
}
inline std::string* VectorSearchRequest::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.VectorSearchRequest.table_name)
  return _s;
}
inline const std::string& VectorSearchRequest::_internal_table_name() const {
  return _impl_.table_name_.Get();
}
inline void VectorSearchRequest::_internal_set_table_name(const std::string& value) {
  
  _impl_.table_name_.Set(value, GetArenaForAllocation());
}
inline std::string* VectorSearchRequest::_internal_mutable_table_name() {
  
  return _impl_.table_name_.Mutable(GetArenaForAllocation());
}
inline std::string* VectorSearchRequest::release_table_name() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.VectorSearchRequest.table_name)
  return _impl_.table_name_.Release();
}
inline void VectorSearchRequest::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    
  } else {
    
  }
  _impl_.table_name_.SetAllocated(table_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.table_name_.IsDefault()) {
    _impl_.table_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.VectorSearchRequest.table_name)
}

// repeated float query_vector = 2;
inline int VectorSearchRequest::_internal_query_vector_size() const {
  return _impl_.query_vector_.size();
}
inline int VectorSearchRequest::query_vector_size() const {
  return _internal_query_vector_size();
}
inline void VectorSearchRequest::clear_query_vector() {
  _impl_.query_vector_.Clear();
}
inline float VectorSearchRequest::_internal_query_vector(int index) const {
  return _impl_.query_vector_.Get(index);
}
inline float VectorSearchRequest::query_vector(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.VectorSearchRequest.query_vector)
  return _internal_query_vector(index);
}
inline void VectorSearchRequest::set_query_vector(int index, float value) {
  _impl_.query_vector_.Set(index, value);
  // @@protoc_insertion_point(field_set:unhinged.persistence.VectorSearchRequest.query_vector)
}
inline void VectorSearchRequest::_internal_add_query_vector(float value) {
  _impl_.query_vector_.Add(value);
}
inline void VectorSearchRequest::add_query_vector(float value) {
  _internal_add_query_vector(value);
  // @@protoc_insertion_point(field_add:unhinged.persistence.VectorSearchRequest.query_vector)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
VectorSearchRequest::_internal_query_vector() const {
  return _impl_.query_vector_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
VectorSearchRequest::query_vector() const {
  // @@protoc_insertion_point(field_list:unhinged.persistence.VectorSearchRequest.query_vector)
  return _internal_query_vector();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
VectorSearchRequest::_internal_mutable_query_vector() {
  return &_impl_.query_vector_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
VectorSearchRequest::mutable_query_vector() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.persistence.VectorSearchRequest.query_vector)
  return _internal_mutable_query_vector();
}

// int32 limit = 3;
inline void VectorSearchRequest::clear_limit() {
  _impl_.limit_ = 0;
}
inline int32_t VectorSearchRequest::_internal_limit() const {
  return _impl_.limit_;
}
inline int32_t VectorSearchRequest::limit() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.VectorSearchRequest.limit)
  return _internal_limit();
}
inline void VectorSearchRequest::_internal_set_limit(int32_t value) {
  
  _impl_.limit_ = value;
}
inline void VectorSearchRequest::set_limit(int32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:unhinged.persistence.VectorSearchRequest.limit)
}

// double threshold = 4;
inline void VectorSearchRequest::clear_threshold() {
  _impl_.threshold_ = 0;
}
inline double VectorSearchRequest::_internal_threshold() const {
  return _impl_.threshold_;
}
inline double VectorSearchRequest::threshold() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.VectorSearchRequest.threshold)
  return _internal_threshold();
}
inline void VectorSearchRequest::_internal_set_threshold(double value) {
  
  _impl_.threshold_ = value;
}
inline void VectorSearchRequest::set_threshold(double value) {
  _internal_set_threshold(value);
  // @@protoc_insertion_point(field_set:unhinged.persistence.VectorSearchRequest.threshold)
}

// string distance_metric = 5;
inline void VectorSearchRequest::clear_distance_metric() {
  _impl_.distance_metric_.ClearToEmpty();
}
inline const std::string& VectorSearchRequest::distance_metric() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.VectorSearchRequest.distance_metric)
  return _internal_distance_metric();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VectorSearchRequest::set_distance_metric(ArgT0&& arg0, ArgT... args) {
 
 _impl_.distance_metric_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.persistence.VectorSearchRequest.distance_metric)
}
inline std::string* VectorSearchRequest::mutable_distance_metric() {
  std::string* _s = _internal_mutable_distance_metric();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.VectorSearchRequest.distance_metric)
  return _s;
}
inline const std::string& VectorSearchRequest::_internal_distance_metric() const {
  return _impl_.distance_metric_.Get();
}
inline void VectorSearchRequest::_internal_set_distance_metric(const std::string& value) {
  
  _impl_.distance_metric_.Set(value, GetArenaForAllocation());
}
inline std::string* VectorSearchRequest::_internal_mutable_distance_metric() {
  
  return _impl_.distance_metric_.Mutable(GetArenaForAllocation());
}
inline std::string* VectorSearchRequest::release_distance_metric() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.VectorSearchRequest.distance_metric)
  return _impl_.distance_metric_.Release();
}
inline void VectorSearchRequest::set_allocated_distance_metric(std::string* distance_metric) {
  if (distance_metric != nullptr) {
    
  } else {
    
  }
  _impl_.distance_metric_.SetAllocated(distance_metric, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.distance_metric_.IsDefault()) {
    _impl_.distance_metric_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.VectorSearchRequest.distance_metric)
}

// .unhinged.persistence.ExecutionContext context = 6;
inline bool VectorSearchRequest::_internal_has_context() const {
  return this != internal_default_instance() && _impl_.context_ != nullptr;
}
inline bool VectorSearchRequest::has_context() const {
  return _internal_has_context();
}
inline void VectorSearchRequest::clear_context() {
  if (GetArenaForAllocation() == nullptr && _impl_.context_ != nullptr) {
    delete _impl_.context_;
  }
  _impl_.context_ = nullptr;
}
inline const ::unhinged::persistence::ExecutionContext& VectorSearchRequest::_internal_context() const {
  const ::unhinged::persistence::ExecutionContext* p = _impl_.context_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::persistence::ExecutionContext&>(
      ::unhinged::persistence::_ExecutionContext_default_instance_);
}
inline const ::unhinged::persistence::ExecutionContext& VectorSearchRequest::context() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.VectorSearchRequest.context)
  return _internal_context();
}
inline void VectorSearchRequest::unsafe_arena_set_allocated_context(
    ::unhinged::persistence::ExecutionContext* context) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.context_);
  }
  _impl_.context_ = context;
  if (context) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.persistence.VectorSearchRequest.context)
}
inline ::unhinged::persistence::ExecutionContext* VectorSearchRequest::release_context() {
  
  ::unhinged::persistence::ExecutionContext* temp = _impl_.context_;
  _impl_.context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::persistence::ExecutionContext* VectorSearchRequest::unsafe_arena_release_context() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.VectorSearchRequest.context)
  
  ::unhinged::persistence::ExecutionContext* temp = _impl_.context_;
  _impl_.context_ = nullptr;
  return temp;
}
inline ::unhinged::persistence::ExecutionContext* VectorSearchRequest::_internal_mutable_context() {
  
  if (_impl_.context_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::persistence::ExecutionContext>(GetArenaForAllocation());
    _impl_.context_ = p;
  }
  return _impl_.context_;
}
inline ::unhinged::persistence::ExecutionContext* VectorSearchRequest::mutable_context() {
  ::unhinged::persistence::ExecutionContext* _msg = _internal_mutable_context();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.VectorSearchRequest.context)
  return _msg;
}
inline void VectorSearchRequest::set_allocated_context(::unhinged::persistence::ExecutionContext* context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.context_;
  }
  if (context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(context);
    if (message_arena != submessage_arena) {
      context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, context, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.context_ = context;
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.VectorSearchRequest.context)
}

// -------------------------------------------------------------------

// VectorSearchResponse

// bool success = 1;
inline void VectorSearchResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool VectorSearchResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool VectorSearchResponse::success() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.VectorSearchResponse.success)
  return _internal_success();
}
inline void VectorSearchResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void VectorSearchResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:unhinged.persistence.VectorSearchResponse.success)
}

// repeated .unhinged.persistence.VectorSearchResult results = 2;
inline int VectorSearchResponse::_internal_results_size() const {
  return _impl_.results_.size();
}
inline int VectorSearchResponse::results_size() const {
  return _internal_results_size();
}
inline void VectorSearchResponse::clear_results() {
  _impl_.results_.Clear();
}
inline ::unhinged::persistence::VectorSearchResult* VectorSearchResponse::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.VectorSearchResponse.results)
  return _impl_.results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::persistence::VectorSearchResult >*
VectorSearchResponse::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.persistence.VectorSearchResponse.results)
  return &_impl_.results_;
}
inline const ::unhinged::persistence::VectorSearchResult& VectorSearchResponse::_internal_results(int index) const {
  return _impl_.results_.Get(index);
}
inline const ::unhinged::persistence::VectorSearchResult& VectorSearchResponse::results(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.VectorSearchResponse.results)
  return _internal_results(index);
}
inline ::unhinged::persistence::VectorSearchResult* VectorSearchResponse::_internal_add_results() {
  return _impl_.results_.Add();
}
inline ::unhinged::persistence::VectorSearchResult* VectorSearchResponse::add_results() {
  ::unhinged::persistence::VectorSearchResult* _add = _internal_add_results();
  // @@protoc_insertion_point(field_add:unhinged.persistence.VectorSearchResponse.results)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::persistence::VectorSearchResult >&
VectorSearchResponse::results() const {
  // @@protoc_insertion_point(field_list:unhinged.persistence.VectorSearchResponse.results)
  return _impl_.results_;
}

// string error_message = 3;
inline void VectorSearchResponse::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& VectorSearchResponse::error_message() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.VectorSearchResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VectorSearchResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.persistence.VectorSearchResponse.error_message)
}
inline std::string* VectorSearchResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.VectorSearchResponse.error_message)
  return _s;
}
inline const std::string& VectorSearchResponse::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void VectorSearchResponse::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* VectorSearchResponse::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* VectorSearchResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.VectorSearchResponse.error_message)
  return _impl_.error_message_.Release();
}
inline void VectorSearchResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.VectorSearchResponse.error_message)
}

// int64 execution_time_ms = 4;
inline void VectorSearchResponse::clear_execution_time_ms() {
  _impl_.execution_time_ms_ = int64_t{0};
}
inline int64_t VectorSearchResponse::_internal_execution_time_ms() const {
  return _impl_.execution_time_ms_;
}
inline int64_t VectorSearchResponse::execution_time_ms() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.VectorSearchResponse.execution_time_ms)
  return _internal_execution_time_ms();
}
inline void VectorSearchResponse::_internal_set_execution_time_ms(int64_t value) {
  
  _impl_.execution_time_ms_ = value;
}
inline void VectorSearchResponse::set_execution_time_ms(int64_t value) {
  _internal_set_execution_time_ms(value);
  // @@protoc_insertion_point(field_set:unhinged.persistence.VectorSearchResponse.execution_time_ms)
}

// -------------------------------------------------------------------

// VectorSearchResult

// .unhinged.persistence.Record record = 1;
inline bool VectorSearchResult::_internal_has_record() const {
  return this != internal_default_instance() && _impl_.record_ != nullptr;
}
inline bool VectorSearchResult::has_record() const {
  return _internal_has_record();
}
inline void VectorSearchResult::clear_record() {
  if (GetArenaForAllocation() == nullptr && _impl_.record_ != nullptr) {
    delete _impl_.record_;
  }
  _impl_.record_ = nullptr;
}
inline const ::unhinged::persistence::Record& VectorSearchResult::_internal_record() const {
  const ::unhinged::persistence::Record* p = _impl_.record_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::persistence::Record&>(
      ::unhinged::persistence::_Record_default_instance_);
}
inline const ::unhinged::persistence::Record& VectorSearchResult::record() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.VectorSearchResult.record)
  return _internal_record();
}
inline void VectorSearchResult::unsafe_arena_set_allocated_record(
    ::unhinged::persistence::Record* record) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.record_);
  }
  _impl_.record_ = record;
  if (record) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.persistence.VectorSearchResult.record)
}
inline ::unhinged::persistence::Record* VectorSearchResult::release_record() {
  
  ::unhinged::persistence::Record* temp = _impl_.record_;
  _impl_.record_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::persistence::Record* VectorSearchResult::unsafe_arena_release_record() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.VectorSearchResult.record)
  
  ::unhinged::persistence::Record* temp = _impl_.record_;
  _impl_.record_ = nullptr;
  return temp;
}
inline ::unhinged::persistence::Record* VectorSearchResult::_internal_mutable_record() {
  
  if (_impl_.record_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::persistence::Record>(GetArenaForAllocation());
    _impl_.record_ = p;
  }
  return _impl_.record_;
}
inline ::unhinged::persistence::Record* VectorSearchResult::mutable_record() {
  ::unhinged::persistence::Record* _msg = _internal_mutable_record();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.VectorSearchResult.record)
  return _msg;
}
inline void VectorSearchResult::set_allocated_record(::unhinged::persistence::Record* record) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.record_;
  }
  if (record) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(record);
    if (message_arena != submessage_arena) {
      record = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, record, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.record_ = record;
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.VectorSearchResult.record)
}

// double similarity_score = 2;
inline void VectorSearchResult::clear_similarity_score() {
  _impl_.similarity_score_ = 0;
}
inline double VectorSearchResult::_internal_similarity_score() const {
  return _impl_.similarity_score_;
}
inline double VectorSearchResult::similarity_score() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.VectorSearchResult.similarity_score)
  return _internal_similarity_score();
}
inline void VectorSearchResult::_internal_set_similarity_score(double value) {
  
  _impl_.similarity_score_ = value;
}
inline void VectorSearchResult::set_similarity_score(double value) {
  _internal_set_similarity_score(value);
  // @@protoc_insertion_point(field_set:unhinged.persistence.VectorSearchResult.similarity_score)
}

// double distance = 3;
inline void VectorSearchResult::clear_distance() {
  _impl_.distance_ = 0;
}
inline double VectorSearchResult::_internal_distance() const {
  return _impl_.distance_;
}
inline double VectorSearchResult::distance() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.VectorSearchResult.distance)
  return _internal_distance();
}
inline void VectorSearchResult::_internal_set_distance(double value) {
  
  _impl_.distance_ = value;
}
inline void VectorSearchResult::set_distance(double value) {
  _internal_set_distance(value);
  // @@protoc_insertion_point(field_set:unhinged.persistence.VectorSearchResult.distance)
}

// -------------------------------------------------------------------

// GraphTraverseRequest

// string table_name = 1;
inline void GraphTraverseRequest::clear_table_name() {
  _impl_.table_name_.ClearToEmpty();
}
inline const std::string& GraphTraverseRequest::table_name() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.GraphTraverseRequest.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GraphTraverseRequest::set_table_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.table_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.persistence.GraphTraverseRequest.table_name)
}
inline std::string* GraphTraverseRequest::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.GraphTraverseRequest.table_name)
  return _s;
}
inline const std::string& GraphTraverseRequest::_internal_table_name() const {
  return _impl_.table_name_.Get();
}
inline void GraphTraverseRequest::_internal_set_table_name(const std::string& value) {
  
  _impl_.table_name_.Set(value, GetArenaForAllocation());
}
inline std::string* GraphTraverseRequest::_internal_mutable_table_name() {
  
  return _impl_.table_name_.Mutable(GetArenaForAllocation());
}
inline std::string* GraphTraverseRequest::release_table_name() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.GraphTraverseRequest.table_name)
  return _impl_.table_name_.Release();
}
inline void GraphTraverseRequest::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    
  } else {
    
  }
  _impl_.table_name_.SetAllocated(table_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.table_name_.IsDefault()) {
    _impl_.table_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.GraphTraverseRequest.table_name)
}

// string start_node = 2;
inline void GraphTraverseRequest::clear_start_node() {
  _impl_.start_node_.ClearToEmpty();
}
inline const std::string& GraphTraverseRequest::start_node() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.GraphTraverseRequest.start_node)
  return _internal_start_node();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GraphTraverseRequest::set_start_node(ArgT0&& arg0, ArgT... args) {
 
 _impl_.start_node_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.persistence.GraphTraverseRequest.start_node)
}
inline std::string* GraphTraverseRequest::mutable_start_node() {
  std::string* _s = _internal_mutable_start_node();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.GraphTraverseRequest.start_node)
  return _s;
}
inline const std::string& GraphTraverseRequest::_internal_start_node() const {
  return _impl_.start_node_.Get();
}
inline void GraphTraverseRequest::_internal_set_start_node(const std::string& value) {
  
  _impl_.start_node_.Set(value, GetArenaForAllocation());
}
inline std::string* GraphTraverseRequest::_internal_mutable_start_node() {
  
  return _impl_.start_node_.Mutable(GetArenaForAllocation());
}
inline std::string* GraphTraverseRequest::release_start_node() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.GraphTraverseRequest.start_node)
  return _impl_.start_node_.Release();
}
inline void GraphTraverseRequest::set_allocated_start_node(std::string* start_node) {
  if (start_node != nullptr) {
    
  } else {
    
  }
  _impl_.start_node_.SetAllocated(start_node, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.start_node_.IsDefault()) {
    _impl_.start_node_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.GraphTraverseRequest.start_node)
}

// .unhinged.persistence.GraphTraversalSpec traversal_spec = 3;
inline bool GraphTraverseRequest::_internal_has_traversal_spec() const {
  return this != internal_default_instance() && _impl_.traversal_spec_ != nullptr;
}
inline bool GraphTraverseRequest::has_traversal_spec() const {
  return _internal_has_traversal_spec();
}
inline void GraphTraverseRequest::clear_traversal_spec() {
  if (GetArenaForAllocation() == nullptr && _impl_.traversal_spec_ != nullptr) {
    delete _impl_.traversal_spec_;
  }
  _impl_.traversal_spec_ = nullptr;
}
inline const ::unhinged::persistence::GraphTraversalSpec& GraphTraverseRequest::_internal_traversal_spec() const {
  const ::unhinged::persistence::GraphTraversalSpec* p = _impl_.traversal_spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::persistence::GraphTraversalSpec&>(
      ::unhinged::persistence::_GraphTraversalSpec_default_instance_);
}
inline const ::unhinged::persistence::GraphTraversalSpec& GraphTraverseRequest::traversal_spec() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.GraphTraverseRequest.traversal_spec)
  return _internal_traversal_spec();
}
inline void GraphTraverseRequest::unsafe_arena_set_allocated_traversal_spec(
    ::unhinged::persistence::GraphTraversalSpec* traversal_spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.traversal_spec_);
  }
  _impl_.traversal_spec_ = traversal_spec;
  if (traversal_spec) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.persistence.GraphTraverseRequest.traversal_spec)
}
inline ::unhinged::persistence::GraphTraversalSpec* GraphTraverseRequest::release_traversal_spec() {
  
  ::unhinged::persistence::GraphTraversalSpec* temp = _impl_.traversal_spec_;
  _impl_.traversal_spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::persistence::GraphTraversalSpec* GraphTraverseRequest::unsafe_arena_release_traversal_spec() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.GraphTraverseRequest.traversal_spec)
  
  ::unhinged::persistence::GraphTraversalSpec* temp = _impl_.traversal_spec_;
  _impl_.traversal_spec_ = nullptr;
  return temp;
}
inline ::unhinged::persistence::GraphTraversalSpec* GraphTraverseRequest::_internal_mutable_traversal_spec() {
  
  if (_impl_.traversal_spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::persistence::GraphTraversalSpec>(GetArenaForAllocation());
    _impl_.traversal_spec_ = p;
  }
  return _impl_.traversal_spec_;
}
inline ::unhinged::persistence::GraphTraversalSpec* GraphTraverseRequest::mutable_traversal_spec() {
  ::unhinged::persistence::GraphTraversalSpec* _msg = _internal_mutable_traversal_spec();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.GraphTraverseRequest.traversal_spec)
  return _msg;
}
inline void GraphTraverseRequest::set_allocated_traversal_spec(::unhinged::persistence::GraphTraversalSpec* traversal_spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.traversal_spec_;
  }
  if (traversal_spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(traversal_spec);
    if (message_arena != submessage_arena) {
      traversal_spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, traversal_spec, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.traversal_spec_ = traversal_spec;
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.GraphTraverseRequest.traversal_spec)
}

// .unhinged.persistence.ExecutionContext context = 4;
inline bool GraphTraverseRequest::_internal_has_context() const {
  return this != internal_default_instance() && _impl_.context_ != nullptr;
}
inline bool GraphTraverseRequest::has_context() const {
  return _internal_has_context();
}
inline void GraphTraverseRequest::clear_context() {
  if (GetArenaForAllocation() == nullptr && _impl_.context_ != nullptr) {
    delete _impl_.context_;
  }
  _impl_.context_ = nullptr;
}
inline const ::unhinged::persistence::ExecutionContext& GraphTraverseRequest::_internal_context() const {
  const ::unhinged::persistence::ExecutionContext* p = _impl_.context_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::persistence::ExecutionContext&>(
      ::unhinged::persistence::_ExecutionContext_default_instance_);
}
inline const ::unhinged::persistence::ExecutionContext& GraphTraverseRequest::context() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.GraphTraverseRequest.context)
  return _internal_context();
}
inline void GraphTraverseRequest::unsafe_arena_set_allocated_context(
    ::unhinged::persistence::ExecutionContext* context) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.context_);
  }
  _impl_.context_ = context;
  if (context) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.persistence.GraphTraverseRequest.context)
}
inline ::unhinged::persistence::ExecutionContext* GraphTraverseRequest::release_context() {
  
  ::unhinged::persistence::ExecutionContext* temp = _impl_.context_;
  _impl_.context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::persistence::ExecutionContext* GraphTraverseRequest::unsafe_arena_release_context() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.GraphTraverseRequest.context)
  
  ::unhinged::persistence::ExecutionContext* temp = _impl_.context_;
  _impl_.context_ = nullptr;
  return temp;
}
inline ::unhinged::persistence::ExecutionContext* GraphTraverseRequest::_internal_mutable_context() {
  
  if (_impl_.context_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::persistence::ExecutionContext>(GetArenaForAllocation());
    _impl_.context_ = p;
  }
  return _impl_.context_;
}
inline ::unhinged::persistence::ExecutionContext* GraphTraverseRequest::mutable_context() {
  ::unhinged::persistence::ExecutionContext* _msg = _internal_mutable_context();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.GraphTraverseRequest.context)
  return _msg;
}
inline void GraphTraverseRequest::set_allocated_context(::unhinged::persistence::ExecutionContext* context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.context_;
  }
  if (context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(context);
    if (message_arena != submessage_arena) {
      context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, context, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.context_ = context;
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.GraphTraverseRequest.context)
}

// -------------------------------------------------------------------

// GraphTraverseResponse

// bool success = 1;
inline void GraphTraverseResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool GraphTraverseResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool GraphTraverseResponse::success() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.GraphTraverseResponse.success)
  return _internal_success();
}
inline void GraphTraverseResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void GraphTraverseResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:unhinged.persistence.GraphTraverseResponse.success)
}

// repeated .unhinged.persistence.GraphNode nodes = 2;
inline int GraphTraverseResponse::_internal_nodes_size() const {
  return _impl_.nodes_.size();
}
inline int GraphTraverseResponse::nodes_size() const {
  return _internal_nodes_size();
}
inline void GraphTraverseResponse::clear_nodes() {
  _impl_.nodes_.Clear();
}
inline ::unhinged::persistence::GraphNode* GraphTraverseResponse::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.GraphTraverseResponse.nodes)
  return _impl_.nodes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::persistence::GraphNode >*
GraphTraverseResponse::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.persistence.GraphTraverseResponse.nodes)
  return &_impl_.nodes_;
}
inline const ::unhinged::persistence::GraphNode& GraphTraverseResponse::_internal_nodes(int index) const {
  return _impl_.nodes_.Get(index);
}
inline const ::unhinged::persistence::GraphNode& GraphTraverseResponse::nodes(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.GraphTraverseResponse.nodes)
  return _internal_nodes(index);
}
inline ::unhinged::persistence::GraphNode* GraphTraverseResponse::_internal_add_nodes() {
  return _impl_.nodes_.Add();
}
inline ::unhinged::persistence::GraphNode* GraphTraverseResponse::add_nodes() {
  ::unhinged::persistence::GraphNode* _add = _internal_add_nodes();
  // @@protoc_insertion_point(field_add:unhinged.persistence.GraphTraverseResponse.nodes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::persistence::GraphNode >&
GraphTraverseResponse::nodes() const {
  // @@protoc_insertion_point(field_list:unhinged.persistence.GraphTraverseResponse.nodes)
  return _impl_.nodes_;
}

// repeated .unhinged.persistence.GraphEdge edges = 3;
inline int GraphTraverseResponse::_internal_edges_size() const {
  return _impl_.edges_.size();
}
inline int GraphTraverseResponse::edges_size() const {
  return _internal_edges_size();
}
inline void GraphTraverseResponse::clear_edges() {
  _impl_.edges_.Clear();
}
inline ::unhinged::persistence::GraphEdge* GraphTraverseResponse::mutable_edges(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.GraphTraverseResponse.edges)
  return _impl_.edges_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::persistence::GraphEdge >*
GraphTraverseResponse::mutable_edges() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.persistence.GraphTraverseResponse.edges)
  return &_impl_.edges_;
}
inline const ::unhinged::persistence::GraphEdge& GraphTraverseResponse::_internal_edges(int index) const {
  return _impl_.edges_.Get(index);
}
inline const ::unhinged::persistence::GraphEdge& GraphTraverseResponse::edges(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.GraphTraverseResponse.edges)
  return _internal_edges(index);
}
inline ::unhinged::persistence::GraphEdge* GraphTraverseResponse::_internal_add_edges() {
  return _impl_.edges_.Add();
}
inline ::unhinged::persistence::GraphEdge* GraphTraverseResponse::add_edges() {
  ::unhinged::persistence::GraphEdge* _add = _internal_add_edges();
  // @@protoc_insertion_point(field_add:unhinged.persistence.GraphTraverseResponse.edges)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::persistence::GraphEdge >&
GraphTraverseResponse::edges() const {
  // @@protoc_insertion_point(field_list:unhinged.persistence.GraphTraverseResponse.edges)
  return _impl_.edges_;
}

// string error_message = 4;
inline void GraphTraverseResponse::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& GraphTraverseResponse::error_message() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.GraphTraverseResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GraphTraverseResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.persistence.GraphTraverseResponse.error_message)
}
inline std::string* GraphTraverseResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.GraphTraverseResponse.error_message)
  return _s;
}
inline const std::string& GraphTraverseResponse::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void GraphTraverseResponse::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* GraphTraverseResponse::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* GraphTraverseResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.GraphTraverseResponse.error_message)
  return _impl_.error_message_.Release();
}
inline void GraphTraverseResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.GraphTraverseResponse.error_message)
}

// int64 execution_time_ms = 5;
inline void GraphTraverseResponse::clear_execution_time_ms() {
  _impl_.execution_time_ms_ = int64_t{0};
}
inline int64_t GraphTraverseResponse::_internal_execution_time_ms() const {
  return _impl_.execution_time_ms_;
}
inline int64_t GraphTraverseResponse::execution_time_ms() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.GraphTraverseResponse.execution_time_ms)
  return _internal_execution_time_ms();
}
inline void GraphTraverseResponse::_internal_set_execution_time_ms(int64_t value) {
  
  _impl_.execution_time_ms_ = value;
}
inline void GraphTraverseResponse::set_execution_time_ms(int64_t value) {
  _internal_set_execution_time_ms(value);
  // @@protoc_insertion_point(field_set:unhinged.persistence.GraphTraverseResponse.execution_time_ms)
}

// -------------------------------------------------------------------

// GraphTraversalSpec

// .unhinged.persistence.GraphTraversalType traversal_type = 1;
inline void GraphTraversalSpec::clear_traversal_type() {
  _impl_.traversal_type_ = 0;
}
inline ::unhinged::persistence::GraphTraversalType GraphTraversalSpec::_internal_traversal_type() const {
  return static_cast< ::unhinged::persistence::GraphTraversalType >(_impl_.traversal_type_);
}
inline ::unhinged::persistence::GraphTraversalType GraphTraversalSpec::traversal_type() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.GraphTraversalSpec.traversal_type)
  return _internal_traversal_type();
}
inline void GraphTraversalSpec::_internal_set_traversal_type(::unhinged::persistence::GraphTraversalType value) {
  
  _impl_.traversal_type_ = value;
}
inline void GraphTraversalSpec::set_traversal_type(::unhinged::persistence::GraphTraversalType value) {
  _internal_set_traversal_type(value);
  // @@protoc_insertion_point(field_set:unhinged.persistence.GraphTraversalSpec.traversal_type)
}

// int32 max_depth = 2;
inline void GraphTraversalSpec::clear_max_depth() {
  _impl_.max_depth_ = 0;
}
inline int32_t GraphTraversalSpec::_internal_max_depth() const {
  return _impl_.max_depth_;
}
inline int32_t GraphTraversalSpec::max_depth() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.GraphTraversalSpec.max_depth)
  return _internal_max_depth();
}
inline void GraphTraversalSpec::_internal_set_max_depth(int32_t value) {
  
  _impl_.max_depth_ = value;
}
inline void GraphTraversalSpec::set_max_depth(int32_t value) {
  _internal_set_max_depth(value);
  // @@protoc_insertion_point(field_set:unhinged.persistence.GraphTraversalSpec.max_depth)
}

// repeated string relationship_types = 3;
inline int GraphTraversalSpec::_internal_relationship_types_size() const {
  return _impl_.relationship_types_.size();
}
inline int GraphTraversalSpec::relationship_types_size() const {
  return _internal_relationship_types_size();
}
inline void GraphTraversalSpec::clear_relationship_types() {
  _impl_.relationship_types_.Clear();
}
inline std::string* GraphTraversalSpec::add_relationship_types() {
  std::string* _s = _internal_add_relationship_types();
  // @@protoc_insertion_point(field_add_mutable:unhinged.persistence.GraphTraversalSpec.relationship_types)
  return _s;
}
inline const std::string& GraphTraversalSpec::_internal_relationship_types(int index) const {
  return _impl_.relationship_types_.Get(index);
}
inline const std::string& GraphTraversalSpec::relationship_types(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.GraphTraversalSpec.relationship_types)
  return _internal_relationship_types(index);
}
inline std::string* GraphTraversalSpec::mutable_relationship_types(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.GraphTraversalSpec.relationship_types)
  return _impl_.relationship_types_.Mutable(index);
}
inline void GraphTraversalSpec::set_relationship_types(int index, const std::string& value) {
  _impl_.relationship_types_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.persistence.GraphTraversalSpec.relationship_types)
}
inline void GraphTraversalSpec::set_relationship_types(int index, std::string&& value) {
  _impl_.relationship_types_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.persistence.GraphTraversalSpec.relationship_types)
}
inline void GraphTraversalSpec::set_relationship_types(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.relationship_types_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.persistence.GraphTraversalSpec.relationship_types)
}
inline void GraphTraversalSpec::set_relationship_types(int index, const char* value, size_t size) {
  _impl_.relationship_types_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.persistence.GraphTraversalSpec.relationship_types)
}
inline std::string* GraphTraversalSpec::_internal_add_relationship_types() {
  return _impl_.relationship_types_.Add();
}
inline void GraphTraversalSpec::add_relationship_types(const std::string& value) {
  _impl_.relationship_types_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.persistence.GraphTraversalSpec.relationship_types)
}
inline void GraphTraversalSpec::add_relationship_types(std::string&& value) {
  _impl_.relationship_types_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.persistence.GraphTraversalSpec.relationship_types)
}
inline void GraphTraversalSpec::add_relationship_types(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.relationship_types_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.persistence.GraphTraversalSpec.relationship_types)
}
inline void GraphTraversalSpec::add_relationship_types(const char* value, size_t size) {
  _impl_.relationship_types_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.persistence.GraphTraversalSpec.relationship_types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GraphTraversalSpec::relationship_types() const {
  // @@protoc_insertion_point(field_list:unhinged.persistence.GraphTraversalSpec.relationship_types)
  return _impl_.relationship_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GraphTraversalSpec::mutable_relationship_types() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.persistence.GraphTraversalSpec.relationship_types)
  return &_impl_.relationship_types_;
}

// .unhinged.persistence.QueryCriteria node_filter = 4;
inline bool GraphTraversalSpec::_internal_has_node_filter() const {
  return this != internal_default_instance() && _impl_.node_filter_ != nullptr;
}
inline bool GraphTraversalSpec::has_node_filter() const {
  return _internal_has_node_filter();
}
inline void GraphTraversalSpec::clear_node_filter() {
  if (GetArenaForAllocation() == nullptr && _impl_.node_filter_ != nullptr) {
    delete _impl_.node_filter_;
  }
  _impl_.node_filter_ = nullptr;
}
inline const ::unhinged::persistence::QueryCriteria& GraphTraversalSpec::_internal_node_filter() const {
  const ::unhinged::persistence::QueryCriteria* p = _impl_.node_filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::persistence::QueryCriteria&>(
      ::unhinged::persistence::_QueryCriteria_default_instance_);
}
inline const ::unhinged::persistence::QueryCriteria& GraphTraversalSpec::node_filter() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.GraphTraversalSpec.node_filter)
  return _internal_node_filter();
}
inline void GraphTraversalSpec::unsafe_arena_set_allocated_node_filter(
    ::unhinged::persistence::QueryCriteria* node_filter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.node_filter_);
  }
  _impl_.node_filter_ = node_filter;
  if (node_filter) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.persistence.GraphTraversalSpec.node_filter)
}
inline ::unhinged::persistence::QueryCriteria* GraphTraversalSpec::release_node_filter() {
  
  ::unhinged::persistence::QueryCriteria* temp = _impl_.node_filter_;
  _impl_.node_filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::persistence::QueryCriteria* GraphTraversalSpec::unsafe_arena_release_node_filter() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.GraphTraversalSpec.node_filter)
  
  ::unhinged::persistence::QueryCriteria* temp = _impl_.node_filter_;
  _impl_.node_filter_ = nullptr;
  return temp;
}
inline ::unhinged::persistence::QueryCriteria* GraphTraversalSpec::_internal_mutable_node_filter() {
  
  if (_impl_.node_filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::persistence::QueryCriteria>(GetArenaForAllocation());
    _impl_.node_filter_ = p;
  }
  return _impl_.node_filter_;
}
inline ::unhinged::persistence::QueryCriteria* GraphTraversalSpec::mutable_node_filter() {
  ::unhinged::persistence::QueryCriteria* _msg = _internal_mutable_node_filter();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.GraphTraversalSpec.node_filter)
  return _msg;
}
inline void GraphTraversalSpec::set_allocated_node_filter(::unhinged::persistence::QueryCriteria* node_filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.node_filter_;
  }
  if (node_filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(node_filter);
    if (message_arena != submessage_arena) {
      node_filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, node_filter, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.node_filter_ = node_filter;
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.GraphTraversalSpec.node_filter)
}

// .unhinged.persistence.QueryCriteria edge_filter = 5;
inline bool GraphTraversalSpec::_internal_has_edge_filter() const {
  return this != internal_default_instance() && _impl_.edge_filter_ != nullptr;
}
inline bool GraphTraversalSpec::has_edge_filter() const {
  return _internal_has_edge_filter();
}
inline void GraphTraversalSpec::clear_edge_filter() {
  if (GetArenaForAllocation() == nullptr && _impl_.edge_filter_ != nullptr) {
    delete _impl_.edge_filter_;
  }
  _impl_.edge_filter_ = nullptr;
}
inline const ::unhinged::persistence::QueryCriteria& GraphTraversalSpec::_internal_edge_filter() const {
  const ::unhinged::persistence::QueryCriteria* p = _impl_.edge_filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::persistence::QueryCriteria&>(
      ::unhinged::persistence::_QueryCriteria_default_instance_);
}
inline const ::unhinged::persistence::QueryCriteria& GraphTraversalSpec::edge_filter() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.GraphTraversalSpec.edge_filter)
  return _internal_edge_filter();
}
inline void GraphTraversalSpec::unsafe_arena_set_allocated_edge_filter(
    ::unhinged::persistence::QueryCriteria* edge_filter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.edge_filter_);
  }
  _impl_.edge_filter_ = edge_filter;
  if (edge_filter) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.persistence.GraphTraversalSpec.edge_filter)
}
inline ::unhinged::persistence::QueryCriteria* GraphTraversalSpec::release_edge_filter() {
  
  ::unhinged::persistence::QueryCriteria* temp = _impl_.edge_filter_;
  _impl_.edge_filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::persistence::QueryCriteria* GraphTraversalSpec::unsafe_arena_release_edge_filter() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.GraphTraversalSpec.edge_filter)
  
  ::unhinged::persistence::QueryCriteria* temp = _impl_.edge_filter_;
  _impl_.edge_filter_ = nullptr;
  return temp;
}
inline ::unhinged::persistence::QueryCriteria* GraphTraversalSpec::_internal_mutable_edge_filter() {
  
  if (_impl_.edge_filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::persistence::QueryCriteria>(GetArenaForAllocation());
    _impl_.edge_filter_ = p;
  }
  return _impl_.edge_filter_;
}
inline ::unhinged::persistence::QueryCriteria* GraphTraversalSpec::mutable_edge_filter() {
  ::unhinged::persistence::QueryCriteria* _msg = _internal_mutable_edge_filter();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.GraphTraversalSpec.edge_filter)
  return _msg;
}
inline void GraphTraversalSpec::set_allocated_edge_filter(::unhinged::persistence::QueryCriteria* edge_filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.edge_filter_;
  }
  if (edge_filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(edge_filter);
    if (message_arena != submessage_arena) {
      edge_filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, edge_filter, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.edge_filter_ = edge_filter;
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.GraphTraversalSpec.edge_filter)
}

// -------------------------------------------------------------------

// GraphNode

// string id = 1;
inline void GraphNode::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& GraphNode::id() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.GraphNode.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GraphNode::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.persistence.GraphNode.id)
}
inline std::string* GraphNode::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.GraphNode.id)
  return _s;
}
inline const std::string& GraphNode::_internal_id() const {
  return _impl_.id_.Get();
}
inline void GraphNode::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* GraphNode::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* GraphNode::release_id() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.GraphNode.id)
  return _impl_.id_.Release();
}
inline void GraphNode::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.GraphNode.id)
}

// string label = 2;
inline void GraphNode::clear_label() {
  _impl_.label_.ClearToEmpty();
}
inline const std::string& GraphNode::label() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.GraphNode.label)
  return _internal_label();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GraphNode::set_label(ArgT0&& arg0, ArgT... args) {
 
 _impl_.label_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.persistence.GraphNode.label)
}
inline std::string* GraphNode::mutable_label() {
  std::string* _s = _internal_mutable_label();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.GraphNode.label)
  return _s;
}
inline const std::string& GraphNode::_internal_label() const {
  return _impl_.label_.Get();
}
inline void GraphNode::_internal_set_label(const std::string& value) {
  
  _impl_.label_.Set(value, GetArenaForAllocation());
}
inline std::string* GraphNode::_internal_mutable_label() {
  
  return _impl_.label_.Mutable(GetArenaForAllocation());
}
inline std::string* GraphNode::release_label() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.GraphNode.label)
  return _impl_.label_.Release();
}
inline void GraphNode::set_allocated_label(std::string* label) {
  if (label != nullptr) {
    
  } else {
    
  }
  _impl_.label_.SetAllocated(label, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.label_.IsDefault()) {
    _impl_.label_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.GraphNode.label)
}

// .google.protobuf.Struct properties = 3;
inline bool GraphNode::_internal_has_properties() const {
  return this != internal_default_instance() && _impl_.properties_ != nullptr;
}
inline bool GraphNode::has_properties() const {
  return _internal_has_properties();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& GraphNode::_internal_properties() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.properties_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& GraphNode::properties() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.GraphNode.properties)
  return _internal_properties();
}
inline void GraphNode::unsafe_arena_set_allocated_properties(
    ::PROTOBUF_NAMESPACE_ID::Struct* properties) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.properties_);
  }
  _impl_.properties_ = properties;
  if (properties) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.persistence.GraphNode.properties)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GraphNode::release_properties() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.properties_;
  _impl_.properties_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GraphNode::unsafe_arena_release_properties() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.GraphNode.properties)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.properties_;
  _impl_.properties_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GraphNode::_internal_mutable_properties() {
  
  if (_impl_.properties_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.properties_ = p;
  }
  return _impl_.properties_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GraphNode::mutable_properties() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_properties();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.GraphNode.properties)
  return _msg;
}
inline void GraphNode::set_allocated_properties(::PROTOBUF_NAMESPACE_ID::Struct* properties) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.properties_);
  }
  if (properties) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(properties));
    if (message_arena != submessage_arena) {
      properties = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, properties, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.properties_ = properties;
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.GraphNode.properties)
}

// -------------------------------------------------------------------

// GraphEdge

// string id = 1;
inline void GraphEdge::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& GraphEdge::id() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.GraphEdge.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GraphEdge::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.persistence.GraphEdge.id)
}
inline std::string* GraphEdge::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.GraphEdge.id)
  return _s;
}
inline const std::string& GraphEdge::_internal_id() const {
  return _impl_.id_.Get();
}
inline void GraphEdge::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* GraphEdge::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* GraphEdge::release_id() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.GraphEdge.id)
  return _impl_.id_.Release();
}
inline void GraphEdge::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.GraphEdge.id)
}

// string source_id = 2;
inline void GraphEdge::clear_source_id() {
  _impl_.source_id_.ClearToEmpty();
}
inline const std::string& GraphEdge::source_id() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.GraphEdge.source_id)
  return _internal_source_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GraphEdge::set_source_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.source_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.persistence.GraphEdge.source_id)
}
inline std::string* GraphEdge::mutable_source_id() {
  std::string* _s = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.GraphEdge.source_id)
  return _s;
}
inline const std::string& GraphEdge::_internal_source_id() const {
  return _impl_.source_id_.Get();
}
inline void GraphEdge::_internal_set_source_id(const std::string& value) {
  
  _impl_.source_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GraphEdge::_internal_mutable_source_id() {
  
  return _impl_.source_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GraphEdge::release_source_id() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.GraphEdge.source_id)
  return _impl_.source_id_.Release();
}
inline void GraphEdge::set_allocated_source_id(std::string* source_id) {
  if (source_id != nullptr) {
    
  } else {
    
  }
  _impl_.source_id_.SetAllocated(source_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.source_id_.IsDefault()) {
    _impl_.source_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.GraphEdge.source_id)
}

// string target_id = 3;
inline void GraphEdge::clear_target_id() {
  _impl_.target_id_.ClearToEmpty();
}
inline const std::string& GraphEdge::target_id() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.GraphEdge.target_id)
  return _internal_target_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GraphEdge::set_target_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.target_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.persistence.GraphEdge.target_id)
}
inline std::string* GraphEdge::mutable_target_id() {
  std::string* _s = _internal_mutable_target_id();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.GraphEdge.target_id)
  return _s;
}
inline const std::string& GraphEdge::_internal_target_id() const {
  return _impl_.target_id_.Get();
}
inline void GraphEdge::_internal_set_target_id(const std::string& value) {
  
  _impl_.target_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GraphEdge::_internal_mutable_target_id() {
  
  return _impl_.target_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GraphEdge::release_target_id() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.GraphEdge.target_id)
  return _impl_.target_id_.Release();
}
inline void GraphEdge::set_allocated_target_id(std::string* target_id) {
  if (target_id != nullptr) {
    
  } else {
    
  }
  _impl_.target_id_.SetAllocated(target_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.target_id_.IsDefault()) {
    _impl_.target_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.GraphEdge.target_id)
}

// string relationship_type = 4;
inline void GraphEdge::clear_relationship_type() {
  _impl_.relationship_type_.ClearToEmpty();
}
inline const std::string& GraphEdge::relationship_type() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.GraphEdge.relationship_type)
  return _internal_relationship_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GraphEdge::set_relationship_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.relationship_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.persistence.GraphEdge.relationship_type)
}
inline std::string* GraphEdge::mutable_relationship_type() {
  std::string* _s = _internal_mutable_relationship_type();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.GraphEdge.relationship_type)
  return _s;
}
inline const std::string& GraphEdge::_internal_relationship_type() const {
  return _impl_.relationship_type_.Get();
}
inline void GraphEdge::_internal_set_relationship_type(const std::string& value) {
  
  _impl_.relationship_type_.Set(value, GetArenaForAllocation());
}
inline std::string* GraphEdge::_internal_mutable_relationship_type() {
  
  return _impl_.relationship_type_.Mutable(GetArenaForAllocation());
}
inline std::string* GraphEdge::release_relationship_type() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.GraphEdge.relationship_type)
  return _impl_.relationship_type_.Release();
}
inline void GraphEdge::set_allocated_relationship_type(std::string* relationship_type) {
  if (relationship_type != nullptr) {
    
  } else {
    
  }
  _impl_.relationship_type_.SetAllocated(relationship_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.relationship_type_.IsDefault()) {
    _impl_.relationship_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.GraphEdge.relationship_type)
}

// .google.protobuf.Struct properties = 5;
inline bool GraphEdge::_internal_has_properties() const {
  return this != internal_default_instance() && _impl_.properties_ != nullptr;
}
inline bool GraphEdge::has_properties() const {
  return _internal_has_properties();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& GraphEdge::_internal_properties() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.properties_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& GraphEdge::properties() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.GraphEdge.properties)
  return _internal_properties();
}
inline void GraphEdge::unsafe_arena_set_allocated_properties(
    ::PROTOBUF_NAMESPACE_ID::Struct* properties) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.properties_);
  }
  _impl_.properties_ = properties;
  if (properties) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.persistence.GraphEdge.properties)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GraphEdge::release_properties() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.properties_;
  _impl_.properties_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GraphEdge::unsafe_arena_release_properties() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.GraphEdge.properties)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.properties_;
  _impl_.properties_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GraphEdge::_internal_mutable_properties() {
  
  if (_impl_.properties_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.properties_ = p;
  }
  return _impl_.properties_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GraphEdge::mutable_properties() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_properties();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.GraphEdge.properties)
  return _msg;
}
inline void GraphEdge::set_allocated_properties(::PROTOBUF_NAMESPACE_ID::Struct* properties) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.properties_);
  }
  if (properties) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(properties));
    if (message_arena != submessage_arena) {
      properties = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, properties, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.properties_ = properties;
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.GraphEdge.properties)
}

// -------------------------------------------------------------------

// ExecuteOperationRequest

// string operation_name = 1;
inline void ExecuteOperationRequest::clear_operation_name() {
  _impl_.operation_name_.ClearToEmpty();
}
inline const std::string& ExecuteOperationRequest::operation_name() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.ExecuteOperationRequest.operation_name)
  return _internal_operation_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecuteOperationRequest::set_operation_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.operation_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.persistence.ExecuteOperationRequest.operation_name)
}
inline std::string* ExecuteOperationRequest::mutable_operation_name() {
  std::string* _s = _internal_mutable_operation_name();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.ExecuteOperationRequest.operation_name)
  return _s;
}
inline const std::string& ExecuteOperationRequest::_internal_operation_name() const {
  return _impl_.operation_name_.Get();
}
inline void ExecuteOperationRequest::_internal_set_operation_name(const std::string& value) {
  
  _impl_.operation_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ExecuteOperationRequest::_internal_mutable_operation_name() {
  
  return _impl_.operation_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ExecuteOperationRequest::release_operation_name() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.ExecuteOperationRequest.operation_name)
  return _impl_.operation_name_.Release();
}
inline void ExecuteOperationRequest::set_allocated_operation_name(std::string* operation_name) {
  if (operation_name != nullptr) {
    
  } else {
    
  }
  _impl_.operation_name_.SetAllocated(operation_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.operation_name_.IsDefault()) {
    _impl_.operation_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.ExecuteOperationRequest.operation_name)
}

// .google.protobuf.Struct parameters = 2;
inline bool ExecuteOperationRequest::_internal_has_parameters() const {
  return this != internal_default_instance() && _impl_.parameters_ != nullptr;
}
inline bool ExecuteOperationRequest::has_parameters() const {
  return _internal_has_parameters();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& ExecuteOperationRequest::_internal_parameters() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.parameters_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& ExecuteOperationRequest::parameters() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.ExecuteOperationRequest.parameters)
  return _internal_parameters();
}
inline void ExecuteOperationRequest::unsafe_arena_set_allocated_parameters(
    ::PROTOBUF_NAMESPACE_ID::Struct* parameters) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.parameters_);
  }
  _impl_.parameters_ = parameters;
  if (parameters) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.persistence.ExecuteOperationRequest.parameters)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ExecuteOperationRequest::release_parameters() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.parameters_;
  _impl_.parameters_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ExecuteOperationRequest::unsafe_arena_release_parameters() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.ExecuteOperationRequest.parameters)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.parameters_;
  _impl_.parameters_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ExecuteOperationRequest::_internal_mutable_parameters() {
  
  if (_impl_.parameters_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.parameters_ = p;
  }
  return _impl_.parameters_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ExecuteOperationRequest::mutable_parameters() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_parameters();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.ExecuteOperationRequest.parameters)
  return _msg;
}
inline void ExecuteOperationRequest::set_allocated_parameters(::PROTOBUF_NAMESPACE_ID::Struct* parameters) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.parameters_);
  }
  if (parameters) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(parameters));
    if (message_arena != submessage_arena) {
      parameters = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parameters, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.parameters_ = parameters;
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.ExecuteOperationRequest.parameters)
}

// .unhinged.persistence.ExecutionContext context = 3;
inline bool ExecuteOperationRequest::_internal_has_context() const {
  return this != internal_default_instance() && _impl_.context_ != nullptr;
}
inline bool ExecuteOperationRequest::has_context() const {
  return _internal_has_context();
}
inline void ExecuteOperationRequest::clear_context() {
  if (GetArenaForAllocation() == nullptr && _impl_.context_ != nullptr) {
    delete _impl_.context_;
  }
  _impl_.context_ = nullptr;
}
inline const ::unhinged::persistence::ExecutionContext& ExecuteOperationRequest::_internal_context() const {
  const ::unhinged::persistence::ExecutionContext* p = _impl_.context_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::persistence::ExecutionContext&>(
      ::unhinged::persistence::_ExecutionContext_default_instance_);
}
inline const ::unhinged::persistence::ExecutionContext& ExecuteOperationRequest::context() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.ExecuteOperationRequest.context)
  return _internal_context();
}
inline void ExecuteOperationRequest::unsafe_arena_set_allocated_context(
    ::unhinged::persistence::ExecutionContext* context) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.context_);
  }
  _impl_.context_ = context;
  if (context) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.persistence.ExecuteOperationRequest.context)
}
inline ::unhinged::persistence::ExecutionContext* ExecuteOperationRequest::release_context() {
  
  ::unhinged::persistence::ExecutionContext* temp = _impl_.context_;
  _impl_.context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::persistence::ExecutionContext* ExecuteOperationRequest::unsafe_arena_release_context() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.ExecuteOperationRequest.context)
  
  ::unhinged::persistence::ExecutionContext* temp = _impl_.context_;
  _impl_.context_ = nullptr;
  return temp;
}
inline ::unhinged::persistence::ExecutionContext* ExecuteOperationRequest::_internal_mutable_context() {
  
  if (_impl_.context_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::persistence::ExecutionContext>(GetArenaForAllocation());
    _impl_.context_ = p;
  }
  return _impl_.context_;
}
inline ::unhinged::persistence::ExecutionContext* ExecuteOperationRequest::mutable_context() {
  ::unhinged::persistence::ExecutionContext* _msg = _internal_mutable_context();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.ExecuteOperationRequest.context)
  return _msg;
}
inline void ExecuteOperationRequest::set_allocated_context(::unhinged::persistence::ExecutionContext* context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.context_;
  }
  if (context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(context);
    if (message_arena != submessage_arena) {
      context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, context, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.context_ = context;
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.ExecuteOperationRequest.context)
}

// -------------------------------------------------------------------

// ExecuteOperationResponse

// bool success = 1;
inline void ExecuteOperationResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool ExecuteOperationResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool ExecuteOperationResponse::success() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.ExecuteOperationResponse.success)
  return _internal_success();
}
inline void ExecuteOperationResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void ExecuteOperationResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:unhinged.persistence.ExecuteOperationResponse.success)
}

// .google.protobuf.Any result = 2;
inline bool ExecuteOperationResponse::_internal_has_result() const {
  return this != internal_default_instance() && _impl_.result_ != nullptr;
}
inline bool ExecuteOperationResponse::has_result() const {
  return _internal_has_result();
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& ExecuteOperationResponse::_internal_result() const {
  const ::PROTOBUF_NAMESPACE_ID::Any* p = _impl_.result_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Any&>(
      ::PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& ExecuteOperationResponse::result() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.ExecuteOperationResponse.result)
  return _internal_result();
}
inline void ExecuteOperationResponse::unsafe_arena_set_allocated_result(
    ::PROTOBUF_NAMESPACE_ID::Any* result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.result_);
  }
  _impl_.result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.persistence.ExecuteOperationResponse.result)
}
inline ::PROTOBUF_NAMESPACE_ID::Any* ExecuteOperationResponse::release_result() {
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.result_;
  _impl_.result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* ExecuteOperationResponse::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.ExecuteOperationResponse.result)
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = _impl_.result_;
  _impl_.result_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* ExecuteOperationResponse::_internal_mutable_result() {
  
  if (_impl_.result_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Any>(GetArenaForAllocation());
    _impl_.result_ = p;
  }
  return _impl_.result_;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* ExecuteOperationResponse::mutable_result() {
  ::PROTOBUF_NAMESPACE_ID::Any* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.ExecuteOperationResponse.result)
  return _msg;
}
inline void ExecuteOperationResponse::set_allocated_result(::PROTOBUF_NAMESPACE_ID::Any* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.result_);
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result));
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.result_ = result;
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.ExecuteOperationResponse.result)
}

// string error_message = 3;
inline void ExecuteOperationResponse::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& ExecuteOperationResponse::error_message() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.ExecuteOperationResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecuteOperationResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.persistence.ExecuteOperationResponse.error_message)
}
inline std::string* ExecuteOperationResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.ExecuteOperationResponse.error_message)
  return _s;
}
inline const std::string& ExecuteOperationResponse::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void ExecuteOperationResponse::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* ExecuteOperationResponse::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* ExecuteOperationResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.ExecuteOperationResponse.error_message)
  return _impl_.error_message_.Release();
}
inline void ExecuteOperationResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.ExecuteOperationResponse.error_message)
}

// int64 execution_time_ms = 4;
inline void ExecuteOperationResponse::clear_execution_time_ms() {
  _impl_.execution_time_ms_ = int64_t{0};
}
inline int64_t ExecuteOperationResponse::_internal_execution_time_ms() const {
  return _impl_.execution_time_ms_;
}
inline int64_t ExecuteOperationResponse::execution_time_ms() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.ExecuteOperationResponse.execution_time_ms)
  return _internal_execution_time_ms();
}
inline void ExecuteOperationResponse::_internal_set_execution_time_ms(int64_t value) {
  
  _impl_.execution_time_ms_ = value;
}
inline void ExecuteOperationResponse::set_execution_time_ms(int64_t value) {
  _internal_set_execution_time_ms(value);
  // @@protoc_insertion_point(field_set:unhinged.persistence.ExecuteOperationResponse.execution_time_ms)
}

// repeated string affected_tables = 5;
inline int ExecuteOperationResponse::_internal_affected_tables_size() const {
  return _impl_.affected_tables_.size();
}
inline int ExecuteOperationResponse::affected_tables_size() const {
  return _internal_affected_tables_size();
}
inline void ExecuteOperationResponse::clear_affected_tables() {
  _impl_.affected_tables_.Clear();
}
inline std::string* ExecuteOperationResponse::add_affected_tables() {
  std::string* _s = _internal_add_affected_tables();
  // @@protoc_insertion_point(field_add_mutable:unhinged.persistence.ExecuteOperationResponse.affected_tables)
  return _s;
}
inline const std::string& ExecuteOperationResponse::_internal_affected_tables(int index) const {
  return _impl_.affected_tables_.Get(index);
}
inline const std::string& ExecuteOperationResponse::affected_tables(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.ExecuteOperationResponse.affected_tables)
  return _internal_affected_tables(index);
}
inline std::string* ExecuteOperationResponse::mutable_affected_tables(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.ExecuteOperationResponse.affected_tables)
  return _impl_.affected_tables_.Mutable(index);
}
inline void ExecuteOperationResponse::set_affected_tables(int index, const std::string& value) {
  _impl_.affected_tables_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.persistence.ExecuteOperationResponse.affected_tables)
}
inline void ExecuteOperationResponse::set_affected_tables(int index, std::string&& value) {
  _impl_.affected_tables_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.persistence.ExecuteOperationResponse.affected_tables)
}
inline void ExecuteOperationResponse::set_affected_tables(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.affected_tables_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.persistence.ExecuteOperationResponse.affected_tables)
}
inline void ExecuteOperationResponse::set_affected_tables(int index, const char* value, size_t size) {
  _impl_.affected_tables_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.persistence.ExecuteOperationResponse.affected_tables)
}
inline std::string* ExecuteOperationResponse::_internal_add_affected_tables() {
  return _impl_.affected_tables_.Add();
}
inline void ExecuteOperationResponse::add_affected_tables(const std::string& value) {
  _impl_.affected_tables_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.persistence.ExecuteOperationResponse.affected_tables)
}
inline void ExecuteOperationResponse::add_affected_tables(std::string&& value) {
  _impl_.affected_tables_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.persistence.ExecuteOperationResponse.affected_tables)
}
inline void ExecuteOperationResponse::add_affected_tables(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.affected_tables_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.persistence.ExecuteOperationResponse.affected_tables)
}
inline void ExecuteOperationResponse::add_affected_tables(const char* value, size_t size) {
  _impl_.affected_tables_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.persistence.ExecuteOperationResponse.affected_tables)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ExecuteOperationResponse::affected_tables() const {
  // @@protoc_insertion_point(field_list:unhinged.persistence.ExecuteOperationResponse.affected_tables)
  return _impl_.affected_tables_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ExecuteOperationResponse::mutable_affected_tables() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.persistence.ExecuteOperationResponse.affected_tables)
  return &_impl_.affected_tables_;
}

// -------------------------------------------------------------------

// HealthCheckRequest

// bool include_details = 1;
inline void HealthCheckRequest::clear_include_details() {
  _impl_.include_details_ = false;
}
inline bool HealthCheckRequest::_internal_include_details() const {
  return _impl_.include_details_;
}
inline bool HealthCheckRequest::include_details() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.HealthCheckRequest.include_details)
  return _internal_include_details();
}
inline void HealthCheckRequest::_internal_set_include_details(bool value) {
  
  _impl_.include_details_ = value;
}
inline void HealthCheckRequest::set_include_details(bool value) {
  _internal_set_include_details(value);
  // @@protoc_insertion_point(field_set:unhinged.persistence.HealthCheckRequest.include_details)
}

// -------------------------------------------------------------------

// HealthCheckResponse

// bool healthy = 1;
inline void HealthCheckResponse::clear_healthy() {
  _impl_.healthy_ = false;
}
inline bool HealthCheckResponse::_internal_healthy() const {
  return _impl_.healthy_;
}
inline bool HealthCheckResponse::healthy() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.HealthCheckResponse.healthy)
  return _internal_healthy();
}
inline void HealthCheckResponse::_internal_set_healthy(bool value) {
  
  _impl_.healthy_ = value;
}
inline void HealthCheckResponse::set_healthy(bool value) {
  _internal_set_healthy(value);
  // @@protoc_insertion_point(field_set:unhinged.persistence.HealthCheckResponse.healthy)
}

// string version = 2;
inline void HealthCheckResponse::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& HealthCheckResponse::version() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.HealthCheckResponse.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HealthCheckResponse::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.persistence.HealthCheckResponse.version)
}
inline std::string* HealthCheckResponse::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.HealthCheckResponse.version)
  return _s;
}
inline const std::string& HealthCheckResponse::_internal_version() const {
  return _impl_.version_.Get();
}
inline void HealthCheckResponse::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* HealthCheckResponse::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* HealthCheckResponse::release_version() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.HealthCheckResponse.version)
  return _impl_.version_.Release();
}
inline void HealthCheckResponse::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.HealthCheckResponse.version)
}

// int64 uptime_seconds = 3;
inline void HealthCheckResponse::clear_uptime_seconds() {
  _impl_.uptime_seconds_ = int64_t{0};
}
inline int64_t HealthCheckResponse::_internal_uptime_seconds() const {
  return _impl_.uptime_seconds_;
}
inline int64_t HealthCheckResponse::uptime_seconds() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.HealthCheckResponse.uptime_seconds)
  return _internal_uptime_seconds();
}
inline void HealthCheckResponse::_internal_set_uptime_seconds(int64_t value) {
  
  _impl_.uptime_seconds_ = value;
}
inline void HealthCheckResponse::set_uptime_seconds(int64_t value) {
  _internal_set_uptime_seconds(value);
  // @@protoc_insertion_point(field_set:unhinged.persistence.HealthCheckResponse.uptime_seconds)
}

// repeated .unhinged.persistence.TechnologyHealth technology_health = 4;
inline int HealthCheckResponse::_internal_technology_health_size() const {
  return _impl_.technology_health_.size();
}
inline int HealthCheckResponse::technology_health_size() const {
  return _internal_technology_health_size();
}
inline void HealthCheckResponse::clear_technology_health() {
  _impl_.technology_health_.Clear();
}
inline ::unhinged::persistence::TechnologyHealth* HealthCheckResponse::mutable_technology_health(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.HealthCheckResponse.technology_health)
  return _impl_.technology_health_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::persistence::TechnologyHealth >*
HealthCheckResponse::mutable_technology_health() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.persistence.HealthCheckResponse.technology_health)
  return &_impl_.technology_health_;
}
inline const ::unhinged::persistence::TechnologyHealth& HealthCheckResponse::_internal_technology_health(int index) const {
  return _impl_.technology_health_.Get(index);
}
inline const ::unhinged::persistence::TechnologyHealth& HealthCheckResponse::technology_health(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.HealthCheckResponse.technology_health)
  return _internal_technology_health(index);
}
inline ::unhinged::persistence::TechnologyHealth* HealthCheckResponse::_internal_add_technology_health() {
  return _impl_.technology_health_.Add();
}
inline ::unhinged::persistence::TechnologyHealth* HealthCheckResponse::add_technology_health() {
  ::unhinged::persistence::TechnologyHealth* _add = _internal_add_technology_health();
  // @@protoc_insertion_point(field_add:unhinged.persistence.HealthCheckResponse.technology_health)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::persistence::TechnologyHealth >&
HealthCheckResponse::technology_health() const {
  // @@protoc_insertion_point(field_list:unhinged.persistence.HealthCheckResponse.technology_health)
  return _impl_.technology_health_;
}

// -------------------------------------------------------------------

// TechnologyHealth

// string technology = 1;
inline void TechnologyHealth::clear_technology() {
  _impl_.technology_.ClearToEmpty();
}
inline const std::string& TechnologyHealth::technology() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.TechnologyHealth.technology)
  return _internal_technology();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TechnologyHealth::set_technology(ArgT0&& arg0, ArgT... args) {
 
 _impl_.technology_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.persistence.TechnologyHealth.technology)
}
inline std::string* TechnologyHealth::mutable_technology() {
  std::string* _s = _internal_mutable_technology();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.TechnologyHealth.technology)
  return _s;
}
inline const std::string& TechnologyHealth::_internal_technology() const {
  return _impl_.technology_.Get();
}
inline void TechnologyHealth::_internal_set_technology(const std::string& value) {
  
  _impl_.technology_.Set(value, GetArenaForAllocation());
}
inline std::string* TechnologyHealth::_internal_mutable_technology() {
  
  return _impl_.technology_.Mutable(GetArenaForAllocation());
}
inline std::string* TechnologyHealth::release_technology() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.TechnologyHealth.technology)
  return _impl_.technology_.Release();
}
inline void TechnologyHealth::set_allocated_technology(std::string* technology) {
  if (technology != nullptr) {
    
  } else {
    
  }
  _impl_.technology_.SetAllocated(technology, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.technology_.IsDefault()) {
    _impl_.technology_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.TechnologyHealth.technology)
}

// bool healthy = 2;
inline void TechnologyHealth::clear_healthy() {
  _impl_.healthy_ = false;
}
inline bool TechnologyHealth::_internal_healthy() const {
  return _impl_.healthy_;
}
inline bool TechnologyHealth::healthy() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.TechnologyHealth.healthy)
  return _internal_healthy();
}
inline void TechnologyHealth::_internal_set_healthy(bool value) {
  
  _impl_.healthy_ = value;
}
inline void TechnologyHealth::set_healthy(bool value) {
  _internal_set_healthy(value);
  // @@protoc_insertion_point(field_set:unhinged.persistence.TechnologyHealth.healthy)
}

// string status = 3;
inline void TechnologyHealth::clear_status() {
  _impl_.status_.ClearToEmpty();
}
inline const std::string& TechnologyHealth::status() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.TechnologyHealth.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TechnologyHealth::set_status(ArgT0&& arg0, ArgT... args) {
 
 _impl_.status_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.persistence.TechnologyHealth.status)
}
inline std::string* TechnologyHealth::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.TechnologyHealth.status)
  return _s;
}
inline const std::string& TechnologyHealth::_internal_status() const {
  return _impl_.status_.Get();
}
inline void TechnologyHealth::_internal_set_status(const std::string& value) {
  
  _impl_.status_.Set(value, GetArenaForAllocation());
}
inline std::string* TechnologyHealth::_internal_mutable_status() {
  
  return _impl_.status_.Mutable(GetArenaForAllocation());
}
inline std::string* TechnologyHealth::release_status() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.TechnologyHealth.status)
  return _impl_.status_.Release();
}
inline void TechnologyHealth::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  _impl_.status_.SetAllocated(status, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.TechnologyHealth.status)
}

// int64 response_time_ms = 4;
inline void TechnologyHealth::clear_response_time_ms() {
  _impl_.response_time_ms_ = int64_t{0};
}
inline int64_t TechnologyHealth::_internal_response_time_ms() const {
  return _impl_.response_time_ms_;
}
inline int64_t TechnologyHealth::response_time_ms() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.TechnologyHealth.response_time_ms)
  return _internal_response_time_ms();
}
inline void TechnologyHealth::_internal_set_response_time_ms(int64_t value) {
  
  _impl_.response_time_ms_ = value;
}
inline void TechnologyHealth::set_response_time_ms(int64_t value) {
  _internal_set_response_time_ms(value);
  // @@protoc_insertion_point(field_set:unhinged.persistence.TechnologyHealth.response_time_ms)
}

// string error_message = 5;
inline void TechnologyHealth::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& TechnologyHealth::error_message() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.TechnologyHealth.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TechnologyHealth::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.persistence.TechnologyHealth.error_message)
}
inline std::string* TechnologyHealth::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.TechnologyHealth.error_message)
  return _s;
}
inline const std::string& TechnologyHealth::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void TechnologyHealth::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* TechnologyHealth::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* TechnologyHealth::release_error_message() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.TechnologyHealth.error_message)
  return _impl_.error_message_.Release();
}
inline void TechnologyHealth::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.TechnologyHealth.error_message)
}

// -------------------------------------------------------------------

// GetPlatformInfoRequest

// -------------------------------------------------------------------

// GetPlatformInfoResponse

// string platform_name = 1;
inline void GetPlatformInfoResponse::clear_platform_name() {
  _impl_.platform_name_.ClearToEmpty();
}
inline const std::string& GetPlatformInfoResponse::platform_name() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.GetPlatformInfoResponse.platform_name)
  return _internal_platform_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetPlatformInfoResponse::set_platform_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.platform_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.persistence.GetPlatformInfoResponse.platform_name)
}
inline std::string* GetPlatformInfoResponse::mutable_platform_name() {
  std::string* _s = _internal_mutable_platform_name();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.GetPlatformInfoResponse.platform_name)
  return _s;
}
inline const std::string& GetPlatformInfoResponse::_internal_platform_name() const {
  return _impl_.platform_name_.Get();
}
inline void GetPlatformInfoResponse::_internal_set_platform_name(const std::string& value) {
  
  _impl_.platform_name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetPlatformInfoResponse::_internal_mutable_platform_name() {
  
  return _impl_.platform_name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetPlatformInfoResponse::release_platform_name() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.GetPlatformInfoResponse.platform_name)
  return _impl_.platform_name_.Release();
}
inline void GetPlatformInfoResponse::set_allocated_platform_name(std::string* platform_name) {
  if (platform_name != nullptr) {
    
  } else {
    
  }
  _impl_.platform_name_.SetAllocated(platform_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.platform_name_.IsDefault()) {
    _impl_.platform_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.GetPlatformInfoResponse.platform_name)
}

// string version = 2;
inline void GetPlatformInfoResponse::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& GetPlatformInfoResponse::version() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.GetPlatformInfoResponse.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetPlatformInfoResponse::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.persistence.GetPlatformInfoResponse.version)
}
inline std::string* GetPlatformInfoResponse::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.GetPlatformInfoResponse.version)
  return _s;
}
inline const std::string& GetPlatformInfoResponse::_internal_version() const {
  return _impl_.version_.Get();
}
inline void GetPlatformInfoResponse::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* GetPlatformInfoResponse::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* GetPlatformInfoResponse::release_version() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.GetPlatformInfoResponse.version)
  return _impl_.version_.Release();
}
inline void GetPlatformInfoResponse::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.GetPlatformInfoResponse.version)
}

// repeated string supported_technologies = 3;
inline int GetPlatformInfoResponse::_internal_supported_technologies_size() const {
  return _impl_.supported_technologies_.size();
}
inline int GetPlatformInfoResponse::supported_technologies_size() const {
  return _internal_supported_technologies_size();
}
inline void GetPlatformInfoResponse::clear_supported_technologies() {
  _impl_.supported_technologies_.Clear();
}
inline std::string* GetPlatformInfoResponse::add_supported_technologies() {
  std::string* _s = _internal_add_supported_technologies();
  // @@protoc_insertion_point(field_add_mutable:unhinged.persistence.GetPlatformInfoResponse.supported_technologies)
  return _s;
}
inline const std::string& GetPlatformInfoResponse::_internal_supported_technologies(int index) const {
  return _impl_.supported_technologies_.Get(index);
}
inline const std::string& GetPlatformInfoResponse::supported_technologies(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.GetPlatformInfoResponse.supported_technologies)
  return _internal_supported_technologies(index);
}
inline std::string* GetPlatformInfoResponse::mutable_supported_technologies(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.GetPlatformInfoResponse.supported_technologies)
  return _impl_.supported_technologies_.Mutable(index);
}
inline void GetPlatformInfoResponse::set_supported_technologies(int index, const std::string& value) {
  _impl_.supported_technologies_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.persistence.GetPlatformInfoResponse.supported_technologies)
}
inline void GetPlatformInfoResponse::set_supported_technologies(int index, std::string&& value) {
  _impl_.supported_technologies_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.persistence.GetPlatformInfoResponse.supported_technologies)
}
inline void GetPlatformInfoResponse::set_supported_technologies(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.supported_technologies_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.persistence.GetPlatformInfoResponse.supported_technologies)
}
inline void GetPlatformInfoResponse::set_supported_technologies(int index, const char* value, size_t size) {
  _impl_.supported_technologies_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.persistence.GetPlatformInfoResponse.supported_technologies)
}
inline std::string* GetPlatformInfoResponse::_internal_add_supported_technologies() {
  return _impl_.supported_technologies_.Add();
}
inline void GetPlatformInfoResponse::add_supported_technologies(const std::string& value) {
  _impl_.supported_technologies_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.persistence.GetPlatformInfoResponse.supported_technologies)
}
inline void GetPlatformInfoResponse::add_supported_technologies(std::string&& value) {
  _impl_.supported_technologies_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.persistence.GetPlatformInfoResponse.supported_technologies)
}
inline void GetPlatformInfoResponse::add_supported_technologies(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.supported_technologies_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.persistence.GetPlatformInfoResponse.supported_technologies)
}
inline void GetPlatformInfoResponse::add_supported_technologies(const char* value, size_t size) {
  _impl_.supported_technologies_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.persistence.GetPlatformInfoResponse.supported_technologies)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetPlatformInfoResponse::supported_technologies() const {
  // @@protoc_insertion_point(field_list:unhinged.persistence.GetPlatformInfoResponse.supported_technologies)
  return _impl_.supported_technologies_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetPlatformInfoResponse::mutable_supported_technologies() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.persistence.GetPlatformInfoResponse.supported_technologies)
  return &_impl_.supported_technologies_;
}

// repeated string supported_features = 4;
inline int GetPlatformInfoResponse::_internal_supported_features_size() const {
  return _impl_.supported_features_.size();
}
inline int GetPlatformInfoResponse::supported_features_size() const {
  return _internal_supported_features_size();
}
inline void GetPlatformInfoResponse::clear_supported_features() {
  _impl_.supported_features_.Clear();
}
inline std::string* GetPlatformInfoResponse::add_supported_features() {
  std::string* _s = _internal_add_supported_features();
  // @@protoc_insertion_point(field_add_mutable:unhinged.persistence.GetPlatformInfoResponse.supported_features)
  return _s;
}
inline const std::string& GetPlatformInfoResponse::_internal_supported_features(int index) const {
  return _impl_.supported_features_.Get(index);
}
inline const std::string& GetPlatformInfoResponse::supported_features(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.GetPlatformInfoResponse.supported_features)
  return _internal_supported_features(index);
}
inline std::string* GetPlatformInfoResponse::mutable_supported_features(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.GetPlatformInfoResponse.supported_features)
  return _impl_.supported_features_.Mutable(index);
}
inline void GetPlatformInfoResponse::set_supported_features(int index, const std::string& value) {
  _impl_.supported_features_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.persistence.GetPlatformInfoResponse.supported_features)
}
inline void GetPlatformInfoResponse::set_supported_features(int index, std::string&& value) {
  _impl_.supported_features_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.persistence.GetPlatformInfoResponse.supported_features)
}
inline void GetPlatformInfoResponse::set_supported_features(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.supported_features_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.persistence.GetPlatformInfoResponse.supported_features)
}
inline void GetPlatformInfoResponse::set_supported_features(int index, const char* value, size_t size) {
  _impl_.supported_features_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.persistence.GetPlatformInfoResponse.supported_features)
}
inline std::string* GetPlatformInfoResponse::_internal_add_supported_features() {
  return _impl_.supported_features_.Add();
}
inline void GetPlatformInfoResponse::add_supported_features(const std::string& value) {
  _impl_.supported_features_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.persistence.GetPlatformInfoResponse.supported_features)
}
inline void GetPlatformInfoResponse::add_supported_features(std::string&& value) {
  _impl_.supported_features_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.persistence.GetPlatformInfoResponse.supported_features)
}
inline void GetPlatformInfoResponse::add_supported_features(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.supported_features_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.persistence.GetPlatformInfoResponse.supported_features)
}
inline void GetPlatformInfoResponse::add_supported_features(const char* value, size_t size) {
  _impl_.supported_features_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.persistence.GetPlatformInfoResponse.supported_features)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetPlatformInfoResponse::supported_features() const {
  // @@protoc_insertion_point(field_list:unhinged.persistence.GetPlatformInfoResponse.supported_features)
  return _impl_.supported_features_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetPlatformInfoResponse::mutable_supported_features() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.persistence.GetPlatformInfoResponse.supported_features)
  return &_impl_.supported_features_;
}

// .google.protobuf.Struct configuration = 5;
inline bool GetPlatformInfoResponse::_internal_has_configuration() const {
  return this != internal_default_instance() && _impl_.configuration_ != nullptr;
}
inline bool GetPlatformInfoResponse::has_configuration() const {
  return _internal_has_configuration();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& GetPlatformInfoResponse::_internal_configuration() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.configuration_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& GetPlatformInfoResponse::configuration() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.GetPlatformInfoResponse.configuration)
  return _internal_configuration();
}
inline void GetPlatformInfoResponse::unsafe_arena_set_allocated_configuration(
    ::PROTOBUF_NAMESPACE_ID::Struct* configuration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.configuration_);
  }
  _impl_.configuration_ = configuration;
  if (configuration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.persistence.GetPlatformInfoResponse.configuration)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetPlatformInfoResponse::release_configuration() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.configuration_;
  _impl_.configuration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetPlatformInfoResponse::unsafe_arena_release_configuration() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.GetPlatformInfoResponse.configuration)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.configuration_;
  _impl_.configuration_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetPlatformInfoResponse::_internal_mutable_configuration() {
  
  if (_impl_.configuration_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.configuration_ = p;
  }
  return _impl_.configuration_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* GetPlatformInfoResponse::mutable_configuration() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_configuration();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.GetPlatformInfoResponse.configuration)
  return _msg;
}
inline void GetPlatformInfoResponse::set_allocated_configuration(::PROTOBUF_NAMESPACE_ID::Struct* configuration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.configuration_);
  }
  if (configuration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(configuration));
    if (message_arena != submessage_arena) {
      configuration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, configuration, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.configuration_ = configuration;
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.GetPlatformInfoResponse.configuration)
}

// -------------------------------------------------------------------

// GetMetricsRequest

// string format = 1;
inline void GetMetricsRequest::clear_format() {
  _impl_.format_.ClearToEmpty();
}
inline const std::string& GetMetricsRequest::format() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.GetMetricsRequest.format)
  return _internal_format();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetMetricsRequest::set_format(ArgT0&& arg0, ArgT... args) {
 
 _impl_.format_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.persistence.GetMetricsRequest.format)
}
inline std::string* GetMetricsRequest::mutable_format() {
  std::string* _s = _internal_mutable_format();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.GetMetricsRequest.format)
  return _s;
}
inline const std::string& GetMetricsRequest::_internal_format() const {
  return _impl_.format_.Get();
}
inline void GetMetricsRequest::_internal_set_format(const std::string& value) {
  
  _impl_.format_.Set(value, GetArenaForAllocation());
}
inline std::string* GetMetricsRequest::_internal_mutable_format() {
  
  return _impl_.format_.Mutable(GetArenaForAllocation());
}
inline std::string* GetMetricsRequest::release_format() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.GetMetricsRequest.format)
  return _impl_.format_.Release();
}
inline void GetMetricsRequest::set_allocated_format(std::string* format) {
  if (format != nullptr) {
    
  } else {
    
  }
  _impl_.format_.SetAllocated(format, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.format_.IsDefault()) {
    _impl_.format_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.GetMetricsRequest.format)
}

// -------------------------------------------------------------------

// GetMetricsResponse

// string format = 1;
inline void GetMetricsResponse::clear_format() {
  _impl_.format_.ClearToEmpty();
}
inline const std::string& GetMetricsResponse::format() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.GetMetricsResponse.format)
  return _internal_format();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetMetricsResponse::set_format(ArgT0&& arg0, ArgT... args) {
 
 _impl_.format_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.persistence.GetMetricsResponse.format)
}
inline std::string* GetMetricsResponse::mutable_format() {
  std::string* _s = _internal_mutable_format();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.GetMetricsResponse.format)
  return _s;
}
inline const std::string& GetMetricsResponse::_internal_format() const {
  return _impl_.format_.Get();
}
inline void GetMetricsResponse::_internal_set_format(const std::string& value) {
  
  _impl_.format_.Set(value, GetArenaForAllocation());
}
inline std::string* GetMetricsResponse::_internal_mutable_format() {
  
  return _impl_.format_.Mutable(GetArenaForAllocation());
}
inline std::string* GetMetricsResponse::release_format() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.GetMetricsResponse.format)
  return _impl_.format_.Release();
}
inline void GetMetricsResponse::set_allocated_format(std::string* format) {
  if (format != nullptr) {
    
  } else {
    
  }
  _impl_.format_.SetAllocated(format, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.format_.IsDefault()) {
    _impl_.format_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.GetMetricsResponse.format)
}

// string metrics_data = 2;
inline void GetMetricsResponse::clear_metrics_data() {
  _impl_.metrics_data_.ClearToEmpty();
}
inline const std::string& GetMetricsResponse::metrics_data() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.GetMetricsResponse.metrics_data)
  return _internal_metrics_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetMetricsResponse::set_metrics_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.metrics_data_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.persistence.GetMetricsResponse.metrics_data)
}
inline std::string* GetMetricsResponse::mutable_metrics_data() {
  std::string* _s = _internal_mutable_metrics_data();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.GetMetricsResponse.metrics_data)
  return _s;
}
inline const std::string& GetMetricsResponse::_internal_metrics_data() const {
  return _impl_.metrics_data_.Get();
}
inline void GetMetricsResponse::_internal_set_metrics_data(const std::string& value) {
  
  _impl_.metrics_data_.Set(value, GetArenaForAllocation());
}
inline std::string* GetMetricsResponse::_internal_mutable_metrics_data() {
  
  return _impl_.metrics_data_.Mutable(GetArenaForAllocation());
}
inline std::string* GetMetricsResponse::release_metrics_data() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.GetMetricsResponse.metrics_data)
  return _impl_.metrics_data_.Release();
}
inline void GetMetricsResponse::set_allocated_metrics_data(std::string* metrics_data) {
  if (metrics_data != nullptr) {
    
  } else {
    
  }
  _impl_.metrics_data_.SetAllocated(metrics_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.metrics_data_.IsDefault()) {
    _impl_.metrics_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.GetMetricsResponse.metrics_data)
}

// .google.protobuf.Timestamp collected_at = 3;
inline bool GetMetricsResponse::_internal_has_collected_at() const {
  return this != internal_default_instance() && _impl_.collected_at_ != nullptr;
}
inline bool GetMetricsResponse::has_collected_at() const {
  return _internal_has_collected_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& GetMetricsResponse::_internal_collected_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.collected_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& GetMetricsResponse::collected_at() const {
  // @@protoc_insertion_point(field_get:unhinged.persistence.GetMetricsResponse.collected_at)
  return _internal_collected_at();
}
inline void GetMetricsResponse::unsafe_arena_set_allocated_collected_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* collected_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.collected_at_);
  }
  _impl_.collected_at_ = collected_at;
  if (collected_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.persistence.GetMetricsResponse.collected_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetMetricsResponse::release_collected_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.collected_at_;
  _impl_.collected_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetMetricsResponse::unsafe_arena_release_collected_at() {
  // @@protoc_insertion_point(field_release:unhinged.persistence.GetMetricsResponse.collected_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.collected_at_;
  _impl_.collected_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetMetricsResponse::_internal_mutable_collected_at() {
  
  if (_impl_.collected_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.collected_at_ = p;
  }
  return _impl_.collected_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetMetricsResponse::mutable_collected_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_collected_at();
  // @@protoc_insertion_point(field_mutable:unhinged.persistence.GetMetricsResponse.collected_at)
  return _msg;
}
inline void GetMetricsResponse::set_allocated_collected_at(::PROTOBUF_NAMESPACE_ID::Timestamp* collected_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.collected_at_);
  }
  if (collected_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(collected_at));
    if (message_arena != submessage_arena) {
      collected_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, collected_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.collected_at_ = collected_at;
  // @@protoc_insertion_point(field_set_allocated:unhinged.persistence.GetMetricsResponse.collected_at)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace persistence
}  // namespace unhinged

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::unhinged::persistence::QueryType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::unhinged::persistence::QueryType>() {
  return ::unhinged::persistence::QueryType_descriptor();
}
template <> struct is_proto_enum< ::unhinged::persistence::GraphTraversalType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::unhinged::persistence::GraphTraversalType>() {
  return ::unhinged::persistence::GraphTraversalType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_persistence_5fplatform_2eproto
