// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cdc_events.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_cdc_5fevents_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_cdc_5fevents_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
#include <google/protobuf/struct.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_cdc_5fevents_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_cdc_5fevents_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_cdc_5fevents_2eproto;
namespace unhinged {
namespace cdc {
class AgentCompleted;
struct AgentCompletedDefaultTypeInternal;
extern AgentCompletedDefaultTypeInternal _AgentCompleted_default_instance_;
class AgentEvent;
struct AgentEventDefaultTypeInternal;
extern AgentEventDefaultTypeInternal _AgentEvent_default_instance_;
class AgentFailed;
struct AgentFailedDefaultTypeInternal;
extern AgentFailedDefaultTypeInternal _AgentFailed_default_instance_;
class AgentStarted;
struct AgentStartedDefaultTypeInternal;
extern AgentStartedDefaultTypeInternal _AgentStarted_default_instance_;
class AgentStepCompleted;
struct AgentStepCompletedDefaultTypeInternal;
extern AgentStepCompletedDefaultTypeInternal _AgentStepCompleted_default_instance_;
class AgentToolUsed;
struct AgentToolUsedDefaultTypeInternal;
extern AgentToolUsedDefaultTypeInternal _AgentToolUsed_default_instance_;
class AlertTriggered;
struct AlertTriggeredDefaultTypeInternal;
extern AlertTriggeredDefaultTypeInternal _AlertTriggered_default_instance_;
class AudioEvent;
struct AudioEventDefaultTypeInternal;
extern AudioEventDefaultTypeInternal _AudioEvent_default_instance_;
class ChatEvent;
struct ChatEventDefaultTypeInternal;
extern ChatEventDefaultTypeInternal _ChatEvent_default_instance_;
class ConversationCreated;
struct ConversationCreatedDefaultTypeInternal;
extern ConversationCreatedDefaultTypeInternal _ConversationCreated_default_instance_;
class DocumentAccessed;
struct DocumentAccessedDefaultTypeInternal;
extern DocumentAccessedDefaultTypeInternal _DocumentAccessed_default_instance_;
class DocumentCreated;
struct DocumentCreatedDefaultTypeInternal;
extern DocumentCreatedDefaultTypeInternal _DocumentCreated_default_instance_;
class DocumentDeleted;
struct DocumentDeletedDefaultTypeInternal;
extern DocumentDeletedDefaultTypeInternal _DocumentDeleted_default_instance_;
class DocumentEvent;
struct DocumentEventDefaultTypeInternal;
extern DocumentEventDefaultTypeInternal _DocumentEvent_default_instance_;
class DocumentTagged;
struct DocumentTaggedDefaultTypeInternal;
extern DocumentTaggedDefaultTypeInternal _DocumentTagged_default_instance_;
class DocumentUpdated;
struct DocumentUpdatedDefaultTypeInternal;
extern DocumentUpdatedDefaultTypeInternal _DocumentUpdated_default_instance_;
class DocumentVersioned;
struct DocumentVersionedDefaultTypeInternal;
extern DocumentVersionedDefaultTypeInternal _DocumentVersioned_default_instance_;
class HealthCheck;
struct HealthCheckDefaultTypeInternal;
extern HealthCheckDefaultTypeInternal _HealthCheck_default_instance_;
class LLMError;
struct LLMErrorDefaultTypeInternal;
extern LLMErrorDefaultTypeInternal _LLMError_default_instance_;
class LLMEvent;
struct LLMEventDefaultTypeInternal;
extern LLMEventDefaultTypeInternal _LLMEvent_default_instance_;
class LLMFeedback;
struct LLMFeedbackDefaultTypeInternal;
extern LLMFeedbackDefaultTypeInternal _LLMFeedback_default_instance_;
class LLMPromptSent;
struct LLMPromptSentDefaultTypeInternal;
extern LLMPromptSentDefaultTypeInternal _LLMPromptSent_default_instance_;
class LLMResponseReceived;
struct LLMResponseReceivedDefaultTypeInternal;
extern LLMResponseReceivedDefaultTypeInternal _LLMResponseReceived_default_instance_;
class LLMTokenUsage;
struct LLMTokenUsageDefaultTypeInternal;
extern LLMTokenUsageDefaultTypeInternal _LLMTokenUsage_default_instance_;
class MessageSent;
struct MessageSentDefaultTypeInternal;
extern MessageSentDefaultTypeInternal _MessageSent_default_instance_;
class MessageUpdated;
struct MessageUpdatedDefaultTypeInternal;
extern MessageUpdatedDefaultTypeInternal _MessageUpdated_default_instance_;
class MetricReported;
struct MetricReportedDefaultTypeInternal;
extern MetricReportedDefaultTypeInternal _MetricReported_default_instance_;
class ParticipantJoined;
struct ParticipantJoinedDefaultTypeInternal;
extern ParticipantJoinedDefaultTypeInternal _ParticipantJoined_default_instance_;
class STTCompleted;
struct STTCompletedDefaultTypeInternal;
extern STTCompletedDefaultTypeInternal _STTCompleted_default_instance_;
class ServiceStarted;
struct ServiceStartedDefaultTypeInternal;
extern ServiceStartedDefaultTypeInternal _ServiceStarted_default_instance_;
class ServiceStopped;
struct ServiceStoppedDefaultTypeInternal;
extern ServiceStoppedDefaultTypeInternal _ServiceStopped_default_instance_;
class SessionContextAccessed;
struct SessionContextAccessedDefaultTypeInternal;
extern SessionContextAccessedDefaultTypeInternal _SessionContextAccessed_default_instance_;
class SessionEnded;
struct SessionEndedDefaultTypeInternal;
extern SessionEndedDefaultTypeInternal _SessionEnded_default_instance_;
class SessionEvent;
struct SessionEventDefaultTypeInternal;
extern SessionEventDefaultTypeInternal _SessionEvent_default_instance_;
class SessionHeartbeat;
struct SessionHeartbeatDefaultTypeInternal;
extern SessionHeartbeatDefaultTypeInternal _SessionHeartbeat_default_instance_;
class SessionStarted;
struct SessionStartedDefaultTypeInternal;
extern SessionStartedDefaultTypeInternal _SessionStarted_default_instance_;
class SystemEvent;
struct SystemEventDefaultTypeInternal;
extern SystemEventDefaultTypeInternal _SystemEvent_default_instance_;
class TTSCompleted;
struct TTSCompletedDefaultTypeInternal;
extern TTSCompletedDefaultTypeInternal _TTSCompleted_default_instance_;
class TTSStarted;
struct TTSStartedDefaultTypeInternal;
extern TTSStartedDefaultTypeInternal _TTSStarted_default_instance_;
class TeamMemberAdded;
struct TeamMemberAddedDefaultTypeInternal;
extern TeamMemberAddedDefaultTypeInternal _TeamMemberAdded_default_instance_;
class TypingStarted;
struct TypingStartedDefaultTypeInternal;
extern TypingStartedDefaultTypeInternal _TypingStarted_default_instance_;
class UniversalEvent;
struct UniversalEventDefaultTypeInternal;
extern UniversalEventDefaultTypeInternal _UniversalEvent_default_instance_;
class UserCreated;
struct UserCreatedDefaultTypeInternal;
extern UserCreatedDefaultTypeInternal _UserCreated_default_instance_;
class UserEvent;
struct UserEventDefaultTypeInternal;
extern UserEventDefaultTypeInternal _UserEvent_default_instance_;
class UserLoggedIn;
struct UserLoggedInDefaultTypeInternal;
extern UserLoggedInDefaultTypeInternal _UserLoggedIn_default_instance_;
class WorkflowCompleted;
struct WorkflowCompletedDefaultTypeInternal;
extern WorkflowCompletedDefaultTypeInternal _WorkflowCompleted_default_instance_;
class WorkflowEvent;
struct WorkflowEventDefaultTypeInternal;
extern WorkflowEventDefaultTypeInternal _WorkflowEvent_default_instance_;
class WorkflowFailed;
struct WorkflowFailedDefaultTypeInternal;
extern WorkflowFailedDefaultTypeInternal _WorkflowFailed_default_instance_;
class WorkflowStepExecuted;
struct WorkflowStepExecutedDefaultTypeInternal;
extern WorkflowStepExecutedDefaultTypeInternal _WorkflowStepExecuted_default_instance_;
class WorkflowTriggered;
struct WorkflowTriggeredDefaultTypeInternal;
extern WorkflowTriggeredDefaultTypeInternal _WorkflowTriggered_default_instance_;
}  // namespace cdc
}  // namespace unhinged
PROTOBUF_NAMESPACE_OPEN
template<> ::unhinged::cdc::AgentCompleted* Arena::CreateMaybeMessage<::unhinged::cdc::AgentCompleted>(Arena*);
template<> ::unhinged::cdc::AgentEvent* Arena::CreateMaybeMessage<::unhinged::cdc::AgentEvent>(Arena*);
template<> ::unhinged::cdc::AgentFailed* Arena::CreateMaybeMessage<::unhinged::cdc::AgentFailed>(Arena*);
template<> ::unhinged::cdc::AgentStarted* Arena::CreateMaybeMessage<::unhinged::cdc::AgentStarted>(Arena*);
template<> ::unhinged::cdc::AgentStepCompleted* Arena::CreateMaybeMessage<::unhinged::cdc::AgentStepCompleted>(Arena*);
template<> ::unhinged::cdc::AgentToolUsed* Arena::CreateMaybeMessage<::unhinged::cdc::AgentToolUsed>(Arena*);
template<> ::unhinged::cdc::AlertTriggered* Arena::CreateMaybeMessage<::unhinged::cdc::AlertTriggered>(Arena*);
template<> ::unhinged::cdc::AudioEvent* Arena::CreateMaybeMessage<::unhinged::cdc::AudioEvent>(Arena*);
template<> ::unhinged::cdc::ChatEvent* Arena::CreateMaybeMessage<::unhinged::cdc::ChatEvent>(Arena*);
template<> ::unhinged::cdc::ConversationCreated* Arena::CreateMaybeMessage<::unhinged::cdc::ConversationCreated>(Arena*);
template<> ::unhinged::cdc::DocumentAccessed* Arena::CreateMaybeMessage<::unhinged::cdc::DocumentAccessed>(Arena*);
template<> ::unhinged::cdc::DocumentCreated* Arena::CreateMaybeMessage<::unhinged::cdc::DocumentCreated>(Arena*);
template<> ::unhinged::cdc::DocumentDeleted* Arena::CreateMaybeMessage<::unhinged::cdc::DocumentDeleted>(Arena*);
template<> ::unhinged::cdc::DocumentEvent* Arena::CreateMaybeMessage<::unhinged::cdc::DocumentEvent>(Arena*);
template<> ::unhinged::cdc::DocumentTagged* Arena::CreateMaybeMessage<::unhinged::cdc::DocumentTagged>(Arena*);
template<> ::unhinged::cdc::DocumentUpdated* Arena::CreateMaybeMessage<::unhinged::cdc::DocumentUpdated>(Arena*);
template<> ::unhinged::cdc::DocumentVersioned* Arena::CreateMaybeMessage<::unhinged::cdc::DocumentVersioned>(Arena*);
template<> ::unhinged::cdc::HealthCheck* Arena::CreateMaybeMessage<::unhinged::cdc::HealthCheck>(Arena*);
template<> ::unhinged::cdc::LLMError* Arena::CreateMaybeMessage<::unhinged::cdc::LLMError>(Arena*);
template<> ::unhinged::cdc::LLMEvent* Arena::CreateMaybeMessage<::unhinged::cdc::LLMEvent>(Arena*);
template<> ::unhinged::cdc::LLMFeedback* Arena::CreateMaybeMessage<::unhinged::cdc::LLMFeedback>(Arena*);
template<> ::unhinged::cdc::LLMPromptSent* Arena::CreateMaybeMessage<::unhinged::cdc::LLMPromptSent>(Arena*);
template<> ::unhinged::cdc::LLMResponseReceived* Arena::CreateMaybeMessage<::unhinged::cdc::LLMResponseReceived>(Arena*);
template<> ::unhinged::cdc::LLMTokenUsage* Arena::CreateMaybeMessage<::unhinged::cdc::LLMTokenUsage>(Arena*);
template<> ::unhinged::cdc::MessageSent* Arena::CreateMaybeMessage<::unhinged::cdc::MessageSent>(Arena*);
template<> ::unhinged::cdc::MessageUpdated* Arena::CreateMaybeMessage<::unhinged::cdc::MessageUpdated>(Arena*);
template<> ::unhinged::cdc::MetricReported* Arena::CreateMaybeMessage<::unhinged::cdc::MetricReported>(Arena*);
template<> ::unhinged::cdc::ParticipantJoined* Arena::CreateMaybeMessage<::unhinged::cdc::ParticipantJoined>(Arena*);
template<> ::unhinged::cdc::STTCompleted* Arena::CreateMaybeMessage<::unhinged::cdc::STTCompleted>(Arena*);
template<> ::unhinged::cdc::ServiceStarted* Arena::CreateMaybeMessage<::unhinged::cdc::ServiceStarted>(Arena*);
template<> ::unhinged::cdc::ServiceStopped* Arena::CreateMaybeMessage<::unhinged::cdc::ServiceStopped>(Arena*);
template<> ::unhinged::cdc::SessionContextAccessed* Arena::CreateMaybeMessage<::unhinged::cdc::SessionContextAccessed>(Arena*);
template<> ::unhinged::cdc::SessionEnded* Arena::CreateMaybeMessage<::unhinged::cdc::SessionEnded>(Arena*);
template<> ::unhinged::cdc::SessionEvent* Arena::CreateMaybeMessage<::unhinged::cdc::SessionEvent>(Arena*);
template<> ::unhinged::cdc::SessionHeartbeat* Arena::CreateMaybeMessage<::unhinged::cdc::SessionHeartbeat>(Arena*);
template<> ::unhinged::cdc::SessionStarted* Arena::CreateMaybeMessage<::unhinged::cdc::SessionStarted>(Arena*);
template<> ::unhinged::cdc::SystemEvent* Arena::CreateMaybeMessage<::unhinged::cdc::SystemEvent>(Arena*);
template<> ::unhinged::cdc::TTSCompleted* Arena::CreateMaybeMessage<::unhinged::cdc::TTSCompleted>(Arena*);
template<> ::unhinged::cdc::TTSStarted* Arena::CreateMaybeMessage<::unhinged::cdc::TTSStarted>(Arena*);
template<> ::unhinged::cdc::TeamMemberAdded* Arena::CreateMaybeMessage<::unhinged::cdc::TeamMemberAdded>(Arena*);
template<> ::unhinged::cdc::TypingStarted* Arena::CreateMaybeMessage<::unhinged::cdc::TypingStarted>(Arena*);
template<> ::unhinged::cdc::UniversalEvent* Arena::CreateMaybeMessage<::unhinged::cdc::UniversalEvent>(Arena*);
template<> ::unhinged::cdc::UserCreated* Arena::CreateMaybeMessage<::unhinged::cdc::UserCreated>(Arena*);
template<> ::unhinged::cdc::UserEvent* Arena::CreateMaybeMessage<::unhinged::cdc::UserEvent>(Arena*);
template<> ::unhinged::cdc::UserLoggedIn* Arena::CreateMaybeMessage<::unhinged::cdc::UserLoggedIn>(Arena*);
template<> ::unhinged::cdc::WorkflowCompleted* Arena::CreateMaybeMessage<::unhinged::cdc::WorkflowCompleted>(Arena*);
template<> ::unhinged::cdc::WorkflowEvent* Arena::CreateMaybeMessage<::unhinged::cdc::WorkflowEvent>(Arena*);
template<> ::unhinged::cdc::WorkflowFailed* Arena::CreateMaybeMessage<::unhinged::cdc::WorkflowFailed>(Arena*);
template<> ::unhinged::cdc::WorkflowStepExecuted* Arena::CreateMaybeMessage<::unhinged::cdc::WorkflowStepExecuted>(Arena*);
template<> ::unhinged::cdc::WorkflowTriggered* Arena::CreateMaybeMessage<::unhinged::cdc::WorkflowTriggered>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace unhinged {
namespace cdc {

enum DocumentEventType : int {
  DOCUMENT_CREATED = 0,
  DOCUMENT_UPDATED = 1,
  DOCUMENT_DELETED = 2,
  DOCUMENT_ACCESSED = 3,
  DOCUMENT_TAGGED = 4,
  DOCUMENT_VERSIONED = 5,
  DocumentEventType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DocumentEventType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DocumentEventType_IsValid(int value);
constexpr DocumentEventType DocumentEventType_MIN = DOCUMENT_CREATED;
constexpr DocumentEventType DocumentEventType_MAX = DOCUMENT_VERSIONED;
constexpr int DocumentEventType_ARRAYSIZE = DocumentEventType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DocumentEventType_descriptor();
template<typename T>
inline const std::string& DocumentEventType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DocumentEventType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DocumentEventType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DocumentEventType_descriptor(), enum_t_value);
}
inline bool DocumentEventType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DocumentEventType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DocumentEventType>(
    DocumentEventType_descriptor(), name, value);
}
enum LLMEventType : int {
  LLM_PROMPT_SENT = 0,
  LLM_RESPONSE_RECEIVED = 1,
  LLM_ERROR = 2,
  LLM_FEEDBACK = 3,
  LLM_TOKEN_USAGE = 4,
  LLMEventType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  LLMEventType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool LLMEventType_IsValid(int value);
constexpr LLMEventType LLMEventType_MIN = LLM_PROMPT_SENT;
constexpr LLMEventType LLMEventType_MAX = LLM_TOKEN_USAGE;
constexpr int LLMEventType_ARRAYSIZE = LLMEventType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LLMEventType_descriptor();
template<typename T>
inline const std::string& LLMEventType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LLMEventType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LLMEventType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LLMEventType_descriptor(), enum_t_value);
}
inline bool LLMEventType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LLMEventType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LLMEventType>(
    LLMEventType_descriptor(), name, value);
}
enum AgentEventType : int {
  AGENT_STARTED = 0,
  AGENT_STEP_COMPLETED = 1,
  AGENT_COMPLETED = 2,
  AGENT_FAILED = 3,
  AGENT_TOOL_USED = 4,
  AgentEventType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AgentEventType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AgentEventType_IsValid(int value);
constexpr AgentEventType AgentEventType_MIN = AGENT_STARTED;
constexpr AgentEventType AgentEventType_MAX = AGENT_TOOL_USED;
constexpr int AgentEventType_ARRAYSIZE = AgentEventType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AgentEventType_descriptor();
template<typename T>
inline const std::string& AgentEventType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AgentEventType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AgentEventType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AgentEventType_descriptor(), enum_t_value);
}
inline bool AgentEventType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AgentEventType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AgentEventType>(
    AgentEventType_descriptor(), name, value);
}
enum SessionEventType : int {
  SESSION_STARTED = 0,
  SESSION_ENDED = 1,
  SESSION_CONTEXT_ACCESSED = 2,
  SESSION_HEARTBEAT = 3,
  SessionEventType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SessionEventType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SessionEventType_IsValid(int value);
constexpr SessionEventType SessionEventType_MIN = SESSION_STARTED;
constexpr SessionEventType SessionEventType_MAX = SESSION_HEARTBEAT;
constexpr int SessionEventType_ARRAYSIZE = SessionEventType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SessionEventType_descriptor();
template<typename T>
inline const std::string& SessionEventType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SessionEventType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SessionEventType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SessionEventType_descriptor(), enum_t_value);
}
inline bool SessionEventType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SessionEventType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SessionEventType>(
    SessionEventType_descriptor(), name, value);
}
enum SystemEventType : int {
  HEALTH_CHECK = 0,
  METRIC_REPORTED = 1,
  ALERT_TRIGGERED = 2,
  SERVICE_STARTED = 3,
  SERVICE_STOPPED = 4,
  SystemEventType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SystemEventType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SystemEventType_IsValid(int value);
constexpr SystemEventType SystemEventType_MIN = HEALTH_CHECK;
constexpr SystemEventType SystemEventType_MAX = SERVICE_STOPPED;
constexpr int SystemEventType_ARRAYSIZE = SystemEventType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SystemEventType_descriptor();
template<typename T>
inline const std::string& SystemEventType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SystemEventType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SystemEventType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SystemEventType_descriptor(), enum_t_value);
}
inline bool SystemEventType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SystemEventType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SystemEventType>(
    SystemEventType_descriptor(), name, value);
}
enum WorkflowEventType : int {
  WORKFLOW_TRIGGERED = 0,
  WORKFLOW_STEP_EXECUTED = 1,
  WORKFLOW_COMPLETED = 2,
  WORKFLOW_FAILED = 3,
  WorkflowEventType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  WorkflowEventType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool WorkflowEventType_IsValid(int value);
constexpr WorkflowEventType WorkflowEventType_MIN = WORKFLOW_TRIGGERED;
constexpr WorkflowEventType WorkflowEventType_MAX = WORKFLOW_FAILED;
constexpr int WorkflowEventType_ARRAYSIZE = WorkflowEventType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WorkflowEventType_descriptor();
template<typename T>
inline const std::string& WorkflowEventType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WorkflowEventType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WorkflowEventType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WorkflowEventType_descriptor(), enum_t_value);
}
inline bool WorkflowEventType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WorkflowEventType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WorkflowEventType>(
    WorkflowEventType_descriptor(), name, value);
}
enum ChatEventType : int {
  CHAT_EVENT_TYPE_UNSPECIFIED = 0,
  CHAT_EVENT_TYPE_CONVERSATION_CREATED = 1,
  CHAT_EVENT_TYPE_MESSAGE_SENT = 2,
  CHAT_EVENT_TYPE_MESSAGE_UPDATED = 3,
  CHAT_EVENT_TYPE_TYPING_STARTED = 4,
  CHAT_EVENT_TYPE_PARTICIPANT_JOINED = 5,
  ChatEventType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ChatEventType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ChatEventType_IsValid(int value);
constexpr ChatEventType ChatEventType_MIN = CHAT_EVENT_TYPE_UNSPECIFIED;
constexpr ChatEventType ChatEventType_MAX = CHAT_EVENT_TYPE_PARTICIPANT_JOINED;
constexpr int ChatEventType_ARRAYSIZE = ChatEventType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ChatEventType_descriptor();
template<typename T>
inline const std::string& ChatEventType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ChatEventType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ChatEventType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ChatEventType_descriptor(), enum_t_value);
}
inline bool ChatEventType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ChatEventType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ChatEventType>(
    ChatEventType_descriptor(), name, value);
}
enum AudioEventType : int {
  AUDIO_EVENT_TYPE_UNSPECIFIED = 0,
  AUDIO_EVENT_TYPE_TTS_STARTED = 1,
  AUDIO_EVENT_TYPE_TTS_COMPLETED = 2,
  AUDIO_EVENT_TYPE_STT_COMPLETED = 3,
  AudioEventType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AudioEventType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AudioEventType_IsValid(int value);
constexpr AudioEventType AudioEventType_MIN = AUDIO_EVENT_TYPE_UNSPECIFIED;
constexpr AudioEventType AudioEventType_MAX = AUDIO_EVENT_TYPE_STT_COMPLETED;
constexpr int AudioEventType_ARRAYSIZE = AudioEventType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AudioEventType_descriptor();
template<typename T>
inline const std::string& AudioEventType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AudioEventType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AudioEventType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AudioEventType_descriptor(), enum_t_value);
}
inline bool AudioEventType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AudioEventType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AudioEventType>(
    AudioEventType_descriptor(), name, value);
}
enum UserEventType : int {
  USER_EVENT_TYPE_UNSPECIFIED = 0,
  USER_EVENT_TYPE_CREATED = 1,
  USER_EVENT_TYPE_LOGGED_IN = 2,
  USER_EVENT_TYPE_TEAM_MEMBER_ADDED = 3,
  UserEventType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  UserEventType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool UserEventType_IsValid(int value);
constexpr UserEventType UserEventType_MIN = USER_EVENT_TYPE_UNSPECIFIED;
constexpr UserEventType UserEventType_MAX = USER_EVENT_TYPE_TEAM_MEMBER_ADDED;
constexpr int UserEventType_ARRAYSIZE = UserEventType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UserEventType_descriptor();
template<typename T>
inline const std::string& UserEventType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UserEventType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UserEventType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UserEventType_descriptor(), enum_t_value);
}
inline bool UserEventType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UserEventType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UserEventType>(
    UserEventType_descriptor(), name, value);
}
// ===================================================================

class UniversalEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.UniversalEvent) */ {
 public:
  inline UniversalEvent() : UniversalEvent(nullptr) {}
  ~UniversalEvent() override;
  explicit PROTOBUF_CONSTEXPR UniversalEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UniversalEvent(const UniversalEvent& from);
  UniversalEvent(UniversalEvent&& from) noexcept
    : UniversalEvent() {
    *this = ::std::move(from);
  }

  inline UniversalEvent& operator=(const UniversalEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline UniversalEvent& operator=(UniversalEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UniversalEvent& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadCase {
    kDocumentEvent = 20,
    kLlmEvent = 21,
    kAgentEvent = 22,
    kSessionEvent = 23,
    kSystemEvent = 24,
    kWorkflowEvent = 25,
    kChatEvent = 26,
    kAudioEvent = 27,
    kUserEvent = 28,
    PAYLOAD_NOT_SET = 0,
  };

  static inline const UniversalEvent* internal_default_instance() {
    return reinterpret_cast<const UniversalEvent*>(
               &_UniversalEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(UniversalEvent& a, UniversalEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(UniversalEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UniversalEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UniversalEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UniversalEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UniversalEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UniversalEvent& from) {
    UniversalEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UniversalEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.UniversalEvent";
  }
  protected:
  explicit UniversalEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagsFieldNumber = 31,
    kEventIdFieldNumber = 1,
    kEventTypeFieldNumber = 2,
    kEventVersionFieldNumber = 3,
    kSourceServiceFieldNumber = 6,
    kSourceVersionFieldNumber = 7,
    kTraceIdFieldNumber = 8,
    kCorrelationIdFieldNumber = 9,
    kUserIdFieldNumber = 10,
    kSessionIdFieldNumber = 11,
    kTenantIdFieldNumber = 12,
    kRoutingKeyFieldNumber = 32,
    kEventTimeFieldNumber = 4,
    kMetadataFieldNumber = 30,
    kExpiresAtFieldNumber = 34,
    kSequenceNumberFieldNumber = 5,
    kRetryCountFieldNumber = 33,
    kDocumentEventFieldNumber = 20,
    kLlmEventFieldNumber = 21,
    kAgentEventFieldNumber = 22,
    kSessionEventFieldNumber = 23,
    kSystemEventFieldNumber = 24,
    kWorkflowEventFieldNumber = 25,
    kChatEventFieldNumber = 26,
    kAudioEventFieldNumber = 27,
    kUserEventFieldNumber = 28,
  };
  // repeated string tags = 31;
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  const std::string& tags(int index) const;
  std::string* mutable_tags(int index);
  void set_tags(int index, const std::string& value);
  void set_tags(int index, std::string&& value);
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, size_t size);
  std::string* add_tags();
  void add_tags(const std::string& value);
  void add_tags(std::string&& value);
  void add_tags(const char* value);
  void add_tags(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tags();
  private:
  const std::string& _internal_tags(int index) const;
  std::string* _internal_add_tags();
  public:

  // string event_id = 1;
  void clear_event_id();
  const std::string& event_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_event_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_event_id();
  PROTOBUF_NODISCARD std::string* release_event_id();
  void set_allocated_event_id(std::string* event_id);
  private:
  const std::string& _internal_event_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_event_id(const std::string& value);
  std::string* _internal_mutable_event_id();
  public:

  // string event_type = 2;
  void clear_event_type();
  const std::string& event_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_event_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_event_type();
  PROTOBUF_NODISCARD std::string* release_event_type();
  void set_allocated_event_type(std::string* event_type);
  private:
  const std::string& _internal_event_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_event_type(const std::string& value);
  std::string* _internal_mutable_event_type();
  public:

  // string event_version = 3;
  void clear_event_version();
  const std::string& event_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_event_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_event_version();
  PROTOBUF_NODISCARD std::string* release_event_version();
  void set_allocated_event_version(std::string* event_version);
  private:
  const std::string& _internal_event_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_event_version(const std::string& value);
  std::string* _internal_mutable_event_version();
  public:

  // string source_service = 6;
  void clear_source_service();
  const std::string& source_service() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_source_service(ArgT0&& arg0, ArgT... args);
  std::string* mutable_source_service();
  PROTOBUF_NODISCARD std::string* release_source_service();
  void set_allocated_source_service(std::string* source_service);
  private:
  const std::string& _internal_source_service() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source_service(const std::string& value);
  std::string* _internal_mutable_source_service();
  public:

  // string source_version = 7;
  void clear_source_version();
  const std::string& source_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_source_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_source_version();
  PROTOBUF_NODISCARD std::string* release_source_version();
  void set_allocated_source_version(std::string* source_version);
  private:
  const std::string& _internal_source_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source_version(const std::string& value);
  std::string* _internal_mutable_source_version();
  public:

  // string trace_id = 8;
  void clear_trace_id();
  const std::string& trace_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_trace_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_trace_id();
  PROTOBUF_NODISCARD std::string* release_trace_id();
  void set_allocated_trace_id(std::string* trace_id);
  private:
  const std::string& _internal_trace_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trace_id(const std::string& value);
  std::string* _internal_mutable_trace_id();
  public:

  // string correlation_id = 9;
  void clear_correlation_id();
  const std::string& correlation_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_correlation_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_correlation_id();
  PROTOBUF_NODISCARD std::string* release_correlation_id();
  void set_allocated_correlation_id(std::string* correlation_id);
  private:
  const std::string& _internal_correlation_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_correlation_id(const std::string& value);
  std::string* _internal_mutable_correlation_id();
  public:

  // string user_id = 10;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string session_id = 11;
  void clear_session_id();
  const std::string& session_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // string tenant_id = 12;
  void clear_tenant_id();
  const std::string& tenant_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tenant_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tenant_id();
  PROTOBUF_NODISCARD std::string* release_tenant_id();
  void set_allocated_tenant_id(std::string* tenant_id);
  private:
  const std::string& _internal_tenant_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tenant_id(const std::string& value);
  std::string* _internal_mutable_tenant_id();
  public:

  // string routing_key = 32;
  void clear_routing_key();
  const std::string& routing_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_routing_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_routing_key();
  PROTOBUF_NODISCARD std::string* release_routing_key();
  void set_allocated_routing_key(std::string* routing_key);
  private:
  const std::string& _internal_routing_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_routing_key(const std::string& value);
  std::string* _internal_mutable_routing_key();
  public:

  // .google.protobuf.Timestamp event_time = 4;
  bool has_event_time() const;
  private:
  bool _internal_has_event_time() const;
  public:
  void clear_event_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& event_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_event_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_event_time();
  void set_allocated_event_time(::PROTOBUF_NAMESPACE_ID::Timestamp* event_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_event_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_event_time();
  public:
  void unsafe_arena_set_allocated_event_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* event_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_event_time();

  // .google.protobuf.Struct metadata = 30;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::PROTOBUF_NAMESPACE_ID::Struct& metadata() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_metadata();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_metadata();
  void set_allocated_metadata(::PROTOBUF_NAMESPACE_ID::Struct* metadata);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::PROTOBUF_NAMESPACE_ID::Struct* metadata);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_metadata();

  // .google.protobuf.Timestamp expires_at = 34;
  bool has_expires_at() const;
  private:
  bool _internal_has_expires_at() const;
  public:
  void clear_expires_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& expires_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_expires_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_expires_at();
  void set_allocated_expires_at(::PROTOBUF_NAMESPACE_ID::Timestamp* expires_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_expires_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_expires_at();
  public:
  void unsafe_arena_set_allocated_expires_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* expires_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_expires_at();

  // int64 sequence_number = 5;
  void clear_sequence_number();
  int64_t sequence_number() const;
  void set_sequence_number(int64_t value);
  private:
  int64_t _internal_sequence_number() const;
  void _internal_set_sequence_number(int64_t value);
  public:

  // int32 retry_count = 33;
  void clear_retry_count();
  int32_t retry_count() const;
  void set_retry_count(int32_t value);
  private:
  int32_t _internal_retry_count() const;
  void _internal_set_retry_count(int32_t value);
  public:

  // .unhinged.cdc.DocumentEvent document_event = 20;
  bool has_document_event() const;
  private:
  bool _internal_has_document_event() const;
  public:
  void clear_document_event();
  const ::unhinged::cdc::DocumentEvent& document_event() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::DocumentEvent* release_document_event();
  ::unhinged::cdc::DocumentEvent* mutable_document_event();
  void set_allocated_document_event(::unhinged::cdc::DocumentEvent* document_event);
  private:
  const ::unhinged::cdc::DocumentEvent& _internal_document_event() const;
  ::unhinged::cdc::DocumentEvent* _internal_mutable_document_event();
  public:
  void unsafe_arena_set_allocated_document_event(
      ::unhinged::cdc::DocumentEvent* document_event);
  ::unhinged::cdc::DocumentEvent* unsafe_arena_release_document_event();

  // .unhinged.cdc.LLMEvent llm_event = 21;
  bool has_llm_event() const;
  private:
  bool _internal_has_llm_event() const;
  public:
  void clear_llm_event();
  const ::unhinged::cdc::LLMEvent& llm_event() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::LLMEvent* release_llm_event();
  ::unhinged::cdc::LLMEvent* mutable_llm_event();
  void set_allocated_llm_event(::unhinged::cdc::LLMEvent* llm_event);
  private:
  const ::unhinged::cdc::LLMEvent& _internal_llm_event() const;
  ::unhinged::cdc::LLMEvent* _internal_mutable_llm_event();
  public:
  void unsafe_arena_set_allocated_llm_event(
      ::unhinged::cdc::LLMEvent* llm_event);
  ::unhinged::cdc::LLMEvent* unsafe_arena_release_llm_event();

  // .unhinged.cdc.AgentEvent agent_event = 22;
  bool has_agent_event() const;
  private:
  bool _internal_has_agent_event() const;
  public:
  void clear_agent_event();
  const ::unhinged::cdc::AgentEvent& agent_event() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::AgentEvent* release_agent_event();
  ::unhinged::cdc::AgentEvent* mutable_agent_event();
  void set_allocated_agent_event(::unhinged::cdc::AgentEvent* agent_event);
  private:
  const ::unhinged::cdc::AgentEvent& _internal_agent_event() const;
  ::unhinged::cdc::AgentEvent* _internal_mutable_agent_event();
  public:
  void unsafe_arena_set_allocated_agent_event(
      ::unhinged::cdc::AgentEvent* agent_event);
  ::unhinged::cdc::AgentEvent* unsafe_arena_release_agent_event();

  // .unhinged.cdc.SessionEvent session_event = 23;
  bool has_session_event() const;
  private:
  bool _internal_has_session_event() const;
  public:
  void clear_session_event();
  const ::unhinged::cdc::SessionEvent& session_event() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::SessionEvent* release_session_event();
  ::unhinged::cdc::SessionEvent* mutable_session_event();
  void set_allocated_session_event(::unhinged::cdc::SessionEvent* session_event);
  private:
  const ::unhinged::cdc::SessionEvent& _internal_session_event() const;
  ::unhinged::cdc::SessionEvent* _internal_mutable_session_event();
  public:
  void unsafe_arena_set_allocated_session_event(
      ::unhinged::cdc::SessionEvent* session_event);
  ::unhinged::cdc::SessionEvent* unsafe_arena_release_session_event();

  // .unhinged.cdc.SystemEvent system_event = 24;
  bool has_system_event() const;
  private:
  bool _internal_has_system_event() const;
  public:
  void clear_system_event();
  const ::unhinged::cdc::SystemEvent& system_event() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::SystemEvent* release_system_event();
  ::unhinged::cdc::SystemEvent* mutable_system_event();
  void set_allocated_system_event(::unhinged::cdc::SystemEvent* system_event);
  private:
  const ::unhinged::cdc::SystemEvent& _internal_system_event() const;
  ::unhinged::cdc::SystemEvent* _internal_mutable_system_event();
  public:
  void unsafe_arena_set_allocated_system_event(
      ::unhinged::cdc::SystemEvent* system_event);
  ::unhinged::cdc::SystemEvent* unsafe_arena_release_system_event();

  // .unhinged.cdc.WorkflowEvent workflow_event = 25;
  bool has_workflow_event() const;
  private:
  bool _internal_has_workflow_event() const;
  public:
  void clear_workflow_event();
  const ::unhinged::cdc::WorkflowEvent& workflow_event() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::WorkflowEvent* release_workflow_event();
  ::unhinged::cdc::WorkflowEvent* mutable_workflow_event();
  void set_allocated_workflow_event(::unhinged::cdc::WorkflowEvent* workflow_event);
  private:
  const ::unhinged::cdc::WorkflowEvent& _internal_workflow_event() const;
  ::unhinged::cdc::WorkflowEvent* _internal_mutable_workflow_event();
  public:
  void unsafe_arena_set_allocated_workflow_event(
      ::unhinged::cdc::WorkflowEvent* workflow_event);
  ::unhinged::cdc::WorkflowEvent* unsafe_arena_release_workflow_event();

  // .unhinged.cdc.ChatEvent chat_event = 26;
  bool has_chat_event() const;
  private:
  bool _internal_has_chat_event() const;
  public:
  void clear_chat_event();
  const ::unhinged::cdc::ChatEvent& chat_event() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::ChatEvent* release_chat_event();
  ::unhinged::cdc::ChatEvent* mutable_chat_event();
  void set_allocated_chat_event(::unhinged::cdc::ChatEvent* chat_event);
  private:
  const ::unhinged::cdc::ChatEvent& _internal_chat_event() const;
  ::unhinged::cdc::ChatEvent* _internal_mutable_chat_event();
  public:
  void unsafe_arena_set_allocated_chat_event(
      ::unhinged::cdc::ChatEvent* chat_event);
  ::unhinged::cdc::ChatEvent* unsafe_arena_release_chat_event();

  // .unhinged.cdc.AudioEvent audio_event = 27;
  bool has_audio_event() const;
  private:
  bool _internal_has_audio_event() const;
  public:
  void clear_audio_event();
  const ::unhinged::cdc::AudioEvent& audio_event() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::AudioEvent* release_audio_event();
  ::unhinged::cdc::AudioEvent* mutable_audio_event();
  void set_allocated_audio_event(::unhinged::cdc::AudioEvent* audio_event);
  private:
  const ::unhinged::cdc::AudioEvent& _internal_audio_event() const;
  ::unhinged::cdc::AudioEvent* _internal_mutable_audio_event();
  public:
  void unsafe_arena_set_allocated_audio_event(
      ::unhinged::cdc::AudioEvent* audio_event);
  ::unhinged::cdc::AudioEvent* unsafe_arena_release_audio_event();

  // .unhinged.cdc.UserEvent user_event = 28;
  bool has_user_event() const;
  private:
  bool _internal_has_user_event() const;
  public:
  void clear_user_event();
  const ::unhinged::cdc::UserEvent& user_event() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::UserEvent* release_user_event();
  ::unhinged::cdc::UserEvent* mutable_user_event();
  void set_allocated_user_event(::unhinged::cdc::UserEvent* user_event);
  private:
  const ::unhinged::cdc::UserEvent& _internal_user_event() const;
  ::unhinged::cdc::UserEvent* _internal_mutable_user_event();
  public:
  void unsafe_arena_set_allocated_user_event(
      ::unhinged::cdc::UserEvent* user_event);
  ::unhinged::cdc::UserEvent* unsafe_arena_release_user_event();

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:unhinged.cdc.UniversalEvent)
 private:
  class _Internal;
  void set_has_document_event();
  void set_has_llm_event();
  void set_has_agent_event();
  void set_has_session_event();
  void set_has_system_event();
  void set_has_workflow_event();
  void set_has_chat_event();
  void set_has_audio_event();
  void set_has_user_event();

  inline bool has_payload() const;
  inline void clear_has_payload();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tags_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr event_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr event_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr event_version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_service_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trace_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr correlation_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tenant_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr routing_key_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* event_time_;
    ::PROTOBUF_NAMESPACE_ID::Struct* metadata_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* expires_at_;
    int64_t sequence_number_;
    int32_t retry_count_;
    union PayloadUnion {
      constexpr PayloadUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::unhinged::cdc::DocumentEvent* document_event_;
      ::unhinged::cdc::LLMEvent* llm_event_;
      ::unhinged::cdc::AgentEvent* agent_event_;
      ::unhinged::cdc::SessionEvent* session_event_;
      ::unhinged::cdc::SystemEvent* system_event_;
      ::unhinged::cdc::WorkflowEvent* workflow_event_;
      ::unhinged::cdc::ChatEvent* chat_event_;
      ::unhinged::cdc::AudioEvent* audio_event_;
      ::unhinged::cdc::UserEvent* user_event_;
    } payload_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fevents_2eproto;
};
// -------------------------------------------------------------------

class DocumentEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.DocumentEvent) */ {
 public:
  inline DocumentEvent() : DocumentEvent(nullptr) {}
  ~DocumentEvent() override;
  explicit PROTOBUF_CONSTEXPR DocumentEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DocumentEvent(const DocumentEvent& from);
  DocumentEvent(DocumentEvent&& from) noexcept
    : DocumentEvent() {
    *this = ::std::move(from);
  }

  inline DocumentEvent& operator=(const DocumentEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline DocumentEvent& operator=(DocumentEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DocumentEvent& default_instance() {
    return *internal_default_instance();
  }
  enum EventDataCase {
    kCreated = 10,
    kUpdated = 11,
    kDeleted = 12,
    kAccessed = 13,
    kTagged = 14,
    kVersioned = 15,
    EVENT_DATA_NOT_SET = 0,
  };

  static inline const DocumentEvent* internal_default_instance() {
    return reinterpret_cast<const DocumentEvent*>(
               &_DocumentEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DocumentEvent& a, DocumentEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(DocumentEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DocumentEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DocumentEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DocumentEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DocumentEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DocumentEvent& from) {
    DocumentEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DocumentEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.DocumentEvent";
  }
  protected:
  explicit DocumentEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDocumentUuidFieldNumber = 1,
    kDocumentTypeFieldNumber = 2,
    kNamespaceFieldNumber = 3,
    kVersionFieldNumber = 4,
    kEventTypeFieldNumber = 5,
    kCreatedFieldNumber = 10,
    kUpdatedFieldNumber = 11,
    kDeletedFieldNumber = 12,
    kAccessedFieldNumber = 13,
    kTaggedFieldNumber = 14,
    kVersionedFieldNumber = 15,
  };
  // string document_uuid = 1;
  void clear_document_uuid();
  const std::string& document_uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_document_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_document_uuid();
  PROTOBUF_NODISCARD std::string* release_document_uuid();
  void set_allocated_document_uuid(std::string* document_uuid);
  private:
  const std::string& _internal_document_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_document_uuid(const std::string& value);
  std::string* _internal_mutable_document_uuid();
  public:

  // string document_type = 2;
  void clear_document_type();
  const std::string& document_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_document_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_document_type();
  PROTOBUF_NODISCARD std::string* release_document_type();
  void set_allocated_document_type(std::string* document_type);
  private:
  const std::string& _internal_document_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_document_type(const std::string& value);
  std::string* _internal_mutable_document_type();
  public:

  // string namespace = 3;
  void clear_namespace_();
  const std::string& namespace_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_namespace_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_namespace_();
  PROTOBUF_NODISCARD std::string* release_namespace_();
  void set_allocated_namespace_(std::string* namespace_);
  private:
  const std::string& _internal_namespace_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_namespace_(const std::string& value);
  std::string* _internal_mutable_namespace_();
  public:

  // int32 version = 4;
  void clear_version();
  int32_t version() const;
  void set_version(int32_t value);
  private:
  int32_t _internal_version() const;
  void _internal_set_version(int32_t value);
  public:

  // .unhinged.cdc.DocumentEventType event_type = 5;
  void clear_event_type();
  ::unhinged::cdc::DocumentEventType event_type() const;
  void set_event_type(::unhinged::cdc::DocumentEventType value);
  private:
  ::unhinged::cdc::DocumentEventType _internal_event_type() const;
  void _internal_set_event_type(::unhinged::cdc::DocumentEventType value);
  public:

  // .unhinged.cdc.DocumentCreated created = 10;
  bool has_created() const;
  private:
  bool _internal_has_created() const;
  public:
  void clear_created();
  const ::unhinged::cdc::DocumentCreated& created() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::DocumentCreated* release_created();
  ::unhinged::cdc::DocumentCreated* mutable_created();
  void set_allocated_created(::unhinged::cdc::DocumentCreated* created);
  private:
  const ::unhinged::cdc::DocumentCreated& _internal_created() const;
  ::unhinged::cdc::DocumentCreated* _internal_mutable_created();
  public:
  void unsafe_arena_set_allocated_created(
      ::unhinged::cdc::DocumentCreated* created);
  ::unhinged::cdc::DocumentCreated* unsafe_arena_release_created();

  // .unhinged.cdc.DocumentUpdated updated = 11;
  bool has_updated() const;
  private:
  bool _internal_has_updated() const;
  public:
  void clear_updated();
  const ::unhinged::cdc::DocumentUpdated& updated() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::DocumentUpdated* release_updated();
  ::unhinged::cdc::DocumentUpdated* mutable_updated();
  void set_allocated_updated(::unhinged::cdc::DocumentUpdated* updated);
  private:
  const ::unhinged::cdc::DocumentUpdated& _internal_updated() const;
  ::unhinged::cdc::DocumentUpdated* _internal_mutable_updated();
  public:
  void unsafe_arena_set_allocated_updated(
      ::unhinged::cdc::DocumentUpdated* updated);
  ::unhinged::cdc::DocumentUpdated* unsafe_arena_release_updated();

  // .unhinged.cdc.DocumentDeleted deleted = 12;
  bool has_deleted() const;
  private:
  bool _internal_has_deleted() const;
  public:
  void clear_deleted();
  const ::unhinged::cdc::DocumentDeleted& deleted() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::DocumentDeleted* release_deleted();
  ::unhinged::cdc::DocumentDeleted* mutable_deleted();
  void set_allocated_deleted(::unhinged::cdc::DocumentDeleted* deleted);
  private:
  const ::unhinged::cdc::DocumentDeleted& _internal_deleted() const;
  ::unhinged::cdc::DocumentDeleted* _internal_mutable_deleted();
  public:
  void unsafe_arena_set_allocated_deleted(
      ::unhinged::cdc::DocumentDeleted* deleted);
  ::unhinged::cdc::DocumentDeleted* unsafe_arena_release_deleted();

  // .unhinged.cdc.DocumentAccessed accessed = 13;
  bool has_accessed() const;
  private:
  bool _internal_has_accessed() const;
  public:
  void clear_accessed();
  const ::unhinged::cdc::DocumentAccessed& accessed() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::DocumentAccessed* release_accessed();
  ::unhinged::cdc::DocumentAccessed* mutable_accessed();
  void set_allocated_accessed(::unhinged::cdc::DocumentAccessed* accessed);
  private:
  const ::unhinged::cdc::DocumentAccessed& _internal_accessed() const;
  ::unhinged::cdc::DocumentAccessed* _internal_mutable_accessed();
  public:
  void unsafe_arena_set_allocated_accessed(
      ::unhinged::cdc::DocumentAccessed* accessed);
  ::unhinged::cdc::DocumentAccessed* unsafe_arena_release_accessed();

  // .unhinged.cdc.DocumentTagged tagged = 14;
  bool has_tagged() const;
  private:
  bool _internal_has_tagged() const;
  public:
  void clear_tagged();
  const ::unhinged::cdc::DocumentTagged& tagged() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::DocumentTagged* release_tagged();
  ::unhinged::cdc::DocumentTagged* mutable_tagged();
  void set_allocated_tagged(::unhinged::cdc::DocumentTagged* tagged);
  private:
  const ::unhinged::cdc::DocumentTagged& _internal_tagged() const;
  ::unhinged::cdc::DocumentTagged* _internal_mutable_tagged();
  public:
  void unsafe_arena_set_allocated_tagged(
      ::unhinged::cdc::DocumentTagged* tagged);
  ::unhinged::cdc::DocumentTagged* unsafe_arena_release_tagged();

  // .unhinged.cdc.DocumentVersioned versioned = 15;
  bool has_versioned() const;
  private:
  bool _internal_has_versioned() const;
  public:
  void clear_versioned();
  const ::unhinged::cdc::DocumentVersioned& versioned() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::DocumentVersioned* release_versioned();
  ::unhinged::cdc::DocumentVersioned* mutable_versioned();
  void set_allocated_versioned(::unhinged::cdc::DocumentVersioned* versioned);
  private:
  const ::unhinged::cdc::DocumentVersioned& _internal_versioned() const;
  ::unhinged::cdc::DocumentVersioned* _internal_mutable_versioned();
  public:
  void unsafe_arena_set_allocated_versioned(
      ::unhinged::cdc::DocumentVersioned* versioned);
  ::unhinged::cdc::DocumentVersioned* unsafe_arena_release_versioned();

  void clear_event_data();
  EventDataCase event_data_case() const;
  // @@protoc_insertion_point(class_scope:unhinged.cdc.DocumentEvent)
 private:
  class _Internal;
  void set_has_created();
  void set_has_updated();
  void set_has_deleted();
  void set_has_accessed();
  void set_has_tagged();
  void set_has_versioned();

  inline bool has_event_data() const;
  inline void clear_has_event_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr document_uuid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr document_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr namespace__;
    int32_t version_;
    int event_type_;
    union EventDataUnion {
      constexpr EventDataUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::unhinged::cdc::DocumentCreated* created_;
      ::unhinged::cdc::DocumentUpdated* updated_;
      ::unhinged::cdc::DocumentDeleted* deleted_;
      ::unhinged::cdc::DocumentAccessed* accessed_;
      ::unhinged::cdc::DocumentTagged* tagged_;
      ::unhinged::cdc::DocumentVersioned* versioned_;
    } event_data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fevents_2eproto;
};
// -------------------------------------------------------------------

class DocumentCreated final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.DocumentCreated) */ {
 public:
  inline DocumentCreated() : DocumentCreated(nullptr) {}
  ~DocumentCreated() override;
  explicit PROTOBUF_CONSTEXPR DocumentCreated(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DocumentCreated(const DocumentCreated& from);
  DocumentCreated(DocumentCreated&& from) noexcept
    : DocumentCreated() {
    *this = ::std::move(from);
  }

  inline DocumentCreated& operator=(const DocumentCreated& from) {
    CopyFrom(from);
    return *this;
  }
  inline DocumentCreated& operator=(DocumentCreated&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DocumentCreated& default_instance() {
    return *internal_default_instance();
  }
  static inline const DocumentCreated* internal_default_instance() {
    return reinterpret_cast<const DocumentCreated*>(
               &_DocumentCreated_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DocumentCreated& a, DocumentCreated& b) {
    a.Swap(&b);
  }
  inline void Swap(DocumentCreated* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DocumentCreated* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DocumentCreated* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DocumentCreated>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DocumentCreated& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DocumentCreated& from) {
    DocumentCreated::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DocumentCreated* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.DocumentCreated";
  }
  protected:
  explicit DocumentCreated(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDocumentNameFieldNumber = 1,
    kCreatedByFieldNumber = 2,
    kCreatedByTypeFieldNumber = 3,
    kDocumentMetadataFieldNumber = 4,
    kDocumentSizeBytesFieldNumber = 5,
  };
  // string document_name = 1;
  void clear_document_name();
  const std::string& document_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_document_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_document_name();
  PROTOBUF_NODISCARD std::string* release_document_name();
  void set_allocated_document_name(std::string* document_name);
  private:
  const std::string& _internal_document_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_document_name(const std::string& value);
  std::string* _internal_mutable_document_name();
  public:

  // string created_by = 2;
  void clear_created_by();
  const std::string& created_by() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_created_by(ArgT0&& arg0, ArgT... args);
  std::string* mutable_created_by();
  PROTOBUF_NODISCARD std::string* release_created_by();
  void set_allocated_created_by(std::string* created_by);
  private:
  const std::string& _internal_created_by() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_created_by(const std::string& value);
  std::string* _internal_mutable_created_by();
  public:

  // string created_by_type = 3;
  void clear_created_by_type();
  const std::string& created_by_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_created_by_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_created_by_type();
  PROTOBUF_NODISCARD std::string* release_created_by_type();
  void set_allocated_created_by_type(std::string* created_by_type);
  private:
  const std::string& _internal_created_by_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_created_by_type(const std::string& value);
  std::string* _internal_mutable_created_by_type();
  public:

  // .google.protobuf.Struct document_metadata = 4;
  bool has_document_metadata() const;
  private:
  bool _internal_has_document_metadata() const;
  public:
  void clear_document_metadata();
  const ::PROTOBUF_NAMESPACE_ID::Struct& document_metadata() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_document_metadata();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_document_metadata();
  void set_allocated_document_metadata(::PROTOBUF_NAMESPACE_ID::Struct* document_metadata);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_document_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_document_metadata();
  public:
  void unsafe_arena_set_allocated_document_metadata(
      ::PROTOBUF_NAMESPACE_ID::Struct* document_metadata);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_document_metadata();

  // int64 document_size_bytes = 5;
  void clear_document_size_bytes();
  int64_t document_size_bytes() const;
  void set_document_size_bytes(int64_t value);
  private:
  int64_t _internal_document_size_bytes() const;
  void _internal_set_document_size_bytes(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.cdc.DocumentCreated)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr document_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr created_by_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr created_by_type_;
    ::PROTOBUF_NAMESPACE_ID::Struct* document_metadata_;
    int64_t document_size_bytes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fevents_2eproto;
};
// -------------------------------------------------------------------

class DocumentUpdated final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.DocumentUpdated) */ {
 public:
  inline DocumentUpdated() : DocumentUpdated(nullptr) {}
  ~DocumentUpdated() override;
  explicit PROTOBUF_CONSTEXPR DocumentUpdated(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DocumentUpdated(const DocumentUpdated& from);
  DocumentUpdated(DocumentUpdated&& from) noexcept
    : DocumentUpdated() {
    *this = ::std::move(from);
  }

  inline DocumentUpdated& operator=(const DocumentUpdated& from) {
    CopyFrom(from);
    return *this;
  }
  inline DocumentUpdated& operator=(DocumentUpdated&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DocumentUpdated& default_instance() {
    return *internal_default_instance();
  }
  static inline const DocumentUpdated* internal_default_instance() {
    return reinterpret_cast<const DocumentUpdated*>(
               &_DocumentUpdated_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(DocumentUpdated& a, DocumentUpdated& b) {
    a.Swap(&b);
  }
  inline void Swap(DocumentUpdated* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DocumentUpdated* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DocumentUpdated* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DocumentUpdated>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DocumentUpdated& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DocumentUpdated& from) {
    DocumentUpdated::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DocumentUpdated* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.DocumentUpdated";
  }
  protected:
  explicit DocumentUpdated(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChangedFieldsFieldNumber = 4,
    kUpdatedByFieldNumber = 2,
    kUpdatedByTypeFieldNumber = 3,
    kChangesFieldNumber = 5,
    kPreviousVersionFieldNumber = 1,
  };
  // repeated string changed_fields = 4;
  int changed_fields_size() const;
  private:
  int _internal_changed_fields_size() const;
  public:
  void clear_changed_fields();
  const std::string& changed_fields(int index) const;
  std::string* mutable_changed_fields(int index);
  void set_changed_fields(int index, const std::string& value);
  void set_changed_fields(int index, std::string&& value);
  void set_changed_fields(int index, const char* value);
  void set_changed_fields(int index, const char* value, size_t size);
  std::string* add_changed_fields();
  void add_changed_fields(const std::string& value);
  void add_changed_fields(std::string&& value);
  void add_changed_fields(const char* value);
  void add_changed_fields(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& changed_fields() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_changed_fields();
  private:
  const std::string& _internal_changed_fields(int index) const;
  std::string* _internal_add_changed_fields();
  public:

  // string updated_by = 2;
  void clear_updated_by();
  const std::string& updated_by() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_updated_by(ArgT0&& arg0, ArgT... args);
  std::string* mutable_updated_by();
  PROTOBUF_NODISCARD std::string* release_updated_by();
  void set_allocated_updated_by(std::string* updated_by);
  private:
  const std::string& _internal_updated_by() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_updated_by(const std::string& value);
  std::string* _internal_mutable_updated_by();
  public:

  // string updated_by_type = 3;
  void clear_updated_by_type();
  const std::string& updated_by_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_updated_by_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_updated_by_type();
  PROTOBUF_NODISCARD std::string* release_updated_by_type();
  void set_allocated_updated_by_type(std::string* updated_by_type);
  private:
  const std::string& _internal_updated_by_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_updated_by_type(const std::string& value);
  std::string* _internal_mutable_updated_by_type();
  public:

  // .google.protobuf.Struct changes = 5;
  bool has_changes() const;
  private:
  bool _internal_has_changes() const;
  public:
  void clear_changes();
  const ::PROTOBUF_NAMESPACE_ID::Struct& changes() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_changes();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_changes();
  void set_allocated_changes(::PROTOBUF_NAMESPACE_ID::Struct* changes);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_changes() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_changes();
  public:
  void unsafe_arena_set_allocated_changes(
      ::PROTOBUF_NAMESPACE_ID::Struct* changes);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_changes();

  // int32 previous_version = 1;
  void clear_previous_version();
  int32_t previous_version() const;
  void set_previous_version(int32_t value);
  private:
  int32_t _internal_previous_version() const;
  void _internal_set_previous_version(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.cdc.DocumentUpdated)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> changed_fields_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr updated_by_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr updated_by_type_;
    ::PROTOBUF_NAMESPACE_ID::Struct* changes_;
    int32_t previous_version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fevents_2eproto;
};
// -------------------------------------------------------------------

class DocumentDeleted final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.DocumentDeleted) */ {
 public:
  inline DocumentDeleted() : DocumentDeleted(nullptr) {}
  ~DocumentDeleted() override;
  explicit PROTOBUF_CONSTEXPR DocumentDeleted(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DocumentDeleted(const DocumentDeleted& from);
  DocumentDeleted(DocumentDeleted&& from) noexcept
    : DocumentDeleted() {
    *this = ::std::move(from);
  }

  inline DocumentDeleted& operator=(const DocumentDeleted& from) {
    CopyFrom(from);
    return *this;
  }
  inline DocumentDeleted& operator=(DocumentDeleted&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DocumentDeleted& default_instance() {
    return *internal_default_instance();
  }
  static inline const DocumentDeleted* internal_default_instance() {
    return reinterpret_cast<const DocumentDeleted*>(
               &_DocumentDeleted_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(DocumentDeleted& a, DocumentDeleted& b) {
    a.Swap(&b);
  }
  inline void Swap(DocumentDeleted* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DocumentDeleted* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DocumentDeleted* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DocumentDeleted>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DocumentDeleted& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DocumentDeleted& from) {
    DocumentDeleted::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DocumentDeleted* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.DocumentDeleted";
  }
  protected:
  explicit DocumentDeleted(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeletedByFieldNumber = 1,
    kDeletedByTypeFieldNumber = 2,
    kDeletionReasonFieldNumber = 4,
    kVersionsDeletedFieldNumber = 3,
  };
  // string deleted_by = 1;
  void clear_deleted_by();
  const std::string& deleted_by() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_deleted_by(ArgT0&& arg0, ArgT... args);
  std::string* mutable_deleted_by();
  PROTOBUF_NODISCARD std::string* release_deleted_by();
  void set_allocated_deleted_by(std::string* deleted_by);
  private:
  const std::string& _internal_deleted_by() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_deleted_by(const std::string& value);
  std::string* _internal_mutable_deleted_by();
  public:

  // string deleted_by_type = 2;
  void clear_deleted_by_type();
  const std::string& deleted_by_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_deleted_by_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_deleted_by_type();
  PROTOBUF_NODISCARD std::string* release_deleted_by_type();
  void set_allocated_deleted_by_type(std::string* deleted_by_type);
  private:
  const std::string& _internal_deleted_by_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_deleted_by_type(const std::string& value);
  std::string* _internal_mutable_deleted_by_type();
  public:

  // string deletion_reason = 4;
  void clear_deletion_reason();
  const std::string& deletion_reason() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_deletion_reason(ArgT0&& arg0, ArgT... args);
  std::string* mutable_deletion_reason();
  PROTOBUF_NODISCARD std::string* release_deletion_reason();
  void set_allocated_deletion_reason(std::string* deletion_reason);
  private:
  const std::string& _internal_deletion_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_deletion_reason(const std::string& value);
  std::string* _internal_mutable_deletion_reason();
  public:

  // int32 versions_deleted = 3;
  void clear_versions_deleted();
  int32_t versions_deleted() const;
  void set_versions_deleted(int32_t value);
  private:
  int32_t _internal_versions_deleted() const;
  void _internal_set_versions_deleted(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.cdc.DocumentDeleted)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deleted_by_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deleted_by_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deletion_reason_;
    int32_t versions_deleted_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fevents_2eproto;
};
// -------------------------------------------------------------------

class DocumentAccessed final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.DocumentAccessed) */ {
 public:
  inline DocumentAccessed() : DocumentAccessed(nullptr) {}
  ~DocumentAccessed() override;
  explicit PROTOBUF_CONSTEXPR DocumentAccessed(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DocumentAccessed(const DocumentAccessed& from);
  DocumentAccessed(DocumentAccessed&& from) noexcept
    : DocumentAccessed() {
    *this = ::std::move(from);
  }

  inline DocumentAccessed& operator=(const DocumentAccessed& from) {
    CopyFrom(from);
    return *this;
  }
  inline DocumentAccessed& operator=(DocumentAccessed&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DocumentAccessed& default_instance() {
    return *internal_default_instance();
  }
  static inline const DocumentAccessed* internal_default_instance() {
    return reinterpret_cast<const DocumentAccessed*>(
               &_DocumentAccessed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(DocumentAccessed& a, DocumentAccessed& b) {
    a.Swap(&b);
  }
  inline void Swap(DocumentAccessed* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DocumentAccessed* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DocumentAccessed* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DocumentAccessed>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DocumentAccessed& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DocumentAccessed& from) {
    DocumentAccessed::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DocumentAccessed* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.DocumentAccessed";
  }
  protected:
  explicit DocumentAccessed(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccessedByFieldNumber = 1,
    kAccessedByTypeFieldNumber = 2,
    kAccessMethodFieldNumber = 3,
    kBodyIncludedFieldNumber = 4,
  };
  // string accessed_by = 1;
  void clear_accessed_by();
  const std::string& accessed_by() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_accessed_by(ArgT0&& arg0, ArgT... args);
  std::string* mutable_accessed_by();
  PROTOBUF_NODISCARD std::string* release_accessed_by();
  void set_allocated_accessed_by(std::string* accessed_by);
  private:
  const std::string& _internal_accessed_by() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_accessed_by(const std::string& value);
  std::string* _internal_mutable_accessed_by();
  public:

  // string accessed_by_type = 2;
  void clear_accessed_by_type();
  const std::string& accessed_by_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_accessed_by_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_accessed_by_type();
  PROTOBUF_NODISCARD std::string* release_accessed_by_type();
  void set_allocated_accessed_by_type(std::string* accessed_by_type);
  private:
  const std::string& _internal_accessed_by_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_accessed_by_type(const std::string& value);
  std::string* _internal_mutable_accessed_by_type();
  public:

  // string access_method = 3;
  void clear_access_method();
  const std::string& access_method() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_access_method(ArgT0&& arg0, ArgT... args);
  std::string* mutable_access_method();
  PROTOBUF_NODISCARD std::string* release_access_method();
  void set_allocated_access_method(std::string* access_method);
  private:
  const std::string& _internal_access_method() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_access_method(const std::string& value);
  std::string* _internal_mutable_access_method();
  public:

  // bool body_included = 4;
  void clear_body_included();
  bool body_included() const;
  void set_body_included(bool value);
  private:
  bool _internal_body_included() const;
  void _internal_set_body_included(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.cdc.DocumentAccessed)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr accessed_by_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr accessed_by_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr access_method_;
    bool body_included_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fevents_2eproto;
};
// -------------------------------------------------------------------

class DocumentTagged final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.DocumentTagged) */ {
 public:
  inline DocumentTagged() : DocumentTagged(nullptr) {}
  ~DocumentTagged() override;
  explicit PROTOBUF_CONSTEXPR DocumentTagged(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DocumentTagged(const DocumentTagged& from);
  DocumentTagged(DocumentTagged&& from) noexcept
    : DocumentTagged() {
    *this = ::std::move(from);
  }

  inline DocumentTagged& operator=(const DocumentTagged& from) {
    CopyFrom(from);
    return *this;
  }
  inline DocumentTagged& operator=(DocumentTagged&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DocumentTagged& default_instance() {
    return *internal_default_instance();
  }
  static inline const DocumentTagged* internal_default_instance() {
    return reinterpret_cast<const DocumentTagged*>(
               &_DocumentTagged_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(DocumentTagged& a, DocumentTagged& b) {
    a.Swap(&b);
  }
  inline void Swap(DocumentTagged* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DocumentTagged* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DocumentTagged* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DocumentTagged>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DocumentTagged& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DocumentTagged& from) {
    DocumentTagged::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DocumentTagged* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.DocumentTagged";
  }
  protected:
  explicit DocumentTagged(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagFieldNumber = 1,
    kTaggedByFieldNumber = 2,
    kTaggedByTypeFieldNumber = 3,
    kTagOperationFieldNumber = 4,
  };
  // string tag = 1;
  void clear_tag();
  const std::string& tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tag();
  PROTOBUF_NODISCARD std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  private:
  const std::string& _internal_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  // string tagged_by = 2;
  void clear_tagged_by();
  const std::string& tagged_by() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tagged_by(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tagged_by();
  PROTOBUF_NODISCARD std::string* release_tagged_by();
  void set_allocated_tagged_by(std::string* tagged_by);
  private:
  const std::string& _internal_tagged_by() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tagged_by(const std::string& value);
  std::string* _internal_mutable_tagged_by();
  public:

  // string tagged_by_type = 3;
  void clear_tagged_by_type();
  const std::string& tagged_by_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tagged_by_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tagged_by_type();
  PROTOBUF_NODISCARD std::string* release_tagged_by_type();
  void set_allocated_tagged_by_type(std::string* tagged_by_type);
  private:
  const std::string& _internal_tagged_by_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tagged_by_type(const std::string& value);
  std::string* _internal_mutable_tagged_by_type();
  public:

  // string tag_operation = 4;
  void clear_tag_operation();
  const std::string& tag_operation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tag_operation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tag_operation();
  PROTOBUF_NODISCARD std::string* release_tag_operation();
  void set_allocated_tag_operation(std::string* tag_operation);
  private:
  const std::string& _internal_tag_operation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tag_operation(const std::string& value);
  std::string* _internal_mutable_tag_operation();
  public:

  // @@protoc_insertion_point(class_scope:unhinged.cdc.DocumentTagged)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tagged_by_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tagged_by_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_operation_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fevents_2eproto;
};
// -------------------------------------------------------------------

class DocumentVersioned final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.DocumentVersioned) */ {
 public:
  inline DocumentVersioned() : DocumentVersioned(nullptr) {}
  ~DocumentVersioned() override;
  explicit PROTOBUF_CONSTEXPR DocumentVersioned(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DocumentVersioned(const DocumentVersioned& from);
  DocumentVersioned(DocumentVersioned&& from) noexcept
    : DocumentVersioned() {
    *this = ::std::move(from);
  }

  inline DocumentVersioned& operator=(const DocumentVersioned& from) {
    CopyFrom(from);
    return *this;
  }
  inline DocumentVersioned& operator=(DocumentVersioned&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DocumentVersioned& default_instance() {
    return *internal_default_instance();
  }
  static inline const DocumentVersioned* internal_default_instance() {
    return reinterpret_cast<const DocumentVersioned*>(
               &_DocumentVersioned_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(DocumentVersioned& a, DocumentVersioned& b) {
    a.Swap(&b);
  }
  inline void Swap(DocumentVersioned* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DocumentVersioned* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DocumentVersioned* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DocumentVersioned>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DocumentVersioned& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DocumentVersioned& from) {
    DocumentVersioned::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DocumentVersioned* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.DocumentVersioned";
  }
  protected:
  explicit DocumentVersioned(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionReasonFieldNumber = 3,
    kNewVersionFieldNumber = 1,
    kPreviousVersionFieldNumber = 2,
  };
  // string version_reason = 3;
  void clear_version_reason();
  const std::string& version_reason() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version_reason(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version_reason();
  PROTOBUF_NODISCARD std::string* release_version_reason();
  void set_allocated_version_reason(std::string* version_reason);
  private:
  const std::string& _internal_version_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version_reason(const std::string& value);
  std::string* _internal_mutable_version_reason();
  public:

  // int32 new_version = 1;
  void clear_new_version();
  int32_t new_version() const;
  void set_new_version(int32_t value);
  private:
  int32_t _internal_new_version() const;
  void _internal_set_new_version(int32_t value);
  public:

  // int32 previous_version = 2;
  void clear_previous_version();
  int32_t previous_version() const;
  void set_previous_version(int32_t value);
  private:
  int32_t _internal_previous_version() const;
  void _internal_set_previous_version(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.cdc.DocumentVersioned)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_reason_;
    int32_t new_version_;
    int32_t previous_version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fevents_2eproto;
};
// -------------------------------------------------------------------

class LLMEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.LLMEvent) */ {
 public:
  inline LLMEvent() : LLMEvent(nullptr) {}
  ~LLMEvent() override;
  explicit PROTOBUF_CONSTEXPR LLMEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LLMEvent(const LLMEvent& from);
  LLMEvent(LLMEvent&& from) noexcept
    : LLMEvent() {
    *this = ::std::move(from);
  }

  inline LLMEvent& operator=(const LLMEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline LLMEvent& operator=(LLMEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LLMEvent& default_instance() {
    return *internal_default_instance();
  }
  enum EventDataCase {
    kPromptSent = 10,
    kResponseReceived = 11,
    kLlmError = 12,
    kFeedback = 13,
    kTokenUsage = 14,
    EVENT_DATA_NOT_SET = 0,
  };

  static inline const LLMEvent* internal_default_instance() {
    return reinterpret_cast<const LLMEvent*>(
               &_LLMEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(LLMEvent& a, LLMEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(LLMEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LLMEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LLMEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LLMEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LLMEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LLMEvent& from) {
    LLMEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LLMEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.LLMEvent";
  }
  protected:
  explicit LLMEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInteractionIdFieldNumber = 1,
    kModelNameFieldNumber = 2,
    kProviderFieldNumber = 3,
    kEventTypeFieldNumber = 4,
    kPromptSentFieldNumber = 10,
    kResponseReceivedFieldNumber = 11,
    kLlmErrorFieldNumber = 12,
    kFeedbackFieldNumber = 13,
    kTokenUsageFieldNumber = 14,
  };
  // string interaction_id = 1;
  void clear_interaction_id();
  const std::string& interaction_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_interaction_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_interaction_id();
  PROTOBUF_NODISCARD std::string* release_interaction_id();
  void set_allocated_interaction_id(std::string* interaction_id);
  private:
  const std::string& _internal_interaction_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_interaction_id(const std::string& value);
  std::string* _internal_mutable_interaction_id();
  public:

  // string model_name = 2;
  void clear_model_name();
  const std::string& model_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_name();
  PROTOBUF_NODISCARD std::string* release_model_name();
  void set_allocated_model_name(std::string* model_name);
  private:
  const std::string& _internal_model_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_name(const std::string& value);
  std::string* _internal_mutable_model_name();
  public:

  // string provider = 3;
  void clear_provider();
  const std::string& provider() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_provider(ArgT0&& arg0, ArgT... args);
  std::string* mutable_provider();
  PROTOBUF_NODISCARD std::string* release_provider();
  void set_allocated_provider(std::string* provider);
  private:
  const std::string& _internal_provider() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_provider(const std::string& value);
  std::string* _internal_mutable_provider();
  public:

  // .unhinged.cdc.LLMEventType event_type = 4;
  void clear_event_type();
  ::unhinged::cdc::LLMEventType event_type() const;
  void set_event_type(::unhinged::cdc::LLMEventType value);
  private:
  ::unhinged::cdc::LLMEventType _internal_event_type() const;
  void _internal_set_event_type(::unhinged::cdc::LLMEventType value);
  public:

  // .unhinged.cdc.LLMPromptSent prompt_sent = 10;
  bool has_prompt_sent() const;
  private:
  bool _internal_has_prompt_sent() const;
  public:
  void clear_prompt_sent();
  const ::unhinged::cdc::LLMPromptSent& prompt_sent() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::LLMPromptSent* release_prompt_sent();
  ::unhinged::cdc::LLMPromptSent* mutable_prompt_sent();
  void set_allocated_prompt_sent(::unhinged::cdc::LLMPromptSent* prompt_sent);
  private:
  const ::unhinged::cdc::LLMPromptSent& _internal_prompt_sent() const;
  ::unhinged::cdc::LLMPromptSent* _internal_mutable_prompt_sent();
  public:
  void unsafe_arena_set_allocated_prompt_sent(
      ::unhinged::cdc::LLMPromptSent* prompt_sent);
  ::unhinged::cdc::LLMPromptSent* unsafe_arena_release_prompt_sent();

  // .unhinged.cdc.LLMResponseReceived response_received = 11;
  bool has_response_received() const;
  private:
  bool _internal_has_response_received() const;
  public:
  void clear_response_received();
  const ::unhinged::cdc::LLMResponseReceived& response_received() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::LLMResponseReceived* release_response_received();
  ::unhinged::cdc::LLMResponseReceived* mutable_response_received();
  void set_allocated_response_received(::unhinged::cdc::LLMResponseReceived* response_received);
  private:
  const ::unhinged::cdc::LLMResponseReceived& _internal_response_received() const;
  ::unhinged::cdc::LLMResponseReceived* _internal_mutable_response_received();
  public:
  void unsafe_arena_set_allocated_response_received(
      ::unhinged::cdc::LLMResponseReceived* response_received);
  ::unhinged::cdc::LLMResponseReceived* unsafe_arena_release_response_received();

  // .unhinged.cdc.LLMError llm_error = 12;
  bool has_llm_error() const;
  private:
  bool _internal_has_llm_error() const;
  public:
  void clear_llm_error();
  const ::unhinged::cdc::LLMError& llm_error() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::LLMError* release_llm_error();
  ::unhinged::cdc::LLMError* mutable_llm_error();
  void set_allocated_llm_error(::unhinged::cdc::LLMError* llm_error);
  private:
  const ::unhinged::cdc::LLMError& _internal_llm_error() const;
  ::unhinged::cdc::LLMError* _internal_mutable_llm_error();
  public:
  void unsafe_arena_set_allocated_llm_error(
      ::unhinged::cdc::LLMError* llm_error);
  ::unhinged::cdc::LLMError* unsafe_arena_release_llm_error();

  // .unhinged.cdc.LLMFeedback feedback = 13;
  bool has_feedback() const;
  private:
  bool _internal_has_feedback() const;
  public:
  void clear_feedback();
  const ::unhinged::cdc::LLMFeedback& feedback() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::LLMFeedback* release_feedback();
  ::unhinged::cdc::LLMFeedback* mutable_feedback();
  void set_allocated_feedback(::unhinged::cdc::LLMFeedback* feedback);
  private:
  const ::unhinged::cdc::LLMFeedback& _internal_feedback() const;
  ::unhinged::cdc::LLMFeedback* _internal_mutable_feedback();
  public:
  void unsafe_arena_set_allocated_feedback(
      ::unhinged::cdc::LLMFeedback* feedback);
  ::unhinged::cdc::LLMFeedback* unsafe_arena_release_feedback();

  // .unhinged.cdc.LLMTokenUsage token_usage = 14;
  bool has_token_usage() const;
  private:
  bool _internal_has_token_usage() const;
  public:
  void clear_token_usage();
  const ::unhinged::cdc::LLMTokenUsage& token_usage() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::LLMTokenUsage* release_token_usage();
  ::unhinged::cdc::LLMTokenUsage* mutable_token_usage();
  void set_allocated_token_usage(::unhinged::cdc::LLMTokenUsage* token_usage);
  private:
  const ::unhinged::cdc::LLMTokenUsage& _internal_token_usage() const;
  ::unhinged::cdc::LLMTokenUsage* _internal_mutable_token_usage();
  public:
  void unsafe_arena_set_allocated_token_usage(
      ::unhinged::cdc::LLMTokenUsage* token_usage);
  ::unhinged::cdc::LLMTokenUsage* unsafe_arena_release_token_usage();

  void clear_event_data();
  EventDataCase event_data_case() const;
  // @@protoc_insertion_point(class_scope:unhinged.cdc.LLMEvent)
 private:
  class _Internal;
  void set_has_prompt_sent();
  void set_has_response_received();
  void set_has_llm_error();
  void set_has_feedback();
  void set_has_token_usage();

  inline bool has_event_data() const;
  inline void clear_has_event_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr interaction_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr provider_;
    int event_type_;
    union EventDataUnion {
      constexpr EventDataUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::unhinged::cdc::LLMPromptSent* prompt_sent_;
      ::unhinged::cdc::LLMResponseReceived* response_received_;
      ::unhinged::cdc::LLMError* llm_error_;
      ::unhinged::cdc::LLMFeedback* feedback_;
      ::unhinged::cdc::LLMTokenUsage* token_usage_;
    } event_data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fevents_2eproto;
};
// -------------------------------------------------------------------

class LLMPromptSent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.LLMPromptSent) */ {
 public:
  inline LLMPromptSent() : LLMPromptSent(nullptr) {}
  ~LLMPromptSent() override;
  explicit PROTOBUF_CONSTEXPR LLMPromptSent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LLMPromptSent(const LLMPromptSent& from);
  LLMPromptSent(LLMPromptSent&& from) noexcept
    : LLMPromptSent() {
    *this = ::std::move(from);
  }

  inline LLMPromptSent& operator=(const LLMPromptSent& from) {
    CopyFrom(from);
    return *this;
  }
  inline LLMPromptSent& operator=(LLMPromptSent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LLMPromptSent& default_instance() {
    return *internal_default_instance();
  }
  static inline const LLMPromptSent* internal_default_instance() {
    return reinterpret_cast<const LLMPromptSent*>(
               &_LLMPromptSent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(LLMPromptSent& a, LLMPromptSent& b) {
    a.Swap(&b);
  }
  inline void Swap(LLMPromptSent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LLMPromptSent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LLMPromptSent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LLMPromptSent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LLMPromptSent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LLMPromptSent& from) {
    LLMPromptSent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LLMPromptSent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.LLMPromptSent";
  }
  protected:
  explicit LLMPromptSent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContextDocumentIdsFieldNumber = 3,
    kPromptTextFieldNumber = 1,
    kPromptParametersFieldNumber = 2,
    kMaxTokensFieldNumber = 4,
    kTemperatureFieldNumber = 5,
  };
  // repeated string context_document_ids = 3;
  int context_document_ids_size() const;
  private:
  int _internal_context_document_ids_size() const;
  public:
  void clear_context_document_ids();
  const std::string& context_document_ids(int index) const;
  std::string* mutable_context_document_ids(int index);
  void set_context_document_ids(int index, const std::string& value);
  void set_context_document_ids(int index, std::string&& value);
  void set_context_document_ids(int index, const char* value);
  void set_context_document_ids(int index, const char* value, size_t size);
  std::string* add_context_document_ids();
  void add_context_document_ids(const std::string& value);
  void add_context_document_ids(std::string&& value);
  void add_context_document_ids(const char* value);
  void add_context_document_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& context_document_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_context_document_ids();
  private:
  const std::string& _internal_context_document_ids(int index) const;
  std::string* _internal_add_context_document_ids();
  public:

  // string prompt_text = 1;
  void clear_prompt_text();
  const std::string& prompt_text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_prompt_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_prompt_text();
  PROTOBUF_NODISCARD std::string* release_prompt_text();
  void set_allocated_prompt_text(std::string* prompt_text);
  private:
  const std::string& _internal_prompt_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_prompt_text(const std::string& value);
  std::string* _internal_mutable_prompt_text();
  public:

  // .google.protobuf.Struct prompt_parameters = 2;
  bool has_prompt_parameters() const;
  private:
  bool _internal_has_prompt_parameters() const;
  public:
  void clear_prompt_parameters();
  const ::PROTOBUF_NAMESPACE_ID::Struct& prompt_parameters() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_prompt_parameters();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_prompt_parameters();
  void set_allocated_prompt_parameters(::PROTOBUF_NAMESPACE_ID::Struct* prompt_parameters);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_prompt_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_prompt_parameters();
  public:
  void unsafe_arena_set_allocated_prompt_parameters(
      ::PROTOBUF_NAMESPACE_ID::Struct* prompt_parameters);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_prompt_parameters();

  // int32 max_tokens = 4;
  void clear_max_tokens();
  int32_t max_tokens() const;
  void set_max_tokens(int32_t value);
  private:
  int32_t _internal_max_tokens() const;
  void _internal_set_max_tokens(int32_t value);
  public:

  // float temperature = 5;
  void clear_temperature();
  float temperature() const;
  void set_temperature(float value);
  private:
  float _internal_temperature() const;
  void _internal_set_temperature(float value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.cdc.LLMPromptSent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> context_document_ids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr prompt_text_;
    ::PROTOBUF_NAMESPACE_ID::Struct* prompt_parameters_;
    int32_t max_tokens_;
    float temperature_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fevents_2eproto;
};
// -------------------------------------------------------------------

class LLMResponseReceived final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.LLMResponseReceived) */ {
 public:
  inline LLMResponseReceived() : LLMResponseReceived(nullptr) {}
  ~LLMResponseReceived() override;
  explicit PROTOBUF_CONSTEXPR LLMResponseReceived(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LLMResponseReceived(const LLMResponseReceived& from);
  LLMResponseReceived(LLMResponseReceived&& from) noexcept
    : LLMResponseReceived() {
    *this = ::std::move(from);
  }

  inline LLMResponseReceived& operator=(const LLMResponseReceived& from) {
    CopyFrom(from);
    return *this;
  }
  inline LLMResponseReceived& operator=(LLMResponseReceived&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LLMResponseReceived& default_instance() {
    return *internal_default_instance();
  }
  static inline const LLMResponseReceived* internal_default_instance() {
    return reinterpret_cast<const LLMResponseReceived*>(
               &_LLMResponseReceived_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(LLMResponseReceived& a, LLMResponseReceived& b) {
    a.Swap(&b);
  }
  inline void Swap(LLMResponseReceived* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LLMResponseReceived* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LLMResponseReceived* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LLMResponseReceived>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LLMResponseReceived& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LLMResponseReceived& from) {
    LLMResponseReceived::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LLMResponseReceived* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.LLMResponseReceived";
  }
  protected:
  explicit LLMResponseReceived(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseTextFieldNumber = 1,
    kFinishReasonFieldNumber = 2,
    kResponseMetadataFieldNumber = 5,
    kResponseTokensFieldNumber = 3,
    kResponseTimeMsFieldNumber = 4,
  };
  // string response_text = 1;
  void clear_response_text();
  const std::string& response_text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_response_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_response_text();
  PROTOBUF_NODISCARD std::string* release_response_text();
  void set_allocated_response_text(std::string* response_text);
  private:
  const std::string& _internal_response_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_response_text(const std::string& value);
  std::string* _internal_mutable_response_text();
  public:

  // string finish_reason = 2;
  void clear_finish_reason();
  const std::string& finish_reason() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_finish_reason(ArgT0&& arg0, ArgT... args);
  std::string* mutable_finish_reason();
  PROTOBUF_NODISCARD std::string* release_finish_reason();
  void set_allocated_finish_reason(std::string* finish_reason);
  private:
  const std::string& _internal_finish_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_finish_reason(const std::string& value);
  std::string* _internal_mutable_finish_reason();
  public:

  // .google.protobuf.Struct response_metadata = 5;
  bool has_response_metadata() const;
  private:
  bool _internal_has_response_metadata() const;
  public:
  void clear_response_metadata();
  const ::PROTOBUF_NAMESPACE_ID::Struct& response_metadata() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_response_metadata();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_response_metadata();
  void set_allocated_response_metadata(::PROTOBUF_NAMESPACE_ID::Struct* response_metadata);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_response_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_response_metadata();
  public:
  void unsafe_arena_set_allocated_response_metadata(
      ::PROTOBUF_NAMESPACE_ID::Struct* response_metadata);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_response_metadata();

  // int32 response_tokens = 3;
  void clear_response_tokens();
  int32_t response_tokens() const;
  void set_response_tokens(int32_t value);
  private:
  int32_t _internal_response_tokens() const;
  void _internal_set_response_tokens(int32_t value);
  public:

  // float response_time_ms = 4;
  void clear_response_time_ms();
  float response_time_ms() const;
  void set_response_time_ms(float value);
  private:
  float _internal_response_time_ms() const;
  void _internal_set_response_time_ms(float value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.cdc.LLMResponseReceived)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr response_text_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr finish_reason_;
    ::PROTOBUF_NAMESPACE_ID::Struct* response_metadata_;
    int32_t response_tokens_;
    float response_time_ms_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fevents_2eproto;
};
// -------------------------------------------------------------------

class LLMError final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.LLMError) */ {
 public:
  inline LLMError() : LLMError(nullptr) {}
  ~LLMError() override;
  explicit PROTOBUF_CONSTEXPR LLMError(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LLMError(const LLMError& from);
  LLMError(LLMError&& from) noexcept
    : LLMError() {
    *this = ::std::move(from);
  }

  inline LLMError& operator=(const LLMError& from) {
    CopyFrom(from);
    return *this;
  }
  inline LLMError& operator=(LLMError&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LLMError& default_instance() {
    return *internal_default_instance();
  }
  static inline const LLMError* internal_default_instance() {
    return reinterpret_cast<const LLMError*>(
               &_LLMError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(LLMError& a, LLMError& b) {
    a.Swap(&b);
  }
  inline void Swap(LLMError* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LLMError* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LLMError* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LLMError>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LLMError& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LLMError& from) {
    LLMError::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LLMError* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.LLMError";
  }
  protected:
  explicit LLMError(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorCodeFieldNumber = 1,
    kErrorMessageFieldNumber = 2,
    kErrorTypeFieldNumber = 3,
    kIsRetryableFieldNumber = 4,
  };
  // string error_code = 1;
  void clear_error_code();
  const std::string& error_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_code();
  PROTOBUF_NODISCARD std::string* release_error_code();
  void set_allocated_error_code(std::string* error_code);
  private:
  const std::string& _internal_error_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_code(const std::string& value);
  std::string* _internal_mutable_error_code();
  public:

  // string error_message = 2;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // string error_type = 3;
  void clear_error_type();
  const std::string& error_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_type();
  PROTOBUF_NODISCARD std::string* release_error_type();
  void set_allocated_error_type(std::string* error_type);
  private:
  const std::string& _internal_error_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_type(const std::string& value);
  std::string* _internal_mutable_error_type();
  public:

  // bool is_retryable = 4;
  void clear_is_retryable();
  bool is_retryable() const;
  void set_is_retryable(bool value);
  private:
  bool _internal_is_retryable() const;
  void _internal_set_is_retryable(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.cdc.LLMError)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_code_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_type_;
    bool is_retryable_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fevents_2eproto;
};
// -------------------------------------------------------------------

class LLMFeedback final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.LLMFeedback) */ {
 public:
  inline LLMFeedback() : LLMFeedback(nullptr) {}
  ~LLMFeedback() override;
  explicit PROTOBUF_CONSTEXPR LLMFeedback(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LLMFeedback(const LLMFeedback& from);
  LLMFeedback(LLMFeedback&& from) noexcept
    : LLMFeedback() {
    *this = ::std::move(from);
  }

  inline LLMFeedback& operator=(const LLMFeedback& from) {
    CopyFrom(from);
    return *this;
  }
  inline LLMFeedback& operator=(LLMFeedback&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LLMFeedback& default_instance() {
    return *internal_default_instance();
  }
  static inline const LLMFeedback* internal_default_instance() {
    return reinterpret_cast<const LLMFeedback*>(
               &_LLMFeedback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(LLMFeedback& a, LLMFeedback& b) {
    a.Swap(&b);
  }
  inline void Swap(LLMFeedback* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LLMFeedback* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LLMFeedback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LLMFeedback>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LLMFeedback& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LLMFeedback& from) {
    LLMFeedback::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LLMFeedback* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.LLMFeedback";
  }
  protected:
  explicit LLMFeedback(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFeedbackTypeFieldNumber = 1,
    kFeedbackValueFieldNumber = 2,
    kFeedbackTextFieldNumber = 3,
    kProvidedByFieldNumber = 4,
  };
  // string feedback_type = 1;
  void clear_feedback_type();
  const std::string& feedback_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_feedback_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_feedback_type();
  PROTOBUF_NODISCARD std::string* release_feedback_type();
  void set_allocated_feedback_type(std::string* feedback_type);
  private:
  const std::string& _internal_feedback_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_feedback_type(const std::string& value);
  std::string* _internal_mutable_feedback_type();
  public:

  // string feedback_value = 2;
  void clear_feedback_value();
  const std::string& feedback_value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_feedback_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_feedback_value();
  PROTOBUF_NODISCARD std::string* release_feedback_value();
  void set_allocated_feedback_value(std::string* feedback_value);
  private:
  const std::string& _internal_feedback_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_feedback_value(const std::string& value);
  std::string* _internal_mutable_feedback_value();
  public:

  // string feedback_text = 3;
  void clear_feedback_text();
  const std::string& feedback_text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_feedback_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_feedback_text();
  PROTOBUF_NODISCARD std::string* release_feedback_text();
  void set_allocated_feedback_text(std::string* feedback_text);
  private:
  const std::string& _internal_feedback_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_feedback_text(const std::string& value);
  std::string* _internal_mutable_feedback_text();
  public:

  // string provided_by = 4;
  void clear_provided_by();
  const std::string& provided_by() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_provided_by(ArgT0&& arg0, ArgT... args);
  std::string* mutable_provided_by();
  PROTOBUF_NODISCARD std::string* release_provided_by();
  void set_allocated_provided_by(std::string* provided_by);
  private:
  const std::string& _internal_provided_by() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_provided_by(const std::string& value);
  std::string* _internal_mutable_provided_by();
  public:

  // @@protoc_insertion_point(class_scope:unhinged.cdc.LLMFeedback)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr feedback_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr feedback_value_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr feedback_text_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr provided_by_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fevents_2eproto;
};
// -------------------------------------------------------------------

class LLMTokenUsage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.LLMTokenUsage) */ {
 public:
  inline LLMTokenUsage() : LLMTokenUsage(nullptr) {}
  ~LLMTokenUsage() override;
  explicit PROTOBUF_CONSTEXPR LLMTokenUsage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LLMTokenUsage(const LLMTokenUsage& from);
  LLMTokenUsage(LLMTokenUsage&& from) noexcept
    : LLMTokenUsage() {
    *this = ::std::move(from);
  }

  inline LLMTokenUsage& operator=(const LLMTokenUsage& from) {
    CopyFrom(from);
    return *this;
  }
  inline LLMTokenUsage& operator=(LLMTokenUsage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LLMTokenUsage& default_instance() {
    return *internal_default_instance();
  }
  static inline const LLMTokenUsage* internal_default_instance() {
    return reinterpret_cast<const LLMTokenUsage*>(
               &_LLMTokenUsage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(LLMTokenUsage& a, LLMTokenUsage& b) {
    a.Swap(&b);
  }
  inline void Swap(LLMTokenUsage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LLMTokenUsage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LLMTokenUsage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LLMTokenUsage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LLMTokenUsage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LLMTokenUsage& from) {
    LLMTokenUsage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LLMTokenUsage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.LLMTokenUsage";
  }
  protected:
  explicit LLMTokenUsage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPromptTokensFieldNumber = 1,
    kCompletionTokensFieldNumber = 2,
    kTotalTokensFieldNumber = 3,
    kCostUsdFieldNumber = 4,
  };
  // int32 prompt_tokens = 1;
  void clear_prompt_tokens();
  int32_t prompt_tokens() const;
  void set_prompt_tokens(int32_t value);
  private:
  int32_t _internal_prompt_tokens() const;
  void _internal_set_prompt_tokens(int32_t value);
  public:

  // int32 completion_tokens = 2;
  void clear_completion_tokens();
  int32_t completion_tokens() const;
  void set_completion_tokens(int32_t value);
  private:
  int32_t _internal_completion_tokens() const;
  void _internal_set_completion_tokens(int32_t value);
  public:

  // int32 total_tokens = 3;
  void clear_total_tokens();
  int32_t total_tokens() const;
  void set_total_tokens(int32_t value);
  private:
  int32_t _internal_total_tokens() const;
  void _internal_set_total_tokens(int32_t value);
  public:

  // float cost_usd = 4;
  void clear_cost_usd();
  float cost_usd() const;
  void set_cost_usd(float value);
  private:
  float _internal_cost_usd() const;
  void _internal_set_cost_usd(float value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.cdc.LLMTokenUsage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t prompt_tokens_;
    int32_t completion_tokens_;
    int32_t total_tokens_;
    float cost_usd_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fevents_2eproto;
};
// -------------------------------------------------------------------

class AgentEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.AgentEvent) */ {
 public:
  inline AgentEvent() : AgentEvent(nullptr) {}
  ~AgentEvent() override;
  explicit PROTOBUF_CONSTEXPR AgentEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AgentEvent(const AgentEvent& from);
  AgentEvent(AgentEvent&& from) noexcept
    : AgentEvent() {
    *this = ::std::move(from);
  }

  inline AgentEvent& operator=(const AgentEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline AgentEvent& operator=(AgentEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AgentEvent& default_instance() {
    return *internal_default_instance();
  }
  enum EventDataCase {
    kStarted = 10,
    kStepCompleted = 11,
    kCompleted = 12,
    kFailed = 13,
    kToolUsed = 14,
    EVENT_DATA_NOT_SET = 0,
  };

  static inline const AgentEvent* internal_default_instance() {
    return reinterpret_cast<const AgentEvent*>(
               &_AgentEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(AgentEvent& a, AgentEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(AgentEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AgentEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AgentEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AgentEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AgentEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AgentEvent& from) {
    AgentEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AgentEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.AgentEvent";
  }
  protected:
  explicit AgentEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAgentIdFieldNumber = 1,
    kAgentTypeFieldNumber = 2,
    kAgentVersionFieldNumber = 3,
    kExecutionIdFieldNumber = 4,
    kEventTypeFieldNumber = 5,
    kStartedFieldNumber = 10,
    kStepCompletedFieldNumber = 11,
    kCompletedFieldNumber = 12,
    kFailedFieldNumber = 13,
    kToolUsedFieldNumber = 14,
  };
  // string agent_id = 1;
  void clear_agent_id();
  const std::string& agent_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_agent_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_agent_id();
  PROTOBUF_NODISCARD std::string* release_agent_id();
  void set_allocated_agent_id(std::string* agent_id);
  private:
  const std::string& _internal_agent_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_agent_id(const std::string& value);
  std::string* _internal_mutable_agent_id();
  public:

  // string agent_type = 2;
  void clear_agent_type();
  const std::string& agent_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_agent_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_agent_type();
  PROTOBUF_NODISCARD std::string* release_agent_type();
  void set_allocated_agent_type(std::string* agent_type);
  private:
  const std::string& _internal_agent_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_agent_type(const std::string& value);
  std::string* _internal_mutable_agent_type();
  public:

  // string agent_version = 3;
  void clear_agent_version();
  const std::string& agent_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_agent_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_agent_version();
  PROTOBUF_NODISCARD std::string* release_agent_version();
  void set_allocated_agent_version(std::string* agent_version);
  private:
  const std::string& _internal_agent_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_agent_version(const std::string& value);
  std::string* _internal_mutable_agent_version();
  public:

  // string execution_id = 4;
  void clear_execution_id();
  const std::string& execution_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_execution_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_execution_id();
  PROTOBUF_NODISCARD std::string* release_execution_id();
  void set_allocated_execution_id(std::string* execution_id);
  private:
  const std::string& _internal_execution_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_execution_id(const std::string& value);
  std::string* _internal_mutable_execution_id();
  public:

  // .unhinged.cdc.AgentEventType event_type = 5;
  void clear_event_type();
  ::unhinged::cdc::AgentEventType event_type() const;
  void set_event_type(::unhinged::cdc::AgentEventType value);
  private:
  ::unhinged::cdc::AgentEventType _internal_event_type() const;
  void _internal_set_event_type(::unhinged::cdc::AgentEventType value);
  public:

  // .unhinged.cdc.AgentStarted started = 10;
  bool has_started() const;
  private:
  bool _internal_has_started() const;
  public:
  void clear_started();
  const ::unhinged::cdc::AgentStarted& started() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::AgentStarted* release_started();
  ::unhinged::cdc::AgentStarted* mutable_started();
  void set_allocated_started(::unhinged::cdc::AgentStarted* started);
  private:
  const ::unhinged::cdc::AgentStarted& _internal_started() const;
  ::unhinged::cdc::AgentStarted* _internal_mutable_started();
  public:
  void unsafe_arena_set_allocated_started(
      ::unhinged::cdc::AgentStarted* started);
  ::unhinged::cdc::AgentStarted* unsafe_arena_release_started();

  // .unhinged.cdc.AgentStepCompleted step_completed = 11;
  bool has_step_completed() const;
  private:
  bool _internal_has_step_completed() const;
  public:
  void clear_step_completed();
  const ::unhinged::cdc::AgentStepCompleted& step_completed() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::AgentStepCompleted* release_step_completed();
  ::unhinged::cdc::AgentStepCompleted* mutable_step_completed();
  void set_allocated_step_completed(::unhinged::cdc::AgentStepCompleted* step_completed);
  private:
  const ::unhinged::cdc::AgentStepCompleted& _internal_step_completed() const;
  ::unhinged::cdc::AgentStepCompleted* _internal_mutable_step_completed();
  public:
  void unsafe_arena_set_allocated_step_completed(
      ::unhinged::cdc::AgentStepCompleted* step_completed);
  ::unhinged::cdc::AgentStepCompleted* unsafe_arena_release_step_completed();

  // .unhinged.cdc.AgentCompleted completed = 12;
  bool has_completed() const;
  private:
  bool _internal_has_completed() const;
  public:
  void clear_completed();
  const ::unhinged::cdc::AgentCompleted& completed() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::AgentCompleted* release_completed();
  ::unhinged::cdc::AgentCompleted* mutable_completed();
  void set_allocated_completed(::unhinged::cdc::AgentCompleted* completed);
  private:
  const ::unhinged::cdc::AgentCompleted& _internal_completed() const;
  ::unhinged::cdc::AgentCompleted* _internal_mutable_completed();
  public:
  void unsafe_arena_set_allocated_completed(
      ::unhinged::cdc::AgentCompleted* completed);
  ::unhinged::cdc::AgentCompleted* unsafe_arena_release_completed();

  // .unhinged.cdc.AgentFailed failed = 13;
  bool has_failed() const;
  private:
  bool _internal_has_failed() const;
  public:
  void clear_failed();
  const ::unhinged::cdc::AgentFailed& failed() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::AgentFailed* release_failed();
  ::unhinged::cdc::AgentFailed* mutable_failed();
  void set_allocated_failed(::unhinged::cdc::AgentFailed* failed);
  private:
  const ::unhinged::cdc::AgentFailed& _internal_failed() const;
  ::unhinged::cdc::AgentFailed* _internal_mutable_failed();
  public:
  void unsafe_arena_set_allocated_failed(
      ::unhinged::cdc::AgentFailed* failed);
  ::unhinged::cdc::AgentFailed* unsafe_arena_release_failed();

  // .unhinged.cdc.AgentToolUsed tool_used = 14;
  bool has_tool_used() const;
  private:
  bool _internal_has_tool_used() const;
  public:
  void clear_tool_used();
  const ::unhinged::cdc::AgentToolUsed& tool_used() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::AgentToolUsed* release_tool_used();
  ::unhinged::cdc::AgentToolUsed* mutable_tool_used();
  void set_allocated_tool_used(::unhinged::cdc::AgentToolUsed* tool_used);
  private:
  const ::unhinged::cdc::AgentToolUsed& _internal_tool_used() const;
  ::unhinged::cdc::AgentToolUsed* _internal_mutable_tool_used();
  public:
  void unsafe_arena_set_allocated_tool_used(
      ::unhinged::cdc::AgentToolUsed* tool_used);
  ::unhinged::cdc::AgentToolUsed* unsafe_arena_release_tool_used();

  void clear_event_data();
  EventDataCase event_data_case() const;
  // @@protoc_insertion_point(class_scope:unhinged.cdc.AgentEvent)
 private:
  class _Internal;
  void set_has_started();
  void set_has_step_completed();
  void set_has_completed();
  void set_has_failed();
  void set_has_tool_used();

  inline bool has_event_data() const;
  inline void clear_has_event_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr agent_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr agent_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr agent_version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr execution_id_;
    int event_type_;
    union EventDataUnion {
      constexpr EventDataUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::unhinged::cdc::AgentStarted* started_;
      ::unhinged::cdc::AgentStepCompleted* step_completed_;
      ::unhinged::cdc::AgentCompleted* completed_;
      ::unhinged::cdc::AgentFailed* failed_;
      ::unhinged::cdc::AgentToolUsed* tool_used_;
    } event_data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fevents_2eproto;
};
// -------------------------------------------------------------------

class AgentStarted final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.AgentStarted) */ {
 public:
  inline AgentStarted() : AgentStarted(nullptr) {}
  ~AgentStarted() override;
  explicit PROTOBUF_CONSTEXPR AgentStarted(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AgentStarted(const AgentStarted& from);
  AgentStarted(AgentStarted&& from) noexcept
    : AgentStarted() {
    *this = ::std::move(from);
  }

  inline AgentStarted& operator=(const AgentStarted& from) {
    CopyFrom(from);
    return *this;
  }
  inline AgentStarted& operator=(AgentStarted&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AgentStarted& default_instance() {
    return *internal_default_instance();
  }
  static inline const AgentStarted* internal_default_instance() {
    return reinterpret_cast<const AgentStarted*>(
               &_AgentStarted_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(AgentStarted& a, AgentStarted& b) {
    a.Swap(&b);
  }
  inline void Swap(AgentStarted* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AgentStarted* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AgentStarted* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AgentStarted>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AgentStarted& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AgentStarted& from) {
    AgentStarted::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AgentStarted* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.AgentStarted";
  }
  protected:
  explicit AgentStarted(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAvailableToolsFieldNumber = 3,
    kTaskDescriptionFieldNumber = 1,
    kInitialContextFieldNumber = 2,
  };
  // repeated string available_tools = 3;
  int available_tools_size() const;
  private:
  int _internal_available_tools_size() const;
  public:
  void clear_available_tools();
  const std::string& available_tools(int index) const;
  std::string* mutable_available_tools(int index);
  void set_available_tools(int index, const std::string& value);
  void set_available_tools(int index, std::string&& value);
  void set_available_tools(int index, const char* value);
  void set_available_tools(int index, const char* value, size_t size);
  std::string* add_available_tools();
  void add_available_tools(const std::string& value);
  void add_available_tools(std::string&& value);
  void add_available_tools(const char* value);
  void add_available_tools(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& available_tools() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_available_tools();
  private:
  const std::string& _internal_available_tools(int index) const;
  std::string* _internal_add_available_tools();
  public:

  // string task_description = 1;
  void clear_task_description();
  const std::string& task_description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_task_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_task_description();
  PROTOBUF_NODISCARD std::string* release_task_description();
  void set_allocated_task_description(std::string* task_description);
  private:
  const std::string& _internal_task_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_task_description(const std::string& value);
  std::string* _internal_mutable_task_description();
  public:

  // .google.protobuf.Struct initial_context = 2;
  bool has_initial_context() const;
  private:
  bool _internal_has_initial_context() const;
  public:
  void clear_initial_context();
  const ::PROTOBUF_NAMESPACE_ID::Struct& initial_context() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_initial_context();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_initial_context();
  void set_allocated_initial_context(::PROTOBUF_NAMESPACE_ID::Struct* initial_context);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_initial_context() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_initial_context();
  public:
  void unsafe_arena_set_allocated_initial_context(
      ::PROTOBUF_NAMESPACE_ID::Struct* initial_context);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_initial_context();

  // @@protoc_insertion_point(class_scope:unhinged.cdc.AgentStarted)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> available_tools_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr task_description_;
    ::PROTOBUF_NAMESPACE_ID::Struct* initial_context_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fevents_2eproto;
};
// -------------------------------------------------------------------

class AgentStepCompleted final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.AgentStepCompleted) */ {
 public:
  inline AgentStepCompleted() : AgentStepCompleted(nullptr) {}
  ~AgentStepCompleted() override;
  explicit PROTOBUF_CONSTEXPR AgentStepCompleted(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AgentStepCompleted(const AgentStepCompleted& from);
  AgentStepCompleted(AgentStepCompleted&& from) noexcept
    : AgentStepCompleted() {
    *this = ::std::move(from);
  }

  inline AgentStepCompleted& operator=(const AgentStepCompleted& from) {
    CopyFrom(from);
    return *this;
  }
  inline AgentStepCompleted& operator=(AgentStepCompleted&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AgentStepCompleted& default_instance() {
    return *internal_default_instance();
  }
  static inline const AgentStepCompleted* internal_default_instance() {
    return reinterpret_cast<const AgentStepCompleted*>(
               &_AgentStepCompleted_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(AgentStepCompleted& a, AgentStepCompleted& b) {
    a.Swap(&b);
  }
  inline void Swap(AgentStepCompleted* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AgentStepCompleted* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AgentStepCompleted* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AgentStepCompleted>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AgentStepCompleted& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AgentStepCompleted& from) {
    AgentStepCompleted::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AgentStepCompleted* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.AgentStepCompleted";
  }
  protected:
  explicit AgentStepCompleted(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStepTypeFieldNumber = 2,
    kStepDescriptionFieldNumber = 3,
    kStepResultFieldNumber = 4,
    kStepNumberFieldNumber = 1,
    kStepDurationMsFieldNumber = 5,
  };
  // string step_type = 2;
  void clear_step_type();
  const std::string& step_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_step_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_step_type();
  PROTOBUF_NODISCARD std::string* release_step_type();
  void set_allocated_step_type(std::string* step_type);
  private:
  const std::string& _internal_step_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_step_type(const std::string& value);
  std::string* _internal_mutable_step_type();
  public:

  // string step_description = 3;
  void clear_step_description();
  const std::string& step_description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_step_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_step_description();
  PROTOBUF_NODISCARD std::string* release_step_description();
  void set_allocated_step_description(std::string* step_description);
  private:
  const std::string& _internal_step_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_step_description(const std::string& value);
  std::string* _internal_mutable_step_description();
  public:

  // .google.protobuf.Struct step_result = 4;
  bool has_step_result() const;
  private:
  bool _internal_has_step_result() const;
  public:
  void clear_step_result();
  const ::PROTOBUF_NAMESPACE_ID::Struct& step_result() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_step_result();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_step_result();
  void set_allocated_step_result(::PROTOBUF_NAMESPACE_ID::Struct* step_result);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_step_result() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_step_result();
  public:
  void unsafe_arena_set_allocated_step_result(
      ::PROTOBUF_NAMESPACE_ID::Struct* step_result);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_step_result();

  // int32 step_number = 1;
  void clear_step_number();
  int32_t step_number() const;
  void set_step_number(int32_t value);
  private:
  int32_t _internal_step_number() const;
  void _internal_set_step_number(int32_t value);
  public:

  // float step_duration_ms = 5;
  void clear_step_duration_ms();
  float step_duration_ms() const;
  void set_step_duration_ms(float value);
  private:
  float _internal_step_duration_ms() const;
  void _internal_set_step_duration_ms(float value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.cdc.AgentStepCompleted)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr step_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr step_description_;
    ::PROTOBUF_NAMESPACE_ID::Struct* step_result_;
    int32_t step_number_;
    float step_duration_ms_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fevents_2eproto;
};
// -------------------------------------------------------------------

class AgentCompleted final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.AgentCompleted) */ {
 public:
  inline AgentCompleted() : AgentCompleted(nullptr) {}
  ~AgentCompleted() override;
  explicit PROTOBUF_CONSTEXPR AgentCompleted(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AgentCompleted(const AgentCompleted& from);
  AgentCompleted(AgentCompleted&& from) noexcept
    : AgentCompleted() {
    *this = ::std::move(from);
  }

  inline AgentCompleted& operator=(const AgentCompleted& from) {
    CopyFrom(from);
    return *this;
  }
  inline AgentCompleted& operator=(AgentCompleted&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AgentCompleted& default_instance() {
    return *internal_default_instance();
  }
  static inline const AgentCompleted* internal_default_instance() {
    return reinterpret_cast<const AgentCompleted*>(
               &_AgentCompleted_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(AgentCompleted& a, AgentCompleted& b) {
    a.Swap(&b);
  }
  inline void Swap(AgentCompleted* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AgentCompleted* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AgentCompleted* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AgentCompleted>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AgentCompleted& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AgentCompleted& from) {
    AgentCompleted::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AgentCompleted* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.AgentCompleted";
  }
  protected:
  explicit AgentCompleted(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCompletionStatusFieldNumber = 1,
    kFinalResultFieldNumber = 2,
    kTotalStepsFieldNumber = 3,
    kTotalDurationMsFieldNumber = 4,
  };
  // string completion_status = 1;
  void clear_completion_status();
  const std::string& completion_status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_completion_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_completion_status();
  PROTOBUF_NODISCARD std::string* release_completion_status();
  void set_allocated_completion_status(std::string* completion_status);
  private:
  const std::string& _internal_completion_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_completion_status(const std::string& value);
  std::string* _internal_mutable_completion_status();
  public:

  // .google.protobuf.Struct final_result = 2;
  bool has_final_result() const;
  private:
  bool _internal_has_final_result() const;
  public:
  void clear_final_result();
  const ::PROTOBUF_NAMESPACE_ID::Struct& final_result() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_final_result();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_final_result();
  void set_allocated_final_result(::PROTOBUF_NAMESPACE_ID::Struct* final_result);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_final_result() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_final_result();
  public:
  void unsafe_arena_set_allocated_final_result(
      ::PROTOBUF_NAMESPACE_ID::Struct* final_result);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_final_result();

  // int32 total_steps = 3;
  void clear_total_steps();
  int32_t total_steps() const;
  void set_total_steps(int32_t value);
  private:
  int32_t _internal_total_steps() const;
  void _internal_set_total_steps(int32_t value);
  public:

  // float total_duration_ms = 4;
  void clear_total_duration_ms();
  float total_duration_ms() const;
  void set_total_duration_ms(float value);
  private:
  float _internal_total_duration_ms() const;
  void _internal_set_total_duration_ms(float value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.cdc.AgentCompleted)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr completion_status_;
    ::PROTOBUF_NAMESPACE_ID::Struct* final_result_;
    int32_t total_steps_;
    float total_duration_ms_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fevents_2eproto;
};
// -------------------------------------------------------------------

class AgentFailed final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.AgentFailed) */ {
 public:
  inline AgentFailed() : AgentFailed(nullptr) {}
  ~AgentFailed() override;
  explicit PROTOBUF_CONSTEXPR AgentFailed(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AgentFailed(const AgentFailed& from);
  AgentFailed(AgentFailed&& from) noexcept
    : AgentFailed() {
    *this = ::std::move(from);
  }

  inline AgentFailed& operator=(const AgentFailed& from) {
    CopyFrom(from);
    return *this;
  }
  inline AgentFailed& operator=(AgentFailed&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AgentFailed& default_instance() {
    return *internal_default_instance();
  }
  static inline const AgentFailed* internal_default_instance() {
    return reinterpret_cast<const AgentFailed*>(
               &_AgentFailed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(AgentFailed& a, AgentFailed& b) {
    a.Swap(&b);
  }
  inline void Swap(AgentFailed* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AgentFailed* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AgentFailed* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AgentFailed>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AgentFailed& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AgentFailed& from) {
    AgentFailed::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AgentFailed* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.AgentFailed";
  }
  protected:
  explicit AgentFailed(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFailureReasonFieldNumber = 1,
    kErrorMessageFieldNumber = 2,
    kFailedAtStepFieldNumber = 3,
    kIsRecoverableFieldNumber = 4,
  };
  // string failure_reason = 1;
  void clear_failure_reason();
  const std::string& failure_reason() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_failure_reason(ArgT0&& arg0, ArgT... args);
  std::string* mutable_failure_reason();
  PROTOBUF_NODISCARD std::string* release_failure_reason();
  void set_allocated_failure_reason(std::string* failure_reason);
  private:
  const std::string& _internal_failure_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_failure_reason(const std::string& value);
  std::string* _internal_mutable_failure_reason();
  public:

  // string error_message = 2;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // int32 failed_at_step = 3;
  void clear_failed_at_step();
  int32_t failed_at_step() const;
  void set_failed_at_step(int32_t value);
  private:
  int32_t _internal_failed_at_step() const;
  void _internal_set_failed_at_step(int32_t value);
  public:

  // bool is_recoverable = 4;
  void clear_is_recoverable();
  bool is_recoverable() const;
  void set_is_recoverable(bool value);
  private:
  bool _internal_is_recoverable() const;
  void _internal_set_is_recoverable(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.cdc.AgentFailed)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr failure_reason_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    int32_t failed_at_step_;
    bool is_recoverable_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fevents_2eproto;
};
// -------------------------------------------------------------------

class AgentToolUsed final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.AgentToolUsed) */ {
 public:
  inline AgentToolUsed() : AgentToolUsed(nullptr) {}
  ~AgentToolUsed() override;
  explicit PROTOBUF_CONSTEXPR AgentToolUsed(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AgentToolUsed(const AgentToolUsed& from);
  AgentToolUsed(AgentToolUsed&& from) noexcept
    : AgentToolUsed() {
    *this = ::std::move(from);
  }

  inline AgentToolUsed& operator=(const AgentToolUsed& from) {
    CopyFrom(from);
    return *this;
  }
  inline AgentToolUsed& operator=(AgentToolUsed&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AgentToolUsed& default_instance() {
    return *internal_default_instance();
  }
  static inline const AgentToolUsed* internal_default_instance() {
    return reinterpret_cast<const AgentToolUsed*>(
               &_AgentToolUsed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(AgentToolUsed& a, AgentToolUsed& b) {
    a.Swap(&b);
  }
  inline void Swap(AgentToolUsed* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AgentToolUsed* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AgentToolUsed* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AgentToolUsed>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AgentToolUsed& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AgentToolUsed& from) {
    AgentToolUsed::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AgentToolUsed* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.AgentToolUsed";
  }
  protected:
  explicit AgentToolUsed(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kToolNameFieldNumber = 1,
    kToolVersionFieldNumber = 2,
    kToolInputFieldNumber = 3,
    kToolOutputFieldNumber = 4,
    kToolDurationMsFieldNumber = 5,
    kToolSuccessFieldNumber = 6,
  };
  // string tool_name = 1;
  void clear_tool_name();
  const std::string& tool_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tool_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tool_name();
  PROTOBUF_NODISCARD std::string* release_tool_name();
  void set_allocated_tool_name(std::string* tool_name);
  private:
  const std::string& _internal_tool_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tool_name(const std::string& value);
  std::string* _internal_mutable_tool_name();
  public:

  // string tool_version = 2;
  void clear_tool_version();
  const std::string& tool_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tool_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tool_version();
  PROTOBUF_NODISCARD std::string* release_tool_version();
  void set_allocated_tool_version(std::string* tool_version);
  private:
  const std::string& _internal_tool_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tool_version(const std::string& value);
  std::string* _internal_mutable_tool_version();
  public:

  // .google.protobuf.Struct tool_input = 3;
  bool has_tool_input() const;
  private:
  bool _internal_has_tool_input() const;
  public:
  void clear_tool_input();
  const ::PROTOBUF_NAMESPACE_ID::Struct& tool_input() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_tool_input();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_tool_input();
  void set_allocated_tool_input(::PROTOBUF_NAMESPACE_ID::Struct* tool_input);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_tool_input() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_tool_input();
  public:
  void unsafe_arena_set_allocated_tool_input(
      ::PROTOBUF_NAMESPACE_ID::Struct* tool_input);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_tool_input();

  // .google.protobuf.Struct tool_output = 4;
  bool has_tool_output() const;
  private:
  bool _internal_has_tool_output() const;
  public:
  void clear_tool_output();
  const ::PROTOBUF_NAMESPACE_ID::Struct& tool_output() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_tool_output();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_tool_output();
  void set_allocated_tool_output(::PROTOBUF_NAMESPACE_ID::Struct* tool_output);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_tool_output() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_tool_output();
  public:
  void unsafe_arena_set_allocated_tool_output(
      ::PROTOBUF_NAMESPACE_ID::Struct* tool_output);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_tool_output();

  // float tool_duration_ms = 5;
  void clear_tool_duration_ms();
  float tool_duration_ms() const;
  void set_tool_duration_ms(float value);
  private:
  float _internal_tool_duration_ms() const;
  void _internal_set_tool_duration_ms(float value);
  public:

  // bool tool_success = 6;
  void clear_tool_success();
  bool tool_success() const;
  void set_tool_success(bool value);
  private:
  bool _internal_tool_success() const;
  void _internal_set_tool_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.cdc.AgentToolUsed)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tool_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tool_version_;
    ::PROTOBUF_NAMESPACE_ID::Struct* tool_input_;
    ::PROTOBUF_NAMESPACE_ID::Struct* tool_output_;
    float tool_duration_ms_;
    bool tool_success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fevents_2eproto;
};
// -------------------------------------------------------------------

class SessionEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.SessionEvent) */ {
 public:
  inline SessionEvent() : SessionEvent(nullptr) {}
  ~SessionEvent() override;
  explicit PROTOBUF_CONSTEXPR SessionEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SessionEvent(const SessionEvent& from);
  SessionEvent(SessionEvent&& from) noexcept
    : SessionEvent() {
    *this = ::std::move(from);
  }

  inline SessionEvent& operator=(const SessionEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionEvent& operator=(SessionEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SessionEvent& default_instance() {
    return *internal_default_instance();
  }
  enum EventDataCase {
    kStarted = 10,
    kEnded = 11,
    kContextAccessed = 12,
    kHeartbeat = 13,
    EVENT_DATA_NOT_SET = 0,
  };

  static inline const SessionEvent* internal_default_instance() {
    return reinterpret_cast<const SessionEvent*>(
               &_SessionEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(SessionEvent& a, SessionEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(SessionEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SessionEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SessionEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SessionEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SessionEvent& from) {
    SessionEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SessionEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.SessionEvent";
  }
  protected:
  explicit SessionEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
    kEventTypeFieldNumber = 2,
    kStartedFieldNumber = 10,
    kEndedFieldNumber = 11,
    kContextAccessedFieldNumber = 12,
    kHeartbeatFieldNumber = 13,
  };
  // string session_id = 1;
  void clear_session_id();
  const std::string& session_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // .unhinged.cdc.SessionEventType event_type = 2;
  void clear_event_type();
  ::unhinged::cdc::SessionEventType event_type() const;
  void set_event_type(::unhinged::cdc::SessionEventType value);
  private:
  ::unhinged::cdc::SessionEventType _internal_event_type() const;
  void _internal_set_event_type(::unhinged::cdc::SessionEventType value);
  public:

  // .unhinged.cdc.SessionStarted started = 10;
  bool has_started() const;
  private:
  bool _internal_has_started() const;
  public:
  void clear_started();
  const ::unhinged::cdc::SessionStarted& started() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::SessionStarted* release_started();
  ::unhinged::cdc::SessionStarted* mutable_started();
  void set_allocated_started(::unhinged::cdc::SessionStarted* started);
  private:
  const ::unhinged::cdc::SessionStarted& _internal_started() const;
  ::unhinged::cdc::SessionStarted* _internal_mutable_started();
  public:
  void unsafe_arena_set_allocated_started(
      ::unhinged::cdc::SessionStarted* started);
  ::unhinged::cdc::SessionStarted* unsafe_arena_release_started();

  // .unhinged.cdc.SessionEnded ended = 11;
  bool has_ended() const;
  private:
  bool _internal_has_ended() const;
  public:
  void clear_ended();
  const ::unhinged::cdc::SessionEnded& ended() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::SessionEnded* release_ended();
  ::unhinged::cdc::SessionEnded* mutable_ended();
  void set_allocated_ended(::unhinged::cdc::SessionEnded* ended);
  private:
  const ::unhinged::cdc::SessionEnded& _internal_ended() const;
  ::unhinged::cdc::SessionEnded* _internal_mutable_ended();
  public:
  void unsafe_arena_set_allocated_ended(
      ::unhinged::cdc::SessionEnded* ended);
  ::unhinged::cdc::SessionEnded* unsafe_arena_release_ended();

  // .unhinged.cdc.SessionContextAccessed context_accessed = 12;
  bool has_context_accessed() const;
  private:
  bool _internal_has_context_accessed() const;
  public:
  void clear_context_accessed();
  const ::unhinged::cdc::SessionContextAccessed& context_accessed() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::SessionContextAccessed* release_context_accessed();
  ::unhinged::cdc::SessionContextAccessed* mutable_context_accessed();
  void set_allocated_context_accessed(::unhinged::cdc::SessionContextAccessed* context_accessed);
  private:
  const ::unhinged::cdc::SessionContextAccessed& _internal_context_accessed() const;
  ::unhinged::cdc::SessionContextAccessed* _internal_mutable_context_accessed();
  public:
  void unsafe_arena_set_allocated_context_accessed(
      ::unhinged::cdc::SessionContextAccessed* context_accessed);
  ::unhinged::cdc::SessionContextAccessed* unsafe_arena_release_context_accessed();

  // .unhinged.cdc.SessionHeartbeat heartbeat = 13;
  bool has_heartbeat() const;
  private:
  bool _internal_has_heartbeat() const;
  public:
  void clear_heartbeat();
  const ::unhinged::cdc::SessionHeartbeat& heartbeat() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::SessionHeartbeat* release_heartbeat();
  ::unhinged::cdc::SessionHeartbeat* mutable_heartbeat();
  void set_allocated_heartbeat(::unhinged::cdc::SessionHeartbeat* heartbeat);
  private:
  const ::unhinged::cdc::SessionHeartbeat& _internal_heartbeat() const;
  ::unhinged::cdc::SessionHeartbeat* _internal_mutable_heartbeat();
  public:
  void unsafe_arena_set_allocated_heartbeat(
      ::unhinged::cdc::SessionHeartbeat* heartbeat);
  ::unhinged::cdc::SessionHeartbeat* unsafe_arena_release_heartbeat();

  void clear_event_data();
  EventDataCase event_data_case() const;
  // @@protoc_insertion_point(class_scope:unhinged.cdc.SessionEvent)
 private:
  class _Internal;
  void set_has_started();
  void set_has_ended();
  void set_has_context_accessed();
  void set_has_heartbeat();

  inline bool has_event_data() const;
  inline void clear_has_event_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
    int event_type_;
    union EventDataUnion {
      constexpr EventDataUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::unhinged::cdc::SessionStarted* started_;
      ::unhinged::cdc::SessionEnded* ended_;
      ::unhinged::cdc::SessionContextAccessed* context_accessed_;
      ::unhinged::cdc::SessionHeartbeat* heartbeat_;
    } event_data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fevents_2eproto;
};
// -------------------------------------------------------------------

class SessionStarted final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.SessionStarted) */ {
 public:
  inline SessionStarted() : SessionStarted(nullptr) {}
  ~SessionStarted() override;
  explicit PROTOBUF_CONSTEXPR SessionStarted(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SessionStarted(const SessionStarted& from);
  SessionStarted(SessionStarted&& from) noexcept
    : SessionStarted() {
    *this = ::std::move(from);
  }

  inline SessionStarted& operator=(const SessionStarted& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionStarted& operator=(SessionStarted&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SessionStarted& default_instance() {
    return *internal_default_instance();
  }
  static inline const SessionStarted* internal_default_instance() {
    return reinterpret_cast<const SessionStarted*>(
               &_SessionStarted_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(SessionStarted& a, SessionStarted& b) {
    a.Swap(&b);
  }
  inline void Swap(SessionStarted* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionStarted* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SessionStarted* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SessionStarted>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SessionStarted& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SessionStarted& from) {
    SessionStarted::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SessionStarted* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.SessionStarted";
  }
  protected:
  explicit SessionStarted(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserAgentFieldNumber = 1,
    kIpAddressFieldNumber = 2,
    kSessionMetadataFieldNumber = 3,
  };
  // string user_agent = 1;
  void clear_user_agent();
  const std::string& user_agent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_agent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_agent();
  PROTOBUF_NODISCARD std::string* release_user_agent();
  void set_allocated_user_agent(std::string* user_agent);
  private:
  const std::string& _internal_user_agent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_agent(const std::string& value);
  std::string* _internal_mutable_user_agent();
  public:

  // string ip_address = 2;
  void clear_ip_address();
  const std::string& ip_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip_address();
  PROTOBUF_NODISCARD std::string* release_ip_address();
  void set_allocated_ip_address(std::string* ip_address);
  private:
  const std::string& _internal_ip_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip_address(const std::string& value);
  std::string* _internal_mutable_ip_address();
  public:

  // .google.protobuf.Struct session_metadata = 3;
  bool has_session_metadata() const;
  private:
  bool _internal_has_session_metadata() const;
  public:
  void clear_session_metadata();
  const ::PROTOBUF_NAMESPACE_ID::Struct& session_metadata() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_session_metadata();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_session_metadata();
  void set_allocated_session_metadata(::PROTOBUF_NAMESPACE_ID::Struct* session_metadata);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_session_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_session_metadata();
  public:
  void unsafe_arena_set_allocated_session_metadata(
      ::PROTOBUF_NAMESPACE_ID::Struct* session_metadata);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_session_metadata();

  // @@protoc_insertion_point(class_scope:unhinged.cdc.SessionStarted)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_agent_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_address_;
    ::PROTOBUF_NAMESPACE_ID::Struct* session_metadata_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fevents_2eproto;
};
// -------------------------------------------------------------------

class SessionEnded final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.SessionEnded) */ {
 public:
  inline SessionEnded() : SessionEnded(nullptr) {}
  ~SessionEnded() override;
  explicit PROTOBUF_CONSTEXPR SessionEnded(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SessionEnded(const SessionEnded& from);
  SessionEnded(SessionEnded&& from) noexcept
    : SessionEnded() {
    *this = ::std::move(from);
  }

  inline SessionEnded& operator=(const SessionEnded& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionEnded& operator=(SessionEnded&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SessionEnded& default_instance() {
    return *internal_default_instance();
  }
  static inline const SessionEnded* internal_default_instance() {
    return reinterpret_cast<const SessionEnded*>(
               &_SessionEnded_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(SessionEnded& a, SessionEnded& b) {
    a.Swap(&b);
  }
  inline void Swap(SessionEnded* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionEnded* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SessionEnded* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SessionEnded>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SessionEnded& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SessionEnded& from) {
    SessionEnded::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SessionEnded* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.SessionEnded";
  }
  protected:
  explicit SessionEnded(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEndReasonFieldNumber = 1,
    kSessionDurationMsFieldNumber = 2,
    kInteractionsCountFieldNumber = 3,
  };
  // string end_reason = 1;
  void clear_end_reason();
  const std::string& end_reason() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_end_reason(ArgT0&& arg0, ArgT... args);
  std::string* mutable_end_reason();
  PROTOBUF_NODISCARD std::string* release_end_reason();
  void set_allocated_end_reason(std::string* end_reason);
  private:
  const std::string& _internal_end_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_end_reason(const std::string& value);
  std::string* _internal_mutable_end_reason();
  public:

  // float session_duration_ms = 2;
  void clear_session_duration_ms();
  float session_duration_ms() const;
  void set_session_duration_ms(float value);
  private:
  float _internal_session_duration_ms() const;
  void _internal_set_session_duration_ms(float value);
  public:

  // int32 interactions_count = 3;
  void clear_interactions_count();
  int32_t interactions_count() const;
  void set_interactions_count(int32_t value);
  private:
  int32_t _internal_interactions_count() const;
  void _internal_set_interactions_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.cdc.SessionEnded)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr end_reason_;
    float session_duration_ms_;
    int32_t interactions_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fevents_2eproto;
};
// -------------------------------------------------------------------

class SessionContextAccessed final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.SessionContextAccessed) */ {
 public:
  inline SessionContextAccessed() : SessionContextAccessed(nullptr) {}
  ~SessionContextAccessed() override;
  explicit PROTOBUF_CONSTEXPR SessionContextAccessed(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SessionContextAccessed(const SessionContextAccessed& from);
  SessionContextAccessed(SessionContextAccessed&& from) noexcept
    : SessionContextAccessed() {
    *this = ::std::move(from);
  }

  inline SessionContextAccessed& operator=(const SessionContextAccessed& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionContextAccessed& operator=(SessionContextAccessed&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SessionContextAccessed& default_instance() {
    return *internal_default_instance();
  }
  static inline const SessionContextAccessed* internal_default_instance() {
    return reinterpret_cast<const SessionContextAccessed*>(
               &_SessionContextAccessed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(SessionContextAccessed& a, SessionContextAccessed& b) {
    a.Swap(&b);
  }
  inline void Swap(SessionContextAccessed* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionContextAccessed* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SessionContextAccessed* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SessionContextAccessed>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SessionContextAccessed& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SessionContextAccessed& from) {
    SessionContextAccessed::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SessionContextAccessed* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.SessionContextAccessed";
  }
  protected:
  explicit SessionContextAccessed(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDocumentTypesFieldNumber = 1,
    kAccessReasonFieldNumber = 3,
    kDocumentsReturnedFieldNumber = 2,
  };
  // repeated string document_types = 1;
  int document_types_size() const;
  private:
  int _internal_document_types_size() const;
  public:
  void clear_document_types();
  const std::string& document_types(int index) const;
  std::string* mutable_document_types(int index);
  void set_document_types(int index, const std::string& value);
  void set_document_types(int index, std::string&& value);
  void set_document_types(int index, const char* value);
  void set_document_types(int index, const char* value, size_t size);
  std::string* add_document_types();
  void add_document_types(const std::string& value);
  void add_document_types(std::string&& value);
  void add_document_types(const char* value);
  void add_document_types(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& document_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_document_types();
  private:
  const std::string& _internal_document_types(int index) const;
  std::string* _internal_add_document_types();
  public:

  // string access_reason = 3;
  void clear_access_reason();
  const std::string& access_reason() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_access_reason(ArgT0&& arg0, ArgT... args);
  std::string* mutable_access_reason();
  PROTOBUF_NODISCARD std::string* release_access_reason();
  void set_allocated_access_reason(std::string* access_reason);
  private:
  const std::string& _internal_access_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_access_reason(const std::string& value);
  std::string* _internal_mutable_access_reason();
  public:

  // int32 documents_returned = 2;
  void clear_documents_returned();
  int32_t documents_returned() const;
  void set_documents_returned(int32_t value);
  private:
  int32_t _internal_documents_returned() const;
  void _internal_set_documents_returned(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.cdc.SessionContextAccessed)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> document_types_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr access_reason_;
    int32_t documents_returned_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fevents_2eproto;
};
// -------------------------------------------------------------------

class SessionHeartbeat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.SessionHeartbeat) */ {
 public:
  inline SessionHeartbeat() : SessionHeartbeat(nullptr) {}
  ~SessionHeartbeat() override;
  explicit PROTOBUF_CONSTEXPR SessionHeartbeat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SessionHeartbeat(const SessionHeartbeat& from);
  SessionHeartbeat(SessionHeartbeat&& from) noexcept
    : SessionHeartbeat() {
    *this = ::std::move(from);
  }

  inline SessionHeartbeat& operator=(const SessionHeartbeat& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionHeartbeat& operator=(SessionHeartbeat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SessionHeartbeat& default_instance() {
    return *internal_default_instance();
  }
  static inline const SessionHeartbeat* internal_default_instance() {
    return reinterpret_cast<const SessionHeartbeat*>(
               &_SessionHeartbeat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(SessionHeartbeat& a, SessionHeartbeat& b) {
    a.Swap(&b);
  }
  inline void Swap(SessionHeartbeat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionHeartbeat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SessionHeartbeat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SessionHeartbeat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SessionHeartbeat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SessionHeartbeat& from) {
    SessionHeartbeat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SessionHeartbeat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.SessionHeartbeat";
  }
  protected:
  explicit SessionHeartbeat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLastActivityFieldNumber = 1,
    kIsActiveFieldNumber = 2,
  };
  // .google.protobuf.Timestamp last_activity = 1;
  bool has_last_activity() const;
  private:
  bool _internal_has_last_activity() const;
  public:
  void clear_last_activity();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& last_activity() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_last_activity();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_last_activity();
  void set_allocated_last_activity(::PROTOBUF_NAMESPACE_ID::Timestamp* last_activity);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_last_activity() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_last_activity();
  public:
  void unsafe_arena_set_allocated_last_activity(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* last_activity);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_last_activity();

  // bool is_active = 2;
  void clear_is_active();
  bool is_active() const;
  void set_is_active(bool value);
  private:
  bool _internal_is_active() const;
  void _internal_set_is_active(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.cdc.SessionHeartbeat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_activity_;
    bool is_active_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fevents_2eproto;
};
// -------------------------------------------------------------------

class SystemEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.SystemEvent) */ {
 public:
  inline SystemEvent() : SystemEvent(nullptr) {}
  ~SystemEvent() override;
  explicit PROTOBUF_CONSTEXPR SystemEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SystemEvent(const SystemEvent& from);
  SystemEvent(SystemEvent&& from) noexcept
    : SystemEvent() {
    *this = ::std::move(from);
  }

  inline SystemEvent& operator=(const SystemEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SystemEvent& operator=(SystemEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SystemEvent& default_instance() {
    return *internal_default_instance();
  }
  enum EventDataCase {
    kHealthCheck = 10,
    kMetric = 11,
    kAlert = 12,
    kServiceStarted = 13,
    kServiceStopped = 14,
    EVENT_DATA_NOT_SET = 0,
  };

  static inline const SystemEvent* internal_default_instance() {
    return reinterpret_cast<const SystemEvent*>(
               &_SystemEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(SystemEvent& a, SystemEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(SystemEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SystemEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SystemEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SystemEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SystemEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SystemEvent& from) {
    SystemEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SystemEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.SystemEvent";
  }
  protected:
  explicit SystemEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kComponentFieldNumber = 1,
    kEventTypeFieldNumber = 2,
    kHealthCheckFieldNumber = 10,
    kMetricFieldNumber = 11,
    kAlertFieldNumber = 12,
    kServiceStartedFieldNumber = 13,
    kServiceStoppedFieldNumber = 14,
  };
  // string component = 1;
  void clear_component();
  const std::string& component() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_component(ArgT0&& arg0, ArgT... args);
  std::string* mutable_component();
  PROTOBUF_NODISCARD std::string* release_component();
  void set_allocated_component(std::string* component);
  private:
  const std::string& _internal_component() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_component(const std::string& value);
  std::string* _internal_mutable_component();
  public:

  // .unhinged.cdc.SystemEventType event_type = 2;
  void clear_event_type();
  ::unhinged::cdc::SystemEventType event_type() const;
  void set_event_type(::unhinged::cdc::SystemEventType value);
  private:
  ::unhinged::cdc::SystemEventType _internal_event_type() const;
  void _internal_set_event_type(::unhinged::cdc::SystemEventType value);
  public:

  // .unhinged.cdc.HealthCheck health_check = 10;
  bool has_health_check() const;
  private:
  bool _internal_has_health_check() const;
  public:
  void clear_health_check();
  const ::unhinged::cdc::HealthCheck& health_check() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::HealthCheck* release_health_check();
  ::unhinged::cdc::HealthCheck* mutable_health_check();
  void set_allocated_health_check(::unhinged::cdc::HealthCheck* health_check);
  private:
  const ::unhinged::cdc::HealthCheck& _internal_health_check() const;
  ::unhinged::cdc::HealthCheck* _internal_mutable_health_check();
  public:
  void unsafe_arena_set_allocated_health_check(
      ::unhinged::cdc::HealthCheck* health_check);
  ::unhinged::cdc::HealthCheck* unsafe_arena_release_health_check();

  // .unhinged.cdc.MetricReported metric = 11;
  bool has_metric() const;
  private:
  bool _internal_has_metric() const;
  public:
  void clear_metric();
  const ::unhinged::cdc::MetricReported& metric() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::MetricReported* release_metric();
  ::unhinged::cdc::MetricReported* mutable_metric();
  void set_allocated_metric(::unhinged::cdc::MetricReported* metric);
  private:
  const ::unhinged::cdc::MetricReported& _internal_metric() const;
  ::unhinged::cdc::MetricReported* _internal_mutable_metric();
  public:
  void unsafe_arena_set_allocated_metric(
      ::unhinged::cdc::MetricReported* metric);
  ::unhinged::cdc::MetricReported* unsafe_arena_release_metric();

  // .unhinged.cdc.AlertTriggered alert = 12;
  bool has_alert() const;
  private:
  bool _internal_has_alert() const;
  public:
  void clear_alert();
  const ::unhinged::cdc::AlertTriggered& alert() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::AlertTriggered* release_alert();
  ::unhinged::cdc::AlertTriggered* mutable_alert();
  void set_allocated_alert(::unhinged::cdc::AlertTriggered* alert);
  private:
  const ::unhinged::cdc::AlertTriggered& _internal_alert() const;
  ::unhinged::cdc::AlertTriggered* _internal_mutable_alert();
  public:
  void unsafe_arena_set_allocated_alert(
      ::unhinged::cdc::AlertTriggered* alert);
  ::unhinged::cdc::AlertTriggered* unsafe_arena_release_alert();

  // .unhinged.cdc.ServiceStarted service_started = 13;
  bool has_service_started() const;
  private:
  bool _internal_has_service_started() const;
  public:
  void clear_service_started();
  const ::unhinged::cdc::ServiceStarted& service_started() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::ServiceStarted* release_service_started();
  ::unhinged::cdc::ServiceStarted* mutable_service_started();
  void set_allocated_service_started(::unhinged::cdc::ServiceStarted* service_started);
  private:
  const ::unhinged::cdc::ServiceStarted& _internal_service_started() const;
  ::unhinged::cdc::ServiceStarted* _internal_mutable_service_started();
  public:
  void unsafe_arena_set_allocated_service_started(
      ::unhinged::cdc::ServiceStarted* service_started);
  ::unhinged::cdc::ServiceStarted* unsafe_arena_release_service_started();

  // .unhinged.cdc.ServiceStopped service_stopped = 14;
  bool has_service_stopped() const;
  private:
  bool _internal_has_service_stopped() const;
  public:
  void clear_service_stopped();
  const ::unhinged::cdc::ServiceStopped& service_stopped() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::ServiceStopped* release_service_stopped();
  ::unhinged::cdc::ServiceStopped* mutable_service_stopped();
  void set_allocated_service_stopped(::unhinged::cdc::ServiceStopped* service_stopped);
  private:
  const ::unhinged::cdc::ServiceStopped& _internal_service_stopped() const;
  ::unhinged::cdc::ServiceStopped* _internal_mutable_service_stopped();
  public:
  void unsafe_arena_set_allocated_service_stopped(
      ::unhinged::cdc::ServiceStopped* service_stopped);
  ::unhinged::cdc::ServiceStopped* unsafe_arena_release_service_stopped();

  void clear_event_data();
  EventDataCase event_data_case() const;
  // @@protoc_insertion_point(class_scope:unhinged.cdc.SystemEvent)
 private:
  class _Internal;
  void set_has_health_check();
  void set_has_metric();
  void set_has_alert();
  void set_has_service_started();
  void set_has_service_stopped();

  inline bool has_event_data() const;
  inline void clear_has_event_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr component_;
    int event_type_;
    union EventDataUnion {
      constexpr EventDataUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::unhinged::cdc::HealthCheck* health_check_;
      ::unhinged::cdc::MetricReported* metric_;
      ::unhinged::cdc::AlertTriggered* alert_;
      ::unhinged::cdc::ServiceStarted* service_started_;
      ::unhinged::cdc::ServiceStopped* service_stopped_;
    } event_data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fevents_2eproto;
};
// -------------------------------------------------------------------

class HealthCheck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.HealthCheck) */ {
 public:
  inline HealthCheck() : HealthCheck(nullptr) {}
  ~HealthCheck() override;
  explicit PROTOBUF_CONSTEXPR HealthCheck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HealthCheck(const HealthCheck& from);
  HealthCheck(HealthCheck&& from) noexcept
    : HealthCheck() {
    *this = ::std::move(from);
  }

  inline HealthCheck& operator=(const HealthCheck& from) {
    CopyFrom(from);
    return *this;
  }
  inline HealthCheck& operator=(HealthCheck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HealthCheck& default_instance() {
    return *internal_default_instance();
  }
  static inline const HealthCheck* internal_default_instance() {
    return reinterpret_cast<const HealthCheck*>(
               &_HealthCheck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(HealthCheck& a, HealthCheck& b) {
    a.Swap(&b);
  }
  inline void Swap(HealthCheck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HealthCheck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HealthCheck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HealthCheck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HealthCheck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HealthCheck& from) {
    HealthCheck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HealthCheck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.HealthCheck";
  }
  protected:
  explicit HealthCheck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 2,
    kHealthDetailsFieldNumber = 3,
    kIsHealthyFieldNumber = 1,
  };
  // string status = 2;
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // .google.protobuf.Struct health_details = 3;
  bool has_health_details() const;
  private:
  bool _internal_has_health_details() const;
  public:
  void clear_health_details();
  const ::PROTOBUF_NAMESPACE_ID::Struct& health_details() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_health_details();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_health_details();
  void set_allocated_health_details(::PROTOBUF_NAMESPACE_ID::Struct* health_details);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_health_details() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_health_details();
  public:
  void unsafe_arena_set_allocated_health_details(
      ::PROTOBUF_NAMESPACE_ID::Struct* health_details);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_health_details();

  // bool is_healthy = 1;
  void clear_is_healthy();
  bool is_healthy() const;
  void set_is_healthy(bool value);
  private:
  bool _internal_is_healthy() const;
  void _internal_set_is_healthy(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.cdc.HealthCheck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
    ::PROTOBUF_NAMESPACE_ID::Struct* health_details_;
    bool is_healthy_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fevents_2eproto;
};
// -------------------------------------------------------------------

class MetricReported final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.MetricReported) */ {
 public:
  inline MetricReported() : MetricReported(nullptr) {}
  ~MetricReported() override;
  explicit PROTOBUF_CONSTEXPR MetricReported(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MetricReported(const MetricReported& from);
  MetricReported(MetricReported&& from) noexcept
    : MetricReported() {
    *this = ::std::move(from);
  }

  inline MetricReported& operator=(const MetricReported& from) {
    CopyFrom(from);
    return *this;
  }
  inline MetricReported& operator=(MetricReported&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MetricReported& default_instance() {
    return *internal_default_instance();
  }
  static inline const MetricReported* internal_default_instance() {
    return reinterpret_cast<const MetricReported*>(
               &_MetricReported_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(MetricReported& a, MetricReported& b) {
    a.Swap(&b);
  }
  inline void Swap(MetricReported* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MetricReported* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MetricReported* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MetricReported>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MetricReported& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MetricReported& from) {
    MetricReported::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MetricReported* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.MetricReported";
  }
  protected:
  explicit MetricReported(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetricNameFieldNumber = 1,
    kMetricUnitFieldNumber = 3,
    kMetricTagsFieldNumber = 4,
    kMetricValueFieldNumber = 2,
  };
  // string metric_name = 1;
  void clear_metric_name();
  const std::string& metric_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_metric_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_metric_name();
  PROTOBUF_NODISCARD std::string* release_metric_name();
  void set_allocated_metric_name(std::string* metric_name);
  private:
  const std::string& _internal_metric_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_metric_name(const std::string& value);
  std::string* _internal_mutable_metric_name();
  public:

  // string metric_unit = 3;
  void clear_metric_unit();
  const std::string& metric_unit() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_metric_unit(ArgT0&& arg0, ArgT... args);
  std::string* mutable_metric_unit();
  PROTOBUF_NODISCARD std::string* release_metric_unit();
  void set_allocated_metric_unit(std::string* metric_unit);
  private:
  const std::string& _internal_metric_unit() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_metric_unit(const std::string& value);
  std::string* _internal_mutable_metric_unit();
  public:

  // .google.protobuf.Struct metric_tags = 4;
  bool has_metric_tags() const;
  private:
  bool _internal_has_metric_tags() const;
  public:
  void clear_metric_tags();
  const ::PROTOBUF_NAMESPACE_ID::Struct& metric_tags() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_metric_tags();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_metric_tags();
  void set_allocated_metric_tags(::PROTOBUF_NAMESPACE_ID::Struct* metric_tags);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_metric_tags() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_metric_tags();
  public:
  void unsafe_arena_set_allocated_metric_tags(
      ::PROTOBUF_NAMESPACE_ID::Struct* metric_tags);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_metric_tags();

  // double metric_value = 2;
  void clear_metric_value();
  double metric_value() const;
  void set_metric_value(double value);
  private:
  double _internal_metric_value() const;
  void _internal_set_metric_value(double value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.cdc.MetricReported)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr metric_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr metric_unit_;
    ::PROTOBUF_NAMESPACE_ID::Struct* metric_tags_;
    double metric_value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fevents_2eproto;
};
// -------------------------------------------------------------------

class AlertTriggered final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.AlertTriggered) */ {
 public:
  inline AlertTriggered() : AlertTriggered(nullptr) {}
  ~AlertTriggered() override;
  explicit PROTOBUF_CONSTEXPR AlertTriggered(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AlertTriggered(const AlertTriggered& from);
  AlertTriggered(AlertTriggered&& from) noexcept
    : AlertTriggered() {
    *this = ::std::move(from);
  }

  inline AlertTriggered& operator=(const AlertTriggered& from) {
    CopyFrom(from);
    return *this;
  }
  inline AlertTriggered& operator=(AlertTriggered&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AlertTriggered& default_instance() {
    return *internal_default_instance();
  }
  static inline const AlertTriggered* internal_default_instance() {
    return reinterpret_cast<const AlertTriggered*>(
               &_AlertTriggered_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(AlertTriggered& a, AlertTriggered& b) {
    a.Swap(&b);
  }
  inline void Swap(AlertTriggered* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AlertTriggered* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AlertTriggered* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AlertTriggered>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AlertTriggered& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AlertTriggered& from) {
    AlertTriggered::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AlertTriggered* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.AlertTriggered";
  }
  protected:
  explicit AlertTriggered(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAlertNameFieldNumber = 1,
    kSeverityFieldNumber = 2,
    kDescriptionFieldNumber = 3,
    kAlertContextFieldNumber = 4,
  };
  // string alert_name = 1;
  void clear_alert_name();
  const std::string& alert_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_alert_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_alert_name();
  PROTOBUF_NODISCARD std::string* release_alert_name();
  void set_allocated_alert_name(std::string* alert_name);
  private:
  const std::string& _internal_alert_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_alert_name(const std::string& value);
  std::string* _internal_mutable_alert_name();
  public:

  // string severity = 2;
  void clear_severity();
  const std::string& severity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_severity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_severity();
  PROTOBUF_NODISCARD std::string* release_severity();
  void set_allocated_severity(std::string* severity);
  private:
  const std::string& _internal_severity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_severity(const std::string& value);
  std::string* _internal_mutable_severity();
  public:

  // string description = 3;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // .google.protobuf.Struct alert_context = 4;
  bool has_alert_context() const;
  private:
  bool _internal_has_alert_context() const;
  public:
  void clear_alert_context();
  const ::PROTOBUF_NAMESPACE_ID::Struct& alert_context() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_alert_context();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_alert_context();
  void set_allocated_alert_context(::PROTOBUF_NAMESPACE_ID::Struct* alert_context);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_alert_context() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_alert_context();
  public:
  void unsafe_arena_set_allocated_alert_context(
      ::PROTOBUF_NAMESPACE_ID::Struct* alert_context);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_alert_context();

  // @@protoc_insertion_point(class_scope:unhinged.cdc.AlertTriggered)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr alert_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr severity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::Struct* alert_context_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fevents_2eproto;
};
// -------------------------------------------------------------------

class ServiceStarted final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.ServiceStarted) */ {
 public:
  inline ServiceStarted() : ServiceStarted(nullptr) {}
  ~ServiceStarted() override;
  explicit PROTOBUF_CONSTEXPR ServiceStarted(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServiceStarted(const ServiceStarted& from);
  ServiceStarted(ServiceStarted&& from) noexcept
    : ServiceStarted() {
    *this = ::std::move(from);
  }

  inline ServiceStarted& operator=(const ServiceStarted& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServiceStarted& operator=(ServiceStarted&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServiceStarted& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServiceStarted* internal_default_instance() {
    return reinterpret_cast<const ServiceStarted*>(
               &_ServiceStarted_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(ServiceStarted& a, ServiceStarted& b) {
    a.Swap(&b);
  }
  inline void Swap(ServiceStarted* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServiceStarted* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServiceStarted* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServiceStarted>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServiceStarted& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ServiceStarted& from) {
    ServiceStarted::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServiceStarted* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.ServiceStarted";
  }
  protected:
  explicit ServiceStarted(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceNameFieldNumber = 1,
    kServiceVersionFieldNumber = 2,
    kBuildInfoFieldNumber = 3,
  };
  // string service_name = 1;
  void clear_service_name();
  const std::string& service_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // string service_version = 2;
  void clear_service_version();
  const std::string& service_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_version();
  PROTOBUF_NODISCARD std::string* release_service_version();
  void set_allocated_service_version(std::string* service_version);
  private:
  const std::string& _internal_service_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_version(const std::string& value);
  std::string* _internal_mutable_service_version();
  public:

  // string build_info = 3;
  void clear_build_info();
  const std::string& build_info() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_build_info(ArgT0&& arg0, ArgT... args);
  std::string* mutable_build_info();
  PROTOBUF_NODISCARD std::string* release_build_info();
  void set_allocated_build_info(std::string* build_info);
  private:
  const std::string& _internal_build_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_build_info(const std::string& value);
  std::string* _internal_mutable_build_info();
  public:

  // @@protoc_insertion_point(class_scope:unhinged.cdc.ServiceStarted)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr build_info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fevents_2eproto;
};
// -------------------------------------------------------------------

class ServiceStopped final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.ServiceStopped) */ {
 public:
  inline ServiceStopped() : ServiceStopped(nullptr) {}
  ~ServiceStopped() override;
  explicit PROTOBUF_CONSTEXPR ServiceStopped(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServiceStopped(const ServiceStopped& from);
  ServiceStopped(ServiceStopped&& from) noexcept
    : ServiceStopped() {
    *this = ::std::move(from);
  }

  inline ServiceStopped& operator=(const ServiceStopped& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServiceStopped& operator=(ServiceStopped&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServiceStopped& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServiceStopped* internal_default_instance() {
    return reinterpret_cast<const ServiceStopped*>(
               &_ServiceStopped_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(ServiceStopped& a, ServiceStopped& b) {
    a.Swap(&b);
  }
  inline void Swap(ServiceStopped* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServiceStopped* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServiceStopped* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServiceStopped>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServiceStopped& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ServiceStopped& from) {
    ServiceStopped::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServiceStopped* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.ServiceStopped";
  }
  protected:
  explicit ServiceStopped(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceNameFieldNumber = 1,
    kStopReasonFieldNumber = 2,
    kUptimeMsFieldNumber = 3,
  };
  // string service_name = 1;
  void clear_service_name();
  const std::string& service_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // string stop_reason = 2;
  void clear_stop_reason();
  const std::string& stop_reason() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stop_reason(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stop_reason();
  PROTOBUF_NODISCARD std::string* release_stop_reason();
  void set_allocated_stop_reason(std::string* stop_reason);
  private:
  const std::string& _internal_stop_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stop_reason(const std::string& value);
  std::string* _internal_mutable_stop_reason();
  public:

  // float uptime_ms = 3;
  void clear_uptime_ms();
  float uptime_ms() const;
  void set_uptime_ms(float value);
  private:
  float _internal_uptime_ms() const;
  void _internal_set_uptime_ms(float value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.cdc.ServiceStopped)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stop_reason_;
    float uptime_ms_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fevents_2eproto;
};
// -------------------------------------------------------------------

class WorkflowEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.WorkflowEvent) */ {
 public:
  inline WorkflowEvent() : WorkflowEvent(nullptr) {}
  ~WorkflowEvent() override;
  explicit PROTOBUF_CONSTEXPR WorkflowEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WorkflowEvent(const WorkflowEvent& from);
  WorkflowEvent(WorkflowEvent&& from) noexcept
    : WorkflowEvent() {
    *this = ::std::move(from);
  }

  inline WorkflowEvent& operator=(const WorkflowEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkflowEvent& operator=(WorkflowEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkflowEvent& default_instance() {
    return *internal_default_instance();
  }
  enum EventDataCase {
    kTriggered = 10,
    kStepExecuted = 11,
    kCompleted = 12,
    kFailed = 13,
    EVENT_DATA_NOT_SET = 0,
  };

  static inline const WorkflowEvent* internal_default_instance() {
    return reinterpret_cast<const WorkflowEvent*>(
               &_WorkflowEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(WorkflowEvent& a, WorkflowEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkflowEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkflowEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorkflowEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WorkflowEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WorkflowEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WorkflowEvent& from) {
    WorkflowEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkflowEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.WorkflowEvent";
  }
  protected:
  explicit WorkflowEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWorkflowIdFieldNumber = 1,
    kWorkflowTypeFieldNumber = 2,
    kExecutionIdFieldNumber = 3,
    kEventTypeFieldNumber = 4,
    kTriggeredFieldNumber = 10,
    kStepExecutedFieldNumber = 11,
    kCompletedFieldNumber = 12,
    kFailedFieldNumber = 13,
  };
  // string workflow_id = 1;
  void clear_workflow_id();
  const std::string& workflow_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_workflow_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_workflow_id();
  PROTOBUF_NODISCARD std::string* release_workflow_id();
  void set_allocated_workflow_id(std::string* workflow_id);
  private:
  const std::string& _internal_workflow_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_workflow_id(const std::string& value);
  std::string* _internal_mutable_workflow_id();
  public:

  // string workflow_type = 2;
  void clear_workflow_type();
  const std::string& workflow_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_workflow_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_workflow_type();
  PROTOBUF_NODISCARD std::string* release_workflow_type();
  void set_allocated_workflow_type(std::string* workflow_type);
  private:
  const std::string& _internal_workflow_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_workflow_type(const std::string& value);
  std::string* _internal_mutable_workflow_type();
  public:

  // string execution_id = 3;
  void clear_execution_id();
  const std::string& execution_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_execution_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_execution_id();
  PROTOBUF_NODISCARD std::string* release_execution_id();
  void set_allocated_execution_id(std::string* execution_id);
  private:
  const std::string& _internal_execution_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_execution_id(const std::string& value);
  std::string* _internal_mutable_execution_id();
  public:

  // .unhinged.cdc.WorkflowEventType event_type = 4;
  void clear_event_type();
  ::unhinged::cdc::WorkflowEventType event_type() const;
  void set_event_type(::unhinged::cdc::WorkflowEventType value);
  private:
  ::unhinged::cdc::WorkflowEventType _internal_event_type() const;
  void _internal_set_event_type(::unhinged::cdc::WorkflowEventType value);
  public:

  // .unhinged.cdc.WorkflowTriggered triggered = 10;
  bool has_triggered() const;
  private:
  bool _internal_has_triggered() const;
  public:
  void clear_triggered();
  const ::unhinged::cdc::WorkflowTriggered& triggered() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::WorkflowTriggered* release_triggered();
  ::unhinged::cdc::WorkflowTriggered* mutable_triggered();
  void set_allocated_triggered(::unhinged::cdc::WorkflowTriggered* triggered);
  private:
  const ::unhinged::cdc::WorkflowTriggered& _internal_triggered() const;
  ::unhinged::cdc::WorkflowTriggered* _internal_mutable_triggered();
  public:
  void unsafe_arena_set_allocated_triggered(
      ::unhinged::cdc::WorkflowTriggered* triggered);
  ::unhinged::cdc::WorkflowTriggered* unsafe_arena_release_triggered();

  // .unhinged.cdc.WorkflowStepExecuted step_executed = 11;
  bool has_step_executed() const;
  private:
  bool _internal_has_step_executed() const;
  public:
  void clear_step_executed();
  const ::unhinged::cdc::WorkflowStepExecuted& step_executed() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::WorkflowStepExecuted* release_step_executed();
  ::unhinged::cdc::WorkflowStepExecuted* mutable_step_executed();
  void set_allocated_step_executed(::unhinged::cdc::WorkflowStepExecuted* step_executed);
  private:
  const ::unhinged::cdc::WorkflowStepExecuted& _internal_step_executed() const;
  ::unhinged::cdc::WorkflowStepExecuted* _internal_mutable_step_executed();
  public:
  void unsafe_arena_set_allocated_step_executed(
      ::unhinged::cdc::WorkflowStepExecuted* step_executed);
  ::unhinged::cdc::WorkflowStepExecuted* unsafe_arena_release_step_executed();

  // .unhinged.cdc.WorkflowCompleted completed = 12;
  bool has_completed() const;
  private:
  bool _internal_has_completed() const;
  public:
  void clear_completed();
  const ::unhinged::cdc::WorkflowCompleted& completed() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::WorkflowCompleted* release_completed();
  ::unhinged::cdc::WorkflowCompleted* mutable_completed();
  void set_allocated_completed(::unhinged::cdc::WorkflowCompleted* completed);
  private:
  const ::unhinged::cdc::WorkflowCompleted& _internal_completed() const;
  ::unhinged::cdc::WorkflowCompleted* _internal_mutable_completed();
  public:
  void unsafe_arena_set_allocated_completed(
      ::unhinged::cdc::WorkflowCompleted* completed);
  ::unhinged::cdc::WorkflowCompleted* unsafe_arena_release_completed();

  // .unhinged.cdc.WorkflowFailed failed = 13;
  bool has_failed() const;
  private:
  bool _internal_has_failed() const;
  public:
  void clear_failed();
  const ::unhinged::cdc::WorkflowFailed& failed() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::WorkflowFailed* release_failed();
  ::unhinged::cdc::WorkflowFailed* mutable_failed();
  void set_allocated_failed(::unhinged::cdc::WorkflowFailed* failed);
  private:
  const ::unhinged::cdc::WorkflowFailed& _internal_failed() const;
  ::unhinged::cdc::WorkflowFailed* _internal_mutable_failed();
  public:
  void unsafe_arena_set_allocated_failed(
      ::unhinged::cdc::WorkflowFailed* failed);
  ::unhinged::cdc::WorkflowFailed* unsafe_arena_release_failed();

  void clear_event_data();
  EventDataCase event_data_case() const;
  // @@protoc_insertion_point(class_scope:unhinged.cdc.WorkflowEvent)
 private:
  class _Internal;
  void set_has_triggered();
  void set_has_step_executed();
  void set_has_completed();
  void set_has_failed();

  inline bool has_event_data() const;
  inline void clear_has_event_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr workflow_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr workflow_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr execution_id_;
    int event_type_;
    union EventDataUnion {
      constexpr EventDataUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::unhinged::cdc::WorkflowTriggered* triggered_;
      ::unhinged::cdc::WorkflowStepExecuted* step_executed_;
      ::unhinged::cdc::WorkflowCompleted* completed_;
      ::unhinged::cdc::WorkflowFailed* failed_;
    } event_data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fevents_2eproto;
};
// -------------------------------------------------------------------

class WorkflowTriggered final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.WorkflowTriggered) */ {
 public:
  inline WorkflowTriggered() : WorkflowTriggered(nullptr) {}
  ~WorkflowTriggered() override;
  explicit PROTOBUF_CONSTEXPR WorkflowTriggered(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WorkflowTriggered(const WorkflowTriggered& from);
  WorkflowTriggered(WorkflowTriggered&& from) noexcept
    : WorkflowTriggered() {
    *this = ::std::move(from);
  }

  inline WorkflowTriggered& operator=(const WorkflowTriggered& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkflowTriggered& operator=(WorkflowTriggered&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkflowTriggered& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorkflowTriggered* internal_default_instance() {
    return reinterpret_cast<const WorkflowTriggered*>(
               &_WorkflowTriggered_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(WorkflowTriggered& a, WorkflowTriggered& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkflowTriggered* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkflowTriggered* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorkflowTriggered* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WorkflowTriggered>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WorkflowTriggered& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WorkflowTriggered& from) {
    WorkflowTriggered::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkflowTriggered* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.WorkflowTriggered";
  }
  protected:
  explicit WorkflowTriggered(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTriggerEventIdFieldNumber = 1,
    kTriggerTypeFieldNumber = 2,
    kTriggerContextFieldNumber = 3,
  };
  // string trigger_event_id = 1;
  void clear_trigger_event_id();
  const std::string& trigger_event_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_trigger_event_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_trigger_event_id();
  PROTOBUF_NODISCARD std::string* release_trigger_event_id();
  void set_allocated_trigger_event_id(std::string* trigger_event_id);
  private:
  const std::string& _internal_trigger_event_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trigger_event_id(const std::string& value);
  std::string* _internal_mutable_trigger_event_id();
  public:

  // string trigger_type = 2;
  void clear_trigger_type();
  const std::string& trigger_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_trigger_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_trigger_type();
  PROTOBUF_NODISCARD std::string* release_trigger_type();
  void set_allocated_trigger_type(std::string* trigger_type);
  private:
  const std::string& _internal_trigger_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trigger_type(const std::string& value);
  std::string* _internal_mutable_trigger_type();
  public:

  // .google.protobuf.Struct trigger_context = 3;
  bool has_trigger_context() const;
  private:
  bool _internal_has_trigger_context() const;
  public:
  void clear_trigger_context();
  const ::PROTOBUF_NAMESPACE_ID::Struct& trigger_context() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_trigger_context();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_trigger_context();
  void set_allocated_trigger_context(::PROTOBUF_NAMESPACE_ID::Struct* trigger_context);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_trigger_context() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_trigger_context();
  public:
  void unsafe_arena_set_allocated_trigger_context(
      ::PROTOBUF_NAMESPACE_ID::Struct* trigger_context);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_trigger_context();

  // @@protoc_insertion_point(class_scope:unhinged.cdc.WorkflowTriggered)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trigger_event_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trigger_type_;
    ::PROTOBUF_NAMESPACE_ID::Struct* trigger_context_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fevents_2eproto;
};
// -------------------------------------------------------------------

class WorkflowStepExecuted final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.WorkflowStepExecuted) */ {
 public:
  inline WorkflowStepExecuted() : WorkflowStepExecuted(nullptr) {}
  ~WorkflowStepExecuted() override;
  explicit PROTOBUF_CONSTEXPR WorkflowStepExecuted(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WorkflowStepExecuted(const WorkflowStepExecuted& from);
  WorkflowStepExecuted(WorkflowStepExecuted&& from) noexcept
    : WorkflowStepExecuted() {
    *this = ::std::move(from);
  }

  inline WorkflowStepExecuted& operator=(const WorkflowStepExecuted& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkflowStepExecuted& operator=(WorkflowStepExecuted&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkflowStepExecuted& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorkflowStepExecuted* internal_default_instance() {
    return reinterpret_cast<const WorkflowStepExecuted*>(
               &_WorkflowStepExecuted_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(WorkflowStepExecuted& a, WorkflowStepExecuted& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkflowStepExecuted* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkflowStepExecuted* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorkflowStepExecuted* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WorkflowStepExecuted>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WorkflowStepExecuted& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WorkflowStepExecuted& from) {
    WorkflowStepExecuted::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkflowStepExecuted* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.WorkflowStepExecuted";
  }
  protected:
  explicit WorkflowStepExecuted(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStepIdFieldNumber = 1,
    kStepTypeFieldNumber = 2,
    kStepInputFieldNumber = 3,
    kStepOutputFieldNumber = 4,
    kStepDurationMsFieldNumber = 5,
  };
  // string step_id = 1;
  void clear_step_id();
  const std::string& step_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_step_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_step_id();
  PROTOBUF_NODISCARD std::string* release_step_id();
  void set_allocated_step_id(std::string* step_id);
  private:
  const std::string& _internal_step_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_step_id(const std::string& value);
  std::string* _internal_mutable_step_id();
  public:

  // string step_type = 2;
  void clear_step_type();
  const std::string& step_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_step_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_step_type();
  PROTOBUF_NODISCARD std::string* release_step_type();
  void set_allocated_step_type(std::string* step_type);
  private:
  const std::string& _internal_step_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_step_type(const std::string& value);
  std::string* _internal_mutable_step_type();
  public:

  // .google.protobuf.Struct step_input = 3;
  bool has_step_input() const;
  private:
  bool _internal_has_step_input() const;
  public:
  void clear_step_input();
  const ::PROTOBUF_NAMESPACE_ID::Struct& step_input() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_step_input();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_step_input();
  void set_allocated_step_input(::PROTOBUF_NAMESPACE_ID::Struct* step_input);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_step_input() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_step_input();
  public:
  void unsafe_arena_set_allocated_step_input(
      ::PROTOBUF_NAMESPACE_ID::Struct* step_input);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_step_input();

  // .google.protobuf.Struct step_output = 4;
  bool has_step_output() const;
  private:
  bool _internal_has_step_output() const;
  public:
  void clear_step_output();
  const ::PROTOBUF_NAMESPACE_ID::Struct& step_output() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_step_output();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_step_output();
  void set_allocated_step_output(::PROTOBUF_NAMESPACE_ID::Struct* step_output);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_step_output() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_step_output();
  public:
  void unsafe_arena_set_allocated_step_output(
      ::PROTOBUF_NAMESPACE_ID::Struct* step_output);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_step_output();

  // float step_duration_ms = 5;
  void clear_step_duration_ms();
  float step_duration_ms() const;
  void set_step_duration_ms(float value);
  private:
  float _internal_step_duration_ms() const;
  void _internal_set_step_duration_ms(float value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.cdc.WorkflowStepExecuted)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr step_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr step_type_;
    ::PROTOBUF_NAMESPACE_ID::Struct* step_input_;
    ::PROTOBUF_NAMESPACE_ID::Struct* step_output_;
    float step_duration_ms_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fevents_2eproto;
};
// -------------------------------------------------------------------

class WorkflowCompleted final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.WorkflowCompleted) */ {
 public:
  inline WorkflowCompleted() : WorkflowCompleted(nullptr) {}
  ~WorkflowCompleted() override;
  explicit PROTOBUF_CONSTEXPR WorkflowCompleted(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WorkflowCompleted(const WorkflowCompleted& from);
  WorkflowCompleted(WorkflowCompleted&& from) noexcept
    : WorkflowCompleted() {
    *this = ::std::move(from);
  }

  inline WorkflowCompleted& operator=(const WorkflowCompleted& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkflowCompleted& operator=(WorkflowCompleted&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkflowCompleted& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorkflowCompleted* internal_default_instance() {
    return reinterpret_cast<const WorkflowCompleted*>(
               &_WorkflowCompleted_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(WorkflowCompleted& a, WorkflowCompleted& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkflowCompleted* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkflowCompleted* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorkflowCompleted* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WorkflowCompleted>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WorkflowCompleted& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WorkflowCompleted& from) {
    WorkflowCompleted::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkflowCompleted* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.WorkflowCompleted";
  }
  protected:
  explicit WorkflowCompleted(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFinalOutputFieldNumber = 1,
    kTotalStepsFieldNumber = 2,
    kTotalDurationMsFieldNumber = 3,
  };
  // .google.protobuf.Struct final_output = 1;
  bool has_final_output() const;
  private:
  bool _internal_has_final_output() const;
  public:
  void clear_final_output();
  const ::PROTOBUF_NAMESPACE_ID::Struct& final_output() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_final_output();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_final_output();
  void set_allocated_final_output(::PROTOBUF_NAMESPACE_ID::Struct* final_output);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_final_output() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_final_output();
  public:
  void unsafe_arena_set_allocated_final_output(
      ::PROTOBUF_NAMESPACE_ID::Struct* final_output);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_final_output();

  // int32 total_steps = 2;
  void clear_total_steps();
  int32_t total_steps() const;
  void set_total_steps(int32_t value);
  private:
  int32_t _internal_total_steps() const;
  void _internal_set_total_steps(int32_t value);
  public:

  // float total_duration_ms = 3;
  void clear_total_duration_ms();
  float total_duration_ms() const;
  void set_total_duration_ms(float value);
  private:
  float _internal_total_duration_ms() const;
  void _internal_set_total_duration_ms(float value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.cdc.WorkflowCompleted)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::Struct* final_output_;
    int32_t total_steps_;
    float total_duration_ms_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fevents_2eproto;
};
// -------------------------------------------------------------------

class WorkflowFailed final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.WorkflowFailed) */ {
 public:
  inline WorkflowFailed() : WorkflowFailed(nullptr) {}
  ~WorkflowFailed() override;
  explicit PROTOBUF_CONSTEXPR WorkflowFailed(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WorkflowFailed(const WorkflowFailed& from);
  WorkflowFailed(WorkflowFailed&& from) noexcept
    : WorkflowFailed() {
    *this = ::std::move(from);
  }

  inline WorkflowFailed& operator=(const WorkflowFailed& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkflowFailed& operator=(WorkflowFailed&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkflowFailed& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorkflowFailed* internal_default_instance() {
    return reinterpret_cast<const WorkflowFailed*>(
               &_WorkflowFailed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(WorkflowFailed& a, WorkflowFailed& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkflowFailed* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkflowFailed* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorkflowFailed* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WorkflowFailed>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WorkflowFailed& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WorkflowFailed& from) {
    WorkflowFailed::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkflowFailed* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.WorkflowFailed";
  }
  protected:
  explicit WorkflowFailed(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFailureStepIdFieldNumber = 1,
    kFailureReasonFieldNumber = 2,
    kErrorMessageFieldNumber = 3,
  };
  // string failure_step_id = 1;
  void clear_failure_step_id();
  const std::string& failure_step_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_failure_step_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_failure_step_id();
  PROTOBUF_NODISCARD std::string* release_failure_step_id();
  void set_allocated_failure_step_id(std::string* failure_step_id);
  private:
  const std::string& _internal_failure_step_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_failure_step_id(const std::string& value);
  std::string* _internal_mutable_failure_step_id();
  public:

  // string failure_reason = 2;
  void clear_failure_reason();
  const std::string& failure_reason() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_failure_reason(ArgT0&& arg0, ArgT... args);
  std::string* mutable_failure_reason();
  PROTOBUF_NODISCARD std::string* release_failure_reason();
  void set_allocated_failure_reason(std::string* failure_reason);
  private:
  const std::string& _internal_failure_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_failure_reason(const std::string& value);
  std::string* _internal_mutable_failure_reason();
  public:

  // string error_message = 3;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // @@protoc_insertion_point(class_scope:unhinged.cdc.WorkflowFailed)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr failure_step_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr failure_reason_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fevents_2eproto;
};
// -------------------------------------------------------------------

class ChatEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.ChatEvent) */ {
 public:
  inline ChatEvent() : ChatEvent(nullptr) {}
  ~ChatEvent() override;
  explicit PROTOBUF_CONSTEXPR ChatEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChatEvent(const ChatEvent& from);
  ChatEvent(ChatEvent&& from) noexcept
    : ChatEvent() {
    *this = ::std::move(from);
  }

  inline ChatEvent& operator=(const ChatEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatEvent& operator=(ChatEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChatEvent& default_instance() {
    return *internal_default_instance();
  }
  enum EventDataCase {
    kConversationCreated = 10,
    kMessageSent = 11,
    kMessageUpdated = 12,
    kTypingStarted = 13,
    kParticipantJoined = 14,
    EVENT_DATA_NOT_SET = 0,
  };

  static inline const ChatEvent* internal_default_instance() {
    return reinterpret_cast<const ChatEvent*>(
               &_ChatEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(ChatEvent& a, ChatEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(ChatEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChatEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChatEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChatEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChatEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChatEvent& from) {
    ChatEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChatEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.ChatEvent";
  }
  protected:
  explicit ChatEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConversationIdFieldNumber = 1,
    kMessageIdFieldNumber = 2,
    kEventTypeFieldNumber = 3,
    kConversationCreatedFieldNumber = 10,
    kMessageSentFieldNumber = 11,
    kMessageUpdatedFieldNumber = 12,
    kTypingStartedFieldNumber = 13,
    kParticipantJoinedFieldNumber = 14,
  };
  // string conversation_id = 1;
  void clear_conversation_id();
  const std::string& conversation_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_conversation_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_conversation_id();
  PROTOBUF_NODISCARD std::string* release_conversation_id();
  void set_allocated_conversation_id(std::string* conversation_id);
  private:
  const std::string& _internal_conversation_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_conversation_id(const std::string& value);
  std::string* _internal_mutable_conversation_id();
  public:

  // string message_id = 2;
  void clear_message_id();
  const std::string& message_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message_id();
  PROTOBUF_NODISCARD std::string* release_message_id();
  void set_allocated_message_id(std::string* message_id);
  private:
  const std::string& _internal_message_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message_id(const std::string& value);
  std::string* _internal_mutable_message_id();
  public:

  // .unhinged.cdc.ChatEventType event_type = 3;
  void clear_event_type();
  ::unhinged::cdc::ChatEventType event_type() const;
  void set_event_type(::unhinged::cdc::ChatEventType value);
  private:
  ::unhinged::cdc::ChatEventType _internal_event_type() const;
  void _internal_set_event_type(::unhinged::cdc::ChatEventType value);
  public:

  // .unhinged.cdc.ConversationCreated conversation_created = 10;
  bool has_conversation_created() const;
  private:
  bool _internal_has_conversation_created() const;
  public:
  void clear_conversation_created();
  const ::unhinged::cdc::ConversationCreated& conversation_created() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::ConversationCreated* release_conversation_created();
  ::unhinged::cdc::ConversationCreated* mutable_conversation_created();
  void set_allocated_conversation_created(::unhinged::cdc::ConversationCreated* conversation_created);
  private:
  const ::unhinged::cdc::ConversationCreated& _internal_conversation_created() const;
  ::unhinged::cdc::ConversationCreated* _internal_mutable_conversation_created();
  public:
  void unsafe_arena_set_allocated_conversation_created(
      ::unhinged::cdc::ConversationCreated* conversation_created);
  ::unhinged::cdc::ConversationCreated* unsafe_arena_release_conversation_created();

  // .unhinged.cdc.MessageSent message_sent = 11;
  bool has_message_sent() const;
  private:
  bool _internal_has_message_sent() const;
  public:
  void clear_message_sent();
  const ::unhinged::cdc::MessageSent& message_sent() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::MessageSent* release_message_sent();
  ::unhinged::cdc::MessageSent* mutable_message_sent();
  void set_allocated_message_sent(::unhinged::cdc::MessageSent* message_sent);
  private:
  const ::unhinged::cdc::MessageSent& _internal_message_sent() const;
  ::unhinged::cdc::MessageSent* _internal_mutable_message_sent();
  public:
  void unsafe_arena_set_allocated_message_sent(
      ::unhinged::cdc::MessageSent* message_sent);
  ::unhinged::cdc::MessageSent* unsafe_arena_release_message_sent();

  // .unhinged.cdc.MessageUpdated message_updated = 12;
  bool has_message_updated() const;
  private:
  bool _internal_has_message_updated() const;
  public:
  void clear_message_updated();
  const ::unhinged::cdc::MessageUpdated& message_updated() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::MessageUpdated* release_message_updated();
  ::unhinged::cdc::MessageUpdated* mutable_message_updated();
  void set_allocated_message_updated(::unhinged::cdc::MessageUpdated* message_updated);
  private:
  const ::unhinged::cdc::MessageUpdated& _internal_message_updated() const;
  ::unhinged::cdc::MessageUpdated* _internal_mutable_message_updated();
  public:
  void unsafe_arena_set_allocated_message_updated(
      ::unhinged::cdc::MessageUpdated* message_updated);
  ::unhinged::cdc::MessageUpdated* unsafe_arena_release_message_updated();

  // .unhinged.cdc.TypingStarted typing_started = 13;
  bool has_typing_started() const;
  private:
  bool _internal_has_typing_started() const;
  public:
  void clear_typing_started();
  const ::unhinged::cdc::TypingStarted& typing_started() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::TypingStarted* release_typing_started();
  ::unhinged::cdc::TypingStarted* mutable_typing_started();
  void set_allocated_typing_started(::unhinged::cdc::TypingStarted* typing_started);
  private:
  const ::unhinged::cdc::TypingStarted& _internal_typing_started() const;
  ::unhinged::cdc::TypingStarted* _internal_mutable_typing_started();
  public:
  void unsafe_arena_set_allocated_typing_started(
      ::unhinged::cdc::TypingStarted* typing_started);
  ::unhinged::cdc::TypingStarted* unsafe_arena_release_typing_started();

  // .unhinged.cdc.ParticipantJoined participant_joined = 14;
  bool has_participant_joined() const;
  private:
  bool _internal_has_participant_joined() const;
  public:
  void clear_participant_joined();
  const ::unhinged::cdc::ParticipantJoined& participant_joined() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::ParticipantJoined* release_participant_joined();
  ::unhinged::cdc::ParticipantJoined* mutable_participant_joined();
  void set_allocated_participant_joined(::unhinged::cdc::ParticipantJoined* participant_joined);
  private:
  const ::unhinged::cdc::ParticipantJoined& _internal_participant_joined() const;
  ::unhinged::cdc::ParticipantJoined* _internal_mutable_participant_joined();
  public:
  void unsafe_arena_set_allocated_participant_joined(
      ::unhinged::cdc::ParticipantJoined* participant_joined);
  ::unhinged::cdc::ParticipantJoined* unsafe_arena_release_participant_joined();

  void clear_event_data();
  EventDataCase event_data_case() const;
  // @@protoc_insertion_point(class_scope:unhinged.cdc.ChatEvent)
 private:
  class _Internal;
  void set_has_conversation_created();
  void set_has_message_sent();
  void set_has_message_updated();
  void set_has_typing_started();
  void set_has_participant_joined();

  inline bool has_event_data() const;
  inline void clear_has_event_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr conversation_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_id_;
    int event_type_;
    union EventDataUnion {
      constexpr EventDataUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::unhinged::cdc::ConversationCreated* conversation_created_;
      ::unhinged::cdc::MessageSent* message_sent_;
      ::unhinged::cdc::MessageUpdated* message_updated_;
      ::unhinged::cdc::TypingStarted* typing_started_;
      ::unhinged::cdc::ParticipantJoined* participant_joined_;
    } event_data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fevents_2eproto;
};
// -------------------------------------------------------------------

class ConversationCreated final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.ConversationCreated) */ {
 public:
  inline ConversationCreated() : ConversationCreated(nullptr) {}
  ~ConversationCreated() override;
  explicit PROTOBUF_CONSTEXPR ConversationCreated(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConversationCreated(const ConversationCreated& from);
  ConversationCreated(ConversationCreated&& from) noexcept
    : ConversationCreated() {
    *this = ::std::move(from);
  }

  inline ConversationCreated& operator=(const ConversationCreated& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConversationCreated& operator=(ConversationCreated&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConversationCreated& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConversationCreated* internal_default_instance() {
    return reinterpret_cast<const ConversationCreated*>(
               &_ConversationCreated_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(ConversationCreated& a, ConversationCreated& b) {
    a.Swap(&b);
  }
  inline void Swap(ConversationCreated* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConversationCreated* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConversationCreated* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConversationCreated>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConversationCreated& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConversationCreated& from) {
    ConversationCreated::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConversationCreated* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.ConversationCreated";
  }
  protected:
  explicit ConversationCreated(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParticipantIdsFieldNumber = 3,
    kTitleFieldNumber = 1,
    kCreatedByFieldNumber = 2,
  };
  // repeated string participant_ids = 3;
  int participant_ids_size() const;
  private:
  int _internal_participant_ids_size() const;
  public:
  void clear_participant_ids();
  const std::string& participant_ids(int index) const;
  std::string* mutable_participant_ids(int index);
  void set_participant_ids(int index, const std::string& value);
  void set_participant_ids(int index, std::string&& value);
  void set_participant_ids(int index, const char* value);
  void set_participant_ids(int index, const char* value, size_t size);
  std::string* add_participant_ids();
  void add_participant_ids(const std::string& value);
  void add_participant_ids(std::string&& value);
  void add_participant_ids(const char* value);
  void add_participant_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& participant_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_participant_ids();
  private:
  const std::string& _internal_participant_ids(int index) const;
  std::string* _internal_add_participant_ids();
  public:

  // string title = 1;
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // string created_by = 2;
  void clear_created_by();
  const std::string& created_by() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_created_by(ArgT0&& arg0, ArgT... args);
  std::string* mutable_created_by();
  PROTOBUF_NODISCARD std::string* release_created_by();
  void set_allocated_created_by(std::string* created_by);
  private:
  const std::string& _internal_created_by() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_created_by(const std::string& value);
  std::string* _internal_mutable_created_by();
  public:

  // @@protoc_insertion_point(class_scope:unhinged.cdc.ConversationCreated)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> participant_ids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr created_by_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fevents_2eproto;
};
// -------------------------------------------------------------------

class MessageSent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.MessageSent) */ {
 public:
  inline MessageSent() : MessageSent(nullptr) {}
  ~MessageSent() override;
  explicit PROTOBUF_CONSTEXPR MessageSent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MessageSent(const MessageSent& from);
  MessageSent(MessageSent&& from) noexcept
    : MessageSent() {
    *this = ::std::move(from);
  }

  inline MessageSent& operator=(const MessageSent& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessageSent& operator=(MessageSent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MessageSent& default_instance() {
    return *internal_default_instance();
  }
  static inline const MessageSent* internal_default_instance() {
    return reinterpret_cast<const MessageSent*>(
               &_MessageSent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(MessageSent& a, MessageSent& b) {
    a.Swap(&b);
  }
  inline void Swap(MessageSent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessageSent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MessageSent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MessageSent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MessageSent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MessageSent& from) {
    MessageSent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessageSent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.MessageSent";
  }
  protected:
  explicit MessageSent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentFieldNumber = 1,
    kRoleFieldNumber = 2,
    kSentByFieldNumber = 3,
  };
  // string content = 1;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // string role = 2;
  void clear_role();
  const std::string& role() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_role(ArgT0&& arg0, ArgT... args);
  std::string* mutable_role();
  PROTOBUF_NODISCARD std::string* release_role();
  void set_allocated_role(std::string* role);
  private:
  const std::string& _internal_role() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_role(const std::string& value);
  std::string* _internal_mutable_role();
  public:

  // string sent_by = 3;
  void clear_sent_by();
  const std::string& sent_by() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sent_by(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sent_by();
  PROTOBUF_NODISCARD std::string* release_sent_by();
  void set_allocated_sent_by(std::string* sent_by);
  private:
  const std::string& _internal_sent_by() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sent_by(const std::string& value);
  std::string* _internal_mutable_sent_by();
  public:

  // @@protoc_insertion_point(class_scope:unhinged.cdc.MessageSent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr role_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sent_by_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fevents_2eproto;
};
// -------------------------------------------------------------------

class MessageUpdated final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.MessageUpdated) */ {
 public:
  inline MessageUpdated() : MessageUpdated(nullptr) {}
  ~MessageUpdated() override;
  explicit PROTOBUF_CONSTEXPR MessageUpdated(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MessageUpdated(const MessageUpdated& from);
  MessageUpdated(MessageUpdated&& from) noexcept
    : MessageUpdated() {
    *this = ::std::move(from);
  }

  inline MessageUpdated& operator=(const MessageUpdated& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessageUpdated& operator=(MessageUpdated&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MessageUpdated& default_instance() {
    return *internal_default_instance();
  }
  static inline const MessageUpdated* internal_default_instance() {
    return reinterpret_cast<const MessageUpdated*>(
               &_MessageUpdated_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(MessageUpdated& a, MessageUpdated& b) {
    a.Swap(&b);
  }
  inline void Swap(MessageUpdated* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessageUpdated* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MessageUpdated* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MessageUpdated>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MessageUpdated& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MessageUpdated& from) {
    MessageUpdated::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessageUpdated* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.MessageUpdated";
  }
  protected:
  explicit MessageUpdated(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentFieldNumber = 1,
    kUpdatedByFieldNumber = 2,
  };
  // string content = 1;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // string updated_by = 2;
  void clear_updated_by();
  const std::string& updated_by() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_updated_by(ArgT0&& arg0, ArgT... args);
  std::string* mutable_updated_by();
  PROTOBUF_NODISCARD std::string* release_updated_by();
  void set_allocated_updated_by(std::string* updated_by);
  private:
  const std::string& _internal_updated_by() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_updated_by(const std::string& value);
  std::string* _internal_mutable_updated_by();
  public:

  // @@protoc_insertion_point(class_scope:unhinged.cdc.MessageUpdated)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr updated_by_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fevents_2eproto;
};
// -------------------------------------------------------------------

class TypingStarted final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.TypingStarted) */ {
 public:
  inline TypingStarted() : TypingStarted(nullptr) {}
  ~TypingStarted() override;
  explicit PROTOBUF_CONSTEXPR TypingStarted(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TypingStarted(const TypingStarted& from);
  TypingStarted(TypingStarted&& from) noexcept
    : TypingStarted() {
    *this = ::std::move(from);
  }

  inline TypingStarted& operator=(const TypingStarted& from) {
    CopyFrom(from);
    return *this;
  }
  inline TypingStarted& operator=(TypingStarted&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TypingStarted& default_instance() {
    return *internal_default_instance();
  }
  static inline const TypingStarted* internal_default_instance() {
    return reinterpret_cast<const TypingStarted*>(
               &_TypingStarted_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(TypingStarted& a, TypingStarted& b) {
    a.Swap(&b);
  }
  inline void Swap(TypingStarted* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TypingStarted* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TypingStarted* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TypingStarted>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TypingStarted& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TypingStarted& from) {
    TypingStarted::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TypingStarted* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.TypingStarted";
  }
  protected:
  explicit TypingStarted(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
  };
  // string user_id = 1;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // @@protoc_insertion_point(class_scope:unhinged.cdc.TypingStarted)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fevents_2eproto;
};
// -------------------------------------------------------------------

class ParticipantJoined final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.ParticipantJoined) */ {
 public:
  inline ParticipantJoined() : ParticipantJoined(nullptr) {}
  ~ParticipantJoined() override;
  explicit PROTOBUF_CONSTEXPR ParticipantJoined(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ParticipantJoined(const ParticipantJoined& from);
  ParticipantJoined(ParticipantJoined&& from) noexcept
    : ParticipantJoined() {
    *this = ::std::move(from);
  }

  inline ParticipantJoined& operator=(const ParticipantJoined& from) {
    CopyFrom(from);
    return *this;
  }
  inline ParticipantJoined& operator=(ParticipantJoined&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ParticipantJoined& default_instance() {
    return *internal_default_instance();
  }
  static inline const ParticipantJoined* internal_default_instance() {
    return reinterpret_cast<const ParticipantJoined*>(
               &_ParticipantJoined_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(ParticipantJoined& a, ParticipantJoined& b) {
    a.Swap(&b);
  }
  inline void Swap(ParticipantJoined* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ParticipantJoined* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ParticipantJoined* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ParticipantJoined>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ParticipantJoined& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ParticipantJoined& from) {
    ParticipantJoined::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ParticipantJoined* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.ParticipantJoined";
  }
  protected:
  explicit ParticipantJoined(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kInvitedByFieldNumber = 2,
  };
  // string user_id = 1;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string invited_by = 2;
  void clear_invited_by();
  const std::string& invited_by() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_invited_by(ArgT0&& arg0, ArgT... args);
  std::string* mutable_invited_by();
  PROTOBUF_NODISCARD std::string* release_invited_by();
  void set_allocated_invited_by(std::string* invited_by);
  private:
  const std::string& _internal_invited_by() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_invited_by(const std::string& value);
  std::string* _internal_mutable_invited_by();
  public:

  // @@protoc_insertion_point(class_scope:unhinged.cdc.ParticipantJoined)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr invited_by_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fevents_2eproto;
};
// -------------------------------------------------------------------

class AudioEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.AudioEvent) */ {
 public:
  inline AudioEvent() : AudioEvent(nullptr) {}
  ~AudioEvent() override;
  explicit PROTOBUF_CONSTEXPR AudioEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AudioEvent(const AudioEvent& from);
  AudioEvent(AudioEvent&& from) noexcept
    : AudioEvent() {
    *this = ::std::move(from);
  }

  inline AudioEvent& operator=(const AudioEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioEvent& operator=(AudioEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AudioEvent& default_instance() {
    return *internal_default_instance();
  }
  enum EventDataCase {
    kTtsStarted = 10,
    kTtsCompleted = 11,
    kSttCompleted = 12,
    EVENT_DATA_NOT_SET = 0,
  };

  static inline const AudioEvent* internal_default_instance() {
    return reinterpret_cast<const AudioEvent*>(
               &_AudioEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(AudioEvent& a, AudioEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AudioEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AudioEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AudioEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AudioEvent& from) {
    AudioEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AudioEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.AudioEvent";
  }
  protected:
  explicit AudioEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAudioIdFieldNumber = 1,
    kEventTypeFieldNumber = 2,
    kTtsStartedFieldNumber = 10,
    kTtsCompletedFieldNumber = 11,
    kSttCompletedFieldNumber = 12,
  };
  // string audio_id = 1;
  void clear_audio_id();
  const std::string& audio_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_audio_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_audio_id();
  PROTOBUF_NODISCARD std::string* release_audio_id();
  void set_allocated_audio_id(std::string* audio_id);
  private:
  const std::string& _internal_audio_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_audio_id(const std::string& value);
  std::string* _internal_mutable_audio_id();
  public:

  // .unhinged.cdc.AudioEventType event_type = 2;
  void clear_event_type();
  ::unhinged::cdc::AudioEventType event_type() const;
  void set_event_type(::unhinged::cdc::AudioEventType value);
  private:
  ::unhinged::cdc::AudioEventType _internal_event_type() const;
  void _internal_set_event_type(::unhinged::cdc::AudioEventType value);
  public:

  // .unhinged.cdc.TTSStarted tts_started = 10;
  bool has_tts_started() const;
  private:
  bool _internal_has_tts_started() const;
  public:
  void clear_tts_started();
  const ::unhinged::cdc::TTSStarted& tts_started() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::TTSStarted* release_tts_started();
  ::unhinged::cdc::TTSStarted* mutable_tts_started();
  void set_allocated_tts_started(::unhinged::cdc::TTSStarted* tts_started);
  private:
  const ::unhinged::cdc::TTSStarted& _internal_tts_started() const;
  ::unhinged::cdc::TTSStarted* _internal_mutable_tts_started();
  public:
  void unsafe_arena_set_allocated_tts_started(
      ::unhinged::cdc::TTSStarted* tts_started);
  ::unhinged::cdc::TTSStarted* unsafe_arena_release_tts_started();

  // .unhinged.cdc.TTSCompleted tts_completed = 11;
  bool has_tts_completed() const;
  private:
  bool _internal_has_tts_completed() const;
  public:
  void clear_tts_completed();
  const ::unhinged::cdc::TTSCompleted& tts_completed() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::TTSCompleted* release_tts_completed();
  ::unhinged::cdc::TTSCompleted* mutable_tts_completed();
  void set_allocated_tts_completed(::unhinged::cdc::TTSCompleted* tts_completed);
  private:
  const ::unhinged::cdc::TTSCompleted& _internal_tts_completed() const;
  ::unhinged::cdc::TTSCompleted* _internal_mutable_tts_completed();
  public:
  void unsafe_arena_set_allocated_tts_completed(
      ::unhinged::cdc::TTSCompleted* tts_completed);
  ::unhinged::cdc::TTSCompleted* unsafe_arena_release_tts_completed();

  // .unhinged.cdc.STTCompleted stt_completed = 12;
  bool has_stt_completed() const;
  private:
  bool _internal_has_stt_completed() const;
  public:
  void clear_stt_completed();
  const ::unhinged::cdc::STTCompleted& stt_completed() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::STTCompleted* release_stt_completed();
  ::unhinged::cdc::STTCompleted* mutable_stt_completed();
  void set_allocated_stt_completed(::unhinged::cdc::STTCompleted* stt_completed);
  private:
  const ::unhinged::cdc::STTCompleted& _internal_stt_completed() const;
  ::unhinged::cdc::STTCompleted* _internal_mutable_stt_completed();
  public:
  void unsafe_arena_set_allocated_stt_completed(
      ::unhinged::cdc::STTCompleted* stt_completed);
  ::unhinged::cdc::STTCompleted* unsafe_arena_release_stt_completed();

  void clear_event_data();
  EventDataCase event_data_case() const;
  // @@protoc_insertion_point(class_scope:unhinged.cdc.AudioEvent)
 private:
  class _Internal;
  void set_has_tts_started();
  void set_has_tts_completed();
  void set_has_stt_completed();

  inline bool has_event_data() const;
  inline void clear_has_event_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr audio_id_;
    int event_type_;
    union EventDataUnion {
      constexpr EventDataUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::unhinged::cdc::TTSStarted* tts_started_;
      ::unhinged::cdc::TTSCompleted* tts_completed_;
      ::unhinged::cdc::STTCompleted* stt_completed_;
    } event_data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fevents_2eproto;
};
// -------------------------------------------------------------------

class TTSStarted final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.TTSStarted) */ {
 public:
  inline TTSStarted() : TTSStarted(nullptr) {}
  ~TTSStarted() override;
  explicit PROTOBUF_CONSTEXPR TTSStarted(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TTSStarted(const TTSStarted& from);
  TTSStarted(TTSStarted&& from) noexcept
    : TTSStarted() {
    *this = ::std::move(from);
  }

  inline TTSStarted& operator=(const TTSStarted& from) {
    CopyFrom(from);
    return *this;
  }
  inline TTSStarted& operator=(TTSStarted&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TTSStarted& default_instance() {
    return *internal_default_instance();
  }
  static inline const TTSStarted* internal_default_instance() {
    return reinterpret_cast<const TTSStarted*>(
               &_TTSStarted_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(TTSStarted& a, TTSStarted& b) {
    a.Swap(&b);
  }
  inline void Swap(TTSStarted* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TTSStarted* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TTSStarted* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TTSStarted>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TTSStarted& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TTSStarted& from) {
    TTSStarted::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TTSStarted* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.TTSStarted";
  }
  protected:
  explicit TTSStarted(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
    kVoiceIdFieldNumber = 2,
  };
  // string text = 1;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // string voice_id = 2;
  void clear_voice_id();
  const std::string& voice_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_voice_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_voice_id();
  PROTOBUF_NODISCARD std::string* release_voice_id();
  void set_allocated_voice_id(std::string* voice_id);
  private:
  const std::string& _internal_voice_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_voice_id(const std::string& value);
  std::string* _internal_mutable_voice_id();
  public:

  // @@protoc_insertion_point(class_scope:unhinged.cdc.TTSStarted)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr voice_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fevents_2eproto;
};
// -------------------------------------------------------------------

class TTSCompleted final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.TTSCompleted) */ {
 public:
  inline TTSCompleted() : TTSCompleted(nullptr) {}
  ~TTSCompleted() override;
  explicit PROTOBUF_CONSTEXPR TTSCompleted(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TTSCompleted(const TTSCompleted& from);
  TTSCompleted(TTSCompleted&& from) noexcept
    : TTSCompleted() {
    *this = ::std::move(from);
  }

  inline TTSCompleted& operator=(const TTSCompleted& from) {
    CopyFrom(from);
    return *this;
  }
  inline TTSCompleted& operator=(TTSCompleted&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TTSCompleted& default_instance() {
    return *internal_default_instance();
  }
  static inline const TTSCompleted* internal_default_instance() {
    return reinterpret_cast<const TTSCompleted*>(
               &_TTSCompleted_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(TTSCompleted& a, TTSCompleted& b) {
    a.Swap(&b);
  }
  inline void Swap(TTSCompleted* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TTSCompleted* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TTSCompleted* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TTSCompleted>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TTSCompleted& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TTSCompleted& from) {
    TTSCompleted::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TTSCompleted* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.TTSCompleted";
  }
  protected:
  explicit TTSCompleted(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAudioUrlFieldNumber = 1,
    kDurationSecondsFieldNumber = 2,
  };
  // string audio_url = 1;
  void clear_audio_url();
  const std::string& audio_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_audio_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_audio_url();
  PROTOBUF_NODISCARD std::string* release_audio_url();
  void set_allocated_audio_url(std::string* audio_url);
  private:
  const std::string& _internal_audio_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_audio_url(const std::string& value);
  std::string* _internal_mutable_audio_url();
  public:

  // float duration_seconds = 2;
  void clear_duration_seconds();
  float duration_seconds() const;
  void set_duration_seconds(float value);
  private:
  float _internal_duration_seconds() const;
  void _internal_set_duration_seconds(float value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.cdc.TTSCompleted)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr audio_url_;
    float duration_seconds_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fevents_2eproto;
};
// -------------------------------------------------------------------

class STTCompleted final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.STTCompleted) */ {
 public:
  inline STTCompleted() : STTCompleted(nullptr) {}
  ~STTCompleted() override;
  explicit PROTOBUF_CONSTEXPR STTCompleted(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  STTCompleted(const STTCompleted& from);
  STTCompleted(STTCompleted&& from) noexcept
    : STTCompleted() {
    *this = ::std::move(from);
  }

  inline STTCompleted& operator=(const STTCompleted& from) {
    CopyFrom(from);
    return *this;
  }
  inline STTCompleted& operator=(STTCompleted&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const STTCompleted& default_instance() {
    return *internal_default_instance();
  }
  static inline const STTCompleted* internal_default_instance() {
    return reinterpret_cast<const STTCompleted*>(
               &_STTCompleted_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(STTCompleted& a, STTCompleted& b) {
    a.Swap(&b);
  }
  inline void Swap(STTCompleted* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(STTCompleted* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  STTCompleted* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<STTCompleted>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const STTCompleted& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const STTCompleted& from) {
    STTCompleted::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(STTCompleted* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.STTCompleted";
  }
  protected:
  explicit STTCompleted(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTranscriptFieldNumber = 1,
    kConfidenceFieldNumber = 2,
  };
  // string transcript = 1;
  void clear_transcript();
  const std::string& transcript() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_transcript(ArgT0&& arg0, ArgT... args);
  std::string* mutable_transcript();
  PROTOBUF_NODISCARD std::string* release_transcript();
  void set_allocated_transcript(std::string* transcript);
  private:
  const std::string& _internal_transcript() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transcript(const std::string& value);
  std::string* _internal_mutable_transcript();
  public:

  // float confidence = 2;
  void clear_confidence();
  float confidence() const;
  void set_confidence(float value);
  private:
  float _internal_confidence() const;
  void _internal_set_confidence(float value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.cdc.STTCompleted)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transcript_;
    float confidence_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fevents_2eproto;
};
// -------------------------------------------------------------------

class UserEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.UserEvent) */ {
 public:
  inline UserEvent() : UserEvent(nullptr) {}
  ~UserEvent() override;
  explicit PROTOBUF_CONSTEXPR UserEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserEvent(const UserEvent& from);
  UserEvent(UserEvent&& from) noexcept
    : UserEvent() {
    *this = ::std::move(from);
  }

  inline UserEvent& operator=(const UserEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserEvent& operator=(UserEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserEvent& default_instance() {
    return *internal_default_instance();
  }
  enum EventDataCase {
    kUserCreated = 10,
    kUserLoggedIn = 11,
    kTeamMemberAdded = 12,
    EVENT_DATA_NOT_SET = 0,
  };

  static inline const UserEvent* internal_default_instance() {
    return reinterpret_cast<const UserEvent*>(
               &_UserEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(UserEvent& a, UserEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(UserEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserEvent& from) {
    UserEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.UserEvent";
  }
  protected:
  explicit UserEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kEventTypeFieldNumber = 2,
    kUserCreatedFieldNumber = 10,
    kUserLoggedInFieldNumber = 11,
    kTeamMemberAddedFieldNumber = 12,
  };
  // string user_id = 1;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // .unhinged.cdc.UserEventType event_type = 2;
  void clear_event_type();
  ::unhinged::cdc::UserEventType event_type() const;
  void set_event_type(::unhinged::cdc::UserEventType value);
  private:
  ::unhinged::cdc::UserEventType _internal_event_type() const;
  void _internal_set_event_type(::unhinged::cdc::UserEventType value);
  public:

  // .unhinged.cdc.UserCreated user_created = 10;
  bool has_user_created() const;
  private:
  bool _internal_has_user_created() const;
  public:
  void clear_user_created();
  const ::unhinged::cdc::UserCreated& user_created() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::UserCreated* release_user_created();
  ::unhinged::cdc::UserCreated* mutable_user_created();
  void set_allocated_user_created(::unhinged::cdc::UserCreated* user_created);
  private:
  const ::unhinged::cdc::UserCreated& _internal_user_created() const;
  ::unhinged::cdc::UserCreated* _internal_mutable_user_created();
  public:
  void unsafe_arena_set_allocated_user_created(
      ::unhinged::cdc::UserCreated* user_created);
  ::unhinged::cdc::UserCreated* unsafe_arena_release_user_created();

  // .unhinged.cdc.UserLoggedIn user_logged_in = 11;
  bool has_user_logged_in() const;
  private:
  bool _internal_has_user_logged_in() const;
  public:
  void clear_user_logged_in();
  const ::unhinged::cdc::UserLoggedIn& user_logged_in() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::UserLoggedIn* release_user_logged_in();
  ::unhinged::cdc::UserLoggedIn* mutable_user_logged_in();
  void set_allocated_user_logged_in(::unhinged::cdc::UserLoggedIn* user_logged_in);
  private:
  const ::unhinged::cdc::UserLoggedIn& _internal_user_logged_in() const;
  ::unhinged::cdc::UserLoggedIn* _internal_mutable_user_logged_in();
  public:
  void unsafe_arena_set_allocated_user_logged_in(
      ::unhinged::cdc::UserLoggedIn* user_logged_in);
  ::unhinged::cdc::UserLoggedIn* unsafe_arena_release_user_logged_in();

  // .unhinged.cdc.TeamMemberAdded team_member_added = 12;
  bool has_team_member_added() const;
  private:
  bool _internal_has_team_member_added() const;
  public:
  void clear_team_member_added();
  const ::unhinged::cdc::TeamMemberAdded& team_member_added() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::TeamMemberAdded* release_team_member_added();
  ::unhinged::cdc::TeamMemberAdded* mutable_team_member_added();
  void set_allocated_team_member_added(::unhinged::cdc::TeamMemberAdded* team_member_added);
  private:
  const ::unhinged::cdc::TeamMemberAdded& _internal_team_member_added() const;
  ::unhinged::cdc::TeamMemberAdded* _internal_mutable_team_member_added();
  public:
  void unsafe_arena_set_allocated_team_member_added(
      ::unhinged::cdc::TeamMemberAdded* team_member_added);
  ::unhinged::cdc::TeamMemberAdded* unsafe_arena_release_team_member_added();

  void clear_event_data();
  EventDataCase event_data_case() const;
  // @@protoc_insertion_point(class_scope:unhinged.cdc.UserEvent)
 private:
  class _Internal;
  void set_has_user_created();
  void set_has_user_logged_in();
  void set_has_team_member_added();

  inline bool has_event_data() const;
  inline void clear_has_event_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    int event_type_;
    union EventDataUnion {
      constexpr EventDataUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::unhinged::cdc::UserCreated* user_created_;
      ::unhinged::cdc::UserLoggedIn* user_logged_in_;
      ::unhinged::cdc::TeamMemberAdded* team_member_added_;
    } event_data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fevents_2eproto;
};
// -------------------------------------------------------------------

class UserCreated final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.UserCreated) */ {
 public:
  inline UserCreated() : UserCreated(nullptr) {}
  ~UserCreated() override;
  explicit PROTOBUF_CONSTEXPR UserCreated(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserCreated(const UserCreated& from);
  UserCreated(UserCreated&& from) noexcept
    : UserCreated() {
    *this = ::std::move(from);
  }

  inline UserCreated& operator=(const UserCreated& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserCreated& operator=(UserCreated&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserCreated& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserCreated* internal_default_instance() {
    return reinterpret_cast<const UserCreated*>(
               &_UserCreated_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(UserCreated& a, UserCreated& b) {
    a.Swap(&b);
  }
  inline void Swap(UserCreated* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserCreated* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserCreated* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserCreated>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserCreated& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserCreated& from) {
    UserCreated::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserCreated* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.UserCreated";
  }
  protected:
  explicit UserCreated(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEmailFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // string email = 1;
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:unhinged.cdc.UserCreated)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fevents_2eproto;
};
// -------------------------------------------------------------------

class UserLoggedIn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.UserLoggedIn) */ {
 public:
  inline UserLoggedIn() : UserLoggedIn(nullptr) {}
  ~UserLoggedIn() override;
  explicit PROTOBUF_CONSTEXPR UserLoggedIn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserLoggedIn(const UserLoggedIn& from);
  UserLoggedIn(UserLoggedIn&& from) noexcept
    : UserLoggedIn() {
    *this = ::std::move(from);
  }

  inline UserLoggedIn& operator=(const UserLoggedIn& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserLoggedIn& operator=(UserLoggedIn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserLoggedIn& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserLoggedIn* internal_default_instance() {
    return reinterpret_cast<const UserLoggedIn*>(
               &_UserLoggedIn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(UserLoggedIn& a, UserLoggedIn& b) {
    a.Swap(&b);
  }
  inline void Swap(UserLoggedIn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserLoggedIn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserLoggedIn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserLoggedIn>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserLoggedIn& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserLoggedIn& from) {
    UserLoggedIn::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserLoggedIn* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.UserLoggedIn";
  }
  protected:
  explicit UserLoggedIn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpAddressFieldNumber = 1,
    kUserAgentFieldNumber = 2,
  };
  // string ip_address = 1;
  void clear_ip_address();
  const std::string& ip_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip_address();
  PROTOBUF_NODISCARD std::string* release_ip_address();
  void set_allocated_ip_address(std::string* ip_address);
  private:
  const std::string& _internal_ip_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip_address(const std::string& value);
  std::string* _internal_mutable_ip_address();
  public:

  // string user_agent = 2;
  void clear_user_agent();
  const std::string& user_agent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_agent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_agent();
  PROTOBUF_NODISCARD std::string* release_user_agent();
  void set_allocated_user_agent(std::string* user_agent);
  private:
  const std::string& _internal_user_agent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_agent(const std::string& value);
  std::string* _internal_mutable_user_agent();
  public:

  // @@protoc_insertion_point(class_scope:unhinged.cdc.UserLoggedIn)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_agent_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fevents_2eproto;
};
// -------------------------------------------------------------------

class TeamMemberAdded final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.TeamMemberAdded) */ {
 public:
  inline TeamMemberAdded() : TeamMemberAdded(nullptr) {}
  ~TeamMemberAdded() override;
  explicit PROTOBUF_CONSTEXPR TeamMemberAdded(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TeamMemberAdded(const TeamMemberAdded& from);
  TeamMemberAdded(TeamMemberAdded&& from) noexcept
    : TeamMemberAdded() {
    *this = ::std::move(from);
  }

  inline TeamMemberAdded& operator=(const TeamMemberAdded& from) {
    CopyFrom(from);
    return *this;
  }
  inline TeamMemberAdded& operator=(TeamMemberAdded&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TeamMemberAdded& default_instance() {
    return *internal_default_instance();
  }
  static inline const TeamMemberAdded* internal_default_instance() {
    return reinterpret_cast<const TeamMemberAdded*>(
               &_TeamMemberAdded_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(TeamMemberAdded& a, TeamMemberAdded& b) {
    a.Swap(&b);
  }
  inline void Swap(TeamMemberAdded* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TeamMemberAdded* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TeamMemberAdded* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TeamMemberAdded>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TeamMemberAdded& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TeamMemberAdded& from) {
    TeamMemberAdded::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TeamMemberAdded* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.TeamMemberAdded";
  }
  protected:
  explicit TeamMemberAdded(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTeamIdFieldNumber = 1,
    kRoleFieldNumber = 2,
    kAddedByFieldNumber = 3,
  };
  // string team_id = 1;
  void clear_team_id();
  const std::string& team_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_team_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_team_id();
  PROTOBUF_NODISCARD std::string* release_team_id();
  void set_allocated_team_id(std::string* team_id);
  private:
  const std::string& _internal_team_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_team_id(const std::string& value);
  std::string* _internal_mutable_team_id();
  public:

  // string role = 2;
  void clear_role();
  const std::string& role() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_role(ArgT0&& arg0, ArgT... args);
  std::string* mutable_role();
  PROTOBUF_NODISCARD std::string* release_role();
  void set_allocated_role(std::string* role);
  private:
  const std::string& _internal_role() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_role(const std::string& value);
  std::string* _internal_mutable_role();
  public:

  // string added_by = 3;
  void clear_added_by();
  const std::string& added_by() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_added_by(ArgT0&& arg0, ArgT... args);
  std::string* mutable_added_by();
  PROTOBUF_NODISCARD std::string* release_added_by();
  void set_allocated_added_by(std::string* added_by);
  private:
  const std::string& _internal_added_by() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_added_by(const std::string& value);
  std::string* _internal_mutable_added_by();
  public:

  // @@protoc_insertion_point(class_scope:unhinged.cdc.TeamMemberAdded)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr team_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr role_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr added_by_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fevents_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// UniversalEvent

// string event_id = 1;
inline void UniversalEvent::clear_event_id() {
  _impl_.event_id_.ClearToEmpty();
}
inline const std::string& UniversalEvent::event_id() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.UniversalEvent.event_id)
  return _internal_event_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UniversalEvent::set_event_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.event_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.UniversalEvent.event_id)
}
inline std::string* UniversalEvent::mutable_event_id() {
  std::string* _s = _internal_mutable_event_id();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.UniversalEvent.event_id)
  return _s;
}
inline const std::string& UniversalEvent::_internal_event_id() const {
  return _impl_.event_id_.Get();
}
inline void UniversalEvent::_internal_set_event_id(const std::string& value) {
  
  _impl_.event_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UniversalEvent::_internal_mutable_event_id() {
  
  return _impl_.event_id_.Mutable(GetArenaForAllocation());
}
inline std::string* UniversalEvent::release_event_id() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.UniversalEvent.event_id)
  return _impl_.event_id_.Release();
}
inline void UniversalEvent::set_allocated_event_id(std::string* event_id) {
  if (event_id != nullptr) {
    
  } else {
    
  }
  _impl_.event_id_.SetAllocated(event_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.event_id_.IsDefault()) {
    _impl_.event_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.UniversalEvent.event_id)
}

// string event_type = 2;
inline void UniversalEvent::clear_event_type() {
  _impl_.event_type_.ClearToEmpty();
}
inline const std::string& UniversalEvent::event_type() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.UniversalEvent.event_type)
  return _internal_event_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UniversalEvent::set_event_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.event_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.UniversalEvent.event_type)
}
inline std::string* UniversalEvent::mutable_event_type() {
  std::string* _s = _internal_mutable_event_type();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.UniversalEvent.event_type)
  return _s;
}
inline const std::string& UniversalEvent::_internal_event_type() const {
  return _impl_.event_type_.Get();
}
inline void UniversalEvent::_internal_set_event_type(const std::string& value) {
  
  _impl_.event_type_.Set(value, GetArenaForAllocation());
}
inline std::string* UniversalEvent::_internal_mutable_event_type() {
  
  return _impl_.event_type_.Mutable(GetArenaForAllocation());
}
inline std::string* UniversalEvent::release_event_type() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.UniversalEvent.event_type)
  return _impl_.event_type_.Release();
}
inline void UniversalEvent::set_allocated_event_type(std::string* event_type) {
  if (event_type != nullptr) {
    
  } else {
    
  }
  _impl_.event_type_.SetAllocated(event_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.event_type_.IsDefault()) {
    _impl_.event_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.UniversalEvent.event_type)
}

// string event_version = 3;
inline void UniversalEvent::clear_event_version() {
  _impl_.event_version_.ClearToEmpty();
}
inline const std::string& UniversalEvent::event_version() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.UniversalEvent.event_version)
  return _internal_event_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UniversalEvent::set_event_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.event_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.UniversalEvent.event_version)
}
inline std::string* UniversalEvent::mutable_event_version() {
  std::string* _s = _internal_mutable_event_version();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.UniversalEvent.event_version)
  return _s;
}
inline const std::string& UniversalEvent::_internal_event_version() const {
  return _impl_.event_version_.Get();
}
inline void UniversalEvent::_internal_set_event_version(const std::string& value) {
  
  _impl_.event_version_.Set(value, GetArenaForAllocation());
}
inline std::string* UniversalEvent::_internal_mutable_event_version() {
  
  return _impl_.event_version_.Mutable(GetArenaForAllocation());
}
inline std::string* UniversalEvent::release_event_version() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.UniversalEvent.event_version)
  return _impl_.event_version_.Release();
}
inline void UniversalEvent::set_allocated_event_version(std::string* event_version) {
  if (event_version != nullptr) {
    
  } else {
    
  }
  _impl_.event_version_.SetAllocated(event_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.event_version_.IsDefault()) {
    _impl_.event_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.UniversalEvent.event_version)
}

// .google.protobuf.Timestamp event_time = 4;
inline bool UniversalEvent::_internal_has_event_time() const {
  return this != internal_default_instance() && _impl_.event_time_ != nullptr;
}
inline bool UniversalEvent::has_event_time() const {
  return _internal_has_event_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& UniversalEvent::_internal_event_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.event_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& UniversalEvent::event_time() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.UniversalEvent.event_time)
  return _internal_event_time();
}
inline void UniversalEvent::unsafe_arena_set_allocated_event_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* event_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.event_time_);
  }
  _impl_.event_time_ = event_time;
  if (event_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.UniversalEvent.event_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UniversalEvent::release_event_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.event_time_;
  _impl_.event_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UniversalEvent::unsafe_arena_release_event_time() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.UniversalEvent.event_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.event_time_;
  _impl_.event_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UniversalEvent::_internal_mutable_event_time() {
  
  if (_impl_.event_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.event_time_ = p;
  }
  return _impl_.event_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UniversalEvent::mutable_event_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_event_time();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.UniversalEvent.event_time)
  return _msg;
}
inline void UniversalEvent::set_allocated_event_time(::PROTOBUF_NAMESPACE_ID::Timestamp* event_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.event_time_);
  }
  if (event_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(event_time));
    if (message_arena != submessage_arena) {
      event_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, event_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.event_time_ = event_time;
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.UniversalEvent.event_time)
}

// int64 sequence_number = 5;
inline void UniversalEvent::clear_sequence_number() {
  _impl_.sequence_number_ = int64_t{0};
}
inline int64_t UniversalEvent::_internal_sequence_number() const {
  return _impl_.sequence_number_;
}
inline int64_t UniversalEvent::sequence_number() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.UniversalEvent.sequence_number)
  return _internal_sequence_number();
}
inline void UniversalEvent::_internal_set_sequence_number(int64_t value) {
  
  _impl_.sequence_number_ = value;
}
inline void UniversalEvent::set_sequence_number(int64_t value) {
  _internal_set_sequence_number(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.UniversalEvent.sequence_number)
}

// string source_service = 6;
inline void UniversalEvent::clear_source_service() {
  _impl_.source_service_.ClearToEmpty();
}
inline const std::string& UniversalEvent::source_service() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.UniversalEvent.source_service)
  return _internal_source_service();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UniversalEvent::set_source_service(ArgT0&& arg0, ArgT... args) {
 
 _impl_.source_service_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.UniversalEvent.source_service)
}
inline std::string* UniversalEvent::mutable_source_service() {
  std::string* _s = _internal_mutable_source_service();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.UniversalEvent.source_service)
  return _s;
}
inline const std::string& UniversalEvent::_internal_source_service() const {
  return _impl_.source_service_.Get();
}
inline void UniversalEvent::_internal_set_source_service(const std::string& value) {
  
  _impl_.source_service_.Set(value, GetArenaForAllocation());
}
inline std::string* UniversalEvent::_internal_mutable_source_service() {
  
  return _impl_.source_service_.Mutable(GetArenaForAllocation());
}
inline std::string* UniversalEvent::release_source_service() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.UniversalEvent.source_service)
  return _impl_.source_service_.Release();
}
inline void UniversalEvent::set_allocated_source_service(std::string* source_service) {
  if (source_service != nullptr) {
    
  } else {
    
  }
  _impl_.source_service_.SetAllocated(source_service, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.source_service_.IsDefault()) {
    _impl_.source_service_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.UniversalEvent.source_service)
}

// string source_version = 7;
inline void UniversalEvent::clear_source_version() {
  _impl_.source_version_.ClearToEmpty();
}
inline const std::string& UniversalEvent::source_version() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.UniversalEvent.source_version)
  return _internal_source_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UniversalEvent::set_source_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.source_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.UniversalEvent.source_version)
}
inline std::string* UniversalEvent::mutable_source_version() {
  std::string* _s = _internal_mutable_source_version();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.UniversalEvent.source_version)
  return _s;
}
inline const std::string& UniversalEvent::_internal_source_version() const {
  return _impl_.source_version_.Get();
}
inline void UniversalEvent::_internal_set_source_version(const std::string& value) {
  
  _impl_.source_version_.Set(value, GetArenaForAllocation());
}
inline std::string* UniversalEvent::_internal_mutable_source_version() {
  
  return _impl_.source_version_.Mutable(GetArenaForAllocation());
}
inline std::string* UniversalEvent::release_source_version() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.UniversalEvent.source_version)
  return _impl_.source_version_.Release();
}
inline void UniversalEvent::set_allocated_source_version(std::string* source_version) {
  if (source_version != nullptr) {
    
  } else {
    
  }
  _impl_.source_version_.SetAllocated(source_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.source_version_.IsDefault()) {
    _impl_.source_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.UniversalEvent.source_version)
}

// string trace_id = 8;
inline void UniversalEvent::clear_trace_id() {
  _impl_.trace_id_.ClearToEmpty();
}
inline const std::string& UniversalEvent::trace_id() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.UniversalEvent.trace_id)
  return _internal_trace_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UniversalEvent::set_trace_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.trace_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.UniversalEvent.trace_id)
}
inline std::string* UniversalEvent::mutable_trace_id() {
  std::string* _s = _internal_mutable_trace_id();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.UniversalEvent.trace_id)
  return _s;
}
inline const std::string& UniversalEvent::_internal_trace_id() const {
  return _impl_.trace_id_.Get();
}
inline void UniversalEvent::_internal_set_trace_id(const std::string& value) {
  
  _impl_.trace_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UniversalEvent::_internal_mutable_trace_id() {
  
  return _impl_.trace_id_.Mutable(GetArenaForAllocation());
}
inline std::string* UniversalEvent::release_trace_id() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.UniversalEvent.trace_id)
  return _impl_.trace_id_.Release();
}
inline void UniversalEvent::set_allocated_trace_id(std::string* trace_id) {
  if (trace_id != nullptr) {
    
  } else {
    
  }
  _impl_.trace_id_.SetAllocated(trace_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.trace_id_.IsDefault()) {
    _impl_.trace_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.UniversalEvent.trace_id)
}

// string correlation_id = 9;
inline void UniversalEvent::clear_correlation_id() {
  _impl_.correlation_id_.ClearToEmpty();
}
inline const std::string& UniversalEvent::correlation_id() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.UniversalEvent.correlation_id)
  return _internal_correlation_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UniversalEvent::set_correlation_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.correlation_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.UniversalEvent.correlation_id)
}
inline std::string* UniversalEvent::mutable_correlation_id() {
  std::string* _s = _internal_mutable_correlation_id();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.UniversalEvent.correlation_id)
  return _s;
}
inline const std::string& UniversalEvent::_internal_correlation_id() const {
  return _impl_.correlation_id_.Get();
}
inline void UniversalEvent::_internal_set_correlation_id(const std::string& value) {
  
  _impl_.correlation_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UniversalEvent::_internal_mutable_correlation_id() {
  
  return _impl_.correlation_id_.Mutable(GetArenaForAllocation());
}
inline std::string* UniversalEvent::release_correlation_id() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.UniversalEvent.correlation_id)
  return _impl_.correlation_id_.Release();
}
inline void UniversalEvent::set_allocated_correlation_id(std::string* correlation_id) {
  if (correlation_id != nullptr) {
    
  } else {
    
  }
  _impl_.correlation_id_.SetAllocated(correlation_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.correlation_id_.IsDefault()) {
    _impl_.correlation_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.UniversalEvent.correlation_id)
}

// string user_id = 10;
inline void UniversalEvent::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& UniversalEvent::user_id() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.UniversalEvent.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UniversalEvent::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.UniversalEvent.user_id)
}
inline std::string* UniversalEvent::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.UniversalEvent.user_id)
  return _s;
}
inline const std::string& UniversalEvent::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void UniversalEvent::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UniversalEvent::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* UniversalEvent::release_user_id() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.UniversalEvent.user_id)
  return _impl_.user_id_.Release();
}
inline void UniversalEvent::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.UniversalEvent.user_id)
}

// string session_id = 11;
inline void UniversalEvent::clear_session_id() {
  _impl_.session_id_.ClearToEmpty();
}
inline const std::string& UniversalEvent::session_id() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.UniversalEvent.session_id)
  return _internal_session_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UniversalEvent::set_session_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.session_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.UniversalEvent.session_id)
}
inline std::string* UniversalEvent::mutable_session_id() {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.UniversalEvent.session_id)
  return _s;
}
inline const std::string& UniversalEvent::_internal_session_id() const {
  return _impl_.session_id_.Get();
}
inline void UniversalEvent::_internal_set_session_id(const std::string& value) {
  
  _impl_.session_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UniversalEvent::_internal_mutable_session_id() {
  
  return _impl_.session_id_.Mutable(GetArenaForAllocation());
}
inline std::string* UniversalEvent::release_session_id() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.UniversalEvent.session_id)
  return _impl_.session_id_.Release();
}
inline void UniversalEvent::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  _impl_.session_id_.SetAllocated(session_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.session_id_.IsDefault()) {
    _impl_.session_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.UniversalEvent.session_id)
}

// string tenant_id = 12;
inline void UniversalEvent::clear_tenant_id() {
  _impl_.tenant_id_.ClearToEmpty();
}
inline const std::string& UniversalEvent::tenant_id() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.UniversalEvent.tenant_id)
  return _internal_tenant_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UniversalEvent::set_tenant_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tenant_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.UniversalEvent.tenant_id)
}
inline std::string* UniversalEvent::mutable_tenant_id() {
  std::string* _s = _internal_mutable_tenant_id();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.UniversalEvent.tenant_id)
  return _s;
}
inline const std::string& UniversalEvent::_internal_tenant_id() const {
  return _impl_.tenant_id_.Get();
}
inline void UniversalEvent::_internal_set_tenant_id(const std::string& value) {
  
  _impl_.tenant_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UniversalEvent::_internal_mutable_tenant_id() {
  
  return _impl_.tenant_id_.Mutable(GetArenaForAllocation());
}
inline std::string* UniversalEvent::release_tenant_id() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.UniversalEvent.tenant_id)
  return _impl_.tenant_id_.Release();
}
inline void UniversalEvent::set_allocated_tenant_id(std::string* tenant_id) {
  if (tenant_id != nullptr) {
    
  } else {
    
  }
  _impl_.tenant_id_.SetAllocated(tenant_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tenant_id_.IsDefault()) {
    _impl_.tenant_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.UniversalEvent.tenant_id)
}

// .unhinged.cdc.DocumentEvent document_event = 20;
inline bool UniversalEvent::_internal_has_document_event() const {
  return payload_case() == kDocumentEvent;
}
inline bool UniversalEvent::has_document_event() const {
  return _internal_has_document_event();
}
inline void UniversalEvent::set_has_document_event() {
  _impl_._oneof_case_[0] = kDocumentEvent;
}
inline void UniversalEvent::clear_document_event() {
  if (_internal_has_document_event()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.document_event_;
    }
    clear_has_payload();
  }
}
inline ::unhinged::cdc::DocumentEvent* UniversalEvent::release_document_event() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.UniversalEvent.document_event)
  if (_internal_has_document_event()) {
    clear_has_payload();
    ::unhinged::cdc::DocumentEvent* temp = _impl_.payload_.document_event_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.document_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::cdc::DocumentEvent& UniversalEvent::_internal_document_event() const {
  return _internal_has_document_event()
      ? *_impl_.payload_.document_event_
      : reinterpret_cast< ::unhinged::cdc::DocumentEvent&>(::unhinged::cdc::_DocumentEvent_default_instance_);
}
inline const ::unhinged::cdc::DocumentEvent& UniversalEvent::document_event() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.UniversalEvent.document_event)
  return _internal_document_event();
}
inline ::unhinged::cdc::DocumentEvent* UniversalEvent::unsafe_arena_release_document_event() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.cdc.UniversalEvent.document_event)
  if (_internal_has_document_event()) {
    clear_has_payload();
    ::unhinged::cdc::DocumentEvent* temp = _impl_.payload_.document_event_;
    _impl_.payload_.document_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UniversalEvent::unsafe_arena_set_allocated_document_event(::unhinged::cdc::DocumentEvent* document_event) {
  clear_payload();
  if (document_event) {
    set_has_document_event();
    _impl_.payload_.document_event_ = document_event;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.UniversalEvent.document_event)
}
inline ::unhinged::cdc::DocumentEvent* UniversalEvent::_internal_mutable_document_event() {
  if (!_internal_has_document_event()) {
    clear_payload();
    set_has_document_event();
    _impl_.payload_.document_event_ = CreateMaybeMessage< ::unhinged::cdc::DocumentEvent >(GetArenaForAllocation());
  }
  return _impl_.payload_.document_event_;
}
inline ::unhinged::cdc::DocumentEvent* UniversalEvent::mutable_document_event() {
  ::unhinged::cdc::DocumentEvent* _msg = _internal_mutable_document_event();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.UniversalEvent.document_event)
  return _msg;
}

// .unhinged.cdc.LLMEvent llm_event = 21;
inline bool UniversalEvent::_internal_has_llm_event() const {
  return payload_case() == kLlmEvent;
}
inline bool UniversalEvent::has_llm_event() const {
  return _internal_has_llm_event();
}
inline void UniversalEvent::set_has_llm_event() {
  _impl_._oneof_case_[0] = kLlmEvent;
}
inline void UniversalEvent::clear_llm_event() {
  if (_internal_has_llm_event()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.llm_event_;
    }
    clear_has_payload();
  }
}
inline ::unhinged::cdc::LLMEvent* UniversalEvent::release_llm_event() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.UniversalEvent.llm_event)
  if (_internal_has_llm_event()) {
    clear_has_payload();
    ::unhinged::cdc::LLMEvent* temp = _impl_.payload_.llm_event_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.llm_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::cdc::LLMEvent& UniversalEvent::_internal_llm_event() const {
  return _internal_has_llm_event()
      ? *_impl_.payload_.llm_event_
      : reinterpret_cast< ::unhinged::cdc::LLMEvent&>(::unhinged::cdc::_LLMEvent_default_instance_);
}
inline const ::unhinged::cdc::LLMEvent& UniversalEvent::llm_event() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.UniversalEvent.llm_event)
  return _internal_llm_event();
}
inline ::unhinged::cdc::LLMEvent* UniversalEvent::unsafe_arena_release_llm_event() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.cdc.UniversalEvent.llm_event)
  if (_internal_has_llm_event()) {
    clear_has_payload();
    ::unhinged::cdc::LLMEvent* temp = _impl_.payload_.llm_event_;
    _impl_.payload_.llm_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UniversalEvent::unsafe_arena_set_allocated_llm_event(::unhinged::cdc::LLMEvent* llm_event) {
  clear_payload();
  if (llm_event) {
    set_has_llm_event();
    _impl_.payload_.llm_event_ = llm_event;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.UniversalEvent.llm_event)
}
inline ::unhinged::cdc::LLMEvent* UniversalEvent::_internal_mutable_llm_event() {
  if (!_internal_has_llm_event()) {
    clear_payload();
    set_has_llm_event();
    _impl_.payload_.llm_event_ = CreateMaybeMessage< ::unhinged::cdc::LLMEvent >(GetArenaForAllocation());
  }
  return _impl_.payload_.llm_event_;
}
inline ::unhinged::cdc::LLMEvent* UniversalEvent::mutable_llm_event() {
  ::unhinged::cdc::LLMEvent* _msg = _internal_mutable_llm_event();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.UniversalEvent.llm_event)
  return _msg;
}

// .unhinged.cdc.AgentEvent agent_event = 22;
inline bool UniversalEvent::_internal_has_agent_event() const {
  return payload_case() == kAgentEvent;
}
inline bool UniversalEvent::has_agent_event() const {
  return _internal_has_agent_event();
}
inline void UniversalEvent::set_has_agent_event() {
  _impl_._oneof_case_[0] = kAgentEvent;
}
inline void UniversalEvent::clear_agent_event() {
  if (_internal_has_agent_event()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.agent_event_;
    }
    clear_has_payload();
  }
}
inline ::unhinged::cdc::AgentEvent* UniversalEvent::release_agent_event() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.UniversalEvent.agent_event)
  if (_internal_has_agent_event()) {
    clear_has_payload();
    ::unhinged::cdc::AgentEvent* temp = _impl_.payload_.agent_event_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.agent_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::cdc::AgentEvent& UniversalEvent::_internal_agent_event() const {
  return _internal_has_agent_event()
      ? *_impl_.payload_.agent_event_
      : reinterpret_cast< ::unhinged::cdc::AgentEvent&>(::unhinged::cdc::_AgentEvent_default_instance_);
}
inline const ::unhinged::cdc::AgentEvent& UniversalEvent::agent_event() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.UniversalEvent.agent_event)
  return _internal_agent_event();
}
inline ::unhinged::cdc::AgentEvent* UniversalEvent::unsafe_arena_release_agent_event() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.cdc.UniversalEvent.agent_event)
  if (_internal_has_agent_event()) {
    clear_has_payload();
    ::unhinged::cdc::AgentEvent* temp = _impl_.payload_.agent_event_;
    _impl_.payload_.agent_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UniversalEvent::unsafe_arena_set_allocated_agent_event(::unhinged::cdc::AgentEvent* agent_event) {
  clear_payload();
  if (agent_event) {
    set_has_agent_event();
    _impl_.payload_.agent_event_ = agent_event;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.UniversalEvent.agent_event)
}
inline ::unhinged::cdc::AgentEvent* UniversalEvent::_internal_mutable_agent_event() {
  if (!_internal_has_agent_event()) {
    clear_payload();
    set_has_agent_event();
    _impl_.payload_.agent_event_ = CreateMaybeMessage< ::unhinged::cdc::AgentEvent >(GetArenaForAllocation());
  }
  return _impl_.payload_.agent_event_;
}
inline ::unhinged::cdc::AgentEvent* UniversalEvent::mutable_agent_event() {
  ::unhinged::cdc::AgentEvent* _msg = _internal_mutable_agent_event();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.UniversalEvent.agent_event)
  return _msg;
}

// .unhinged.cdc.SessionEvent session_event = 23;
inline bool UniversalEvent::_internal_has_session_event() const {
  return payload_case() == kSessionEvent;
}
inline bool UniversalEvent::has_session_event() const {
  return _internal_has_session_event();
}
inline void UniversalEvent::set_has_session_event() {
  _impl_._oneof_case_[0] = kSessionEvent;
}
inline void UniversalEvent::clear_session_event() {
  if (_internal_has_session_event()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.session_event_;
    }
    clear_has_payload();
  }
}
inline ::unhinged::cdc::SessionEvent* UniversalEvent::release_session_event() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.UniversalEvent.session_event)
  if (_internal_has_session_event()) {
    clear_has_payload();
    ::unhinged::cdc::SessionEvent* temp = _impl_.payload_.session_event_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.session_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::cdc::SessionEvent& UniversalEvent::_internal_session_event() const {
  return _internal_has_session_event()
      ? *_impl_.payload_.session_event_
      : reinterpret_cast< ::unhinged::cdc::SessionEvent&>(::unhinged::cdc::_SessionEvent_default_instance_);
}
inline const ::unhinged::cdc::SessionEvent& UniversalEvent::session_event() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.UniversalEvent.session_event)
  return _internal_session_event();
}
inline ::unhinged::cdc::SessionEvent* UniversalEvent::unsafe_arena_release_session_event() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.cdc.UniversalEvent.session_event)
  if (_internal_has_session_event()) {
    clear_has_payload();
    ::unhinged::cdc::SessionEvent* temp = _impl_.payload_.session_event_;
    _impl_.payload_.session_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UniversalEvent::unsafe_arena_set_allocated_session_event(::unhinged::cdc::SessionEvent* session_event) {
  clear_payload();
  if (session_event) {
    set_has_session_event();
    _impl_.payload_.session_event_ = session_event;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.UniversalEvent.session_event)
}
inline ::unhinged::cdc::SessionEvent* UniversalEvent::_internal_mutable_session_event() {
  if (!_internal_has_session_event()) {
    clear_payload();
    set_has_session_event();
    _impl_.payload_.session_event_ = CreateMaybeMessage< ::unhinged::cdc::SessionEvent >(GetArenaForAllocation());
  }
  return _impl_.payload_.session_event_;
}
inline ::unhinged::cdc::SessionEvent* UniversalEvent::mutable_session_event() {
  ::unhinged::cdc::SessionEvent* _msg = _internal_mutable_session_event();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.UniversalEvent.session_event)
  return _msg;
}

// .unhinged.cdc.SystemEvent system_event = 24;
inline bool UniversalEvent::_internal_has_system_event() const {
  return payload_case() == kSystemEvent;
}
inline bool UniversalEvent::has_system_event() const {
  return _internal_has_system_event();
}
inline void UniversalEvent::set_has_system_event() {
  _impl_._oneof_case_[0] = kSystemEvent;
}
inline void UniversalEvent::clear_system_event() {
  if (_internal_has_system_event()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.system_event_;
    }
    clear_has_payload();
  }
}
inline ::unhinged::cdc::SystemEvent* UniversalEvent::release_system_event() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.UniversalEvent.system_event)
  if (_internal_has_system_event()) {
    clear_has_payload();
    ::unhinged::cdc::SystemEvent* temp = _impl_.payload_.system_event_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.system_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::cdc::SystemEvent& UniversalEvent::_internal_system_event() const {
  return _internal_has_system_event()
      ? *_impl_.payload_.system_event_
      : reinterpret_cast< ::unhinged::cdc::SystemEvent&>(::unhinged::cdc::_SystemEvent_default_instance_);
}
inline const ::unhinged::cdc::SystemEvent& UniversalEvent::system_event() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.UniversalEvent.system_event)
  return _internal_system_event();
}
inline ::unhinged::cdc::SystemEvent* UniversalEvent::unsafe_arena_release_system_event() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.cdc.UniversalEvent.system_event)
  if (_internal_has_system_event()) {
    clear_has_payload();
    ::unhinged::cdc::SystemEvent* temp = _impl_.payload_.system_event_;
    _impl_.payload_.system_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UniversalEvent::unsafe_arena_set_allocated_system_event(::unhinged::cdc::SystemEvent* system_event) {
  clear_payload();
  if (system_event) {
    set_has_system_event();
    _impl_.payload_.system_event_ = system_event;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.UniversalEvent.system_event)
}
inline ::unhinged::cdc::SystemEvent* UniversalEvent::_internal_mutable_system_event() {
  if (!_internal_has_system_event()) {
    clear_payload();
    set_has_system_event();
    _impl_.payload_.system_event_ = CreateMaybeMessage< ::unhinged::cdc::SystemEvent >(GetArenaForAllocation());
  }
  return _impl_.payload_.system_event_;
}
inline ::unhinged::cdc::SystemEvent* UniversalEvent::mutable_system_event() {
  ::unhinged::cdc::SystemEvent* _msg = _internal_mutable_system_event();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.UniversalEvent.system_event)
  return _msg;
}

// .unhinged.cdc.WorkflowEvent workflow_event = 25;
inline bool UniversalEvent::_internal_has_workflow_event() const {
  return payload_case() == kWorkflowEvent;
}
inline bool UniversalEvent::has_workflow_event() const {
  return _internal_has_workflow_event();
}
inline void UniversalEvent::set_has_workflow_event() {
  _impl_._oneof_case_[0] = kWorkflowEvent;
}
inline void UniversalEvent::clear_workflow_event() {
  if (_internal_has_workflow_event()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.workflow_event_;
    }
    clear_has_payload();
  }
}
inline ::unhinged::cdc::WorkflowEvent* UniversalEvent::release_workflow_event() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.UniversalEvent.workflow_event)
  if (_internal_has_workflow_event()) {
    clear_has_payload();
    ::unhinged::cdc::WorkflowEvent* temp = _impl_.payload_.workflow_event_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.workflow_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::cdc::WorkflowEvent& UniversalEvent::_internal_workflow_event() const {
  return _internal_has_workflow_event()
      ? *_impl_.payload_.workflow_event_
      : reinterpret_cast< ::unhinged::cdc::WorkflowEvent&>(::unhinged::cdc::_WorkflowEvent_default_instance_);
}
inline const ::unhinged::cdc::WorkflowEvent& UniversalEvent::workflow_event() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.UniversalEvent.workflow_event)
  return _internal_workflow_event();
}
inline ::unhinged::cdc::WorkflowEvent* UniversalEvent::unsafe_arena_release_workflow_event() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.cdc.UniversalEvent.workflow_event)
  if (_internal_has_workflow_event()) {
    clear_has_payload();
    ::unhinged::cdc::WorkflowEvent* temp = _impl_.payload_.workflow_event_;
    _impl_.payload_.workflow_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UniversalEvent::unsafe_arena_set_allocated_workflow_event(::unhinged::cdc::WorkflowEvent* workflow_event) {
  clear_payload();
  if (workflow_event) {
    set_has_workflow_event();
    _impl_.payload_.workflow_event_ = workflow_event;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.UniversalEvent.workflow_event)
}
inline ::unhinged::cdc::WorkflowEvent* UniversalEvent::_internal_mutable_workflow_event() {
  if (!_internal_has_workflow_event()) {
    clear_payload();
    set_has_workflow_event();
    _impl_.payload_.workflow_event_ = CreateMaybeMessage< ::unhinged::cdc::WorkflowEvent >(GetArenaForAllocation());
  }
  return _impl_.payload_.workflow_event_;
}
inline ::unhinged::cdc::WorkflowEvent* UniversalEvent::mutable_workflow_event() {
  ::unhinged::cdc::WorkflowEvent* _msg = _internal_mutable_workflow_event();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.UniversalEvent.workflow_event)
  return _msg;
}

// .unhinged.cdc.ChatEvent chat_event = 26;
inline bool UniversalEvent::_internal_has_chat_event() const {
  return payload_case() == kChatEvent;
}
inline bool UniversalEvent::has_chat_event() const {
  return _internal_has_chat_event();
}
inline void UniversalEvent::set_has_chat_event() {
  _impl_._oneof_case_[0] = kChatEvent;
}
inline void UniversalEvent::clear_chat_event() {
  if (_internal_has_chat_event()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.chat_event_;
    }
    clear_has_payload();
  }
}
inline ::unhinged::cdc::ChatEvent* UniversalEvent::release_chat_event() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.UniversalEvent.chat_event)
  if (_internal_has_chat_event()) {
    clear_has_payload();
    ::unhinged::cdc::ChatEvent* temp = _impl_.payload_.chat_event_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.chat_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::cdc::ChatEvent& UniversalEvent::_internal_chat_event() const {
  return _internal_has_chat_event()
      ? *_impl_.payload_.chat_event_
      : reinterpret_cast< ::unhinged::cdc::ChatEvent&>(::unhinged::cdc::_ChatEvent_default_instance_);
}
inline const ::unhinged::cdc::ChatEvent& UniversalEvent::chat_event() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.UniversalEvent.chat_event)
  return _internal_chat_event();
}
inline ::unhinged::cdc::ChatEvent* UniversalEvent::unsafe_arena_release_chat_event() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.cdc.UniversalEvent.chat_event)
  if (_internal_has_chat_event()) {
    clear_has_payload();
    ::unhinged::cdc::ChatEvent* temp = _impl_.payload_.chat_event_;
    _impl_.payload_.chat_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UniversalEvent::unsafe_arena_set_allocated_chat_event(::unhinged::cdc::ChatEvent* chat_event) {
  clear_payload();
  if (chat_event) {
    set_has_chat_event();
    _impl_.payload_.chat_event_ = chat_event;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.UniversalEvent.chat_event)
}
inline ::unhinged::cdc::ChatEvent* UniversalEvent::_internal_mutable_chat_event() {
  if (!_internal_has_chat_event()) {
    clear_payload();
    set_has_chat_event();
    _impl_.payload_.chat_event_ = CreateMaybeMessage< ::unhinged::cdc::ChatEvent >(GetArenaForAllocation());
  }
  return _impl_.payload_.chat_event_;
}
inline ::unhinged::cdc::ChatEvent* UniversalEvent::mutable_chat_event() {
  ::unhinged::cdc::ChatEvent* _msg = _internal_mutable_chat_event();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.UniversalEvent.chat_event)
  return _msg;
}

// .unhinged.cdc.AudioEvent audio_event = 27;
inline bool UniversalEvent::_internal_has_audio_event() const {
  return payload_case() == kAudioEvent;
}
inline bool UniversalEvent::has_audio_event() const {
  return _internal_has_audio_event();
}
inline void UniversalEvent::set_has_audio_event() {
  _impl_._oneof_case_[0] = kAudioEvent;
}
inline void UniversalEvent::clear_audio_event() {
  if (_internal_has_audio_event()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.audio_event_;
    }
    clear_has_payload();
  }
}
inline ::unhinged::cdc::AudioEvent* UniversalEvent::release_audio_event() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.UniversalEvent.audio_event)
  if (_internal_has_audio_event()) {
    clear_has_payload();
    ::unhinged::cdc::AudioEvent* temp = _impl_.payload_.audio_event_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.audio_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::cdc::AudioEvent& UniversalEvent::_internal_audio_event() const {
  return _internal_has_audio_event()
      ? *_impl_.payload_.audio_event_
      : reinterpret_cast< ::unhinged::cdc::AudioEvent&>(::unhinged::cdc::_AudioEvent_default_instance_);
}
inline const ::unhinged::cdc::AudioEvent& UniversalEvent::audio_event() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.UniversalEvent.audio_event)
  return _internal_audio_event();
}
inline ::unhinged::cdc::AudioEvent* UniversalEvent::unsafe_arena_release_audio_event() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.cdc.UniversalEvent.audio_event)
  if (_internal_has_audio_event()) {
    clear_has_payload();
    ::unhinged::cdc::AudioEvent* temp = _impl_.payload_.audio_event_;
    _impl_.payload_.audio_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UniversalEvent::unsafe_arena_set_allocated_audio_event(::unhinged::cdc::AudioEvent* audio_event) {
  clear_payload();
  if (audio_event) {
    set_has_audio_event();
    _impl_.payload_.audio_event_ = audio_event;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.UniversalEvent.audio_event)
}
inline ::unhinged::cdc::AudioEvent* UniversalEvent::_internal_mutable_audio_event() {
  if (!_internal_has_audio_event()) {
    clear_payload();
    set_has_audio_event();
    _impl_.payload_.audio_event_ = CreateMaybeMessage< ::unhinged::cdc::AudioEvent >(GetArenaForAllocation());
  }
  return _impl_.payload_.audio_event_;
}
inline ::unhinged::cdc::AudioEvent* UniversalEvent::mutable_audio_event() {
  ::unhinged::cdc::AudioEvent* _msg = _internal_mutable_audio_event();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.UniversalEvent.audio_event)
  return _msg;
}

// .unhinged.cdc.UserEvent user_event = 28;
inline bool UniversalEvent::_internal_has_user_event() const {
  return payload_case() == kUserEvent;
}
inline bool UniversalEvent::has_user_event() const {
  return _internal_has_user_event();
}
inline void UniversalEvent::set_has_user_event() {
  _impl_._oneof_case_[0] = kUserEvent;
}
inline void UniversalEvent::clear_user_event() {
  if (_internal_has_user_event()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.user_event_;
    }
    clear_has_payload();
  }
}
inline ::unhinged::cdc::UserEvent* UniversalEvent::release_user_event() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.UniversalEvent.user_event)
  if (_internal_has_user_event()) {
    clear_has_payload();
    ::unhinged::cdc::UserEvent* temp = _impl_.payload_.user_event_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.user_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::cdc::UserEvent& UniversalEvent::_internal_user_event() const {
  return _internal_has_user_event()
      ? *_impl_.payload_.user_event_
      : reinterpret_cast< ::unhinged::cdc::UserEvent&>(::unhinged::cdc::_UserEvent_default_instance_);
}
inline const ::unhinged::cdc::UserEvent& UniversalEvent::user_event() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.UniversalEvent.user_event)
  return _internal_user_event();
}
inline ::unhinged::cdc::UserEvent* UniversalEvent::unsafe_arena_release_user_event() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.cdc.UniversalEvent.user_event)
  if (_internal_has_user_event()) {
    clear_has_payload();
    ::unhinged::cdc::UserEvent* temp = _impl_.payload_.user_event_;
    _impl_.payload_.user_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UniversalEvent::unsafe_arena_set_allocated_user_event(::unhinged::cdc::UserEvent* user_event) {
  clear_payload();
  if (user_event) {
    set_has_user_event();
    _impl_.payload_.user_event_ = user_event;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.UniversalEvent.user_event)
}
inline ::unhinged::cdc::UserEvent* UniversalEvent::_internal_mutable_user_event() {
  if (!_internal_has_user_event()) {
    clear_payload();
    set_has_user_event();
    _impl_.payload_.user_event_ = CreateMaybeMessage< ::unhinged::cdc::UserEvent >(GetArenaForAllocation());
  }
  return _impl_.payload_.user_event_;
}
inline ::unhinged::cdc::UserEvent* UniversalEvent::mutable_user_event() {
  ::unhinged::cdc::UserEvent* _msg = _internal_mutable_user_event();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.UniversalEvent.user_event)
  return _msg;
}

// .google.protobuf.Struct metadata = 30;
inline bool UniversalEvent::_internal_has_metadata() const {
  return this != internal_default_instance() && _impl_.metadata_ != nullptr;
}
inline bool UniversalEvent::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& UniversalEvent::_internal_metadata() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& UniversalEvent::metadata() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.UniversalEvent.metadata)
  return _internal_metadata();
}
inline void UniversalEvent::unsafe_arena_set_allocated_metadata(
    ::PROTOBUF_NAMESPACE_ID::Struct* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.UniversalEvent.metadata)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* UniversalEvent::release_metadata() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* UniversalEvent::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.UniversalEvent.metadata)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* UniversalEvent::_internal_mutable_metadata() {
  
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* UniversalEvent::mutable_metadata() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.UniversalEvent.metadata)
  return _msg;
}
inline void UniversalEvent::set_allocated_metadata(::PROTOBUF_NAMESPACE_ID::Struct* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.UniversalEvent.metadata)
}

// repeated string tags = 31;
inline int UniversalEvent::_internal_tags_size() const {
  return _impl_.tags_.size();
}
inline int UniversalEvent::tags_size() const {
  return _internal_tags_size();
}
inline void UniversalEvent::clear_tags() {
  _impl_.tags_.Clear();
}
inline std::string* UniversalEvent::add_tags() {
  std::string* _s = _internal_add_tags();
  // @@protoc_insertion_point(field_add_mutable:unhinged.cdc.UniversalEvent.tags)
  return _s;
}
inline const std::string& UniversalEvent::_internal_tags(int index) const {
  return _impl_.tags_.Get(index);
}
inline const std::string& UniversalEvent::tags(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.UniversalEvent.tags)
  return _internal_tags(index);
}
inline std::string* UniversalEvent::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.UniversalEvent.tags)
  return _impl_.tags_.Mutable(index);
}
inline void UniversalEvent::set_tags(int index, const std::string& value) {
  _impl_.tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.UniversalEvent.tags)
}
inline void UniversalEvent::set_tags(int index, std::string&& value) {
  _impl_.tags_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.cdc.UniversalEvent.tags)
}
inline void UniversalEvent::set_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.cdc.UniversalEvent.tags)
}
inline void UniversalEvent::set_tags(int index, const char* value, size_t size) {
  _impl_.tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.cdc.UniversalEvent.tags)
}
inline std::string* UniversalEvent::_internal_add_tags() {
  return _impl_.tags_.Add();
}
inline void UniversalEvent::add_tags(const std::string& value) {
  _impl_.tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.cdc.UniversalEvent.tags)
}
inline void UniversalEvent::add_tags(std::string&& value) {
  _impl_.tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.cdc.UniversalEvent.tags)
}
inline void UniversalEvent::add_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.cdc.UniversalEvent.tags)
}
inline void UniversalEvent::add_tags(const char* value, size_t size) {
  _impl_.tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.cdc.UniversalEvent.tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
UniversalEvent::tags() const {
  // @@protoc_insertion_point(field_list:unhinged.cdc.UniversalEvent.tags)
  return _impl_.tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
UniversalEvent::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.cdc.UniversalEvent.tags)
  return &_impl_.tags_;
}

// string routing_key = 32;
inline void UniversalEvent::clear_routing_key() {
  _impl_.routing_key_.ClearToEmpty();
}
inline const std::string& UniversalEvent::routing_key() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.UniversalEvent.routing_key)
  return _internal_routing_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UniversalEvent::set_routing_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.routing_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.UniversalEvent.routing_key)
}
inline std::string* UniversalEvent::mutable_routing_key() {
  std::string* _s = _internal_mutable_routing_key();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.UniversalEvent.routing_key)
  return _s;
}
inline const std::string& UniversalEvent::_internal_routing_key() const {
  return _impl_.routing_key_.Get();
}
inline void UniversalEvent::_internal_set_routing_key(const std::string& value) {
  
  _impl_.routing_key_.Set(value, GetArenaForAllocation());
}
inline std::string* UniversalEvent::_internal_mutable_routing_key() {
  
  return _impl_.routing_key_.Mutable(GetArenaForAllocation());
}
inline std::string* UniversalEvent::release_routing_key() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.UniversalEvent.routing_key)
  return _impl_.routing_key_.Release();
}
inline void UniversalEvent::set_allocated_routing_key(std::string* routing_key) {
  if (routing_key != nullptr) {
    
  } else {
    
  }
  _impl_.routing_key_.SetAllocated(routing_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.routing_key_.IsDefault()) {
    _impl_.routing_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.UniversalEvent.routing_key)
}

// int32 retry_count = 33;
inline void UniversalEvent::clear_retry_count() {
  _impl_.retry_count_ = 0;
}
inline int32_t UniversalEvent::_internal_retry_count() const {
  return _impl_.retry_count_;
}
inline int32_t UniversalEvent::retry_count() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.UniversalEvent.retry_count)
  return _internal_retry_count();
}
inline void UniversalEvent::_internal_set_retry_count(int32_t value) {
  
  _impl_.retry_count_ = value;
}
inline void UniversalEvent::set_retry_count(int32_t value) {
  _internal_set_retry_count(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.UniversalEvent.retry_count)
}

// .google.protobuf.Timestamp expires_at = 34;
inline bool UniversalEvent::_internal_has_expires_at() const {
  return this != internal_default_instance() && _impl_.expires_at_ != nullptr;
}
inline bool UniversalEvent::has_expires_at() const {
  return _internal_has_expires_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& UniversalEvent::_internal_expires_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.expires_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& UniversalEvent::expires_at() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.UniversalEvent.expires_at)
  return _internal_expires_at();
}
inline void UniversalEvent::unsafe_arena_set_allocated_expires_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* expires_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.expires_at_);
  }
  _impl_.expires_at_ = expires_at;
  if (expires_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.UniversalEvent.expires_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UniversalEvent::release_expires_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.expires_at_;
  _impl_.expires_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UniversalEvent::unsafe_arena_release_expires_at() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.UniversalEvent.expires_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.expires_at_;
  _impl_.expires_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UniversalEvent::_internal_mutable_expires_at() {
  
  if (_impl_.expires_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.expires_at_ = p;
  }
  return _impl_.expires_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UniversalEvent::mutable_expires_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_expires_at();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.UniversalEvent.expires_at)
  return _msg;
}
inline void UniversalEvent::set_allocated_expires_at(::PROTOBUF_NAMESPACE_ID::Timestamp* expires_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.expires_at_);
  }
  if (expires_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(expires_at));
    if (message_arena != submessage_arena) {
      expires_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, expires_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.expires_at_ = expires_at;
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.UniversalEvent.expires_at)
}

inline bool UniversalEvent::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void UniversalEvent::clear_has_payload() {
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline UniversalEvent::PayloadCase UniversalEvent::payload_case() const {
  return UniversalEvent::PayloadCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// DocumentEvent

// string document_uuid = 1;
inline void DocumentEvent::clear_document_uuid() {
  _impl_.document_uuid_.ClearToEmpty();
}
inline const std::string& DocumentEvent::document_uuid() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.DocumentEvent.document_uuid)
  return _internal_document_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DocumentEvent::set_document_uuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.document_uuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.DocumentEvent.document_uuid)
}
inline std::string* DocumentEvent::mutable_document_uuid() {
  std::string* _s = _internal_mutable_document_uuid();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.DocumentEvent.document_uuid)
  return _s;
}
inline const std::string& DocumentEvent::_internal_document_uuid() const {
  return _impl_.document_uuid_.Get();
}
inline void DocumentEvent::_internal_set_document_uuid(const std::string& value) {
  
  _impl_.document_uuid_.Set(value, GetArenaForAllocation());
}
inline std::string* DocumentEvent::_internal_mutable_document_uuid() {
  
  return _impl_.document_uuid_.Mutable(GetArenaForAllocation());
}
inline std::string* DocumentEvent::release_document_uuid() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.DocumentEvent.document_uuid)
  return _impl_.document_uuid_.Release();
}
inline void DocumentEvent::set_allocated_document_uuid(std::string* document_uuid) {
  if (document_uuid != nullptr) {
    
  } else {
    
  }
  _impl_.document_uuid_.SetAllocated(document_uuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.document_uuid_.IsDefault()) {
    _impl_.document_uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.DocumentEvent.document_uuid)
}

// string document_type = 2;
inline void DocumentEvent::clear_document_type() {
  _impl_.document_type_.ClearToEmpty();
}
inline const std::string& DocumentEvent::document_type() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.DocumentEvent.document_type)
  return _internal_document_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DocumentEvent::set_document_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.document_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.DocumentEvent.document_type)
}
inline std::string* DocumentEvent::mutable_document_type() {
  std::string* _s = _internal_mutable_document_type();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.DocumentEvent.document_type)
  return _s;
}
inline const std::string& DocumentEvent::_internal_document_type() const {
  return _impl_.document_type_.Get();
}
inline void DocumentEvent::_internal_set_document_type(const std::string& value) {
  
  _impl_.document_type_.Set(value, GetArenaForAllocation());
}
inline std::string* DocumentEvent::_internal_mutable_document_type() {
  
  return _impl_.document_type_.Mutable(GetArenaForAllocation());
}
inline std::string* DocumentEvent::release_document_type() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.DocumentEvent.document_type)
  return _impl_.document_type_.Release();
}
inline void DocumentEvent::set_allocated_document_type(std::string* document_type) {
  if (document_type != nullptr) {
    
  } else {
    
  }
  _impl_.document_type_.SetAllocated(document_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.document_type_.IsDefault()) {
    _impl_.document_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.DocumentEvent.document_type)
}

// string namespace = 3;
inline void DocumentEvent::clear_namespace_() {
  _impl_.namespace__.ClearToEmpty();
}
inline const std::string& DocumentEvent::namespace_() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.DocumentEvent.namespace)
  return _internal_namespace_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DocumentEvent::set_namespace_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.namespace__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.DocumentEvent.namespace)
}
inline std::string* DocumentEvent::mutable_namespace_() {
  std::string* _s = _internal_mutable_namespace_();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.DocumentEvent.namespace)
  return _s;
}
inline const std::string& DocumentEvent::_internal_namespace_() const {
  return _impl_.namespace__.Get();
}
inline void DocumentEvent::_internal_set_namespace_(const std::string& value) {
  
  _impl_.namespace__.Set(value, GetArenaForAllocation());
}
inline std::string* DocumentEvent::_internal_mutable_namespace_() {
  
  return _impl_.namespace__.Mutable(GetArenaForAllocation());
}
inline std::string* DocumentEvent::release_namespace_() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.DocumentEvent.namespace)
  return _impl_.namespace__.Release();
}
inline void DocumentEvent::set_allocated_namespace_(std::string* namespace_) {
  if (namespace_ != nullptr) {
    
  } else {
    
  }
  _impl_.namespace__.SetAllocated(namespace_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.namespace__.IsDefault()) {
    _impl_.namespace__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.DocumentEvent.namespace)
}

// int32 version = 4;
inline void DocumentEvent::clear_version() {
  _impl_.version_ = 0;
}
inline int32_t DocumentEvent::_internal_version() const {
  return _impl_.version_;
}
inline int32_t DocumentEvent::version() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.DocumentEvent.version)
  return _internal_version();
}
inline void DocumentEvent::_internal_set_version(int32_t value) {
  
  _impl_.version_ = value;
}
inline void DocumentEvent::set_version(int32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.DocumentEvent.version)
}

// .unhinged.cdc.DocumentEventType event_type = 5;
inline void DocumentEvent::clear_event_type() {
  _impl_.event_type_ = 0;
}
inline ::unhinged::cdc::DocumentEventType DocumentEvent::_internal_event_type() const {
  return static_cast< ::unhinged::cdc::DocumentEventType >(_impl_.event_type_);
}
inline ::unhinged::cdc::DocumentEventType DocumentEvent::event_type() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.DocumentEvent.event_type)
  return _internal_event_type();
}
inline void DocumentEvent::_internal_set_event_type(::unhinged::cdc::DocumentEventType value) {
  
  _impl_.event_type_ = value;
}
inline void DocumentEvent::set_event_type(::unhinged::cdc::DocumentEventType value) {
  _internal_set_event_type(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.DocumentEvent.event_type)
}

// .unhinged.cdc.DocumentCreated created = 10;
inline bool DocumentEvent::_internal_has_created() const {
  return event_data_case() == kCreated;
}
inline bool DocumentEvent::has_created() const {
  return _internal_has_created();
}
inline void DocumentEvent::set_has_created() {
  _impl_._oneof_case_[0] = kCreated;
}
inline void DocumentEvent::clear_created() {
  if (_internal_has_created()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_data_.created_;
    }
    clear_has_event_data();
  }
}
inline ::unhinged::cdc::DocumentCreated* DocumentEvent::release_created() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.DocumentEvent.created)
  if (_internal_has_created()) {
    clear_has_event_data();
    ::unhinged::cdc::DocumentCreated* temp = _impl_.event_data_.created_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_data_.created_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::cdc::DocumentCreated& DocumentEvent::_internal_created() const {
  return _internal_has_created()
      ? *_impl_.event_data_.created_
      : reinterpret_cast< ::unhinged::cdc::DocumentCreated&>(::unhinged::cdc::_DocumentCreated_default_instance_);
}
inline const ::unhinged::cdc::DocumentCreated& DocumentEvent::created() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.DocumentEvent.created)
  return _internal_created();
}
inline ::unhinged::cdc::DocumentCreated* DocumentEvent::unsafe_arena_release_created() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.cdc.DocumentEvent.created)
  if (_internal_has_created()) {
    clear_has_event_data();
    ::unhinged::cdc::DocumentCreated* temp = _impl_.event_data_.created_;
    _impl_.event_data_.created_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DocumentEvent::unsafe_arena_set_allocated_created(::unhinged::cdc::DocumentCreated* created) {
  clear_event_data();
  if (created) {
    set_has_created();
    _impl_.event_data_.created_ = created;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.DocumentEvent.created)
}
inline ::unhinged::cdc::DocumentCreated* DocumentEvent::_internal_mutable_created() {
  if (!_internal_has_created()) {
    clear_event_data();
    set_has_created();
    _impl_.event_data_.created_ = CreateMaybeMessage< ::unhinged::cdc::DocumentCreated >(GetArenaForAllocation());
  }
  return _impl_.event_data_.created_;
}
inline ::unhinged::cdc::DocumentCreated* DocumentEvent::mutable_created() {
  ::unhinged::cdc::DocumentCreated* _msg = _internal_mutable_created();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.DocumentEvent.created)
  return _msg;
}

// .unhinged.cdc.DocumentUpdated updated = 11;
inline bool DocumentEvent::_internal_has_updated() const {
  return event_data_case() == kUpdated;
}
inline bool DocumentEvent::has_updated() const {
  return _internal_has_updated();
}
inline void DocumentEvent::set_has_updated() {
  _impl_._oneof_case_[0] = kUpdated;
}
inline void DocumentEvent::clear_updated() {
  if (_internal_has_updated()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_data_.updated_;
    }
    clear_has_event_data();
  }
}
inline ::unhinged::cdc::DocumentUpdated* DocumentEvent::release_updated() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.DocumentEvent.updated)
  if (_internal_has_updated()) {
    clear_has_event_data();
    ::unhinged::cdc::DocumentUpdated* temp = _impl_.event_data_.updated_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_data_.updated_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::cdc::DocumentUpdated& DocumentEvent::_internal_updated() const {
  return _internal_has_updated()
      ? *_impl_.event_data_.updated_
      : reinterpret_cast< ::unhinged::cdc::DocumentUpdated&>(::unhinged::cdc::_DocumentUpdated_default_instance_);
}
inline const ::unhinged::cdc::DocumentUpdated& DocumentEvent::updated() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.DocumentEvent.updated)
  return _internal_updated();
}
inline ::unhinged::cdc::DocumentUpdated* DocumentEvent::unsafe_arena_release_updated() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.cdc.DocumentEvent.updated)
  if (_internal_has_updated()) {
    clear_has_event_data();
    ::unhinged::cdc::DocumentUpdated* temp = _impl_.event_data_.updated_;
    _impl_.event_data_.updated_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DocumentEvent::unsafe_arena_set_allocated_updated(::unhinged::cdc::DocumentUpdated* updated) {
  clear_event_data();
  if (updated) {
    set_has_updated();
    _impl_.event_data_.updated_ = updated;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.DocumentEvent.updated)
}
inline ::unhinged::cdc::DocumentUpdated* DocumentEvent::_internal_mutable_updated() {
  if (!_internal_has_updated()) {
    clear_event_data();
    set_has_updated();
    _impl_.event_data_.updated_ = CreateMaybeMessage< ::unhinged::cdc::DocumentUpdated >(GetArenaForAllocation());
  }
  return _impl_.event_data_.updated_;
}
inline ::unhinged::cdc::DocumentUpdated* DocumentEvent::mutable_updated() {
  ::unhinged::cdc::DocumentUpdated* _msg = _internal_mutable_updated();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.DocumentEvent.updated)
  return _msg;
}

// .unhinged.cdc.DocumentDeleted deleted = 12;
inline bool DocumentEvent::_internal_has_deleted() const {
  return event_data_case() == kDeleted;
}
inline bool DocumentEvent::has_deleted() const {
  return _internal_has_deleted();
}
inline void DocumentEvent::set_has_deleted() {
  _impl_._oneof_case_[0] = kDeleted;
}
inline void DocumentEvent::clear_deleted() {
  if (_internal_has_deleted()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_data_.deleted_;
    }
    clear_has_event_data();
  }
}
inline ::unhinged::cdc::DocumentDeleted* DocumentEvent::release_deleted() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.DocumentEvent.deleted)
  if (_internal_has_deleted()) {
    clear_has_event_data();
    ::unhinged::cdc::DocumentDeleted* temp = _impl_.event_data_.deleted_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_data_.deleted_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::cdc::DocumentDeleted& DocumentEvent::_internal_deleted() const {
  return _internal_has_deleted()
      ? *_impl_.event_data_.deleted_
      : reinterpret_cast< ::unhinged::cdc::DocumentDeleted&>(::unhinged::cdc::_DocumentDeleted_default_instance_);
}
inline const ::unhinged::cdc::DocumentDeleted& DocumentEvent::deleted() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.DocumentEvent.deleted)
  return _internal_deleted();
}
inline ::unhinged::cdc::DocumentDeleted* DocumentEvent::unsafe_arena_release_deleted() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.cdc.DocumentEvent.deleted)
  if (_internal_has_deleted()) {
    clear_has_event_data();
    ::unhinged::cdc::DocumentDeleted* temp = _impl_.event_data_.deleted_;
    _impl_.event_data_.deleted_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DocumentEvent::unsafe_arena_set_allocated_deleted(::unhinged::cdc::DocumentDeleted* deleted) {
  clear_event_data();
  if (deleted) {
    set_has_deleted();
    _impl_.event_data_.deleted_ = deleted;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.DocumentEvent.deleted)
}
inline ::unhinged::cdc::DocumentDeleted* DocumentEvent::_internal_mutable_deleted() {
  if (!_internal_has_deleted()) {
    clear_event_data();
    set_has_deleted();
    _impl_.event_data_.deleted_ = CreateMaybeMessage< ::unhinged::cdc::DocumentDeleted >(GetArenaForAllocation());
  }
  return _impl_.event_data_.deleted_;
}
inline ::unhinged::cdc::DocumentDeleted* DocumentEvent::mutable_deleted() {
  ::unhinged::cdc::DocumentDeleted* _msg = _internal_mutable_deleted();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.DocumentEvent.deleted)
  return _msg;
}

// .unhinged.cdc.DocumentAccessed accessed = 13;
inline bool DocumentEvent::_internal_has_accessed() const {
  return event_data_case() == kAccessed;
}
inline bool DocumentEvent::has_accessed() const {
  return _internal_has_accessed();
}
inline void DocumentEvent::set_has_accessed() {
  _impl_._oneof_case_[0] = kAccessed;
}
inline void DocumentEvent::clear_accessed() {
  if (_internal_has_accessed()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_data_.accessed_;
    }
    clear_has_event_data();
  }
}
inline ::unhinged::cdc::DocumentAccessed* DocumentEvent::release_accessed() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.DocumentEvent.accessed)
  if (_internal_has_accessed()) {
    clear_has_event_data();
    ::unhinged::cdc::DocumentAccessed* temp = _impl_.event_data_.accessed_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_data_.accessed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::cdc::DocumentAccessed& DocumentEvent::_internal_accessed() const {
  return _internal_has_accessed()
      ? *_impl_.event_data_.accessed_
      : reinterpret_cast< ::unhinged::cdc::DocumentAccessed&>(::unhinged::cdc::_DocumentAccessed_default_instance_);
}
inline const ::unhinged::cdc::DocumentAccessed& DocumentEvent::accessed() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.DocumentEvent.accessed)
  return _internal_accessed();
}
inline ::unhinged::cdc::DocumentAccessed* DocumentEvent::unsafe_arena_release_accessed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.cdc.DocumentEvent.accessed)
  if (_internal_has_accessed()) {
    clear_has_event_data();
    ::unhinged::cdc::DocumentAccessed* temp = _impl_.event_data_.accessed_;
    _impl_.event_data_.accessed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DocumentEvent::unsafe_arena_set_allocated_accessed(::unhinged::cdc::DocumentAccessed* accessed) {
  clear_event_data();
  if (accessed) {
    set_has_accessed();
    _impl_.event_data_.accessed_ = accessed;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.DocumentEvent.accessed)
}
inline ::unhinged::cdc::DocumentAccessed* DocumentEvent::_internal_mutable_accessed() {
  if (!_internal_has_accessed()) {
    clear_event_data();
    set_has_accessed();
    _impl_.event_data_.accessed_ = CreateMaybeMessage< ::unhinged::cdc::DocumentAccessed >(GetArenaForAllocation());
  }
  return _impl_.event_data_.accessed_;
}
inline ::unhinged::cdc::DocumentAccessed* DocumentEvent::mutable_accessed() {
  ::unhinged::cdc::DocumentAccessed* _msg = _internal_mutable_accessed();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.DocumentEvent.accessed)
  return _msg;
}

// .unhinged.cdc.DocumentTagged tagged = 14;
inline bool DocumentEvent::_internal_has_tagged() const {
  return event_data_case() == kTagged;
}
inline bool DocumentEvent::has_tagged() const {
  return _internal_has_tagged();
}
inline void DocumentEvent::set_has_tagged() {
  _impl_._oneof_case_[0] = kTagged;
}
inline void DocumentEvent::clear_tagged() {
  if (_internal_has_tagged()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_data_.tagged_;
    }
    clear_has_event_data();
  }
}
inline ::unhinged::cdc::DocumentTagged* DocumentEvent::release_tagged() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.DocumentEvent.tagged)
  if (_internal_has_tagged()) {
    clear_has_event_data();
    ::unhinged::cdc::DocumentTagged* temp = _impl_.event_data_.tagged_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_data_.tagged_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::cdc::DocumentTagged& DocumentEvent::_internal_tagged() const {
  return _internal_has_tagged()
      ? *_impl_.event_data_.tagged_
      : reinterpret_cast< ::unhinged::cdc::DocumentTagged&>(::unhinged::cdc::_DocumentTagged_default_instance_);
}
inline const ::unhinged::cdc::DocumentTagged& DocumentEvent::tagged() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.DocumentEvent.tagged)
  return _internal_tagged();
}
inline ::unhinged::cdc::DocumentTagged* DocumentEvent::unsafe_arena_release_tagged() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.cdc.DocumentEvent.tagged)
  if (_internal_has_tagged()) {
    clear_has_event_data();
    ::unhinged::cdc::DocumentTagged* temp = _impl_.event_data_.tagged_;
    _impl_.event_data_.tagged_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DocumentEvent::unsafe_arena_set_allocated_tagged(::unhinged::cdc::DocumentTagged* tagged) {
  clear_event_data();
  if (tagged) {
    set_has_tagged();
    _impl_.event_data_.tagged_ = tagged;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.DocumentEvent.tagged)
}
inline ::unhinged::cdc::DocumentTagged* DocumentEvent::_internal_mutable_tagged() {
  if (!_internal_has_tagged()) {
    clear_event_data();
    set_has_tagged();
    _impl_.event_data_.tagged_ = CreateMaybeMessage< ::unhinged::cdc::DocumentTagged >(GetArenaForAllocation());
  }
  return _impl_.event_data_.tagged_;
}
inline ::unhinged::cdc::DocumentTagged* DocumentEvent::mutable_tagged() {
  ::unhinged::cdc::DocumentTagged* _msg = _internal_mutable_tagged();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.DocumentEvent.tagged)
  return _msg;
}

// .unhinged.cdc.DocumentVersioned versioned = 15;
inline bool DocumentEvent::_internal_has_versioned() const {
  return event_data_case() == kVersioned;
}
inline bool DocumentEvent::has_versioned() const {
  return _internal_has_versioned();
}
inline void DocumentEvent::set_has_versioned() {
  _impl_._oneof_case_[0] = kVersioned;
}
inline void DocumentEvent::clear_versioned() {
  if (_internal_has_versioned()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_data_.versioned_;
    }
    clear_has_event_data();
  }
}
inline ::unhinged::cdc::DocumentVersioned* DocumentEvent::release_versioned() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.DocumentEvent.versioned)
  if (_internal_has_versioned()) {
    clear_has_event_data();
    ::unhinged::cdc::DocumentVersioned* temp = _impl_.event_data_.versioned_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_data_.versioned_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::cdc::DocumentVersioned& DocumentEvent::_internal_versioned() const {
  return _internal_has_versioned()
      ? *_impl_.event_data_.versioned_
      : reinterpret_cast< ::unhinged::cdc::DocumentVersioned&>(::unhinged::cdc::_DocumentVersioned_default_instance_);
}
inline const ::unhinged::cdc::DocumentVersioned& DocumentEvent::versioned() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.DocumentEvent.versioned)
  return _internal_versioned();
}
inline ::unhinged::cdc::DocumentVersioned* DocumentEvent::unsafe_arena_release_versioned() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.cdc.DocumentEvent.versioned)
  if (_internal_has_versioned()) {
    clear_has_event_data();
    ::unhinged::cdc::DocumentVersioned* temp = _impl_.event_data_.versioned_;
    _impl_.event_data_.versioned_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DocumentEvent::unsafe_arena_set_allocated_versioned(::unhinged::cdc::DocumentVersioned* versioned) {
  clear_event_data();
  if (versioned) {
    set_has_versioned();
    _impl_.event_data_.versioned_ = versioned;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.DocumentEvent.versioned)
}
inline ::unhinged::cdc::DocumentVersioned* DocumentEvent::_internal_mutable_versioned() {
  if (!_internal_has_versioned()) {
    clear_event_data();
    set_has_versioned();
    _impl_.event_data_.versioned_ = CreateMaybeMessage< ::unhinged::cdc::DocumentVersioned >(GetArenaForAllocation());
  }
  return _impl_.event_data_.versioned_;
}
inline ::unhinged::cdc::DocumentVersioned* DocumentEvent::mutable_versioned() {
  ::unhinged::cdc::DocumentVersioned* _msg = _internal_mutable_versioned();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.DocumentEvent.versioned)
  return _msg;
}

inline bool DocumentEvent::has_event_data() const {
  return event_data_case() != EVENT_DATA_NOT_SET;
}
inline void DocumentEvent::clear_has_event_data() {
  _impl_._oneof_case_[0] = EVENT_DATA_NOT_SET;
}
inline DocumentEvent::EventDataCase DocumentEvent::event_data_case() const {
  return DocumentEvent::EventDataCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// DocumentCreated

// string document_name = 1;
inline void DocumentCreated::clear_document_name() {
  _impl_.document_name_.ClearToEmpty();
}
inline const std::string& DocumentCreated::document_name() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.DocumentCreated.document_name)
  return _internal_document_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DocumentCreated::set_document_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.document_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.DocumentCreated.document_name)
}
inline std::string* DocumentCreated::mutable_document_name() {
  std::string* _s = _internal_mutable_document_name();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.DocumentCreated.document_name)
  return _s;
}
inline const std::string& DocumentCreated::_internal_document_name() const {
  return _impl_.document_name_.Get();
}
inline void DocumentCreated::_internal_set_document_name(const std::string& value) {
  
  _impl_.document_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DocumentCreated::_internal_mutable_document_name() {
  
  return _impl_.document_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DocumentCreated::release_document_name() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.DocumentCreated.document_name)
  return _impl_.document_name_.Release();
}
inline void DocumentCreated::set_allocated_document_name(std::string* document_name) {
  if (document_name != nullptr) {
    
  } else {
    
  }
  _impl_.document_name_.SetAllocated(document_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.document_name_.IsDefault()) {
    _impl_.document_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.DocumentCreated.document_name)
}

// string created_by = 2;
inline void DocumentCreated::clear_created_by() {
  _impl_.created_by_.ClearToEmpty();
}
inline const std::string& DocumentCreated::created_by() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.DocumentCreated.created_by)
  return _internal_created_by();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DocumentCreated::set_created_by(ArgT0&& arg0, ArgT... args) {
 
 _impl_.created_by_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.DocumentCreated.created_by)
}
inline std::string* DocumentCreated::mutable_created_by() {
  std::string* _s = _internal_mutable_created_by();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.DocumentCreated.created_by)
  return _s;
}
inline const std::string& DocumentCreated::_internal_created_by() const {
  return _impl_.created_by_.Get();
}
inline void DocumentCreated::_internal_set_created_by(const std::string& value) {
  
  _impl_.created_by_.Set(value, GetArenaForAllocation());
}
inline std::string* DocumentCreated::_internal_mutable_created_by() {
  
  return _impl_.created_by_.Mutable(GetArenaForAllocation());
}
inline std::string* DocumentCreated::release_created_by() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.DocumentCreated.created_by)
  return _impl_.created_by_.Release();
}
inline void DocumentCreated::set_allocated_created_by(std::string* created_by) {
  if (created_by != nullptr) {
    
  } else {
    
  }
  _impl_.created_by_.SetAllocated(created_by, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.created_by_.IsDefault()) {
    _impl_.created_by_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.DocumentCreated.created_by)
}

// string created_by_type = 3;
inline void DocumentCreated::clear_created_by_type() {
  _impl_.created_by_type_.ClearToEmpty();
}
inline const std::string& DocumentCreated::created_by_type() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.DocumentCreated.created_by_type)
  return _internal_created_by_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DocumentCreated::set_created_by_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.created_by_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.DocumentCreated.created_by_type)
}
inline std::string* DocumentCreated::mutable_created_by_type() {
  std::string* _s = _internal_mutable_created_by_type();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.DocumentCreated.created_by_type)
  return _s;
}
inline const std::string& DocumentCreated::_internal_created_by_type() const {
  return _impl_.created_by_type_.Get();
}
inline void DocumentCreated::_internal_set_created_by_type(const std::string& value) {
  
  _impl_.created_by_type_.Set(value, GetArenaForAllocation());
}
inline std::string* DocumentCreated::_internal_mutable_created_by_type() {
  
  return _impl_.created_by_type_.Mutable(GetArenaForAllocation());
}
inline std::string* DocumentCreated::release_created_by_type() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.DocumentCreated.created_by_type)
  return _impl_.created_by_type_.Release();
}
inline void DocumentCreated::set_allocated_created_by_type(std::string* created_by_type) {
  if (created_by_type != nullptr) {
    
  } else {
    
  }
  _impl_.created_by_type_.SetAllocated(created_by_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.created_by_type_.IsDefault()) {
    _impl_.created_by_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.DocumentCreated.created_by_type)
}

// .google.protobuf.Struct document_metadata = 4;
inline bool DocumentCreated::_internal_has_document_metadata() const {
  return this != internal_default_instance() && _impl_.document_metadata_ != nullptr;
}
inline bool DocumentCreated::has_document_metadata() const {
  return _internal_has_document_metadata();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& DocumentCreated::_internal_document_metadata() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.document_metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& DocumentCreated::document_metadata() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.DocumentCreated.document_metadata)
  return _internal_document_metadata();
}
inline void DocumentCreated::unsafe_arena_set_allocated_document_metadata(
    ::PROTOBUF_NAMESPACE_ID::Struct* document_metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.document_metadata_);
  }
  _impl_.document_metadata_ = document_metadata;
  if (document_metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.DocumentCreated.document_metadata)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* DocumentCreated::release_document_metadata() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.document_metadata_;
  _impl_.document_metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* DocumentCreated::unsafe_arena_release_document_metadata() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.DocumentCreated.document_metadata)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.document_metadata_;
  _impl_.document_metadata_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* DocumentCreated::_internal_mutable_document_metadata() {
  
  if (_impl_.document_metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.document_metadata_ = p;
  }
  return _impl_.document_metadata_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* DocumentCreated::mutable_document_metadata() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_document_metadata();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.DocumentCreated.document_metadata)
  return _msg;
}
inline void DocumentCreated::set_allocated_document_metadata(::PROTOBUF_NAMESPACE_ID::Struct* document_metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.document_metadata_);
  }
  if (document_metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(document_metadata));
    if (message_arena != submessage_arena) {
      document_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, document_metadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.document_metadata_ = document_metadata;
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.DocumentCreated.document_metadata)
}

// int64 document_size_bytes = 5;
inline void DocumentCreated::clear_document_size_bytes() {
  _impl_.document_size_bytes_ = int64_t{0};
}
inline int64_t DocumentCreated::_internal_document_size_bytes() const {
  return _impl_.document_size_bytes_;
}
inline int64_t DocumentCreated::document_size_bytes() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.DocumentCreated.document_size_bytes)
  return _internal_document_size_bytes();
}
inline void DocumentCreated::_internal_set_document_size_bytes(int64_t value) {
  
  _impl_.document_size_bytes_ = value;
}
inline void DocumentCreated::set_document_size_bytes(int64_t value) {
  _internal_set_document_size_bytes(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.DocumentCreated.document_size_bytes)
}

// -------------------------------------------------------------------

// DocumentUpdated

// int32 previous_version = 1;
inline void DocumentUpdated::clear_previous_version() {
  _impl_.previous_version_ = 0;
}
inline int32_t DocumentUpdated::_internal_previous_version() const {
  return _impl_.previous_version_;
}
inline int32_t DocumentUpdated::previous_version() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.DocumentUpdated.previous_version)
  return _internal_previous_version();
}
inline void DocumentUpdated::_internal_set_previous_version(int32_t value) {
  
  _impl_.previous_version_ = value;
}
inline void DocumentUpdated::set_previous_version(int32_t value) {
  _internal_set_previous_version(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.DocumentUpdated.previous_version)
}

// string updated_by = 2;
inline void DocumentUpdated::clear_updated_by() {
  _impl_.updated_by_.ClearToEmpty();
}
inline const std::string& DocumentUpdated::updated_by() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.DocumentUpdated.updated_by)
  return _internal_updated_by();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DocumentUpdated::set_updated_by(ArgT0&& arg0, ArgT... args) {
 
 _impl_.updated_by_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.DocumentUpdated.updated_by)
}
inline std::string* DocumentUpdated::mutable_updated_by() {
  std::string* _s = _internal_mutable_updated_by();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.DocumentUpdated.updated_by)
  return _s;
}
inline const std::string& DocumentUpdated::_internal_updated_by() const {
  return _impl_.updated_by_.Get();
}
inline void DocumentUpdated::_internal_set_updated_by(const std::string& value) {
  
  _impl_.updated_by_.Set(value, GetArenaForAllocation());
}
inline std::string* DocumentUpdated::_internal_mutable_updated_by() {
  
  return _impl_.updated_by_.Mutable(GetArenaForAllocation());
}
inline std::string* DocumentUpdated::release_updated_by() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.DocumentUpdated.updated_by)
  return _impl_.updated_by_.Release();
}
inline void DocumentUpdated::set_allocated_updated_by(std::string* updated_by) {
  if (updated_by != nullptr) {
    
  } else {
    
  }
  _impl_.updated_by_.SetAllocated(updated_by, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.updated_by_.IsDefault()) {
    _impl_.updated_by_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.DocumentUpdated.updated_by)
}

// string updated_by_type = 3;
inline void DocumentUpdated::clear_updated_by_type() {
  _impl_.updated_by_type_.ClearToEmpty();
}
inline const std::string& DocumentUpdated::updated_by_type() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.DocumentUpdated.updated_by_type)
  return _internal_updated_by_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DocumentUpdated::set_updated_by_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.updated_by_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.DocumentUpdated.updated_by_type)
}
inline std::string* DocumentUpdated::mutable_updated_by_type() {
  std::string* _s = _internal_mutable_updated_by_type();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.DocumentUpdated.updated_by_type)
  return _s;
}
inline const std::string& DocumentUpdated::_internal_updated_by_type() const {
  return _impl_.updated_by_type_.Get();
}
inline void DocumentUpdated::_internal_set_updated_by_type(const std::string& value) {
  
  _impl_.updated_by_type_.Set(value, GetArenaForAllocation());
}
inline std::string* DocumentUpdated::_internal_mutable_updated_by_type() {
  
  return _impl_.updated_by_type_.Mutable(GetArenaForAllocation());
}
inline std::string* DocumentUpdated::release_updated_by_type() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.DocumentUpdated.updated_by_type)
  return _impl_.updated_by_type_.Release();
}
inline void DocumentUpdated::set_allocated_updated_by_type(std::string* updated_by_type) {
  if (updated_by_type != nullptr) {
    
  } else {
    
  }
  _impl_.updated_by_type_.SetAllocated(updated_by_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.updated_by_type_.IsDefault()) {
    _impl_.updated_by_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.DocumentUpdated.updated_by_type)
}

// repeated string changed_fields = 4;
inline int DocumentUpdated::_internal_changed_fields_size() const {
  return _impl_.changed_fields_.size();
}
inline int DocumentUpdated::changed_fields_size() const {
  return _internal_changed_fields_size();
}
inline void DocumentUpdated::clear_changed_fields() {
  _impl_.changed_fields_.Clear();
}
inline std::string* DocumentUpdated::add_changed_fields() {
  std::string* _s = _internal_add_changed_fields();
  // @@protoc_insertion_point(field_add_mutable:unhinged.cdc.DocumentUpdated.changed_fields)
  return _s;
}
inline const std::string& DocumentUpdated::_internal_changed_fields(int index) const {
  return _impl_.changed_fields_.Get(index);
}
inline const std::string& DocumentUpdated::changed_fields(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.DocumentUpdated.changed_fields)
  return _internal_changed_fields(index);
}
inline std::string* DocumentUpdated::mutable_changed_fields(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.DocumentUpdated.changed_fields)
  return _impl_.changed_fields_.Mutable(index);
}
inline void DocumentUpdated::set_changed_fields(int index, const std::string& value) {
  _impl_.changed_fields_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.DocumentUpdated.changed_fields)
}
inline void DocumentUpdated::set_changed_fields(int index, std::string&& value) {
  _impl_.changed_fields_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.cdc.DocumentUpdated.changed_fields)
}
inline void DocumentUpdated::set_changed_fields(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.changed_fields_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.cdc.DocumentUpdated.changed_fields)
}
inline void DocumentUpdated::set_changed_fields(int index, const char* value, size_t size) {
  _impl_.changed_fields_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.cdc.DocumentUpdated.changed_fields)
}
inline std::string* DocumentUpdated::_internal_add_changed_fields() {
  return _impl_.changed_fields_.Add();
}
inline void DocumentUpdated::add_changed_fields(const std::string& value) {
  _impl_.changed_fields_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.cdc.DocumentUpdated.changed_fields)
}
inline void DocumentUpdated::add_changed_fields(std::string&& value) {
  _impl_.changed_fields_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.cdc.DocumentUpdated.changed_fields)
}
inline void DocumentUpdated::add_changed_fields(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.changed_fields_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.cdc.DocumentUpdated.changed_fields)
}
inline void DocumentUpdated::add_changed_fields(const char* value, size_t size) {
  _impl_.changed_fields_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.cdc.DocumentUpdated.changed_fields)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DocumentUpdated::changed_fields() const {
  // @@protoc_insertion_point(field_list:unhinged.cdc.DocumentUpdated.changed_fields)
  return _impl_.changed_fields_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DocumentUpdated::mutable_changed_fields() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.cdc.DocumentUpdated.changed_fields)
  return &_impl_.changed_fields_;
}

// .google.protobuf.Struct changes = 5;
inline bool DocumentUpdated::_internal_has_changes() const {
  return this != internal_default_instance() && _impl_.changes_ != nullptr;
}
inline bool DocumentUpdated::has_changes() const {
  return _internal_has_changes();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& DocumentUpdated::_internal_changes() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.changes_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& DocumentUpdated::changes() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.DocumentUpdated.changes)
  return _internal_changes();
}
inline void DocumentUpdated::unsafe_arena_set_allocated_changes(
    ::PROTOBUF_NAMESPACE_ID::Struct* changes) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.changes_);
  }
  _impl_.changes_ = changes;
  if (changes) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.DocumentUpdated.changes)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* DocumentUpdated::release_changes() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.changes_;
  _impl_.changes_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* DocumentUpdated::unsafe_arena_release_changes() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.DocumentUpdated.changes)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.changes_;
  _impl_.changes_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* DocumentUpdated::_internal_mutable_changes() {
  
  if (_impl_.changes_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.changes_ = p;
  }
  return _impl_.changes_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* DocumentUpdated::mutable_changes() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_changes();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.DocumentUpdated.changes)
  return _msg;
}
inline void DocumentUpdated::set_allocated_changes(::PROTOBUF_NAMESPACE_ID::Struct* changes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.changes_);
  }
  if (changes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(changes));
    if (message_arena != submessage_arena) {
      changes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, changes, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.changes_ = changes;
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.DocumentUpdated.changes)
}

// -------------------------------------------------------------------

// DocumentDeleted

// string deleted_by = 1;
inline void DocumentDeleted::clear_deleted_by() {
  _impl_.deleted_by_.ClearToEmpty();
}
inline const std::string& DocumentDeleted::deleted_by() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.DocumentDeleted.deleted_by)
  return _internal_deleted_by();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DocumentDeleted::set_deleted_by(ArgT0&& arg0, ArgT... args) {
 
 _impl_.deleted_by_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.DocumentDeleted.deleted_by)
}
inline std::string* DocumentDeleted::mutable_deleted_by() {
  std::string* _s = _internal_mutable_deleted_by();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.DocumentDeleted.deleted_by)
  return _s;
}
inline const std::string& DocumentDeleted::_internal_deleted_by() const {
  return _impl_.deleted_by_.Get();
}
inline void DocumentDeleted::_internal_set_deleted_by(const std::string& value) {
  
  _impl_.deleted_by_.Set(value, GetArenaForAllocation());
}
inline std::string* DocumentDeleted::_internal_mutable_deleted_by() {
  
  return _impl_.deleted_by_.Mutable(GetArenaForAllocation());
}
inline std::string* DocumentDeleted::release_deleted_by() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.DocumentDeleted.deleted_by)
  return _impl_.deleted_by_.Release();
}
inline void DocumentDeleted::set_allocated_deleted_by(std::string* deleted_by) {
  if (deleted_by != nullptr) {
    
  } else {
    
  }
  _impl_.deleted_by_.SetAllocated(deleted_by, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.deleted_by_.IsDefault()) {
    _impl_.deleted_by_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.DocumentDeleted.deleted_by)
}

// string deleted_by_type = 2;
inline void DocumentDeleted::clear_deleted_by_type() {
  _impl_.deleted_by_type_.ClearToEmpty();
}
inline const std::string& DocumentDeleted::deleted_by_type() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.DocumentDeleted.deleted_by_type)
  return _internal_deleted_by_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DocumentDeleted::set_deleted_by_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.deleted_by_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.DocumentDeleted.deleted_by_type)
}
inline std::string* DocumentDeleted::mutable_deleted_by_type() {
  std::string* _s = _internal_mutable_deleted_by_type();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.DocumentDeleted.deleted_by_type)
  return _s;
}
inline const std::string& DocumentDeleted::_internal_deleted_by_type() const {
  return _impl_.deleted_by_type_.Get();
}
inline void DocumentDeleted::_internal_set_deleted_by_type(const std::string& value) {
  
  _impl_.deleted_by_type_.Set(value, GetArenaForAllocation());
}
inline std::string* DocumentDeleted::_internal_mutable_deleted_by_type() {
  
  return _impl_.deleted_by_type_.Mutable(GetArenaForAllocation());
}
inline std::string* DocumentDeleted::release_deleted_by_type() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.DocumentDeleted.deleted_by_type)
  return _impl_.deleted_by_type_.Release();
}
inline void DocumentDeleted::set_allocated_deleted_by_type(std::string* deleted_by_type) {
  if (deleted_by_type != nullptr) {
    
  } else {
    
  }
  _impl_.deleted_by_type_.SetAllocated(deleted_by_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.deleted_by_type_.IsDefault()) {
    _impl_.deleted_by_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.DocumentDeleted.deleted_by_type)
}

// int32 versions_deleted = 3;
inline void DocumentDeleted::clear_versions_deleted() {
  _impl_.versions_deleted_ = 0;
}
inline int32_t DocumentDeleted::_internal_versions_deleted() const {
  return _impl_.versions_deleted_;
}
inline int32_t DocumentDeleted::versions_deleted() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.DocumentDeleted.versions_deleted)
  return _internal_versions_deleted();
}
inline void DocumentDeleted::_internal_set_versions_deleted(int32_t value) {
  
  _impl_.versions_deleted_ = value;
}
inline void DocumentDeleted::set_versions_deleted(int32_t value) {
  _internal_set_versions_deleted(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.DocumentDeleted.versions_deleted)
}

// string deletion_reason = 4;
inline void DocumentDeleted::clear_deletion_reason() {
  _impl_.deletion_reason_.ClearToEmpty();
}
inline const std::string& DocumentDeleted::deletion_reason() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.DocumentDeleted.deletion_reason)
  return _internal_deletion_reason();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DocumentDeleted::set_deletion_reason(ArgT0&& arg0, ArgT... args) {
 
 _impl_.deletion_reason_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.DocumentDeleted.deletion_reason)
}
inline std::string* DocumentDeleted::mutable_deletion_reason() {
  std::string* _s = _internal_mutable_deletion_reason();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.DocumentDeleted.deletion_reason)
  return _s;
}
inline const std::string& DocumentDeleted::_internal_deletion_reason() const {
  return _impl_.deletion_reason_.Get();
}
inline void DocumentDeleted::_internal_set_deletion_reason(const std::string& value) {
  
  _impl_.deletion_reason_.Set(value, GetArenaForAllocation());
}
inline std::string* DocumentDeleted::_internal_mutable_deletion_reason() {
  
  return _impl_.deletion_reason_.Mutable(GetArenaForAllocation());
}
inline std::string* DocumentDeleted::release_deletion_reason() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.DocumentDeleted.deletion_reason)
  return _impl_.deletion_reason_.Release();
}
inline void DocumentDeleted::set_allocated_deletion_reason(std::string* deletion_reason) {
  if (deletion_reason != nullptr) {
    
  } else {
    
  }
  _impl_.deletion_reason_.SetAllocated(deletion_reason, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.deletion_reason_.IsDefault()) {
    _impl_.deletion_reason_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.DocumentDeleted.deletion_reason)
}

// -------------------------------------------------------------------

// DocumentAccessed

// string accessed_by = 1;
inline void DocumentAccessed::clear_accessed_by() {
  _impl_.accessed_by_.ClearToEmpty();
}
inline const std::string& DocumentAccessed::accessed_by() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.DocumentAccessed.accessed_by)
  return _internal_accessed_by();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DocumentAccessed::set_accessed_by(ArgT0&& arg0, ArgT... args) {
 
 _impl_.accessed_by_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.DocumentAccessed.accessed_by)
}
inline std::string* DocumentAccessed::mutable_accessed_by() {
  std::string* _s = _internal_mutable_accessed_by();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.DocumentAccessed.accessed_by)
  return _s;
}
inline const std::string& DocumentAccessed::_internal_accessed_by() const {
  return _impl_.accessed_by_.Get();
}
inline void DocumentAccessed::_internal_set_accessed_by(const std::string& value) {
  
  _impl_.accessed_by_.Set(value, GetArenaForAllocation());
}
inline std::string* DocumentAccessed::_internal_mutable_accessed_by() {
  
  return _impl_.accessed_by_.Mutable(GetArenaForAllocation());
}
inline std::string* DocumentAccessed::release_accessed_by() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.DocumentAccessed.accessed_by)
  return _impl_.accessed_by_.Release();
}
inline void DocumentAccessed::set_allocated_accessed_by(std::string* accessed_by) {
  if (accessed_by != nullptr) {
    
  } else {
    
  }
  _impl_.accessed_by_.SetAllocated(accessed_by, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.accessed_by_.IsDefault()) {
    _impl_.accessed_by_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.DocumentAccessed.accessed_by)
}

// string accessed_by_type = 2;
inline void DocumentAccessed::clear_accessed_by_type() {
  _impl_.accessed_by_type_.ClearToEmpty();
}
inline const std::string& DocumentAccessed::accessed_by_type() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.DocumentAccessed.accessed_by_type)
  return _internal_accessed_by_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DocumentAccessed::set_accessed_by_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.accessed_by_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.DocumentAccessed.accessed_by_type)
}
inline std::string* DocumentAccessed::mutable_accessed_by_type() {
  std::string* _s = _internal_mutable_accessed_by_type();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.DocumentAccessed.accessed_by_type)
  return _s;
}
inline const std::string& DocumentAccessed::_internal_accessed_by_type() const {
  return _impl_.accessed_by_type_.Get();
}
inline void DocumentAccessed::_internal_set_accessed_by_type(const std::string& value) {
  
  _impl_.accessed_by_type_.Set(value, GetArenaForAllocation());
}
inline std::string* DocumentAccessed::_internal_mutable_accessed_by_type() {
  
  return _impl_.accessed_by_type_.Mutable(GetArenaForAllocation());
}
inline std::string* DocumentAccessed::release_accessed_by_type() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.DocumentAccessed.accessed_by_type)
  return _impl_.accessed_by_type_.Release();
}
inline void DocumentAccessed::set_allocated_accessed_by_type(std::string* accessed_by_type) {
  if (accessed_by_type != nullptr) {
    
  } else {
    
  }
  _impl_.accessed_by_type_.SetAllocated(accessed_by_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.accessed_by_type_.IsDefault()) {
    _impl_.accessed_by_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.DocumentAccessed.accessed_by_type)
}

// string access_method = 3;
inline void DocumentAccessed::clear_access_method() {
  _impl_.access_method_.ClearToEmpty();
}
inline const std::string& DocumentAccessed::access_method() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.DocumentAccessed.access_method)
  return _internal_access_method();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DocumentAccessed::set_access_method(ArgT0&& arg0, ArgT... args) {
 
 _impl_.access_method_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.DocumentAccessed.access_method)
}
inline std::string* DocumentAccessed::mutable_access_method() {
  std::string* _s = _internal_mutable_access_method();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.DocumentAccessed.access_method)
  return _s;
}
inline const std::string& DocumentAccessed::_internal_access_method() const {
  return _impl_.access_method_.Get();
}
inline void DocumentAccessed::_internal_set_access_method(const std::string& value) {
  
  _impl_.access_method_.Set(value, GetArenaForAllocation());
}
inline std::string* DocumentAccessed::_internal_mutable_access_method() {
  
  return _impl_.access_method_.Mutable(GetArenaForAllocation());
}
inline std::string* DocumentAccessed::release_access_method() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.DocumentAccessed.access_method)
  return _impl_.access_method_.Release();
}
inline void DocumentAccessed::set_allocated_access_method(std::string* access_method) {
  if (access_method != nullptr) {
    
  } else {
    
  }
  _impl_.access_method_.SetAllocated(access_method, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.access_method_.IsDefault()) {
    _impl_.access_method_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.DocumentAccessed.access_method)
}

// bool body_included = 4;
inline void DocumentAccessed::clear_body_included() {
  _impl_.body_included_ = false;
}
inline bool DocumentAccessed::_internal_body_included() const {
  return _impl_.body_included_;
}
inline bool DocumentAccessed::body_included() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.DocumentAccessed.body_included)
  return _internal_body_included();
}
inline void DocumentAccessed::_internal_set_body_included(bool value) {
  
  _impl_.body_included_ = value;
}
inline void DocumentAccessed::set_body_included(bool value) {
  _internal_set_body_included(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.DocumentAccessed.body_included)
}

// -------------------------------------------------------------------

// DocumentTagged

// string tag = 1;
inline void DocumentTagged::clear_tag() {
  _impl_.tag_.ClearToEmpty();
}
inline const std::string& DocumentTagged::tag() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.DocumentTagged.tag)
  return _internal_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DocumentTagged::set_tag(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.DocumentTagged.tag)
}
inline std::string* DocumentTagged::mutable_tag() {
  std::string* _s = _internal_mutable_tag();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.DocumentTagged.tag)
  return _s;
}
inline const std::string& DocumentTagged::_internal_tag() const {
  return _impl_.tag_.Get();
}
inline void DocumentTagged::_internal_set_tag(const std::string& value) {
  
  _impl_.tag_.Set(value, GetArenaForAllocation());
}
inline std::string* DocumentTagged::_internal_mutable_tag() {
  
  return _impl_.tag_.Mutable(GetArenaForAllocation());
}
inline std::string* DocumentTagged::release_tag() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.DocumentTagged.tag)
  return _impl_.tag_.Release();
}
inline void DocumentTagged::set_allocated_tag(std::string* tag) {
  if (tag != nullptr) {
    
  } else {
    
  }
  _impl_.tag_.SetAllocated(tag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tag_.IsDefault()) {
    _impl_.tag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.DocumentTagged.tag)
}

// string tagged_by = 2;
inline void DocumentTagged::clear_tagged_by() {
  _impl_.tagged_by_.ClearToEmpty();
}
inline const std::string& DocumentTagged::tagged_by() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.DocumentTagged.tagged_by)
  return _internal_tagged_by();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DocumentTagged::set_tagged_by(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tagged_by_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.DocumentTagged.tagged_by)
}
inline std::string* DocumentTagged::mutable_tagged_by() {
  std::string* _s = _internal_mutable_tagged_by();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.DocumentTagged.tagged_by)
  return _s;
}
inline const std::string& DocumentTagged::_internal_tagged_by() const {
  return _impl_.tagged_by_.Get();
}
inline void DocumentTagged::_internal_set_tagged_by(const std::string& value) {
  
  _impl_.tagged_by_.Set(value, GetArenaForAllocation());
}
inline std::string* DocumentTagged::_internal_mutable_tagged_by() {
  
  return _impl_.tagged_by_.Mutable(GetArenaForAllocation());
}
inline std::string* DocumentTagged::release_tagged_by() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.DocumentTagged.tagged_by)
  return _impl_.tagged_by_.Release();
}
inline void DocumentTagged::set_allocated_tagged_by(std::string* tagged_by) {
  if (tagged_by != nullptr) {
    
  } else {
    
  }
  _impl_.tagged_by_.SetAllocated(tagged_by, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tagged_by_.IsDefault()) {
    _impl_.tagged_by_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.DocumentTagged.tagged_by)
}

// string tagged_by_type = 3;
inline void DocumentTagged::clear_tagged_by_type() {
  _impl_.tagged_by_type_.ClearToEmpty();
}
inline const std::string& DocumentTagged::tagged_by_type() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.DocumentTagged.tagged_by_type)
  return _internal_tagged_by_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DocumentTagged::set_tagged_by_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tagged_by_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.DocumentTagged.tagged_by_type)
}
inline std::string* DocumentTagged::mutable_tagged_by_type() {
  std::string* _s = _internal_mutable_tagged_by_type();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.DocumentTagged.tagged_by_type)
  return _s;
}
inline const std::string& DocumentTagged::_internal_tagged_by_type() const {
  return _impl_.tagged_by_type_.Get();
}
inline void DocumentTagged::_internal_set_tagged_by_type(const std::string& value) {
  
  _impl_.tagged_by_type_.Set(value, GetArenaForAllocation());
}
inline std::string* DocumentTagged::_internal_mutable_tagged_by_type() {
  
  return _impl_.tagged_by_type_.Mutable(GetArenaForAllocation());
}
inline std::string* DocumentTagged::release_tagged_by_type() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.DocumentTagged.tagged_by_type)
  return _impl_.tagged_by_type_.Release();
}
inline void DocumentTagged::set_allocated_tagged_by_type(std::string* tagged_by_type) {
  if (tagged_by_type != nullptr) {
    
  } else {
    
  }
  _impl_.tagged_by_type_.SetAllocated(tagged_by_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tagged_by_type_.IsDefault()) {
    _impl_.tagged_by_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.DocumentTagged.tagged_by_type)
}

// string tag_operation = 4;
inline void DocumentTagged::clear_tag_operation() {
  _impl_.tag_operation_.ClearToEmpty();
}
inline const std::string& DocumentTagged::tag_operation() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.DocumentTagged.tag_operation)
  return _internal_tag_operation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DocumentTagged::set_tag_operation(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tag_operation_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.DocumentTagged.tag_operation)
}
inline std::string* DocumentTagged::mutable_tag_operation() {
  std::string* _s = _internal_mutable_tag_operation();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.DocumentTagged.tag_operation)
  return _s;
}
inline const std::string& DocumentTagged::_internal_tag_operation() const {
  return _impl_.tag_operation_.Get();
}
inline void DocumentTagged::_internal_set_tag_operation(const std::string& value) {
  
  _impl_.tag_operation_.Set(value, GetArenaForAllocation());
}
inline std::string* DocumentTagged::_internal_mutable_tag_operation() {
  
  return _impl_.tag_operation_.Mutable(GetArenaForAllocation());
}
inline std::string* DocumentTagged::release_tag_operation() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.DocumentTagged.tag_operation)
  return _impl_.tag_operation_.Release();
}
inline void DocumentTagged::set_allocated_tag_operation(std::string* tag_operation) {
  if (tag_operation != nullptr) {
    
  } else {
    
  }
  _impl_.tag_operation_.SetAllocated(tag_operation, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tag_operation_.IsDefault()) {
    _impl_.tag_operation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.DocumentTagged.tag_operation)
}

// -------------------------------------------------------------------

// DocumentVersioned

// int32 new_version = 1;
inline void DocumentVersioned::clear_new_version() {
  _impl_.new_version_ = 0;
}
inline int32_t DocumentVersioned::_internal_new_version() const {
  return _impl_.new_version_;
}
inline int32_t DocumentVersioned::new_version() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.DocumentVersioned.new_version)
  return _internal_new_version();
}
inline void DocumentVersioned::_internal_set_new_version(int32_t value) {
  
  _impl_.new_version_ = value;
}
inline void DocumentVersioned::set_new_version(int32_t value) {
  _internal_set_new_version(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.DocumentVersioned.new_version)
}

// int32 previous_version = 2;
inline void DocumentVersioned::clear_previous_version() {
  _impl_.previous_version_ = 0;
}
inline int32_t DocumentVersioned::_internal_previous_version() const {
  return _impl_.previous_version_;
}
inline int32_t DocumentVersioned::previous_version() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.DocumentVersioned.previous_version)
  return _internal_previous_version();
}
inline void DocumentVersioned::_internal_set_previous_version(int32_t value) {
  
  _impl_.previous_version_ = value;
}
inline void DocumentVersioned::set_previous_version(int32_t value) {
  _internal_set_previous_version(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.DocumentVersioned.previous_version)
}

// string version_reason = 3;
inline void DocumentVersioned::clear_version_reason() {
  _impl_.version_reason_.ClearToEmpty();
}
inline const std::string& DocumentVersioned::version_reason() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.DocumentVersioned.version_reason)
  return _internal_version_reason();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DocumentVersioned::set_version_reason(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_reason_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.DocumentVersioned.version_reason)
}
inline std::string* DocumentVersioned::mutable_version_reason() {
  std::string* _s = _internal_mutable_version_reason();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.DocumentVersioned.version_reason)
  return _s;
}
inline const std::string& DocumentVersioned::_internal_version_reason() const {
  return _impl_.version_reason_.Get();
}
inline void DocumentVersioned::_internal_set_version_reason(const std::string& value) {
  
  _impl_.version_reason_.Set(value, GetArenaForAllocation());
}
inline std::string* DocumentVersioned::_internal_mutable_version_reason() {
  
  return _impl_.version_reason_.Mutable(GetArenaForAllocation());
}
inline std::string* DocumentVersioned::release_version_reason() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.DocumentVersioned.version_reason)
  return _impl_.version_reason_.Release();
}
inline void DocumentVersioned::set_allocated_version_reason(std::string* version_reason) {
  if (version_reason != nullptr) {
    
  } else {
    
  }
  _impl_.version_reason_.SetAllocated(version_reason, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_reason_.IsDefault()) {
    _impl_.version_reason_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.DocumentVersioned.version_reason)
}

// -------------------------------------------------------------------

// LLMEvent

// string interaction_id = 1;
inline void LLMEvent::clear_interaction_id() {
  _impl_.interaction_id_.ClearToEmpty();
}
inline const std::string& LLMEvent::interaction_id() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.LLMEvent.interaction_id)
  return _internal_interaction_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LLMEvent::set_interaction_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.interaction_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.LLMEvent.interaction_id)
}
inline std::string* LLMEvent::mutable_interaction_id() {
  std::string* _s = _internal_mutable_interaction_id();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.LLMEvent.interaction_id)
  return _s;
}
inline const std::string& LLMEvent::_internal_interaction_id() const {
  return _impl_.interaction_id_.Get();
}
inline void LLMEvent::_internal_set_interaction_id(const std::string& value) {
  
  _impl_.interaction_id_.Set(value, GetArenaForAllocation());
}
inline std::string* LLMEvent::_internal_mutable_interaction_id() {
  
  return _impl_.interaction_id_.Mutable(GetArenaForAllocation());
}
inline std::string* LLMEvent::release_interaction_id() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.LLMEvent.interaction_id)
  return _impl_.interaction_id_.Release();
}
inline void LLMEvent::set_allocated_interaction_id(std::string* interaction_id) {
  if (interaction_id != nullptr) {
    
  } else {
    
  }
  _impl_.interaction_id_.SetAllocated(interaction_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.interaction_id_.IsDefault()) {
    _impl_.interaction_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.LLMEvent.interaction_id)
}

// string model_name = 2;
inline void LLMEvent::clear_model_name() {
  _impl_.model_name_.ClearToEmpty();
}
inline const std::string& LLMEvent::model_name() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.LLMEvent.model_name)
  return _internal_model_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LLMEvent::set_model_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.LLMEvent.model_name)
}
inline std::string* LLMEvent::mutable_model_name() {
  std::string* _s = _internal_mutable_model_name();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.LLMEvent.model_name)
  return _s;
}
inline const std::string& LLMEvent::_internal_model_name() const {
  return _impl_.model_name_.Get();
}
inline void LLMEvent::_internal_set_model_name(const std::string& value) {
  
  _impl_.model_name_.Set(value, GetArenaForAllocation());
}
inline std::string* LLMEvent::_internal_mutable_model_name() {
  
  return _impl_.model_name_.Mutable(GetArenaForAllocation());
}
inline std::string* LLMEvent::release_model_name() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.LLMEvent.model_name)
  return _impl_.model_name_.Release();
}
inline void LLMEvent::set_allocated_model_name(std::string* model_name) {
  if (model_name != nullptr) {
    
  } else {
    
  }
  _impl_.model_name_.SetAllocated(model_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_name_.IsDefault()) {
    _impl_.model_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.LLMEvent.model_name)
}

// string provider = 3;
inline void LLMEvent::clear_provider() {
  _impl_.provider_.ClearToEmpty();
}
inline const std::string& LLMEvent::provider() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.LLMEvent.provider)
  return _internal_provider();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LLMEvent::set_provider(ArgT0&& arg0, ArgT... args) {
 
 _impl_.provider_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.LLMEvent.provider)
}
inline std::string* LLMEvent::mutable_provider() {
  std::string* _s = _internal_mutable_provider();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.LLMEvent.provider)
  return _s;
}
inline const std::string& LLMEvent::_internal_provider() const {
  return _impl_.provider_.Get();
}
inline void LLMEvent::_internal_set_provider(const std::string& value) {
  
  _impl_.provider_.Set(value, GetArenaForAllocation());
}
inline std::string* LLMEvent::_internal_mutable_provider() {
  
  return _impl_.provider_.Mutable(GetArenaForAllocation());
}
inline std::string* LLMEvent::release_provider() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.LLMEvent.provider)
  return _impl_.provider_.Release();
}
inline void LLMEvent::set_allocated_provider(std::string* provider) {
  if (provider != nullptr) {
    
  } else {
    
  }
  _impl_.provider_.SetAllocated(provider, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.provider_.IsDefault()) {
    _impl_.provider_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.LLMEvent.provider)
}

// .unhinged.cdc.LLMEventType event_type = 4;
inline void LLMEvent::clear_event_type() {
  _impl_.event_type_ = 0;
}
inline ::unhinged::cdc::LLMEventType LLMEvent::_internal_event_type() const {
  return static_cast< ::unhinged::cdc::LLMEventType >(_impl_.event_type_);
}
inline ::unhinged::cdc::LLMEventType LLMEvent::event_type() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.LLMEvent.event_type)
  return _internal_event_type();
}
inline void LLMEvent::_internal_set_event_type(::unhinged::cdc::LLMEventType value) {
  
  _impl_.event_type_ = value;
}
inline void LLMEvent::set_event_type(::unhinged::cdc::LLMEventType value) {
  _internal_set_event_type(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.LLMEvent.event_type)
}

// .unhinged.cdc.LLMPromptSent prompt_sent = 10;
inline bool LLMEvent::_internal_has_prompt_sent() const {
  return event_data_case() == kPromptSent;
}
inline bool LLMEvent::has_prompt_sent() const {
  return _internal_has_prompt_sent();
}
inline void LLMEvent::set_has_prompt_sent() {
  _impl_._oneof_case_[0] = kPromptSent;
}
inline void LLMEvent::clear_prompt_sent() {
  if (_internal_has_prompt_sent()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_data_.prompt_sent_;
    }
    clear_has_event_data();
  }
}
inline ::unhinged::cdc::LLMPromptSent* LLMEvent::release_prompt_sent() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.LLMEvent.prompt_sent)
  if (_internal_has_prompt_sent()) {
    clear_has_event_data();
    ::unhinged::cdc::LLMPromptSent* temp = _impl_.event_data_.prompt_sent_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_data_.prompt_sent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::cdc::LLMPromptSent& LLMEvent::_internal_prompt_sent() const {
  return _internal_has_prompt_sent()
      ? *_impl_.event_data_.prompt_sent_
      : reinterpret_cast< ::unhinged::cdc::LLMPromptSent&>(::unhinged::cdc::_LLMPromptSent_default_instance_);
}
inline const ::unhinged::cdc::LLMPromptSent& LLMEvent::prompt_sent() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.LLMEvent.prompt_sent)
  return _internal_prompt_sent();
}
inline ::unhinged::cdc::LLMPromptSent* LLMEvent::unsafe_arena_release_prompt_sent() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.cdc.LLMEvent.prompt_sent)
  if (_internal_has_prompt_sent()) {
    clear_has_event_data();
    ::unhinged::cdc::LLMPromptSent* temp = _impl_.event_data_.prompt_sent_;
    _impl_.event_data_.prompt_sent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LLMEvent::unsafe_arena_set_allocated_prompt_sent(::unhinged::cdc::LLMPromptSent* prompt_sent) {
  clear_event_data();
  if (prompt_sent) {
    set_has_prompt_sent();
    _impl_.event_data_.prompt_sent_ = prompt_sent;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.LLMEvent.prompt_sent)
}
inline ::unhinged::cdc::LLMPromptSent* LLMEvent::_internal_mutable_prompt_sent() {
  if (!_internal_has_prompt_sent()) {
    clear_event_data();
    set_has_prompt_sent();
    _impl_.event_data_.prompt_sent_ = CreateMaybeMessage< ::unhinged::cdc::LLMPromptSent >(GetArenaForAllocation());
  }
  return _impl_.event_data_.prompt_sent_;
}
inline ::unhinged::cdc::LLMPromptSent* LLMEvent::mutable_prompt_sent() {
  ::unhinged::cdc::LLMPromptSent* _msg = _internal_mutable_prompt_sent();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.LLMEvent.prompt_sent)
  return _msg;
}

// .unhinged.cdc.LLMResponseReceived response_received = 11;
inline bool LLMEvent::_internal_has_response_received() const {
  return event_data_case() == kResponseReceived;
}
inline bool LLMEvent::has_response_received() const {
  return _internal_has_response_received();
}
inline void LLMEvent::set_has_response_received() {
  _impl_._oneof_case_[0] = kResponseReceived;
}
inline void LLMEvent::clear_response_received() {
  if (_internal_has_response_received()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_data_.response_received_;
    }
    clear_has_event_data();
  }
}
inline ::unhinged::cdc::LLMResponseReceived* LLMEvent::release_response_received() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.LLMEvent.response_received)
  if (_internal_has_response_received()) {
    clear_has_event_data();
    ::unhinged::cdc::LLMResponseReceived* temp = _impl_.event_data_.response_received_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_data_.response_received_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::cdc::LLMResponseReceived& LLMEvent::_internal_response_received() const {
  return _internal_has_response_received()
      ? *_impl_.event_data_.response_received_
      : reinterpret_cast< ::unhinged::cdc::LLMResponseReceived&>(::unhinged::cdc::_LLMResponseReceived_default_instance_);
}
inline const ::unhinged::cdc::LLMResponseReceived& LLMEvent::response_received() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.LLMEvent.response_received)
  return _internal_response_received();
}
inline ::unhinged::cdc::LLMResponseReceived* LLMEvent::unsafe_arena_release_response_received() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.cdc.LLMEvent.response_received)
  if (_internal_has_response_received()) {
    clear_has_event_data();
    ::unhinged::cdc::LLMResponseReceived* temp = _impl_.event_data_.response_received_;
    _impl_.event_data_.response_received_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LLMEvent::unsafe_arena_set_allocated_response_received(::unhinged::cdc::LLMResponseReceived* response_received) {
  clear_event_data();
  if (response_received) {
    set_has_response_received();
    _impl_.event_data_.response_received_ = response_received;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.LLMEvent.response_received)
}
inline ::unhinged::cdc::LLMResponseReceived* LLMEvent::_internal_mutable_response_received() {
  if (!_internal_has_response_received()) {
    clear_event_data();
    set_has_response_received();
    _impl_.event_data_.response_received_ = CreateMaybeMessage< ::unhinged::cdc::LLMResponseReceived >(GetArenaForAllocation());
  }
  return _impl_.event_data_.response_received_;
}
inline ::unhinged::cdc::LLMResponseReceived* LLMEvent::mutable_response_received() {
  ::unhinged::cdc::LLMResponseReceived* _msg = _internal_mutable_response_received();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.LLMEvent.response_received)
  return _msg;
}

// .unhinged.cdc.LLMError llm_error = 12;
inline bool LLMEvent::_internal_has_llm_error() const {
  return event_data_case() == kLlmError;
}
inline bool LLMEvent::has_llm_error() const {
  return _internal_has_llm_error();
}
inline void LLMEvent::set_has_llm_error() {
  _impl_._oneof_case_[0] = kLlmError;
}
inline void LLMEvent::clear_llm_error() {
  if (_internal_has_llm_error()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_data_.llm_error_;
    }
    clear_has_event_data();
  }
}
inline ::unhinged::cdc::LLMError* LLMEvent::release_llm_error() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.LLMEvent.llm_error)
  if (_internal_has_llm_error()) {
    clear_has_event_data();
    ::unhinged::cdc::LLMError* temp = _impl_.event_data_.llm_error_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_data_.llm_error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::cdc::LLMError& LLMEvent::_internal_llm_error() const {
  return _internal_has_llm_error()
      ? *_impl_.event_data_.llm_error_
      : reinterpret_cast< ::unhinged::cdc::LLMError&>(::unhinged::cdc::_LLMError_default_instance_);
}
inline const ::unhinged::cdc::LLMError& LLMEvent::llm_error() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.LLMEvent.llm_error)
  return _internal_llm_error();
}
inline ::unhinged::cdc::LLMError* LLMEvent::unsafe_arena_release_llm_error() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.cdc.LLMEvent.llm_error)
  if (_internal_has_llm_error()) {
    clear_has_event_data();
    ::unhinged::cdc::LLMError* temp = _impl_.event_data_.llm_error_;
    _impl_.event_data_.llm_error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LLMEvent::unsafe_arena_set_allocated_llm_error(::unhinged::cdc::LLMError* llm_error) {
  clear_event_data();
  if (llm_error) {
    set_has_llm_error();
    _impl_.event_data_.llm_error_ = llm_error;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.LLMEvent.llm_error)
}
inline ::unhinged::cdc::LLMError* LLMEvent::_internal_mutable_llm_error() {
  if (!_internal_has_llm_error()) {
    clear_event_data();
    set_has_llm_error();
    _impl_.event_data_.llm_error_ = CreateMaybeMessage< ::unhinged::cdc::LLMError >(GetArenaForAllocation());
  }
  return _impl_.event_data_.llm_error_;
}
inline ::unhinged::cdc::LLMError* LLMEvent::mutable_llm_error() {
  ::unhinged::cdc::LLMError* _msg = _internal_mutable_llm_error();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.LLMEvent.llm_error)
  return _msg;
}

// .unhinged.cdc.LLMFeedback feedback = 13;
inline bool LLMEvent::_internal_has_feedback() const {
  return event_data_case() == kFeedback;
}
inline bool LLMEvent::has_feedback() const {
  return _internal_has_feedback();
}
inline void LLMEvent::set_has_feedback() {
  _impl_._oneof_case_[0] = kFeedback;
}
inline void LLMEvent::clear_feedback() {
  if (_internal_has_feedback()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_data_.feedback_;
    }
    clear_has_event_data();
  }
}
inline ::unhinged::cdc::LLMFeedback* LLMEvent::release_feedback() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.LLMEvent.feedback)
  if (_internal_has_feedback()) {
    clear_has_event_data();
    ::unhinged::cdc::LLMFeedback* temp = _impl_.event_data_.feedback_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_data_.feedback_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::cdc::LLMFeedback& LLMEvent::_internal_feedback() const {
  return _internal_has_feedback()
      ? *_impl_.event_data_.feedback_
      : reinterpret_cast< ::unhinged::cdc::LLMFeedback&>(::unhinged::cdc::_LLMFeedback_default_instance_);
}
inline const ::unhinged::cdc::LLMFeedback& LLMEvent::feedback() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.LLMEvent.feedback)
  return _internal_feedback();
}
inline ::unhinged::cdc::LLMFeedback* LLMEvent::unsafe_arena_release_feedback() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.cdc.LLMEvent.feedback)
  if (_internal_has_feedback()) {
    clear_has_event_data();
    ::unhinged::cdc::LLMFeedback* temp = _impl_.event_data_.feedback_;
    _impl_.event_data_.feedback_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LLMEvent::unsafe_arena_set_allocated_feedback(::unhinged::cdc::LLMFeedback* feedback) {
  clear_event_data();
  if (feedback) {
    set_has_feedback();
    _impl_.event_data_.feedback_ = feedback;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.LLMEvent.feedback)
}
inline ::unhinged::cdc::LLMFeedback* LLMEvent::_internal_mutable_feedback() {
  if (!_internal_has_feedback()) {
    clear_event_data();
    set_has_feedback();
    _impl_.event_data_.feedback_ = CreateMaybeMessage< ::unhinged::cdc::LLMFeedback >(GetArenaForAllocation());
  }
  return _impl_.event_data_.feedback_;
}
inline ::unhinged::cdc::LLMFeedback* LLMEvent::mutable_feedback() {
  ::unhinged::cdc::LLMFeedback* _msg = _internal_mutable_feedback();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.LLMEvent.feedback)
  return _msg;
}

// .unhinged.cdc.LLMTokenUsage token_usage = 14;
inline bool LLMEvent::_internal_has_token_usage() const {
  return event_data_case() == kTokenUsage;
}
inline bool LLMEvent::has_token_usage() const {
  return _internal_has_token_usage();
}
inline void LLMEvent::set_has_token_usage() {
  _impl_._oneof_case_[0] = kTokenUsage;
}
inline void LLMEvent::clear_token_usage() {
  if (_internal_has_token_usage()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_data_.token_usage_;
    }
    clear_has_event_data();
  }
}
inline ::unhinged::cdc::LLMTokenUsage* LLMEvent::release_token_usage() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.LLMEvent.token_usage)
  if (_internal_has_token_usage()) {
    clear_has_event_data();
    ::unhinged::cdc::LLMTokenUsage* temp = _impl_.event_data_.token_usage_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_data_.token_usage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::cdc::LLMTokenUsage& LLMEvent::_internal_token_usage() const {
  return _internal_has_token_usage()
      ? *_impl_.event_data_.token_usage_
      : reinterpret_cast< ::unhinged::cdc::LLMTokenUsage&>(::unhinged::cdc::_LLMTokenUsage_default_instance_);
}
inline const ::unhinged::cdc::LLMTokenUsage& LLMEvent::token_usage() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.LLMEvent.token_usage)
  return _internal_token_usage();
}
inline ::unhinged::cdc::LLMTokenUsage* LLMEvent::unsafe_arena_release_token_usage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.cdc.LLMEvent.token_usage)
  if (_internal_has_token_usage()) {
    clear_has_event_data();
    ::unhinged::cdc::LLMTokenUsage* temp = _impl_.event_data_.token_usage_;
    _impl_.event_data_.token_usage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LLMEvent::unsafe_arena_set_allocated_token_usage(::unhinged::cdc::LLMTokenUsage* token_usage) {
  clear_event_data();
  if (token_usage) {
    set_has_token_usage();
    _impl_.event_data_.token_usage_ = token_usage;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.LLMEvent.token_usage)
}
inline ::unhinged::cdc::LLMTokenUsage* LLMEvent::_internal_mutable_token_usage() {
  if (!_internal_has_token_usage()) {
    clear_event_data();
    set_has_token_usage();
    _impl_.event_data_.token_usage_ = CreateMaybeMessage< ::unhinged::cdc::LLMTokenUsage >(GetArenaForAllocation());
  }
  return _impl_.event_data_.token_usage_;
}
inline ::unhinged::cdc::LLMTokenUsage* LLMEvent::mutable_token_usage() {
  ::unhinged::cdc::LLMTokenUsage* _msg = _internal_mutable_token_usage();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.LLMEvent.token_usage)
  return _msg;
}

inline bool LLMEvent::has_event_data() const {
  return event_data_case() != EVENT_DATA_NOT_SET;
}
inline void LLMEvent::clear_has_event_data() {
  _impl_._oneof_case_[0] = EVENT_DATA_NOT_SET;
}
inline LLMEvent::EventDataCase LLMEvent::event_data_case() const {
  return LLMEvent::EventDataCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// LLMPromptSent

// string prompt_text = 1;
inline void LLMPromptSent::clear_prompt_text() {
  _impl_.prompt_text_.ClearToEmpty();
}
inline const std::string& LLMPromptSent::prompt_text() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.LLMPromptSent.prompt_text)
  return _internal_prompt_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LLMPromptSent::set_prompt_text(ArgT0&& arg0, ArgT... args) {
 
 _impl_.prompt_text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.LLMPromptSent.prompt_text)
}
inline std::string* LLMPromptSent::mutable_prompt_text() {
  std::string* _s = _internal_mutable_prompt_text();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.LLMPromptSent.prompt_text)
  return _s;
}
inline const std::string& LLMPromptSent::_internal_prompt_text() const {
  return _impl_.prompt_text_.Get();
}
inline void LLMPromptSent::_internal_set_prompt_text(const std::string& value) {
  
  _impl_.prompt_text_.Set(value, GetArenaForAllocation());
}
inline std::string* LLMPromptSent::_internal_mutable_prompt_text() {
  
  return _impl_.prompt_text_.Mutable(GetArenaForAllocation());
}
inline std::string* LLMPromptSent::release_prompt_text() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.LLMPromptSent.prompt_text)
  return _impl_.prompt_text_.Release();
}
inline void LLMPromptSent::set_allocated_prompt_text(std::string* prompt_text) {
  if (prompt_text != nullptr) {
    
  } else {
    
  }
  _impl_.prompt_text_.SetAllocated(prompt_text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.prompt_text_.IsDefault()) {
    _impl_.prompt_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.LLMPromptSent.prompt_text)
}

// .google.protobuf.Struct prompt_parameters = 2;
inline bool LLMPromptSent::_internal_has_prompt_parameters() const {
  return this != internal_default_instance() && _impl_.prompt_parameters_ != nullptr;
}
inline bool LLMPromptSent::has_prompt_parameters() const {
  return _internal_has_prompt_parameters();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& LLMPromptSent::_internal_prompt_parameters() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.prompt_parameters_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& LLMPromptSent::prompt_parameters() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.LLMPromptSent.prompt_parameters)
  return _internal_prompt_parameters();
}
inline void LLMPromptSent::unsafe_arena_set_allocated_prompt_parameters(
    ::PROTOBUF_NAMESPACE_ID::Struct* prompt_parameters) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.prompt_parameters_);
  }
  _impl_.prompt_parameters_ = prompt_parameters;
  if (prompt_parameters) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.LLMPromptSent.prompt_parameters)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* LLMPromptSent::release_prompt_parameters() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.prompt_parameters_;
  _impl_.prompt_parameters_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* LLMPromptSent::unsafe_arena_release_prompt_parameters() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.LLMPromptSent.prompt_parameters)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.prompt_parameters_;
  _impl_.prompt_parameters_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* LLMPromptSent::_internal_mutable_prompt_parameters() {
  
  if (_impl_.prompt_parameters_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.prompt_parameters_ = p;
  }
  return _impl_.prompt_parameters_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* LLMPromptSent::mutable_prompt_parameters() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_prompt_parameters();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.LLMPromptSent.prompt_parameters)
  return _msg;
}
inline void LLMPromptSent::set_allocated_prompt_parameters(::PROTOBUF_NAMESPACE_ID::Struct* prompt_parameters) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.prompt_parameters_);
  }
  if (prompt_parameters) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(prompt_parameters));
    if (message_arena != submessage_arena) {
      prompt_parameters = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, prompt_parameters, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.prompt_parameters_ = prompt_parameters;
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.LLMPromptSent.prompt_parameters)
}

// repeated string context_document_ids = 3;
inline int LLMPromptSent::_internal_context_document_ids_size() const {
  return _impl_.context_document_ids_.size();
}
inline int LLMPromptSent::context_document_ids_size() const {
  return _internal_context_document_ids_size();
}
inline void LLMPromptSent::clear_context_document_ids() {
  _impl_.context_document_ids_.Clear();
}
inline std::string* LLMPromptSent::add_context_document_ids() {
  std::string* _s = _internal_add_context_document_ids();
  // @@protoc_insertion_point(field_add_mutable:unhinged.cdc.LLMPromptSent.context_document_ids)
  return _s;
}
inline const std::string& LLMPromptSent::_internal_context_document_ids(int index) const {
  return _impl_.context_document_ids_.Get(index);
}
inline const std::string& LLMPromptSent::context_document_ids(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.LLMPromptSent.context_document_ids)
  return _internal_context_document_ids(index);
}
inline std::string* LLMPromptSent::mutable_context_document_ids(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.LLMPromptSent.context_document_ids)
  return _impl_.context_document_ids_.Mutable(index);
}
inline void LLMPromptSent::set_context_document_ids(int index, const std::string& value) {
  _impl_.context_document_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.LLMPromptSent.context_document_ids)
}
inline void LLMPromptSent::set_context_document_ids(int index, std::string&& value) {
  _impl_.context_document_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.cdc.LLMPromptSent.context_document_ids)
}
inline void LLMPromptSent::set_context_document_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.context_document_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.cdc.LLMPromptSent.context_document_ids)
}
inline void LLMPromptSent::set_context_document_ids(int index, const char* value, size_t size) {
  _impl_.context_document_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.cdc.LLMPromptSent.context_document_ids)
}
inline std::string* LLMPromptSent::_internal_add_context_document_ids() {
  return _impl_.context_document_ids_.Add();
}
inline void LLMPromptSent::add_context_document_ids(const std::string& value) {
  _impl_.context_document_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.cdc.LLMPromptSent.context_document_ids)
}
inline void LLMPromptSent::add_context_document_ids(std::string&& value) {
  _impl_.context_document_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.cdc.LLMPromptSent.context_document_ids)
}
inline void LLMPromptSent::add_context_document_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.context_document_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.cdc.LLMPromptSent.context_document_ids)
}
inline void LLMPromptSent::add_context_document_ids(const char* value, size_t size) {
  _impl_.context_document_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.cdc.LLMPromptSent.context_document_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
LLMPromptSent::context_document_ids() const {
  // @@protoc_insertion_point(field_list:unhinged.cdc.LLMPromptSent.context_document_ids)
  return _impl_.context_document_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
LLMPromptSent::mutable_context_document_ids() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.cdc.LLMPromptSent.context_document_ids)
  return &_impl_.context_document_ids_;
}

// int32 max_tokens = 4;
inline void LLMPromptSent::clear_max_tokens() {
  _impl_.max_tokens_ = 0;
}
inline int32_t LLMPromptSent::_internal_max_tokens() const {
  return _impl_.max_tokens_;
}
inline int32_t LLMPromptSent::max_tokens() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.LLMPromptSent.max_tokens)
  return _internal_max_tokens();
}
inline void LLMPromptSent::_internal_set_max_tokens(int32_t value) {
  
  _impl_.max_tokens_ = value;
}
inline void LLMPromptSent::set_max_tokens(int32_t value) {
  _internal_set_max_tokens(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.LLMPromptSent.max_tokens)
}

// float temperature = 5;
inline void LLMPromptSent::clear_temperature() {
  _impl_.temperature_ = 0;
}
inline float LLMPromptSent::_internal_temperature() const {
  return _impl_.temperature_;
}
inline float LLMPromptSent::temperature() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.LLMPromptSent.temperature)
  return _internal_temperature();
}
inline void LLMPromptSent::_internal_set_temperature(float value) {
  
  _impl_.temperature_ = value;
}
inline void LLMPromptSent::set_temperature(float value) {
  _internal_set_temperature(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.LLMPromptSent.temperature)
}

// -------------------------------------------------------------------

// LLMResponseReceived

// string response_text = 1;
inline void LLMResponseReceived::clear_response_text() {
  _impl_.response_text_.ClearToEmpty();
}
inline const std::string& LLMResponseReceived::response_text() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.LLMResponseReceived.response_text)
  return _internal_response_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LLMResponseReceived::set_response_text(ArgT0&& arg0, ArgT... args) {
 
 _impl_.response_text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.LLMResponseReceived.response_text)
}
inline std::string* LLMResponseReceived::mutable_response_text() {
  std::string* _s = _internal_mutable_response_text();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.LLMResponseReceived.response_text)
  return _s;
}
inline const std::string& LLMResponseReceived::_internal_response_text() const {
  return _impl_.response_text_.Get();
}
inline void LLMResponseReceived::_internal_set_response_text(const std::string& value) {
  
  _impl_.response_text_.Set(value, GetArenaForAllocation());
}
inline std::string* LLMResponseReceived::_internal_mutable_response_text() {
  
  return _impl_.response_text_.Mutable(GetArenaForAllocation());
}
inline std::string* LLMResponseReceived::release_response_text() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.LLMResponseReceived.response_text)
  return _impl_.response_text_.Release();
}
inline void LLMResponseReceived::set_allocated_response_text(std::string* response_text) {
  if (response_text != nullptr) {
    
  } else {
    
  }
  _impl_.response_text_.SetAllocated(response_text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.response_text_.IsDefault()) {
    _impl_.response_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.LLMResponseReceived.response_text)
}

// string finish_reason = 2;
inline void LLMResponseReceived::clear_finish_reason() {
  _impl_.finish_reason_.ClearToEmpty();
}
inline const std::string& LLMResponseReceived::finish_reason() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.LLMResponseReceived.finish_reason)
  return _internal_finish_reason();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LLMResponseReceived::set_finish_reason(ArgT0&& arg0, ArgT... args) {
 
 _impl_.finish_reason_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.LLMResponseReceived.finish_reason)
}
inline std::string* LLMResponseReceived::mutable_finish_reason() {
  std::string* _s = _internal_mutable_finish_reason();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.LLMResponseReceived.finish_reason)
  return _s;
}
inline const std::string& LLMResponseReceived::_internal_finish_reason() const {
  return _impl_.finish_reason_.Get();
}
inline void LLMResponseReceived::_internal_set_finish_reason(const std::string& value) {
  
  _impl_.finish_reason_.Set(value, GetArenaForAllocation());
}
inline std::string* LLMResponseReceived::_internal_mutable_finish_reason() {
  
  return _impl_.finish_reason_.Mutable(GetArenaForAllocation());
}
inline std::string* LLMResponseReceived::release_finish_reason() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.LLMResponseReceived.finish_reason)
  return _impl_.finish_reason_.Release();
}
inline void LLMResponseReceived::set_allocated_finish_reason(std::string* finish_reason) {
  if (finish_reason != nullptr) {
    
  } else {
    
  }
  _impl_.finish_reason_.SetAllocated(finish_reason, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.finish_reason_.IsDefault()) {
    _impl_.finish_reason_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.LLMResponseReceived.finish_reason)
}

// int32 response_tokens = 3;
inline void LLMResponseReceived::clear_response_tokens() {
  _impl_.response_tokens_ = 0;
}
inline int32_t LLMResponseReceived::_internal_response_tokens() const {
  return _impl_.response_tokens_;
}
inline int32_t LLMResponseReceived::response_tokens() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.LLMResponseReceived.response_tokens)
  return _internal_response_tokens();
}
inline void LLMResponseReceived::_internal_set_response_tokens(int32_t value) {
  
  _impl_.response_tokens_ = value;
}
inline void LLMResponseReceived::set_response_tokens(int32_t value) {
  _internal_set_response_tokens(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.LLMResponseReceived.response_tokens)
}

// float response_time_ms = 4;
inline void LLMResponseReceived::clear_response_time_ms() {
  _impl_.response_time_ms_ = 0;
}
inline float LLMResponseReceived::_internal_response_time_ms() const {
  return _impl_.response_time_ms_;
}
inline float LLMResponseReceived::response_time_ms() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.LLMResponseReceived.response_time_ms)
  return _internal_response_time_ms();
}
inline void LLMResponseReceived::_internal_set_response_time_ms(float value) {
  
  _impl_.response_time_ms_ = value;
}
inline void LLMResponseReceived::set_response_time_ms(float value) {
  _internal_set_response_time_ms(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.LLMResponseReceived.response_time_ms)
}

// .google.protobuf.Struct response_metadata = 5;
inline bool LLMResponseReceived::_internal_has_response_metadata() const {
  return this != internal_default_instance() && _impl_.response_metadata_ != nullptr;
}
inline bool LLMResponseReceived::has_response_metadata() const {
  return _internal_has_response_metadata();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& LLMResponseReceived::_internal_response_metadata() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.response_metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& LLMResponseReceived::response_metadata() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.LLMResponseReceived.response_metadata)
  return _internal_response_metadata();
}
inline void LLMResponseReceived::unsafe_arena_set_allocated_response_metadata(
    ::PROTOBUF_NAMESPACE_ID::Struct* response_metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_metadata_);
  }
  _impl_.response_metadata_ = response_metadata;
  if (response_metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.LLMResponseReceived.response_metadata)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* LLMResponseReceived::release_response_metadata() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.response_metadata_;
  _impl_.response_metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* LLMResponseReceived::unsafe_arena_release_response_metadata() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.LLMResponseReceived.response_metadata)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.response_metadata_;
  _impl_.response_metadata_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* LLMResponseReceived::_internal_mutable_response_metadata() {
  
  if (_impl_.response_metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.response_metadata_ = p;
  }
  return _impl_.response_metadata_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* LLMResponseReceived::mutable_response_metadata() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_response_metadata();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.LLMResponseReceived.response_metadata)
  return _msg;
}
inline void LLMResponseReceived::set_allocated_response_metadata(::PROTOBUF_NAMESPACE_ID::Struct* response_metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_metadata_);
  }
  if (response_metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response_metadata));
    if (message_arena != submessage_arena) {
      response_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response_metadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_metadata_ = response_metadata;
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.LLMResponseReceived.response_metadata)
}

// -------------------------------------------------------------------

// LLMError

// string error_code = 1;
inline void LLMError::clear_error_code() {
  _impl_.error_code_.ClearToEmpty();
}
inline const std::string& LLMError::error_code() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.LLMError.error_code)
  return _internal_error_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LLMError::set_error_code(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.LLMError.error_code)
}
inline std::string* LLMError::mutable_error_code() {
  std::string* _s = _internal_mutable_error_code();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.LLMError.error_code)
  return _s;
}
inline const std::string& LLMError::_internal_error_code() const {
  return _impl_.error_code_.Get();
}
inline void LLMError::_internal_set_error_code(const std::string& value) {
  
  _impl_.error_code_.Set(value, GetArenaForAllocation());
}
inline std::string* LLMError::_internal_mutable_error_code() {
  
  return _impl_.error_code_.Mutable(GetArenaForAllocation());
}
inline std::string* LLMError::release_error_code() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.LLMError.error_code)
  return _impl_.error_code_.Release();
}
inline void LLMError::set_allocated_error_code(std::string* error_code) {
  if (error_code != nullptr) {
    
  } else {
    
  }
  _impl_.error_code_.SetAllocated(error_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_code_.IsDefault()) {
    _impl_.error_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.LLMError.error_code)
}

// string error_message = 2;
inline void LLMError::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& LLMError::error_message() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.LLMError.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LLMError::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.LLMError.error_message)
}
inline std::string* LLMError::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.LLMError.error_message)
  return _s;
}
inline const std::string& LLMError::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void LLMError::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* LLMError::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* LLMError::release_error_message() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.LLMError.error_message)
  return _impl_.error_message_.Release();
}
inline void LLMError::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.LLMError.error_message)
}

// string error_type = 3;
inline void LLMError::clear_error_type() {
  _impl_.error_type_.ClearToEmpty();
}
inline const std::string& LLMError::error_type() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.LLMError.error_type)
  return _internal_error_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LLMError::set_error_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.LLMError.error_type)
}
inline std::string* LLMError::mutable_error_type() {
  std::string* _s = _internal_mutable_error_type();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.LLMError.error_type)
  return _s;
}
inline const std::string& LLMError::_internal_error_type() const {
  return _impl_.error_type_.Get();
}
inline void LLMError::_internal_set_error_type(const std::string& value) {
  
  _impl_.error_type_.Set(value, GetArenaForAllocation());
}
inline std::string* LLMError::_internal_mutable_error_type() {
  
  return _impl_.error_type_.Mutable(GetArenaForAllocation());
}
inline std::string* LLMError::release_error_type() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.LLMError.error_type)
  return _impl_.error_type_.Release();
}
inline void LLMError::set_allocated_error_type(std::string* error_type) {
  if (error_type != nullptr) {
    
  } else {
    
  }
  _impl_.error_type_.SetAllocated(error_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_type_.IsDefault()) {
    _impl_.error_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.LLMError.error_type)
}

// bool is_retryable = 4;
inline void LLMError::clear_is_retryable() {
  _impl_.is_retryable_ = false;
}
inline bool LLMError::_internal_is_retryable() const {
  return _impl_.is_retryable_;
}
inline bool LLMError::is_retryable() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.LLMError.is_retryable)
  return _internal_is_retryable();
}
inline void LLMError::_internal_set_is_retryable(bool value) {
  
  _impl_.is_retryable_ = value;
}
inline void LLMError::set_is_retryable(bool value) {
  _internal_set_is_retryable(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.LLMError.is_retryable)
}

// -------------------------------------------------------------------

// LLMFeedback

// string feedback_type = 1;
inline void LLMFeedback::clear_feedback_type() {
  _impl_.feedback_type_.ClearToEmpty();
}
inline const std::string& LLMFeedback::feedback_type() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.LLMFeedback.feedback_type)
  return _internal_feedback_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LLMFeedback::set_feedback_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.feedback_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.LLMFeedback.feedback_type)
}
inline std::string* LLMFeedback::mutable_feedback_type() {
  std::string* _s = _internal_mutable_feedback_type();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.LLMFeedback.feedback_type)
  return _s;
}
inline const std::string& LLMFeedback::_internal_feedback_type() const {
  return _impl_.feedback_type_.Get();
}
inline void LLMFeedback::_internal_set_feedback_type(const std::string& value) {
  
  _impl_.feedback_type_.Set(value, GetArenaForAllocation());
}
inline std::string* LLMFeedback::_internal_mutable_feedback_type() {
  
  return _impl_.feedback_type_.Mutable(GetArenaForAllocation());
}
inline std::string* LLMFeedback::release_feedback_type() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.LLMFeedback.feedback_type)
  return _impl_.feedback_type_.Release();
}
inline void LLMFeedback::set_allocated_feedback_type(std::string* feedback_type) {
  if (feedback_type != nullptr) {
    
  } else {
    
  }
  _impl_.feedback_type_.SetAllocated(feedback_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.feedback_type_.IsDefault()) {
    _impl_.feedback_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.LLMFeedback.feedback_type)
}

// string feedback_value = 2;
inline void LLMFeedback::clear_feedback_value() {
  _impl_.feedback_value_.ClearToEmpty();
}
inline const std::string& LLMFeedback::feedback_value() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.LLMFeedback.feedback_value)
  return _internal_feedback_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LLMFeedback::set_feedback_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.feedback_value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.LLMFeedback.feedback_value)
}
inline std::string* LLMFeedback::mutable_feedback_value() {
  std::string* _s = _internal_mutable_feedback_value();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.LLMFeedback.feedback_value)
  return _s;
}
inline const std::string& LLMFeedback::_internal_feedback_value() const {
  return _impl_.feedback_value_.Get();
}
inline void LLMFeedback::_internal_set_feedback_value(const std::string& value) {
  
  _impl_.feedback_value_.Set(value, GetArenaForAllocation());
}
inline std::string* LLMFeedback::_internal_mutable_feedback_value() {
  
  return _impl_.feedback_value_.Mutable(GetArenaForAllocation());
}
inline std::string* LLMFeedback::release_feedback_value() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.LLMFeedback.feedback_value)
  return _impl_.feedback_value_.Release();
}
inline void LLMFeedback::set_allocated_feedback_value(std::string* feedback_value) {
  if (feedback_value != nullptr) {
    
  } else {
    
  }
  _impl_.feedback_value_.SetAllocated(feedback_value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.feedback_value_.IsDefault()) {
    _impl_.feedback_value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.LLMFeedback.feedback_value)
}

// string feedback_text = 3;
inline void LLMFeedback::clear_feedback_text() {
  _impl_.feedback_text_.ClearToEmpty();
}
inline const std::string& LLMFeedback::feedback_text() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.LLMFeedback.feedback_text)
  return _internal_feedback_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LLMFeedback::set_feedback_text(ArgT0&& arg0, ArgT... args) {
 
 _impl_.feedback_text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.LLMFeedback.feedback_text)
}
inline std::string* LLMFeedback::mutable_feedback_text() {
  std::string* _s = _internal_mutable_feedback_text();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.LLMFeedback.feedback_text)
  return _s;
}
inline const std::string& LLMFeedback::_internal_feedback_text() const {
  return _impl_.feedback_text_.Get();
}
inline void LLMFeedback::_internal_set_feedback_text(const std::string& value) {
  
  _impl_.feedback_text_.Set(value, GetArenaForAllocation());
}
inline std::string* LLMFeedback::_internal_mutable_feedback_text() {
  
  return _impl_.feedback_text_.Mutable(GetArenaForAllocation());
}
inline std::string* LLMFeedback::release_feedback_text() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.LLMFeedback.feedback_text)
  return _impl_.feedback_text_.Release();
}
inline void LLMFeedback::set_allocated_feedback_text(std::string* feedback_text) {
  if (feedback_text != nullptr) {
    
  } else {
    
  }
  _impl_.feedback_text_.SetAllocated(feedback_text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.feedback_text_.IsDefault()) {
    _impl_.feedback_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.LLMFeedback.feedback_text)
}

// string provided_by = 4;
inline void LLMFeedback::clear_provided_by() {
  _impl_.provided_by_.ClearToEmpty();
}
inline const std::string& LLMFeedback::provided_by() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.LLMFeedback.provided_by)
  return _internal_provided_by();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LLMFeedback::set_provided_by(ArgT0&& arg0, ArgT... args) {
 
 _impl_.provided_by_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.LLMFeedback.provided_by)
}
inline std::string* LLMFeedback::mutable_provided_by() {
  std::string* _s = _internal_mutable_provided_by();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.LLMFeedback.provided_by)
  return _s;
}
inline const std::string& LLMFeedback::_internal_provided_by() const {
  return _impl_.provided_by_.Get();
}
inline void LLMFeedback::_internal_set_provided_by(const std::string& value) {
  
  _impl_.provided_by_.Set(value, GetArenaForAllocation());
}
inline std::string* LLMFeedback::_internal_mutable_provided_by() {
  
  return _impl_.provided_by_.Mutable(GetArenaForAllocation());
}
inline std::string* LLMFeedback::release_provided_by() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.LLMFeedback.provided_by)
  return _impl_.provided_by_.Release();
}
inline void LLMFeedback::set_allocated_provided_by(std::string* provided_by) {
  if (provided_by != nullptr) {
    
  } else {
    
  }
  _impl_.provided_by_.SetAllocated(provided_by, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.provided_by_.IsDefault()) {
    _impl_.provided_by_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.LLMFeedback.provided_by)
}

// -------------------------------------------------------------------

// LLMTokenUsage

// int32 prompt_tokens = 1;
inline void LLMTokenUsage::clear_prompt_tokens() {
  _impl_.prompt_tokens_ = 0;
}
inline int32_t LLMTokenUsage::_internal_prompt_tokens() const {
  return _impl_.prompt_tokens_;
}
inline int32_t LLMTokenUsage::prompt_tokens() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.LLMTokenUsage.prompt_tokens)
  return _internal_prompt_tokens();
}
inline void LLMTokenUsage::_internal_set_prompt_tokens(int32_t value) {
  
  _impl_.prompt_tokens_ = value;
}
inline void LLMTokenUsage::set_prompt_tokens(int32_t value) {
  _internal_set_prompt_tokens(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.LLMTokenUsage.prompt_tokens)
}

// int32 completion_tokens = 2;
inline void LLMTokenUsage::clear_completion_tokens() {
  _impl_.completion_tokens_ = 0;
}
inline int32_t LLMTokenUsage::_internal_completion_tokens() const {
  return _impl_.completion_tokens_;
}
inline int32_t LLMTokenUsage::completion_tokens() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.LLMTokenUsage.completion_tokens)
  return _internal_completion_tokens();
}
inline void LLMTokenUsage::_internal_set_completion_tokens(int32_t value) {
  
  _impl_.completion_tokens_ = value;
}
inline void LLMTokenUsage::set_completion_tokens(int32_t value) {
  _internal_set_completion_tokens(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.LLMTokenUsage.completion_tokens)
}

// int32 total_tokens = 3;
inline void LLMTokenUsage::clear_total_tokens() {
  _impl_.total_tokens_ = 0;
}
inline int32_t LLMTokenUsage::_internal_total_tokens() const {
  return _impl_.total_tokens_;
}
inline int32_t LLMTokenUsage::total_tokens() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.LLMTokenUsage.total_tokens)
  return _internal_total_tokens();
}
inline void LLMTokenUsage::_internal_set_total_tokens(int32_t value) {
  
  _impl_.total_tokens_ = value;
}
inline void LLMTokenUsage::set_total_tokens(int32_t value) {
  _internal_set_total_tokens(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.LLMTokenUsage.total_tokens)
}

// float cost_usd = 4;
inline void LLMTokenUsage::clear_cost_usd() {
  _impl_.cost_usd_ = 0;
}
inline float LLMTokenUsage::_internal_cost_usd() const {
  return _impl_.cost_usd_;
}
inline float LLMTokenUsage::cost_usd() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.LLMTokenUsage.cost_usd)
  return _internal_cost_usd();
}
inline void LLMTokenUsage::_internal_set_cost_usd(float value) {
  
  _impl_.cost_usd_ = value;
}
inline void LLMTokenUsage::set_cost_usd(float value) {
  _internal_set_cost_usd(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.LLMTokenUsage.cost_usd)
}

// -------------------------------------------------------------------

// AgentEvent

// string agent_id = 1;
inline void AgentEvent::clear_agent_id() {
  _impl_.agent_id_.ClearToEmpty();
}
inline const std::string& AgentEvent::agent_id() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.AgentEvent.agent_id)
  return _internal_agent_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AgentEvent::set_agent_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.agent_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.AgentEvent.agent_id)
}
inline std::string* AgentEvent::mutable_agent_id() {
  std::string* _s = _internal_mutable_agent_id();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.AgentEvent.agent_id)
  return _s;
}
inline const std::string& AgentEvent::_internal_agent_id() const {
  return _impl_.agent_id_.Get();
}
inline void AgentEvent::_internal_set_agent_id(const std::string& value) {
  
  _impl_.agent_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AgentEvent::_internal_mutable_agent_id() {
  
  return _impl_.agent_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AgentEvent::release_agent_id() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.AgentEvent.agent_id)
  return _impl_.agent_id_.Release();
}
inline void AgentEvent::set_allocated_agent_id(std::string* agent_id) {
  if (agent_id != nullptr) {
    
  } else {
    
  }
  _impl_.agent_id_.SetAllocated(agent_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.agent_id_.IsDefault()) {
    _impl_.agent_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.AgentEvent.agent_id)
}

// string agent_type = 2;
inline void AgentEvent::clear_agent_type() {
  _impl_.agent_type_.ClearToEmpty();
}
inline const std::string& AgentEvent::agent_type() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.AgentEvent.agent_type)
  return _internal_agent_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AgentEvent::set_agent_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.agent_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.AgentEvent.agent_type)
}
inline std::string* AgentEvent::mutable_agent_type() {
  std::string* _s = _internal_mutable_agent_type();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.AgentEvent.agent_type)
  return _s;
}
inline const std::string& AgentEvent::_internal_agent_type() const {
  return _impl_.agent_type_.Get();
}
inline void AgentEvent::_internal_set_agent_type(const std::string& value) {
  
  _impl_.agent_type_.Set(value, GetArenaForAllocation());
}
inline std::string* AgentEvent::_internal_mutable_agent_type() {
  
  return _impl_.agent_type_.Mutable(GetArenaForAllocation());
}
inline std::string* AgentEvent::release_agent_type() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.AgentEvent.agent_type)
  return _impl_.agent_type_.Release();
}
inline void AgentEvent::set_allocated_agent_type(std::string* agent_type) {
  if (agent_type != nullptr) {
    
  } else {
    
  }
  _impl_.agent_type_.SetAllocated(agent_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.agent_type_.IsDefault()) {
    _impl_.agent_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.AgentEvent.agent_type)
}

// string agent_version = 3;
inline void AgentEvent::clear_agent_version() {
  _impl_.agent_version_.ClearToEmpty();
}
inline const std::string& AgentEvent::agent_version() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.AgentEvent.agent_version)
  return _internal_agent_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AgentEvent::set_agent_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.agent_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.AgentEvent.agent_version)
}
inline std::string* AgentEvent::mutable_agent_version() {
  std::string* _s = _internal_mutable_agent_version();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.AgentEvent.agent_version)
  return _s;
}
inline const std::string& AgentEvent::_internal_agent_version() const {
  return _impl_.agent_version_.Get();
}
inline void AgentEvent::_internal_set_agent_version(const std::string& value) {
  
  _impl_.agent_version_.Set(value, GetArenaForAllocation());
}
inline std::string* AgentEvent::_internal_mutable_agent_version() {
  
  return _impl_.agent_version_.Mutable(GetArenaForAllocation());
}
inline std::string* AgentEvent::release_agent_version() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.AgentEvent.agent_version)
  return _impl_.agent_version_.Release();
}
inline void AgentEvent::set_allocated_agent_version(std::string* agent_version) {
  if (agent_version != nullptr) {
    
  } else {
    
  }
  _impl_.agent_version_.SetAllocated(agent_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.agent_version_.IsDefault()) {
    _impl_.agent_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.AgentEvent.agent_version)
}

// string execution_id = 4;
inline void AgentEvent::clear_execution_id() {
  _impl_.execution_id_.ClearToEmpty();
}
inline const std::string& AgentEvent::execution_id() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.AgentEvent.execution_id)
  return _internal_execution_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AgentEvent::set_execution_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.execution_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.AgentEvent.execution_id)
}
inline std::string* AgentEvent::mutable_execution_id() {
  std::string* _s = _internal_mutable_execution_id();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.AgentEvent.execution_id)
  return _s;
}
inline const std::string& AgentEvent::_internal_execution_id() const {
  return _impl_.execution_id_.Get();
}
inline void AgentEvent::_internal_set_execution_id(const std::string& value) {
  
  _impl_.execution_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AgentEvent::_internal_mutable_execution_id() {
  
  return _impl_.execution_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AgentEvent::release_execution_id() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.AgentEvent.execution_id)
  return _impl_.execution_id_.Release();
}
inline void AgentEvent::set_allocated_execution_id(std::string* execution_id) {
  if (execution_id != nullptr) {
    
  } else {
    
  }
  _impl_.execution_id_.SetAllocated(execution_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.execution_id_.IsDefault()) {
    _impl_.execution_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.AgentEvent.execution_id)
}

// .unhinged.cdc.AgentEventType event_type = 5;
inline void AgentEvent::clear_event_type() {
  _impl_.event_type_ = 0;
}
inline ::unhinged::cdc::AgentEventType AgentEvent::_internal_event_type() const {
  return static_cast< ::unhinged::cdc::AgentEventType >(_impl_.event_type_);
}
inline ::unhinged::cdc::AgentEventType AgentEvent::event_type() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.AgentEvent.event_type)
  return _internal_event_type();
}
inline void AgentEvent::_internal_set_event_type(::unhinged::cdc::AgentEventType value) {
  
  _impl_.event_type_ = value;
}
inline void AgentEvent::set_event_type(::unhinged::cdc::AgentEventType value) {
  _internal_set_event_type(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.AgentEvent.event_type)
}

// .unhinged.cdc.AgentStarted started = 10;
inline bool AgentEvent::_internal_has_started() const {
  return event_data_case() == kStarted;
}
inline bool AgentEvent::has_started() const {
  return _internal_has_started();
}
inline void AgentEvent::set_has_started() {
  _impl_._oneof_case_[0] = kStarted;
}
inline void AgentEvent::clear_started() {
  if (_internal_has_started()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_data_.started_;
    }
    clear_has_event_data();
  }
}
inline ::unhinged::cdc::AgentStarted* AgentEvent::release_started() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.AgentEvent.started)
  if (_internal_has_started()) {
    clear_has_event_data();
    ::unhinged::cdc::AgentStarted* temp = _impl_.event_data_.started_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_data_.started_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::cdc::AgentStarted& AgentEvent::_internal_started() const {
  return _internal_has_started()
      ? *_impl_.event_data_.started_
      : reinterpret_cast< ::unhinged::cdc::AgentStarted&>(::unhinged::cdc::_AgentStarted_default_instance_);
}
inline const ::unhinged::cdc::AgentStarted& AgentEvent::started() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.AgentEvent.started)
  return _internal_started();
}
inline ::unhinged::cdc::AgentStarted* AgentEvent::unsafe_arena_release_started() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.cdc.AgentEvent.started)
  if (_internal_has_started()) {
    clear_has_event_data();
    ::unhinged::cdc::AgentStarted* temp = _impl_.event_data_.started_;
    _impl_.event_data_.started_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AgentEvent::unsafe_arena_set_allocated_started(::unhinged::cdc::AgentStarted* started) {
  clear_event_data();
  if (started) {
    set_has_started();
    _impl_.event_data_.started_ = started;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.AgentEvent.started)
}
inline ::unhinged::cdc::AgentStarted* AgentEvent::_internal_mutable_started() {
  if (!_internal_has_started()) {
    clear_event_data();
    set_has_started();
    _impl_.event_data_.started_ = CreateMaybeMessage< ::unhinged::cdc::AgentStarted >(GetArenaForAllocation());
  }
  return _impl_.event_data_.started_;
}
inline ::unhinged::cdc::AgentStarted* AgentEvent::mutable_started() {
  ::unhinged::cdc::AgentStarted* _msg = _internal_mutable_started();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.AgentEvent.started)
  return _msg;
}

// .unhinged.cdc.AgentStepCompleted step_completed = 11;
inline bool AgentEvent::_internal_has_step_completed() const {
  return event_data_case() == kStepCompleted;
}
inline bool AgentEvent::has_step_completed() const {
  return _internal_has_step_completed();
}
inline void AgentEvent::set_has_step_completed() {
  _impl_._oneof_case_[0] = kStepCompleted;
}
inline void AgentEvent::clear_step_completed() {
  if (_internal_has_step_completed()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_data_.step_completed_;
    }
    clear_has_event_data();
  }
}
inline ::unhinged::cdc::AgentStepCompleted* AgentEvent::release_step_completed() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.AgentEvent.step_completed)
  if (_internal_has_step_completed()) {
    clear_has_event_data();
    ::unhinged::cdc::AgentStepCompleted* temp = _impl_.event_data_.step_completed_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_data_.step_completed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::cdc::AgentStepCompleted& AgentEvent::_internal_step_completed() const {
  return _internal_has_step_completed()
      ? *_impl_.event_data_.step_completed_
      : reinterpret_cast< ::unhinged::cdc::AgentStepCompleted&>(::unhinged::cdc::_AgentStepCompleted_default_instance_);
}
inline const ::unhinged::cdc::AgentStepCompleted& AgentEvent::step_completed() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.AgentEvent.step_completed)
  return _internal_step_completed();
}
inline ::unhinged::cdc::AgentStepCompleted* AgentEvent::unsafe_arena_release_step_completed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.cdc.AgentEvent.step_completed)
  if (_internal_has_step_completed()) {
    clear_has_event_data();
    ::unhinged::cdc::AgentStepCompleted* temp = _impl_.event_data_.step_completed_;
    _impl_.event_data_.step_completed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AgentEvent::unsafe_arena_set_allocated_step_completed(::unhinged::cdc::AgentStepCompleted* step_completed) {
  clear_event_data();
  if (step_completed) {
    set_has_step_completed();
    _impl_.event_data_.step_completed_ = step_completed;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.AgentEvent.step_completed)
}
inline ::unhinged::cdc::AgentStepCompleted* AgentEvent::_internal_mutable_step_completed() {
  if (!_internal_has_step_completed()) {
    clear_event_data();
    set_has_step_completed();
    _impl_.event_data_.step_completed_ = CreateMaybeMessage< ::unhinged::cdc::AgentStepCompleted >(GetArenaForAllocation());
  }
  return _impl_.event_data_.step_completed_;
}
inline ::unhinged::cdc::AgentStepCompleted* AgentEvent::mutable_step_completed() {
  ::unhinged::cdc::AgentStepCompleted* _msg = _internal_mutable_step_completed();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.AgentEvent.step_completed)
  return _msg;
}

// .unhinged.cdc.AgentCompleted completed = 12;
inline bool AgentEvent::_internal_has_completed() const {
  return event_data_case() == kCompleted;
}
inline bool AgentEvent::has_completed() const {
  return _internal_has_completed();
}
inline void AgentEvent::set_has_completed() {
  _impl_._oneof_case_[0] = kCompleted;
}
inline void AgentEvent::clear_completed() {
  if (_internal_has_completed()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_data_.completed_;
    }
    clear_has_event_data();
  }
}
inline ::unhinged::cdc::AgentCompleted* AgentEvent::release_completed() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.AgentEvent.completed)
  if (_internal_has_completed()) {
    clear_has_event_data();
    ::unhinged::cdc::AgentCompleted* temp = _impl_.event_data_.completed_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_data_.completed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::cdc::AgentCompleted& AgentEvent::_internal_completed() const {
  return _internal_has_completed()
      ? *_impl_.event_data_.completed_
      : reinterpret_cast< ::unhinged::cdc::AgentCompleted&>(::unhinged::cdc::_AgentCompleted_default_instance_);
}
inline const ::unhinged::cdc::AgentCompleted& AgentEvent::completed() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.AgentEvent.completed)
  return _internal_completed();
}
inline ::unhinged::cdc::AgentCompleted* AgentEvent::unsafe_arena_release_completed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.cdc.AgentEvent.completed)
  if (_internal_has_completed()) {
    clear_has_event_data();
    ::unhinged::cdc::AgentCompleted* temp = _impl_.event_data_.completed_;
    _impl_.event_data_.completed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AgentEvent::unsafe_arena_set_allocated_completed(::unhinged::cdc::AgentCompleted* completed) {
  clear_event_data();
  if (completed) {
    set_has_completed();
    _impl_.event_data_.completed_ = completed;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.AgentEvent.completed)
}
inline ::unhinged::cdc::AgentCompleted* AgentEvent::_internal_mutable_completed() {
  if (!_internal_has_completed()) {
    clear_event_data();
    set_has_completed();
    _impl_.event_data_.completed_ = CreateMaybeMessage< ::unhinged::cdc::AgentCompleted >(GetArenaForAllocation());
  }
  return _impl_.event_data_.completed_;
}
inline ::unhinged::cdc::AgentCompleted* AgentEvent::mutable_completed() {
  ::unhinged::cdc::AgentCompleted* _msg = _internal_mutable_completed();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.AgentEvent.completed)
  return _msg;
}

// .unhinged.cdc.AgentFailed failed = 13;
inline bool AgentEvent::_internal_has_failed() const {
  return event_data_case() == kFailed;
}
inline bool AgentEvent::has_failed() const {
  return _internal_has_failed();
}
inline void AgentEvent::set_has_failed() {
  _impl_._oneof_case_[0] = kFailed;
}
inline void AgentEvent::clear_failed() {
  if (_internal_has_failed()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_data_.failed_;
    }
    clear_has_event_data();
  }
}
inline ::unhinged::cdc::AgentFailed* AgentEvent::release_failed() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.AgentEvent.failed)
  if (_internal_has_failed()) {
    clear_has_event_data();
    ::unhinged::cdc::AgentFailed* temp = _impl_.event_data_.failed_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_data_.failed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::cdc::AgentFailed& AgentEvent::_internal_failed() const {
  return _internal_has_failed()
      ? *_impl_.event_data_.failed_
      : reinterpret_cast< ::unhinged::cdc::AgentFailed&>(::unhinged::cdc::_AgentFailed_default_instance_);
}
inline const ::unhinged::cdc::AgentFailed& AgentEvent::failed() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.AgentEvent.failed)
  return _internal_failed();
}
inline ::unhinged::cdc::AgentFailed* AgentEvent::unsafe_arena_release_failed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.cdc.AgentEvent.failed)
  if (_internal_has_failed()) {
    clear_has_event_data();
    ::unhinged::cdc::AgentFailed* temp = _impl_.event_data_.failed_;
    _impl_.event_data_.failed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AgentEvent::unsafe_arena_set_allocated_failed(::unhinged::cdc::AgentFailed* failed) {
  clear_event_data();
  if (failed) {
    set_has_failed();
    _impl_.event_data_.failed_ = failed;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.AgentEvent.failed)
}
inline ::unhinged::cdc::AgentFailed* AgentEvent::_internal_mutable_failed() {
  if (!_internal_has_failed()) {
    clear_event_data();
    set_has_failed();
    _impl_.event_data_.failed_ = CreateMaybeMessage< ::unhinged::cdc::AgentFailed >(GetArenaForAllocation());
  }
  return _impl_.event_data_.failed_;
}
inline ::unhinged::cdc::AgentFailed* AgentEvent::mutable_failed() {
  ::unhinged::cdc::AgentFailed* _msg = _internal_mutable_failed();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.AgentEvent.failed)
  return _msg;
}

// .unhinged.cdc.AgentToolUsed tool_used = 14;
inline bool AgentEvent::_internal_has_tool_used() const {
  return event_data_case() == kToolUsed;
}
inline bool AgentEvent::has_tool_used() const {
  return _internal_has_tool_used();
}
inline void AgentEvent::set_has_tool_used() {
  _impl_._oneof_case_[0] = kToolUsed;
}
inline void AgentEvent::clear_tool_used() {
  if (_internal_has_tool_used()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_data_.tool_used_;
    }
    clear_has_event_data();
  }
}
inline ::unhinged::cdc::AgentToolUsed* AgentEvent::release_tool_used() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.AgentEvent.tool_used)
  if (_internal_has_tool_used()) {
    clear_has_event_data();
    ::unhinged::cdc::AgentToolUsed* temp = _impl_.event_data_.tool_used_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_data_.tool_used_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::cdc::AgentToolUsed& AgentEvent::_internal_tool_used() const {
  return _internal_has_tool_used()
      ? *_impl_.event_data_.tool_used_
      : reinterpret_cast< ::unhinged::cdc::AgentToolUsed&>(::unhinged::cdc::_AgentToolUsed_default_instance_);
}
inline const ::unhinged::cdc::AgentToolUsed& AgentEvent::tool_used() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.AgentEvent.tool_used)
  return _internal_tool_used();
}
inline ::unhinged::cdc::AgentToolUsed* AgentEvent::unsafe_arena_release_tool_used() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.cdc.AgentEvent.tool_used)
  if (_internal_has_tool_used()) {
    clear_has_event_data();
    ::unhinged::cdc::AgentToolUsed* temp = _impl_.event_data_.tool_used_;
    _impl_.event_data_.tool_used_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AgentEvent::unsafe_arena_set_allocated_tool_used(::unhinged::cdc::AgentToolUsed* tool_used) {
  clear_event_data();
  if (tool_used) {
    set_has_tool_used();
    _impl_.event_data_.tool_used_ = tool_used;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.AgentEvent.tool_used)
}
inline ::unhinged::cdc::AgentToolUsed* AgentEvent::_internal_mutable_tool_used() {
  if (!_internal_has_tool_used()) {
    clear_event_data();
    set_has_tool_used();
    _impl_.event_data_.tool_used_ = CreateMaybeMessage< ::unhinged::cdc::AgentToolUsed >(GetArenaForAllocation());
  }
  return _impl_.event_data_.tool_used_;
}
inline ::unhinged::cdc::AgentToolUsed* AgentEvent::mutable_tool_used() {
  ::unhinged::cdc::AgentToolUsed* _msg = _internal_mutable_tool_used();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.AgentEvent.tool_used)
  return _msg;
}

inline bool AgentEvent::has_event_data() const {
  return event_data_case() != EVENT_DATA_NOT_SET;
}
inline void AgentEvent::clear_has_event_data() {
  _impl_._oneof_case_[0] = EVENT_DATA_NOT_SET;
}
inline AgentEvent::EventDataCase AgentEvent::event_data_case() const {
  return AgentEvent::EventDataCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// AgentStarted

// string task_description = 1;
inline void AgentStarted::clear_task_description() {
  _impl_.task_description_.ClearToEmpty();
}
inline const std::string& AgentStarted::task_description() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.AgentStarted.task_description)
  return _internal_task_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AgentStarted::set_task_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.task_description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.AgentStarted.task_description)
}
inline std::string* AgentStarted::mutable_task_description() {
  std::string* _s = _internal_mutable_task_description();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.AgentStarted.task_description)
  return _s;
}
inline const std::string& AgentStarted::_internal_task_description() const {
  return _impl_.task_description_.Get();
}
inline void AgentStarted::_internal_set_task_description(const std::string& value) {
  
  _impl_.task_description_.Set(value, GetArenaForAllocation());
}
inline std::string* AgentStarted::_internal_mutable_task_description() {
  
  return _impl_.task_description_.Mutable(GetArenaForAllocation());
}
inline std::string* AgentStarted::release_task_description() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.AgentStarted.task_description)
  return _impl_.task_description_.Release();
}
inline void AgentStarted::set_allocated_task_description(std::string* task_description) {
  if (task_description != nullptr) {
    
  } else {
    
  }
  _impl_.task_description_.SetAllocated(task_description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.task_description_.IsDefault()) {
    _impl_.task_description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.AgentStarted.task_description)
}

// .google.protobuf.Struct initial_context = 2;
inline bool AgentStarted::_internal_has_initial_context() const {
  return this != internal_default_instance() && _impl_.initial_context_ != nullptr;
}
inline bool AgentStarted::has_initial_context() const {
  return _internal_has_initial_context();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& AgentStarted::_internal_initial_context() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.initial_context_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& AgentStarted::initial_context() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.AgentStarted.initial_context)
  return _internal_initial_context();
}
inline void AgentStarted::unsafe_arena_set_allocated_initial_context(
    ::PROTOBUF_NAMESPACE_ID::Struct* initial_context) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.initial_context_);
  }
  _impl_.initial_context_ = initial_context;
  if (initial_context) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.AgentStarted.initial_context)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AgentStarted::release_initial_context() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.initial_context_;
  _impl_.initial_context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AgentStarted::unsafe_arena_release_initial_context() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.AgentStarted.initial_context)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.initial_context_;
  _impl_.initial_context_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AgentStarted::_internal_mutable_initial_context() {
  
  if (_impl_.initial_context_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.initial_context_ = p;
  }
  return _impl_.initial_context_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AgentStarted::mutable_initial_context() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_initial_context();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.AgentStarted.initial_context)
  return _msg;
}
inline void AgentStarted::set_allocated_initial_context(::PROTOBUF_NAMESPACE_ID::Struct* initial_context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.initial_context_);
  }
  if (initial_context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(initial_context));
    if (message_arena != submessage_arena) {
      initial_context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, initial_context, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.initial_context_ = initial_context;
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.AgentStarted.initial_context)
}

// repeated string available_tools = 3;
inline int AgentStarted::_internal_available_tools_size() const {
  return _impl_.available_tools_.size();
}
inline int AgentStarted::available_tools_size() const {
  return _internal_available_tools_size();
}
inline void AgentStarted::clear_available_tools() {
  _impl_.available_tools_.Clear();
}
inline std::string* AgentStarted::add_available_tools() {
  std::string* _s = _internal_add_available_tools();
  // @@protoc_insertion_point(field_add_mutable:unhinged.cdc.AgentStarted.available_tools)
  return _s;
}
inline const std::string& AgentStarted::_internal_available_tools(int index) const {
  return _impl_.available_tools_.Get(index);
}
inline const std::string& AgentStarted::available_tools(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.AgentStarted.available_tools)
  return _internal_available_tools(index);
}
inline std::string* AgentStarted::mutable_available_tools(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.AgentStarted.available_tools)
  return _impl_.available_tools_.Mutable(index);
}
inline void AgentStarted::set_available_tools(int index, const std::string& value) {
  _impl_.available_tools_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.AgentStarted.available_tools)
}
inline void AgentStarted::set_available_tools(int index, std::string&& value) {
  _impl_.available_tools_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.cdc.AgentStarted.available_tools)
}
inline void AgentStarted::set_available_tools(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.available_tools_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.cdc.AgentStarted.available_tools)
}
inline void AgentStarted::set_available_tools(int index, const char* value, size_t size) {
  _impl_.available_tools_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.cdc.AgentStarted.available_tools)
}
inline std::string* AgentStarted::_internal_add_available_tools() {
  return _impl_.available_tools_.Add();
}
inline void AgentStarted::add_available_tools(const std::string& value) {
  _impl_.available_tools_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.cdc.AgentStarted.available_tools)
}
inline void AgentStarted::add_available_tools(std::string&& value) {
  _impl_.available_tools_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.cdc.AgentStarted.available_tools)
}
inline void AgentStarted::add_available_tools(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.available_tools_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.cdc.AgentStarted.available_tools)
}
inline void AgentStarted::add_available_tools(const char* value, size_t size) {
  _impl_.available_tools_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.cdc.AgentStarted.available_tools)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AgentStarted::available_tools() const {
  // @@protoc_insertion_point(field_list:unhinged.cdc.AgentStarted.available_tools)
  return _impl_.available_tools_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AgentStarted::mutable_available_tools() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.cdc.AgentStarted.available_tools)
  return &_impl_.available_tools_;
}

// -------------------------------------------------------------------

// AgentStepCompleted

// int32 step_number = 1;
inline void AgentStepCompleted::clear_step_number() {
  _impl_.step_number_ = 0;
}
inline int32_t AgentStepCompleted::_internal_step_number() const {
  return _impl_.step_number_;
}
inline int32_t AgentStepCompleted::step_number() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.AgentStepCompleted.step_number)
  return _internal_step_number();
}
inline void AgentStepCompleted::_internal_set_step_number(int32_t value) {
  
  _impl_.step_number_ = value;
}
inline void AgentStepCompleted::set_step_number(int32_t value) {
  _internal_set_step_number(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.AgentStepCompleted.step_number)
}

// string step_type = 2;
inline void AgentStepCompleted::clear_step_type() {
  _impl_.step_type_.ClearToEmpty();
}
inline const std::string& AgentStepCompleted::step_type() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.AgentStepCompleted.step_type)
  return _internal_step_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AgentStepCompleted::set_step_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.step_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.AgentStepCompleted.step_type)
}
inline std::string* AgentStepCompleted::mutable_step_type() {
  std::string* _s = _internal_mutable_step_type();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.AgentStepCompleted.step_type)
  return _s;
}
inline const std::string& AgentStepCompleted::_internal_step_type() const {
  return _impl_.step_type_.Get();
}
inline void AgentStepCompleted::_internal_set_step_type(const std::string& value) {
  
  _impl_.step_type_.Set(value, GetArenaForAllocation());
}
inline std::string* AgentStepCompleted::_internal_mutable_step_type() {
  
  return _impl_.step_type_.Mutable(GetArenaForAllocation());
}
inline std::string* AgentStepCompleted::release_step_type() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.AgentStepCompleted.step_type)
  return _impl_.step_type_.Release();
}
inline void AgentStepCompleted::set_allocated_step_type(std::string* step_type) {
  if (step_type != nullptr) {
    
  } else {
    
  }
  _impl_.step_type_.SetAllocated(step_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.step_type_.IsDefault()) {
    _impl_.step_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.AgentStepCompleted.step_type)
}

// string step_description = 3;
inline void AgentStepCompleted::clear_step_description() {
  _impl_.step_description_.ClearToEmpty();
}
inline const std::string& AgentStepCompleted::step_description() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.AgentStepCompleted.step_description)
  return _internal_step_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AgentStepCompleted::set_step_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.step_description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.AgentStepCompleted.step_description)
}
inline std::string* AgentStepCompleted::mutable_step_description() {
  std::string* _s = _internal_mutable_step_description();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.AgentStepCompleted.step_description)
  return _s;
}
inline const std::string& AgentStepCompleted::_internal_step_description() const {
  return _impl_.step_description_.Get();
}
inline void AgentStepCompleted::_internal_set_step_description(const std::string& value) {
  
  _impl_.step_description_.Set(value, GetArenaForAllocation());
}
inline std::string* AgentStepCompleted::_internal_mutable_step_description() {
  
  return _impl_.step_description_.Mutable(GetArenaForAllocation());
}
inline std::string* AgentStepCompleted::release_step_description() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.AgentStepCompleted.step_description)
  return _impl_.step_description_.Release();
}
inline void AgentStepCompleted::set_allocated_step_description(std::string* step_description) {
  if (step_description != nullptr) {
    
  } else {
    
  }
  _impl_.step_description_.SetAllocated(step_description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.step_description_.IsDefault()) {
    _impl_.step_description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.AgentStepCompleted.step_description)
}

// .google.protobuf.Struct step_result = 4;
inline bool AgentStepCompleted::_internal_has_step_result() const {
  return this != internal_default_instance() && _impl_.step_result_ != nullptr;
}
inline bool AgentStepCompleted::has_step_result() const {
  return _internal_has_step_result();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& AgentStepCompleted::_internal_step_result() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.step_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& AgentStepCompleted::step_result() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.AgentStepCompleted.step_result)
  return _internal_step_result();
}
inline void AgentStepCompleted::unsafe_arena_set_allocated_step_result(
    ::PROTOBUF_NAMESPACE_ID::Struct* step_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.step_result_);
  }
  _impl_.step_result_ = step_result;
  if (step_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.AgentStepCompleted.step_result)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AgentStepCompleted::release_step_result() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.step_result_;
  _impl_.step_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AgentStepCompleted::unsafe_arena_release_step_result() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.AgentStepCompleted.step_result)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.step_result_;
  _impl_.step_result_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AgentStepCompleted::_internal_mutable_step_result() {
  
  if (_impl_.step_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.step_result_ = p;
  }
  return _impl_.step_result_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AgentStepCompleted::mutable_step_result() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_step_result();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.AgentStepCompleted.step_result)
  return _msg;
}
inline void AgentStepCompleted::set_allocated_step_result(::PROTOBUF_NAMESPACE_ID::Struct* step_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.step_result_);
  }
  if (step_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(step_result));
    if (message_arena != submessage_arena) {
      step_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, step_result, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.step_result_ = step_result;
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.AgentStepCompleted.step_result)
}

// float step_duration_ms = 5;
inline void AgentStepCompleted::clear_step_duration_ms() {
  _impl_.step_duration_ms_ = 0;
}
inline float AgentStepCompleted::_internal_step_duration_ms() const {
  return _impl_.step_duration_ms_;
}
inline float AgentStepCompleted::step_duration_ms() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.AgentStepCompleted.step_duration_ms)
  return _internal_step_duration_ms();
}
inline void AgentStepCompleted::_internal_set_step_duration_ms(float value) {
  
  _impl_.step_duration_ms_ = value;
}
inline void AgentStepCompleted::set_step_duration_ms(float value) {
  _internal_set_step_duration_ms(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.AgentStepCompleted.step_duration_ms)
}

// -------------------------------------------------------------------

// AgentCompleted

// string completion_status = 1;
inline void AgentCompleted::clear_completion_status() {
  _impl_.completion_status_.ClearToEmpty();
}
inline const std::string& AgentCompleted::completion_status() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.AgentCompleted.completion_status)
  return _internal_completion_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AgentCompleted::set_completion_status(ArgT0&& arg0, ArgT... args) {
 
 _impl_.completion_status_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.AgentCompleted.completion_status)
}
inline std::string* AgentCompleted::mutable_completion_status() {
  std::string* _s = _internal_mutable_completion_status();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.AgentCompleted.completion_status)
  return _s;
}
inline const std::string& AgentCompleted::_internal_completion_status() const {
  return _impl_.completion_status_.Get();
}
inline void AgentCompleted::_internal_set_completion_status(const std::string& value) {
  
  _impl_.completion_status_.Set(value, GetArenaForAllocation());
}
inline std::string* AgentCompleted::_internal_mutable_completion_status() {
  
  return _impl_.completion_status_.Mutable(GetArenaForAllocation());
}
inline std::string* AgentCompleted::release_completion_status() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.AgentCompleted.completion_status)
  return _impl_.completion_status_.Release();
}
inline void AgentCompleted::set_allocated_completion_status(std::string* completion_status) {
  if (completion_status != nullptr) {
    
  } else {
    
  }
  _impl_.completion_status_.SetAllocated(completion_status, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.completion_status_.IsDefault()) {
    _impl_.completion_status_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.AgentCompleted.completion_status)
}

// .google.protobuf.Struct final_result = 2;
inline bool AgentCompleted::_internal_has_final_result() const {
  return this != internal_default_instance() && _impl_.final_result_ != nullptr;
}
inline bool AgentCompleted::has_final_result() const {
  return _internal_has_final_result();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& AgentCompleted::_internal_final_result() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.final_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& AgentCompleted::final_result() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.AgentCompleted.final_result)
  return _internal_final_result();
}
inline void AgentCompleted::unsafe_arena_set_allocated_final_result(
    ::PROTOBUF_NAMESPACE_ID::Struct* final_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.final_result_);
  }
  _impl_.final_result_ = final_result;
  if (final_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.AgentCompleted.final_result)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AgentCompleted::release_final_result() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.final_result_;
  _impl_.final_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AgentCompleted::unsafe_arena_release_final_result() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.AgentCompleted.final_result)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.final_result_;
  _impl_.final_result_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AgentCompleted::_internal_mutable_final_result() {
  
  if (_impl_.final_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.final_result_ = p;
  }
  return _impl_.final_result_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AgentCompleted::mutable_final_result() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_final_result();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.AgentCompleted.final_result)
  return _msg;
}
inline void AgentCompleted::set_allocated_final_result(::PROTOBUF_NAMESPACE_ID::Struct* final_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.final_result_);
  }
  if (final_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(final_result));
    if (message_arena != submessage_arena) {
      final_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, final_result, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.final_result_ = final_result;
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.AgentCompleted.final_result)
}

// int32 total_steps = 3;
inline void AgentCompleted::clear_total_steps() {
  _impl_.total_steps_ = 0;
}
inline int32_t AgentCompleted::_internal_total_steps() const {
  return _impl_.total_steps_;
}
inline int32_t AgentCompleted::total_steps() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.AgentCompleted.total_steps)
  return _internal_total_steps();
}
inline void AgentCompleted::_internal_set_total_steps(int32_t value) {
  
  _impl_.total_steps_ = value;
}
inline void AgentCompleted::set_total_steps(int32_t value) {
  _internal_set_total_steps(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.AgentCompleted.total_steps)
}

// float total_duration_ms = 4;
inline void AgentCompleted::clear_total_duration_ms() {
  _impl_.total_duration_ms_ = 0;
}
inline float AgentCompleted::_internal_total_duration_ms() const {
  return _impl_.total_duration_ms_;
}
inline float AgentCompleted::total_duration_ms() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.AgentCompleted.total_duration_ms)
  return _internal_total_duration_ms();
}
inline void AgentCompleted::_internal_set_total_duration_ms(float value) {
  
  _impl_.total_duration_ms_ = value;
}
inline void AgentCompleted::set_total_duration_ms(float value) {
  _internal_set_total_duration_ms(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.AgentCompleted.total_duration_ms)
}

// -------------------------------------------------------------------

// AgentFailed

// string failure_reason = 1;
inline void AgentFailed::clear_failure_reason() {
  _impl_.failure_reason_.ClearToEmpty();
}
inline const std::string& AgentFailed::failure_reason() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.AgentFailed.failure_reason)
  return _internal_failure_reason();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AgentFailed::set_failure_reason(ArgT0&& arg0, ArgT... args) {
 
 _impl_.failure_reason_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.AgentFailed.failure_reason)
}
inline std::string* AgentFailed::mutable_failure_reason() {
  std::string* _s = _internal_mutable_failure_reason();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.AgentFailed.failure_reason)
  return _s;
}
inline const std::string& AgentFailed::_internal_failure_reason() const {
  return _impl_.failure_reason_.Get();
}
inline void AgentFailed::_internal_set_failure_reason(const std::string& value) {
  
  _impl_.failure_reason_.Set(value, GetArenaForAllocation());
}
inline std::string* AgentFailed::_internal_mutable_failure_reason() {
  
  return _impl_.failure_reason_.Mutable(GetArenaForAllocation());
}
inline std::string* AgentFailed::release_failure_reason() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.AgentFailed.failure_reason)
  return _impl_.failure_reason_.Release();
}
inline void AgentFailed::set_allocated_failure_reason(std::string* failure_reason) {
  if (failure_reason != nullptr) {
    
  } else {
    
  }
  _impl_.failure_reason_.SetAllocated(failure_reason, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.failure_reason_.IsDefault()) {
    _impl_.failure_reason_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.AgentFailed.failure_reason)
}

// string error_message = 2;
inline void AgentFailed::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& AgentFailed::error_message() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.AgentFailed.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AgentFailed::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.AgentFailed.error_message)
}
inline std::string* AgentFailed::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.AgentFailed.error_message)
  return _s;
}
inline const std::string& AgentFailed::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void AgentFailed::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* AgentFailed::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* AgentFailed::release_error_message() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.AgentFailed.error_message)
  return _impl_.error_message_.Release();
}
inline void AgentFailed::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.AgentFailed.error_message)
}

// int32 failed_at_step = 3;
inline void AgentFailed::clear_failed_at_step() {
  _impl_.failed_at_step_ = 0;
}
inline int32_t AgentFailed::_internal_failed_at_step() const {
  return _impl_.failed_at_step_;
}
inline int32_t AgentFailed::failed_at_step() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.AgentFailed.failed_at_step)
  return _internal_failed_at_step();
}
inline void AgentFailed::_internal_set_failed_at_step(int32_t value) {
  
  _impl_.failed_at_step_ = value;
}
inline void AgentFailed::set_failed_at_step(int32_t value) {
  _internal_set_failed_at_step(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.AgentFailed.failed_at_step)
}

// bool is_recoverable = 4;
inline void AgentFailed::clear_is_recoverable() {
  _impl_.is_recoverable_ = false;
}
inline bool AgentFailed::_internal_is_recoverable() const {
  return _impl_.is_recoverable_;
}
inline bool AgentFailed::is_recoverable() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.AgentFailed.is_recoverable)
  return _internal_is_recoverable();
}
inline void AgentFailed::_internal_set_is_recoverable(bool value) {
  
  _impl_.is_recoverable_ = value;
}
inline void AgentFailed::set_is_recoverable(bool value) {
  _internal_set_is_recoverable(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.AgentFailed.is_recoverable)
}

// -------------------------------------------------------------------

// AgentToolUsed

// string tool_name = 1;
inline void AgentToolUsed::clear_tool_name() {
  _impl_.tool_name_.ClearToEmpty();
}
inline const std::string& AgentToolUsed::tool_name() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.AgentToolUsed.tool_name)
  return _internal_tool_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AgentToolUsed::set_tool_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tool_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.AgentToolUsed.tool_name)
}
inline std::string* AgentToolUsed::mutable_tool_name() {
  std::string* _s = _internal_mutable_tool_name();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.AgentToolUsed.tool_name)
  return _s;
}
inline const std::string& AgentToolUsed::_internal_tool_name() const {
  return _impl_.tool_name_.Get();
}
inline void AgentToolUsed::_internal_set_tool_name(const std::string& value) {
  
  _impl_.tool_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AgentToolUsed::_internal_mutable_tool_name() {
  
  return _impl_.tool_name_.Mutable(GetArenaForAllocation());
}
inline std::string* AgentToolUsed::release_tool_name() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.AgentToolUsed.tool_name)
  return _impl_.tool_name_.Release();
}
inline void AgentToolUsed::set_allocated_tool_name(std::string* tool_name) {
  if (tool_name != nullptr) {
    
  } else {
    
  }
  _impl_.tool_name_.SetAllocated(tool_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tool_name_.IsDefault()) {
    _impl_.tool_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.AgentToolUsed.tool_name)
}

// string tool_version = 2;
inline void AgentToolUsed::clear_tool_version() {
  _impl_.tool_version_.ClearToEmpty();
}
inline const std::string& AgentToolUsed::tool_version() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.AgentToolUsed.tool_version)
  return _internal_tool_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AgentToolUsed::set_tool_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tool_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.AgentToolUsed.tool_version)
}
inline std::string* AgentToolUsed::mutable_tool_version() {
  std::string* _s = _internal_mutable_tool_version();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.AgentToolUsed.tool_version)
  return _s;
}
inline const std::string& AgentToolUsed::_internal_tool_version() const {
  return _impl_.tool_version_.Get();
}
inline void AgentToolUsed::_internal_set_tool_version(const std::string& value) {
  
  _impl_.tool_version_.Set(value, GetArenaForAllocation());
}
inline std::string* AgentToolUsed::_internal_mutable_tool_version() {
  
  return _impl_.tool_version_.Mutable(GetArenaForAllocation());
}
inline std::string* AgentToolUsed::release_tool_version() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.AgentToolUsed.tool_version)
  return _impl_.tool_version_.Release();
}
inline void AgentToolUsed::set_allocated_tool_version(std::string* tool_version) {
  if (tool_version != nullptr) {
    
  } else {
    
  }
  _impl_.tool_version_.SetAllocated(tool_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tool_version_.IsDefault()) {
    _impl_.tool_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.AgentToolUsed.tool_version)
}

// .google.protobuf.Struct tool_input = 3;
inline bool AgentToolUsed::_internal_has_tool_input() const {
  return this != internal_default_instance() && _impl_.tool_input_ != nullptr;
}
inline bool AgentToolUsed::has_tool_input() const {
  return _internal_has_tool_input();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& AgentToolUsed::_internal_tool_input() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.tool_input_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& AgentToolUsed::tool_input() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.AgentToolUsed.tool_input)
  return _internal_tool_input();
}
inline void AgentToolUsed::unsafe_arena_set_allocated_tool_input(
    ::PROTOBUF_NAMESPACE_ID::Struct* tool_input) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tool_input_);
  }
  _impl_.tool_input_ = tool_input;
  if (tool_input) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.AgentToolUsed.tool_input)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AgentToolUsed::release_tool_input() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.tool_input_;
  _impl_.tool_input_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AgentToolUsed::unsafe_arena_release_tool_input() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.AgentToolUsed.tool_input)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.tool_input_;
  _impl_.tool_input_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AgentToolUsed::_internal_mutable_tool_input() {
  
  if (_impl_.tool_input_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.tool_input_ = p;
  }
  return _impl_.tool_input_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AgentToolUsed::mutable_tool_input() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_tool_input();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.AgentToolUsed.tool_input)
  return _msg;
}
inline void AgentToolUsed::set_allocated_tool_input(::PROTOBUF_NAMESPACE_ID::Struct* tool_input) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tool_input_);
  }
  if (tool_input) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tool_input));
    if (message_arena != submessage_arena) {
      tool_input = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tool_input, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.tool_input_ = tool_input;
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.AgentToolUsed.tool_input)
}

// .google.protobuf.Struct tool_output = 4;
inline bool AgentToolUsed::_internal_has_tool_output() const {
  return this != internal_default_instance() && _impl_.tool_output_ != nullptr;
}
inline bool AgentToolUsed::has_tool_output() const {
  return _internal_has_tool_output();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& AgentToolUsed::_internal_tool_output() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.tool_output_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& AgentToolUsed::tool_output() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.AgentToolUsed.tool_output)
  return _internal_tool_output();
}
inline void AgentToolUsed::unsafe_arena_set_allocated_tool_output(
    ::PROTOBUF_NAMESPACE_ID::Struct* tool_output) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tool_output_);
  }
  _impl_.tool_output_ = tool_output;
  if (tool_output) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.AgentToolUsed.tool_output)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AgentToolUsed::release_tool_output() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.tool_output_;
  _impl_.tool_output_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AgentToolUsed::unsafe_arena_release_tool_output() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.AgentToolUsed.tool_output)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.tool_output_;
  _impl_.tool_output_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AgentToolUsed::_internal_mutable_tool_output() {
  
  if (_impl_.tool_output_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.tool_output_ = p;
  }
  return _impl_.tool_output_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AgentToolUsed::mutable_tool_output() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_tool_output();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.AgentToolUsed.tool_output)
  return _msg;
}
inline void AgentToolUsed::set_allocated_tool_output(::PROTOBUF_NAMESPACE_ID::Struct* tool_output) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tool_output_);
  }
  if (tool_output) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tool_output));
    if (message_arena != submessage_arena) {
      tool_output = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tool_output, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.tool_output_ = tool_output;
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.AgentToolUsed.tool_output)
}

// float tool_duration_ms = 5;
inline void AgentToolUsed::clear_tool_duration_ms() {
  _impl_.tool_duration_ms_ = 0;
}
inline float AgentToolUsed::_internal_tool_duration_ms() const {
  return _impl_.tool_duration_ms_;
}
inline float AgentToolUsed::tool_duration_ms() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.AgentToolUsed.tool_duration_ms)
  return _internal_tool_duration_ms();
}
inline void AgentToolUsed::_internal_set_tool_duration_ms(float value) {
  
  _impl_.tool_duration_ms_ = value;
}
inline void AgentToolUsed::set_tool_duration_ms(float value) {
  _internal_set_tool_duration_ms(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.AgentToolUsed.tool_duration_ms)
}

// bool tool_success = 6;
inline void AgentToolUsed::clear_tool_success() {
  _impl_.tool_success_ = false;
}
inline bool AgentToolUsed::_internal_tool_success() const {
  return _impl_.tool_success_;
}
inline bool AgentToolUsed::tool_success() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.AgentToolUsed.tool_success)
  return _internal_tool_success();
}
inline void AgentToolUsed::_internal_set_tool_success(bool value) {
  
  _impl_.tool_success_ = value;
}
inline void AgentToolUsed::set_tool_success(bool value) {
  _internal_set_tool_success(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.AgentToolUsed.tool_success)
}

// -------------------------------------------------------------------

// SessionEvent

// string session_id = 1;
inline void SessionEvent::clear_session_id() {
  _impl_.session_id_.ClearToEmpty();
}
inline const std::string& SessionEvent::session_id() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.SessionEvent.session_id)
  return _internal_session_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SessionEvent::set_session_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.session_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.SessionEvent.session_id)
}
inline std::string* SessionEvent::mutable_session_id() {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.SessionEvent.session_id)
  return _s;
}
inline const std::string& SessionEvent::_internal_session_id() const {
  return _impl_.session_id_.Get();
}
inline void SessionEvent::_internal_set_session_id(const std::string& value) {
  
  _impl_.session_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SessionEvent::_internal_mutable_session_id() {
  
  return _impl_.session_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SessionEvent::release_session_id() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.SessionEvent.session_id)
  return _impl_.session_id_.Release();
}
inline void SessionEvent::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  _impl_.session_id_.SetAllocated(session_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.session_id_.IsDefault()) {
    _impl_.session_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.SessionEvent.session_id)
}

// .unhinged.cdc.SessionEventType event_type = 2;
inline void SessionEvent::clear_event_type() {
  _impl_.event_type_ = 0;
}
inline ::unhinged::cdc::SessionEventType SessionEvent::_internal_event_type() const {
  return static_cast< ::unhinged::cdc::SessionEventType >(_impl_.event_type_);
}
inline ::unhinged::cdc::SessionEventType SessionEvent::event_type() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.SessionEvent.event_type)
  return _internal_event_type();
}
inline void SessionEvent::_internal_set_event_type(::unhinged::cdc::SessionEventType value) {
  
  _impl_.event_type_ = value;
}
inline void SessionEvent::set_event_type(::unhinged::cdc::SessionEventType value) {
  _internal_set_event_type(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.SessionEvent.event_type)
}

// .unhinged.cdc.SessionStarted started = 10;
inline bool SessionEvent::_internal_has_started() const {
  return event_data_case() == kStarted;
}
inline bool SessionEvent::has_started() const {
  return _internal_has_started();
}
inline void SessionEvent::set_has_started() {
  _impl_._oneof_case_[0] = kStarted;
}
inline void SessionEvent::clear_started() {
  if (_internal_has_started()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_data_.started_;
    }
    clear_has_event_data();
  }
}
inline ::unhinged::cdc::SessionStarted* SessionEvent::release_started() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.SessionEvent.started)
  if (_internal_has_started()) {
    clear_has_event_data();
    ::unhinged::cdc::SessionStarted* temp = _impl_.event_data_.started_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_data_.started_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::cdc::SessionStarted& SessionEvent::_internal_started() const {
  return _internal_has_started()
      ? *_impl_.event_data_.started_
      : reinterpret_cast< ::unhinged::cdc::SessionStarted&>(::unhinged::cdc::_SessionStarted_default_instance_);
}
inline const ::unhinged::cdc::SessionStarted& SessionEvent::started() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.SessionEvent.started)
  return _internal_started();
}
inline ::unhinged::cdc::SessionStarted* SessionEvent::unsafe_arena_release_started() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.cdc.SessionEvent.started)
  if (_internal_has_started()) {
    clear_has_event_data();
    ::unhinged::cdc::SessionStarted* temp = _impl_.event_data_.started_;
    _impl_.event_data_.started_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SessionEvent::unsafe_arena_set_allocated_started(::unhinged::cdc::SessionStarted* started) {
  clear_event_data();
  if (started) {
    set_has_started();
    _impl_.event_data_.started_ = started;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.SessionEvent.started)
}
inline ::unhinged::cdc::SessionStarted* SessionEvent::_internal_mutable_started() {
  if (!_internal_has_started()) {
    clear_event_data();
    set_has_started();
    _impl_.event_data_.started_ = CreateMaybeMessage< ::unhinged::cdc::SessionStarted >(GetArenaForAllocation());
  }
  return _impl_.event_data_.started_;
}
inline ::unhinged::cdc::SessionStarted* SessionEvent::mutable_started() {
  ::unhinged::cdc::SessionStarted* _msg = _internal_mutable_started();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.SessionEvent.started)
  return _msg;
}

// .unhinged.cdc.SessionEnded ended = 11;
inline bool SessionEvent::_internal_has_ended() const {
  return event_data_case() == kEnded;
}
inline bool SessionEvent::has_ended() const {
  return _internal_has_ended();
}
inline void SessionEvent::set_has_ended() {
  _impl_._oneof_case_[0] = kEnded;
}
inline void SessionEvent::clear_ended() {
  if (_internal_has_ended()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_data_.ended_;
    }
    clear_has_event_data();
  }
}
inline ::unhinged::cdc::SessionEnded* SessionEvent::release_ended() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.SessionEvent.ended)
  if (_internal_has_ended()) {
    clear_has_event_data();
    ::unhinged::cdc::SessionEnded* temp = _impl_.event_data_.ended_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_data_.ended_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::cdc::SessionEnded& SessionEvent::_internal_ended() const {
  return _internal_has_ended()
      ? *_impl_.event_data_.ended_
      : reinterpret_cast< ::unhinged::cdc::SessionEnded&>(::unhinged::cdc::_SessionEnded_default_instance_);
}
inline const ::unhinged::cdc::SessionEnded& SessionEvent::ended() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.SessionEvent.ended)
  return _internal_ended();
}
inline ::unhinged::cdc::SessionEnded* SessionEvent::unsafe_arena_release_ended() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.cdc.SessionEvent.ended)
  if (_internal_has_ended()) {
    clear_has_event_data();
    ::unhinged::cdc::SessionEnded* temp = _impl_.event_data_.ended_;
    _impl_.event_data_.ended_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SessionEvent::unsafe_arena_set_allocated_ended(::unhinged::cdc::SessionEnded* ended) {
  clear_event_data();
  if (ended) {
    set_has_ended();
    _impl_.event_data_.ended_ = ended;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.SessionEvent.ended)
}
inline ::unhinged::cdc::SessionEnded* SessionEvent::_internal_mutable_ended() {
  if (!_internal_has_ended()) {
    clear_event_data();
    set_has_ended();
    _impl_.event_data_.ended_ = CreateMaybeMessage< ::unhinged::cdc::SessionEnded >(GetArenaForAllocation());
  }
  return _impl_.event_data_.ended_;
}
inline ::unhinged::cdc::SessionEnded* SessionEvent::mutable_ended() {
  ::unhinged::cdc::SessionEnded* _msg = _internal_mutable_ended();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.SessionEvent.ended)
  return _msg;
}

// .unhinged.cdc.SessionContextAccessed context_accessed = 12;
inline bool SessionEvent::_internal_has_context_accessed() const {
  return event_data_case() == kContextAccessed;
}
inline bool SessionEvent::has_context_accessed() const {
  return _internal_has_context_accessed();
}
inline void SessionEvent::set_has_context_accessed() {
  _impl_._oneof_case_[0] = kContextAccessed;
}
inline void SessionEvent::clear_context_accessed() {
  if (_internal_has_context_accessed()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_data_.context_accessed_;
    }
    clear_has_event_data();
  }
}
inline ::unhinged::cdc::SessionContextAccessed* SessionEvent::release_context_accessed() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.SessionEvent.context_accessed)
  if (_internal_has_context_accessed()) {
    clear_has_event_data();
    ::unhinged::cdc::SessionContextAccessed* temp = _impl_.event_data_.context_accessed_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_data_.context_accessed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::cdc::SessionContextAccessed& SessionEvent::_internal_context_accessed() const {
  return _internal_has_context_accessed()
      ? *_impl_.event_data_.context_accessed_
      : reinterpret_cast< ::unhinged::cdc::SessionContextAccessed&>(::unhinged::cdc::_SessionContextAccessed_default_instance_);
}
inline const ::unhinged::cdc::SessionContextAccessed& SessionEvent::context_accessed() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.SessionEvent.context_accessed)
  return _internal_context_accessed();
}
inline ::unhinged::cdc::SessionContextAccessed* SessionEvent::unsafe_arena_release_context_accessed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.cdc.SessionEvent.context_accessed)
  if (_internal_has_context_accessed()) {
    clear_has_event_data();
    ::unhinged::cdc::SessionContextAccessed* temp = _impl_.event_data_.context_accessed_;
    _impl_.event_data_.context_accessed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SessionEvent::unsafe_arena_set_allocated_context_accessed(::unhinged::cdc::SessionContextAccessed* context_accessed) {
  clear_event_data();
  if (context_accessed) {
    set_has_context_accessed();
    _impl_.event_data_.context_accessed_ = context_accessed;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.SessionEvent.context_accessed)
}
inline ::unhinged::cdc::SessionContextAccessed* SessionEvent::_internal_mutable_context_accessed() {
  if (!_internal_has_context_accessed()) {
    clear_event_data();
    set_has_context_accessed();
    _impl_.event_data_.context_accessed_ = CreateMaybeMessage< ::unhinged::cdc::SessionContextAccessed >(GetArenaForAllocation());
  }
  return _impl_.event_data_.context_accessed_;
}
inline ::unhinged::cdc::SessionContextAccessed* SessionEvent::mutable_context_accessed() {
  ::unhinged::cdc::SessionContextAccessed* _msg = _internal_mutable_context_accessed();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.SessionEvent.context_accessed)
  return _msg;
}

// .unhinged.cdc.SessionHeartbeat heartbeat = 13;
inline bool SessionEvent::_internal_has_heartbeat() const {
  return event_data_case() == kHeartbeat;
}
inline bool SessionEvent::has_heartbeat() const {
  return _internal_has_heartbeat();
}
inline void SessionEvent::set_has_heartbeat() {
  _impl_._oneof_case_[0] = kHeartbeat;
}
inline void SessionEvent::clear_heartbeat() {
  if (_internal_has_heartbeat()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_data_.heartbeat_;
    }
    clear_has_event_data();
  }
}
inline ::unhinged::cdc::SessionHeartbeat* SessionEvent::release_heartbeat() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.SessionEvent.heartbeat)
  if (_internal_has_heartbeat()) {
    clear_has_event_data();
    ::unhinged::cdc::SessionHeartbeat* temp = _impl_.event_data_.heartbeat_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_data_.heartbeat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::cdc::SessionHeartbeat& SessionEvent::_internal_heartbeat() const {
  return _internal_has_heartbeat()
      ? *_impl_.event_data_.heartbeat_
      : reinterpret_cast< ::unhinged::cdc::SessionHeartbeat&>(::unhinged::cdc::_SessionHeartbeat_default_instance_);
}
inline const ::unhinged::cdc::SessionHeartbeat& SessionEvent::heartbeat() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.SessionEvent.heartbeat)
  return _internal_heartbeat();
}
inline ::unhinged::cdc::SessionHeartbeat* SessionEvent::unsafe_arena_release_heartbeat() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.cdc.SessionEvent.heartbeat)
  if (_internal_has_heartbeat()) {
    clear_has_event_data();
    ::unhinged::cdc::SessionHeartbeat* temp = _impl_.event_data_.heartbeat_;
    _impl_.event_data_.heartbeat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SessionEvent::unsafe_arena_set_allocated_heartbeat(::unhinged::cdc::SessionHeartbeat* heartbeat) {
  clear_event_data();
  if (heartbeat) {
    set_has_heartbeat();
    _impl_.event_data_.heartbeat_ = heartbeat;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.SessionEvent.heartbeat)
}
inline ::unhinged::cdc::SessionHeartbeat* SessionEvent::_internal_mutable_heartbeat() {
  if (!_internal_has_heartbeat()) {
    clear_event_data();
    set_has_heartbeat();
    _impl_.event_data_.heartbeat_ = CreateMaybeMessage< ::unhinged::cdc::SessionHeartbeat >(GetArenaForAllocation());
  }
  return _impl_.event_data_.heartbeat_;
}
inline ::unhinged::cdc::SessionHeartbeat* SessionEvent::mutable_heartbeat() {
  ::unhinged::cdc::SessionHeartbeat* _msg = _internal_mutable_heartbeat();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.SessionEvent.heartbeat)
  return _msg;
}

inline bool SessionEvent::has_event_data() const {
  return event_data_case() != EVENT_DATA_NOT_SET;
}
inline void SessionEvent::clear_has_event_data() {
  _impl_._oneof_case_[0] = EVENT_DATA_NOT_SET;
}
inline SessionEvent::EventDataCase SessionEvent::event_data_case() const {
  return SessionEvent::EventDataCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SessionStarted

// string user_agent = 1;
inline void SessionStarted::clear_user_agent() {
  _impl_.user_agent_.ClearToEmpty();
}
inline const std::string& SessionStarted::user_agent() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.SessionStarted.user_agent)
  return _internal_user_agent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SessionStarted::set_user_agent(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_agent_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.SessionStarted.user_agent)
}
inline std::string* SessionStarted::mutable_user_agent() {
  std::string* _s = _internal_mutable_user_agent();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.SessionStarted.user_agent)
  return _s;
}
inline const std::string& SessionStarted::_internal_user_agent() const {
  return _impl_.user_agent_.Get();
}
inline void SessionStarted::_internal_set_user_agent(const std::string& value) {
  
  _impl_.user_agent_.Set(value, GetArenaForAllocation());
}
inline std::string* SessionStarted::_internal_mutable_user_agent() {
  
  return _impl_.user_agent_.Mutable(GetArenaForAllocation());
}
inline std::string* SessionStarted::release_user_agent() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.SessionStarted.user_agent)
  return _impl_.user_agent_.Release();
}
inline void SessionStarted::set_allocated_user_agent(std::string* user_agent) {
  if (user_agent != nullptr) {
    
  } else {
    
  }
  _impl_.user_agent_.SetAllocated(user_agent, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_agent_.IsDefault()) {
    _impl_.user_agent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.SessionStarted.user_agent)
}

// string ip_address = 2;
inline void SessionStarted::clear_ip_address() {
  _impl_.ip_address_.ClearToEmpty();
}
inline const std::string& SessionStarted::ip_address() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.SessionStarted.ip_address)
  return _internal_ip_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SessionStarted::set_ip_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ip_address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.SessionStarted.ip_address)
}
inline std::string* SessionStarted::mutable_ip_address() {
  std::string* _s = _internal_mutable_ip_address();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.SessionStarted.ip_address)
  return _s;
}
inline const std::string& SessionStarted::_internal_ip_address() const {
  return _impl_.ip_address_.Get();
}
inline void SessionStarted::_internal_set_ip_address(const std::string& value) {
  
  _impl_.ip_address_.Set(value, GetArenaForAllocation());
}
inline std::string* SessionStarted::_internal_mutable_ip_address() {
  
  return _impl_.ip_address_.Mutable(GetArenaForAllocation());
}
inline std::string* SessionStarted::release_ip_address() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.SessionStarted.ip_address)
  return _impl_.ip_address_.Release();
}
inline void SessionStarted::set_allocated_ip_address(std::string* ip_address) {
  if (ip_address != nullptr) {
    
  } else {
    
  }
  _impl_.ip_address_.SetAllocated(ip_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ip_address_.IsDefault()) {
    _impl_.ip_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.SessionStarted.ip_address)
}

// .google.protobuf.Struct session_metadata = 3;
inline bool SessionStarted::_internal_has_session_metadata() const {
  return this != internal_default_instance() && _impl_.session_metadata_ != nullptr;
}
inline bool SessionStarted::has_session_metadata() const {
  return _internal_has_session_metadata();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& SessionStarted::_internal_session_metadata() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.session_metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& SessionStarted::session_metadata() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.SessionStarted.session_metadata)
  return _internal_session_metadata();
}
inline void SessionStarted::unsafe_arena_set_allocated_session_metadata(
    ::PROTOBUF_NAMESPACE_ID::Struct* session_metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.session_metadata_);
  }
  _impl_.session_metadata_ = session_metadata;
  if (session_metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.SessionStarted.session_metadata)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* SessionStarted::release_session_metadata() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.session_metadata_;
  _impl_.session_metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* SessionStarted::unsafe_arena_release_session_metadata() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.SessionStarted.session_metadata)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.session_metadata_;
  _impl_.session_metadata_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* SessionStarted::_internal_mutable_session_metadata() {
  
  if (_impl_.session_metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.session_metadata_ = p;
  }
  return _impl_.session_metadata_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* SessionStarted::mutable_session_metadata() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_session_metadata();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.SessionStarted.session_metadata)
  return _msg;
}
inline void SessionStarted::set_allocated_session_metadata(::PROTOBUF_NAMESPACE_ID::Struct* session_metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.session_metadata_);
  }
  if (session_metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(session_metadata));
    if (message_arena != submessage_arena) {
      session_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, session_metadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.session_metadata_ = session_metadata;
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.SessionStarted.session_metadata)
}

// -------------------------------------------------------------------

// SessionEnded

// string end_reason = 1;
inline void SessionEnded::clear_end_reason() {
  _impl_.end_reason_.ClearToEmpty();
}
inline const std::string& SessionEnded::end_reason() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.SessionEnded.end_reason)
  return _internal_end_reason();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SessionEnded::set_end_reason(ArgT0&& arg0, ArgT... args) {
 
 _impl_.end_reason_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.SessionEnded.end_reason)
}
inline std::string* SessionEnded::mutable_end_reason() {
  std::string* _s = _internal_mutable_end_reason();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.SessionEnded.end_reason)
  return _s;
}
inline const std::string& SessionEnded::_internal_end_reason() const {
  return _impl_.end_reason_.Get();
}
inline void SessionEnded::_internal_set_end_reason(const std::string& value) {
  
  _impl_.end_reason_.Set(value, GetArenaForAllocation());
}
inline std::string* SessionEnded::_internal_mutable_end_reason() {
  
  return _impl_.end_reason_.Mutable(GetArenaForAllocation());
}
inline std::string* SessionEnded::release_end_reason() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.SessionEnded.end_reason)
  return _impl_.end_reason_.Release();
}
inline void SessionEnded::set_allocated_end_reason(std::string* end_reason) {
  if (end_reason != nullptr) {
    
  } else {
    
  }
  _impl_.end_reason_.SetAllocated(end_reason, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.end_reason_.IsDefault()) {
    _impl_.end_reason_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.SessionEnded.end_reason)
}

// float session_duration_ms = 2;
inline void SessionEnded::clear_session_duration_ms() {
  _impl_.session_duration_ms_ = 0;
}
inline float SessionEnded::_internal_session_duration_ms() const {
  return _impl_.session_duration_ms_;
}
inline float SessionEnded::session_duration_ms() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.SessionEnded.session_duration_ms)
  return _internal_session_duration_ms();
}
inline void SessionEnded::_internal_set_session_duration_ms(float value) {
  
  _impl_.session_duration_ms_ = value;
}
inline void SessionEnded::set_session_duration_ms(float value) {
  _internal_set_session_duration_ms(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.SessionEnded.session_duration_ms)
}

// int32 interactions_count = 3;
inline void SessionEnded::clear_interactions_count() {
  _impl_.interactions_count_ = 0;
}
inline int32_t SessionEnded::_internal_interactions_count() const {
  return _impl_.interactions_count_;
}
inline int32_t SessionEnded::interactions_count() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.SessionEnded.interactions_count)
  return _internal_interactions_count();
}
inline void SessionEnded::_internal_set_interactions_count(int32_t value) {
  
  _impl_.interactions_count_ = value;
}
inline void SessionEnded::set_interactions_count(int32_t value) {
  _internal_set_interactions_count(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.SessionEnded.interactions_count)
}

// -------------------------------------------------------------------

// SessionContextAccessed

// repeated string document_types = 1;
inline int SessionContextAccessed::_internal_document_types_size() const {
  return _impl_.document_types_.size();
}
inline int SessionContextAccessed::document_types_size() const {
  return _internal_document_types_size();
}
inline void SessionContextAccessed::clear_document_types() {
  _impl_.document_types_.Clear();
}
inline std::string* SessionContextAccessed::add_document_types() {
  std::string* _s = _internal_add_document_types();
  // @@protoc_insertion_point(field_add_mutable:unhinged.cdc.SessionContextAccessed.document_types)
  return _s;
}
inline const std::string& SessionContextAccessed::_internal_document_types(int index) const {
  return _impl_.document_types_.Get(index);
}
inline const std::string& SessionContextAccessed::document_types(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.SessionContextAccessed.document_types)
  return _internal_document_types(index);
}
inline std::string* SessionContextAccessed::mutable_document_types(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.SessionContextAccessed.document_types)
  return _impl_.document_types_.Mutable(index);
}
inline void SessionContextAccessed::set_document_types(int index, const std::string& value) {
  _impl_.document_types_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.SessionContextAccessed.document_types)
}
inline void SessionContextAccessed::set_document_types(int index, std::string&& value) {
  _impl_.document_types_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.cdc.SessionContextAccessed.document_types)
}
inline void SessionContextAccessed::set_document_types(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.document_types_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.cdc.SessionContextAccessed.document_types)
}
inline void SessionContextAccessed::set_document_types(int index, const char* value, size_t size) {
  _impl_.document_types_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.cdc.SessionContextAccessed.document_types)
}
inline std::string* SessionContextAccessed::_internal_add_document_types() {
  return _impl_.document_types_.Add();
}
inline void SessionContextAccessed::add_document_types(const std::string& value) {
  _impl_.document_types_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.cdc.SessionContextAccessed.document_types)
}
inline void SessionContextAccessed::add_document_types(std::string&& value) {
  _impl_.document_types_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.cdc.SessionContextAccessed.document_types)
}
inline void SessionContextAccessed::add_document_types(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.document_types_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.cdc.SessionContextAccessed.document_types)
}
inline void SessionContextAccessed::add_document_types(const char* value, size_t size) {
  _impl_.document_types_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.cdc.SessionContextAccessed.document_types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SessionContextAccessed::document_types() const {
  // @@protoc_insertion_point(field_list:unhinged.cdc.SessionContextAccessed.document_types)
  return _impl_.document_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SessionContextAccessed::mutable_document_types() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.cdc.SessionContextAccessed.document_types)
  return &_impl_.document_types_;
}

// int32 documents_returned = 2;
inline void SessionContextAccessed::clear_documents_returned() {
  _impl_.documents_returned_ = 0;
}
inline int32_t SessionContextAccessed::_internal_documents_returned() const {
  return _impl_.documents_returned_;
}
inline int32_t SessionContextAccessed::documents_returned() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.SessionContextAccessed.documents_returned)
  return _internal_documents_returned();
}
inline void SessionContextAccessed::_internal_set_documents_returned(int32_t value) {
  
  _impl_.documents_returned_ = value;
}
inline void SessionContextAccessed::set_documents_returned(int32_t value) {
  _internal_set_documents_returned(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.SessionContextAccessed.documents_returned)
}

// string access_reason = 3;
inline void SessionContextAccessed::clear_access_reason() {
  _impl_.access_reason_.ClearToEmpty();
}
inline const std::string& SessionContextAccessed::access_reason() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.SessionContextAccessed.access_reason)
  return _internal_access_reason();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SessionContextAccessed::set_access_reason(ArgT0&& arg0, ArgT... args) {
 
 _impl_.access_reason_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.SessionContextAccessed.access_reason)
}
inline std::string* SessionContextAccessed::mutable_access_reason() {
  std::string* _s = _internal_mutable_access_reason();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.SessionContextAccessed.access_reason)
  return _s;
}
inline const std::string& SessionContextAccessed::_internal_access_reason() const {
  return _impl_.access_reason_.Get();
}
inline void SessionContextAccessed::_internal_set_access_reason(const std::string& value) {
  
  _impl_.access_reason_.Set(value, GetArenaForAllocation());
}
inline std::string* SessionContextAccessed::_internal_mutable_access_reason() {
  
  return _impl_.access_reason_.Mutable(GetArenaForAllocation());
}
inline std::string* SessionContextAccessed::release_access_reason() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.SessionContextAccessed.access_reason)
  return _impl_.access_reason_.Release();
}
inline void SessionContextAccessed::set_allocated_access_reason(std::string* access_reason) {
  if (access_reason != nullptr) {
    
  } else {
    
  }
  _impl_.access_reason_.SetAllocated(access_reason, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.access_reason_.IsDefault()) {
    _impl_.access_reason_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.SessionContextAccessed.access_reason)
}

// -------------------------------------------------------------------

// SessionHeartbeat

// .google.protobuf.Timestamp last_activity = 1;
inline bool SessionHeartbeat::_internal_has_last_activity() const {
  return this != internal_default_instance() && _impl_.last_activity_ != nullptr;
}
inline bool SessionHeartbeat::has_last_activity() const {
  return _internal_has_last_activity();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SessionHeartbeat::_internal_last_activity() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.last_activity_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SessionHeartbeat::last_activity() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.SessionHeartbeat.last_activity)
  return _internal_last_activity();
}
inline void SessionHeartbeat::unsafe_arena_set_allocated_last_activity(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_activity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_activity_);
  }
  _impl_.last_activity_ = last_activity;
  if (last_activity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.SessionHeartbeat.last_activity)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SessionHeartbeat::release_last_activity() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.last_activity_;
  _impl_.last_activity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SessionHeartbeat::unsafe_arena_release_last_activity() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.SessionHeartbeat.last_activity)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.last_activity_;
  _impl_.last_activity_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SessionHeartbeat::_internal_mutable_last_activity() {
  
  if (_impl_.last_activity_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.last_activity_ = p;
  }
  return _impl_.last_activity_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SessionHeartbeat::mutable_last_activity() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_last_activity();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.SessionHeartbeat.last_activity)
  return _msg;
}
inline void SessionHeartbeat::set_allocated_last_activity(::PROTOBUF_NAMESPACE_ID::Timestamp* last_activity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_activity_);
  }
  if (last_activity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_activity));
    if (message_arena != submessage_arena) {
      last_activity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_activity, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.last_activity_ = last_activity;
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.SessionHeartbeat.last_activity)
}

// bool is_active = 2;
inline void SessionHeartbeat::clear_is_active() {
  _impl_.is_active_ = false;
}
inline bool SessionHeartbeat::_internal_is_active() const {
  return _impl_.is_active_;
}
inline bool SessionHeartbeat::is_active() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.SessionHeartbeat.is_active)
  return _internal_is_active();
}
inline void SessionHeartbeat::_internal_set_is_active(bool value) {
  
  _impl_.is_active_ = value;
}
inline void SessionHeartbeat::set_is_active(bool value) {
  _internal_set_is_active(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.SessionHeartbeat.is_active)
}

// -------------------------------------------------------------------

// SystemEvent

// string component = 1;
inline void SystemEvent::clear_component() {
  _impl_.component_.ClearToEmpty();
}
inline const std::string& SystemEvent::component() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.SystemEvent.component)
  return _internal_component();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SystemEvent::set_component(ArgT0&& arg0, ArgT... args) {
 
 _impl_.component_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.SystemEvent.component)
}
inline std::string* SystemEvent::mutable_component() {
  std::string* _s = _internal_mutable_component();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.SystemEvent.component)
  return _s;
}
inline const std::string& SystemEvent::_internal_component() const {
  return _impl_.component_.Get();
}
inline void SystemEvent::_internal_set_component(const std::string& value) {
  
  _impl_.component_.Set(value, GetArenaForAllocation());
}
inline std::string* SystemEvent::_internal_mutable_component() {
  
  return _impl_.component_.Mutable(GetArenaForAllocation());
}
inline std::string* SystemEvent::release_component() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.SystemEvent.component)
  return _impl_.component_.Release();
}
inline void SystemEvent::set_allocated_component(std::string* component) {
  if (component != nullptr) {
    
  } else {
    
  }
  _impl_.component_.SetAllocated(component, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.component_.IsDefault()) {
    _impl_.component_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.SystemEvent.component)
}

// .unhinged.cdc.SystemEventType event_type = 2;
inline void SystemEvent::clear_event_type() {
  _impl_.event_type_ = 0;
}
inline ::unhinged::cdc::SystemEventType SystemEvent::_internal_event_type() const {
  return static_cast< ::unhinged::cdc::SystemEventType >(_impl_.event_type_);
}
inline ::unhinged::cdc::SystemEventType SystemEvent::event_type() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.SystemEvent.event_type)
  return _internal_event_type();
}
inline void SystemEvent::_internal_set_event_type(::unhinged::cdc::SystemEventType value) {
  
  _impl_.event_type_ = value;
}
inline void SystemEvent::set_event_type(::unhinged::cdc::SystemEventType value) {
  _internal_set_event_type(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.SystemEvent.event_type)
}

// .unhinged.cdc.HealthCheck health_check = 10;
inline bool SystemEvent::_internal_has_health_check() const {
  return event_data_case() == kHealthCheck;
}
inline bool SystemEvent::has_health_check() const {
  return _internal_has_health_check();
}
inline void SystemEvent::set_has_health_check() {
  _impl_._oneof_case_[0] = kHealthCheck;
}
inline void SystemEvent::clear_health_check() {
  if (_internal_has_health_check()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_data_.health_check_;
    }
    clear_has_event_data();
  }
}
inline ::unhinged::cdc::HealthCheck* SystemEvent::release_health_check() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.SystemEvent.health_check)
  if (_internal_has_health_check()) {
    clear_has_event_data();
    ::unhinged::cdc::HealthCheck* temp = _impl_.event_data_.health_check_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_data_.health_check_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::cdc::HealthCheck& SystemEvent::_internal_health_check() const {
  return _internal_has_health_check()
      ? *_impl_.event_data_.health_check_
      : reinterpret_cast< ::unhinged::cdc::HealthCheck&>(::unhinged::cdc::_HealthCheck_default_instance_);
}
inline const ::unhinged::cdc::HealthCheck& SystemEvent::health_check() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.SystemEvent.health_check)
  return _internal_health_check();
}
inline ::unhinged::cdc::HealthCheck* SystemEvent::unsafe_arena_release_health_check() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.cdc.SystemEvent.health_check)
  if (_internal_has_health_check()) {
    clear_has_event_data();
    ::unhinged::cdc::HealthCheck* temp = _impl_.event_data_.health_check_;
    _impl_.event_data_.health_check_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SystemEvent::unsafe_arena_set_allocated_health_check(::unhinged::cdc::HealthCheck* health_check) {
  clear_event_data();
  if (health_check) {
    set_has_health_check();
    _impl_.event_data_.health_check_ = health_check;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.SystemEvent.health_check)
}
inline ::unhinged::cdc::HealthCheck* SystemEvent::_internal_mutable_health_check() {
  if (!_internal_has_health_check()) {
    clear_event_data();
    set_has_health_check();
    _impl_.event_data_.health_check_ = CreateMaybeMessage< ::unhinged::cdc::HealthCheck >(GetArenaForAllocation());
  }
  return _impl_.event_data_.health_check_;
}
inline ::unhinged::cdc::HealthCheck* SystemEvent::mutable_health_check() {
  ::unhinged::cdc::HealthCheck* _msg = _internal_mutable_health_check();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.SystemEvent.health_check)
  return _msg;
}

// .unhinged.cdc.MetricReported metric = 11;
inline bool SystemEvent::_internal_has_metric() const {
  return event_data_case() == kMetric;
}
inline bool SystemEvent::has_metric() const {
  return _internal_has_metric();
}
inline void SystemEvent::set_has_metric() {
  _impl_._oneof_case_[0] = kMetric;
}
inline void SystemEvent::clear_metric() {
  if (_internal_has_metric()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_data_.metric_;
    }
    clear_has_event_data();
  }
}
inline ::unhinged::cdc::MetricReported* SystemEvent::release_metric() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.SystemEvent.metric)
  if (_internal_has_metric()) {
    clear_has_event_data();
    ::unhinged::cdc::MetricReported* temp = _impl_.event_data_.metric_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_data_.metric_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::cdc::MetricReported& SystemEvent::_internal_metric() const {
  return _internal_has_metric()
      ? *_impl_.event_data_.metric_
      : reinterpret_cast< ::unhinged::cdc::MetricReported&>(::unhinged::cdc::_MetricReported_default_instance_);
}
inline const ::unhinged::cdc::MetricReported& SystemEvent::metric() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.SystemEvent.metric)
  return _internal_metric();
}
inline ::unhinged::cdc::MetricReported* SystemEvent::unsafe_arena_release_metric() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.cdc.SystemEvent.metric)
  if (_internal_has_metric()) {
    clear_has_event_data();
    ::unhinged::cdc::MetricReported* temp = _impl_.event_data_.metric_;
    _impl_.event_data_.metric_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SystemEvent::unsafe_arena_set_allocated_metric(::unhinged::cdc::MetricReported* metric) {
  clear_event_data();
  if (metric) {
    set_has_metric();
    _impl_.event_data_.metric_ = metric;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.SystemEvent.metric)
}
inline ::unhinged::cdc::MetricReported* SystemEvent::_internal_mutable_metric() {
  if (!_internal_has_metric()) {
    clear_event_data();
    set_has_metric();
    _impl_.event_data_.metric_ = CreateMaybeMessage< ::unhinged::cdc::MetricReported >(GetArenaForAllocation());
  }
  return _impl_.event_data_.metric_;
}
inline ::unhinged::cdc::MetricReported* SystemEvent::mutable_metric() {
  ::unhinged::cdc::MetricReported* _msg = _internal_mutable_metric();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.SystemEvent.metric)
  return _msg;
}

// .unhinged.cdc.AlertTriggered alert = 12;
inline bool SystemEvent::_internal_has_alert() const {
  return event_data_case() == kAlert;
}
inline bool SystemEvent::has_alert() const {
  return _internal_has_alert();
}
inline void SystemEvent::set_has_alert() {
  _impl_._oneof_case_[0] = kAlert;
}
inline void SystemEvent::clear_alert() {
  if (_internal_has_alert()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_data_.alert_;
    }
    clear_has_event_data();
  }
}
inline ::unhinged::cdc::AlertTriggered* SystemEvent::release_alert() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.SystemEvent.alert)
  if (_internal_has_alert()) {
    clear_has_event_data();
    ::unhinged::cdc::AlertTriggered* temp = _impl_.event_data_.alert_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_data_.alert_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::cdc::AlertTriggered& SystemEvent::_internal_alert() const {
  return _internal_has_alert()
      ? *_impl_.event_data_.alert_
      : reinterpret_cast< ::unhinged::cdc::AlertTriggered&>(::unhinged::cdc::_AlertTriggered_default_instance_);
}
inline const ::unhinged::cdc::AlertTriggered& SystemEvent::alert() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.SystemEvent.alert)
  return _internal_alert();
}
inline ::unhinged::cdc::AlertTriggered* SystemEvent::unsafe_arena_release_alert() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.cdc.SystemEvent.alert)
  if (_internal_has_alert()) {
    clear_has_event_data();
    ::unhinged::cdc::AlertTriggered* temp = _impl_.event_data_.alert_;
    _impl_.event_data_.alert_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SystemEvent::unsafe_arena_set_allocated_alert(::unhinged::cdc::AlertTriggered* alert) {
  clear_event_data();
  if (alert) {
    set_has_alert();
    _impl_.event_data_.alert_ = alert;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.SystemEvent.alert)
}
inline ::unhinged::cdc::AlertTriggered* SystemEvent::_internal_mutable_alert() {
  if (!_internal_has_alert()) {
    clear_event_data();
    set_has_alert();
    _impl_.event_data_.alert_ = CreateMaybeMessage< ::unhinged::cdc::AlertTriggered >(GetArenaForAllocation());
  }
  return _impl_.event_data_.alert_;
}
inline ::unhinged::cdc::AlertTriggered* SystemEvent::mutable_alert() {
  ::unhinged::cdc::AlertTriggered* _msg = _internal_mutable_alert();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.SystemEvent.alert)
  return _msg;
}

// .unhinged.cdc.ServiceStarted service_started = 13;
inline bool SystemEvent::_internal_has_service_started() const {
  return event_data_case() == kServiceStarted;
}
inline bool SystemEvent::has_service_started() const {
  return _internal_has_service_started();
}
inline void SystemEvent::set_has_service_started() {
  _impl_._oneof_case_[0] = kServiceStarted;
}
inline void SystemEvent::clear_service_started() {
  if (_internal_has_service_started()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_data_.service_started_;
    }
    clear_has_event_data();
  }
}
inline ::unhinged::cdc::ServiceStarted* SystemEvent::release_service_started() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.SystemEvent.service_started)
  if (_internal_has_service_started()) {
    clear_has_event_data();
    ::unhinged::cdc::ServiceStarted* temp = _impl_.event_data_.service_started_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_data_.service_started_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::cdc::ServiceStarted& SystemEvent::_internal_service_started() const {
  return _internal_has_service_started()
      ? *_impl_.event_data_.service_started_
      : reinterpret_cast< ::unhinged::cdc::ServiceStarted&>(::unhinged::cdc::_ServiceStarted_default_instance_);
}
inline const ::unhinged::cdc::ServiceStarted& SystemEvent::service_started() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.SystemEvent.service_started)
  return _internal_service_started();
}
inline ::unhinged::cdc::ServiceStarted* SystemEvent::unsafe_arena_release_service_started() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.cdc.SystemEvent.service_started)
  if (_internal_has_service_started()) {
    clear_has_event_data();
    ::unhinged::cdc::ServiceStarted* temp = _impl_.event_data_.service_started_;
    _impl_.event_data_.service_started_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SystemEvent::unsafe_arena_set_allocated_service_started(::unhinged::cdc::ServiceStarted* service_started) {
  clear_event_data();
  if (service_started) {
    set_has_service_started();
    _impl_.event_data_.service_started_ = service_started;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.SystemEvent.service_started)
}
inline ::unhinged::cdc::ServiceStarted* SystemEvent::_internal_mutable_service_started() {
  if (!_internal_has_service_started()) {
    clear_event_data();
    set_has_service_started();
    _impl_.event_data_.service_started_ = CreateMaybeMessage< ::unhinged::cdc::ServiceStarted >(GetArenaForAllocation());
  }
  return _impl_.event_data_.service_started_;
}
inline ::unhinged::cdc::ServiceStarted* SystemEvent::mutable_service_started() {
  ::unhinged::cdc::ServiceStarted* _msg = _internal_mutable_service_started();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.SystemEvent.service_started)
  return _msg;
}

// .unhinged.cdc.ServiceStopped service_stopped = 14;
inline bool SystemEvent::_internal_has_service_stopped() const {
  return event_data_case() == kServiceStopped;
}
inline bool SystemEvent::has_service_stopped() const {
  return _internal_has_service_stopped();
}
inline void SystemEvent::set_has_service_stopped() {
  _impl_._oneof_case_[0] = kServiceStopped;
}
inline void SystemEvent::clear_service_stopped() {
  if (_internal_has_service_stopped()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_data_.service_stopped_;
    }
    clear_has_event_data();
  }
}
inline ::unhinged::cdc::ServiceStopped* SystemEvent::release_service_stopped() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.SystemEvent.service_stopped)
  if (_internal_has_service_stopped()) {
    clear_has_event_data();
    ::unhinged::cdc::ServiceStopped* temp = _impl_.event_data_.service_stopped_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_data_.service_stopped_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::cdc::ServiceStopped& SystemEvent::_internal_service_stopped() const {
  return _internal_has_service_stopped()
      ? *_impl_.event_data_.service_stopped_
      : reinterpret_cast< ::unhinged::cdc::ServiceStopped&>(::unhinged::cdc::_ServiceStopped_default_instance_);
}
inline const ::unhinged::cdc::ServiceStopped& SystemEvent::service_stopped() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.SystemEvent.service_stopped)
  return _internal_service_stopped();
}
inline ::unhinged::cdc::ServiceStopped* SystemEvent::unsafe_arena_release_service_stopped() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.cdc.SystemEvent.service_stopped)
  if (_internal_has_service_stopped()) {
    clear_has_event_data();
    ::unhinged::cdc::ServiceStopped* temp = _impl_.event_data_.service_stopped_;
    _impl_.event_data_.service_stopped_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SystemEvent::unsafe_arena_set_allocated_service_stopped(::unhinged::cdc::ServiceStopped* service_stopped) {
  clear_event_data();
  if (service_stopped) {
    set_has_service_stopped();
    _impl_.event_data_.service_stopped_ = service_stopped;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.SystemEvent.service_stopped)
}
inline ::unhinged::cdc::ServiceStopped* SystemEvent::_internal_mutable_service_stopped() {
  if (!_internal_has_service_stopped()) {
    clear_event_data();
    set_has_service_stopped();
    _impl_.event_data_.service_stopped_ = CreateMaybeMessage< ::unhinged::cdc::ServiceStopped >(GetArenaForAllocation());
  }
  return _impl_.event_data_.service_stopped_;
}
inline ::unhinged::cdc::ServiceStopped* SystemEvent::mutable_service_stopped() {
  ::unhinged::cdc::ServiceStopped* _msg = _internal_mutable_service_stopped();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.SystemEvent.service_stopped)
  return _msg;
}

inline bool SystemEvent::has_event_data() const {
  return event_data_case() != EVENT_DATA_NOT_SET;
}
inline void SystemEvent::clear_has_event_data() {
  _impl_._oneof_case_[0] = EVENT_DATA_NOT_SET;
}
inline SystemEvent::EventDataCase SystemEvent::event_data_case() const {
  return SystemEvent::EventDataCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// HealthCheck

// bool is_healthy = 1;
inline void HealthCheck::clear_is_healthy() {
  _impl_.is_healthy_ = false;
}
inline bool HealthCheck::_internal_is_healthy() const {
  return _impl_.is_healthy_;
}
inline bool HealthCheck::is_healthy() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.HealthCheck.is_healthy)
  return _internal_is_healthy();
}
inline void HealthCheck::_internal_set_is_healthy(bool value) {
  
  _impl_.is_healthy_ = value;
}
inline void HealthCheck::set_is_healthy(bool value) {
  _internal_set_is_healthy(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.HealthCheck.is_healthy)
}

// string status = 2;
inline void HealthCheck::clear_status() {
  _impl_.status_.ClearToEmpty();
}
inline const std::string& HealthCheck::status() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.HealthCheck.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HealthCheck::set_status(ArgT0&& arg0, ArgT... args) {
 
 _impl_.status_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.HealthCheck.status)
}
inline std::string* HealthCheck::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.HealthCheck.status)
  return _s;
}
inline const std::string& HealthCheck::_internal_status() const {
  return _impl_.status_.Get();
}
inline void HealthCheck::_internal_set_status(const std::string& value) {
  
  _impl_.status_.Set(value, GetArenaForAllocation());
}
inline std::string* HealthCheck::_internal_mutable_status() {
  
  return _impl_.status_.Mutable(GetArenaForAllocation());
}
inline std::string* HealthCheck::release_status() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.HealthCheck.status)
  return _impl_.status_.Release();
}
inline void HealthCheck::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  _impl_.status_.SetAllocated(status, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.HealthCheck.status)
}

// .google.protobuf.Struct health_details = 3;
inline bool HealthCheck::_internal_has_health_details() const {
  return this != internal_default_instance() && _impl_.health_details_ != nullptr;
}
inline bool HealthCheck::has_health_details() const {
  return _internal_has_health_details();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& HealthCheck::_internal_health_details() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.health_details_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& HealthCheck::health_details() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.HealthCheck.health_details)
  return _internal_health_details();
}
inline void HealthCheck::unsafe_arena_set_allocated_health_details(
    ::PROTOBUF_NAMESPACE_ID::Struct* health_details) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.health_details_);
  }
  _impl_.health_details_ = health_details;
  if (health_details) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.HealthCheck.health_details)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* HealthCheck::release_health_details() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.health_details_;
  _impl_.health_details_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* HealthCheck::unsafe_arena_release_health_details() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.HealthCheck.health_details)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.health_details_;
  _impl_.health_details_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* HealthCheck::_internal_mutable_health_details() {
  
  if (_impl_.health_details_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.health_details_ = p;
  }
  return _impl_.health_details_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* HealthCheck::mutable_health_details() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_health_details();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.HealthCheck.health_details)
  return _msg;
}
inline void HealthCheck::set_allocated_health_details(::PROTOBUF_NAMESPACE_ID::Struct* health_details) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.health_details_);
  }
  if (health_details) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(health_details));
    if (message_arena != submessage_arena) {
      health_details = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, health_details, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.health_details_ = health_details;
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.HealthCheck.health_details)
}

// -------------------------------------------------------------------

// MetricReported

// string metric_name = 1;
inline void MetricReported::clear_metric_name() {
  _impl_.metric_name_.ClearToEmpty();
}
inline const std::string& MetricReported::metric_name() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.MetricReported.metric_name)
  return _internal_metric_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MetricReported::set_metric_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.metric_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.MetricReported.metric_name)
}
inline std::string* MetricReported::mutable_metric_name() {
  std::string* _s = _internal_mutable_metric_name();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.MetricReported.metric_name)
  return _s;
}
inline const std::string& MetricReported::_internal_metric_name() const {
  return _impl_.metric_name_.Get();
}
inline void MetricReported::_internal_set_metric_name(const std::string& value) {
  
  _impl_.metric_name_.Set(value, GetArenaForAllocation());
}
inline std::string* MetricReported::_internal_mutable_metric_name() {
  
  return _impl_.metric_name_.Mutable(GetArenaForAllocation());
}
inline std::string* MetricReported::release_metric_name() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.MetricReported.metric_name)
  return _impl_.metric_name_.Release();
}
inline void MetricReported::set_allocated_metric_name(std::string* metric_name) {
  if (metric_name != nullptr) {
    
  } else {
    
  }
  _impl_.metric_name_.SetAllocated(metric_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.metric_name_.IsDefault()) {
    _impl_.metric_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.MetricReported.metric_name)
}

// double metric_value = 2;
inline void MetricReported::clear_metric_value() {
  _impl_.metric_value_ = 0;
}
inline double MetricReported::_internal_metric_value() const {
  return _impl_.metric_value_;
}
inline double MetricReported::metric_value() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.MetricReported.metric_value)
  return _internal_metric_value();
}
inline void MetricReported::_internal_set_metric_value(double value) {
  
  _impl_.metric_value_ = value;
}
inline void MetricReported::set_metric_value(double value) {
  _internal_set_metric_value(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.MetricReported.metric_value)
}

// string metric_unit = 3;
inline void MetricReported::clear_metric_unit() {
  _impl_.metric_unit_.ClearToEmpty();
}
inline const std::string& MetricReported::metric_unit() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.MetricReported.metric_unit)
  return _internal_metric_unit();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MetricReported::set_metric_unit(ArgT0&& arg0, ArgT... args) {
 
 _impl_.metric_unit_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.MetricReported.metric_unit)
}
inline std::string* MetricReported::mutable_metric_unit() {
  std::string* _s = _internal_mutable_metric_unit();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.MetricReported.metric_unit)
  return _s;
}
inline const std::string& MetricReported::_internal_metric_unit() const {
  return _impl_.metric_unit_.Get();
}
inline void MetricReported::_internal_set_metric_unit(const std::string& value) {
  
  _impl_.metric_unit_.Set(value, GetArenaForAllocation());
}
inline std::string* MetricReported::_internal_mutable_metric_unit() {
  
  return _impl_.metric_unit_.Mutable(GetArenaForAllocation());
}
inline std::string* MetricReported::release_metric_unit() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.MetricReported.metric_unit)
  return _impl_.metric_unit_.Release();
}
inline void MetricReported::set_allocated_metric_unit(std::string* metric_unit) {
  if (metric_unit != nullptr) {
    
  } else {
    
  }
  _impl_.metric_unit_.SetAllocated(metric_unit, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.metric_unit_.IsDefault()) {
    _impl_.metric_unit_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.MetricReported.metric_unit)
}

// .google.protobuf.Struct metric_tags = 4;
inline bool MetricReported::_internal_has_metric_tags() const {
  return this != internal_default_instance() && _impl_.metric_tags_ != nullptr;
}
inline bool MetricReported::has_metric_tags() const {
  return _internal_has_metric_tags();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& MetricReported::_internal_metric_tags() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.metric_tags_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& MetricReported::metric_tags() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.MetricReported.metric_tags)
  return _internal_metric_tags();
}
inline void MetricReported::unsafe_arena_set_allocated_metric_tags(
    ::PROTOBUF_NAMESPACE_ID::Struct* metric_tags) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metric_tags_);
  }
  _impl_.metric_tags_ = metric_tags;
  if (metric_tags) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.MetricReported.metric_tags)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* MetricReported::release_metric_tags() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.metric_tags_;
  _impl_.metric_tags_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* MetricReported::unsafe_arena_release_metric_tags() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.MetricReported.metric_tags)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.metric_tags_;
  _impl_.metric_tags_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* MetricReported::_internal_mutable_metric_tags() {
  
  if (_impl_.metric_tags_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.metric_tags_ = p;
  }
  return _impl_.metric_tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* MetricReported::mutable_metric_tags() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_metric_tags();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.MetricReported.metric_tags)
  return _msg;
}
inline void MetricReported::set_allocated_metric_tags(::PROTOBUF_NAMESPACE_ID::Struct* metric_tags) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metric_tags_);
  }
  if (metric_tags) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metric_tags));
    if (message_arena != submessage_arena) {
      metric_tags = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metric_tags, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.metric_tags_ = metric_tags;
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.MetricReported.metric_tags)
}

// -------------------------------------------------------------------

// AlertTriggered

// string alert_name = 1;
inline void AlertTriggered::clear_alert_name() {
  _impl_.alert_name_.ClearToEmpty();
}
inline const std::string& AlertTriggered::alert_name() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.AlertTriggered.alert_name)
  return _internal_alert_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AlertTriggered::set_alert_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.alert_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.AlertTriggered.alert_name)
}
inline std::string* AlertTriggered::mutable_alert_name() {
  std::string* _s = _internal_mutable_alert_name();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.AlertTriggered.alert_name)
  return _s;
}
inline const std::string& AlertTriggered::_internal_alert_name() const {
  return _impl_.alert_name_.Get();
}
inline void AlertTriggered::_internal_set_alert_name(const std::string& value) {
  
  _impl_.alert_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AlertTriggered::_internal_mutable_alert_name() {
  
  return _impl_.alert_name_.Mutable(GetArenaForAllocation());
}
inline std::string* AlertTriggered::release_alert_name() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.AlertTriggered.alert_name)
  return _impl_.alert_name_.Release();
}
inline void AlertTriggered::set_allocated_alert_name(std::string* alert_name) {
  if (alert_name != nullptr) {
    
  } else {
    
  }
  _impl_.alert_name_.SetAllocated(alert_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.alert_name_.IsDefault()) {
    _impl_.alert_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.AlertTriggered.alert_name)
}

// string severity = 2;
inline void AlertTriggered::clear_severity() {
  _impl_.severity_.ClearToEmpty();
}
inline const std::string& AlertTriggered::severity() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.AlertTriggered.severity)
  return _internal_severity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AlertTriggered::set_severity(ArgT0&& arg0, ArgT... args) {
 
 _impl_.severity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.AlertTriggered.severity)
}
inline std::string* AlertTriggered::mutable_severity() {
  std::string* _s = _internal_mutable_severity();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.AlertTriggered.severity)
  return _s;
}
inline const std::string& AlertTriggered::_internal_severity() const {
  return _impl_.severity_.Get();
}
inline void AlertTriggered::_internal_set_severity(const std::string& value) {
  
  _impl_.severity_.Set(value, GetArenaForAllocation());
}
inline std::string* AlertTriggered::_internal_mutable_severity() {
  
  return _impl_.severity_.Mutable(GetArenaForAllocation());
}
inline std::string* AlertTriggered::release_severity() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.AlertTriggered.severity)
  return _impl_.severity_.Release();
}
inline void AlertTriggered::set_allocated_severity(std::string* severity) {
  if (severity != nullptr) {
    
  } else {
    
  }
  _impl_.severity_.SetAllocated(severity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.severity_.IsDefault()) {
    _impl_.severity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.AlertTriggered.severity)
}

// string description = 3;
inline void AlertTriggered::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& AlertTriggered::description() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.AlertTriggered.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AlertTriggered::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.AlertTriggered.description)
}
inline std::string* AlertTriggered::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.AlertTriggered.description)
  return _s;
}
inline const std::string& AlertTriggered::_internal_description() const {
  return _impl_.description_.Get();
}
inline void AlertTriggered::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* AlertTriggered::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* AlertTriggered::release_description() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.AlertTriggered.description)
  return _impl_.description_.Release();
}
inline void AlertTriggered::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.AlertTriggered.description)
}

// .google.protobuf.Struct alert_context = 4;
inline bool AlertTriggered::_internal_has_alert_context() const {
  return this != internal_default_instance() && _impl_.alert_context_ != nullptr;
}
inline bool AlertTriggered::has_alert_context() const {
  return _internal_has_alert_context();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& AlertTriggered::_internal_alert_context() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.alert_context_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& AlertTriggered::alert_context() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.AlertTriggered.alert_context)
  return _internal_alert_context();
}
inline void AlertTriggered::unsafe_arena_set_allocated_alert_context(
    ::PROTOBUF_NAMESPACE_ID::Struct* alert_context) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.alert_context_);
  }
  _impl_.alert_context_ = alert_context;
  if (alert_context) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.AlertTriggered.alert_context)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AlertTriggered::release_alert_context() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.alert_context_;
  _impl_.alert_context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AlertTriggered::unsafe_arena_release_alert_context() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.AlertTriggered.alert_context)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.alert_context_;
  _impl_.alert_context_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AlertTriggered::_internal_mutable_alert_context() {
  
  if (_impl_.alert_context_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.alert_context_ = p;
  }
  return _impl_.alert_context_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AlertTriggered::mutable_alert_context() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_alert_context();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.AlertTriggered.alert_context)
  return _msg;
}
inline void AlertTriggered::set_allocated_alert_context(::PROTOBUF_NAMESPACE_ID::Struct* alert_context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.alert_context_);
  }
  if (alert_context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(alert_context));
    if (message_arena != submessage_arena) {
      alert_context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, alert_context, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.alert_context_ = alert_context;
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.AlertTriggered.alert_context)
}

// -------------------------------------------------------------------

// ServiceStarted

// string service_name = 1;
inline void ServiceStarted::clear_service_name() {
  _impl_.service_name_.ClearToEmpty();
}
inline const std::string& ServiceStarted::service_name() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.ServiceStarted.service_name)
  return _internal_service_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceStarted::set_service_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.ServiceStarted.service_name)
}
inline std::string* ServiceStarted::mutable_service_name() {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.ServiceStarted.service_name)
  return _s;
}
inline const std::string& ServiceStarted::_internal_service_name() const {
  return _impl_.service_name_.Get();
}
inline void ServiceStarted::_internal_set_service_name(const std::string& value) {
  
  _impl_.service_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceStarted::_internal_mutable_service_name() {
  
  return _impl_.service_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ServiceStarted::release_service_name() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.ServiceStarted.service_name)
  return _impl_.service_name_.Release();
}
inline void ServiceStarted::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  _impl_.service_name_.SetAllocated(service_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_name_.IsDefault()) {
    _impl_.service_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.ServiceStarted.service_name)
}

// string service_version = 2;
inline void ServiceStarted::clear_service_version() {
  _impl_.service_version_.ClearToEmpty();
}
inline const std::string& ServiceStarted::service_version() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.ServiceStarted.service_version)
  return _internal_service_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceStarted::set_service_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.ServiceStarted.service_version)
}
inline std::string* ServiceStarted::mutable_service_version() {
  std::string* _s = _internal_mutable_service_version();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.ServiceStarted.service_version)
  return _s;
}
inline const std::string& ServiceStarted::_internal_service_version() const {
  return _impl_.service_version_.Get();
}
inline void ServiceStarted::_internal_set_service_version(const std::string& value) {
  
  _impl_.service_version_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceStarted::_internal_mutable_service_version() {
  
  return _impl_.service_version_.Mutable(GetArenaForAllocation());
}
inline std::string* ServiceStarted::release_service_version() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.ServiceStarted.service_version)
  return _impl_.service_version_.Release();
}
inline void ServiceStarted::set_allocated_service_version(std::string* service_version) {
  if (service_version != nullptr) {
    
  } else {
    
  }
  _impl_.service_version_.SetAllocated(service_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_version_.IsDefault()) {
    _impl_.service_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.ServiceStarted.service_version)
}

// string build_info = 3;
inline void ServiceStarted::clear_build_info() {
  _impl_.build_info_.ClearToEmpty();
}
inline const std::string& ServiceStarted::build_info() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.ServiceStarted.build_info)
  return _internal_build_info();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceStarted::set_build_info(ArgT0&& arg0, ArgT... args) {
 
 _impl_.build_info_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.ServiceStarted.build_info)
}
inline std::string* ServiceStarted::mutable_build_info() {
  std::string* _s = _internal_mutable_build_info();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.ServiceStarted.build_info)
  return _s;
}
inline const std::string& ServiceStarted::_internal_build_info() const {
  return _impl_.build_info_.Get();
}
inline void ServiceStarted::_internal_set_build_info(const std::string& value) {
  
  _impl_.build_info_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceStarted::_internal_mutable_build_info() {
  
  return _impl_.build_info_.Mutable(GetArenaForAllocation());
}
inline std::string* ServiceStarted::release_build_info() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.ServiceStarted.build_info)
  return _impl_.build_info_.Release();
}
inline void ServiceStarted::set_allocated_build_info(std::string* build_info) {
  if (build_info != nullptr) {
    
  } else {
    
  }
  _impl_.build_info_.SetAllocated(build_info, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.build_info_.IsDefault()) {
    _impl_.build_info_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.ServiceStarted.build_info)
}

// -------------------------------------------------------------------

// ServiceStopped

// string service_name = 1;
inline void ServiceStopped::clear_service_name() {
  _impl_.service_name_.ClearToEmpty();
}
inline const std::string& ServiceStopped::service_name() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.ServiceStopped.service_name)
  return _internal_service_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceStopped::set_service_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.ServiceStopped.service_name)
}
inline std::string* ServiceStopped::mutable_service_name() {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.ServiceStopped.service_name)
  return _s;
}
inline const std::string& ServiceStopped::_internal_service_name() const {
  return _impl_.service_name_.Get();
}
inline void ServiceStopped::_internal_set_service_name(const std::string& value) {
  
  _impl_.service_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceStopped::_internal_mutable_service_name() {
  
  return _impl_.service_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ServiceStopped::release_service_name() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.ServiceStopped.service_name)
  return _impl_.service_name_.Release();
}
inline void ServiceStopped::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  _impl_.service_name_.SetAllocated(service_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_name_.IsDefault()) {
    _impl_.service_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.ServiceStopped.service_name)
}

// string stop_reason = 2;
inline void ServiceStopped::clear_stop_reason() {
  _impl_.stop_reason_.ClearToEmpty();
}
inline const std::string& ServiceStopped::stop_reason() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.ServiceStopped.stop_reason)
  return _internal_stop_reason();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceStopped::set_stop_reason(ArgT0&& arg0, ArgT... args) {
 
 _impl_.stop_reason_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.ServiceStopped.stop_reason)
}
inline std::string* ServiceStopped::mutable_stop_reason() {
  std::string* _s = _internal_mutable_stop_reason();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.ServiceStopped.stop_reason)
  return _s;
}
inline const std::string& ServiceStopped::_internal_stop_reason() const {
  return _impl_.stop_reason_.Get();
}
inline void ServiceStopped::_internal_set_stop_reason(const std::string& value) {
  
  _impl_.stop_reason_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceStopped::_internal_mutable_stop_reason() {
  
  return _impl_.stop_reason_.Mutable(GetArenaForAllocation());
}
inline std::string* ServiceStopped::release_stop_reason() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.ServiceStopped.stop_reason)
  return _impl_.stop_reason_.Release();
}
inline void ServiceStopped::set_allocated_stop_reason(std::string* stop_reason) {
  if (stop_reason != nullptr) {
    
  } else {
    
  }
  _impl_.stop_reason_.SetAllocated(stop_reason, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stop_reason_.IsDefault()) {
    _impl_.stop_reason_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.ServiceStopped.stop_reason)
}

// float uptime_ms = 3;
inline void ServiceStopped::clear_uptime_ms() {
  _impl_.uptime_ms_ = 0;
}
inline float ServiceStopped::_internal_uptime_ms() const {
  return _impl_.uptime_ms_;
}
inline float ServiceStopped::uptime_ms() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.ServiceStopped.uptime_ms)
  return _internal_uptime_ms();
}
inline void ServiceStopped::_internal_set_uptime_ms(float value) {
  
  _impl_.uptime_ms_ = value;
}
inline void ServiceStopped::set_uptime_ms(float value) {
  _internal_set_uptime_ms(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.ServiceStopped.uptime_ms)
}

// -------------------------------------------------------------------

// WorkflowEvent

// string workflow_id = 1;
inline void WorkflowEvent::clear_workflow_id() {
  _impl_.workflow_id_.ClearToEmpty();
}
inline const std::string& WorkflowEvent::workflow_id() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.WorkflowEvent.workflow_id)
  return _internal_workflow_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WorkflowEvent::set_workflow_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.workflow_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.WorkflowEvent.workflow_id)
}
inline std::string* WorkflowEvent::mutable_workflow_id() {
  std::string* _s = _internal_mutable_workflow_id();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.WorkflowEvent.workflow_id)
  return _s;
}
inline const std::string& WorkflowEvent::_internal_workflow_id() const {
  return _impl_.workflow_id_.Get();
}
inline void WorkflowEvent::_internal_set_workflow_id(const std::string& value) {
  
  _impl_.workflow_id_.Set(value, GetArenaForAllocation());
}
inline std::string* WorkflowEvent::_internal_mutable_workflow_id() {
  
  return _impl_.workflow_id_.Mutable(GetArenaForAllocation());
}
inline std::string* WorkflowEvent::release_workflow_id() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.WorkflowEvent.workflow_id)
  return _impl_.workflow_id_.Release();
}
inline void WorkflowEvent::set_allocated_workflow_id(std::string* workflow_id) {
  if (workflow_id != nullptr) {
    
  } else {
    
  }
  _impl_.workflow_id_.SetAllocated(workflow_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.workflow_id_.IsDefault()) {
    _impl_.workflow_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.WorkflowEvent.workflow_id)
}

// string workflow_type = 2;
inline void WorkflowEvent::clear_workflow_type() {
  _impl_.workflow_type_.ClearToEmpty();
}
inline const std::string& WorkflowEvent::workflow_type() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.WorkflowEvent.workflow_type)
  return _internal_workflow_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WorkflowEvent::set_workflow_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.workflow_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.WorkflowEvent.workflow_type)
}
inline std::string* WorkflowEvent::mutable_workflow_type() {
  std::string* _s = _internal_mutable_workflow_type();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.WorkflowEvent.workflow_type)
  return _s;
}
inline const std::string& WorkflowEvent::_internal_workflow_type() const {
  return _impl_.workflow_type_.Get();
}
inline void WorkflowEvent::_internal_set_workflow_type(const std::string& value) {
  
  _impl_.workflow_type_.Set(value, GetArenaForAllocation());
}
inline std::string* WorkflowEvent::_internal_mutable_workflow_type() {
  
  return _impl_.workflow_type_.Mutable(GetArenaForAllocation());
}
inline std::string* WorkflowEvent::release_workflow_type() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.WorkflowEvent.workflow_type)
  return _impl_.workflow_type_.Release();
}
inline void WorkflowEvent::set_allocated_workflow_type(std::string* workflow_type) {
  if (workflow_type != nullptr) {
    
  } else {
    
  }
  _impl_.workflow_type_.SetAllocated(workflow_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.workflow_type_.IsDefault()) {
    _impl_.workflow_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.WorkflowEvent.workflow_type)
}

// string execution_id = 3;
inline void WorkflowEvent::clear_execution_id() {
  _impl_.execution_id_.ClearToEmpty();
}
inline const std::string& WorkflowEvent::execution_id() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.WorkflowEvent.execution_id)
  return _internal_execution_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WorkflowEvent::set_execution_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.execution_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.WorkflowEvent.execution_id)
}
inline std::string* WorkflowEvent::mutable_execution_id() {
  std::string* _s = _internal_mutable_execution_id();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.WorkflowEvent.execution_id)
  return _s;
}
inline const std::string& WorkflowEvent::_internal_execution_id() const {
  return _impl_.execution_id_.Get();
}
inline void WorkflowEvent::_internal_set_execution_id(const std::string& value) {
  
  _impl_.execution_id_.Set(value, GetArenaForAllocation());
}
inline std::string* WorkflowEvent::_internal_mutable_execution_id() {
  
  return _impl_.execution_id_.Mutable(GetArenaForAllocation());
}
inline std::string* WorkflowEvent::release_execution_id() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.WorkflowEvent.execution_id)
  return _impl_.execution_id_.Release();
}
inline void WorkflowEvent::set_allocated_execution_id(std::string* execution_id) {
  if (execution_id != nullptr) {
    
  } else {
    
  }
  _impl_.execution_id_.SetAllocated(execution_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.execution_id_.IsDefault()) {
    _impl_.execution_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.WorkflowEvent.execution_id)
}

// .unhinged.cdc.WorkflowEventType event_type = 4;
inline void WorkflowEvent::clear_event_type() {
  _impl_.event_type_ = 0;
}
inline ::unhinged::cdc::WorkflowEventType WorkflowEvent::_internal_event_type() const {
  return static_cast< ::unhinged::cdc::WorkflowEventType >(_impl_.event_type_);
}
inline ::unhinged::cdc::WorkflowEventType WorkflowEvent::event_type() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.WorkflowEvent.event_type)
  return _internal_event_type();
}
inline void WorkflowEvent::_internal_set_event_type(::unhinged::cdc::WorkflowEventType value) {
  
  _impl_.event_type_ = value;
}
inline void WorkflowEvent::set_event_type(::unhinged::cdc::WorkflowEventType value) {
  _internal_set_event_type(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.WorkflowEvent.event_type)
}

// .unhinged.cdc.WorkflowTriggered triggered = 10;
inline bool WorkflowEvent::_internal_has_triggered() const {
  return event_data_case() == kTriggered;
}
inline bool WorkflowEvent::has_triggered() const {
  return _internal_has_triggered();
}
inline void WorkflowEvent::set_has_triggered() {
  _impl_._oneof_case_[0] = kTriggered;
}
inline void WorkflowEvent::clear_triggered() {
  if (_internal_has_triggered()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_data_.triggered_;
    }
    clear_has_event_data();
  }
}
inline ::unhinged::cdc::WorkflowTriggered* WorkflowEvent::release_triggered() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.WorkflowEvent.triggered)
  if (_internal_has_triggered()) {
    clear_has_event_data();
    ::unhinged::cdc::WorkflowTriggered* temp = _impl_.event_data_.triggered_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_data_.triggered_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::cdc::WorkflowTriggered& WorkflowEvent::_internal_triggered() const {
  return _internal_has_triggered()
      ? *_impl_.event_data_.triggered_
      : reinterpret_cast< ::unhinged::cdc::WorkflowTriggered&>(::unhinged::cdc::_WorkflowTriggered_default_instance_);
}
inline const ::unhinged::cdc::WorkflowTriggered& WorkflowEvent::triggered() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.WorkflowEvent.triggered)
  return _internal_triggered();
}
inline ::unhinged::cdc::WorkflowTriggered* WorkflowEvent::unsafe_arena_release_triggered() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.cdc.WorkflowEvent.triggered)
  if (_internal_has_triggered()) {
    clear_has_event_data();
    ::unhinged::cdc::WorkflowTriggered* temp = _impl_.event_data_.triggered_;
    _impl_.event_data_.triggered_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WorkflowEvent::unsafe_arena_set_allocated_triggered(::unhinged::cdc::WorkflowTriggered* triggered) {
  clear_event_data();
  if (triggered) {
    set_has_triggered();
    _impl_.event_data_.triggered_ = triggered;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.WorkflowEvent.triggered)
}
inline ::unhinged::cdc::WorkflowTriggered* WorkflowEvent::_internal_mutable_triggered() {
  if (!_internal_has_triggered()) {
    clear_event_data();
    set_has_triggered();
    _impl_.event_data_.triggered_ = CreateMaybeMessage< ::unhinged::cdc::WorkflowTriggered >(GetArenaForAllocation());
  }
  return _impl_.event_data_.triggered_;
}
inline ::unhinged::cdc::WorkflowTriggered* WorkflowEvent::mutable_triggered() {
  ::unhinged::cdc::WorkflowTriggered* _msg = _internal_mutable_triggered();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.WorkflowEvent.triggered)
  return _msg;
}

// .unhinged.cdc.WorkflowStepExecuted step_executed = 11;
inline bool WorkflowEvent::_internal_has_step_executed() const {
  return event_data_case() == kStepExecuted;
}
inline bool WorkflowEvent::has_step_executed() const {
  return _internal_has_step_executed();
}
inline void WorkflowEvent::set_has_step_executed() {
  _impl_._oneof_case_[0] = kStepExecuted;
}
inline void WorkflowEvent::clear_step_executed() {
  if (_internal_has_step_executed()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_data_.step_executed_;
    }
    clear_has_event_data();
  }
}
inline ::unhinged::cdc::WorkflowStepExecuted* WorkflowEvent::release_step_executed() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.WorkflowEvent.step_executed)
  if (_internal_has_step_executed()) {
    clear_has_event_data();
    ::unhinged::cdc::WorkflowStepExecuted* temp = _impl_.event_data_.step_executed_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_data_.step_executed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::cdc::WorkflowStepExecuted& WorkflowEvent::_internal_step_executed() const {
  return _internal_has_step_executed()
      ? *_impl_.event_data_.step_executed_
      : reinterpret_cast< ::unhinged::cdc::WorkflowStepExecuted&>(::unhinged::cdc::_WorkflowStepExecuted_default_instance_);
}
inline const ::unhinged::cdc::WorkflowStepExecuted& WorkflowEvent::step_executed() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.WorkflowEvent.step_executed)
  return _internal_step_executed();
}
inline ::unhinged::cdc::WorkflowStepExecuted* WorkflowEvent::unsafe_arena_release_step_executed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.cdc.WorkflowEvent.step_executed)
  if (_internal_has_step_executed()) {
    clear_has_event_data();
    ::unhinged::cdc::WorkflowStepExecuted* temp = _impl_.event_data_.step_executed_;
    _impl_.event_data_.step_executed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WorkflowEvent::unsafe_arena_set_allocated_step_executed(::unhinged::cdc::WorkflowStepExecuted* step_executed) {
  clear_event_data();
  if (step_executed) {
    set_has_step_executed();
    _impl_.event_data_.step_executed_ = step_executed;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.WorkflowEvent.step_executed)
}
inline ::unhinged::cdc::WorkflowStepExecuted* WorkflowEvent::_internal_mutable_step_executed() {
  if (!_internal_has_step_executed()) {
    clear_event_data();
    set_has_step_executed();
    _impl_.event_data_.step_executed_ = CreateMaybeMessage< ::unhinged::cdc::WorkflowStepExecuted >(GetArenaForAllocation());
  }
  return _impl_.event_data_.step_executed_;
}
inline ::unhinged::cdc::WorkflowStepExecuted* WorkflowEvent::mutable_step_executed() {
  ::unhinged::cdc::WorkflowStepExecuted* _msg = _internal_mutable_step_executed();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.WorkflowEvent.step_executed)
  return _msg;
}

// .unhinged.cdc.WorkflowCompleted completed = 12;
inline bool WorkflowEvent::_internal_has_completed() const {
  return event_data_case() == kCompleted;
}
inline bool WorkflowEvent::has_completed() const {
  return _internal_has_completed();
}
inline void WorkflowEvent::set_has_completed() {
  _impl_._oneof_case_[0] = kCompleted;
}
inline void WorkflowEvent::clear_completed() {
  if (_internal_has_completed()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_data_.completed_;
    }
    clear_has_event_data();
  }
}
inline ::unhinged::cdc::WorkflowCompleted* WorkflowEvent::release_completed() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.WorkflowEvent.completed)
  if (_internal_has_completed()) {
    clear_has_event_data();
    ::unhinged::cdc::WorkflowCompleted* temp = _impl_.event_data_.completed_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_data_.completed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::cdc::WorkflowCompleted& WorkflowEvent::_internal_completed() const {
  return _internal_has_completed()
      ? *_impl_.event_data_.completed_
      : reinterpret_cast< ::unhinged::cdc::WorkflowCompleted&>(::unhinged::cdc::_WorkflowCompleted_default_instance_);
}
inline const ::unhinged::cdc::WorkflowCompleted& WorkflowEvent::completed() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.WorkflowEvent.completed)
  return _internal_completed();
}
inline ::unhinged::cdc::WorkflowCompleted* WorkflowEvent::unsafe_arena_release_completed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.cdc.WorkflowEvent.completed)
  if (_internal_has_completed()) {
    clear_has_event_data();
    ::unhinged::cdc::WorkflowCompleted* temp = _impl_.event_data_.completed_;
    _impl_.event_data_.completed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WorkflowEvent::unsafe_arena_set_allocated_completed(::unhinged::cdc::WorkflowCompleted* completed) {
  clear_event_data();
  if (completed) {
    set_has_completed();
    _impl_.event_data_.completed_ = completed;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.WorkflowEvent.completed)
}
inline ::unhinged::cdc::WorkflowCompleted* WorkflowEvent::_internal_mutable_completed() {
  if (!_internal_has_completed()) {
    clear_event_data();
    set_has_completed();
    _impl_.event_data_.completed_ = CreateMaybeMessage< ::unhinged::cdc::WorkflowCompleted >(GetArenaForAllocation());
  }
  return _impl_.event_data_.completed_;
}
inline ::unhinged::cdc::WorkflowCompleted* WorkflowEvent::mutable_completed() {
  ::unhinged::cdc::WorkflowCompleted* _msg = _internal_mutable_completed();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.WorkflowEvent.completed)
  return _msg;
}

// .unhinged.cdc.WorkflowFailed failed = 13;
inline bool WorkflowEvent::_internal_has_failed() const {
  return event_data_case() == kFailed;
}
inline bool WorkflowEvent::has_failed() const {
  return _internal_has_failed();
}
inline void WorkflowEvent::set_has_failed() {
  _impl_._oneof_case_[0] = kFailed;
}
inline void WorkflowEvent::clear_failed() {
  if (_internal_has_failed()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_data_.failed_;
    }
    clear_has_event_data();
  }
}
inline ::unhinged::cdc::WorkflowFailed* WorkflowEvent::release_failed() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.WorkflowEvent.failed)
  if (_internal_has_failed()) {
    clear_has_event_data();
    ::unhinged::cdc::WorkflowFailed* temp = _impl_.event_data_.failed_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_data_.failed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::cdc::WorkflowFailed& WorkflowEvent::_internal_failed() const {
  return _internal_has_failed()
      ? *_impl_.event_data_.failed_
      : reinterpret_cast< ::unhinged::cdc::WorkflowFailed&>(::unhinged::cdc::_WorkflowFailed_default_instance_);
}
inline const ::unhinged::cdc::WorkflowFailed& WorkflowEvent::failed() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.WorkflowEvent.failed)
  return _internal_failed();
}
inline ::unhinged::cdc::WorkflowFailed* WorkflowEvent::unsafe_arena_release_failed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.cdc.WorkflowEvent.failed)
  if (_internal_has_failed()) {
    clear_has_event_data();
    ::unhinged::cdc::WorkflowFailed* temp = _impl_.event_data_.failed_;
    _impl_.event_data_.failed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WorkflowEvent::unsafe_arena_set_allocated_failed(::unhinged::cdc::WorkflowFailed* failed) {
  clear_event_data();
  if (failed) {
    set_has_failed();
    _impl_.event_data_.failed_ = failed;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.WorkflowEvent.failed)
}
inline ::unhinged::cdc::WorkflowFailed* WorkflowEvent::_internal_mutable_failed() {
  if (!_internal_has_failed()) {
    clear_event_data();
    set_has_failed();
    _impl_.event_data_.failed_ = CreateMaybeMessage< ::unhinged::cdc::WorkflowFailed >(GetArenaForAllocation());
  }
  return _impl_.event_data_.failed_;
}
inline ::unhinged::cdc::WorkflowFailed* WorkflowEvent::mutable_failed() {
  ::unhinged::cdc::WorkflowFailed* _msg = _internal_mutable_failed();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.WorkflowEvent.failed)
  return _msg;
}

inline bool WorkflowEvent::has_event_data() const {
  return event_data_case() != EVENT_DATA_NOT_SET;
}
inline void WorkflowEvent::clear_has_event_data() {
  _impl_._oneof_case_[0] = EVENT_DATA_NOT_SET;
}
inline WorkflowEvent::EventDataCase WorkflowEvent::event_data_case() const {
  return WorkflowEvent::EventDataCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// WorkflowTriggered

// string trigger_event_id = 1;
inline void WorkflowTriggered::clear_trigger_event_id() {
  _impl_.trigger_event_id_.ClearToEmpty();
}
inline const std::string& WorkflowTriggered::trigger_event_id() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.WorkflowTriggered.trigger_event_id)
  return _internal_trigger_event_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WorkflowTriggered::set_trigger_event_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.trigger_event_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.WorkflowTriggered.trigger_event_id)
}
inline std::string* WorkflowTriggered::mutable_trigger_event_id() {
  std::string* _s = _internal_mutable_trigger_event_id();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.WorkflowTriggered.trigger_event_id)
  return _s;
}
inline const std::string& WorkflowTriggered::_internal_trigger_event_id() const {
  return _impl_.trigger_event_id_.Get();
}
inline void WorkflowTriggered::_internal_set_trigger_event_id(const std::string& value) {
  
  _impl_.trigger_event_id_.Set(value, GetArenaForAllocation());
}
inline std::string* WorkflowTriggered::_internal_mutable_trigger_event_id() {
  
  return _impl_.trigger_event_id_.Mutable(GetArenaForAllocation());
}
inline std::string* WorkflowTriggered::release_trigger_event_id() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.WorkflowTriggered.trigger_event_id)
  return _impl_.trigger_event_id_.Release();
}
inline void WorkflowTriggered::set_allocated_trigger_event_id(std::string* trigger_event_id) {
  if (trigger_event_id != nullptr) {
    
  } else {
    
  }
  _impl_.trigger_event_id_.SetAllocated(trigger_event_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.trigger_event_id_.IsDefault()) {
    _impl_.trigger_event_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.WorkflowTriggered.trigger_event_id)
}

// string trigger_type = 2;
inline void WorkflowTriggered::clear_trigger_type() {
  _impl_.trigger_type_.ClearToEmpty();
}
inline const std::string& WorkflowTriggered::trigger_type() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.WorkflowTriggered.trigger_type)
  return _internal_trigger_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WorkflowTriggered::set_trigger_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.trigger_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.WorkflowTriggered.trigger_type)
}
inline std::string* WorkflowTriggered::mutable_trigger_type() {
  std::string* _s = _internal_mutable_trigger_type();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.WorkflowTriggered.trigger_type)
  return _s;
}
inline const std::string& WorkflowTriggered::_internal_trigger_type() const {
  return _impl_.trigger_type_.Get();
}
inline void WorkflowTriggered::_internal_set_trigger_type(const std::string& value) {
  
  _impl_.trigger_type_.Set(value, GetArenaForAllocation());
}
inline std::string* WorkflowTriggered::_internal_mutable_trigger_type() {
  
  return _impl_.trigger_type_.Mutable(GetArenaForAllocation());
}
inline std::string* WorkflowTriggered::release_trigger_type() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.WorkflowTriggered.trigger_type)
  return _impl_.trigger_type_.Release();
}
inline void WorkflowTriggered::set_allocated_trigger_type(std::string* trigger_type) {
  if (trigger_type != nullptr) {
    
  } else {
    
  }
  _impl_.trigger_type_.SetAllocated(trigger_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.trigger_type_.IsDefault()) {
    _impl_.trigger_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.WorkflowTriggered.trigger_type)
}

// .google.protobuf.Struct trigger_context = 3;
inline bool WorkflowTriggered::_internal_has_trigger_context() const {
  return this != internal_default_instance() && _impl_.trigger_context_ != nullptr;
}
inline bool WorkflowTriggered::has_trigger_context() const {
  return _internal_has_trigger_context();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& WorkflowTriggered::_internal_trigger_context() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.trigger_context_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& WorkflowTriggered::trigger_context() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.WorkflowTriggered.trigger_context)
  return _internal_trigger_context();
}
inline void WorkflowTriggered::unsafe_arena_set_allocated_trigger_context(
    ::PROTOBUF_NAMESPACE_ID::Struct* trigger_context) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.trigger_context_);
  }
  _impl_.trigger_context_ = trigger_context;
  if (trigger_context) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.WorkflowTriggered.trigger_context)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* WorkflowTriggered::release_trigger_context() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.trigger_context_;
  _impl_.trigger_context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* WorkflowTriggered::unsafe_arena_release_trigger_context() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.WorkflowTriggered.trigger_context)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.trigger_context_;
  _impl_.trigger_context_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* WorkflowTriggered::_internal_mutable_trigger_context() {
  
  if (_impl_.trigger_context_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.trigger_context_ = p;
  }
  return _impl_.trigger_context_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* WorkflowTriggered::mutable_trigger_context() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_trigger_context();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.WorkflowTriggered.trigger_context)
  return _msg;
}
inline void WorkflowTriggered::set_allocated_trigger_context(::PROTOBUF_NAMESPACE_ID::Struct* trigger_context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.trigger_context_);
  }
  if (trigger_context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(trigger_context));
    if (message_arena != submessage_arena) {
      trigger_context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trigger_context, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.trigger_context_ = trigger_context;
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.WorkflowTriggered.trigger_context)
}

// -------------------------------------------------------------------

// WorkflowStepExecuted

// string step_id = 1;
inline void WorkflowStepExecuted::clear_step_id() {
  _impl_.step_id_.ClearToEmpty();
}
inline const std::string& WorkflowStepExecuted::step_id() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.WorkflowStepExecuted.step_id)
  return _internal_step_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WorkflowStepExecuted::set_step_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.step_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.WorkflowStepExecuted.step_id)
}
inline std::string* WorkflowStepExecuted::mutable_step_id() {
  std::string* _s = _internal_mutable_step_id();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.WorkflowStepExecuted.step_id)
  return _s;
}
inline const std::string& WorkflowStepExecuted::_internal_step_id() const {
  return _impl_.step_id_.Get();
}
inline void WorkflowStepExecuted::_internal_set_step_id(const std::string& value) {
  
  _impl_.step_id_.Set(value, GetArenaForAllocation());
}
inline std::string* WorkflowStepExecuted::_internal_mutable_step_id() {
  
  return _impl_.step_id_.Mutable(GetArenaForAllocation());
}
inline std::string* WorkflowStepExecuted::release_step_id() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.WorkflowStepExecuted.step_id)
  return _impl_.step_id_.Release();
}
inline void WorkflowStepExecuted::set_allocated_step_id(std::string* step_id) {
  if (step_id != nullptr) {
    
  } else {
    
  }
  _impl_.step_id_.SetAllocated(step_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.step_id_.IsDefault()) {
    _impl_.step_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.WorkflowStepExecuted.step_id)
}

// string step_type = 2;
inline void WorkflowStepExecuted::clear_step_type() {
  _impl_.step_type_.ClearToEmpty();
}
inline const std::string& WorkflowStepExecuted::step_type() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.WorkflowStepExecuted.step_type)
  return _internal_step_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WorkflowStepExecuted::set_step_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.step_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.WorkflowStepExecuted.step_type)
}
inline std::string* WorkflowStepExecuted::mutable_step_type() {
  std::string* _s = _internal_mutable_step_type();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.WorkflowStepExecuted.step_type)
  return _s;
}
inline const std::string& WorkflowStepExecuted::_internal_step_type() const {
  return _impl_.step_type_.Get();
}
inline void WorkflowStepExecuted::_internal_set_step_type(const std::string& value) {
  
  _impl_.step_type_.Set(value, GetArenaForAllocation());
}
inline std::string* WorkflowStepExecuted::_internal_mutable_step_type() {
  
  return _impl_.step_type_.Mutable(GetArenaForAllocation());
}
inline std::string* WorkflowStepExecuted::release_step_type() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.WorkflowStepExecuted.step_type)
  return _impl_.step_type_.Release();
}
inline void WorkflowStepExecuted::set_allocated_step_type(std::string* step_type) {
  if (step_type != nullptr) {
    
  } else {
    
  }
  _impl_.step_type_.SetAllocated(step_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.step_type_.IsDefault()) {
    _impl_.step_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.WorkflowStepExecuted.step_type)
}

// .google.protobuf.Struct step_input = 3;
inline bool WorkflowStepExecuted::_internal_has_step_input() const {
  return this != internal_default_instance() && _impl_.step_input_ != nullptr;
}
inline bool WorkflowStepExecuted::has_step_input() const {
  return _internal_has_step_input();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& WorkflowStepExecuted::_internal_step_input() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.step_input_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& WorkflowStepExecuted::step_input() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.WorkflowStepExecuted.step_input)
  return _internal_step_input();
}
inline void WorkflowStepExecuted::unsafe_arena_set_allocated_step_input(
    ::PROTOBUF_NAMESPACE_ID::Struct* step_input) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.step_input_);
  }
  _impl_.step_input_ = step_input;
  if (step_input) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.WorkflowStepExecuted.step_input)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* WorkflowStepExecuted::release_step_input() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.step_input_;
  _impl_.step_input_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* WorkflowStepExecuted::unsafe_arena_release_step_input() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.WorkflowStepExecuted.step_input)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.step_input_;
  _impl_.step_input_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* WorkflowStepExecuted::_internal_mutable_step_input() {
  
  if (_impl_.step_input_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.step_input_ = p;
  }
  return _impl_.step_input_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* WorkflowStepExecuted::mutable_step_input() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_step_input();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.WorkflowStepExecuted.step_input)
  return _msg;
}
inline void WorkflowStepExecuted::set_allocated_step_input(::PROTOBUF_NAMESPACE_ID::Struct* step_input) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.step_input_);
  }
  if (step_input) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(step_input));
    if (message_arena != submessage_arena) {
      step_input = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, step_input, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.step_input_ = step_input;
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.WorkflowStepExecuted.step_input)
}

// .google.protobuf.Struct step_output = 4;
inline bool WorkflowStepExecuted::_internal_has_step_output() const {
  return this != internal_default_instance() && _impl_.step_output_ != nullptr;
}
inline bool WorkflowStepExecuted::has_step_output() const {
  return _internal_has_step_output();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& WorkflowStepExecuted::_internal_step_output() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.step_output_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& WorkflowStepExecuted::step_output() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.WorkflowStepExecuted.step_output)
  return _internal_step_output();
}
inline void WorkflowStepExecuted::unsafe_arena_set_allocated_step_output(
    ::PROTOBUF_NAMESPACE_ID::Struct* step_output) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.step_output_);
  }
  _impl_.step_output_ = step_output;
  if (step_output) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.WorkflowStepExecuted.step_output)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* WorkflowStepExecuted::release_step_output() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.step_output_;
  _impl_.step_output_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* WorkflowStepExecuted::unsafe_arena_release_step_output() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.WorkflowStepExecuted.step_output)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.step_output_;
  _impl_.step_output_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* WorkflowStepExecuted::_internal_mutable_step_output() {
  
  if (_impl_.step_output_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.step_output_ = p;
  }
  return _impl_.step_output_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* WorkflowStepExecuted::mutable_step_output() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_step_output();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.WorkflowStepExecuted.step_output)
  return _msg;
}
inline void WorkflowStepExecuted::set_allocated_step_output(::PROTOBUF_NAMESPACE_ID::Struct* step_output) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.step_output_);
  }
  if (step_output) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(step_output));
    if (message_arena != submessage_arena) {
      step_output = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, step_output, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.step_output_ = step_output;
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.WorkflowStepExecuted.step_output)
}

// float step_duration_ms = 5;
inline void WorkflowStepExecuted::clear_step_duration_ms() {
  _impl_.step_duration_ms_ = 0;
}
inline float WorkflowStepExecuted::_internal_step_duration_ms() const {
  return _impl_.step_duration_ms_;
}
inline float WorkflowStepExecuted::step_duration_ms() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.WorkflowStepExecuted.step_duration_ms)
  return _internal_step_duration_ms();
}
inline void WorkflowStepExecuted::_internal_set_step_duration_ms(float value) {
  
  _impl_.step_duration_ms_ = value;
}
inline void WorkflowStepExecuted::set_step_duration_ms(float value) {
  _internal_set_step_duration_ms(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.WorkflowStepExecuted.step_duration_ms)
}

// -------------------------------------------------------------------

// WorkflowCompleted

// .google.protobuf.Struct final_output = 1;
inline bool WorkflowCompleted::_internal_has_final_output() const {
  return this != internal_default_instance() && _impl_.final_output_ != nullptr;
}
inline bool WorkflowCompleted::has_final_output() const {
  return _internal_has_final_output();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& WorkflowCompleted::_internal_final_output() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.final_output_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& WorkflowCompleted::final_output() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.WorkflowCompleted.final_output)
  return _internal_final_output();
}
inline void WorkflowCompleted::unsafe_arena_set_allocated_final_output(
    ::PROTOBUF_NAMESPACE_ID::Struct* final_output) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.final_output_);
  }
  _impl_.final_output_ = final_output;
  if (final_output) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.WorkflowCompleted.final_output)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* WorkflowCompleted::release_final_output() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.final_output_;
  _impl_.final_output_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* WorkflowCompleted::unsafe_arena_release_final_output() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.WorkflowCompleted.final_output)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.final_output_;
  _impl_.final_output_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* WorkflowCompleted::_internal_mutable_final_output() {
  
  if (_impl_.final_output_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.final_output_ = p;
  }
  return _impl_.final_output_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* WorkflowCompleted::mutable_final_output() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_final_output();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.WorkflowCompleted.final_output)
  return _msg;
}
inline void WorkflowCompleted::set_allocated_final_output(::PROTOBUF_NAMESPACE_ID::Struct* final_output) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.final_output_);
  }
  if (final_output) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(final_output));
    if (message_arena != submessage_arena) {
      final_output = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, final_output, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.final_output_ = final_output;
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.WorkflowCompleted.final_output)
}

// int32 total_steps = 2;
inline void WorkflowCompleted::clear_total_steps() {
  _impl_.total_steps_ = 0;
}
inline int32_t WorkflowCompleted::_internal_total_steps() const {
  return _impl_.total_steps_;
}
inline int32_t WorkflowCompleted::total_steps() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.WorkflowCompleted.total_steps)
  return _internal_total_steps();
}
inline void WorkflowCompleted::_internal_set_total_steps(int32_t value) {
  
  _impl_.total_steps_ = value;
}
inline void WorkflowCompleted::set_total_steps(int32_t value) {
  _internal_set_total_steps(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.WorkflowCompleted.total_steps)
}

// float total_duration_ms = 3;
inline void WorkflowCompleted::clear_total_duration_ms() {
  _impl_.total_duration_ms_ = 0;
}
inline float WorkflowCompleted::_internal_total_duration_ms() const {
  return _impl_.total_duration_ms_;
}
inline float WorkflowCompleted::total_duration_ms() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.WorkflowCompleted.total_duration_ms)
  return _internal_total_duration_ms();
}
inline void WorkflowCompleted::_internal_set_total_duration_ms(float value) {
  
  _impl_.total_duration_ms_ = value;
}
inline void WorkflowCompleted::set_total_duration_ms(float value) {
  _internal_set_total_duration_ms(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.WorkflowCompleted.total_duration_ms)
}

// -------------------------------------------------------------------

// WorkflowFailed

// string failure_step_id = 1;
inline void WorkflowFailed::clear_failure_step_id() {
  _impl_.failure_step_id_.ClearToEmpty();
}
inline const std::string& WorkflowFailed::failure_step_id() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.WorkflowFailed.failure_step_id)
  return _internal_failure_step_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WorkflowFailed::set_failure_step_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.failure_step_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.WorkflowFailed.failure_step_id)
}
inline std::string* WorkflowFailed::mutable_failure_step_id() {
  std::string* _s = _internal_mutable_failure_step_id();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.WorkflowFailed.failure_step_id)
  return _s;
}
inline const std::string& WorkflowFailed::_internal_failure_step_id() const {
  return _impl_.failure_step_id_.Get();
}
inline void WorkflowFailed::_internal_set_failure_step_id(const std::string& value) {
  
  _impl_.failure_step_id_.Set(value, GetArenaForAllocation());
}
inline std::string* WorkflowFailed::_internal_mutable_failure_step_id() {
  
  return _impl_.failure_step_id_.Mutable(GetArenaForAllocation());
}
inline std::string* WorkflowFailed::release_failure_step_id() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.WorkflowFailed.failure_step_id)
  return _impl_.failure_step_id_.Release();
}
inline void WorkflowFailed::set_allocated_failure_step_id(std::string* failure_step_id) {
  if (failure_step_id != nullptr) {
    
  } else {
    
  }
  _impl_.failure_step_id_.SetAllocated(failure_step_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.failure_step_id_.IsDefault()) {
    _impl_.failure_step_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.WorkflowFailed.failure_step_id)
}

// string failure_reason = 2;
inline void WorkflowFailed::clear_failure_reason() {
  _impl_.failure_reason_.ClearToEmpty();
}
inline const std::string& WorkflowFailed::failure_reason() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.WorkflowFailed.failure_reason)
  return _internal_failure_reason();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WorkflowFailed::set_failure_reason(ArgT0&& arg0, ArgT... args) {
 
 _impl_.failure_reason_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.WorkflowFailed.failure_reason)
}
inline std::string* WorkflowFailed::mutable_failure_reason() {
  std::string* _s = _internal_mutable_failure_reason();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.WorkflowFailed.failure_reason)
  return _s;
}
inline const std::string& WorkflowFailed::_internal_failure_reason() const {
  return _impl_.failure_reason_.Get();
}
inline void WorkflowFailed::_internal_set_failure_reason(const std::string& value) {
  
  _impl_.failure_reason_.Set(value, GetArenaForAllocation());
}
inline std::string* WorkflowFailed::_internal_mutable_failure_reason() {
  
  return _impl_.failure_reason_.Mutable(GetArenaForAllocation());
}
inline std::string* WorkflowFailed::release_failure_reason() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.WorkflowFailed.failure_reason)
  return _impl_.failure_reason_.Release();
}
inline void WorkflowFailed::set_allocated_failure_reason(std::string* failure_reason) {
  if (failure_reason != nullptr) {
    
  } else {
    
  }
  _impl_.failure_reason_.SetAllocated(failure_reason, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.failure_reason_.IsDefault()) {
    _impl_.failure_reason_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.WorkflowFailed.failure_reason)
}

// string error_message = 3;
inline void WorkflowFailed::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& WorkflowFailed::error_message() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.WorkflowFailed.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WorkflowFailed::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.WorkflowFailed.error_message)
}
inline std::string* WorkflowFailed::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.WorkflowFailed.error_message)
  return _s;
}
inline const std::string& WorkflowFailed::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void WorkflowFailed::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* WorkflowFailed::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* WorkflowFailed::release_error_message() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.WorkflowFailed.error_message)
  return _impl_.error_message_.Release();
}
inline void WorkflowFailed::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.WorkflowFailed.error_message)
}

// -------------------------------------------------------------------

// ChatEvent

// string conversation_id = 1;
inline void ChatEvent::clear_conversation_id() {
  _impl_.conversation_id_.ClearToEmpty();
}
inline const std::string& ChatEvent::conversation_id() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.ChatEvent.conversation_id)
  return _internal_conversation_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatEvent::set_conversation_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.conversation_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.ChatEvent.conversation_id)
}
inline std::string* ChatEvent::mutable_conversation_id() {
  std::string* _s = _internal_mutable_conversation_id();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.ChatEvent.conversation_id)
  return _s;
}
inline const std::string& ChatEvent::_internal_conversation_id() const {
  return _impl_.conversation_id_.Get();
}
inline void ChatEvent::_internal_set_conversation_id(const std::string& value) {
  
  _impl_.conversation_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatEvent::_internal_mutable_conversation_id() {
  
  return _impl_.conversation_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatEvent::release_conversation_id() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.ChatEvent.conversation_id)
  return _impl_.conversation_id_.Release();
}
inline void ChatEvent::set_allocated_conversation_id(std::string* conversation_id) {
  if (conversation_id != nullptr) {
    
  } else {
    
  }
  _impl_.conversation_id_.SetAllocated(conversation_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.conversation_id_.IsDefault()) {
    _impl_.conversation_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.ChatEvent.conversation_id)
}

// string message_id = 2;
inline void ChatEvent::clear_message_id() {
  _impl_.message_id_.ClearToEmpty();
}
inline const std::string& ChatEvent::message_id() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.ChatEvent.message_id)
  return _internal_message_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatEvent::set_message_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.ChatEvent.message_id)
}
inline std::string* ChatEvent::mutable_message_id() {
  std::string* _s = _internal_mutable_message_id();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.ChatEvent.message_id)
  return _s;
}
inline const std::string& ChatEvent::_internal_message_id() const {
  return _impl_.message_id_.Get();
}
inline void ChatEvent::_internal_set_message_id(const std::string& value) {
  
  _impl_.message_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatEvent::_internal_mutable_message_id() {
  
  return _impl_.message_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatEvent::release_message_id() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.ChatEvent.message_id)
  return _impl_.message_id_.Release();
}
inline void ChatEvent::set_allocated_message_id(std::string* message_id) {
  if (message_id != nullptr) {
    
  } else {
    
  }
  _impl_.message_id_.SetAllocated(message_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_id_.IsDefault()) {
    _impl_.message_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.ChatEvent.message_id)
}

// .unhinged.cdc.ChatEventType event_type = 3;
inline void ChatEvent::clear_event_type() {
  _impl_.event_type_ = 0;
}
inline ::unhinged::cdc::ChatEventType ChatEvent::_internal_event_type() const {
  return static_cast< ::unhinged::cdc::ChatEventType >(_impl_.event_type_);
}
inline ::unhinged::cdc::ChatEventType ChatEvent::event_type() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.ChatEvent.event_type)
  return _internal_event_type();
}
inline void ChatEvent::_internal_set_event_type(::unhinged::cdc::ChatEventType value) {
  
  _impl_.event_type_ = value;
}
inline void ChatEvent::set_event_type(::unhinged::cdc::ChatEventType value) {
  _internal_set_event_type(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.ChatEvent.event_type)
}

// .unhinged.cdc.ConversationCreated conversation_created = 10;
inline bool ChatEvent::_internal_has_conversation_created() const {
  return event_data_case() == kConversationCreated;
}
inline bool ChatEvent::has_conversation_created() const {
  return _internal_has_conversation_created();
}
inline void ChatEvent::set_has_conversation_created() {
  _impl_._oneof_case_[0] = kConversationCreated;
}
inline void ChatEvent::clear_conversation_created() {
  if (_internal_has_conversation_created()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_data_.conversation_created_;
    }
    clear_has_event_data();
  }
}
inline ::unhinged::cdc::ConversationCreated* ChatEvent::release_conversation_created() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.ChatEvent.conversation_created)
  if (_internal_has_conversation_created()) {
    clear_has_event_data();
    ::unhinged::cdc::ConversationCreated* temp = _impl_.event_data_.conversation_created_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_data_.conversation_created_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::cdc::ConversationCreated& ChatEvent::_internal_conversation_created() const {
  return _internal_has_conversation_created()
      ? *_impl_.event_data_.conversation_created_
      : reinterpret_cast< ::unhinged::cdc::ConversationCreated&>(::unhinged::cdc::_ConversationCreated_default_instance_);
}
inline const ::unhinged::cdc::ConversationCreated& ChatEvent::conversation_created() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.ChatEvent.conversation_created)
  return _internal_conversation_created();
}
inline ::unhinged::cdc::ConversationCreated* ChatEvent::unsafe_arena_release_conversation_created() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.cdc.ChatEvent.conversation_created)
  if (_internal_has_conversation_created()) {
    clear_has_event_data();
    ::unhinged::cdc::ConversationCreated* temp = _impl_.event_data_.conversation_created_;
    _impl_.event_data_.conversation_created_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ChatEvent::unsafe_arena_set_allocated_conversation_created(::unhinged::cdc::ConversationCreated* conversation_created) {
  clear_event_data();
  if (conversation_created) {
    set_has_conversation_created();
    _impl_.event_data_.conversation_created_ = conversation_created;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.ChatEvent.conversation_created)
}
inline ::unhinged::cdc::ConversationCreated* ChatEvent::_internal_mutable_conversation_created() {
  if (!_internal_has_conversation_created()) {
    clear_event_data();
    set_has_conversation_created();
    _impl_.event_data_.conversation_created_ = CreateMaybeMessage< ::unhinged::cdc::ConversationCreated >(GetArenaForAllocation());
  }
  return _impl_.event_data_.conversation_created_;
}
inline ::unhinged::cdc::ConversationCreated* ChatEvent::mutable_conversation_created() {
  ::unhinged::cdc::ConversationCreated* _msg = _internal_mutable_conversation_created();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.ChatEvent.conversation_created)
  return _msg;
}

// .unhinged.cdc.MessageSent message_sent = 11;
inline bool ChatEvent::_internal_has_message_sent() const {
  return event_data_case() == kMessageSent;
}
inline bool ChatEvent::has_message_sent() const {
  return _internal_has_message_sent();
}
inline void ChatEvent::set_has_message_sent() {
  _impl_._oneof_case_[0] = kMessageSent;
}
inline void ChatEvent::clear_message_sent() {
  if (_internal_has_message_sent()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_data_.message_sent_;
    }
    clear_has_event_data();
  }
}
inline ::unhinged::cdc::MessageSent* ChatEvent::release_message_sent() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.ChatEvent.message_sent)
  if (_internal_has_message_sent()) {
    clear_has_event_data();
    ::unhinged::cdc::MessageSent* temp = _impl_.event_data_.message_sent_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_data_.message_sent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::cdc::MessageSent& ChatEvent::_internal_message_sent() const {
  return _internal_has_message_sent()
      ? *_impl_.event_data_.message_sent_
      : reinterpret_cast< ::unhinged::cdc::MessageSent&>(::unhinged::cdc::_MessageSent_default_instance_);
}
inline const ::unhinged::cdc::MessageSent& ChatEvent::message_sent() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.ChatEvent.message_sent)
  return _internal_message_sent();
}
inline ::unhinged::cdc::MessageSent* ChatEvent::unsafe_arena_release_message_sent() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.cdc.ChatEvent.message_sent)
  if (_internal_has_message_sent()) {
    clear_has_event_data();
    ::unhinged::cdc::MessageSent* temp = _impl_.event_data_.message_sent_;
    _impl_.event_data_.message_sent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ChatEvent::unsafe_arena_set_allocated_message_sent(::unhinged::cdc::MessageSent* message_sent) {
  clear_event_data();
  if (message_sent) {
    set_has_message_sent();
    _impl_.event_data_.message_sent_ = message_sent;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.ChatEvent.message_sent)
}
inline ::unhinged::cdc::MessageSent* ChatEvent::_internal_mutable_message_sent() {
  if (!_internal_has_message_sent()) {
    clear_event_data();
    set_has_message_sent();
    _impl_.event_data_.message_sent_ = CreateMaybeMessage< ::unhinged::cdc::MessageSent >(GetArenaForAllocation());
  }
  return _impl_.event_data_.message_sent_;
}
inline ::unhinged::cdc::MessageSent* ChatEvent::mutable_message_sent() {
  ::unhinged::cdc::MessageSent* _msg = _internal_mutable_message_sent();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.ChatEvent.message_sent)
  return _msg;
}

// .unhinged.cdc.MessageUpdated message_updated = 12;
inline bool ChatEvent::_internal_has_message_updated() const {
  return event_data_case() == kMessageUpdated;
}
inline bool ChatEvent::has_message_updated() const {
  return _internal_has_message_updated();
}
inline void ChatEvent::set_has_message_updated() {
  _impl_._oneof_case_[0] = kMessageUpdated;
}
inline void ChatEvent::clear_message_updated() {
  if (_internal_has_message_updated()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_data_.message_updated_;
    }
    clear_has_event_data();
  }
}
inline ::unhinged::cdc::MessageUpdated* ChatEvent::release_message_updated() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.ChatEvent.message_updated)
  if (_internal_has_message_updated()) {
    clear_has_event_data();
    ::unhinged::cdc::MessageUpdated* temp = _impl_.event_data_.message_updated_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_data_.message_updated_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::cdc::MessageUpdated& ChatEvent::_internal_message_updated() const {
  return _internal_has_message_updated()
      ? *_impl_.event_data_.message_updated_
      : reinterpret_cast< ::unhinged::cdc::MessageUpdated&>(::unhinged::cdc::_MessageUpdated_default_instance_);
}
inline const ::unhinged::cdc::MessageUpdated& ChatEvent::message_updated() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.ChatEvent.message_updated)
  return _internal_message_updated();
}
inline ::unhinged::cdc::MessageUpdated* ChatEvent::unsafe_arena_release_message_updated() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.cdc.ChatEvent.message_updated)
  if (_internal_has_message_updated()) {
    clear_has_event_data();
    ::unhinged::cdc::MessageUpdated* temp = _impl_.event_data_.message_updated_;
    _impl_.event_data_.message_updated_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ChatEvent::unsafe_arena_set_allocated_message_updated(::unhinged::cdc::MessageUpdated* message_updated) {
  clear_event_data();
  if (message_updated) {
    set_has_message_updated();
    _impl_.event_data_.message_updated_ = message_updated;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.ChatEvent.message_updated)
}
inline ::unhinged::cdc::MessageUpdated* ChatEvent::_internal_mutable_message_updated() {
  if (!_internal_has_message_updated()) {
    clear_event_data();
    set_has_message_updated();
    _impl_.event_data_.message_updated_ = CreateMaybeMessage< ::unhinged::cdc::MessageUpdated >(GetArenaForAllocation());
  }
  return _impl_.event_data_.message_updated_;
}
inline ::unhinged::cdc::MessageUpdated* ChatEvent::mutable_message_updated() {
  ::unhinged::cdc::MessageUpdated* _msg = _internal_mutable_message_updated();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.ChatEvent.message_updated)
  return _msg;
}

// .unhinged.cdc.TypingStarted typing_started = 13;
inline bool ChatEvent::_internal_has_typing_started() const {
  return event_data_case() == kTypingStarted;
}
inline bool ChatEvent::has_typing_started() const {
  return _internal_has_typing_started();
}
inline void ChatEvent::set_has_typing_started() {
  _impl_._oneof_case_[0] = kTypingStarted;
}
inline void ChatEvent::clear_typing_started() {
  if (_internal_has_typing_started()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_data_.typing_started_;
    }
    clear_has_event_data();
  }
}
inline ::unhinged::cdc::TypingStarted* ChatEvent::release_typing_started() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.ChatEvent.typing_started)
  if (_internal_has_typing_started()) {
    clear_has_event_data();
    ::unhinged::cdc::TypingStarted* temp = _impl_.event_data_.typing_started_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_data_.typing_started_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::cdc::TypingStarted& ChatEvent::_internal_typing_started() const {
  return _internal_has_typing_started()
      ? *_impl_.event_data_.typing_started_
      : reinterpret_cast< ::unhinged::cdc::TypingStarted&>(::unhinged::cdc::_TypingStarted_default_instance_);
}
inline const ::unhinged::cdc::TypingStarted& ChatEvent::typing_started() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.ChatEvent.typing_started)
  return _internal_typing_started();
}
inline ::unhinged::cdc::TypingStarted* ChatEvent::unsafe_arena_release_typing_started() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.cdc.ChatEvent.typing_started)
  if (_internal_has_typing_started()) {
    clear_has_event_data();
    ::unhinged::cdc::TypingStarted* temp = _impl_.event_data_.typing_started_;
    _impl_.event_data_.typing_started_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ChatEvent::unsafe_arena_set_allocated_typing_started(::unhinged::cdc::TypingStarted* typing_started) {
  clear_event_data();
  if (typing_started) {
    set_has_typing_started();
    _impl_.event_data_.typing_started_ = typing_started;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.ChatEvent.typing_started)
}
inline ::unhinged::cdc::TypingStarted* ChatEvent::_internal_mutable_typing_started() {
  if (!_internal_has_typing_started()) {
    clear_event_data();
    set_has_typing_started();
    _impl_.event_data_.typing_started_ = CreateMaybeMessage< ::unhinged::cdc::TypingStarted >(GetArenaForAllocation());
  }
  return _impl_.event_data_.typing_started_;
}
inline ::unhinged::cdc::TypingStarted* ChatEvent::mutable_typing_started() {
  ::unhinged::cdc::TypingStarted* _msg = _internal_mutable_typing_started();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.ChatEvent.typing_started)
  return _msg;
}

// .unhinged.cdc.ParticipantJoined participant_joined = 14;
inline bool ChatEvent::_internal_has_participant_joined() const {
  return event_data_case() == kParticipantJoined;
}
inline bool ChatEvent::has_participant_joined() const {
  return _internal_has_participant_joined();
}
inline void ChatEvent::set_has_participant_joined() {
  _impl_._oneof_case_[0] = kParticipantJoined;
}
inline void ChatEvent::clear_participant_joined() {
  if (_internal_has_participant_joined()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_data_.participant_joined_;
    }
    clear_has_event_data();
  }
}
inline ::unhinged::cdc::ParticipantJoined* ChatEvent::release_participant_joined() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.ChatEvent.participant_joined)
  if (_internal_has_participant_joined()) {
    clear_has_event_data();
    ::unhinged::cdc::ParticipantJoined* temp = _impl_.event_data_.participant_joined_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_data_.participant_joined_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::cdc::ParticipantJoined& ChatEvent::_internal_participant_joined() const {
  return _internal_has_participant_joined()
      ? *_impl_.event_data_.participant_joined_
      : reinterpret_cast< ::unhinged::cdc::ParticipantJoined&>(::unhinged::cdc::_ParticipantJoined_default_instance_);
}
inline const ::unhinged::cdc::ParticipantJoined& ChatEvent::participant_joined() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.ChatEvent.participant_joined)
  return _internal_participant_joined();
}
inline ::unhinged::cdc::ParticipantJoined* ChatEvent::unsafe_arena_release_participant_joined() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.cdc.ChatEvent.participant_joined)
  if (_internal_has_participant_joined()) {
    clear_has_event_data();
    ::unhinged::cdc::ParticipantJoined* temp = _impl_.event_data_.participant_joined_;
    _impl_.event_data_.participant_joined_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ChatEvent::unsafe_arena_set_allocated_participant_joined(::unhinged::cdc::ParticipantJoined* participant_joined) {
  clear_event_data();
  if (participant_joined) {
    set_has_participant_joined();
    _impl_.event_data_.participant_joined_ = participant_joined;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.ChatEvent.participant_joined)
}
inline ::unhinged::cdc::ParticipantJoined* ChatEvent::_internal_mutable_participant_joined() {
  if (!_internal_has_participant_joined()) {
    clear_event_data();
    set_has_participant_joined();
    _impl_.event_data_.participant_joined_ = CreateMaybeMessage< ::unhinged::cdc::ParticipantJoined >(GetArenaForAllocation());
  }
  return _impl_.event_data_.participant_joined_;
}
inline ::unhinged::cdc::ParticipantJoined* ChatEvent::mutable_participant_joined() {
  ::unhinged::cdc::ParticipantJoined* _msg = _internal_mutable_participant_joined();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.ChatEvent.participant_joined)
  return _msg;
}

inline bool ChatEvent::has_event_data() const {
  return event_data_case() != EVENT_DATA_NOT_SET;
}
inline void ChatEvent::clear_has_event_data() {
  _impl_._oneof_case_[0] = EVENT_DATA_NOT_SET;
}
inline ChatEvent::EventDataCase ChatEvent::event_data_case() const {
  return ChatEvent::EventDataCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ConversationCreated

// string title = 1;
inline void ConversationCreated::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& ConversationCreated::title() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.ConversationCreated.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConversationCreated::set_title(ArgT0&& arg0, ArgT... args) {
 
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.ConversationCreated.title)
}
inline std::string* ConversationCreated::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.ConversationCreated.title)
  return _s;
}
inline const std::string& ConversationCreated::_internal_title() const {
  return _impl_.title_.Get();
}
inline void ConversationCreated::_internal_set_title(const std::string& value) {
  
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* ConversationCreated::_internal_mutable_title() {
  
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* ConversationCreated::release_title() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.ConversationCreated.title)
  return _impl_.title_.Release();
}
inline void ConversationCreated::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.ConversationCreated.title)
}

// string created_by = 2;
inline void ConversationCreated::clear_created_by() {
  _impl_.created_by_.ClearToEmpty();
}
inline const std::string& ConversationCreated::created_by() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.ConversationCreated.created_by)
  return _internal_created_by();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConversationCreated::set_created_by(ArgT0&& arg0, ArgT... args) {
 
 _impl_.created_by_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.ConversationCreated.created_by)
}
inline std::string* ConversationCreated::mutable_created_by() {
  std::string* _s = _internal_mutable_created_by();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.ConversationCreated.created_by)
  return _s;
}
inline const std::string& ConversationCreated::_internal_created_by() const {
  return _impl_.created_by_.Get();
}
inline void ConversationCreated::_internal_set_created_by(const std::string& value) {
  
  _impl_.created_by_.Set(value, GetArenaForAllocation());
}
inline std::string* ConversationCreated::_internal_mutable_created_by() {
  
  return _impl_.created_by_.Mutable(GetArenaForAllocation());
}
inline std::string* ConversationCreated::release_created_by() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.ConversationCreated.created_by)
  return _impl_.created_by_.Release();
}
inline void ConversationCreated::set_allocated_created_by(std::string* created_by) {
  if (created_by != nullptr) {
    
  } else {
    
  }
  _impl_.created_by_.SetAllocated(created_by, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.created_by_.IsDefault()) {
    _impl_.created_by_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.ConversationCreated.created_by)
}

// repeated string participant_ids = 3;
inline int ConversationCreated::_internal_participant_ids_size() const {
  return _impl_.participant_ids_.size();
}
inline int ConversationCreated::participant_ids_size() const {
  return _internal_participant_ids_size();
}
inline void ConversationCreated::clear_participant_ids() {
  _impl_.participant_ids_.Clear();
}
inline std::string* ConversationCreated::add_participant_ids() {
  std::string* _s = _internal_add_participant_ids();
  // @@protoc_insertion_point(field_add_mutable:unhinged.cdc.ConversationCreated.participant_ids)
  return _s;
}
inline const std::string& ConversationCreated::_internal_participant_ids(int index) const {
  return _impl_.participant_ids_.Get(index);
}
inline const std::string& ConversationCreated::participant_ids(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.ConversationCreated.participant_ids)
  return _internal_participant_ids(index);
}
inline std::string* ConversationCreated::mutable_participant_ids(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.ConversationCreated.participant_ids)
  return _impl_.participant_ids_.Mutable(index);
}
inline void ConversationCreated::set_participant_ids(int index, const std::string& value) {
  _impl_.participant_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.ConversationCreated.participant_ids)
}
inline void ConversationCreated::set_participant_ids(int index, std::string&& value) {
  _impl_.participant_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.cdc.ConversationCreated.participant_ids)
}
inline void ConversationCreated::set_participant_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.participant_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.cdc.ConversationCreated.participant_ids)
}
inline void ConversationCreated::set_participant_ids(int index, const char* value, size_t size) {
  _impl_.participant_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.cdc.ConversationCreated.participant_ids)
}
inline std::string* ConversationCreated::_internal_add_participant_ids() {
  return _impl_.participant_ids_.Add();
}
inline void ConversationCreated::add_participant_ids(const std::string& value) {
  _impl_.participant_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.cdc.ConversationCreated.participant_ids)
}
inline void ConversationCreated::add_participant_ids(std::string&& value) {
  _impl_.participant_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.cdc.ConversationCreated.participant_ids)
}
inline void ConversationCreated::add_participant_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.participant_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.cdc.ConversationCreated.participant_ids)
}
inline void ConversationCreated::add_participant_ids(const char* value, size_t size) {
  _impl_.participant_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.cdc.ConversationCreated.participant_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ConversationCreated::participant_ids() const {
  // @@protoc_insertion_point(field_list:unhinged.cdc.ConversationCreated.participant_ids)
  return _impl_.participant_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ConversationCreated::mutable_participant_ids() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.cdc.ConversationCreated.participant_ids)
  return &_impl_.participant_ids_;
}

// -------------------------------------------------------------------

// MessageSent

// string content = 1;
inline void MessageSent::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& MessageSent::content() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.MessageSent.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MessageSent::set_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.MessageSent.content)
}
inline std::string* MessageSent::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.MessageSent.content)
  return _s;
}
inline const std::string& MessageSent::_internal_content() const {
  return _impl_.content_.Get();
}
inline void MessageSent::_internal_set_content(const std::string& value) {
  
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* MessageSent::_internal_mutable_content() {
  
  return _impl_.content_.Mutable(GetArenaForAllocation());
}
inline std::string* MessageSent::release_content() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.MessageSent.content)
  return _impl_.content_.Release();
}
inline void MessageSent::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.MessageSent.content)
}

// string role = 2;
inline void MessageSent::clear_role() {
  _impl_.role_.ClearToEmpty();
}
inline const std::string& MessageSent::role() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.MessageSent.role)
  return _internal_role();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MessageSent::set_role(ArgT0&& arg0, ArgT... args) {
 
 _impl_.role_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.MessageSent.role)
}
inline std::string* MessageSent::mutable_role() {
  std::string* _s = _internal_mutable_role();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.MessageSent.role)
  return _s;
}
inline const std::string& MessageSent::_internal_role() const {
  return _impl_.role_.Get();
}
inline void MessageSent::_internal_set_role(const std::string& value) {
  
  _impl_.role_.Set(value, GetArenaForAllocation());
}
inline std::string* MessageSent::_internal_mutable_role() {
  
  return _impl_.role_.Mutable(GetArenaForAllocation());
}
inline std::string* MessageSent::release_role() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.MessageSent.role)
  return _impl_.role_.Release();
}
inline void MessageSent::set_allocated_role(std::string* role) {
  if (role != nullptr) {
    
  } else {
    
  }
  _impl_.role_.SetAllocated(role, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.role_.IsDefault()) {
    _impl_.role_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.MessageSent.role)
}

// string sent_by = 3;
inline void MessageSent::clear_sent_by() {
  _impl_.sent_by_.ClearToEmpty();
}
inline const std::string& MessageSent::sent_by() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.MessageSent.sent_by)
  return _internal_sent_by();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MessageSent::set_sent_by(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sent_by_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.MessageSent.sent_by)
}
inline std::string* MessageSent::mutable_sent_by() {
  std::string* _s = _internal_mutable_sent_by();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.MessageSent.sent_by)
  return _s;
}
inline const std::string& MessageSent::_internal_sent_by() const {
  return _impl_.sent_by_.Get();
}
inline void MessageSent::_internal_set_sent_by(const std::string& value) {
  
  _impl_.sent_by_.Set(value, GetArenaForAllocation());
}
inline std::string* MessageSent::_internal_mutable_sent_by() {
  
  return _impl_.sent_by_.Mutable(GetArenaForAllocation());
}
inline std::string* MessageSent::release_sent_by() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.MessageSent.sent_by)
  return _impl_.sent_by_.Release();
}
inline void MessageSent::set_allocated_sent_by(std::string* sent_by) {
  if (sent_by != nullptr) {
    
  } else {
    
  }
  _impl_.sent_by_.SetAllocated(sent_by, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sent_by_.IsDefault()) {
    _impl_.sent_by_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.MessageSent.sent_by)
}

// -------------------------------------------------------------------

// MessageUpdated

// string content = 1;
inline void MessageUpdated::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& MessageUpdated::content() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.MessageUpdated.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MessageUpdated::set_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.MessageUpdated.content)
}
inline std::string* MessageUpdated::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.MessageUpdated.content)
  return _s;
}
inline const std::string& MessageUpdated::_internal_content() const {
  return _impl_.content_.Get();
}
inline void MessageUpdated::_internal_set_content(const std::string& value) {
  
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* MessageUpdated::_internal_mutable_content() {
  
  return _impl_.content_.Mutable(GetArenaForAllocation());
}
inline std::string* MessageUpdated::release_content() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.MessageUpdated.content)
  return _impl_.content_.Release();
}
inline void MessageUpdated::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.MessageUpdated.content)
}

// string updated_by = 2;
inline void MessageUpdated::clear_updated_by() {
  _impl_.updated_by_.ClearToEmpty();
}
inline const std::string& MessageUpdated::updated_by() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.MessageUpdated.updated_by)
  return _internal_updated_by();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MessageUpdated::set_updated_by(ArgT0&& arg0, ArgT... args) {
 
 _impl_.updated_by_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.MessageUpdated.updated_by)
}
inline std::string* MessageUpdated::mutable_updated_by() {
  std::string* _s = _internal_mutable_updated_by();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.MessageUpdated.updated_by)
  return _s;
}
inline const std::string& MessageUpdated::_internal_updated_by() const {
  return _impl_.updated_by_.Get();
}
inline void MessageUpdated::_internal_set_updated_by(const std::string& value) {
  
  _impl_.updated_by_.Set(value, GetArenaForAllocation());
}
inline std::string* MessageUpdated::_internal_mutable_updated_by() {
  
  return _impl_.updated_by_.Mutable(GetArenaForAllocation());
}
inline std::string* MessageUpdated::release_updated_by() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.MessageUpdated.updated_by)
  return _impl_.updated_by_.Release();
}
inline void MessageUpdated::set_allocated_updated_by(std::string* updated_by) {
  if (updated_by != nullptr) {
    
  } else {
    
  }
  _impl_.updated_by_.SetAllocated(updated_by, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.updated_by_.IsDefault()) {
    _impl_.updated_by_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.MessageUpdated.updated_by)
}

// -------------------------------------------------------------------

// TypingStarted

// string user_id = 1;
inline void TypingStarted::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& TypingStarted::user_id() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.TypingStarted.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TypingStarted::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.TypingStarted.user_id)
}
inline std::string* TypingStarted::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.TypingStarted.user_id)
  return _s;
}
inline const std::string& TypingStarted::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void TypingStarted::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TypingStarted::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TypingStarted::release_user_id() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.TypingStarted.user_id)
  return _impl_.user_id_.Release();
}
inline void TypingStarted::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.TypingStarted.user_id)
}

// -------------------------------------------------------------------

// ParticipantJoined

// string user_id = 1;
inline void ParticipantJoined::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& ParticipantJoined::user_id() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.ParticipantJoined.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ParticipantJoined::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.ParticipantJoined.user_id)
}
inline std::string* ParticipantJoined::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.ParticipantJoined.user_id)
  return _s;
}
inline const std::string& ParticipantJoined::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void ParticipantJoined::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ParticipantJoined::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ParticipantJoined::release_user_id() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.ParticipantJoined.user_id)
  return _impl_.user_id_.Release();
}
inline void ParticipantJoined::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.ParticipantJoined.user_id)
}

// string invited_by = 2;
inline void ParticipantJoined::clear_invited_by() {
  _impl_.invited_by_.ClearToEmpty();
}
inline const std::string& ParticipantJoined::invited_by() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.ParticipantJoined.invited_by)
  return _internal_invited_by();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ParticipantJoined::set_invited_by(ArgT0&& arg0, ArgT... args) {
 
 _impl_.invited_by_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.ParticipantJoined.invited_by)
}
inline std::string* ParticipantJoined::mutable_invited_by() {
  std::string* _s = _internal_mutable_invited_by();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.ParticipantJoined.invited_by)
  return _s;
}
inline const std::string& ParticipantJoined::_internal_invited_by() const {
  return _impl_.invited_by_.Get();
}
inline void ParticipantJoined::_internal_set_invited_by(const std::string& value) {
  
  _impl_.invited_by_.Set(value, GetArenaForAllocation());
}
inline std::string* ParticipantJoined::_internal_mutable_invited_by() {
  
  return _impl_.invited_by_.Mutable(GetArenaForAllocation());
}
inline std::string* ParticipantJoined::release_invited_by() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.ParticipantJoined.invited_by)
  return _impl_.invited_by_.Release();
}
inline void ParticipantJoined::set_allocated_invited_by(std::string* invited_by) {
  if (invited_by != nullptr) {
    
  } else {
    
  }
  _impl_.invited_by_.SetAllocated(invited_by, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.invited_by_.IsDefault()) {
    _impl_.invited_by_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.ParticipantJoined.invited_by)
}

// -------------------------------------------------------------------

// AudioEvent

// string audio_id = 1;
inline void AudioEvent::clear_audio_id() {
  _impl_.audio_id_.ClearToEmpty();
}
inline const std::string& AudioEvent::audio_id() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.AudioEvent.audio_id)
  return _internal_audio_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AudioEvent::set_audio_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.audio_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.AudioEvent.audio_id)
}
inline std::string* AudioEvent::mutable_audio_id() {
  std::string* _s = _internal_mutable_audio_id();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.AudioEvent.audio_id)
  return _s;
}
inline const std::string& AudioEvent::_internal_audio_id() const {
  return _impl_.audio_id_.Get();
}
inline void AudioEvent::_internal_set_audio_id(const std::string& value) {
  
  _impl_.audio_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AudioEvent::_internal_mutable_audio_id() {
  
  return _impl_.audio_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AudioEvent::release_audio_id() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.AudioEvent.audio_id)
  return _impl_.audio_id_.Release();
}
inline void AudioEvent::set_allocated_audio_id(std::string* audio_id) {
  if (audio_id != nullptr) {
    
  } else {
    
  }
  _impl_.audio_id_.SetAllocated(audio_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.audio_id_.IsDefault()) {
    _impl_.audio_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.AudioEvent.audio_id)
}

// .unhinged.cdc.AudioEventType event_type = 2;
inline void AudioEvent::clear_event_type() {
  _impl_.event_type_ = 0;
}
inline ::unhinged::cdc::AudioEventType AudioEvent::_internal_event_type() const {
  return static_cast< ::unhinged::cdc::AudioEventType >(_impl_.event_type_);
}
inline ::unhinged::cdc::AudioEventType AudioEvent::event_type() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.AudioEvent.event_type)
  return _internal_event_type();
}
inline void AudioEvent::_internal_set_event_type(::unhinged::cdc::AudioEventType value) {
  
  _impl_.event_type_ = value;
}
inline void AudioEvent::set_event_type(::unhinged::cdc::AudioEventType value) {
  _internal_set_event_type(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.AudioEvent.event_type)
}

// .unhinged.cdc.TTSStarted tts_started = 10;
inline bool AudioEvent::_internal_has_tts_started() const {
  return event_data_case() == kTtsStarted;
}
inline bool AudioEvent::has_tts_started() const {
  return _internal_has_tts_started();
}
inline void AudioEvent::set_has_tts_started() {
  _impl_._oneof_case_[0] = kTtsStarted;
}
inline void AudioEvent::clear_tts_started() {
  if (_internal_has_tts_started()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_data_.tts_started_;
    }
    clear_has_event_data();
  }
}
inline ::unhinged::cdc::TTSStarted* AudioEvent::release_tts_started() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.AudioEvent.tts_started)
  if (_internal_has_tts_started()) {
    clear_has_event_data();
    ::unhinged::cdc::TTSStarted* temp = _impl_.event_data_.tts_started_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_data_.tts_started_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::cdc::TTSStarted& AudioEvent::_internal_tts_started() const {
  return _internal_has_tts_started()
      ? *_impl_.event_data_.tts_started_
      : reinterpret_cast< ::unhinged::cdc::TTSStarted&>(::unhinged::cdc::_TTSStarted_default_instance_);
}
inline const ::unhinged::cdc::TTSStarted& AudioEvent::tts_started() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.AudioEvent.tts_started)
  return _internal_tts_started();
}
inline ::unhinged::cdc::TTSStarted* AudioEvent::unsafe_arena_release_tts_started() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.cdc.AudioEvent.tts_started)
  if (_internal_has_tts_started()) {
    clear_has_event_data();
    ::unhinged::cdc::TTSStarted* temp = _impl_.event_data_.tts_started_;
    _impl_.event_data_.tts_started_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AudioEvent::unsafe_arena_set_allocated_tts_started(::unhinged::cdc::TTSStarted* tts_started) {
  clear_event_data();
  if (tts_started) {
    set_has_tts_started();
    _impl_.event_data_.tts_started_ = tts_started;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.AudioEvent.tts_started)
}
inline ::unhinged::cdc::TTSStarted* AudioEvent::_internal_mutable_tts_started() {
  if (!_internal_has_tts_started()) {
    clear_event_data();
    set_has_tts_started();
    _impl_.event_data_.tts_started_ = CreateMaybeMessage< ::unhinged::cdc::TTSStarted >(GetArenaForAllocation());
  }
  return _impl_.event_data_.tts_started_;
}
inline ::unhinged::cdc::TTSStarted* AudioEvent::mutable_tts_started() {
  ::unhinged::cdc::TTSStarted* _msg = _internal_mutable_tts_started();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.AudioEvent.tts_started)
  return _msg;
}

// .unhinged.cdc.TTSCompleted tts_completed = 11;
inline bool AudioEvent::_internal_has_tts_completed() const {
  return event_data_case() == kTtsCompleted;
}
inline bool AudioEvent::has_tts_completed() const {
  return _internal_has_tts_completed();
}
inline void AudioEvent::set_has_tts_completed() {
  _impl_._oneof_case_[0] = kTtsCompleted;
}
inline void AudioEvent::clear_tts_completed() {
  if (_internal_has_tts_completed()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_data_.tts_completed_;
    }
    clear_has_event_data();
  }
}
inline ::unhinged::cdc::TTSCompleted* AudioEvent::release_tts_completed() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.AudioEvent.tts_completed)
  if (_internal_has_tts_completed()) {
    clear_has_event_data();
    ::unhinged::cdc::TTSCompleted* temp = _impl_.event_data_.tts_completed_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_data_.tts_completed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::cdc::TTSCompleted& AudioEvent::_internal_tts_completed() const {
  return _internal_has_tts_completed()
      ? *_impl_.event_data_.tts_completed_
      : reinterpret_cast< ::unhinged::cdc::TTSCompleted&>(::unhinged::cdc::_TTSCompleted_default_instance_);
}
inline const ::unhinged::cdc::TTSCompleted& AudioEvent::tts_completed() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.AudioEvent.tts_completed)
  return _internal_tts_completed();
}
inline ::unhinged::cdc::TTSCompleted* AudioEvent::unsafe_arena_release_tts_completed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.cdc.AudioEvent.tts_completed)
  if (_internal_has_tts_completed()) {
    clear_has_event_data();
    ::unhinged::cdc::TTSCompleted* temp = _impl_.event_data_.tts_completed_;
    _impl_.event_data_.tts_completed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AudioEvent::unsafe_arena_set_allocated_tts_completed(::unhinged::cdc::TTSCompleted* tts_completed) {
  clear_event_data();
  if (tts_completed) {
    set_has_tts_completed();
    _impl_.event_data_.tts_completed_ = tts_completed;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.AudioEvent.tts_completed)
}
inline ::unhinged::cdc::TTSCompleted* AudioEvent::_internal_mutable_tts_completed() {
  if (!_internal_has_tts_completed()) {
    clear_event_data();
    set_has_tts_completed();
    _impl_.event_data_.tts_completed_ = CreateMaybeMessage< ::unhinged::cdc::TTSCompleted >(GetArenaForAllocation());
  }
  return _impl_.event_data_.tts_completed_;
}
inline ::unhinged::cdc::TTSCompleted* AudioEvent::mutable_tts_completed() {
  ::unhinged::cdc::TTSCompleted* _msg = _internal_mutable_tts_completed();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.AudioEvent.tts_completed)
  return _msg;
}

// .unhinged.cdc.STTCompleted stt_completed = 12;
inline bool AudioEvent::_internal_has_stt_completed() const {
  return event_data_case() == kSttCompleted;
}
inline bool AudioEvent::has_stt_completed() const {
  return _internal_has_stt_completed();
}
inline void AudioEvent::set_has_stt_completed() {
  _impl_._oneof_case_[0] = kSttCompleted;
}
inline void AudioEvent::clear_stt_completed() {
  if (_internal_has_stt_completed()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_data_.stt_completed_;
    }
    clear_has_event_data();
  }
}
inline ::unhinged::cdc::STTCompleted* AudioEvent::release_stt_completed() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.AudioEvent.stt_completed)
  if (_internal_has_stt_completed()) {
    clear_has_event_data();
    ::unhinged::cdc::STTCompleted* temp = _impl_.event_data_.stt_completed_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_data_.stt_completed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::cdc::STTCompleted& AudioEvent::_internal_stt_completed() const {
  return _internal_has_stt_completed()
      ? *_impl_.event_data_.stt_completed_
      : reinterpret_cast< ::unhinged::cdc::STTCompleted&>(::unhinged::cdc::_STTCompleted_default_instance_);
}
inline const ::unhinged::cdc::STTCompleted& AudioEvent::stt_completed() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.AudioEvent.stt_completed)
  return _internal_stt_completed();
}
inline ::unhinged::cdc::STTCompleted* AudioEvent::unsafe_arena_release_stt_completed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.cdc.AudioEvent.stt_completed)
  if (_internal_has_stt_completed()) {
    clear_has_event_data();
    ::unhinged::cdc::STTCompleted* temp = _impl_.event_data_.stt_completed_;
    _impl_.event_data_.stt_completed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AudioEvent::unsafe_arena_set_allocated_stt_completed(::unhinged::cdc::STTCompleted* stt_completed) {
  clear_event_data();
  if (stt_completed) {
    set_has_stt_completed();
    _impl_.event_data_.stt_completed_ = stt_completed;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.AudioEvent.stt_completed)
}
inline ::unhinged::cdc::STTCompleted* AudioEvent::_internal_mutable_stt_completed() {
  if (!_internal_has_stt_completed()) {
    clear_event_data();
    set_has_stt_completed();
    _impl_.event_data_.stt_completed_ = CreateMaybeMessage< ::unhinged::cdc::STTCompleted >(GetArenaForAllocation());
  }
  return _impl_.event_data_.stt_completed_;
}
inline ::unhinged::cdc::STTCompleted* AudioEvent::mutable_stt_completed() {
  ::unhinged::cdc::STTCompleted* _msg = _internal_mutable_stt_completed();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.AudioEvent.stt_completed)
  return _msg;
}

inline bool AudioEvent::has_event_data() const {
  return event_data_case() != EVENT_DATA_NOT_SET;
}
inline void AudioEvent::clear_has_event_data() {
  _impl_._oneof_case_[0] = EVENT_DATA_NOT_SET;
}
inline AudioEvent::EventDataCase AudioEvent::event_data_case() const {
  return AudioEvent::EventDataCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// TTSStarted

// string text = 1;
inline void TTSStarted::clear_text() {
  _impl_.text_.ClearToEmpty();
}
inline const std::string& TTSStarted::text() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.TTSStarted.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TTSStarted::set_text(ArgT0&& arg0, ArgT... args) {
 
 _impl_.text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.TTSStarted.text)
}
inline std::string* TTSStarted::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.TTSStarted.text)
  return _s;
}
inline const std::string& TTSStarted::_internal_text() const {
  return _impl_.text_.Get();
}
inline void TTSStarted::_internal_set_text(const std::string& value) {
  
  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* TTSStarted::_internal_mutable_text() {
  
  return _impl_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* TTSStarted::release_text() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.TTSStarted.text)
  return _impl_.text_.Release();
}
inline void TTSStarted::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  _impl_.text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.TTSStarted.text)
}

// string voice_id = 2;
inline void TTSStarted::clear_voice_id() {
  _impl_.voice_id_.ClearToEmpty();
}
inline const std::string& TTSStarted::voice_id() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.TTSStarted.voice_id)
  return _internal_voice_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TTSStarted::set_voice_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.voice_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.TTSStarted.voice_id)
}
inline std::string* TTSStarted::mutable_voice_id() {
  std::string* _s = _internal_mutable_voice_id();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.TTSStarted.voice_id)
  return _s;
}
inline const std::string& TTSStarted::_internal_voice_id() const {
  return _impl_.voice_id_.Get();
}
inline void TTSStarted::_internal_set_voice_id(const std::string& value) {
  
  _impl_.voice_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TTSStarted::_internal_mutable_voice_id() {
  
  return _impl_.voice_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TTSStarted::release_voice_id() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.TTSStarted.voice_id)
  return _impl_.voice_id_.Release();
}
inline void TTSStarted::set_allocated_voice_id(std::string* voice_id) {
  if (voice_id != nullptr) {
    
  } else {
    
  }
  _impl_.voice_id_.SetAllocated(voice_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.voice_id_.IsDefault()) {
    _impl_.voice_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.TTSStarted.voice_id)
}

// -------------------------------------------------------------------

// TTSCompleted

// string audio_url = 1;
inline void TTSCompleted::clear_audio_url() {
  _impl_.audio_url_.ClearToEmpty();
}
inline const std::string& TTSCompleted::audio_url() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.TTSCompleted.audio_url)
  return _internal_audio_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TTSCompleted::set_audio_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.audio_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.TTSCompleted.audio_url)
}
inline std::string* TTSCompleted::mutable_audio_url() {
  std::string* _s = _internal_mutable_audio_url();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.TTSCompleted.audio_url)
  return _s;
}
inline const std::string& TTSCompleted::_internal_audio_url() const {
  return _impl_.audio_url_.Get();
}
inline void TTSCompleted::_internal_set_audio_url(const std::string& value) {
  
  _impl_.audio_url_.Set(value, GetArenaForAllocation());
}
inline std::string* TTSCompleted::_internal_mutable_audio_url() {
  
  return _impl_.audio_url_.Mutable(GetArenaForAllocation());
}
inline std::string* TTSCompleted::release_audio_url() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.TTSCompleted.audio_url)
  return _impl_.audio_url_.Release();
}
inline void TTSCompleted::set_allocated_audio_url(std::string* audio_url) {
  if (audio_url != nullptr) {
    
  } else {
    
  }
  _impl_.audio_url_.SetAllocated(audio_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.audio_url_.IsDefault()) {
    _impl_.audio_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.TTSCompleted.audio_url)
}

// float duration_seconds = 2;
inline void TTSCompleted::clear_duration_seconds() {
  _impl_.duration_seconds_ = 0;
}
inline float TTSCompleted::_internal_duration_seconds() const {
  return _impl_.duration_seconds_;
}
inline float TTSCompleted::duration_seconds() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.TTSCompleted.duration_seconds)
  return _internal_duration_seconds();
}
inline void TTSCompleted::_internal_set_duration_seconds(float value) {
  
  _impl_.duration_seconds_ = value;
}
inline void TTSCompleted::set_duration_seconds(float value) {
  _internal_set_duration_seconds(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.TTSCompleted.duration_seconds)
}

// -------------------------------------------------------------------

// STTCompleted

// string transcript = 1;
inline void STTCompleted::clear_transcript() {
  _impl_.transcript_.ClearToEmpty();
}
inline const std::string& STTCompleted::transcript() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.STTCompleted.transcript)
  return _internal_transcript();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void STTCompleted::set_transcript(ArgT0&& arg0, ArgT... args) {
 
 _impl_.transcript_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.STTCompleted.transcript)
}
inline std::string* STTCompleted::mutable_transcript() {
  std::string* _s = _internal_mutable_transcript();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.STTCompleted.transcript)
  return _s;
}
inline const std::string& STTCompleted::_internal_transcript() const {
  return _impl_.transcript_.Get();
}
inline void STTCompleted::_internal_set_transcript(const std::string& value) {
  
  _impl_.transcript_.Set(value, GetArenaForAllocation());
}
inline std::string* STTCompleted::_internal_mutable_transcript() {
  
  return _impl_.transcript_.Mutable(GetArenaForAllocation());
}
inline std::string* STTCompleted::release_transcript() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.STTCompleted.transcript)
  return _impl_.transcript_.Release();
}
inline void STTCompleted::set_allocated_transcript(std::string* transcript) {
  if (transcript != nullptr) {
    
  } else {
    
  }
  _impl_.transcript_.SetAllocated(transcript, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.transcript_.IsDefault()) {
    _impl_.transcript_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.STTCompleted.transcript)
}

// float confidence = 2;
inline void STTCompleted::clear_confidence() {
  _impl_.confidence_ = 0;
}
inline float STTCompleted::_internal_confidence() const {
  return _impl_.confidence_;
}
inline float STTCompleted::confidence() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.STTCompleted.confidence)
  return _internal_confidence();
}
inline void STTCompleted::_internal_set_confidence(float value) {
  
  _impl_.confidence_ = value;
}
inline void STTCompleted::set_confidence(float value) {
  _internal_set_confidence(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.STTCompleted.confidence)
}

// -------------------------------------------------------------------

// UserEvent

// string user_id = 1;
inline void UserEvent::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& UserEvent::user_id() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.UserEvent.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserEvent::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.UserEvent.user_id)
}
inline std::string* UserEvent::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.UserEvent.user_id)
  return _s;
}
inline const std::string& UserEvent::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void UserEvent::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UserEvent::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* UserEvent::release_user_id() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.UserEvent.user_id)
  return _impl_.user_id_.Release();
}
inline void UserEvent::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.UserEvent.user_id)
}

// .unhinged.cdc.UserEventType event_type = 2;
inline void UserEvent::clear_event_type() {
  _impl_.event_type_ = 0;
}
inline ::unhinged::cdc::UserEventType UserEvent::_internal_event_type() const {
  return static_cast< ::unhinged::cdc::UserEventType >(_impl_.event_type_);
}
inline ::unhinged::cdc::UserEventType UserEvent::event_type() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.UserEvent.event_type)
  return _internal_event_type();
}
inline void UserEvent::_internal_set_event_type(::unhinged::cdc::UserEventType value) {
  
  _impl_.event_type_ = value;
}
inline void UserEvent::set_event_type(::unhinged::cdc::UserEventType value) {
  _internal_set_event_type(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.UserEvent.event_type)
}

// .unhinged.cdc.UserCreated user_created = 10;
inline bool UserEvent::_internal_has_user_created() const {
  return event_data_case() == kUserCreated;
}
inline bool UserEvent::has_user_created() const {
  return _internal_has_user_created();
}
inline void UserEvent::set_has_user_created() {
  _impl_._oneof_case_[0] = kUserCreated;
}
inline void UserEvent::clear_user_created() {
  if (_internal_has_user_created()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_data_.user_created_;
    }
    clear_has_event_data();
  }
}
inline ::unhinged::cdc::UserCreated* UserEvent::release_user_created() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.UserEvent.user_created)
  if (_internal_has_user_created()) {
    clear_has_event_data();
    ::unhinged::cdc::UserCreated* temp = _impl_.event_data_.user_created_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_data_.user_created_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::cdc::UserCreated& UserEvent::_internal_user_created() const {
  return _internal_has_user_created()
      ? *_impl_.event_data_.user_created_
      : reinterpret_cast< ::unhinged::cdc::UserCreated&>(::unhinged::cdc::_UserCreated_default_instance_);
}
inline const ::unhinged::cdc::UserCreated& UserEvent::user_created() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.UserEvent.user_created)
  return _internal_user_created();
}
inline ::unhinged::cdc::UserCreated* UserEvent::unsafe_arena_release_user_created() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.cdc.UserEvent.user_created)
  if (_internal_has_user_created()) {
    clear_has_event_data();
    ::unhinged::cdc::UserCreated* temp = _impl_.event_data_.user_created_;
    _impl_.event_data_.user_created_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UserEvent::unsafe_arena_set_allocated_user_created(::unhinged::cdc::UserCreated* user_created) {
  clear_event_data();
  if (user_created) {
    set_has_user_created();
    _impl_.event_data_.user_created_ = user_created;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.UserEvent.user_created)
}
inline ::unhinged::cdc::UserCreated* UserEvent::_internal_mutable_user_created() {
  if (!_internal_has_user_created()) {
    clear_event_data();
    set_has_user_created();
    _impl_.event_data_.user_created_ = CreateMaybeMessage< ::unhinged::cdc::UserCreated >(GetArenaForAllocation());
  }
  return _impl_.event_data_.user_created_;
}
inline ::unhinged::cdc::UserCreated* UserEvent::mutable_user_created() {
  ::unhinged::cdc::UserCreated* _msg = _internal_mutable_user_created();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.UserEvent.user_created)
  return _msg;
}

// .unhinged.cdc.UserLoggedIn user_logged_in = 11;
inline bool UserEvent::_internal_has_user_logged_in() const {
  return event_data_case() == kUserLoggedIn;
}
inline bool UserEvent::has_user_logged_in() const {
  return _internal_has_user_logged_in();
}
inline void UserEvent::set_has_user_logged_in() {
  _impl_._oneof_case_[0] = kUserLoggedIn;
}
inline void UserEvent::clear_user_logged_in() {
  if (_internal_has_user_logged_in()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_data_.user_logged_in_;
    }
    clear_has_event_data();
  }
}
inline ::unhinged::cdc::UserLoggedIn* UserEvent::release_user_logged_in() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.UserEvent.user_logged_in)
  if (_internal_has_user_logged_in()) {
    clear_has_event_data();
    ::unhinged::cdc::UserLoggedIn* temp = _impl_.event_data_.user_logged_in_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_data_.user_logged_in_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::cdc::UserLoggedIn& UserEvent::_internal_user_logged_in() const {
  return _internal_has_user_logged_in()
      ? *_impl_.event_data_.user_logged_in_
      : reinterpret_cast< ::unhinged::cdc::UserLoggedIn&>(::unhinged::cdc::_UserLoggedIn_default_instance_);
}
inline const ::unhinged::cdc::UserLoggedIn& UserEvent::user_logged_in() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.UserEvent.user_logged_in)
  return _internal_user_logged_in();
}
inline ::unhinged::cdc::UserLoggedIn* UserEvent::unsafe_arena_release_user_logged_in() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.cdc.UserEvent.user_logged_in)
  if (_internal_has_user_logged_in()) {
    clear_has_event_data();
    ::unhinged::cdc::UserLoggedIn* temp = _impl_.event_data_.user_logged_in_;
    _impl_.event_data_.user_logged_in_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UserEvent::unsafe_arena_set_allocated_user_logged_in(::unhinged::cdc::UserLoggedIn* user_logged_in) {
  clear_event_data();
  if (user_logged_in) {
    set_has_user_logged_in();
    _impl_.event_data_.user_logged_in_ = user_logged_in;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.UserEvent.user_logged_in)
}
inline ::unhinged::cdc::UserLoggedIn* UserEvent::_internal_mutable_user_logged_in() {
  if (!_internal_has_user_logged_in()) {
    clear_event_data();
    set_has_user_logged_in();
    _impl_.event_data_.user_logged_in_ = CreateMaybeMessage< ::unhinged::cdc::UserLoggedIn >(GetArenaForAllocation());
  }
  return _impl_.event_data_.user_logged_in_;
}
inline ::unhinged::cdc::UserLoggedIn* UserEvent::mutable_user_logged_in() {
  ::unhinged::cdc::UserLoggedIn* _msg = _internal_mutable_user_logged_in();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.UserEvent.user_logged_in)
  return _msg;
}

// .unhinged.cdc.TeamMemberAdded team_member_added = 12;
inline bool UserEvent::_internal_has_team_member_added() const {
  return event_data_case() == kTeamMemberAdded;
}
inline bool UserEvent::has_team_member_added() const {
  return _internal_has_team_member_added();
}
inline void UserEvent::set_has_team_member_added() {
  _impl_._oneof_case_[0] = kTeamMemberAdded;
}
inline void UserEvent::clear_team_member_added() {
  if (_internal_has_team_member_added()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_data_.team_member_added_;
    }
    clear_has_event_data();
  }
}
inline ::unhinged::cdc::TeamMemberAdded* UserEvent::release_team_member_added() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.UserEvent.team_member_added)
  if (_internal_has_team_member_added()) {
    clear_has_event_data();
    ::unhinged::cdc::TeamMemberAdded* temp = _impl_.event_data_.team_member_added_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_data_.team_member_added_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::cdc::TeamMemberAdded& UserEvent::_internal_team_member_added() const {
  return _internal_has_team_member_added()
      ? *_impl_.event_data_.team_member_added_
      : reinterpret_cast< ::unhinged::cdc::TeamMemberAdded&>(::unhinged::cdc::_TeamMemberAdded_default_instance_);
}
inline const ::unhinged::cdc::TeamMemberAdded& UserEvent::team_member_added() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.UserEvent.team_member_added)
  return _internal_team_member_added();
}
inline ::unhinged::cdc::TeamMemberAdded* UserEvent::unsafe_arena_release_team_member_added() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.cdc.UserEvent.team_member_added)
  if (_internal_has_team_member_added()) {
    clear_has_event_data();
    ::unhinged::cdc::TeamMemberAdded* temp = _impl_.event_data_.team_member_added_;
    _impl_.event_data_.team_member_added_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UserEvent::unsafe_arena_set_allocated_team_member_added(::unhinged::cdc::TeamMemberAdded* team_member_added) {
  clear_event_data();
  if (team_member_added) {
    set_has_team_member_added();
    _impl_.event_data_.team_member_added_ = team_member_added;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.UserEvent.team_member_added)
}
inline ::unhinged::cdc::TeamMemberAdded* UserEvent::_internal_mutable_team_member_added() {
  if (!_internal_has_team_member_added()) {
    clear_event_data();
    set_has_team_member_added();
    _impl_.event_data_.team_member_added_ = CreateMaybeMessage< ::unhinged::cdc::TeamMemberAdded >(GetArenaForAllocation());
  }
  return _impl_.event_data_.team_member_added_;
}
inline ::unhinged::cdc::TeamMemberAdded* UserEvent::mutable_team_member_added() {
  ::unhinged::cdc::TeamMemberAdded* _msg = _internal_mutable_team_member_added();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.UserEvent.team_member_added)
  return _msg;
}

inline bool UserEvent::has_event_data() const {
  return event_data_case() != EVENT_DATA_NOT_SET;
}
inline void UserEvent::clear_has_event_data() {
  _impl_._oneof_case_[0] = EVENT_DATA_NOT_SET;
}
inline UserEvent::EventDataCase UserEvent::event_data_case() const {
  return UserEvent::EventDataCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// UserCreated

// string email = 1;
inline void UserCreated::clear_email() {
  _impl_.email_.ClearToEmpty();
}
inline const std::string& UserCreated::email() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.UserCreated.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserCreated::set_email(ArgT0&& arg0, ArgT... args) {
 
 _impl_.email_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.UserCreated.email)
}
inline std::string* UserCreated::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.UserCreated.email)
  return _s;
}
inline const std::string& UserCreated::_internal_email() const {
  return _impl_.email_.Get();
}
inline void UserCreated::_internal_set_email(const std::string& value) {
  
  _impl_.email_.Set(value, GetArenaForAllocation());
}
inline std::string* UserCreated::_internal_mutable_email() {
  
  return _impl_.email_.Mutable(GetArenaForAllocation());
}
inline std::string* UserCreated::release_email() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.UserCreated.email)
  return _impl_.email_.Release();
}
inline void UserCreated::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  _impl_.email_.SetAllocated(email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.email_.IsDefault()) {
    _impl_.email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.UserCreated.email)
}

// string name = 2;
inline void UserCreated::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& UserCreated::name() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.UserCreated.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserCreated::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.UserCreated.name)
}
inline std::string* UserCreated::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.UserCreated.name)
  return _s;
}
inline const std::string& UserCreated::_internal_name() const {
  return _impl_.name_.Get();
}
inline void UserCreated::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* UserCreated::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* UserCreated::release_name() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.UserCreated.name)
  return _impl_.name_.Release();
}
inline void UserCreated::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.UserCreated.name)
}

// -------------------------------------------------------------------

// UserLoggedIn

// string ip_address = 1;
inline void UserLoggedIn::clear_ip_address() {
  _impl_.ip_address_.ClearToEmpty();
}
inline const std::string& UserLoggedIn::ip_address() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.UserLoggedIn.ip_address)
  return _internal_ip_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserLoggedIn::set_ip_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ip_address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.UserLoggedIn.ip_address)
}
inline std::string* UserLoggedIn::mutable_ip_address() {
  std::string* _s = _internal_mutable_ip_address();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.UserLoggedIn.ip_address)
  return _s;
}
inline const std::string& UserLoggedIn::_internal_ip_address() const {
  return _impl_.ip_address_.Get();
}
inline void UserLoggedIn::_internal_set_ip_address(const std::string& value) {
  
  _impl_.ip_address_.Set(value, GetArenaForAllocation());
}
inline std::string* UserLoggedIn::_internal_mutable_ip_address() {
  
  return _impl_.ip_address_.Mutable(GetArenaForAllocation());
}
inline std::string* UserLoggedIn::release_ip_address() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.UserLoggedIn.ip_address)
  return _impl_.ip_address_.Release();
}
inline void UserLoggedIn::set_allocated_ip_address(std::string* ip_address) {
  if (ip_address != nullptr) {
    
  } else {
    
  }
  _impl_.ip_address_.SetAllocated(ip_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ip_address_.IsDefault()) {
    _impl_.ip_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.UserLoggedIn.ip_address)
}

// string user_agent = 2;
inline void UserLoggedIn::clear_user_agent() {
  _impl_.user_agent_.ClearToEmpty();
}
inline const std::string& UserLoggedIn::user_agent() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.UserLoggedIn.user_agent)
  return _internal_user_agent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserLoggedIn::set_user_agent(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_agent_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.UserLoggedIn.user_agent)
}
inline std::string* UserLoggedIn::mutable_user_agent() {
  std::string* _s = _internal_mutable_user_agent();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.UserLoggedIn.user_agent)
  return _s;
}
inline const std::string& UserLoggedIn::_internal_user_agent() const {
  return _impl_.user_agent_.Get();
}
inline void UserLoggedIn::_internal_set_user_agent(const std::string& value) {
  
  _impl_.user_agent_.Set(value, GetArenaForAllocation());
}
inline std::string* UserLoggedIn::_internal_mutable_user_agent() {
  
  return _impl_.user_agent_.Mutable(GetArenaForAllocation());
}
inline std::string* UserLoggedIn::release_user_agent() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.UserLoggedIn.user_agent)
  return _impl_.user_agent_.Release();
}
inline void UserLoggedIn::set_allocated_user_agent(std::string* user_agent) {
  if (user_agent != nullptr) {
    
  } else {
    
  }
  _impl_.user_agent_.SetAllocated(user_agent, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_agent_.IsDefault()) {
    _impl_.user_agent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.UserLoggedIn.user_agent)
}

// -------------------------------------------------------------------

// TeamMemberAdded

// string team_id = 1;
inline void TeamMemberAdded::clear_team_id() {
  _impl_.team_id_.ClearToEmpty();
}
inline const std::string& TeamMemberAdded::team_id() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.TeamMemberAdded.team_id)
  return _internal_team_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TeamMemberAdded::set_team_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.team_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.TeamMemberAdded.team_id)
}
inline std::string* TeamMemberAdded::mutable_team_id() {
  std::string* _s = _internal_mutable_team_id();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.TeamMemberAdded.team_id)
  return _s;
}
inline const std::string& TeamMemberAdded::_internal_team_id() const {
  return _impl_.team_id_.Get();
}
inline void TeamMemberAdded::_internal_set_team_id(const std::string& value) {
  
  _impl_.team_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TeamMemberAdded::_internal_mutable_team_id() {
  
  return _impl_.team_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TeamMemberAdded::release_team_id() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.TeamMemberAdded.team_id)
  return _impl_.team_id_.Release();
}
inline void TeamMemberAdded::set_allocated_team_id(std::string* team_id) {
  if (team_id != nullptr) {
    
  } else {
    
  }
  _impl_.team_id_.SetAllocated(team_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.team_id_.IsDefault()) {
    _impl_.team_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.TeamMemberAdded.team_id)
}

// string role = 2;
inline void TeamMemberAdded::clear_role() {
  _impl_.role_.ClearToEmpty();
}
inline const std::string& TeamMemberAdded::role() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.TeamMemberAdded.role)
  return _internal_role();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TeamMemberAdded::set_role(ArgT0&& arg0, ArgT... args) {
 
 _impl_.role_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.TeamMemberAdded.role)
}
inline std::string* TeamMemberAdded::mutable_role() {
  std::string* _s = _internal_mutable_role();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.TeamMemberAdded.role)
  return _s;
}
inline const std::string& TeamMemberAdded::_internal_role() const {
  return _impl_.role_.Get();
}
inline void TeamMemberAdded::_internal_set_role(const std::string& value) {
  
  _impl_.role_.Set(value, GetArenaForAllocation());
}
inline std::string* TeamMemberAdded::_internal_mutable_role() {
  
  return _impl_.role_.Mutable(GetArenaForAllocation());
}
inline std::string* TeamMemberAdded::release_role() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.TeamMemberAdded.role)
  return _impl_.role_.Release();
}
inline void TeamMemberAdded::set_allocated_role(std::string* role) {
  if (role != nullptr) {
    
  } else {
    
  }
  _impl_.role_.SetAllocated(role, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.role_.IsDefault()) {
    _impl_.role_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.TeamMemberAdded.role)
}

// string added_by = 3;
inline void TeamMemberAdded::clear_added_by() {
  _impl_.added_by_.ClearToEmpty();
}
inline const std::string& TeamMemberAdded::added_by() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.TeamMemberAdded.added_by)
  return _internal_added_by();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TeamMemberAdded::set_added_by(ArgT0&& arg0, ArgT... args) {
 
 _impl_.added_by_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.TeamMemberAdded.added_by)
}
inline std::string* TeamMemberAdded::mutable_added_by() {
  std::string* _s = _internal_mutable_added_by();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.TeamMemberAdded.added_by)
  return _s;
}
inline const std::string& TeamMemberAdded::_internal_added_by() const {
  return _impl_.added_by_.Get();
}
inline void TeamMemberAdded::_internal_set_added_by(const std::string& value) {
  
  _impl_.added_by_.Set(value, GetArenaForAllocation());
}
inline std::string* TeamMemberAdded::_internal_mutable_added_by() {
  
  return _impl_.added_by_.Mutable(GetArenaForAllocation());
}
inline std::string* TeamMemberAdded::release_added_by() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.TeamMemberAdded.added_by)
  return _impl_.added_by_.Release();
}
inline void TeamMemberAdded::set_allocated_added_by(std::string* added_by) {
  if (added_by != nullptr) {
    
  } else {
    
  }
  _impl_.added_by_.SetAllocated(added_by, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.added_by_.IsDefault()) {
    _impl_.added_by_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.TeamMemberAdded.added_by)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace cdc
}  // namespace unhinged

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::unhinged::cdc::DocumentEventType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::unhinged::cdc::DocumentEventType>() {
  return ::unhinged::cdc::DocumentEventType_descriptor();
}
template <> struct is_proto_enum< ::unhinged::cdc::LLMEventType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::unhinged::cdc::LLMEventType>() {
  return ::unhinged::cdc::LLMEventType_descriptor();
}
template <> struct is_proto_enum< ::unhinged::cdc::AgentEventType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::unhinged::cdc::AgentEventType>() {
  return ::unhinged::cdc::AgentEventType_descriptor();
}
template <> struct is_proto_enum< ::unhinged::cdc::SessionEventType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::unhinged::cdc::SessionEventType>() {
  return ::unhinged::cdc::SessionEventType_descriptor();
}
template <> struct is_proto_enum< ::unhinged::cdc::SystemEventType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::unhinged::cdc::SystemEventType>() {
  return ::unhinged::cdc::SystemEventType_descriptor();
}
template <> struct is_proto_enum< ::unhinged::cdc::WorkflowEventType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::unhinged::cdc::WorkflowEventType>() {
  return ::unhinged::cdc::WorkflowEventType_descriptor();
}
template <> struct is_proto_enum< ::unhinged::cdc::ChatEventType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::unhinged::cdc::ChatEventType>() {
  return ::unhinged::cdc::ChatEventType_descriptor();
}
template <> struct is_proto_enum< ::unhinged::cdc::AudioEventType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::unhinged::cdc::AudioEventType>() {
  return ::unhinged::cdc::AudioEventType_descriptor();
}
template <> struct is_proto_enum< ::unhinged::cdc::UserEventType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::unhinged::cdc::UserEventType>() {
  return ::unhinged::cdc::UserEventType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_cdc_5fevents_2eproto
