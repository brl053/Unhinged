// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: observability.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_observability_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_observability_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
#include <google/protobuf/any.pb.h>
#include <google/protobuf/struct.pb.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_observability_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_observability_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_observability_2eproto;
namespace unhinged {
namespace observability {
namespace v1 {
class DataLakeOptions;
struct DataLakeOptionsDefaultTypeInternal;
extern DataLakeOptionsDefaultTypeInternal _DataLakeOptions_default_instance_;
class DestinationFlags;
struct DestinationFlagsDefaultTypeInternal;
extern DestinationFlagsDefaultTypeInternal _DestinationFlags_default_instance_;
class ErrorInfo;
struct ErrorInfoDefaultTypeInternal;
extern ErrorInfoDefaultTypeInternal _ErrorInfo_default_instance_;
class ErrorInfo_ErrorAttributesEntry_DoNotUse;
struct ErrorInfo_ErrorAttributesEntry_DoNotUseDefaultTypeInternal;
extern ErrorInfo_ErrorAttributesEntry_DoNotUseDefaultTypeInternal _ErrorInfo_ErrorAttributesEntry_DoNotUse_default_instance_;
class LogEvent;
struct LogEventDefaultTypeInternal;
extern LogEventDefaultTypeInternal _LogEvent_default_instance_;
class PartitionInfo;
struct PartitionInfoDefaultTypeInternal;
extern PartitionInfoDefaultTypeInternal _PartitionInfo_default_instance_;
class PartitionInfo_CustomPartitionsEntry_DoNotUse;
struct PartitionInfo_CustomPartitionsEntry_DoNotUseDefaultTypeInternal;
extern PartitionInfo_CustomPartitionsEntry_DoNotUseDefaultTypeInternal _PartitionInfo_CustomPartitionsEntry_DoNotUse_default_instance_;
class Resource;
struct ResourceDefaultTypeInternal;
extern ResourceDefaultTypeInternal _Resource_default_instance_;
class Resource_AttributesEntry_DoNotUse;
struct Resource_AttributesEntry_DoNotUseDefaultTypeInternal;
extern Resource_AttributesEntry_DoNotUseDefaultTypeInternal _Resource_AttributesEntry_DoNotUse_default_instance_;
class TraceContext;
struct TraceContextDefaultTypeInternal;
extern TraceContextDefaultTypeInternal _TraceContext_default_instance_;
class TraceFlags;
struct TraceFlagsDefaultTypeInternal;
extern TraceFlagsDefaultTypeInternal _TraceFlags_default_instance_;
}  // namespace v1
}  // namespace observability
}  // namespace unhinged
PROTOBUF_NAMESPACE_OPEN
template<> ::unhinged::observability::v1::DataLakeOptions* Arena::CreateMaybeMessage<::unhinged::observability::v1::DataLakeOptions>(Arena*);
template<> ::unhinged::observability::v1::DestinationFlags* Arena::CreateMaybeMessage<::unhinged::observability::v1::DestinationFlags>(Arena*);
template<> ::unhinged::observability::v1::ErrorInfo* Arena::CreateMaybeMessage<::unhinged::observability::v1::ErrorInfo>(Arena*);
template<> ::unhinged::observability::v1::ErrorInfo_ErrorAttributesEntry_DoNotUse* Arena::CreateMaybeMessage<::unhinged::observability::v1::ErrorInfo_ErrorAttributesEntry_DoNotUse>(Arena*);
template<> ::unhinged::observability::v1::LogEvent* Arena::CreateMaybeMessage<::unhinged::observability::v1::LogEvent>(Arena*);
template<> ::unhinged::observability::v1::PartitionInfo* Arena::CreateMaybeMessage<::unhinged::observability::v1::PartitionInfo>(Arena*);
template<> ::unhinged::observability::v1::PartitionInfo_CustomPartitionsEntry_DoNotUse* Arena::CreateMaybeMessage<::unhinged::observability::v1::PartitionInfo_CustomPartitionsEntry_DoNotUse>(Arena*);
template<> ::unhinged::observability::v1::Resource* Arena::CreateMaybeMessage<::unhinged::observability::v1::Resource>(Arena*);
template<> ::unhinged::observability::v1::Resource_AttributesEntry_DoNotUse* Arena::CreateMaybeMessage<::unhinged::observability::v1::Resource_AttributesEntry_DoNotUse>(Arena*);
template<> ::unhinged::observability::v1::TraceContext* Arena::CreateMaybeMessage<::unhinged::observability::v1::TraceContext>(Arena*);
template<> ::unhinged::observability::v1::TraceFlags* Arena::CreateMaybeMessage<::unhinged::observability::v1::TraceFlags>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace unhinged {
namespace observability {
namespace v1 {

enum LogLevel : int {
  LOG_LEVEL_UNSPECIFIED = 0,
  LOG_LEVEL_TRACE = 1,
  LOG_LEVEL_DEBUG = 2,
  LOG_LEVEL_INFO = 3,
  LOG_LEVEL_WARN = 4,
  LOG_LEVEL_ERROR = 5,
  LOG_LEVEL_FATAL = 6,
  LogLevel_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  LogLevel_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool LogLevel_IsValid(int value);
constexpr LogLevel LogLevel_MIN = LOG_LEVEL_UNSPECIFIED;
constexpr LogLevel LogLevel_MAX = LOG_LEVEL_FATAL;
constexpr int LogLevel_ARRAYSIZE = LogLevel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LogLevel_descriptor();
template<typename T>
inline const std::string& LogLevel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LogLevel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LogLevel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LogLevel_descriptor(), enum_t_value);
}
inline bool LogLevel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LogLevel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LogLevel>(
    LogLevel_descriptor(), name, value);
}
enum CompressionType : int {
  COMPRESSION_UNSPECIFIED = 0,
  COMPRESSION_NONE = 1,
  COMPRESSION_GZIP = 2,
  COMPRESSION_SNAPPY = 3,
  COMPRESSION_LZ4 = 4,
  COMPRESSION_ZSTD = 5,
  CompressionType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CompressionType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CompressionType_IsValid(int value);
constexpr CompressionType CompressionType_MIN = COMPRESSION_UNSPECIFIED;
constexpr CompressionType CompressionType_MAX = COMPRESSION_ZSTD;
constexpr int CompressionType_ARRAYSIZE = CompressionType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CompressionType_descriptor();
template<typename T>
inline const std::string& CompressionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CompressionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CompressionType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CompressionType_descriptor(), enum_t_value);
}
inline bool CompressionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CompressionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CompressionType>(
    CompressionType_descriptor(), name, value);
}
// ===================================================================

class TraceContext final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.observability.v1.TraceContext) */ {
 public:
  inline TraceContext() : TraceContext(nullptr) {}
  ~TraceContext() override;
  explicit PROTOBUF_CONSTEXPR TraceContext(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TraceContext(const TraceContext& from);
  TraceContext(TraceContext&& from) noexcept
    : TraceContext() {
    *this = ::std::move(from);
  }

  inline TraceContext& operator=(const TraceContext& from) {
    CopyFrom(from);
    return *this;
  }
  inline TraceContext& operator=(TraceContext&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TraceContext& default_instance() {
    return *internal_default_instance();
  }
  static inline const TraceContext* internal_default_instance() {
    return reinterpret_cast<const TraceContext*>(
               &_TraceContext_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(TraceContext& a, TraceContext& b) {
    a.Swap(&b);
  }
  inline void Swap(TraceContext* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TraceContext* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TraceContext* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TraceContext>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TraceContext& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TraceContext& from) {
    TraceContext::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TraceContext* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.observability.v1.TraceContext";
  }
  protected:
  explicit TraceContext(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTraceIdFieldNumber = 1,
    kSpanIdFieldNumber = 2,
    kParentSpanIdFieldNumber = 3,
    kTraceStateFieldNumber = 5,
    kCorrelationIdFieldNumber = 10,
    kRequestIdFieldNumber = 11,
    kSessionIdFieldNumber = 12,
    kUserIdFieldNumber = 13,
    kTraceFlagsFieldNumber = 4,
  };
  // string trace_id = 1;
  void clear_trace_id();
  const std::string& trace_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_trace_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_trace_id();
  PROTOBUF_NODISCARD std::string* release_trace_id();
  void set_allocated_trace_id(std::string* trace_id);
  private:
  const std::string& _internal_trace_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trace_id(const std::string& value);
  std::string* _internal_mutable_trace_id();
  public:

  // string span_id = 2;
  void clear_span_id();
  const std::string& span_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_span_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_span_id();
  PROTOBUF_NODISCARD std::string* release_span_id();
  void set_allocated_span_id(std::string* span_id);
  private:
  const std::string& _internal_span_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_span_id(const std::string& value);
  std::string* _internal_mutable_span_id();
  public:

  // string parent_span_id = 3;
  void clear_parent_span_id();
  const std::string& parent_span_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent_span_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent_span_id();
  PROTOBUF_NODISCARD std::string* release_parent_span_id();
  void set_allocated_parent_span_id(std::string* parent_span_id);
  private:
  const std::string& _internal_parent_span_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent_span_id(const std::string& value);
  std::string* _internal_mutable_parent_span_id();
  public:

  // string trace_state = 5;
  void clear_trace_state();
  const std::string& trace_state() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_trace_state(ArgT0&& arg0, ArgT... args);
  std::string* mutable_trace_state();
  PROTOBUF_NODISCARD std::string* release_trace_state();
  void set_allocated_trace_state(std::string* trace_state);
  private:
  const std::string& _internal_trace_state() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trace_state(const std::string& value);
  std::string* _internal_mutable_trace_state();
  public:

  // string correlation_id = 10;
  void clear_correlation_id();
  const std::string& correlation_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_correlation_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_correlation_id();
  PROTOBUF_NODISCARD std::string* release_correlation_id();
  void set_allocated_correlation_id(std::string* correlation_id);
  private:
  const std::string& _internal_correlation_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_correlation_id(const std::string& value);
  std::string* _internal_mutable_correlation_id();
  public:

  // string request_id = 11;
  void clear_request_id();
  const std::string& request_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_request_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_request_id();
  PROTOBUF_NODISCARD std::string* release_request_id();
  void set_allocated_request_id(std::string* request_id);
  private:
  const std::string& _internal_request_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_id(const std::string& value);
  std::string* _internal_mutable_request_id();
  public:

  // string session_id = 12;
  void clear_session_id();
  const std::string& session_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // string user_id = 13;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // .unhinged.observability.v1.TraceFlags trace_flags = 4;
  bool has_trace_flags() const;
  private:
  bool _internal_has_trace_flags() const;
  public:
  void clear_trace_flags();
  const ::unhinged::observability::v1::TraceFlags& trace_flags() const;
  PROTOBUF_NODISCARD ::unhinged::observability::v1::TraceFlags* release_trace_flags();
  ::unhinged::observability::v1::TraceFlags* mutable_trace_flags();
  void set_allocated_trace_flags(::unhinged::observability::v1::TraceFlags* trace_flags);
  private:
  const ::unhinged::observability::v1::TraceFlags& _internal_trace_flags() const;
  ::unhinged::observability::v1::TraceFlags* _internal_mutable_trace_flags();
  public:
  void unsafe_arena_set_allocated_trace_flags(
      ::unhinged::observability::v1::TraceFlags* trace_flags);
  ::unhinged::observability::v1::TraceFlags* unsafe_arena_release_trace_flags();

  // @@protoc_insertion_point(class_scope:unhinged.observability.v1.TraceContext)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trace_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr span_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_span_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trace_state_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr correlation_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::unhinged::observability::v1::TraceFlags* trace_flags_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_observability_2eproto;
};
// -------------------------------------------------------------------

class TraceFlags final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.observability.v1.TraceFlags) */ {
 public:
  inline TraceFlags() : TraceFlags(nullptr) {}
  ~TraceFlags() override;
  explicit PROTOBUF_CONSTEXPR TraceFlags(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TraceFlags(const TraceFlags& from);
  TraceFlags(TraceFlags&& from) noexcept
    : TraceFlags() {
    *this = ::std::move(from);
  }

  inline TraceFlags& operator=(const TraceFlags& from) {
    CopyFrom(from);
    return *this;
  }
  inline TraceFlags& operator=(TraceFlags&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TraceFlags& default_instance() {
    return *internal_default_instance();
  }
  static inline const TraceFlags* internal_default_instance() {
    return reinterpret_cast<const TraceFlags*>(
               &_TraceFlags_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(TraceFlags& a, TraceFlags& b) {
    a.Swap(&b);
  }
  inline void Swap(TraceFlags* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TraceFlags* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TraceFlags* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TraceFlags>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TraceFlags& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TraceFlags& from) {
    TraceFlags::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TraceFlags* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.observability.v1.TraceFlags";
  }
  protected:
  explicit TraceFlags(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSampledFieldNumber = 1,
    kRandomTraceIdFieldNumber = 2,
  };
  // bool sampled = 1;
  void clear_sampled();
  bool sampled() const;
  void set_sampled(bool value);
  private:
  bool _internal_sampled() const;
  void _internal_set_sampled(bool value);
  public:

  // bool random_trace_id = 2;
  void clear_random_trace_id();
  bool random_trace_id() const;
  void set_random_trace_id(bool value);
  private:
  bool _internal_random_trace_id() const;
  void _internal_set_random_trace_id(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.observability.v1.TraceFlags)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool sampled_;
    bool random_trace_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_observability_2eproto;
};
// -------------------------------------------------------------------

class Resource_AttributesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Resource_AttributesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Resource_AttributesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  Resource_AttributesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Resource_AttributesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Resource_AttributesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Resource_AttributesEntry_DoNotUse& other);
  static const Resource_AttributesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Resource_AttributesEntry_DoNotUse*>(&_Resource_AttributesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "unhinged.observability.v1.Resource.AttributesEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "unhinged.observability.v1.Resource.AttributesEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_observability_2eproto;
};

// -------------------------------------------------------------------

class Resource final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.observability.v1.Resource) */ {
 public:
  inline Resource() : Resource(nullptr) {}
  ~Resource() override;
  explicit PROTOBUF_CONSTEXPR Resource(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Resource(const Resource& from);
  Resource(Resource&& from) noexcept
    : Resource() {
    *this = ::std::move(from);
  }

  inline Resource& operator=(const Resource& from) {
    CopyFrom(from);
    return *this;
  }
  inline Resource& operator=(Resource&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Resource& default_instance() {
    return *internal_default_instance();
  }
  static inline const Resource* internal_default_instance() {
    return reinterpret_cast<const Resource*>(
               &_Resource_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Resource& a, Resource& b) {
    a.Swap(&b);
  }
  inline void Swap(Resource* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Resource* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Resource* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Resource>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Resource& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Resource& from) {
    Resource::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Resource* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.observability.v1.Resource";
  }
  protected:
  explicit Resource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kAttributesFieldNumber = 20,
    kServiceNameFieldNumber = 1,
    kServiceVersionFieldNumber = 2,
    kServiceInstanceIdFieldNumber = 3,
    kDeploymentEnvironmentFieldNumber = 4,
    kK8SClusterNameFieldNumber = 5,
    kK8SNamespaceFieldNumber = 6,
    kK8SPodNameFieldNumber = 7,
    kHostNameFieldNumber = 8,
    kHostArchFieldNumber = 9,
  };
  // map<string, string> attributes = 20;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;
  public:
  void clear_attributes();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_attributes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_attributes();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      attributes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_attributes();

  // string service_name = 1;
  void clear_service_name();
  const std::string& service_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // string service_version = 2;
  void clear_service_version();
  const std::string& service_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_version();
  PROTOBUF_NODISCARD std::string* release_service_version();
  void set_allocated_service_version(std::string* service_version);
  private:
  const std::string& _internal_service_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_version(const std::string& value);
  std::string* _internal_mutable_service_version();
  public:

  // string service_instance_id = 3;
  void clear_service_instance_id();
  const std::string& service_instance_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_instance_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_instance_id();
  PROTOBUF_NODISCARD std::string* release_service_instance_id();
  void set_allocated_service_instance_id(std::string* service_instance_id);
  private:
  const std::string& _internal_service_instance_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_instance_id(const std::string& value);
  std::string* _internal_mutable_service_instance_id();
  public:

  // string deployment_environment = 4;
  void clear_deployment_environment();
  const std::string& deployment_environment() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_deployment_environment(ArgT0&& arg0, ArgT... args);
  std::string* mutable_deployment_environment();
  PROTOBUF_NODISCARD std::string* release_deployment_environment();
  void set_allocated_deployment_environment(std::string* deployment_environment);
  private:
  const std::string& _internal_deployment_environment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_deployment_environment(const std::string& value);
  std::string* _internal_mutable_deployment_environment();
  public:

  // string k8s_cluster_name = 5;
  void clear_k8s_cluster_name();
  const std::string& k8s_cluster_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_k8s_cluster_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_k8s_cluster_name();
  PROTOBUF_NODISCARD std::string* release_k8s_cluster_name();
  void set_allocated_k8s_cluster_name(std::string* k8s_cluster_name);
  private:
  const std::string& _internal_k8s_cluster_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_k8s_cluster_name(const std::string& value);
  std::string* _internal_mutable_k8s_cluster_name();
  public:

  // string k8s_namespace = 6;
  void clear_k8s_namespace();
  const std::string& k8s_namespace() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_k8s_namespace(ArgT0&& arg0, ArgT... args);
  std::string* mutable_k8s_namespace();
  PROTOBUF_NODISCARD std::string* release_k8s_namespace();
  void set_allocated_k8s_namespace(std::string* k8s_namespace);
  private:
  const std::string& _internal_k8s_namespace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_k8s_namespace(const std::string& value);
  std::string* _internal_mutable_k8s_namespace();
  public:

  // string k8s_pod_name = 7;
  void clear_k8s_pod_name();
  const std::string& k8s_pod_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_k8s_pod_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_k8s_pod_name();
  PROTOBUF_NODISCARD std::string* release_k8s_pod_name();
  void set_allocated_k8s_pod_name(std::string* k8s_pod_name);
  private:
  const std::string& _internal_k8s_pod_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_k8s_pod_name(const std::string& value);
  std::string* _internal_mutable_k8s_pod_name();
  public:

  // string host_name = 8;
  void clear_host_name();
  const std::string& host_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_host_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_host_name();
  PROTOBUF_NODISCARD std::string* release_host_name();
  void set_allocated_host_name(std::string* host_name);
  private:
  const std::string& _internal_host_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host_name(const std::string& value);
  std::string* _internal_mutable_host_name();
  public:

  // string host_arch = 9;
  void clear_host_arch();
  const std::string& host_arch() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_host_arch(ArgT0&& arg0, ArgT... args);
  std::string* mutable_host_arch();
  PROTOBUF_NODISCARD std::string* release_host_arch();
  void set_allocated_host_arch(std::string* host_arch);
  private:
  const std::string& _internal_host_arch() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host_arch(const std::string& value);
  std::string* _internal_mutable_host_arch();
  public:

  // @@protoc_insertion_point(class_scope:unhinged.observability.v1.Resource)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Resource_AttributesEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> attributes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_instance_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deployment_environment_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr k8s_cluster_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr k8s_namespace_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr k8s_pod_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_arch_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_observability_2eproto;
};
// -------------------------------------------------------------------

class LogEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.observability.v1.LogEvent) */ {
 public:
  inline LogEvent() : LogEvent(nullptr) {}
  ~LogEvent() override;
  explicit PROTOBUF_CONSTEXPR LogEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogEvent(const LogEvent& from);
  LogEvent(LogEvent&& from) noexcept
    : LogEvent() {
    *this = ::std::move(from);
  }

  inline LogEvent& operator=(const LogEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogEvent& operator=(LogEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogEvent* internal_default_instance() {
    return reinterpret_cast<const LogEvent*>(
               &_LogEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(LogEvent& a, LogEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(LogEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LogEvent& from) {
    LogEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.observability.v1.LogEvent";
  }
  protected:
  explicit LogEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventIdFieldNumber = 1,
    kEventTypeFieldNumber = 3,
    kMessageFieldNumber = 11,
    kTimestampFieldNumber = 2,
    kTraceContextFieldNumber = 5,
    kResourceFieldNumber = 6,
    kMetadataFieldNumber = 12,
    kErrorFieldNumber = 15,
    kDestinationsFieldNumber = 20,
    kPartitionInfoFieldNumber = 25,
    kSequenceNumberFieldNumber = 4,
    kLevelFieldNumber = 10,
  };
  // string event_id = 1;
  void clear_event_id();
  const std::string& event_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_event_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_event_id();
  PROTOBUF_NODISCARD std::string* release_event_id();
  void set_allocated_event_id(std::string* event_id);
  private:
  const std::string& _internal_event_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_event_id(const std::string& value);
  std::string* _internal_mutable_event_id();
  public:

  // string event_type = 3;
  void clear_event_type();
  const std::string& event_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_event_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_event_type();
  PROTOBUF_NODISCARD std::string* release_event_type();
  void set_allocated_event_type(std::string* event_type);
  private:
  const std::string& _internal_event_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_event_type(const std::string& value);
  std::string* _internal_mutable_event_type();
  public:

  // string message = 11;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .google.protobuf.Timestamp timestamp = 2;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // .unhinged.observability.v1.TraceContext trace_context = 5;
  bool has_trace_context() const;
  private:
  bool _internal_has_trace_context() const;
  public:
  void clear_trace_context();
  const ::unhinged::observability::v1::TraceContext& trace_context() const;
  PROTOBUF_NODISCARD ::unhinged::observability::v1::TraceContext* release_trace_context();
  ::unhinged::observability::v1::TraceContext* mutable_trace_context();
  void set_allocated_trace_context(::unhinged::observability::v1::TraceContext* trace_context);
  private:
  const ::unhinged::observability::v1::TraceContext& _internal_trace_context() const;
  ::unhinged::observability::v1::TraceContext* _internal_mutable_trace_context();
  public:
  void unsafe_arena_set_allocated_trace_context(
      ::unhinged::observability::v1::TraceContext* trace_context);
  ::unhinged::observability::v1::TraceContext* unsafe_arena_release_trace_context();

  // .unhinged.observability.v1.Resource resource = 6;
  bool has_resource() const;
  private:
  bool _internal_has_resource() const;
  public:
  void clear_resource();
  const ::unhinged::observability::v1::Resource& resource() const;
  PROTOBUF_NODISCARD ::unhinged::observability::v1::Resource* release_resource();
  ::unhinged::observability::v1::Resource* mutable_resource();
  void set_allocated_resource(::unhinged::observability::v1::Resource* resource);
  private:
  const ::unhinged::observability::v1::Resource& _internal_resource() const;
  ::unhinged::observability::v1::Resource* _internal_mutable_resource();
  public:
  void unsafe_arena_set_allocated_resource(
      ::unhinged::observability::v1::Resource* resource);
  ::unhinged::observability::v1::Resource* unsafe_arena_release_resource();

  // .google.protobuf.Struct metadata = 12;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::PROTOBUF_NAMESPACE_ID::Struct& metadata() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_metadata();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_metadata();
  void set_allocated_metadata(::PROTOBUF_NAMESPACE_ID::Struct* metadata);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::PROTOBUF_NAMESPACE_ID::Struct* metadata);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_metadata();

  // .unhinged.observability.v1.ErrorInfo error = 15;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::unhinged::observability::v1::ErrorInfo& error() const;
  PROTOBUF_NODISCARD ::unhinged::observability::v1::ErrorInfo* release_error();
  ::unhinged::observability::v1::ErrorInfo* mutable_error();
  void set_allocated_error(::unhinged::observability::v1::ErrorInfo* error);
  private:
  const ::unhinged::observability::v1::ErrorInfo& _internal_error() const;
  ::unhinged::observability::v1::ErrorInfo* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::unhinged::observability::v1::ErrorInfo* error);
  ::unhinged::observability::v1::ErrorInfo* unsafe_arena_release_error();

  // .unhinged.observability.v1.DestinationFlags destinations = 20;
  bool has_destinations() const;
  private:
  bool _internal_has_destinations() const;
  public:
  void clear_destinations();
  const ::unhinged::observability::v1::DestinationFlags& destinations() const;
  PROTOBUF_NODISCARD ::unhinged::observability::v1::DestinationFlags* release_destinations();
  ::unhinged::observability::v1::DestinationFlags* mutable_destinations();
  void set_allocated_destinations(::unhinged::observability::v1::DestinationFlags* destinations);
  private:
  const ::unhinged::observability::v1::DestinationFlags& _internal_destinations() const;
  ::unhinged::observability::v1::DestinationFlags* _internal_mutable_destinations();
  public:
  void unsafe_arena_set_allocated_destinations(
      ::unhinged::observability::v1::DestinationFlags* destinations);
  ::unhinged::observability::v1::DestinationFlags* unsafe_arena_release_destinations();

  // .unhinged.observability.v1.PartitionInfo partition_info = 25;
  bool has_partition_info() const;
  private:
  bool _internal_has_partition_info() const;
  public:
  void clear_partition_info();
  const ::unhinged::observability::v1::PartitionInfo& partition_info() const;
  PROTOBUF_NODISCARD ::unhinged::observability::v1::PartitionInfo* release_partition_info();
  ::unhinged::observability::v1::PartitionInfo* mutable_partition_info();
  void set_allocated_partition_info(::unhinged::observability::v1::PartitionInfo* partition_info);
  private:
  const ::unhinged::observability::v1::PartitionInfo& _internal_partition_info() const;
  ::unhinged::observability::v1::PartitionInfo* _internal_mutable_partition_info();
  public:
  void unsafe_arena_set_allocated_partition_info(
      ::unhinged::observability::v1::PartitionInfo* partition_info);
  ::unhinged::observability::v1::PartitionInfo* unsafe_arena_release_partition_info();

  // int64 sequence_number = 4;
  void clear_sequence_number();
  int64_t sequence_number() const;
  void set_sequence_number(int64_t value);
  private:
  int64_t _internal_sequence_number() const;
  void _internal_set_sequence_number(int64_t value);
  public:

  // .unhinged.observability.v1.LogLevel level = 10;
  void clear_level();
  ::unhinged::observability::v1::LogLevel level() const;
  void set_level(::unhinged::observability::v1::LogLevel value);
  private:
  ::unhinged::observability::v1::LogLevel _internal_level() const;
  void _internal_set_level(::unhinged::observability::v1::LogLevel value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.observability.v1.LogEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr event_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr event_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
    ::unhinged::observability::v1::TraceContext* trace_context_;
    ::unhinged::observability::v1::Resource* resource_;
    ::PROTOBUF_NAMESPACE_ID::Struct* metadata_;
    ::unhinged::observability::v1::ErrorInfo* error_;
    ::unhinged::observability::v1::DestinationFlags* destinations_;
    ::unhinged::observability::v1::PartitionInfo* partition_info_;
    int64_t sequence_number_;
    int level_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_observability_2eproto;
};
// -------------------------------------------------------------------

class ErrorInfo_ErrorAttributesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ErrorInfo_ErrorAttributesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ErrorInfo_ErrorAttributesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  ErrorInfo_ErrorAttributesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ErrorInfo_ErrorAttributesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ErrorInfo_ErrorAttributesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ErrorInfo_ErrorAttributesEntry_DoNotUse& other);
  static const ErrorInfo_ErrorAttributesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ErrorInfo_ErrorAttributesEntry_DoNotUse*>(&_ErrorInfo_ErrorAttributesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "unhinged.observability.v1.ErrorInfo.ErrorAttributesEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "unhinged.observability.v1.ErrorInfo.ErrorAttributesEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_observability_2eproto;
};

// -------------------------------------------------------------------

class ErrorInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.observability.v1.ErrorInfo) */ {
 public:
  inline ErrorInfo() : ErrorInfo(nullptr) {}
  ~ErrorInfo() override;
  explicit PROTOBUF_CONSTEXPR ErrorInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ErrorInfo(const ErrorInfo& from);
  ErrorInfo(ErrorInfo&& from) noexcept
    : ErrorInfo() {
    *this = ::std::move(from);
  }

  inline ErrorInfo& operator=(const ErrorInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ErrorInfo& operator=(ErrorInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ErrorInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ErrorInfo* internal_default_instance() {
    return reinterpret_cast<const ErrorInfo*>(
               &_ErrorInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ErrorInfo& a, ErrorInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ErrorInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ErrorInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ErrorInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ErrorInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ErrorInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ErrorInfo& from) {
    ErrorInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ErrorInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.observability.v1.ErrorInfo";
  }
  protected:
  explicit ErrorInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kErrorAttributesFieldNumber = 5,
    kErrorTypeFieldNumber = 1,
    kErrorMessageFieldNumber = 2,
    kStackTraceFieldNumber = 3,
    kErrorCodeFieldNumber = 4,
  };
  // map<string, string> error_attributes = 5;
  int error_attributes_size() const;
  private:
  int _internal_error_attributes_size() const;
  public:
  void clear_error_attributes();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_error_attributes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_error_attributes();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      error_attributes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_error_attributes();

  // string error_type = 1;
  void clear_error_type();
  const std::string& error_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_type();
  PROTOBUF_NODISCARD std::string* release_error_type();
  void set_allocated_error_type(std::string* error_type);
  private:
  const std::string& _internal_error_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_type(const std::string& value);
  std::string* _internal_mutable_error_type();
  public:

  // string error_message = 2;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // string stack_trace = 3;
  void clear_stack_trace();
  const std::string& stack_trace() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stack_trace(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stack_trace();
  PROTOBUF_NODISCARD std::string* release_stack_trace();
  void set_allocated_stack_trace(std::string* stack_trace);
  private:
  const std::string& _internal_stack_trace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stack_trace(const std::string& value);
  std::string* _internal_mutable_stack_trace();
  public:

  // string error_code = 4;
  void clear_error_code();
  const std::string& error_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_code();
  PROTOBUF_NODISCARD std::string* release_error_code();
  void set_allocated_error_code(std::string* error_code);
  private:
  const std::string& _internal_error_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_code(const std::string& value);
  std::string* _internal_mutable_error_code();
  public:

  // @@protoc_insertion_point(class_scope:unhinged.observability.v1.ErrorInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ErrorInfo_ErrorAttributesEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> error_attributes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stack_trace_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_observability_2eproto;
};
// -------------------------------------------------------------------

class DestinationFlags final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.observability.v1.DestinationFlags) */ {
 public:
  inline DestinationFlags() : DestinationFlags(nullptr) {}
  ~DestinationFlags() override;
  explicit PROTOBUF_CONSTEXPR DestinationFlags(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DestinationFlags(const DestinationFlags& from);
  DestinationFlags(DestinationFlags&& from) noexcept
    : DestinationFlags() {
    *this = ::std::move(from);
  }

  inline DestinationFlags& operator=(const DestinationFlags& from) {
    CopyFrom(from);
    return *this;
  }
  inline DestinationFlags& operator=(DestinationFlags&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DestinationFlags& default_instance() {
    return *internal_default_instance();
  }
  static inline const DestinationFlags* internal_default_instance() {
    return reinterpret_cast<const DestinationFlags*>(
               &_DestinationFlags_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(DestinationFlags& a, DestinationFlags& b) {
    a.Swap(&b);
  }
  inline void Swap(DestinationFlags* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DestinationFlags* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DestinationFlags* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DestinationFlags>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DestinationFlags& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DestinationFlags& from) {
    DestinationFlags::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DestinationFlags* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.observability.v1.DestinationFlags";
  }
  protected:
  explicit DestinationFlags(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataLakeOptionsFieldNumber = 10,
    kConsoleFieldNumber = 1,
    kCdcStreamFieldNumber = 2,
    kDataLakeFieldNumber = 3,
  };
  // .unhinged.observability.v1.DataLakeOptions data_lake_options = 10;
  bool has_data_lake_options() const;
  private:
  bool _internal_has_data_lake_options() const;
  public:
  void clear_data_lake_options();
  const ::unhinged::observability::v1::DataLakeOptions& data_lake_options() const;
  PROTOBUF_NODISCARD ::unhinged::observability::v1::DataLakeOptions* release_data_lake_options();
  ::unhinged::observability::v1::DataLakeOptions* mutable_data_lake_options();
  void set_allocated_data_lake_options(::unhinged::observability::v1::DataLakeOptions* data_lake_options);
  private:
  const ::unhinged::observability::v1::DataLakeOptions& _internal_data_lake_options() const;
  ::unhinged::observability::v1::DataLakeOptions* _internal_mutable_data_lake_options();
  public:
  void unsafe_arena_set_allocated_data_lake_options(
      ::unhinged::observability::v1::DataLakeOptions* data_lake_options);
  ::unhinged::observability::v1::DataLakeOptions* unsafe_arena_release_data_lake_options();

  // bool console = 1;
  void clear_console();
  bool console() const;
  void set_console(bool value);
  private:
  bool _internal_console() const;
  void _internal_set_console(bool value);
  public:

  // bool cdc_stream = 2;
  void clear_cdc_stream();
  bool cdc_stream() const;
  void set_cdc_stream(bool value);
  private:
  bool _internal_cdc_stream() const;
  void _internal_set_cdc_stream(bool value);
  public:

  // bool data_lake = 3;
  void clear_data_lake();
  bool data_lake() const;
  void set_data_lake(bool value);
  private:
  bool _internal_data_lake() const;
  void _internal_set_data_lake(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.observability.v1.DestinationFlags)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::unhinged::observability::v1::DataLakeOptions* data_lake_options_;
    bool console_;
    bool cdc_stream_;
    bool data_lake_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_observability_2eproto;
};
// -------------------------------------------------------------------

class DataLakeOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.observability.v1.DataLakeOptions) */ {
 public:
  inline DataLakeOptions() : DataLakeOptions(nullptr) {}
  ~DataLakeOptions() override;
  explicit PROTOBUF_CONSTEXPR DataLakeOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataLakeOptions(const DataLakeOptions& from);
  DataLakeOptions(DataLakeOptions&& from) noexcept
    : DataLakeOptions() {
    *this = ::std::move(from);
  }

  inline DataLakeOptions& operator=(const DataLakeOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataLakeOptions& operator=(DataLakeOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataLakeOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataLakeOptions* internal_default_instance() {
    return reinterpret_cast<const DataLakeOptions*>(
               &_DataLakeOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(DataLakeOptions& a, DataLakeOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(DataLakeOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataLakeOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataLakeOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataLakeOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataLakeOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DataLakeOptions& from) {
    DataLakeOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataLakeOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.observability.v1.DataLakeOptions";
  }
  protected:
  explicit DataLakeOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTableNameFieldNumber = 1,
    kPartitionStrategyFieldNumber = 2,
    kBatchSizeFieldNumber = 3,
    kFlushIntervalSecondsFieldNumber = 4,
    kCompressionFieldNumber = 5,
  };
  // string table_name = 1;
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_NODISCARD std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // string partition_strategy = 2;
  void clear_partition_strategy();
  const std::string& partition_strategy() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_partition_strategy(ArgT0&& arg0, ArgT... args);
  std::string* mutable_partition_strategy();
  PROTOBUF_NODISCARD std::string* release_partition_strategy();
  void set_allocated_partition_strategy(std::string* partition_strategy);
  private:
  const std::string& _internal_partition_strategy() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_partition_strategy(const std::string& value);
  std::string* _internal_mutable_partition_strategy();
  public:

  // int32 batch_size = 3;
  void clear_batch_size();
  int32_t batch_size() const;
  void set_batch_size(int32_t value);
  private:
  int32_t _internal_batch_size() const;
  void _internal_set_batch_size(int32_t value);
  public:

  // int32 flush_interval_seconds = 4;
  void clear_flush_interval_seconds();
  int32_t flush_interval_seconds() const;
  void set_flush_interval_seconds(int32_t value);
  private:
  int32_t _internal_flush_interval_seconds() const;
  void _internal_set_flush_interval_seconds(int32_t value);
  public:

  // .unhinged.observability.v1.CompressionType compression = 5;
  void clear_compression();
  ::unhinged::observability::v1::CompressionType compression() const;
  void set_compression(::unhinged::observability::v1::CompressionType value);
  private:
  ::unhinged::observability::v1::CompressionType _internal_compression() const;
  void _internal_set_compression(::unhinged::observability::v1::CompressionType value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.observability.v1.DataLakeOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr partition_strategy_;
    int32_t batch_size_;
    int32_t flush_interval_seconds_;
    int compression_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_observability_2eproto;
};
// -------------------------------------------------------------------

class PartitionInfo_CustomPartitionsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<PartitionInfo_CustomPartitionsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<PartitionInfo_CustomPartitionsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  PartitionInfo_CustomPartitionsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR PartitionInfo_CustomPartitionsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit PartitionInfo_CustomPartitionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const PartitionInfo_CustomPartitionsEntry_DoNotUse& other);
  static const PartitionInfo_CustomPartitionsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const PartitionInfo_CustomPartitionsEntry_DoNotUse*>(&_PartitionInfo_CustomPartitionsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "unhinged.observability.v1.PartitionInfo.CustomPartitionsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "unhinged.observability.v1.PartitionInfo.CustomPartitionsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_observability_2eproto;
};

// -------------------------------------------------------------------

class PartitionInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.observability.v1.PartitionInfo) */ {
 public:
  inline PartitionInfo() : PartitionInfo(nullptr) {}
  ~PartitionInfo() override;
  explicit PROTOBUF_CONSTEXPR PartitionInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PartitionInfo(const PartitionInfo& from);
  PartitionInfo(PartitionInfo&& from) noexcept
    : PartitionInfo() {
    *this = ::std::move(from);
  }

  inline PartitionInfo& operator=(const PartitionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PartitionInfo& operator=(PartitionInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PartitionInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PartitionInfo* internal_default_instance() {
    return reinterpret_cast<const PartitionInfo*>(
               &_PartitionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(PartitionInfo& a, PartitionInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PartitionInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PartitionInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PartitionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PartitionInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PartitionInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PartitionInfo& from) {
    PartitionInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PartitionInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.observability.v1.PartitionInfo";
  }
  protected:
  explicit PartitionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kCustomPartitionsFieldNumber = 10,
    kDatePartitionFieldNumber = 1,
    kHourPartitionFieldNumber = 2,
    kServicePartitionFieldNumber = 3,
    kLevelPartitionFieldNumber = 4,
  };
  // map<string, string> custom_partitions = 10;
  int custom_partitions_size() const;
  private:
  int _internal_custom_partitions_size() const;
  public:
  void clear_custom_partitions();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_custom_partitions() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_custom_partitions();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      custom_partitions() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_custom_partitions();

  // string date_partition = 1;
  void clear_date_partition();
  const std::string& date_partition() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_date_partition(ArgT0&& arg0, ArgT... args);
  std::string* mutable_date_partition();
  PROTOBUF_NODISCARD std::string* release_date_partition();
  void set_allocated_date_partition(std::string* date_partition);
  private:
  const std::string& _internal_date_partition() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_date_partition(const std::string& value);
  std::string* _internal_mutable_date_partition();
  public:

  // string hour_partition = 2;
  void clear_hour_partition();
  const std::string& hour_partition() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hour_partition(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hour_partition();
  PROTOBUF_NODISCARD std::string* release_hour_partition();
  void set_allocated_hour_partition(std::string* hour_partition);
  private:
  const std::string& _internal_hour_partition() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hour_partition(const std::string& value);
  std::string* _internal_mutable_hour_partition();
  public:

  // string service_partition = 3;
  void clear_service_partition();
  const std::string& service_partition() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_partition(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_partition();
  PROTOBUF_NODISCARD std::string* release_service_partition();
  void set_allocated_service_partition(std::string* service_partition);
  private:
  const std::string& _internal_service_partition() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_partition(const std::string& value);
  std::string* _internal_mutable_service_partition();
  public:

  // string level_partition = 4;
  void clear_level_partition();
  const std::string& level_partition() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_level_partition(ArgT0&& arg0, ArgT... args);
  std::string* mutable_level_partition();
  PROTOBUF_NODISCARD std::string* release_level_partition();
  void set_allocated_level_partition(std::string* level_partition);
  private:
  const std::string& _internal_level_partition() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_level_partition(const std::string& value);
  std::string* _internal_mutable_level_partition();
  public:

  // @@protoc_insertion_point(class_scope:unhinged.observability.v1.PartitionInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        PartitionInfo_CustomPartitionsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> custom_partitions_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr date_partition_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hour_partition_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_partition_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr level_partition_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_observability_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TraceContext

// string trace_id = 1;
inline void TraceContext::clear_trace_id() {
  _impl_.trace_id_.ClearToEmpty();
}
inline const std::string& TraceContext::trace_id() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.TraceContext.trace_id)
  return _internal_trace_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TraceContext::set_trace_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.trace_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.TraceContext.trace_id)
}
inline std::string* TraceContext::mutable_trace_id() {
  std::string* _s = _internal_mutable_trace_id();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.TraceContext.trace_id)
  return _s;
}
inline const std::string& TraceContext::_internal_trace_id() const {
  return _impl_.trace_id_.Get();
}
inline void TraceContext::_internal_set_trace_id(const std::string& value) {
  
  _impl_.trace_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TraceContext::_internal_mutable_trace_id() {
  
  return _impl_.trace_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TraceContext::release_trace_id() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.TraceContext.trace_id)
  return _impl_.trace_id_.Release();
}
inline void TraceContext::set_allocated_trace_id(std::string* trace_id) {
  if (trace_id != nullptr) {
    
  } else {
    
  }
  _impl_.trace_id_.SetAllocated(trace_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.trace_id_.IsDefault()) {
    _impl_.trace_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.TraceContext.trace_id)
}

// string span_id = 2;
inline void TraceContext::clear_span_id() {
  _impl_.span_id_.ClearToEmpty();
}
inline const std::string& TraceContext::span_id() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.TraceContext.span_id)
  return _internal_span_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TraceContext::set_span_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.span_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.TraceContext.span_id)
}
inline std::string* TraceContext::mutable_span_id() {
  std::string* _s = _internal_mutable_span_id();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.TraceContext.span_id)
  return _s;
}
inline const std::string& TraceContext::_internal_span_id() const {
  return _impl_.span_id_.Get();
}
inline void TraceContext::_internal_set_span_id(const std::string& value) {
  
  _impl_.span_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TraceContext::_internal_mutable_span_id() {
  
  return _impl_.span_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TraceContext::release_span_id() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.TraceContext.span_id)
  return _impl_.span_id_.Release();
}
inline void TraceContext::set_allocated_span_id(std::string* span_id) {
  if (span_id != nullptr) {
    
  } else {
    
  }
  _impl_.span_id_.SetAllocated(span_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.span_id_.IsDefault()) {
    _impl_.span_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.TraceContext.span_id)
}

// string parent_span_id = 3;
inline void TraceContext::clear_parent_span_id() {
  _impl_.parent_span_id_.ClearToEmpty();
}
inline const std::string& TraceContext::parent_span_id() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.TraceContext.parent_span_id)
  return _internal_parent_span_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TraceContext::set_parent_span_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.parent_span_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.TraceContext.parent_span_id)
}
inline std::string* TraceContext::mutable_parent_span_id() {
  std::string* _s = _internal_mutable_parent_span_id();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.TraceContext.parent_span_id)
  return _s;
}
inline const std::string& TraceContext::_internal_parent_span_id() const {
  return _impl_.parent_span_id_.Get();
}
inline void TraceContext::_internal_set_parent_span_id(const std::string& value) {
  
  _impl_.parent_span_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TraceContext::_internal_mutable_parent_span_id() {
  
  return _impl_.parent_span_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TraceContext::release_parent_span_id() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.TraceContext.parent_span_id)
  return _impl_.parent_span_id_.Release();
}
inline void TraceContext::set_allocated_parent_span_id(std::string* parent_span_id) {
  if (parent_span_id != nullptr) {
    
  } else {
    
  }
  _impl_.parent_span_id_.SetAllocated(parent_span_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parent_span_id_.IsDefault()) {
    _impl_.parent_span_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.TraceContext.parent_span_id)
}

// .unhinged.observability.v1.TraceFlags trace_flags = 4;
inline bool TraceContext::_internal_has_trace_flags() const {
  return this != internal_default_instance() && _impl_.trace_flags_ != nullptr;
}
inline bool TraceContext::has_trace_flags() const {
  return _internal_has_trace_flags();
}
inline void TraceContext::clear_trace_flags() {
  if (GetArenaForAllocation() == nullptr && _impl_.trace_flags_ != nullptr) {
    delete _impl_.trace_flags_;
  }
  _impl_.trace_flags_ = nullptr;
}
inline const ::unhinged::observability::v1::TraceFlags& TraceContext::_internal_trace_flags() const {
  const ::unhinged::observability::v1::TraceFlags* p = _impl_.trace_flags_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::observability::v1::TraceFlags&>(
      ::unhinged::observability::v1::_TraceFlags_default_instance_);
}
inline const ::unhinged::observability::v1::TraceFlags& TraceContext::trace_flags() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.TraceContext.trace_flags)
  return _internal_trace_flags();
}
inline void TraceContext::unsafe_arena_set_allocated_trace_flags(
    ::unhinged::observability::v1::TraceFlags* trace_flags) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.trace_flags_);
  }
  _impl_.trace_flags_ = trace_flags;
  if (trace_flags) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.TraceContext.trace_flags)
}
inline ::unhinged::observability::v1::TraceFlags* TraceContext::release_trace_flags() {
  
  ::unhinged::observability::v1::TraceFlags* temp = _impl_.trace_flags_;
  _impl_.trace_flags_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::observability::v1::TraceFlags* TraceContext::unsafe_arena_release_trace_flags() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.TraceContext.trace_flags)
  
  ::unhinged::observability::v1::TraceFlags* temp = _impl_.trace_flags_;
  _impl_.trace_flags_ = nullptr;
  return temp;
}
inline ::unhinged::observability::v1::TraceFlags* TraceContext::_internal_mutable_trace_flags() {
  
  if (_impl_.trace_flags_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::observability::v1::TraceFlags>(GetArenaForAllocation());
    _impl_.trace_flags_ = p;
  }
  return _impl_.trace_flags_;
}
inline ::unhinged::observability::v1::TraceFlags* TraceContext::mutable_trace_flags() {
  ::unhinged::observability::v1::TraceFlags* _msg = _internal_mutable_trace_flags();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.TraceContext.trace_flags)
  return _msg;
}
inline void TraceContext::set_allocated_trace_flags(::unhinged::observability::v1::TraceFlags* trace_flags) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.trace_flags_;
  }
  if (trace_flags) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(trace_flags);
    if (message_arena != submessage_arena) {
      trace_flags = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trace_flags, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.trace_flags_ = trace_flags;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.TraceContext.trace_flags)
}

// string trace_state = 5;
inline void TraceContext::clear_trace_state() {
  _impl_.trace_state_.ClearToEmpty();
}
inline const std::string& TraceContext::trace_state() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.TraceContext.trace_state)
  return _internal_trace_state();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TraceContext::set_trace_state(ArgT0&& arg0, ArgT... args) {
 
 _impl_.trace_state_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.TraceContext.trace_state)
}
inline std::string* TraceContext::mutable_trace_state() {
  std::string* _s = _internal_mutable_trace_state();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.TraceContext.trace_state)
  return _s;
}
inline const std::string& TraceContext::_internal_trace_state() const {
  return _impl_.trace_state_.Get();
}
inline void TraceContext::_internal_set_trace_state(const std::string& value) {
  
  _impl_.trace_state_.Set(value, GetArenaForAllocation());
}
inline std::string* TraceContext::_internal_mutable_trace_state() {
  
  return _impl_.trace_state_.Mutable(GetArenaForAllocation());
}
inline std::string* TraceContext::release_trace_state() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.TraceContext.trace_state)
  return _impl_.trace_state_.Release();
}
inline void TraceContext::set_allocated_trace_state(std::string* trace_state) {
  if (trace_state != nullptr) {
    
  } else {
    
  }
  _impl_.trace_state_.SetAllocated(trace_state, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.trace_state_.IsDefault()) {
    _impl_.trace_state_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.TraceContext.trace_state)
}

// string correlation_id = 10;
inline void TraceContext::clear_correlation_id() {
  _impl_.correlation_id_.ClearToEmpty();
}
inline const std::string& TraceContext::correlation_id() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.TraceContext.correlation_id)
  return _internal_correlation_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TraceContext::set_correlation_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.correlation_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.TraceContext.correlation_id)
}
inline std::string* TraceContext::mutable_correlation_id() {
  std::string* _s = _internal_mutable_correlation_id();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.TraceContext.correlation_id)
  return _s;
}
inline const std::string& TraceContext::_internal_correlation_id() const {
  return _impl_.correlation_id_.Get();
}
inline void TraceContext::_internal_set_correlation_id(const std::string& value) {
  
  _impl_.correlation_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TraceContext::_internal_mutable_correlation_id() {
  
  return _impl_.correlation_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TraceContext::release_correlation_id() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.TraceContext.correlation_id)
  return _impl_.correlation_id_.Release();
}
inline void TraceContext::set_allocated_correlation_id(std::string* correlation_id) {
  if (correlation_id != nullptr) {
    
  } else {
    
  }
  _impl_.correlation_id_.SetAllocated(correlation_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.correlation_id_.IsDefault()) {
    _impl_.correlation_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.TraceContext.correlation_id)
}

// string request_id = 11;
inline void TraceContext::clear_request_id() {
  _impl_.request_id_.ClearToEmpty();
}
inline const std::string& TraceContext::request_id() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.TraceContext.request_id)
  return _internal_request_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TraceContext::set_request_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.request_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.TraceContext.request_id)
}
inline std::string* TraceContext::mutable_request_id() {
  std::string* _s = _internal_mutable_request_id();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.TraceContext.request_id)
  return _s;
}
inline const std::string& TraceContext::_internal_request_id() const {
  return _impl_.request_id_.Get();
}
inline void TraceContext::_internal_set_request_id(const std::string& value) {
  
  _impl_.request_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TraceContext::_internal_mutable_request_id() {
  
  return _impl_.request_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TraceContext::release_request_id() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.TraceContext.request_id)
  return _impl_.request_id_.Release();
}
inline void TraceContext::set_allocated_request_id(std::string* request_id) {
  if (request_id != nullptr) {
    
  } else {
    
  }
  _impl_.request_id_.SetAllocated(request_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.request_id_.IsDefault()) {
    _impl_.request_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.TraceContext.request_id)
}

// string session_id = 12;
inline void TraceContext::clear_session_id() {
  _impl_.session_id_.ClearToEmpty();
}
inline const std::string& TraceContext::session_id() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.TraceContext.session_id)
  return _internal_session_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TraceContext::set_session_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.session_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.TraceContext.session_id)
}
inline std::string* TraceContext::mutable_session_id() {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.TraceContext.session_id)
  return _s;
}
inline const std::string& TraceContext::_internal_session_id() const {
  return _impl_.session_id_.Get();
}
inline void TraceContext::_internal_set_session_id(const std::string& value) {
  
  _impl_.session_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TraceContext::_internal_mutable_session_id() {
  
  return _impl_.session_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TraceContext::release_session_id() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.TraceContext.session_id)
  return _impl_.session_id_.Release();
}
inline void TraceContext::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  _impl_.session_id_.SetAllocated(session_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.session_id_.IsDefault()) {
    _impl_.session_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.TraceContext.session_id)
}

// string user_id = 13;
inline void TraceContext::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& TraceContext::user_id() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.TraceContext.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TraceContext::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.TraceContext.user_id)
}
inline std::string* TraceContext::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.TraceContext.user_id)
  return _s;
}
inline const std::string& TraceContext::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void TraceContext::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TraceContext::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TraceContext::release_user_id() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.TraceContext.user_id)
  return _impl_.user_id_.Release();
}
inline void TraceContext::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.TraceContext.user_id)
}

// -------------------------------------------------------------------

// TraceFlags

// bool sampled = 1;
inline void TraceFlags::clear_sampled() {
  _impl_.sampled_ = false;
}
inline bool TraceFlags::_internal_sampled() const {
  return _impl_.sampled_;
}
inline bool TraceFlags::sampled() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.TraceFlags.sampled)
  return _internal_sampled();
}
inline void TraceFlags::_internal_set_sampled(bool value) {
  
  _impl_.sampled_ = value;
}
inline void TraceFlags::set_sampled(bool value) {
  _internal_set_sampled(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.TraceFlags.sampled)
}

// bool random_trace_id = 2;
inline void TraceFlags::clear_random_trace_id() {
  _impl_.random_trace_id_ = false;
}
inline bool TraceFlags::_internal_random_trace_id() const {
  return _impl_.random_trace_id_;
}
inline bool TraceFlags::random_trace_id() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.TraceFlags.random_trace_id)
  return _internal_random_trace_id();
}
inline void TraceFlags::_internal_set_random_trace_id(bool value) {
  
  _impl_.random_trace_id_ = value;
}
inline void TraceFlags::set_random_trace_id(bool value) {
  _internal_set_random_trace_id(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.TraceFlags.random_trace_id)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Resource

// string service_name = 1;
inline void Resource::clear_service_name() {
  _impl_.service_name_.ClearToEmpty();
}
inline const std::string& Resource::service_name() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.Resource.service_name)
  return _internal_service_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Resource::set_service_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.Resource.service_name)
}
inline std::string* Resource::mutable_service_name() {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.Resource.service_name)
  return _s;
}
inline const std::string& Resource::_internal_service_name() const {
  return _impl_.service_name_.Get();
}
inline void Resource::_internal_set_service_name(const std::string& value) {
  
  _impl_.service_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Resource::_internal_mutable_service_name() {
  
  return _impl_.service_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Resource::release_service_name() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.Resource.service_name)
  return _impl_.service_name_.Release();
}
inline void Resource::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  _impl_.service_name_.SetAllocated(service_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_name_.IsDefault()) {
    _impl_.service_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.Resource.service_name)
}

// string service_version = 2;
inline void Resource::clear_service_version() {
  _impl_.service_version_.ClearToEmpty();
}
inline const std::string& Resource::service_version() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.Resource.service_version)
  return _internal_service_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Resource::set_service_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.Resource.service_version)
}
inline std::string* Resource::mutable_service_version() {
  std::string* _s = _internal_mutable_service_version();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.Resource.service_version)
  return _s;
}
inline const std::string& Resource::_internal_service_version() const {
  return _impl_.service_version_.Get();
}
inline void Resource::_internal_set_service_version(const std::string& value) {
  
  _impl_.service_version_.Set(value, GetArenaForAllocation());
}
inline std::string* Resource::_internal_mutable_service_version() {
  
  return _impl_.service_version_.Mutable(GetArenaForAllocation());
}
inline std::string* Resource::release_service_version() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.Resource.service_version)
  return _impl_.service_version_.Release();
}
inline void Resource::set_allocated_service_version(std::string* service_version) {
  if (service_version != nullptr) {
    
  } else {
    
  }
  _impl_.service_version_.SetAllocated(service_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_version_.IsDefault()) {
    _impl_.service_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.Resource.service_version)
}

// string service_instance_id = 3;
inline void Resource::clear_service_instance_id() {
  _impl_.service_instance_id_.ClearToEmpty();
}
inline const std::string& Resource::service_instance_id() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.Resource.service_instance_id)
  return _internal_service_instance_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Resource::set_service_instance_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_instance_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.Resource.service_instance_id)
}
inline std::string* Resource::mutable_service_instance_id() {
  std::string* _s = _internal_mutable_service_instance_id();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.Resource.service_instance_id)
  return _s;
}
inline const std::string& Resource::_internal_service_instance_id() const {
  return _impl_.service_instance_id_.Get();
}
inline void Resource::_internal_set_service_instance_id(const std::string& value) {
  
  _impl_.service_instance_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Resource::_internal_mutable_service_instance_id() {
  
  return _impl_.service_instance_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Resource::release_service_instance_id() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.Resource.service_instance_id)
  return _impl_.service_instance_id_.Release();
}
inline void Resource::set_allocated_service_instance_id(std::string* service_instance_id) {
  if (service_instance_id != nullptr) {
    
  } else {
    
  }
  _impl_.service_instance_id_.SetAllocated(service_instance_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_instance_id_.IsDefault()) {
    _impl_.service_instance_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.Resource.service_instance_id)
}

// string deployment_environment = 4;
inline void Resource::clear_deployment_environment() {
  _impl_.deployment_environment_.ClearToEmpty();
}
inline const std::string& Resource::deployment_environment() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.Resource.deployment_environment)
  return _internal_deployment_environment();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Resource::set_deployment_environment(ArgT0&& arg0, ArgT... args) {
 
 _impl_.deployment_environment_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.Resource.deployment_environment)
}
inline std::string* Resource::mutable_deployment_environment() {
  std::string* _s = _internal_mutable_deployment_environment();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.Resource.deployment_environment)
  return _s;
}
inline const std::string& Resource::_internal_deployment_environment() const {
  return _impl_.deployment_environment_.Get();
}
inline void Resource::_internal_set_deployment_environment(const std::string& value) {
  
  _impl_.deployment_environment_.Set(value, GetArenaForAllocation());
}
inline std::string* Resource::_internal_mutable_deployment_environment() {
  
  return _impl_.deployment_environment_.Mutable(GetArenaForAllocation());
}
inline std::string* Resource::release_deployment_environment() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.Resource.deployment_environment)
  return _impl_.deployment_environment_.Release();
}
inline void Resource::set_allocated_deployment_environment(std::string* deployment_environment) {
  if (deployment_environment != nullptr) {
    
  } else {
    
  }
  _impl_.deployment_environment_.SetAllocated(deployment_environment, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.deployment_environment_.IsDefault()) {
    _impl_.deployment_environment_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.Resource.deployment_environment)
}

// string k8s_cluster_name = 5;
inline void Resource::clear_k8s_cluster_name() {
  _impl_.k8s_cluster_name_.ClearToEmpty();
}
inline const std::string& Resource::k8s_cluster_name() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.Resource.k8s_cluster_name)
  return _internal_k8s_cluster_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Resource::set_k8s_cluster_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.k8s_cluster_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.Resource.k8s_cluster_name)
}
inline std::string* Resource::mutable_k8s_cluster_name() {
  std::string* _s = _internal_mutable_k8s_cluster_name();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.Resource.k8s_cluster_name)
  return _s;
}
inline const std::string& Resource::_internal_k8s_cluster_name() const {
  return _impl_.k8s_cluster_name_.Get();
}
inline void Resource::_internal_set_k8s_cluster_name(const std::string& value) {
  
  _impl_.k8s_cluster_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Resource::_internal_mutable_k8s_cluster_name() {
  
  return _impl_.k8s_cluster_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Resource::release_k8s_cluster_name() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.Resource.k8s_cluster_name)
  return _impl_.k8s_cluster_name_.Release();
}
inline void Resource::set_allocated_k8s_cluster_name(std::string* k8s_cluster_name) {
  if (k8s_cluster_name != nullptr) {
    
  } else {
    
  }
  _impl_.k8s_cluster_name_.SetAllocated(k8s_cluster_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.k8s_cluster_name_.IsDefault()) {
    _impl_.k8s_cluster_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.Resource.k8s_cluster_name)
}

// string k8s_namespace = 6;
inline void Resource::clear_k8s_namespace() {
  _impl_.k8s_namespace_.ClearToEmpty();
}
inline const std::string& Resource::k8s_namespace() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.Resource.k8s_namespace)
  return _internal_k8s_namespace();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Resource::set_k8s_namespace(ArgT0&& arg0, ArgT... args) {
 
 _impl_.k8s_namespace_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.Resource.k8s_namespace)
}
inline std::string* Resource::mutable_k8s_namespace() {
  std::string* _s = _internal_mutable_k8s_namespace();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.Resource.k8s_namespace)
  return _s;
}
inline const std::string& Resource::_internal_k8s_namespace() const {
  return _impl_.k8s_namespace_.Get();
}
inline void Resource::_internal_set_k8s_namespace(const std::string& value) {
  
  _impl_.k8s_namespace_.Set(value, GetArenaForAllocation());
}
inline std::string* Resource::_internal_mutable_k8s_namespace() {
  
  return _impl_.k8s_namespace_.Mutable(GetArenaForAllocation());
}
inline std::string* Resource::release_k8s_namespace() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.Resource.k8s_namespace)
  return _impl_.k8s_namespace_.Release();
}
inline void Resource::set_allocated_k8s_namespace(std::string* k8s_namespace) {
  if (k8s_namespace != nullptr) {
    
  } else {
    
  }
  _impl_.k8s_namespace_.SetAllocated(k8s_namespace, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.k8s_namespace_.IsDefault()) {
    _impl_.k8s_namespace_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.Resource.k8s_namespace)
}

// string k8s_pod_name = 7;
inline void Resource::clear_k8s_pod_name() {
  _impl_.k8s_pod_name_.ClearToEmpty();
}
inline const std::string& Resource::k8s_pod_name() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.Resource.k8s_pod_name)
  return _internal_k8s_pod_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Resource::set_k8s_pod_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.k8s_pod_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.Resource.k8s_pod_name)
}
inline std::string* Resource::mutable_k8s_pod_name() {
  std::string* _s = _internal_mutable_k8s_pod_name();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.Resource.k8s_pod_name)
  return _s;
}
inline const std::string& Resource::_internal_k8s_pod_name() const {
  return _impl_.k8s_pod_name_.Get();
}
inline void Resource::_internal_set_k8s_pod_name(const std::string& value) {
  
  _impl_.k8s_pod_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Resource::_internal_mutable_k8s_pod_name() {
  
  return _impl_.k8s_pod_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Resource::release_k8s_pod_name() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.Resource.k8s_pod_name)
  return _impl_.k8s_pod_name_.Release();
}
inline void Resource::set_allocated_k8s_pod_name(std::string* k8s_pod_name) {
  if (k8s_pod_name != nullptr) {
    
  } else {
    
  }
  _impl_.k8s_pod_name_.SetAllocated(k8s_pod_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.k8s_pod_name_.IsDefault()) {
    _impl_.k8s_pod_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.Resource.k8s_pod_name)
}

// string host_name = 8;
inline void Resource::clear_host_name() {
  _impl_.host_name_.ClearToEmpty();
}
inline const std::string& Resource::host_name() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.Resource.host_name)
  return _internal_host_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Resource::set_host_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.host_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.Resource.host_name)
}
inline std::string* Resource::mutable_host_name() {
  std::string* _s = _internal_mutable_host_name();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.Resource.host_name)
  return _s;
}
inline const std::string& Resource::_internal_host_name() const {
  return _impl_.host_name_.Get();
}
inline void Resource::_internal_set_host_name(const std::string& value) {
  
  _impl_.host_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Resource::_internal_mutable_host_name() {
  
  return _impl_.host_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Resource::release_host_name() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.Resource.host_name)
  return _impl_.host_name_.Release();
}
inline void Resource::set_allocated_host_name(std::string* host_name) {
  if (host_name != nullptr) {
    
  } else {
    
  }
  _impl_.host_name_.SetAllocated(host_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.host_name_.IsDefault()) {
    _impl_.host_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.Resource.host_name)
}

// string host_arch = 9;
inline void Resource::clear_host_arch() {
  _impl_.host_arch_.ClearToEmpty();
}
inline const std::string& Resource::host_arch() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.Resource.host_arch)
  return _internal_host_arch();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Resource::set_host_arch(ArgT0&& arg0, ArgT... args) {
 
 _impl_.host_arch_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.Resource.host_arch)
}
inline std::string* Resource::mutable_host_arch() {
  std::string* _s = _internal_mutable_host_arch();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.Resource.host_arch)
  return _s;
}
inline const std::string& Resource::_internal_host_arch() const {
  return _impl_.host_arch_.Get();
}
inline void Resource::_internal_set_host_arch(const std::string& value) {
  
  _impl_.host_arch_.Set(value, GetArenaForAllocation());
}
inline std::string* Resource::_internal_mutable_host_arch() {
  
  return _impl_.host_arch_.Mutable(GetArenaForAllocation());
}
inline std::string* Resource::release_host_arch() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.Resource.host_arch)
  return _impl_.host_arch_.Release();
}
inline void Resource::set_allocated_host_arch(std::string* host_arch) {
  if (host_arch != nullptr) {
    
  } else {
    
  }
  _impl_.host_arch_.SetAllocated(host_arch, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.host_arch_.IsDefault()) {
    _impl_.host_arch_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.Resource.host_arch)
}

// map<string, string> attributes = 20;
inline int Resource::_internal_attributes_size() const {
  return _impl_.attributes_.size();
}
inline int Resource::attributes_size() const {
  return _internal_attributes_size();
}
inline void Resource::clear_attributes() {
  _impl_.attributes_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Resource::_internal_attributes() const {
  return _impl_.attributes_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Resource::attributes() const {
  // @@protoc_insertion_point(field_map:unhinged.observability.v1.Resource.attributes)
  return _internal_attributes();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Resource::_internal_mutable_attributes() {
  return _impl_.attributes_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Resource::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_map:unhinged.observability.v1.Resource.attributes)
  return _internal_mutable_attributes();
}

// -------------------------------------------------------------------

// LogEvent

// string event_id = 1;
inline void LogEvent::clear_event_id() {
  _impl_.event_id_.ClearToEmpty();
}
inline const std::string& LogEvent::event_id() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.LogEvent.event_id)
  return _internal_event_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogEvent::set_event_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.event_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.LogEvent.event_id)
}
inline std::string* LogEvent::mutable_event_id() {
  std::string* _s = _internal_mutable_event_id();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.LogEvent.event_id)
  return _s;
}
inline const std::string& LogEvent::_internal_event_id() const {
  return _impl_.event_id_.Get();
}
inline void LogEvent::_internal_set_event_id(const std::string& value) {
  
  _impl_.event_id_.Set(value, GetArenaForAllocation());
}
inline std::string* LogEvent::_internal_mutable_event_id() {
  
  return _impl_.event_id_.Mutable(GetArenaForAllocation());
}
inline std::string* LogEvent::release_event_id() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.LogEvent.event_id)
  return _impl_.event_id_.Release();
}
inline void LogEvent::set_allocated_event_id(std::string* event_id) {
  if (event_id != nullptr) {
    
  } else {
    
  }
  _impl_.event_id_.SetAllocated(event_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.event_id_.IsDefault()) {
    _impl_.event_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.LogEvent.event_id)
}

// .google.protobuf.Timestamp timestamp = 2;
inline bool LogEvent::_internal_has_timestamp() const {
  return this != internal_default_instance() && _impl_.timestamp_ != nullptr;
}
inline bool LogEvent::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& LogEvent::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& LogEvent::timestamp() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.LogEvent.timestamp)
  return _internal_timestamp();
}
inline void LogEvent::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.LogEvent.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LogEvent::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LogEvent::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.LogEvent.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LogEvent::_internal_mutable_timestamp() {
  
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LogEvent::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.LogEvent.timestamp)
  return _msg;
}
inline void LogEvent::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.LogEvent.timestamp)
}

// string event_type = 3;
inline void LogEvent::clear_event_type() {
  _impl_.event_type_.ClearToEmpty();
}
inline const std::string& LogEvent::event_type() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.LogEvent.event_type)
  return _internal_event_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogEvent::set_event_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.event_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.LogEvent.event_type)
}
inline std::string* LogEvent::mutable_event_type() {
  std::string* _s = _internal_mutable_event_type();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.LogEvent.event_type)
  return _s;
}
inline const std::string& LogEvent::_internal_event_type() const {
  return _impl_.event_type_.Get();
}
inline void LogEvent::_internal_set_event_type(const std::string& value) {
  
  _impl_.event_type_.Set(value, GetArenaForAllocation());
}
inline std::string* LogEvent::_internal_mutable_event_type() {
  
  return _impl_.event_type_.Mutable(GetArenaForAllocation());
}
inline std::string* LogEvent::release_event_type() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.LogEvent.event_type)
  return _impl_.event_type_.Release();
}
inline void LogEvent::set_allocated_event_type(std::string* event_type) {
  if (event_type != nullptr) {
    
  } else {
    
  }
  _impl_.event_type_.SetAllocated(event_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.event_type_.IsDefault()) {
    _impl_.event_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.LogEvent.event_type)
}

// int64 sequence_number = 4;
inline void LogEvent::clear_sequence_number() {
  _impl_.sequence_number_ = int64_t{0};
}
inline int64_t LogEvent::_internal_sequence_number() const {
  return _impl_.sequence_number_;
}
inline int64_t LogEvent::sequence_number() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.LogEvent.sequence_number)
  return _internal_sequence_number();
}
inline void LogEvent::_internal_set_sequence_number(int64_t value) {
  
  _impl_.sequence_number_ = value;
}
inline void LogEvent::set_sequence_number(int64_t value) {
  _internal_set_sequence_number(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.LogEvent.sequence_number)
}

// .unhinged.observability.v1.TraceContext trace_context = 5;
inline bool LogEvent::_internal_has_trace_context() const {
  return this != internal_default_instance() && _impl_.trace_context_ != nullptr;
}
inline bool LogEvent::has_trace_context() const {
  return _internal_has_trace_context();
}
inline void LogEvent::clear_trace_context() {
  if (GetArenaForAllocation() == nullptr && _impl_.trace_context_ != nullptr) {
    delete _impl_.trace_context_;
  }
  _impl_.trace_context_ = nullptr;
}
inline const ::unhinged::observability::v1::TraceContext& LogEvent::_internal_trace_context() const {
  const ::unhinged::observability::v1::TraceContext* p = _impl_.trace_context_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::observability::v1::TraceContext&>(
      ::unhinged::observability::v1::_TraceContext_default_instance_);
}
inline const ::unhinged::observability::v1::TraceContext& LogEvent::trace_context() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.LogEvent.trace_context)
  return _internal_trace_context();
}
inline void LogEvent::unsafe_arena_set_allocated_trace_context(
    ::unhinged::observability::v1::TraceContext* trace_context) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.trace_context_);
  }
  _impl_.trace_context_ = trace_context;
  if (trace_context) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.LogEvent.trace_context)
}
inline ::unhinged::observability::v1::TraceContext* LogEvent::release_trace_context() {
  
  ::unhinged::observability::v1::TraceContext* temp = _impl_.trace_context_;
  _impl_.trace_context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::observability::v1::TraceContext* LogEvent::unsafe_arena_release_trace_context() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.LogEvent.trace_context)
  
  ::unhinged::observability::v1::TraceContext* temp = _impl_.trace_context_;
  _impl_.trace_context_ = nullptr;
  return temp;
}
inline ::unhinged::observability::v1::TraceContext* LogEvent::_internal_mutable_trace_context() {
  
  if (_impl_.trace_context_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::observability::v1::TraceContext>(GetArenaForAllocation());
    _impl_.trace_context_ = p;
  }
  return _impl_.trace_context_;
}
inline ::unhinged::observability::v1::TraceContext* LogEvent::mutable_trace_context() {
  ::unhinged::observability::v1::TraceContext* _msg = _internal_mutable_trace_context();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.LogEvent.trace_context)
  return _msg;
}
inline void LogEvent::set_allocated_trace_context(::unhinged::observability::v1::TraceContext* trace_context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.trace_context_;
  }
  if (trace_context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(trace_context);
    if (message_arena != submessage_arena) {
      trace_context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trace_context, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.trace_context_ = trace_context;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.LogEvent.trace_context)
}

// .unhinged.observability.v1.Resource resource = 6;
inline bool LogEvent::_internal_has_resource() const {
  return this != internal_default_instance() && _impl_.resource_ != nullptr;
}
inline bool LogEvent::has_resource() const {
  return _internal_has_resource();
}
inline void LogEvent::clear_resource() {
  if (GetArenaForAllocation() == nullptr && _impl_.resource_ != nullptr) {
    delete _impl_.resource_;
  }
  _impl_.resource_ = nullptr;
}
inline const ::unhinged::observability::v1::Resource& LogEvent::_internal_resource() const {
  const ::unhinged::observability::v1::Resource* p = _impl_.resource_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::observability::v1::Resource&>(
      ::unhinged::observability::v1::_Resource_default_instance_);
}
inline const ::unhinged::observability::v1::Resource& LogEvent::resource() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.LogEvent.resource)
  return _internal_resource();
}
inline void LogEvent::unsafe_arena_set_allocated_resource(
    ::unhinged::observability::v1::Resource* resource) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.resource_);
  }
  _impl_.resource_ = resource;
  if (resource) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.LogEvent.resource)
}
inline ::unhinged::observability::v1::Resource* LogEvent::release_resource() {
  
  ::unhinged::observability::v1::Resource* temp = _impl_.resource_;
  _impl_.resource_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::observability::v1::Resource* LogEvent::unsafe_arena_release_resource() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.LogEvent.resource)
  
  ::unhinged::observability::v1::Resource* temp = _impl_.resource_;
  _impl_.resource_ = nullptr;
  return temp;
}
inline ::unhinged::observability::v1::Resource* LogEvent::_internal_mutable_resource() {
  
  if (_impl_.resource_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::observability::v1::Resource>(GetArenaForAllocation());
    _impl_.resource_ = p;
  }
  return _impl_.resource_;
}
inline ::unhinged::observability::v1::Resource* LogEvent::mutable_resource() {
  ::unhinged::observability::v1::Resource* _msg = _internal_mutable_resource();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.LogEvent.resource)
  return _msg;
}
inline void LogEvent::set_allocated_resource(::unhinged::observability::v1::Resource* resource) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.resource_;
  }
  if (resource) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(resource);
    if (message_arena != submessage_arena) {
      resource = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, resource, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.resource_ = resource;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.LogEvent.resource)
}

// .unhinged.observability.v1.LogLevel level = 10;
inline void LogEvent::clear_level() {
  _impl_.level_ = 0;
}
inline ::unhinged::observability::v1::LogLevel LogEvent::_internal_level() const {
  return static_cast< ::unhinged::observability::v1::LogLevel >(_impl_.level_);
}
inline ::unhinged::observability::v1::LogLevel LogEvent::level() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.LogEvent.level)
  return _internal_level();
}
inline void LogEvent::_internal_set_level(::unhinged::observability::v1::LogLevel value) {
  
  _impl_.level_ = value;
}
inline void LogEvent::set_level(::unhinged::observability::v1::LogLevel value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.LogEvent.level)
}

// string message = 11;
inline void LogEvent::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& LogEvent::message() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.LogEvent.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogEvent::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.LogEvent.message)
}
inline std::string* LogEvent::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.LogEvent.message)
  return _s;
}
inline const std::string& LogEvent::_internal_message() const {
  return _impl_.message_.Get();
}
inline void LogEvent::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* LogEvent::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* LogEvent::release_message() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.LogEvent.message)
  return _impl_.message_.Release();
}
inline void LogEvent::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.LogEvent.message)
}

// .google.protobuf.Struct metadata = 12;
inline bool LogEvent::_internal_has_metadata() const {
  return this != internal_default_instance() && _impl_.metadata_ != nullptr;
}
inline bool LogEvent::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& LogEvent::_internal_metadata() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& LogEvent::metadata() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.LogEvent.metadata)
  return _internal_metadata();
}
inline void LogEvent::unsafe_arena_set_allocated_metadata(
    ::PROTOBUF_NAMESPACE_ID::Struct* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.LogEvent.metadata)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* LogEvent::release_metadata() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* LogEvent::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.LogEvent.metadata)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* LogEvent::_internal_mutable_metadata() {
  
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* LogEvent::mutable_metadata() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.LogEvent.metadata)
  return _msg;
}
inline void LogEvent::set_allocated_metadata(::PROTOBUF_NAMESPACE_ID::Struct* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.LogEvent.metadata)
}

// .unhinged.observability.v1.ErrorInfo error = 15;
inline bool LogEvent::_internal_has_error() const {
  return this != internal_default_instance() && _impl_.error_ != nullptr;
}
inline bool LogEvent::has_error() const {
  return _internal_has_error();
}
inline void LogEvent::clear_error() {
  if (GetArenaForAllocation() == nullptr && _impl_.error_ != nullptr) {
    delete _impl_.error_;
  }
  _impl_.error_ = nullptr;
}
inline const ::unhinged::observability::v1::ErrorInfo& LogEvent::_internal_error() const {
  const ::unhinged::observability::v1::ErrorInfo* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::observability::v1::ErrorInfo&>(
      ::unhinged::observability::v1::_ErrorInfo_default_instance_);
}
inline const ::unhinged::observability::v1::ErrorInfo& LogEvent::error() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.LogEvent.error)
  return _internal_error();
}
inline void LogEvent::unsafe_arena_set_allocated_error(
    ::unhinged::observability::v1::ErrorInfo* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.LogEvent.error)
}
inline ::unhinged::observability::v1::ErrorInfo* LogEvent::release_error() {
  
  ::unhinged::observability::v1::ErrorInfo* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::observability::v1::ErrorInfo* LogEvent::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.LogEvent.error)
  
  ::unhinged::observability::v1::ErrorInfo* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::unhinged::observability::v1::ErrorInfo* LogEvent::_internal_mutable_error() {
  
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::observability::v1::ErrorInfo>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::unhinged::observability::v1::ErrorInfo* LogEvent::mutable_error() {
  ::unhinged::observability::v1::ErrorInfo* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.LogEvent.error)
  return _msg;
}
inline void LogEvent::set_allocated_error(::unhinged::observability::v1::ErrorInfo* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.LogEvent.error)
}

// .unhinged.observability.v1.DestinationFlags destinations = 20;
inline bool LogEvent::_internal_has_destinations() const {
  return this != internal_default_instance() && _impl_.destinations_ != nullptr;
}
inline bool LogEvent::has_destinations() const {
  return _internal_has_destinations();
}
inline void LogEvent::clear_destinations() {
  if (GetArenaForAllocation() == nullptr && _impl_.destinations_ != nullptr) {
    delete _impl_.destinations_;
  }
  _impl_.destinations_ = nullptr;
}
inline const ::unhinged::observability::v1::DestinationFlags& LogEvent::_internal_destinations() const {
  const ::unhinged::observability::v1::DestinationFlags* p = _impl_.destinations_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::observability::v1::DestinationFlags&>(
      ::unhinged::observability::v1::_DestinationFlags_default_instance_);
}
inline const ::unhinged::observability::v1::DestinationFlags& LogEvent::destinations() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.LogEvent.destinations)
  return _internal_destinations();
}
inline void LogEvent::unsafe_arena_set_allocated_destinations(
    ::unhinged::observability::v1::DestinationFlags* destinations) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.destinations_);
  }
  _impl_.destinations_ = destinations;
  if (destinations) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.LogEvent.destinations)
}
inline ::unhinged::observability::v1::DestinationFlags* LogEvent::release_destinations() {
  
  ::unhinged::observability::v1::DestinationFlags* temp = _impl_.destinations_;
  _impl_.destinations_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::observability::v1::DestinationFlags* LogEvent::unsafe_arena_release_destinations() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.LogEvent.destinations)
  
  ::unhinged::observability::v1::DestinationFlags* temp = _impl_.destinations_;
  _impl_.destinations_ = nullptr;
  return temp;
}
inline ::unhinged::observability::v1::DestinationFlags* LogEvent::_internal_mutable_destinations() {
  
  if (_impl_.destinations_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::observability::v1::DestinationFlags>(GetArenaForAllocation());
    _impl_.destinations_ = p;
  }
  return _impl_.destinations_;
}
inline ::unhinged::observability::v1::DestinationFlags* LogEvent::mutable_destinations() {
  ::unhinged::observability::v1::DestinationFlags* _msg = _internal_mutable_destinations();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.LogEvent.destinations)
  return _msg;
}
inline void LogEvent::set_allocated_destinations(::unhinged::observability::v1::DestinationFlags* destinations) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.destinations_;
  }
  if (destinations) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(destinations);
    if (message_arena != submessage_arena) {
      destinations = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, destinations, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.destinations_ = destinations;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.LogEvent.destinations)
}

// .unhinged.observability.v1.PartitionInfo partition_info = 25;
inline bool LogEvent::_internal_has_partition_info() const {
  return this != internal_default_instance() && _impl_.partition_info_ != nullptr;
}
inline bool LogEvent::has_partition_info() const {
  return _internal_has_partition_info();
}
inline void LogEvent::clear_partition_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.partition_info_ != nullptr) {
    delete _impl_.partition_info_;
  }
  _impl_.partition_info_ = nullptr;
}
inline const ::unhinged::observability::v1::PartitionInfo& LogEvent::_internal_partition_info() const {
  const ::unhinged::observability::v1::PartitionInfo* p = _impl_.partition_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::observability::v1::PartitionInfo&>(
      ::unhinged::observability::v1::_PartitionInfo_default_instance_);
}
inline const ::unhinged::observability::v1::PartitionInfo& LogEvent::partition_info() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.LogEvent.partition_info)
  return _internal_partition_info();
}
inline void LogEvent::unsafe_arena_set_allocated_partition_info(
    ::unhinged::observability::v1::PartitionInfo* partition_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.partition_info_);
  }
  _impl_.partition_info_ = partition_info;
  if (partition_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.LogEvent.partition_info)
}
inline ::unhinged::observability::v1::PartitionInfo* LogEvent::release_partition_info() {
  
  ::unhinged::observability::v1::PartitionInfo* temp = _impl_.partition_info_;
  _impl_.partition_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::observability::v1::PartitionInfo* LogEvent::unsafe_arena_release_partition_info() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.LogEvent.partition_info)
  
  ::unhinged::observability::v1::PartitionInfo* temp = _impl_.partition_info_;
  _impl_.partition_info_ = nullptr;
  return temp;
}
inline ::unhinged::observability::v1::PartitionInfo* LogEvent::_internal_mutable_partition_info() {
  
  if (_impl_.partition_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::observability::v1::PartitionInfo>(GetArenaForAllocation());
    _impl_.partition_info_ = p;
  }
  return _impl_.partition_info_;
}
inline ::unhinged::observability::v1::PartitionInfo* LogEvent::mutable_partition_info() {
  ::unhinged::observability::v1::PartitionInfo* _msg = _internal_mutable_partition_info();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.LogEvent.partition_info)
  return _msg;
}
inline void LogEvent::set_allocated_partition_info(::unhinged::observability::v1::PartitionInfo* partition_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.partition_info_;
  }
  if (partition_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(partition_info);
    if (message_arena != submessage_arena) {
      partition_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, partition_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.partition_info_ = partition_info;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.LogEvent.partition_info)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ErrorInfo

// string error_type = 1;
inline void ErrorInfo::clear_error_type() {
  _impl_.error_type_.ClearToEmpty();
}
inline const std::string& ErrorInfo::error_type() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.ErrorInfo.error_type)
  return _internal_error_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ErrorInfo::set_error_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.ErrorInfo.error_type)
}
inline std::string* ErrorInfo::mutable_error_type() {
  std::string* _s = _internal_mutable_error_type();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.ErrorInfo.error_type)
  return _s;
}
inline const std::string& ErrorInfo::_internal_error_type() const {
  return _impl_.error_type_.Get();
}
inline void ErrorInfo::_internal_set_error_type(const std::string& value) {
  
  _impl_.error_type_.Set(value, GetArenaForAllocation());
}
inline std::string* ErrorInfo::_internal_mutable_error_type() {
  
  return _impl_.error_type_.Mutable(GetArenaForAllocation());
}
inline std::string* ErrorInfo::release_error_type() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.ErrorInfo.error_type)
  return _impl_.error_type_.Release();
}
inline void ErrorInfo::set_allocated_error_type(std::string* error_type) {
  if (error_type != nullptr) {
    
  } else {
    
  }
  _impl_.error_type_.SetAllocated(error_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_type_.IsDefault()) {
    _impl_.error_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.ErrorInfo.error_type)
}

// string error_message = 2;
inline void ErrorInfo::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& ErrorInfo::error_message() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.ErrorInfo.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ErrorInfo::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.ErrorInfo.error_message)
}
inline std::string* ErrorInfo::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.ErrorInfo.error_message)
  return _s;
}
inline const std::string& ErrorInfo::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void ErrorInfo::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* ErrorInfo::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* ErrorInfo::release_error_message() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.ErrorInfo.error_message)
  return _impl_.error_message_.Release();
}
inline void ErrorInfo::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.ErrorInfo.error_message)
}

// string stack_trace = 3;
inline void ErrorInfo::clear_stack_trace() {
  _impl_.stack_trace_.ClearToEmpty();
}
inline const std::string& ErrorInfo::stack_trace() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.ErrorInfo.stack_trace)
  return _internal_stack_trace();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ErrorInfo::set_stack_trace(ArgT0&& arg0, ArgT... args) {
 
 _impl_.stack_trace_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.ErrorInfo.stack_trace)
}
inline std::string* ErrorInfo::mutable_stack_trace() {
  std::string* _s = _internal_mutable_stack_trace();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.ErrorInfo.stack_trace)
  return _s;
}
inline const std::string& ErrorInfo::_internal_stack_trace() const {
  return _impl_.stack_trace_.Get();
}
inline void ErrorInfo::_internal_set_stack_trace(const std::string& value) {
  
  _impl_.stack_trace_.Set(value, GetArenaForAllocation());
}
inline std::string* ErrorInfo::_internal_mutable_stack_trace() {
  
  return _impl_.stack_trace_.Mutable(GetArenaForAllocation());
}
inline std::string* ErrorInfo::release_stack_trace() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.ErrorInfo.stack_trace)
  return _impl_.stack_trace_.Release();
}
inline void ErrorInfo::set_allocated_stack_trace(std::string* stack_trace) {
  if (stack_trace != nullptr) {
    
  } else {
    
  }
  _impl_.stack_trace_.SetAllocated(stack_trace, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stack_trace_.IsDefault()) {
    _impl_.stack_trace_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.ErrorInfo.stack_trace)
}

// string error_code = 4;
inline void ErrorInfo::clear_error_code() {
  _impl_.error_code_.ClearToEmpty();
}
inline const std::string& ErrorInfo::error_code() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.ErrorInfo.error_code)
  return _internal_error_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ErrorInfo::set_error_code(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.ErrorInfo.error_code)
}
inline std::string* ErrorInfo::mutable_error_code() {
  std::string* _s = _internal_mutable_error_code();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.ErrorInfo.error_code)
  return _s;
}
inline const std::string& ErrorInfo::_internal_error_code() const {
  return _impl_.error_code_.Get();
}
inline void ErrorInfo::_internal_set_error_code(const std::string& value) {
  
  _impl_.error_code_.Set(value, GetArenaForAllocation());
}
inline std::string* ErrorInfo::_internal_mutable_error_code() {
  
  return _impl_.error_code_.Mutable(GetArenaForAllocation());
}
inline std::string* ErrorInfo::release_error_code() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.ErrorInfo.error_code)
  return _impl_.error_code_.Release();
}
inline void ErrorInfo::set_allocated_error_code(std::string* error_code) {
  if (error_code != nullptr) {
    
  } else {
    
  }
  _impl_.error_code_.SetAllocated(error_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_code_.IsDefault()) {
    _impl_.error_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.ErrorInfo.error_code)
}

// map<string, string> error_attributes = 5;
inline int ErrorInfo::_internal_error_attributes_size() const {
  return _impl_.error_attributes_.size();
}
inline int ErrorInfo::error_attributes_size() const {
  return _internal_error_attributes_size();
}
inline void ErrorInfo::clear_error_attributes() {
  _impl_.error_attributes_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ErrorInfo::_internal_error_attributes() const {
  return _impl_.error_attributes_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ErrorInfo::error_attributes() const {
  // @@protoc_insertion_point(field_map:unhinged.observability.v1.ErrorInfo.error_attributes)
  return _internal_error_attributes();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ErrorInfo::_internal_mutable_error_attributes() {
  return _impl_.error_attributes_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ErrorInfo::mutable_error_attributes() {
  // @@protoc_insertion_point(field_mutable_map:unhinged.observability.v1.ErrorInfo.error_attributes)
  return _internal_mutable_error_attributes();
}

// -------------------------------------------------------------------

// DestinationFlags

// bool console = 1;
inline void DestinationFlags::clear_console() {
  _impl_.console_ = false;
}
inline bool DestinationFlags::_internal_console() const {
  return _impl_.console_;
}
inline bool DestinationFlags::console() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.DestinationFlags.console)
  return _internal_console();
}
inline void DestinationFlags::_internal_set_console(bool value) {
  
  _impl_.console_ = value;
}
inline void DestinationFlags::set_console(bool value) {
  _internal_set_console(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.DestinationFlags.console)
}

// bool cdc_stream = 2;
inline void DestinationFlags::clear_cdc_stream() {
  _impl_.cdc_stream_ = false;
}
inline bool DestinationFlags::_internal_cdc_stream() const {
  return _impl_.cdc_stream_;
}
inline bool DestinationFlags::cdc_stream() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.DestinationFlags.cdc_stream)
  return _internal_cdc_stream();
}
inline void DestinationFlags::_internal_set_cdc_stream(bool value) {
  
  _impl_.cdc_stream_ = value;
}
inline void DestinationFlags::set_cdc_stream(bool value) {
  _internal_set_cdc_stream(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.DestinationFlags.cdc_stream)
}

// bool data_lake = 3;
inline void DestinationFlags::clear_data_lake() {
  _impl_.data_lake_ = false;
}
inline bool DestinationFlags::_internal_data_lake() const {
  return _impl_.data_lake_;
}
inline bool DestinationFlags::data_lake() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.DestinationFlags.data_lake)
  return _internal_data_lake();
}
inline void DestinationFlags::_internal_set_data_lake(bool value) {
  
  _impl_.data_lake_ = value;
}
inline void DestinationFlags::set_data_lake(bool value) {
  _internal_set_data_lake(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.DestinationFlags.data_lake)
}

// .unhinged.observability.v1.DataLakeOptions data_lake_options = 10;
inline bool DestinationFlags::_internal_has_data_lake_options() const {
  return this != internal_default_instance() && _impl_.data_lake_options_ != nullptr;
}
inline bool DestinationFlags::has_data_lake_options() const {
  return _internal_has_data_lake_options();
}
inline void DestinationFlags::clear_data_lake_options() {
  if (GetArenaForAllocation() == nullptr && _impl_.data_lake_options_ != nullptr) {
    delete _impl_.data_lake_options_;
  }
  _impl_.data_lake_options_ = nullptr;
}
inline const ::unhinged::observability::v1::DataLakeOptions& DestinationFlags::_internal_data_lake_options() const {
  const ::unhinged::observability::v1::DataLakeOptions* p = _impl_.data_lake_options_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::observability::v1::DataLakeOptions&>(
      ::unhinged::observability::v1::_DataLakeOptions_default_instance_);
}
inline const ::unhinged::observability::v1::DataLakeOptions& DestinationFlags::data_lake_options() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.DestinationFlags.data_lake_options)
  return _internal_data_lake_options();
}
inline void DestinationFlags::unsafe_arena_set_allocated_data_lake_options(
    ::unhinged::observability::v1::DataLakeOptions* data_lake_options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_lake_options_);
  }
  _impl_.data_lake_options_ = data_lake_options;
  if (data_lake_options) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.DestinationFlags.data_lake_options)
}
inline ::unhinged::observability::v1::DataLakeOptions* DestinationFlags::release_data_lake_options() {
  
  ::unhinged::observability::v1::DataLakeOptions* temp = _impl_.data_lake_options_;
  _impl_.data_lake_options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::observability::v1::DataLakeOptions* DestinationFlags::unsafe_arena_release_data_lake_options() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.DestinationFlags.data_lake_options)
  
  ::unhinged::observability::v1::DataLakeOptions* temp = _impl_.data_lake_options_;
  _impl_.data_lake_options_ = nullptr;
  return temp;
}
inline ::unhinged::observability::v1::DataLakeOptions* DestinationFlags::_internal_mutable_data_lake_options() {
  
  if (_impl_.data_lake_options_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::observability::v1::DataLakeOptions>(GetArenaForAllocation());
    _impl_.data_lake_options_ = p;
  }
  return _impl_.data_lake_options_;
}
inline ::unhinged::observability::v1::DataLakeOptions* DestinationFlags::mutable_data_lake_options() {
  ::unhinged::observability::v1::DataLakeOptions* _msg = _internal_mutable_data_lake_options();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.DestinationFlags.data_lake_options)
  return _msg;
}
inline void DestinationFlags::set_allocated_data_lake_options(::unhinged::observability::v1::DataLakeOptions* data_lake_options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.data_lake_options_;
  }
  if (data_lake_options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(data_lake_options);
    if (message_arena != submessage_arena) {
      data_lake_options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data_lake_options, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_lake_options_ = data_lake_options;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.DestinationFlags.data_lake_options)
}

// -------------------------------------------------------------------

// DataLakeOptions

// string table_name = 1;
inline void DataLakeOptions::clear_table_name() {
  _impl_.table_name_.ClearToEmpty();
}
inline const std::string& DataLakeOptions::table_name() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.DataLakeOptions.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataLakeOptions::set_table_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.table_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.DataLakeOptions.table_name)
}
inline std::string* DataLakeOptions::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.DataLakeOptions.table_name)
  return _s;
}
inline const std::string& DataLakeOptions::_internal_table_name() const {
  return _impl_.table_name_.Get();
}
inline void DataLakeOptions::_internal_set_table_name(const std::string& value) {
  
  _impl_.table_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DataLakeOptions::_internal_mutable_table_name() {
  
  return _impl_.table_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DataLakeOptions::release_table_name() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.DataLakeOptions.table_name)
  return _impl_.table_name_.Release();
}
inline void DataLakeOptions::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    
  } else {
    
  }
  _impl_.table_name_.SetAllocated(table_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.table_name_.IsDefault()) {
    _impl_.table_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.DataLakeOptions.table_name)
}

// string partition_strategy = 2;
inline void DataLakeOptions::clear_partition_strategy() {
  _impl_.partition_strategy_.ClearToEmpty();
}
inline const std::string& DataLakeOptions::partition_strategy() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.DataLakeOptions.partition_strategy)
  return _internal_partition_strategy();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataLakeOptions::set_partition_strategy(ArgT0&& arg0, ArgT... args) {
 
 _impl_.partition_strategy_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.DataLakeOptions.partition_strategy)
}
inline std::string* DataLakeOptions::mutable_partition_strategy() {
  std::string* _s = _internal_mutable_partition_strategy();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.DataLakeOptions.partition_strategy)
  return _s;
}
inline const std::string& DataLakeOptions::_internal_partition_strategy() const {
  return _impl_.partition_strategy_.Get();
}
inline void DataLakeOptions::_internal_set_partition_strategy(const std::string& value) {
  
  _impl_.partition_strategy_.Set(value, GetArenaForAllocation());
}
inline std::string* DataLakeOptions::_internal_mutable_partition_strategy() {
  
  return _impl_.partition_strategy_.Mutable(GetArenaForAllocation());
}
inline std::string* DataLakeOptions::release_partition_strategy() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.DataLakeOptions.partition_strategy)
  return _impl_.partition_strategy_.Release();
}
inline void DataLakeOptions::set_allocated_partition_strategy(std::string* partition_strategy) {
  if (partition_strategy != nullptr) {
    
  } else {
    
  }
  _impl_.partition_strategy_.SetAllocated(partition_strategy, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.partition_strategy_.IsDefault()) {
    _impl_.partition_strategy_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.DataLakeOptions.partition_strategy)
}

// int32 batch_size = 3;
inline void DataLakeOptions::clear_batch_size() {
  _impl_.batch_size_ = 0;
}
inline int32_t DataLakeOptions::_internal_batch_size() const {
  return _impl_.batch_size_;
}
inline int32_t DataLakeOptions::batch_size() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.DataLakeOptions.batch_size)
  return _internal_batch_size();
}
inline void DataLakeOptions::_internal_set_batch_size(int32_t value) {
  
  _impl_.batch_size_ = value;
}
inline void DataLakeOptions::set_batch_size(int32_t value) {
  _internal_set_batch_size(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.DataLakeOptions.batch_size)
}

// int32 flush_interval_seconds = 4;
inline void DataLakeOptions::clear_flush_interval_seconds() {
  _impl_.flush_interval_seconds_ = 0;
}
inline int32_t DataLakeOptions::_internal_flush_interval_seconds() const {
  return _impl_.flush_interval_seconds_;
}
inline int32_t DataLakeOptions::flush_interval_seconds() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.DataLakeOptions.flush_interval_seconds)
  return _internal_flush_interval_seconds();
}
inline void DataLakeOptions::_internal_set_flush_interval_seconds(int32_t value) {
  
  _impl_.flush_interval_seconds_ = value;
}
inline void DataLakeOptions::set_flush_interval_seconds(int32_t value) {
  _internal_set_flush_interval_seconds(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.DataLakeOptions.flush_interval_seconds)
}

// .unhinged.observability.v1.CompressionType compression = 5;
inline void DataLakeOptions::clear_compression() {
  _impl_.compression_ = 0;
}
inline ::unhinged::observability::v1::CompressionType DataLakeOptions::_internal_compression() const {
  return static_cast< ::unhinged::observability::v1::CompressionType >(_impl_.compression_);
}
inline ::unhinged::observability::v1::CompressionType DataLakeOptions::compression() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.DataLakeOptions.compression)
  return _internal_compression();
}
inline void DataLakeOptions::_internal_set_compression(::unhinged::observability::v1::CompressionType value) {
  
  _impl_.compression_ = value;
}
inline void DataLakeOptions::set_compression(::unhinged::observability::v1::CompressionType value) {
  _internal_set_compression(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.DataLakeOptions.compression)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// PartitionInfo

// string date_partition = 1;
inline void PartitionInfo::clear_date_partition() {
  _impl_.date_partition_.ClearToEmpty();
}
inline const std::string& PartitionInfo::date_partition() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.PartitionInfo.date_partition)
  return _internal_date_partition();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PartitionInfo::set_date_partition(ArgT0&& arg0, ArgT... args) {
 
 _impl_.date_partition_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.PartitionInfo.date_partition)
}
inline std::string* PartitionInfo::mutable_date_partition() {
  std::string* _s = _internal_mutable_date_partition();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.PartitionInfo.date_partition)
  return _s;
}
inline const std::string& PartitionInfo::_internal_date_partition() const {
  return _impl_.date_partition_.Get();
}
inline void PartitionInfo::_internal_set_date_partition(const std::string& value) {
  
  _impl_.date_partition_.Set(value, GetArenaForAllocation());
}
inline std::string* PartitionInfo::_internal_mutable_date_partition() {
  
  return _impl_.date_partition_.Mutable(GetArenaForAllocation());
}
inline std::string* PartitionInfo::release_date_partition() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.PartitionInfo.date_partition)
  return _impl_.date_partition_.Release();
}
inline void PartitionInfo::set_allocated_date_partition(std::string* date_partition) {
  if (date_partition != nullptr) {
    
  } else {
    
  }
  _impl_.date_partition_.SetAllocated(date_partition, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.date_partition_.IsDefault()) {
    _impl_.date_partition_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.PartitionInfo.date_partition)
}

// string hour_partition = 2;
inline void PartitionInfo::clear_hour_partition() {
  _impl_.hour_partition_.ClearToEmpty();
}
inline const std::string& PartitionInfo::hour_partition() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.PartitionInfo.hour_partition)
  return _internal_hour_partition();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PartitionInfo::set_hour_partition(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hour_partition_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.PartitionInfo.hour_partition)
}
inline std::string* PartitionInfo::mutable_hour_partition() {
  std::string* _s = _internal_mutable_hour_partition();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.PartitionInfo.hour_partition)
  return _s;
}
inline const std::string& PartitionInfo::_internal_hour_partition() const {
  return _impl_.hour_partition_.Get();
}
inline void PartitionInfo::_internal_set_hour_partition(const std::string& value) {
  
  _impl_.hour_partition_.Set(value, GetArenaForAllocation());
}
inline std::string* PartitionInfo::_internal_mutable_hour_partition() {
  
  return _impl_.hour_partition_.Mutable(GetArenaForAllocation());
}
inline std::string* PartitionInfo::release_hour_partition() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.PartitionInfo.hour_partition)
  return _impl_.hour_partition_.Release();
}
inline void PartitionInfo::set_allocated_hour_partition(std::string* hour_partition) {
  if (hour_partition != nullptr) {
    
  } else {
    
  }
  _impl_.hour_partition_.SetAllocated(hour_partition, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hour_partition_.IsDefault()) {
    _impl_.hour_partition_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.PartitionInfo.hour_partition)
}

// string service_partition = 3;
inline void PartitionInfo::clear_service_partition() {
  _impl_.service_partition_.ClearToEmpty();
}
inline const std::string& PartitionInfo::service_partition() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.PartitionInfo.service_partition)
  return _internal_service_partition();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PartitionInfo::set_service_partition(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_partition_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.PartitionInfo.service_partition)
}
inline std::string* PartitionInfo::mutable_service_partition() {
  std::string* _s = _internal_mutable_service_partition();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.PartitionInfo.service_partition)
  return _s;
}
inline const std::string& PartitionInfo::_internal_service_partition() const {
  return _impl_.service_partition_.Get();
}
inline void PartitionInfo::_internal_set_service_partition(const std::string& value) {
  
  _impl_.service_partition_.Set(value, GetArenaForAllocation());
}
inline std::string* PartitionInfo::_internal_mutable_service_partition() {
  
  return _impl_.service_partition_.Mutable(GetArenaForAllocation());
}
inline std::string* PartitionInfo::release_service_partition() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.PartitionInfo.service_partition)
  return _impl_.service_partition_.Release();
}
inline void PartitionInfo::set_allocated_service_partition(std::string* service_partition) {
  if (service_partition != nullptr) {
    
  } else {
    
  }
  _impl_.service_partition_.SetAllocated(service_partition, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_partition_.IsDefault()) {
    _impl_.service_partition_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.PartitionInfo.service_partition)
}

// string level_partition = 4;
inline void PartitionInfo::clear_level_partition() {
  _impl_.level_partition_.ClearToEmpty();
}
inline const std::string& PartitionInfo::level_partition() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.PartitionInfo.level_partition)
  return _internal_level_partition();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PartitionInfo::set_level_partition(ArgT0&& arg0, ArgT... args) {
 
 _impl_.level_partition_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.PartitionInfo.level_partition)
}
inline std::string* PartitionInfo::mutable_level_partition() {
  std::string* _s = _internal_mutable_level_partition();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.PartitionInfo.level_partition)
  return _s;
}
inline const std::string& PartitionInfo::_internal_level_partition() const {
  return _impl_.level_partition_.Get();
}
inline void PartitionInfo::_internal_set_level_partition(const std::string& value) {
  
  _impl_.level_partition_.Set(value, GetArenaForAllocation());
}
inline std::string* PartitionInfo::_internal_mutable_level_partition() {
  
  return _impl_.level_partition_.Mutable(GetArenaForAllocation());
}
inline std::string* PartitionInfo::release_level_partition() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.PartitionInfo.level_partition)
  return _impl_.level_partition_.Release();
}
inline void PartitionInfo::set_allocated_level_partition(std::string* level_partition) {
  if (level_partition != nullptr) {
    
  } else {
    
  }
  _impl_.level_partition_.SetAllocated(level_partition, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.level_partition_.IsDefault()) {
    _impl_.level_partition_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.PartitionInfo.level_partition)
}

// map<string, string> custom_partitions = 10;
inline int PartitionInfo::_internal_custom_partitions_size() const {
  return _impl_.custom_partitions_.size();
}
inline int PartitionInfo::custom_partitions_size() const {
  return _internal_custom_partitions_size();
}
inline void PartitionInfo::clear_custom_partitions() {
  _impl_.custom_partitions_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
PartitionInfo::_internal_custom_partitions() const {
  return _impl_.custom_partitions_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
PartitionInfo::custom_partitions() const {
  // @@protoc_insertion_point(field_map:unhinged.observability.v1.PartitionInfo.custom_partitions)
  return _internal_custom_partitions();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
PartitionInfo::_internal_mutable_custom_partitions() {
  return _impl_.custom_partitions_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
PartitionInfo::mutable_custom_partitions() {
  // @@protoc_insertion_point(field_mutable_map:unhinged.observability.v1.PartitionInfo.custom_partitions)
  return _internal_mutable_custom_partitions();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace observability
}  // namespace unhinged

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::unhinged::observability::v1::LogLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::unhinged::observability::v1::LogLevel>() {
  return ::unhinged::observability::v1::LogLevel_descriptor();
}
template <> struct is_proto_enum< ::unhinged::observability::v1::CompressionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::unhinged::observability::v1::CompressionType>() {
  return ::unhinged::observability::v1::CompressionType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_observability_2eproto
