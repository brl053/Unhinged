// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: observability.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_observability_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_observability_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
#include <google/protobuf/any.pb.h>
#include <google/protobuf/struct.pb.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_observability_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_observability_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_observability_2eproto;
namespace unhinged {
namespace observability {
namespace v1 {
class AttributeArray;
struct AttributeArrayDefaultTypeInternal;
extern AttributeArrayDefaultTypeInternal _AttributeArray_default_instance_;
class AttributeKeyValue;
struct AttributeKeyValueDefaultTypeInternal;
extern AttributeKeyValueDefaultTypeInternal _AttributeKeyValue_default_instance_;
class AttributeKeyValueList;
struct AttributeKeyValueListDefaultTypeInternal;
extern AttributeKeyValueListDefaultTypeInternal _AttributeKeyValueList_default_instance_;
class AttributeValue;
struct AttributeValueDefaultTypeInternal;
extern AttributeValueDefaultTypeInternal _AttributeValue_default_instance_;
class CounterData;
struct CounterDataDefaultTypeInternal;
extern CounterDataDefaultTypeInternal _CounterData_default_instance_;
class DataLakeOptions;
struct DataLakeOptionsDefaultTypeInternal;
extern DataLakeOptionsDefaultTypeInternal _DataLakeOptions_default_instance_;
class DependencyHealth;
struct DependencyHealthDefaultTypeInternal;
extern DependencyHealthDefaultTypeInternal _DependencyHealth_default_instance_;
class DestinationFlags;
struct DestinationFlagsDefaultTypeInternal;
extern DestinationFlagsDefaultTypeInternal _DestinationFlags_default_instance_;
class ErrorInfo;
struct ErrorInfoDefaultTypeInternal;
extern ErrorInfoDefaultTypeInternal _ErrorInfo_default_instance_;
class ErrorInfo_ErrorAttributesEntry_DoNotUse;
struct ErrorInfo_ErrorAttributesEntry_DoNotUseDefaultTypeInternal;
extern ErrorInfo_ErrorAttributesEntry_DoNotUseDefaultTypeInternal _ErrorInfo_ErrorAttributesEntry_DoNotUse_default_instance_;
class Exemplar;
struct ExemplarDefaultTypeInternal;
extern ExemplarDefaultTypeInternal _Exemplar_default_instance_;
class Exemplar_FilteredAttributesEntry_DoNotUse;
struct Exemplar_FilteredAttributesEntry_DoNotUseDefaultTypeInternal;
extern Exemplar_FilteredAttributesEntry_DoNotUseDefaultTypeInternal _Exemplar_FilteredAttributesEntry_DoNotUse_default_instance_;
class GaugeData;
struct GaugeDataDefaultTypeInternal;
extern GaugeDataDefaultTypeInternal _GaugeData_default_instance_;
class HealthCheck;
struct HealthCheckDefaultTypeInternal;
extern HealthCheckDefaultTypeInternal _HealthCheck_default_instance_;
class HealthCheck_MetadataEntry_DoNotUse;
struct HealthCheck_MetadataEntry_DoNotUseDefaultTypeInternal;
extern HealthCheck_MetadataEntry_DoNotUseDefaultTypeInternal _HealthCheck_MetadataEntry_DoNotUse_default_instance_;
class HealthQuery;
struct HealthQueryDefaultTypeInternal;
extern HealthQueryDefaultTypeInternal _HealthQuery_default_instance_;
class HealthQueryResponse;
struct HealthQueryResponseDefaultTypeInternal;
extern HealthQueryResponseDefaultTypeInternal _HealthQueryResponse_default_instance_;
class HealthResponse;
struct HealthResponseDefaultTypeInternal;
extern HealthResponseDefaultTypeInternal _HealthResponse_default_instance_;
class HistogramData;
struct HistogramDataDefaultTypeInternal;
extern HistogramDataDefaultTypeInternal _HistogramData_default_instance_;
class HistogramDataPoint;
struct HistogramDataPointDefaultTypeInternal;
extern HistogramDataPointDefaultTypeInternal _HistogramDataPoint_default_instance_;
class HistogramDataPoint_AttributesEntry_DoNotUse;
struct HistogramDataPoint_AttributesEntry_DoNotUseDefaultTypeInternal;
extern HistogramDataPoint_AttributesEntry_DoNotUseDefaultTypeInternal _HistogramDataPoint_AttributesEntry_DoNotUse_default_instance_;
class IncidentData;
struct IncidentDataDefaultTypeInternal;
extern IncidentDataDefaultTypeInternal _IncidentData_default_instance_;
class IncidentEvent;
struct IncidentEventDefaultTypeInternal;
extern IncidentEventDefaultTypeInternal _IncidentEvent_default_instance_;
class IncidentImpact;
struct IncidentImpactDefaultTypeInternal;
extern IncidentImpactDefaultTypeInternal _IncidentImpact_default_instance_;
class IncidentQuery;
struct IncidentQueryDefaultTypeInternal;
extern IncidentQueryDefaultTypeInternal _IncidentQuery_default_instance_;
class IncidentQueryResponse;
struct IncidentQueryResponseDefaultTypeInternal;
extern IncidentQueryResponseDefaultTypeInternal _IncidentQueryResponse_default_instance_;
class IncidentResolution;
struct IncidentResolutionDefaultTypeInternal;
extern IncidentResolutionDefaultTypeInternal _IncidentResolution_default_instance_;
class IncidentResponse;
struct IncidentResponseDefaultTypeInternal;
extern IncidentResponseDefaultTypeInternal _IncidentResponse_default_instance_;
class IncidentUpdate;
struct IncidentUpdateDefaultTypeInternal;
extern IncidentUpdateDefaultTypeInternal _IncidentUpdate_default_instance_;
class IngestResponse;
struct IngestResponseDefaultTypeInternal;
extern IngestResponseDefaultTypeInternal _IngestResponse_default_instance_;
class InstrumentationLibrary;
struct InstrumentationLibraryDefaultTypeInternal;
extern InstrumentationLibraryDefaultTypeInternal _InstrumentationLibrary_default_instance_;
class LogEvent;
struct LogEventDefaultTypeInternal;
extern LogEventDefaultTypeInternal _LogEvent_default_instance_;
class MetricData;
struct MetricDataDefaultTypeInternal;
extern MetricDataDefaultTypeInternal _MetricData_default_instance_;
class MetricEvent;
struct MetricEventDefaultTypeInternal;
extern MetricEventDefaultTypeInternal _MetricEvent_default_instance_;
class MetricQuery;
struct MetricQueryDefaultTypeInternal;
extern MetricQueryDefaultTypeInternal _MetricQuery_default_instance_;
class MetricQueryResponse;
struct MetricQueryResponseDefaultTypeInternal;
extern MetricQueryResponseDefaultTypeInternal _MetricQueryResponse_default_instance_;
class MetricQuery_LabelsEntry_DoNotUse;
struct MetricQuery_LabelsEntry_DoNotUseDefaultTypeInternal;
extern MetricQuery_LabelsEntry_DoNotUseDefaultTypeInternal _MetricQuery_LabelsEntry_DoNotUse_default_instance_;
class NumberDataPoint;
struct NumberDataPointDefaultTypeInternal;
extern NumberDataPointDefaultTypeInternal _NumberDataPoint_default_instance_;
class NumberDataPoint_AttributesEntry_DoNotUse;
struct NumberDataPoint_AttributesEntry_DoNotUseDefaultTypeInternal;
extern NumberDataPoint_AttributesEntry_DoNotUseDefaultTypeInternal _NumberDataPoint_AttributesEntry_DoNotUse_default_instance_;
class PartitionInfo;
struct PartitionInfoDefaultTypeInternal;
extern PartitionInfoDefaultTypeInternal _PartitionInfo_default_instance_;
class PartitionInfo_CustomPartitionsEntry_DoNotUse;
struct PartitionInfo_CustomPartitionsEntry_DoNotUseDefaultTypeInternal;
extern PartitionInfo_CustomPartitionsEntry_DoNotUseDefaultTypeInternal _PartitionInfo_CustomPartitionsEntry_DoNotUse_default_instance_;
class QuantileValue;
struct QuantileValueDefaultTypeInternal;
extern QuantileValueDefaultTypeInternal _QuantileValue_default_instance_;
class Resource;
struct ResourceDefaultTypeInternal;
extern ResourceDefaultTypeInternal _Resource_default_instance_;
class Resource_AttributesEntry_DoNotUse;
struct Resource_AttributesEntry_DoNotUseDefaultTypeInternal;
extern Resource_AttributesEntry_DoNotUseDefaultTypeInternal _Resource_AttributesEntry_DoNotUse_default_instance_;
class ServiceHealth;
struct ServiceHealthDefaultTypeInternal;
extern ServiceHealthDefaultTypeInternal _ServiceHealth_default_instance_;
class ServiceHealthEvent;
struct ServiceHealthEventDefaultTypeInternal;
extern ServiceHealthEventDefaultTypeInternal _ServiceHealthEvent_default_instance_;
class ServiceLevelIndicators;
struct ServiceLevelIndicatorsDefaultTypeInternal;
extern ServiceLevelIndicatorsDefaultTypeInternal _ServiceLevelIndicators_default_instance_;
class SpanData;
struct SpanDataDefaultTypeInternal;
extern SpanDataDefaultTypeInternal _SpanData_default_instance_;
class SpanData_AttributesEntry_DoNotUse;
struct SpanData_AttributesEntry_DoNotUseDefaultTypeInternal;
extern SpanData_AttributesEntry_DoNotUseDefaultTypeInternal _SpanData_AttributesEntry_DoNotUse_default_instance_;
class SpanEvent;
struct SpanEventDefaultTypeInternal;
extern SpanEventDefaultTypeInternal _SpanEvent_default_instance_;
class SpanEvent_AttributesEntry_DoNotUse;
struct SpanEvent_AttributesEntry_DoNotUseDefaultTypeInternal;
extern SpanEvent_AttributesEntry_DoNotUseDefaultTypeInternal _SpanEvent_AttributesEntry_DoNotUse_default_instance_;
class SpanLink;
struct SpanLinkDefaultTypeInternal;
extern SpanLinkDefaultTypeInternal _SpanLink_default_instance_;
class SpanLink_AttributesEntry_DoNotUse;
struct SpanLink_AttributesEntry_DoNotUseDefaultTypeInternal;
extern SpanLink_AttributesEntry_DoNotUseDefaultTypeInternal _SpanLink_AttributesEntry_DoNotUse_default_instance_;
class SpanStatus;
struct SpanStatusDefaultTypeInternal;
extern SpanStatusDefaultTypeInternal _SpanStatus_default_instance_;
class SummaryData;
struct SummaryDataDefaultTypeInternal;
extern SummaryDataDefaultTypeInternal _SummaryData_default_instance_;
class SummaryDataPoint;
struct SummaryDataPointDefaultTypeInternal;
extern SummaryDataPointDefaultTypeInternal _SummaryDataPoint_default_instance_;
class SummaryDataPoint_AttributesEntry_DoNotUse;
struct SummaryDataPoint_AttributesEntry_DoNotUseDefaultTypeInternal;
extern SummaryDataPoint_AttributesEntry_DoNotUseDefaultTypeInternal _SummaryDataPoint_AttributesEntry_DoNotUse_default_instance_;
class SystemMetrics;
struct SystemMetricsDefaultTypeInternal;
extern SystemMetricsDefaultTypeInternal _SystemMetrics_default_instance_;
class TraceContext;
struct TraceContextDefaultTypeInternal;
extern TraceContextDefaultTypeInternal _TraceContext_default_instance_;
class TraceEvent;
struct TraceEventDefaultTypeInternal;
extern TraceEventDefaultTypeInternal _TraceEvent_default_instance_;
class TraceFlags;
struct TraceFlagsDefaultTypeInternal;
extern TraceFlagsDefaultTypeInternal _TraceFlags_default_instance_;
class TraceQuery;
struct TraceQueryDefaultTypeInternal;
extern TraceQueryDefaultTypeInternal _TraceQuery_default_instance_;
class TraceQueryResponse;
struct TraceQueryResponseDefaultTypeInternal;
extern TraceQueryResponseDefaultTypeInternal _TraceQueryResponse_default_instance_;
class UptimeInfo;
struct UptimeInfoDefaultTypeInternal;
extern UptimeInfoDefaultTypeInternal _UptimeInfo_default_instance_;
}  // namespace v1
}  // namespace observability
}  // namespace unhinged
PROTOBUF_NAMESPACE_OPEN
template<> ::unhinged::observability::v1::AttributeArray* Arena::CreateMaybeMessage<::unhinged::observability::v1::AttributeArray>(Arena*);
template<> ::unhinged::observability::v1::AttributeKeyValue* Arena::CreateMaybeMessage<::unhinged::observability::v1::AttributeKeyValue>(Arena*);
template<> ::unhinged::observability::v1::AttributeKeyValueList* Arena::CreateMaybeMessage<::unhinged::observability::v1::AttributeKeyValueList>(Arena*);
template<> ::unhinged::observability::v1::AttributeValue* Arena::CreateMaybeMessage<::unhinged::observability::v1::AttributeValue>(Arena*);
template<> ::unhinged::observability::v1::CounterData* Arena::CreateMaybeMessage<::unhinged::observability::v1::CounterData>(Arena*);
template<> ::unhinged::observability::v1::DataLakeOptions* Arena::CreateMaybeMessage<::unhinged::observability::v1::DataLakeOptions>(Arena*);
template<> ::unhinged::observability::v1::DependencyHealth* Arena::CreateMaybeMessage<::unhinged::observability::v1::DependencyHealth>(Arena*);
template<> ::unhinged::observability::v1::DestinationFlags* Arena::CreateMaybeMessage<::unhinged::observability::v1::DestinationFlags>(Arena*);
template<> ::unhinged::observability::v1::ErrorInfo* Arena::CreateMaybeMessage<::unhinged::observability::v1::ErrorInfo>(Arena*);
template<> ::unhinged::observability::v1::ErrorInfo_ErrorAttributesEntry_DoNotUse* Arena::CreateMaybeMessage<::unhinged::observability::v1::ErrorInfo_ErrorAttributesEntry_DoNotUse>(Arena*);
template<> ::unhinged::observability::v1::Exemplar* Arena::CreateMaybeMessage<::unhinged::observability::v1::Exemplar>(Arena*);
template<> ::unhinged::observability::v1::Exemplar_FilteredAttributesEntry_DoNotUse* Arena::CreateMaybeMessage<::unhinged::observability::v1::Exemplar_FilteredAttributesEntry_DoNotUse>(Arena*);
template<> ::unhinged::observability::v1::GaugeData* Arena::CreateMaybeMessage<::unhinged::observability::v1::GaugeData>(Arena*);
template<> ::unhinged::observability::v1::HealthCheck* Arena::CreateMaybeMessage<::unhinged::observability::v1::HealthCheck>(Arena*);
template<> ::unhinged::observability::v1::HealthCheck_MetadataEntry_DoNotUse* Arena::CreateMaybeMessage<::unhinged::observability::v1::HealthCheck_MetadataEntry_DoNotUse>(Arena*);
template<> ::unhinged::observability::v1::HealthQuery* Arena::CreateMaybeMessage<::unhinged::observability::v1::HealthQuery>(Arena*);
template<> ::unhinged::observability::v1::HealthQueryResponse* Arena::CreateMaybeMessage<::unhinged::observability::v1::HealthQueryResponse>(Arena*);
template<> ::unhinged::observability::v1::HealthResponse* Arena::CreateMaybeMessage<::unhinged::observability::v1::HealthResponse>(Arena*);
template<> ::unhinged::observability::v1::HistogramData* Arena::CreateMaybeMessage<::unhinged::observability::v1::HistogramData>(Arena*);
template<> ::unhinged::observability::v1::HistogramDataPoint* Arena::CreateMaybeMessage<::unhinged::observability::v1::HistogramDataPoint>(Arena*);
template<> ::unhinged::observability::v1::HistogramDataPoint_AttributesEntry_DoNotUse* Arena::CreateMaybeMessage<::unhinged::observability::v1::HistogramDataPoint_AttributesEntry_DoNotUse>(Arena*);
template<> ::unhinged::observability::v1::IncidentData* Arena::CreateMaybeMessage<::unhinged::observability::v1::IncidentData>(Arena*);
template<> ::unhinged::observability::v1::IncidentEvent* Arena::CreateMaybeMessage<::unhinged::observability::v1::IncidentEvent>(Arena*);
template<> ::unhinged::observability::v1::IncidentImpact* Arena::CreateMaybeMessage<::unhinged::observability::v1::IncidentImpact>(Arena*);
template<> ::unhinged::observability::v1::IncidentQuery* Arena::CreateMaybeMessage<::unhinged::observability::v1::IncidentQuery>(Arena*);
template<> ::unhinged::observability::v1::IncidentQueryResponse* Arena::CreateMaybeMessage<::unhinged::observability::v1::IncidentQueryResponse>(Arena*);
template<> ::unhinged::observability::v1::IncidentResolution* Arena::CreateMaybeMessage<::unhinged::observability::v1::IncidentResolution>(Arena*);
template<> ::unhinged::observability::v1::IncidentResponse* Arena::CreateMaybeMessage<::unhinged::observability::v1::IncidentResponse>(Arena*);
template<> ::unhinged::observability::v1::IncidentUpdate* Arena::CreateMaybeMessage<::unhinged::observability::v1::IncidentUpdate>(Arena*);
template<> ::unhinged::observability::v1::IngestResponse* Arena::CreateMaybeMessage<::unhinged::observability::v1::IngestResponse>(Arena*);
template<> ::unhinged::observability::v1::InstrumentationLibrary* Arena::CreateMaybeMessage<::unhinged::observability::v1::InstrumentationLibrary>(Arena*);
template<> ::unhinged::observability::v1::LogEvent* Arena::CreateMaybeMessage<::unhinged::observability::v1::LogEvent>(Arena*);
template<> ::unhinged::observability::v1::MetricData* Arena::CreateMaybeMessage<::unhinged::observability::v1::MetricData>(Arena*);
template<> ::unhinged::observability::v1::MetricEvent* Arena::CreateMaybeMessage<::unhinged::observability::v1::MetricEvent>(Arena*);
template<> ::unhinged::observability::v1::MetricQuery* Arena::CreateMaybeMessage<::unhinged::observability::v1::MetricQuery>(Arena*);
template<> ::unhinged::observability::v1::MetricQueryResponse* Arena::CreateMaybeMessage<::unhinged::observability::v1::MetricQueryResponse>(Arena*);
template<> ::unhinged::observability::v1::MetricQuery_LabelsEntry_DoNotUse* Arena::CreateMaybeMessage<::unhinged::observability::v1::MetricQuery_LabelsEntry_DoNotUse>(Arena*);
template<> ::unhinged::observability::v1::NumberDataPoint* Arena::CreateMaybeMessage<::unhinged::observability::v1::NumberDataPoint>(Arena*);
template<> ::unhinged::observability::v1::NumberDataPoint_AttributesEntry_DoNotUse* Arena::CreateMaybeMessage<::unhinged::observability::v1::NumberDataPoint_AttributesEntry_DoNotUse>(Arena*);
template<> ::unhinged::observability::v1::PartitionInfo* Arena::CreateMaybeMessage<::unhinged::observability::v1::PartitionInfo>(Arena*);
template<> ::unhinged::observability::v1::PartitionInfo_CustomPartitionsEntry_DoNotUse* Arena::CreateMaybeMessage<::unhinged::observability::v1::PartitionInfo_CustomPartitionsEntry_DoNotUse>(Arena*);
template<> ::unhinged::observability::v1::QuantileValue* Arena::CreateMaybeMessage<::unhinged::observability::v1::QuantileValue>(Arena*);
template<> ::unhinged::observability::v1::Resource* Arena::CreateMaybeMessage<::unhinged::observability::v1::Resource>(Arena*);
template<> ::unhinged::observability::v1::Resource_AttributesEntry_DoNotUse* Arena::CreateMaybeMessage<::unhinged::observability::v1::Resource_AttributesEntry_DoNotUse>(Arena*);
template<> ::unhinged::observability::v1::ServiceHealth* Arena::CreateMaybeMessage<::unhinged::observability::v1::ServiceHealth>(Arena*);
template<> ::unhinged::observability::v1::ServiceHealthEvent* Arena::CreateMaybeMessage<::unhinged::observability::v1::ServiceHealthEvent>(Arena*);
template<> ::unhinged::observability::v1::ServiceLevelIndicators* Arena::CreateMaybeMessage<::unhinged::observability::v1::ServiceLevelIndicators>(Arena*);
template<> ::unhinged::observability::v1::SpanData* Arena::CreateMaybeMessage<::unhinged::observability::v1::SpanData>(Arena*);
template<> ::unhinged::observability::v1::SpanData_AttributesEntry_DoNotUse* Arena::CreateMaybeMessage<::unhinged::observability::v1::SpanData_AttributesEntry_DoNotUse>(Arena*);
template<> ::unhinged::observability::v1::SpanEvent* Arena::CreateMaybeMessage<::unhinged::observability::v1::SpanEvent>(Arena*);
template<> ::unhinged::observability::v1::SpanEvent_AttributesEntry_DoNotUse* Arena::CreateMaybeMessage<::unhinged::observability::v1::SpanEvent_AttributesEntry_DoNotUse>(Arena*);
template<> ::unhinged::observability::v1::SpanLink* Arena::CreateMaybeMessage<::unhinged::observability::v1::SpanLink>(Arena*);
template<> ::unhinged::observability::v1::SpanLink_AttributesEntry_DoNotUse* Arena::CreateMaybeMessage<::unhinged::observability::v1::SpanLink_AttributesEntry_DoNotUse>(Arena*);
template<> ::unhinged::observability::v1::SpanStatus* Arena::CreateMaybeMessage<::unhinged::observability::v1::SpanStatus>(Arena*);
template<> ::unhinged::observability::v1::SummaryData* Arena::CreateMaybeMessage<::unhinged::observability::v1::SummaryData>(Arena*);
template<> ::unhinged::observability::v1::SummaryDataPoint* Arena::CreateMaybeMessage<::unhinged::observability::v1::SummaryDataPoint>(Arena*);
template<> ::unhinged::observability::v1::SummaryDataPoint_AttributesEntry_DoNotUse* Arena::CreateMaybeMessage<::unhinged::observability::v1::SummaryDataPoint_AttributesEntry_DoNotUse>(Arena*);
template<> ::unhinged::observability::v1::SystemMetrics* Arena::CreateMaybeMessage<::unhinged::observability::v1::SystemMetrics>(Arena*);
template<> ::unhinged::observability::v1::TraceContext* Arena::CreateMaybeMessage<::unhinged::observability::v1::TraceContext>(Arena*);
template<> ::unhinged::observability::v1::TraceEvent* Arena::CreateMaybeMessage<::unhinged::observability::v1::TraceEvent>(Arena*);
template<> ::unhinged::observability::v1::TraceFlags* Arena::CreateMaybeMessage<::unhinged::observability::v1::TraceFlags>(Arena*);
template<> ::unhinged::observability::v1::TraceQuery* Arena::CreateMaybeMessage<::unhinged::observability::v1::TraceQuery>(Arena*);
template<> ::unhinged::observability::v1::TraceQueryResponse* Arena::CreateMaybeMessage<::unhinged::observability::v1::TraceQueryResponse>(Arena*);
template<> ::unhinged::observability::v1::UptimeInfo* Arena::CreateMaybeMessage<::unhinged::observability::v1::UptimeInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace unhinged {
namespace observability {
namespace v1 {

enum LogLevel : int {
  LOG_LEVEL_UNSPECIFIED = 0,
  LOG_LEVEL_TRACE = 1,
  LOG_LEVEL_DEBUG = 2,
  LOG_LEVEL_INFO = 3,
  LOG_LEVEL_WARN = 4,
  LOG_LEVEL_ERROR = 5,
  LOG_LEVEL_FATAL = 6,
  LogLevel_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  LogLevel_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool LogLevel_IsValid(int value);
constexpr LogLevel LogLevel_MIN = LOG_LEVEL_UNSPECIFIED;
constexpr LogLevel LogLevel_MAX = LOG_LEVEL_FATAL;
constexpr int LogLevel_ARRAYSIZE = LogLevel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LogLevel_descriptor();
template<typename T>
inline const std::string& LogLevel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LogLevel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LogLevel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LogLevel_descriptor(), enum_t_value);
}
inline bool LogLevel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LogLevel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LogLevel>(
    LogLevel_descriptor(), name, value);
}
enum CompressionType : int {
  COMPRESSION_UNSPECIFIED = 0,
  COMPRESSION_NONE = 1,
  COMPRESSION_GZIP = 2,
  COMPRESSION_SNAPPY = 3,
  COMPRESSION_LZ4 = 4,
  COMPRESSION_ZSTD = 5,
  CompressionType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CompressionType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CompressionType_IsValid(int value);
constexpr CompressionType CompressionType_MIN = COMPRESSION_UNSPECIFIED;
constexpr CompressionType CompressionType_MAX = COMPRESSION_ZSTD;
constexpr int CompressionType_ARRAYSIZE = CompressionType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CompressionType_descriptor();
template<typename T>
inline const std::string& CompressionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CompressionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CompressionType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CompressionType_descriptor(), enum_t_value);
}
inline bool CompressionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CompressionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CompressionType>(
    CompressionType_descriptor(), name, value);
}
enum SpanKind : int {
  SPAN_KIND_UNSPECIFIED = 0,
  SPAN_KIND_INTERNAL = 1,
  SPAN_KIND_SERVER = 2,
  SPAN_KIND_CLIENT = 3,
  SPAN_KIND_PRODUCER = 4,
  SPAN_KIND_CONSUMER = 5,
  SpanKind_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SpanKind_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SpanKind_IsValid(int value);
constexpr SpanKind SpanKind_MIN = SPAN_KIND_UNSPECIFIED;
constexpr SpanKind SpanKind_MAX = SPAN_KIND_CONSUMER;
constexpr int SpanKind_ARRAYSIZE = SpanKind_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SpanKind_descriptor();
template<typename T>
inline const std::string& SpanKind_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SpanKind>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SpanKind_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SpanKind_descriptor(), enum_t_value);
}
inline bool SpanKind_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SpanKind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SpanKind>(
    SpanKind_descriptor(), name, value);
}
enum StatusCode : int {
  STATUS_CODE_UNSET = 0,
  STATUS_CODE_OK = 1,
  STATUS_CODE_ERROR = 2,
  StatusCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  StatusCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool StatusCode_IsValid(int value);
constexpr StatusCode StatusCode_MIN = STATUS_CODE_UNSET;
constexpr StatusCode StatusCode_MAX = STATUS_CODE_ERROR;
constexpr int StatusCode_ARRAYSIZE = StatusCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StatusCode_descriptor();
template<typename T>
inline const std::string& StatusCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StatusCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StatusCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StatusCode_descriptor(), enum_t_value);
}
inline bool StatusCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StatusCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StatusCode>(
    StatusCode_descriptor(), name, value);
}
enum AggregationTemporality : int {
  AGGREGATION_TEMPORALITY_UNSPECIFIED = 0,
  AGGREGATION_TEMPORALITY_DELTA = 1,
  AGGREGATION_TEMPORALITY_CUMULATIVE = 2,
  AggregationTemporality_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AggregationTemporality_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AggregationTemporality_IsValid(int value);
constexpr AggregationTemporality AggregationTemporality_MIN = AGGREGATION_TEMPORALITY_UNSPECIFIED;
constexpr AggregationTemporality AggregationTemporality_MAX = AGGREGATION_TEMPORALITY_CUMULATIVE;
constexpr int AggregationTemporality_ARRAYSIZE = AggregationTemporality_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AggregationTemporality_descriptor();
template<typename T>
inline const std::string& AggregationTemporality_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AggregationTemporality>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AggregationTemporality_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AggregationTemporality_descriptor(), enum_t_value);
}
inline bool AggregationTemporality_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AggregationTemporality* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AggregationTemporality>(
    AggregationTemporality_descriptor(), name, value);
}
enum HealthStatus : int {
  HEALTH_STATUS_UNKNOWN = 0,
  HEALTH_STATUS_HEALTHY = 1,
  HEALTH_STATUS_DEGRADED = 2,
  HEALTH_STATUS_UNHEALTHY = 3,
  HEALTH_STATUS_MAINTENANCE = 4,
  HealthStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  HealthStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool HealthStatus_IsValid(int value);
constexpr HealthStatus HealthStatus_MIN = HEALTH_STATUS_UNKNOWN;
constexpr HealthStatus HealthStatus_MAX = HEALTH_STATUS_MAINTENANCE;
constexpr int HealthStatus_ARRAYSIZE = HealthStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HealthStatus_descriptor();
template<typename T>
inline const std::string& HealthStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HealthStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HealthStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    HealthStatus_descriptor(), enum_t_value);
}
inline bool HealthStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HealthStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<HealthStatus>(
    HealthStatus_descriptor(), name, value);
}
enum IncidentSeverity : int {
  INCIDENT_SEVERITY_UNKNOWN = 0,
  INCIDENT_SEVERITY_LOW = 1,
  INCIDENT_SEVERITY_MEDIUM = 2,
  INCIDENT_SEVERITY_HIGH = 3,
  INCIDENT_SEVERITY_CRITICAL = 4,
  IncidentSeverity_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  IncidentSeverity_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool IncidentSeverity_IsValid(int value);
constexpr IncidentSeverity IncidentSeverity_MIN = INCIDENT_SEVERITY_UNKNOWN;
constexpr IncidentSeverity IncidentSeverity_MAX = INCIDENT_SEVERITY_CRITICAL;
constexpr int IncidentSeverity_ARRAYSIZE = IncidentSeverity_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* IncidentSeverity_descriptor();
template<typename T>
inline const std::string& IncidentSeverity_Name(T enum_t_value) {
  static_assert(::std::is_same<T, IncidentSeverity>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function IncidentSeverity_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    IncidentSeverity_descriptor(), enum_t_value);
}
inline bool IncidentSeverity_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, IncidentSeverity* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<IncidentSeverity>(
    IncidentSeverity_descriptor(), name, value);
}
enum IncidentStatus : int {
  INCIDENT_STATUS_UNKNOWN = 0,
  INCIDENT_STATUS_INVESTIGATING = 1,
  INCIDENT_STATUS_IDENTIFIED = 2,
  INCIDENT_STATUS_MONITORING = 3,
  INCIDENT_STATUS_RESOLVED = 4,
  INCIDENT_STATUS_POSTMORTEM = 5,
  IncidentStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  IncidentStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool IncidentStatus_IsValid(int value);
constexpr IncidentStatus IncidentStatus_MIN = INCIDENT_STATUS_UNKNOWN;
constexpr IncidentStatus IncidentStatus_MAX = INCIDENT_STATUS_POSTMORTEM;
constexpr int IncidentStatus_ARRAYSIZE = IncidentStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* IncidentStatus_descriptor();
template<typename T>
inline const std::string& IncidentStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, IncidentStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function IncidentStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    IncidentStatus_descriptor(), enum_t_value);
}
inline bool IncidentStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, IncidentStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<IncidentStatus>(
    IncidentStatus_descriptor(), name, value);
}
enum UpdateType : int {
  UPDATE_TYPE_UNKNOWN = 0,
  UPDATE_TYPE_INVESTIGATING = 1,
  UPDATE_TYPE_UPDATE = 2,
  UPDATE_TYPE_RESOLVED = 3,
  UPDATE_TYPE_POSTMORTEM = 4,
  UpdateType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  UpdateType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool UpdateType_IsValid(int value);
constexpr UpdateType UpdateType_MIN = UPDATE_TYPE_UNKNOWN;
constexpr UpdateType UpdateType_MAX = UPDATE_TYPE_POSTMORTEM;
constexpr int UpdateType_ARRAYSIZE = UpdateType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UpdateType_descriptor();
template<typename T>
inline const std::string& UpdateType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UpdateType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UpdateType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UpdateType_descriptor(), enum_t_value);
}
inline bool UpdateType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UpdateType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UpdateType>(
    UpdateType_descriptor(), name, value);
}
// ===================================================================

class TraceContext final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.observability.v1.TraceContext) */ {
 public:
  inline TraceContext() : TraceContext(nullptr) {}
  ~TraceContext() override;
  explicit PROTOBUF_CONSTEXPR TraceContext(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TraceContext(const TraceContext& from);
  TraceContext(TraceContext&& from) noexcept
    : TraceContext() {
    *this = ::std::move(from);
  }

  inline TraceContext& operator=(const TraceContext& from) {
    CopyFrom(from);
    return *this;
  }
  inline TraceContext& operator=(TraceContext&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TraceContext& default_instance() {
    return *internal_default_instance();
  }
  static inline const TraceContext* internal_default_instance() {
    return reinterpret_cast<const TraceContext*>(
               &_TraceContext_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(TraceContext& a, TraceContext& b) {
    a.Swap(&b);
  }
  inline void Swap(TraceContext* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TraceContext* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TraceContext* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TraceContext>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TraceContext& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TraceContext& from) {
    TraceContext::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TraceContext* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.observability.v1.TraceContext";
  }
  protected:
  explicit TraceContext(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTraceIdFieldNumber = 1,
    kSpanIdFieldNumber = 2,
    kParentSpanIdFieldNumber = 3,
    kTraceStateFieldNumber = 5,
    kCorrelationIdFieldNumber = 10,
    kRequestIdFieldNumber = 11,
    kSessionIdFieldNumber = 12,
    kUserIdFieldNumber = 13,
    kTraceFlagsFieldNumber = 4,
  };
  // string trace_id = 1;
  void clear_trace_id();
  const std::string& trace_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_trace_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_trace_id();
  PROTOBUF_NODISCARD std::string* release_trace_id();
  void set_allocated_trace_id(std::string* trace_id);
  private:
  const std::string& _internal_trace_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trace_id(const std::string& value);
  std::string* _internal_mutable_trace_id();
  public:

  // string span_id = 2;
  void clear_span_id();
  const std::string& span_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_span_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_span_id();
  PROTOBUF_NODISCARD std::string* release_span_id();
  void set_allocated_span_id(std::string* span_id);
  private:
  const std::string& _internal_span_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_span_id(const std::string& value);
  std::string* _internal_mutable_span_id();
  public:

  // string parent_span_id = 3;
  void clear_parent_span_id();
  const std::string& parent_span_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent_span_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent_span_id();
  PROTOBUF_NODISCARD std::string* release_parent_span_id();
  void set_allocated_parent_span_id(std::string* parent_span_id);
  private:
  const std::string& _internal_parent_span_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent_span_id(const std::string& value);
  std::string* _internal_mutable_parent_span_id();
  public:

  // string trace_state = 5;
  void clear_trace_state();
  const std::string& trace_state() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_trace_state(ArgT0&& arg0, ArgT... args);
  std::string* mutable_trace_state();
  PROTOBUF_NODISCARD std::string* release_trace_state();
  void set_allocated_trace_state(std::string* trace_state);
  private:
  const std::string& _internal_trace_state() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trace_state(const std::string& value);
  std::string* _internal_mutable_trace_state();
  public:

  // string correlation_id = 10;
  void clear_correlation_id();
  const std::string& correlation_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_correlation_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_correlation_id();
  PROTOBUF_NODISCARD std::string* release_correlation_id();
  void set_allocated_correlation_id(std::string* correlation_id);
  private:
  const std::string& _internal_correlation_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_correlation_id(const std::string& value);
  std::string* _internal_mutable_correlation_id();
  public:

  // string request_id = 11;
  void clear_request_id();
  const std::string& request_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_request_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_request_id();
  PROTOBUF_NODISCARD std::string* release_request_id();
  void set_allocated_request_id(std::string* request_id);
  private:
  const std::string& _internal_request_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_id(const std::string& value);
  std::string* _internal_mutable_request_id();
  public:

  // string session_id = 12;
  void clear_session_id();
  const std::string& session_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // string user_id = 13;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // .unhinged.observability.v1.TraceFlags trace_flags = 4;
  bool has_trace_flags() const;
  private:
  bool _internal_has_trace_flags() const;
  public:
  void clear_trace_flags();
  const ::unhinged::observability::v1::TraceFlags& trace_flags() const;
  PROTOBUF_NODISCARD ::unhinged::observability::v1::TraceFlags* release_trace_flags();
  ::unhinged::observability::v1::TraceFlags* mutable_trace_flags();
  void set_allocated_trace_flags(::unhinged::observability::v1::TraceFlags* trace_flags);
  private:
  const ::unhinged::observability::v1::TraceFlags& _internal_trace_flags() const;
  ::unhinged::observability::v1::TraceFlags* _internal_mutable_trace_flags();
  public:
  void unsafe_arena_set_allocated_trace_flags(
      ::unhinged::observability::v1::TraceFlags* trace_flags);
  ::unhinged::observability::v1::TraceFlags* unsafe_arena_release_trace_flags();

  // @@protoc_insertion_point(class_scope:unhinged.observability.v1.TraceContext)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trace_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr span_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_span_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trace_state_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr correlation_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::unhinged::observability::v1::TraceFlags* trace_flags_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_observability_2eproto;
};
// -------------------------------------------------------------------

class TraceFlags final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.observability.v1.TraceFlags) */ {
 public:
  inline TraceFlags() : TraceFlags(nullptr) {}
  ~TraceFlags() override;
  explicit PROTOBUF_CONSTEXPR TraceFlags(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TraceFlags(const TraceFlags& from);
  TraceFlags(TraceFlags&& from) noexcept
    : TraceFlags() {
    *this = ::std::move(from);
  }

  inline TraceFlags& operator=(const TraceFlags& from) {
    CopyFrom(from);
    return *this;
  }
  inline TraceFlags& operator=(TraceFlags&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TraceFlags& default_instance() {
    return *internal_default_instance();
  }
  static inline const TraceFlags* internal_default_instance() {
    return reinterpret_cast<const TraceFlags*>(
               &_TraceFlags_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(TraceFlags& a, TraceFlags& b) {
    a.Swap(&b);
  }
  inline void Swap(TraceFlags* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TraceFlags* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TraceFlags* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TraceFlags>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TraceFlags& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TraceFlags& from) {
    TraceFlags::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TraceFlags* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.observability.v1.TraceFlags";
  }
  protected:
  explicit TraceFlags(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSampledFieldNumber = 1,
    kRandomTraceIdFieldNumber = 2,
  };
  // bool sampled = 1;
  void clear_sampled();
  bool sampled() const;
  void set_sampled(bool value);
  private:
  bool _internal_sampled() const;
  void _internal_set_sampled(bool value);
  public:

  // bool random_trace_id = 2;
  void clear_random_trace_id();
  bool random_trace_id() const;
  void set_random_trace_id(bool value);
  private:
  bool _internal_random_trace_id() const;
  void _internal_set_random_trace_id(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.observability.v1.TraceFlags)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool sampled_;
    bool random_trace_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_observability_2eproto;
};
// -------------------------------------------------------------------

class Resource_AttributesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Resource_AttributesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Resource_AttributesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  Resource_AttributesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Resource_AttributesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Resource_AttributesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Resource_AttributesEntry_DoNotUse& other);
  static const Resource_AttributesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Resource_AttributesEntry_DoNotUse*>(&_Resource_AttributesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "unhinged.observability.v1.Resource.AttributesEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "unhinged.observability.v1.Resource.AttributesEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_observability_2eproto;
};

// -------------------------------------------------------------------

class Resource final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.observability.v1.Resource) */ {
 public:
  inline Resource() : Resource(nullptr) {}
  ~Resource() override;
  explicit PROTOBUF_CONSTEXPR Resource(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Resource(const Resource& from);
  Resource(Resource&& from) noexcept
    : Resource() {
    *this = ::std::move(from);
  }

  inline Resource& operator=(const Resource& from) {
    CopyFrom(from);
    return *this;
  }
  inline Resource& operator=(Resource&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Resource& default_instance() {
    return *internal_default_instance();
  }
  static inline const Resource* internal_default_instance() {
    return reinterpret_cast<const Resource*>(
               &_Resource_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Resource& a, Resource& b) {
    a.Swap(&b);
  }
  inline void Swap(Resource* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Resource* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Resource* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Resource>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Resource& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Resource& from) {
    Resource::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Resource* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.observability.v1.Resource";
  }
  protected:
  explicit Resource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kAttributesFieldNumber = 20,
    kServiceNameFieldNumber = 1,
    kServiceVersionFieldNumber = 2,
    kServiceInstanceIdFieldNumber = 3,
    kDeploymentEnvironmentFieldNumber = 4,
    kK8SClusterNameFieldNumber = 5,
    kK8SNamespaceFieldNumber = 6,
    kK8SPodNameFieldNumber = 7,
    kHostNameFieldNumber = 8,
    kHostArchFieldNumber = 9,
  };
  // map<string, string> attributes = 20;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;
  public:
  void clear_attributes();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_attributes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_attributes();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      attributes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_attributes();

  // string service_name = 1;
  void clear_service_name();
  const std::string& service_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // string service_version = 2;
  void clear_service_version();
  const std::string& service_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_version();
  PROTOBUF_NODISCARD std::string* release_service_version();
  void set_allocated_service_version(std::string* service_version);
  private:
  const std::string& _internal_service_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_version(const std::string& value);
  std::string* _internal_mutable_service_version();
  public:

  // string service_instance_id = 3;
  void clear_service_instance_id();
  const std::string& service_instance_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_instance_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_instance_id();
  PROTOBUF_NODISCARD std::string* release_service_instance_id();
  void set_allocated_service_instance_id(std::string* service_instance_id);
  private:
  const std::string& _internal_service_instance_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_instance_id(const std::string& value);
  std::string* _internal_mutable_service_instance_id();
  public:

  // string deployment_environment = 4;
  void clear_deployment_environment();
  const std::string& deployment_environment() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_deployment_environment(ArgT0&& arg0, ArgT... args);
  std::string* mutable_deployment_environment();
  PROTOBUF_NODISCARD std::string* release_deployment_environment();
  void set_allocated_deployment_environment(std::string* deployment_environment);
  private:
  const std::string& _internal_deployment_environment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_deployment_environment(const std::string& value);
  std::string* _internal_mutable_deployment_environment();
  public:

  // string k8s_cluster_name = 5;
  void clear_k8s_cluster_name();
  const std::string& k8s_cluster_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_k8s_cluster_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_k8s_cluster_name();
  PROTOBUF_NODISCARD std::string* release_k8s_cluster_name();
  void set_allocated_k8s_cluster_name(std::string* k8s_cluster_name);
  private:
  const std::string& _internal_k8s_cluster_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_k8s_cluster_name(const std::string& value);
  std::string* _internal_mutable_k8s_cluster_name();
  public:

  // string k8s_namespace = 6;
  void clear_k8s_namespace();
  const std::string& k8s_namespace() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_k8s_namespace(ArgT0&& arg0, ArgT... args);
  std::string* mutable_k8s_namespace();
  PROTOBUF_NODISCARD std::string* release_k8s_namespace();
  void set_allocated_k8s_namespace(std::string* k8s_namespace);
  private:
  const std::string& _internal_k8s_namespace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_k8s_namespace(const std::string& value);
  std::string* _internal_mutable_k8s_namespace();
  public:

  // string k8s_pod_name = 7;
  void clear_k8s_pod_name();
  const std::string& k8s_pod_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_k8s_pod_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_k8s_pod_name();
  PROTOBUF_NODISCARD std::string* release_k8s_pod_name();
  void set_allocated_k8s_pod_name(std::string* k8s_pod_name);
  private:
  const std::string& _internal_k8s_pod_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_k8s_pod_name(const std::string& value);
  std::string* _internal_mutable_k8s_pod_name();
  public:

  // string host_name = 8;
  void clear_host_name();
  const std::string& host_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_host_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_host_name();
  PROTOBUF_NODISCARD std::string* release_host_name();
  void set_allocated_host_name(std::string* host_name);
  private:
  const std::string& _internal_host_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host_name(const std::string& value);
  std::string* _internal_mutable_host_name();
  public:

  // string host_arch = 9;
  void clear_host_arch();
  const std::string& host_arch() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_host_arch(ArgT0&& arg0, ArgT... args);
  std::string* mutable_host_arch();
  PROTOBUF_NODISCARD std::string* release_host_arch();
  void set_allocated_host_arch(std::string* host_arch);
  private:
  const std::string& _internal_host_arch() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host_arch(const std::string& value);
  std::string* _internal_mutable_host_arch();
  public:

  // @@protoc_insertion_point(class_scope:unhinged.observability.v1.Resource)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Resource_AttributesEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> attributes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_instance_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deployment_environment_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr k8s_cluster_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr k8s_namespace_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr k8s_pod_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_arch_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_observability_2eproto;
};
// -------------------------------------------------------------------

class LogEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.observability.v1.LogEvent) */ {
 public:
  inline LogEvent() : LogEvent(nullptr) {}
  ~LogEvent() override;
  explicit PROTOBUF_CONSTEXPR LogEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogEvent(const LogEvent& from);
  LogEvent(LogEvent&& from) noexcept
    : LogEvent() {
    *this = ::std::move(from);
  }

  inline LogEvent& operator=(const LogEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogEvent& operator=(LogEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogEvent* internal_default_instance() {
    return reinterpret_cast<const LogEvent*>(
               &_LogEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(LogEvent& a, LogEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(LogEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LogEvent& from) {
    LogEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.observability.v1.LogEvent";
  }
  protected:
  explicit LogEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventIdFieldNumber = 1,
    kEventTypeFieldNumber = 3,
    kMessageFieldNumber = 11,
    kTimestampFieldNumber = 2,
    kTraceContextFieldNumber = 5,
    kResourceFieldNumber = 6,
    kMetadataFieldNumber = 12,
    kErrorFieldNumber = 15,
    kDestinationsFieldNumber = 20,
    kPartitionInfoFieldNumber = 25,
    kSequenceNumberFieldNumber = 4,
    kLevelFieldNumber = 10,
  };
  // string event_id = 1;
  void clear_event_id();
  const std::string& event_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_event_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_event_id();
  PROTOBUF_NODISCARD std::string* release_event_id();
  void set_allocated_event_id(std::string* event_id);
  private:
  const std::string& _internal_event_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_event_id(const std::string& value);
  std::string* _internal_mutable_event_id();
  public:

  // string event_type = 3;
  void clear_event_type();
  const std::string& event_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_event_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_event_type();
  PROTOBUF_NODISCARD std::string* release_event_type();
  void set_allocated_event_type(std::string* event_type);
  private:
  const std::string& _internal_event_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_event_type(const std::string& value);
  std::string* _internal_mutable_event_type();
  public:

  // string message = 11;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .google.protobuf.Timestamp timestamp = 2;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // .unhinged.observability.v1.TraceContext trace_context = 5;
  bool has_trace_context() const;
  private:
  bool _internal_has_trace_context() const;
  public:
  void clear_trace_context();
  const ::unhinged::observability::v1::TraceContext& trace_context() const;
  PROTOBUF_NODISCARD ::unhinged::observability::v1::TraceContext* release_trace_context();
  ::unhinged::observability::v1::TraceContext* mutable_trace_context();
  void set_allocated_trace_context(::unhinged::observability::v1::TraceContext* trace_context);
  private:
  const ::unhinged::observability::v1::TraceContext& _internal_trace_context() const;
  ::unhinged::observability::v1::TraceContext* _internal_mutable_trace_context();
  public:
  void unsafe_arena_set_allocated_trace_context(
      ::unhinged::observability::v1::TraceContext* trace_context);
  ::unhinged::observability::v1::TraceContext* unsafe_arena_release_trace_context();

  // .unhinged.observability.v1.Resource resource = 6;
  bool has_resource() const;
  private:
  bool _internal_has_resource() const;
  public:
  void clear_resource();
  const ::unhinged::observability::v1::Resource& resource() const;
  PROTOBUF_NODISCARD ::unhinged::observability::v1::Resource* release_resource();
  ::unhinged::observability::v1::Resource* mutable_resource();
  void set_allocated_resource(::unhinged::observability::v1::Resource* resource);
  private:
  const ::unhinged::observability::v1::Resource& _internal_resource() const;
  ::unhinged::observability::v1::Resource* _internal_mutable_resource();
  public:
  void unsafe_arena_set_allocated_resource(
      ::unhinged::observability::v1::Resource* resource);
  ::unhinged::observability::v1::Resource* unsafe_arena_release_resource();

  // .google.protobuf.Struct metadata = 12;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::PROTOBUF_NAMESPACE_ID::Struct& metadata() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_metadata();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_metadata();
  void set_allocated_metadata(::PROTOBUF_NAMESPACE_ID::Struct* metadata);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::PROTOBUF_NAMESPACE_ID::Struct* metadata);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_metadata();

  // .unhinged.observability.v1.ErrorInfo error = 15;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::unhinged::observability::v1::ErrorInfo& error() const;
  PROTOBUF_NODISCARD ::unhinged::observability::v1::ErrorInfo* release_error();
  ::unhinged::observability::v1::ErrorInfo* mutable_error();
  void set_allocated_error(::unhinged::observability::v1::ErrorInfo* error);
  private:
  const ::unhinged::observability::v1::ErrorInfo& _internal_error() const;
  ::unhinged::observability::v1::ErrorInfo* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::unhinged::observability::v1::ErrorInfo* error);
  ::unhinged::observability::v1::ErrorInfo* unsafe_arena_release_error();

  // .unhinged.observability.v1.DestinationFlags destinations = 20;
  bool has_destinations() const;
  private:
  bool _internal_has_destinations() const;
  public:
  void clear_destinations();
  const ::unhinged::observability::v1::DestinationFlags& destinations() const;
  PROTOBUF_NODISCARD ::unhinged::observability::v1::DestinationFlags* release_destinations();
  ::unhinged::observability::v1::DestinationFlags* mutable_destinations();
  void set_allocated_destinations(::unhinged::observability::v1::DestinationFlags* destinations);
  private:
  const ::unhinged::observability::v1::DestinationFlags& _internal_destinations() const;
  ::unhinged::observability::v1::DestinationFlags* _internal_mutable_destinations();
  public:
  void unsafe_arena_set_allocated_destinations(
      ::unhinged::observability::v1::DestinationFlags* destinations);
  ::unhinged::observability::v1::DestinationFlags* unsafe_arena_release_destinations();

  // .unhinged.observability.v1.PartitionInfo partition_info = 25;
  bool has_partition_info() const;
  private:
  bool _internal_has_partition_info() const;
  public:
  void clear_partition_info();
  const ::unhinged::observability::v1::PartitionInfo& partition_info() const;
  PROTOBUF_NODISCARD ::unhinged::observability::v1::PartitionInfo* release_partition_info();
  ::unhinged::observability::v1::PartitionInfo* mutable_partition_info();
  void set_allocated_partition_info(::unhinged::observability::v1::PartitionInfo* partition_info);
  private:
  const ::unhinged::observability::v1::PartitionInfo& _internal_partition_info() const;
  ::unhinged::observability::v1::PartitionInfo* _internal_mutable_partition_info();
  public:
  void unsafe_arena_set_allocated_partition_info(
      ::unhinged::observability::v1::PartitionInfo* partition_info);
  ::unhinged::observability::v1::PartitionInfo* unsafe_arena_release_partition_info();

  // int64 sequence_number = 4;
  void clear_sequence_number();
  int64_t sequence_number() const;
  void set_sequence_number(int64_t value);
  private:
  int64_t _internal_sequence_number() const;
  void _internal_set_sequence_number(int64_t value);
  public:

  // .unhinged.observability.v1.LogLevel level = 10;
  void clear_level();
  ::unhinged::observability::v1::LogLevel level() const;
  void set_level(::unhinged::observability::v1::LogLevel value);
  private:
  ::unhinged::observability::v1::LogLevel _internal_level() const;
  void _internal_set_level(::unhinged::observability::v1::LogLevel value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.observability.v1.LogEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr event_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr event_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
    ::unhinged::observability::v1::TraceContext* trace_context_;
    ::unhinged::observability::v1::Resource* resource_;
    ::PROTOBUF_NAMESPACE_ID::Struct* metadata_;
    ::unhinged::observability::v1::ErrorInfo* error_;
    ::unhinged::observability::v1::DestinationFlags* destinations_;
    ::unhinged::observability::v1::PartitionInfo* partition_info_;
    int64_t sequence_number_;
    int level_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_observability_2eproto;
};
// -------------------------------------------------------------------

class ErrorInfo_ErrorAttributesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ErrorInfo_ErrorAttributesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ErrorInfo_ErrorAttributesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  ErrorInfo_ErrorAttributesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ErrorInfo_ErrorAttributesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ErrorInfo_ErrorAttributesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ErrorInfo_ErrorAttributesEntry_DoNotUse& other);
  static const ErrorInfo_ErrorAttributesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ErrorInfo_ErrorAttributesEntry_DoNotUse*>(&_ErrorInfo_ErrorAttributesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "unhinged.observability.v1.ErrorInfo.ErrorAttributesEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "unhinged.observability.v1.ErrorInfo.ErrorAttributesEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_observability_2eproto;
};

// -------------------------------------------------------------------

class ErrorInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.observability.v1.ErrorInfo) */ {
 public:
  inline ErrorInfo() : ErrorInfo(nullptr) {}
  ~ErrorInfo() override;
  explicit PROTOBUF_CONSTEXPR ErrorInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ErrorInfo(const ErrorInfo& from);
  ErrorInfo(ErrorInfo&& from) noexcept
    : ErrorInfo() {
    *this = ::std::move(from);
  }

  inline ErrorInfo& operator=(const ErrorInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ErrorInfo& operator=(ErrorInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ErrorInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ErrorInfo* internal_default_instance() {
    return reinterpret_cast<const ErrorInfo*>(
               &_ErrorInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ErrorInfo& a, ErrorInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ErrorInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ErrorInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ErrorInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ErrorInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ErrorInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ErrorInfo& from) {
    ErrorInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ErrorInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.observability.v1.ErrorInfo";
  }
  protected:
  explicit ErrorInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kErrorAttributesFieldNumber = 5,
    kErrorTypeFieldNumber = 1,
    kErrorMessageFieldNumber = 2,
    kStackTraceFieldNumber = 3,
    kErrorCodeFieldNumber = 4,
  };
  // map<string, string> error_attributes = 5;
  int error_attributes_size() const;
  private:
  int _internal_error_attributes_size() const;
  public:
  void clear_error_attributes();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_error_attributes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_error_attributes();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      error_attributes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_error_attributes();

  // string error_type = 1;
  void clear_error_type();
  const std::string& error_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_type();
  PROTOBUF_NODISCARD std::string* release_error_type();
  void set_allocated_error_type(std::string* error_type);
  private:
  const std::string& _internal_error_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_type(const std::string& value);
  std::string* _internal_mutable_error_type();
  public:

  // string error_message = 2;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // string stack_trace = 3;
  void clear_stack_trace();
  const std::string& stack_trace() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stack_trace(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stack_trace();
  PROTOBUF_NODISCARD std::string* release_stack_trace();
  void set_allocated_stack_trace(std::string* stack_trace);
  private:
  const std::string& _internal_stack_trace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stack_trace(const std::string& value);
  std::string* _internal_mutable_stack_trace();
  public:

  // string error_code = 4;
  void clear_error_code();
  const std::string& error_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_code();
  PROTOBUF_NODISCARD std::string* release_error_code();
  void set_allocated_error_code(std::string* error_code);
  private:
  const std::string& _internal_error_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_code(const std::string& value);
  std::string* _internal_mutable_error_code();
  public:

  // @@protoc_insertion_point(class_scope:unhinged.observability.v1.ErrorInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ErrorInfo_ErrorAttributesEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> error_attributes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stack_trace_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_observability_2eproto;
};
// -------------------------------------------------------------------

class DestinationFlags final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.observability.v1.DestinationFlags) */ {
 public:
  inline DestinationFlags() : DestinationFlags(nullptr) {}
  ~DestinationFlags() override;
  explicit PROTOBUF_CONSTEXPR DestinationFlags(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DestinationFlags(const DestinationFlags& from);
  DestinationFlags(DestinationFlags&& from) noexcept
    : DestinationFlags() {
    *this = ::std::move(from);
  }

  inline DestinationFlags& operator=(const DestinationFlags& from) {
    CopyFrom(from);
    return *this;
  }
  inline DestinationFlags& operator=(DestinationFlags&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DestinationFlags& default_instance() {
    return *internal_default_instance();
  }
  static inline const DestinationFlags* internal_default_instance() {
    return reinterpret_cast<const DestinationFlags*>(
               &_DestinationFlags_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(DestinationFlags& a, DestinationFlags& b) {
    a.Swap(&b);
  }
  inline void Swap(DestinationFlags* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DestinationFlags* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DestinationFlags* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DestinationFlags>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DestinationFlags& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DestinationFlags& from) {
    DestinationFlags::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DestinationFlags* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.observability.v1.DestinationFlags";
  }
  protected:
  explicit DestinationFlags(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataLakeOptionsFieldNumber = 10,
    kConsoleFieldNumber = 1,
    kCdcStreamFieldNumber = 2,
    kDataLakeFieldNumber = 3,
  };
  // .unhinged.observability.v1.DataLakeOptions data_lake_options = 10;
  bool has_data_lake_options() const;
  private:
  bool _internal_has_data_lake_options() const;
  public:
  void clear_data_lake_options();
  const ::unhinged::observability::v1::DataLakeOptions& data_lake_options() const;
  PROTOBUF_NODISCARD ::unhinged::observability::v1::DataLakeOptions* release_data_lake_options();
  ::unhinged::observability::v1::DataLakeOptions* mutable_data_lake_options();
  void set_allocated_data_lake_options(::unhinged::observability::v1::DataLakeOptions* data_lake_options);
  private:
  const ::unhinged::observability::v1::DataLakeOptions& _internal_data_lake_options() const;
  ::unhinged::observability::v1::DataLakeOptions* _internal_mutable_data_lake_options();
  public:
  void unsafe_arena_set_allocated_data_lake_options(
      ::unhinged::observability::v1::DataLakeOptions* data_lake_options);
  ::unhinged::observability::v1::DataLakeOptions* unsafe_arena_release_data_lake_options();

  // bool console = 1;
  void clear_console();
  bool console() const;
  void set_console(bool value);
  private:
  bool _internal_console() const;
  void _internal_set_console(bool value);
  public:

  // bool cdc_stream = 2;
  void clear_cdc_stream();
  bool cdc_stream() const;
  void set_cdc_stream(bool value);
  private:
  bool _internal_cdc_stream() const;
  void _internal_set_cdc_stream(bool value);
  public:

  // bool data_lake = 3;
  void clear_data_lake();
  bool data_lake() const;
  void set_data_lake(bool value);
  private:
  bool _internal_data_lake() const;
  void _internal_set_data_lake(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.observability.v1.DestinationFlags)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::unhinged::observability::v1::DataLakeOptions* data_lake_options_;
    bool console_;
    bool cdc_stream_;
    bool data_lake_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_observability_2eproto;
};
// -------------------------------------------------------------------

class DataLakeOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.observability.v1.DataLakeOptions) */ {
 public:
  inline DataLakeOptions() : DataLakeOptions(nullptr) {}
  ~DataLakeOptions() override;
  explicit PROTOBUF_CONSTEXPR DataLakeOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataLakeOptions(const DataLakeOptions& from);
  DataLakeOptions(DataLakeOptions&& from) noexcept
    : DataLakeOptions() {
    *this = ::std::move(from);
  }

  inline DataLakeOptions& operator=(const DataLakeOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataLakeOptions& operator=(DataLakeOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataLakeOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataLakeOptions* internal_default_instance() {
    return reinterpret_cast<const DataLakeOptions*>(
               &_DataLakeOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(DataLakeOptions& a, DataLakeOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(DataLakeOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataLakeOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataLakeOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataLakeOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataLakeOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DataLakeOptions& from) {
    DataLakeOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataLakeOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.observability.v1.DataLakeOptions";
  }
  protected:
  explicit DataLakeOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTableNameFieldNumber = 1,
    kPartitionStrategyFieldNumber = 2,
    kBatchSizeFieldNumber = 3,
    kFlushIntervalSecondsFieldNumber = 4,
    kCompressionFieldNumber = 5,
  };
  // string table_name = 1;
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_NODISCARD std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // string partition_strategy = 2;
  void clear_partition_strategy();
  const std::string& partition_strategy() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_partition_strategy(ArgT0&& arg0, ArgT... args);
  std::string* mutable_partition_strategy();
  PROTOBUF_NODISCARD std::string* release_partition_strategy();
  void set_allocated_partition_strategy(std::string* partition_strategy);
  private:
  const std::string& _internal_partition_strategy() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_partition_strategy(const std::string& value);
  std::string* _internal_mutable_partition_strategy();
  public:

  // int32 batch_size = 3;
  void clear_batch_size();
  int32_t batch_size() const;
  void set_batch_size(int32_t value);
  private:
  int32_t _internal_batch_size() const;
  void _internal_set_batch_size(int32_t value);
  public:

  // int32 flush_interval_seconds = 4;
  void clear_flush_interval_seconds();
  int32_t flush_interval_seconds() const;
  void set_flush_interval_seconds(int32_t value);
  private:
  int32_t _internal_flush_interval_seconds() const;
  void _internal_set_flush_interval_seconds(int32_t value);
  public:

  // .unhinged.observability.v1.CompressionType compression = 5;
  void clear_compression();
  ::unhinged::observability::v1::CompressionType compression() const;
  void set_compression(::unhinged::observability::v1::CompressionType value);
  private:
  ::unhinged::observability::v1::CompressionType _internal_compression() const;
  void _internal_set_compression(::unhinged::observability::v1::CompressionType value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.observability.v1.DataLakeOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr partition_strategy_;
    int32_t batch_size_;
    int32_t flush_interval_seconds_;
    int compression_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_observability_2eproto;
};
// -------------------------------------------------------------------

class PartitionInfo_CustomPartitionsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<PartitionInfo_CustomPartitionsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<PartitionInfo_CustomPartitionsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  PartitionInfo_CustomPartitionsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR PartitionInfo_CustomPartitionsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit PartitionInfo_CustomPartitionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const PartitionInfo_CustomPartitionsEntry_DoNotUse& other);
  static const PartitionInfo_CustomPartitionsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const PartitionInfo_CustomPartitionsEntry_DoNotUse*>(&_PartitionInfo_CustomPartitionsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "unhinged.observability.v1.PartitionInfo.CustomPartitionsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "unhinged.observability.v1.PartitionInfo.CustomPartitionsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_observability_2eproto;
};

// -------------------------------------------------------------------

class PartitionInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.observability.v1.PartitionInfo) */ {
 public:
  inline PartitionInfo() : PartitionInfo(nullptr) {}
  ~PartitionInfo() override;
  explicit PROTOBUF_CONSTEXPR PartitionInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PartitionInfo(const PartitionInfo& from);
  PartitionInfo(PartitionInfo&& from) noexcept
    : PartitionInfo() {
    *this = ::std::move(from);
  }

  inline PartitionInfo& operator=(const PartitionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PartitionInfo& operator=(PartitionInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PartitionInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PartitionInfo* internal_default_instance() {
    return reinterpret_cast<const PartitionInfo*>(
               &_PartitionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(PartitionInfo& a, PartitionInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PartitionInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PartitionInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PartitionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PartitionInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PartitionInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PartitionInfo& from) {
    PartitionInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PartitionInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.observability.v1.PartitionInfo";
  }
  protected:
  explicit PartitionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kCustomPartitionsFieldNumber = 10,
    kDatePartitionFieldNumber = 1,
    kHourPartitionFieldNumber = 2,
    kServicePartitionFieldNumber = 3,
    kLevelPartitionFieldNumber = 4,
  };
  // map<string, string> custom_partitions = 10;
  int custom_partitions_size() const;
  private:
  int _internal_custom_partitions_size() const;
  public:
  void clear_custom_partitions();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_custom_partitions() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_custom_partitions();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      custom_partitions() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_custom_partitions();

  // string date_partition = 1;
  void clear_date_partition();
  const std::string& date_partition() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_date_partition(ArgT0&& arg0, ArgT... args);
  std::string* mutable_date_partition();
  PROTOBUF_NODISCARD std::string* release_date_partition();
  void set_allocated_date_partition(std::string* date_partition);
  private:
  const std::string& _internal_date_partition() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_date_partition(const std::string& value);
  std::string* _internal_mutable_date_partition();
  public:

  // string hour_partition = 2;
  void clear_hour_partition();
  const std::string& hour_partition() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hour_partition(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hour_partition();
  PROTOBUF_NODISCARD std::string* release_hour_partition();
  void set_allocated_hour_partition(std::string* hour_partition);
  private:
  const std::string& _internal_hour_partition() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hour_partition(const std::string& value);
  std::string* _internal_mutable_hour_partition();
  public:

  // string service_partition = 3;
  void clear_service_partition();
  const std::string& service_partition() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_partition(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_partition();
  PROTOBUF_NODISCARD std::string* release_service_partition();
  void set_allocated_service_partition(std::string* service_partition);
  private:
  const std::string& _internal_service_partition() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_partition(const std::string& value);
  std::string* _internal_mutable_service_partition();
  public:

  // string level_partition = 4;
  void clear_level_partition();
  const std::string& level_partition() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_level_partition(ArgT0&& arg0, ArgT... args);
  std::string* mutable_level_partition();
  PROTOBUF_NODISCARD std::string* release_level_partition();
  void set_allocated_level_partition(std::string* level_partition);
  private:
  const std::string& _internal_level_partition() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_level_partition(const std::string& value);
  std::string* _internal_mutable_level_partition();
  public:

  // @@protoc_insertion_point(class_scope:unhinged.observability.v1.PartitionInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        PartitionInfo_CustomPartitionsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> custom_partitions_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr date_partition_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hour_partition_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_partition_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr level_partition_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_observability_2eproto;
};
// -------------------------------------------------------------------

class TraceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.observability.v1.TraceEvent) */ {
 public:
  inline TraceEvent() : TraceEvent(nullptr) {}
  ~TraceEvent() override;
  explicit PROTOBUF_CONSTEXPR TraceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TraceEvent(const TraceEvent& from);
  TraceEvent(TraceEvent&& from) noexcept
    : TraceEvent() {
    *this = ::std::move(from);
  }

  inline TraceEvent& operator=(const TraceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline TraceEvent& operator=(TraceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TraceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const TraceEvent* internal_default_instance() {
    return reinterpret_cast<const TraceEvent*>(
               &_TraceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(TraceEvent& a, TraceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(TraceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TraceEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TraceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TraceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TraceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TraceEvent& from) {
    TraceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TraceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.observability.v1.TraceEvent";
  }
  protected:
  explicit TraceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventIdFieldNumber = 1,
    kEventTypeFieldNumber = 3,
    kTimestampFieldNumber = 2,
    kTraceContextFieldNumber = 5,
    kResourceFieldNumber = 6,
    kSpanFieldNumber = 10,
    kDestinationsFieldNumber = 20,
    kPartitionInfoFieldNumber = 25,
    kSequenceNumberFieldNumber = 4,
  };
  // string event_id = 1;
  void clear_event_id();
  const std::string& event_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_event_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_event_id();
  PROTOBUF_NODISCARD std::string* release_event_id();
  void set_allocated_event_id(std::string* event_id);
  private:
  const std::string& _internal_event_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_event_id(const std::string& value);
  std::string* _internal_mutable_event_id();
  public:

  // string event_type = 3;
  void clear_event_type();
  const std::string& event_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_event_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_event_type();
  PROTOBUF_NODISCARD std::string* release_event_type();
  void set_allocated_event_type(std::string* event_type);
  private:
  const std::string& _internal_event_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_event_type(const std::string& value);
  std::string* _internal_mutable_event_type();
  public:

  // .google.protobuf.Timestamp timestamp = 2;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // .unhinged.observability.v1.TraceContext trace_context = 5;
  bool has_trace_context() const;
  private:
  bool _internal_has_trace_context() const;
  public:
  void clear_trace_context();
  const ::unhinged::observability::v1::TraceContext& trace_context() const;
  PROTOBUF_NODISCARD ::unhinged::observability::v1::TraceContext* release_trace_context();
  ::unhinged::observability::v1::TraceContext* mutable_trace_context();
  void set_allocated_trace_context(::unhinged::observability::v1::TraceContext* trace_context);
  private:
  const ::unhinged::observability::v1::TraceContext& _internal_trace_context() const;
  ::unhinged::observability::v1::TraceContext* _internal_mutable_trace_context();
  public:
  void unsafe_arena_set_allocated_trace_context(
      ::unhinged::observability::v1::TraceContext* trace_context);
  ::unhinged::observability::v1::TraceContext* unsafe_arena_release_trace_context();

  // .unhinged.observability.v1.Resource resource = 6;
  bool has_resource() const;
  private:
  bool _internal_has_resource() const;
  public:
  void clear_resource();
  const ::unhinged::observability::v1::Resource& resource() const;
  PROTOBUF_NODISCARD ::unhinged::observability::v1::Resource* release_resource();
  ::unhinged::observability::v1::Resource* mutable_resource();
  void set_allocated_resource(::unhinged::observability::v1::Resource* resource);
  private:
  const ::unhinged::observability::v1::Resource& _internal_resource() const;
  ::unhinged::observability::v1::Resource* _internal_mutable_resource();
  public:
  void unsafe_arena_set_allocated_resource(
      ::unhinged::observability::v1::Resource* resource);
  ::unhinged::observability::v1::Resource* unsafe_arena_release_resource();

  // .unhinged.observability.v1.SpanData span = 10;
  bool has_span() const;
  private:
  bool _internal_has_span() const;
  public:
  void clear_span();
  const ::unhinged::observability::v1::SpanData& span() const;
  PROTOBUF_NODISCARD ::unhinged::observability::v1::SpanData* release_span();
  ::unhinged::observability::v1::SpanData* mutable_span();
  void set_allocated_span(::unhinged::observability::v1::SpanData* span);
  private:
  const ::unhinged::observability::v1::SpanData& _internal_span() const;
  ::unhinged::observability::v1::SpanData* _internal_mutable_span();
  public:
  void unsafe_arena_set_allocated_span(
      ::unhinged::observability::v1::SpanData* span);
  ::unhinged::observability::v1::SpanData* unsafe_arena_release_span();

  // .unhinged.observability.v1.DestinationFlags destinations = 20;
  bool has_destinations() const;
  private:
  bool _internal_has_destinations() const;
  public:
  void clear_destinations();
  const ::unhinged::observability::v1::DestinationFlags& destinations() const;
  PROTOBUF_NODISCARD ::unhinged::observability::v1::DestinationFlags* release_destinations();
  ::unhinged::observability::v1::DestinationFlags* mutable_destinations();
  void set_allocated_destinations(::unhinged::observability::v1::DestinationFlags* destinations);
  private:
  const ::unhinged::observability::v1::DestinationFlags& _internal_destinations() const;
  ::unhinged::observability::v1::DestinationFlags* _internal_mutable_destinations();
  public:
  void unsafe_arena_set_allocated_destinations(
      ::unhinged::observability::v1::DestinationFlags* destinations);
  ::unhinged::observability::v1::DestinationFlags* unsafe_arena_release_destinations();

  // .unhinged.observability.v1.PartitionInfo partition_info = 25;
  bool has_partition_info() const;
  private:
  bool _internal_has_partition_info() const;
  public:
  void clear_partition_info();
  const ::unhinged::observability::v1::PartitionInfo& partition_info() const;
  PROTOBUF_NODISCARD ::unhinged::observability::v1::PartitionInfo* release_partition_info();
  ::unhinged::observability::v1::PartitionInfo* mutable_partition_info();
  void set_allocated_partition_info(::unhinged::observability::v1::PartitionInfo* partition_info);
  private:
  const ::unhinged::observability::v1::PartitionInfo& _internal_partition_info() const;
  ::unhinged::observability::v1::PartitionInfo* _internal_mutable_partition_info();
  public:
  void unsafe_arena_set_allocated_partition_info(
      ::unhinged::observability::v1::PartitionInfo* partition_info);
  ::unhinged::observability::v1::PartitionInfo* unsafe_arena_release_partition_info();

  // int64 sequence_number = 4;
  void clear_sequence_number();
  int64_t sequence_number() const;
  void set_sequence_number(int64_t value);
  private:
  int64_t _internal_sequence_number() const;
  void _internal_set_sequence_number(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.observability.v1.TraceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr event_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr event_type_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
    ::unhinged::observability::v1::TraceContext* trace_context_;
    ::unhinged::observability::v1::Resource* resource_;
    ::unhinged::observability::v1::SpanData* span_;
    ::unhinged::observability::v1::DestinationFlags* destinations_;
    ::unhinged::observability::v1::PartitionInfo* partition_info_;
    int64_t sequence_number_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_observability_2eproto;
};
// -------------------------------------------------------------------

class SpanData_AttributesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SpanData_AttributesEntry_DoNotUse, 
    std::string, ::unhinged::observability::v1::AttributeValue,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SpanData_AttributesEntry_DoNotUse, 
    std::string, ::unhinged::observability::v1::AttributeValue,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  SpanData_AttributesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR SpanData_AttributesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit SpanData_AttributesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SpanData_AttributesEntry_DoNotUse& other);
  static const SpanData_AttributesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SpanData_AttributesEntry_DoNotUse*>(&_SpanData_AttributesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "unhinged.observability.v1.SpanData.AttributesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_observability_2eproto;
};

// -------------------------------------------------------------------

class SpanData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.observability.v1.SpanData) */ {
 public:
  inline SpanData() : SpanData(nullptr) {}
  ~SpanData() override;
  explicit PROTOBUF_CONSTEXPR SpanData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpanData(const SpanData& from);
  SpanData(SpanData&& from) noexcept
    : SpanData() {
    *this = ::std::move(from);
  }

  inline SpanData& operator=(const SpanData& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpanData& operator=(SpanData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpanData& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpanData* internal_default_instance() {
    return reinterpret_cast<const SpanData*>(
               &_SpanData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(SpanData& a, SpanData& b) {
    a.Swap(&b);
  }
  inline void Swap(SpanData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpanData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpanData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SpanData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SpanData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SpanData& from) {
    SpanData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpanData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.observability.v1.SpanData";
  }
  protected:
  explicit SpanData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kAttributesFieldNumber = 15,
    kEventsFieldNumber = 20,
    kLinksFieldNumber = 25,
    kNameFieldNumber = 1,
    kStartTimeFieldNumber = 3,
    kEndTimeFieldNumber = 4,
    kStatusFieldNumber = 10,
    kInstrumentationLibraryFieldNumber = 30,
    kDurationNanosFieldNumber = 5,
    kKindFieldNumber = 2,
  };
  // map<string, .unhinged.observability.v1.AttributeValue> attributes = 15;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;
  public:
  void clear_attributes();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::unhinged::observability::v1::AttributeValue >&
      _internal_attributes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::unhinged::observability::v1::AttributeValue >*
      _internal_mutable_attributes();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::unhinged::observability::v1::AttributeValue >&
      attributes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::unhinged::observability::v1::AttributeValue >*
      mutable_attributes();

  // repeated .unhinged.observability.v1.SpanEvent events = 20;
  int events_size() const;
  private:
  int _internal_events_size() const;
  public:
  void clear_events();
  ::unhinged::observability::v1::SpanEvent* mutable_events(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::SpanEvent >*
      mutable_events();
  private:
  const ::unhinged::observability::v1::SpanEvent& _internal_events(int index) const;
  ::unhinged::observability::v1::SpanEvent* _internal_add_events();
  public:
  const ::unhinged::observability::v1::SpanEvent& events(int index) const;
  ::unhinged::observability::v1::SpanEvent* add_events();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::SpanEvent >&
      events() const;

  // repeated .unhinged.observability.v1.SpanLink links = 25;
  int links_size() const;
  private:
  int _internal_links_size() const;
  public:
  void clear_links();
  ::unhinged::observability::v1::SpanLink* mutable_links(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::SpanLink >*
      mutable_links();
  private:
  const ::unhinged::observability::v1::SpanLink& _internal_links(int index) const;
  ::unhinged::observability::v1::SpanLink* _internal_add_links();
  public:
  const ::unhinged::observability::v1::SpanLink& links(int index) const;
  ::unhinged::observability::v1::SpanLink* add_links();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::SpanLink >&
      links() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .google.protobuf.Timestamp start_time = 3;
  bool has_start_time() const;
  private:
  bool _internal_has_start_time() const;
  public:
  void clear_start_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& start_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_start_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_start_time();
  void set_allocated_start_time(::PROTOBUF_NAMESPACE_ID::Timestamp* start_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_start_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_start_time();
  public:
  void unsafe_arena_set_allocated_start_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_start_time();

  // .google.protobuf.Timestamp end_time = 4;
  bool has_end_time() const;
  private:
  bool _internal_has_end_time() const;
  public:
  void clear_end_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& end_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_end_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_end_time();
  void set_allocated_end_time(::PROTOBUF_NAMESPACE_ID::Timestamp* end_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_end_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_end_time();
  public:
  void unsafe_arena_set_allocated_end_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_end_time();

  // .unhinged.observability.v1.SpanStatus status = 10;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::unhinged::observability::v1::SpanStatus& status() const;
  PROTOBUF_NODISCARD ::unhinged::observability::v1::SpanStatus* release_status();
  ::unhinged::observability::v1::SpanStatus* mutable_status();
  void set_allocated_status(::unhinged::observability::v1::SpanStatus* status);
  private:
  const ::unhinged::observability::v1::SpanStatus& _internal_status() const;
  ::unhinged::observability::v1::SpanStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::unhinged::observability::v1::SpanStatus* status);
  ::unhinged::observability::v1::SpanStatus* unsafe_arena_release_status();

  // .unhinged.observability.v1.InstrumentationLibrary instrumentation_library = 30;
  bool has_instrumentation_library() const;
  private:
  bool _internal_has_instrumentation_library() const;
  public:
  void clear_instrumentation_library();
  const ::unhinged::observability::v1::InstrumentationLibrary& instrumentation_library() const;
  PROTOBUF_NODISCARD ::unhinged::observability::v1::InstrumentationLibrary* release_instrumentation_library();
  ::unhinged::observability::v1::InstrumentationLibrary* mutable_instrumentation_library();
  void set_allocated_instrumentation_library(::unhinged::observability::v1::InstrumentationLibrary* instrumentation_library);
  private:
  const ::unhinged::observability::v1::InstrumentationLibrary& _internal_instrumentation_library() const;
  ::unhinged::observability::v1::InstrumentationLibrary* _internal_mutable_instrumentation_library();
  public:
  void unsafe_arena_set_allocated_instrumentation_library(
      ::unhinged::observability::v1::InstrumentationLibrary* instrumentation_library);
  ::unhinged::observability::v1::InstrumentationLibrary* unsafe_arena_release_instrumentation_library();

  // int64 duration_nanos = 5;
  void clear_duration_nanos();
  int64_t duration_nanos() const;
  void set_duration_nanos(int64_t value);
  private:
  int64_t _internal_duration_nanos() const;
  void _internal_set_duration_nanos(int64_t value);
  public:

  // .unhinged.observability.v1.SpanKind kind = 2;
  void clear_kind();
  ::unhinged::observability::v1::SpanKind kind() const;
  void set_kind(::unhinged::observability::v1::SpanKind value);
  private:
  ::unhinged::observability::v1::SpanKind _internal_kind() const;
  void _internal_set_kind(::unhinged::observability::v1::SpanKind value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.observability.v1.SpanData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        SpanData_AttributesEntry_DoNotUse,
        std::string, ::unhinged::observability::v1::AttributeValue,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> attributes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::SpanEvent > events_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::SpanLink > links_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time_;
    ::unhinged::observability::v1::SpanStatus* status_;
    ::unhinged::observability::v1::InstrumentationLibrary* instrumentation_library_;
    int64_t duration_nanos_;
    int kind_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_observability_2eproto;
};
// -------------------------------------------------------------------

class SpanStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.observability.v1.SpanStatus) */ {
 public:
  inline SpanStatus() : SpanStatus(nullptr) {}
  ~SpanStatus() override;
  explicit PROTOBUF_CONSTEXPR SpanStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpanStatus(const SpanStatus& from);
  SpanStatus(SpanStatus&& from) noexcept
    : SpanStatus() {
    *this = ::std::move(from);
  }

  inline SpanStatus& operator=(const SpanStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpanStatus& operator=(SpanStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpanStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpanStatus* internal_default_instance() {
    return reinterpret_cast<const SpanStatus*>(
               &_SpanStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SpanStatus& a, SpanStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(SpanStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpanStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpanStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SpanStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SpanStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SpanStatus& from) {
    SpanStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpanStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.observability.v1.SpanStatus";
  }
  protected:
  explicit SpanStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kCodeFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .unhinged.observability.v1.StatusCode code = 1;
  void clear_code();
  ::unhinged::observability::v1::StatusCode code() const;
  void set_code(::unhinged::observability::v1::StatusCode value);
  private:
  ::unhinged::observability::v1::StatusCode _internal_code() const;
  void _internal_set_code(::unhinged::observability::v1::StatusCode value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.observability.v1.SpanStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    int code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_observability_2eproto;
};
// -------------------------------------------------------------------

class SpanEvent_AttributesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SpanEvent_AttributesEntry_DoNotUse, 
    std::string, ::unhinged::observability::v1::AttributeValue,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SpanEvent_AttributesEntry_DoNotUse, 
    std::string, ::unhinged::observability::v1::AttributeValue,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  SpanEvent_AttributesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR SpanEvent_AttributesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit SpanEvent_AttributesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SpanEvent_AttributesEntry_DoNotUse& other);
  static const SpanEvent_AttributesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SpanEvent_AttributesEntry_DoNotUse*>(&_SpanEvent_AttributesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "unhinged.observability.v1.SpanEvent.AttributesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_observability_2eproto;
};

// -------------------------------------------------------------------

class SpanEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.observability.v1.SpanEvent) */ {
 public:
  inline SpanEvent() : SpanEvent(nullptr) {}
  ~SpanEvent() override;
  explicit PROTOBUF_CONSTEXPR SpanEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpanEvent(const SpanEvent& from);
  SpanEvent(SpanEvent&& from) noexcept
    : SpanEvent() {
    *this = ::std::move(from);
  }

  inline SpanEvent& operator=(const SpanEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpanEvent& operator=(SpanEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpanEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpanEvent* internal_default_instance() {
    return reinterpret_cast<const SpanEvent*>(
               &_SpanEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(SpanEvent& a, SpanEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(SpanEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpanEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpanEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SpanEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SpanEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SpanEvent& from) {
    SpanEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpanEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.observability.v1.SpanEvent";
  }
  protected:
  explicit SpanEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kAttributesFieldNumber = 3,
    kNameFieldNumber = 2,
    kTimestampFieldNumber = 1,
  };
  // map<string, .unhinged.observability.v1.AttributeValue> attributes = 3;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;
  public:
  void clear_attributes();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::unhinged::observability::v1::AttributeValue >&
      _internal_attributes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::unhinged::observability::v1::AttributeValue >*
      _internal_mutable_attributes();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::unhinged::observability::v1::AttributeValue >&
      attributes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::unhinged::observability::v1::AttributeValue >*
      mutable_attributes();

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .google.protobuf.Timestamp timestamp = 1;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // @@protoc_insertion_point(class_scope:unhinged.observability.v1.SpanEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        SpanEvent_AttributesEntry_DoNotUse,
        std::string, ::unhinged::observability::v1::AttributeValue,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> attributes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_observability_2eproto;
};
// -------------------------------------------------------------------

class SpanLink_AttributesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SpanLink_AttributesEntry_DoNotUse, 
    std::string, ::unhinged::observability::v1::AttributeValue,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SpanLink_AttributesEntry_DoNotUse, 
    std::string, ::unhinged::observability::v1::AttributeValue,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  SpanLink_AttributesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR SpanLink_AttributesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit SpanLink_AttributesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SpanLink_AttributesEntry_DoNotUse& other);
  static const SpanLink_AttributesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SpanLink_AttributesEntry_DoNotUse*>(&_SpanLink_AttributesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "unhinged.observability.v1.SpanLink.AttributesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_observability_2eproto;
};

// -------------------------------------------------------------------

class SpanLink final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.observability.v1.SpanLink) */ {
 public:
  inline SpanLink() : SpanLink(nullptr) {}
  ~SpanLink() override;
  explicit PROTOBUF_CONSTEXPR SpanLink(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpanLink(const SpanLink& from);
  SpanLink(SpanLink&& from) noexcept
    : SpanLink() {
    *this = ::std::move(from);
  }

  inline SpanLink& operator=(const SpanLink& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpanLink& operator=(SpanLink&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpanLink& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpanLink* internal_default_instance() {
    return reinterpret_cast<const SpanLink*>(
               &_SpanLink_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(SpanLink& a, SpanLink& b) {
    a.Swap(&b);
  }
  inline void Swap(SpanLink* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpanLink* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpanLink* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SpanLink>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SpanLink& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SpanLink& from) {
    SpanLink::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpanLink* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.observability.v1.SpanLink";
  }
  protected:
  explicit SpanLink(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kAttributesFieldNumber = 2,
    kTraceContextFieldNumber = 1,
  };
  // map<string, .unhinged.observability.v1.AttributeValue> attributes = 2;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;
  public:
  void clear_attributes();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::unhinged::observability::v1::AttributeValue >&
      _internal_attributes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::unhinged::observability::v1::AttributeValue >*
      _internal_mutable_attributes();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::unhinged::observability::v1::AttributeValue >&
      attributes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::unhinged::observability::v1::AttributeValue >*
      mutable_attributes();

  // .unhinged.observability.v1.TraceContext trace_context = 1;
  bool has_trace_context() const;
  private:
  bool _internal_has_trace_context() const;
  public:
  void clear_trace_context();
  const ::unhinged::observability::v1::TraceContext& trace_context() const;
  PROTOBUF_NODISCARD ::unhinged::observability::v1::TraceContext* release_trace_context();
  ::unhinged::observability::v1::TraceContext* mutable_trace_context();
  void set_allocated_trace_context(::unhinged::observability::v1::TraceContext* trace_context);
  private:
  const ::unhinged::observability::v1::TraceContext& _internal_trace_context() const;
  ::unhinged::observability::v1::TraceContext* _internal_mutable_trace_context();
  public:
  void unsafe_arena_set_allocated_trace_context(
      ::unhinged::observability::v1::TraceContext* trace_context);
  ::unhinged::observability::v1::TraceContext* unsafe_arena_release_trace_context();

  // @@protoc_insertion_point(class_scope:unhinged.observability.v1.SpanLink)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        SpanLink_AttributesEntry_DoNotUse,
        std::string, ::unhinged::observability::v1::AttributeValue,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> attributes_;
    ::unhinged::observability::v1::TraceContext* trace_context_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_observability_2eproto;
};
// -------------------------------------------------------------------

class InstrumentationLibrary final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.observability.v1.InstrumentationLibrary) */ {
 public:
  inline InstrumentationLibrary() : InstrumentationLibrary(nullptr) {}
  ~InstrumentationLibrary() override;
  explicit PROTOBUF_CONSTEXPR InstrumentationLibrary(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InstrumentationLibrary(const InstrumentationLibrary& from);
  InstrumentationLibrary(InstrumentationLibrary&& from) noexcept
    : InstrumentationLibrary() {
    *this = ::std::move(from);
  }

  inline InstrumentationLibrary& operator=(const InstrumentationLibrary& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstrumentationLibrary& operator=(InstrumentationLibrary&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstrumentationLibrary& default_instance() {
    return *internal_default_instance();
  }
  static inline const InstrumentationLibrary* internal_default_instance() {
    return reinterpret_cast<const InstrumentationLibrary*>(
               &_InstrumentationLibrary_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(InstrumentationLibrary& a, InstrumentationLibrary& b) {
    a.Swap(&b);
  }
  inline void Swap(InstrumentationLibrary* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstrumentationLibrary* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstrumentationLibrary* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InstrumentationLibrary>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InstrumentationLibrary& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InstrumentationLibrary& from) {
    InstrumentationLibrary::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InstrumentationLibrary* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.observability.v1.InstrumentationLibrary";
  }
  protected:
  explicit InstrumentationLibrary(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kVersionFieldNumber = 2,
    kSchemaUrlFieldNumber = 3,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string version = 2;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string schema_url = 3;
  void clear_schema_url();
  const std::string& schema_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_schema_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_schema_url();
  PROTOBUF_NODISCARD std::string* release_schema_url();
  void set_allocated_schema_url(std::string* schema_url);
  private:
  const std::string& _internal_schema_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema_url(const std::string& value);
  std::string* _internal_mutable_schema_url();
  public:

  // @@protoc_insertion_point(class_scope:unhinged.observability.v1.InstrumentationLibrary)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_url_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_observability_2eproto;
};
// -------------------------------------------------------------------

class AttributeValue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.observability.v1.AttributeValue) */ {
 public:
  inline AttributeValue() : AttributeValue(nullptr) {}
  ~AttributeValue() override;
  explicit PROTOBUF_CONSTEXPR AttributeValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AttributeValue(const AttributeValue& from);
  AttributeValue(AttributeValue&& from) noexcept
    : AttributeValue() {
    *this = ::std::move(from);
  }

  inline AttributeValue& operator=(const AttributeValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline AttributeValue& operator=(AttributeValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AttributeValue& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kStringValue = 1,
    kBoolValue = 2,
    kIntValue = 3,
    kDoubleValue = 4,
    kBytesValue = 5,
    kArrayValue = 6,
    kKvlistValue = 7,
    VALUE_NOT_SET = 0,
  };

  static inline const AttributeValue* internal_default_instance() {
    return reinterpret_cast<const AttributeValue*>(
               &_AttributeValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(AttributeValue& a, AttributeValue& b) {
    a.Swap(&b);
  }
  inline void Swap(AttributeValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AttributeValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AttributeValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AttributeValue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AttributeValue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AttributeValue& from) {
    AttributeValue::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AttributeValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.observability.v1.AttributeValue";
  }
  protected:
  explicit AttributeValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStringValueFieldNumber = 1,
    kBoolValueFieldNumber = 2,
    kIntValueFieldNumber = 3,
    kDoubleValueFieldNumber = 4,
    kBytesValueFieldNumber = 5,
    kArrayValueFieldNumber = 6,
    kKvlistValueFieldNumber = 7,
  };
  // string string_value = 1;
  bool has_string_value() const;
  private:
  bool _internal_has_string_value() const;
  public:
  void clear_string_value();
  const std::string& string_value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_string_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_string_value();
  PROTOBUF_NODISCARD std::string* release_string_value();
  void set_allocated_string_value(std::string* string_value);
  private:
  const std::string& _internal_string_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_string_value(const std::string& value);
  std::string* _internal_mutable_string_value();
  public:

  // bool bool_value = 2;
  bool has_bool_value() const;
  private:
  bool _internal_has_bool_value() const;
  public:
  void clear_bool_value();
  bool bool_value() const;
  void set_bool_value(bool value);
  private:
  bool _internal_bool_value() const;
  void _internal_set_bool_value(bool value);
  public:

  // int64 int_value = 3;
  bool has_int_value() const;
  private:
  bool _internal_has_int_value() const;
  public:
  void clear_int_value();
  int64_t int_value() const;
  void set_int_value(int64_t value);
  private:
  int64_t _internal_int_value() const;
  void _internal_set_int_value(int64_t value);
  public:

  // double double_value = 4;
  bool has_double_value() const;
  private:
  bool _internal_has_double_value() const;
  public:
  void clear_double_value();
  double double_value() const;
  void set_double_value(double value);
  private:
  double _internal_double_value() const;
  void _internal_set_double_value(double value);
  public:

  // bytes bytes_value = 5;
  bool has_bytes_value() const;
  private:
  bool _internal_has_bytes_value() const;
  public:
  void clear_bytes_value();
  const std::string& bytes_value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bytes_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bytes_value();
  PROTOBUF_NODISCARD std::string* release_bytes_value();
  void set_allocated_bytes_value(std::string* bytes_value);
  private:
  const std::string& _internal_bytes_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bytes_value(const std::string& value);
  std::string* _internal_mutable_bytes_value();
  public:

  // .unhinged.observability.v1.AttributeArray array_value = 6;
  bool has_array_value() const;
  private:
  bool _internal_has_array_value() const;
  public:
  void clear_array_value();
  const ::unhinged::observability::v1::AttributeArray& array_value() const;
  PROTOBUF_NODISCARD ::unhinged::observability::v1::AttributeArray* release_array_value();
  ::unhinged::observability::v1::AttributeArray* mutable_array_value();
  void set_allocated_array_value(::unhinged::observability::v1::AttributeArray* array_value);
  private:
  const ::unhinged::observability::v1::AttributeArray& _internal_array_value() const;
  ::unhinged::observability::v1::AttributeArray* _internal_mutable_array_value();
  public:
  void unsafe_arena_set_allocated_array_value(
      ::unhinged::observability::v1::AttributeArray* array_value);
  ::unhinged::observability::v1::AttributeArray* unsafe_arena_release_array_value();

  // .unhinged.observability.v1.AttributeKeyValueList kvlist_value = 7;
  bool has_kvlist_value() const;
  private:
  bool _internal_has_kvlist_value() const;
  public:
  void clear_kvlist_value();
  const ::unhinged::observability::v1::AttributeKeyValueList& kvlist_value() const;
  PROTOBUF_NODISCARD ::unhinged::observability::v1::AttributeKeyValueList* release_kvlist_value();
  ::unhinged::observability::v1::AttributeKeyValueList* mutable_kvlist_value();
  void set_allocated_kvlist_value(::unhinged::observability::v1::AttributeKeyValueList* kvlist_value);
  private:
  const ::unhinged::observability::v1::AttributeKeyValueList& _internal_kvlist_value() const;
  ::unhinged::observability::v1::AttributeKeyValueList* _internal_mutable_kvlist_value();
  public:
  void unsafe_arena_set_allocated_kvlist_value(
      ::unhinged::observability::v1::AttributeKeyValueList* kvlist_value);
  ::unhinged::observability::v1::AttributeKeyValueList* unsafe_arena_release_kvlist_value();

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:unhinged.observability.v1.AttributeValue)
 private:
  class _Internal;
  void set_has_string_value();
  void set_has_bool_value();
  void set_has_int_value();
  void set_has_double_value();
  void set_has_bytes_value();
  void set_has_array_value();
  void set_has_kvlist_value();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr string_value_;
      bool bool_value_;
      int64_t int_value_;
      double double_value_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bytes_value_;
      ::unhinged::observability::v1::AttributeArray* array_value_;
      ::unhinged::observability::v1::AttributeKeyValueList* kvlist_value_;
    } value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_observability_2eproto;
};
// -------------------------------------------------------------------

class AttributeArray final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.observability.v1.AttributeArray) */ {
 public:
  inline AttributeArray() : AttributeArray(nullptr) {}
  ~AttributeArray() override;
  explicit PROTOBUF_CONSTEXPR AttributeArray(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AttributeArray(const AttributeArray& from);
  AttributeArray(AttributeArray&& from) noexcept
    : AttributeArray() {
    *this = ::std::move(from);
  }

  inline AttributeArray& operator=(const AttributeArray& from) {
    CopyFrom(from);
    return *this;
  }
  inline AttributeArray& operator=(AttributeArray&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AttributeArray& default_instance() {
    return *internal_default_instance();
  }
  static inline const AttributeArray* internal_default_instance() {
    return reinterpret_cast<const AttributeArray*>(
               &_AttributeArray_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(AttributeArray& a, AttributeArray& b) {
    a.Swap(&b);
  }
  inline void Swap(AttributeArray* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AttributeArray* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AttributeArray* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AttributeArray>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AttributeArray& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AttributeArray& from) {
    AttributeArray::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AttributeArray* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.observability.v1.AttributeArray";
  }
  protected:
  explicit AttributeArray(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated .unhinged.observability.v1.AttributeValue values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  ::unhinged::observability::v1::AttributeValue* mutable_values(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::AttributeValue >*
      mutable_values();
  private:
  const ::unhinged::observability::v1::AttributeValue& _internal_values(int index) const;
  ::unhinged::observability::v1::AttributeValue* _internal_add_values();
  public:
  const ::unhinged::observability::v1::AttributeValue& values(int index) const;
  ::unhinged::observability::v1::AttributeValue* add_values();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::AttributeValue >&
      values() const;

  // @@protoc_insertion_point(class_scope:unhinged.observability.v1.AttributeArray)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::AttributeValue > values_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_observability_2eproto;
};
// -------------------------------------------------------------------

class AttributeKeyValueList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.observability.v1.AttributeKeyValueList) */ {
 public:
  inline AttributeKeyValueList() : AttributeKeyValueList(nullptr) {}
  ~AttributeKeyValueList() override;
  explicit PROTOBUF_CONSTEXPR AttributeKeyValueList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AttributeKeyValueList(const AttributeKeyValueList& from);
  AttributeKeyValueList(AttributeKeyValueList&& from) noexcept
    : AttributeKeyValueList() {
    *this = ::std::move(from);
  }

  inline AttributeKeyValueList& operator=(const AttributeKeyValueList& from) {
    CopyFrom(from);
    return *this;
  }
  inline AttributeKeyValueList& operator=(AttributeKeyValueList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AttributeKeyValueList& default_instance() {
    return *internal_default_instance();
  }
  static inline const AttributeKeyValueList* internal_default_instance() {
    return reinterpret_cast<const AttributeKeyValueList*>(
               &_AttributeKeyValueList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(AttributeKeyValueList& a, AttributeKeyValueList& b) {
    a.Swap(&b);
  }
  inline void Swap(AttributeKeyValueList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AttributeKeyValueList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AttributeKeyValueList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AttributeKeyValueList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AttributeKeyValueList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AttributeKeyValueList& from) {
    AttributeKeyValueList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AttributeKeyValueList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.observability.v1.AttributeKeyValueList";
  }
  protected:
  explicit AttributeKeyValueList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated .unhinged.observability.v1.AttributeKeyValue values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  ::unhinged::observability::v1::AttributeKeyValue* mutable_values(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::AttributeKeyValue >*
      mutable_values();
  private:
  const ::unhinged::observability::v1::AttributeKeyValue& _internal_values(int index) const;
  ::unhinged::observability::v1::AttributeKeyValue* _internal_add_values();
  public:
  const ::unhinged::observability::v1::AttributeKeyValue& values(int index) const;
  ::unhinged::observability::v1::AttributeKeyValue* add_values();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::AttributeKeyValue >&
      values() const;

  // @@protoc_insertion_point(class_scope:unhinged.observability.v1.AttributeKeyValueList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::AttributeKeyValue > values_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_observability_2eproto;
};
// -------------------------------------------------------------------

class AttributeKeyValue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.observability.v1.AttributeKeyValue) */ {
 public:
  inline AttributeKeyValue() : AttributeKeyValue(nullptr) {}
  ~AttributeKeyValue() override;
  explicit PROTOBUF_CONSTEXPR AttributeKeyValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AttributeKeyValue(const AttributeKeyValue& from);
  AttributeKeyValue(AttributeKeyValue&& from) noexcept
    : AttributeKeyValue() {
    *this = ::std::move(from);
  }

  inline AttributeKeyValue& operator=(const AttributeKeyValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline AttributeKeyValue& operator=(AttributeKeyValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AttributeKeyValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const AttributeKeyValue* internal_default_instance() {
    return reinterpret_cast<const AttributeKeyValue*>(
               &_AttributeKeyValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(AttributeKeyValue& a, AttributeKeyValue& b) {
    a.Swap(&b);
  }
  inline void Swap(AttributeKeyValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AttributeKeyValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AttributeKeyValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AttributeKeyValue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AttributeKeyValue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AttributeKeyValue& from) {
    AttributeKeyValue::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AttributeKeyValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.observability.v1.AttributeKeyValue";
  }
  protected:
  explicit AttributeKeyValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string key = 1;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // .unhinged.observability.v1.AttributeValue value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::unhinged::observability::v1::AttributeValue& value() const;
  PROTOBUF_NODISCARD ::unhinged::observability::v1::AttributeValue* release_value();
  ::unhinged::observability::v1::AttributeValue* mutable_value();
  void set_allocated_value(::unhinged::observability::v1::AttributeValue* value);
  private:
  const ::unhinged::observability::v1::AttributeValue& _internal_value() const;
  ::unhinged::observability::v1::AttributeValue* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::unhinged::observability::v1::AttributeValue* value);
  ::unhinged::observability::v1::AttributeValue* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:unhinged.observability.v1.AttributeKeyValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::unhinged::observability::v1::AttributeValue* value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_observability_2eproto;
};
// -------------------------------------------------------------------

class MetricEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.observability.v1.MetricEvent) */ {
 public:
  inline MetricEvent() : MetricEvent(nullptr) {}
  ~MetricEvent() override;
  explicit PROTOBUF_CONSTEXPR MetricEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MetricEvent(const MetricEvent& from);
  MetricEvent(MetricEvent&& from) noexcept
    : MetricEvent() {
    *this = ::std::move(from);
  }

  inline MetricEvent& operator=(const MetricEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline MetricEvent& operator=(MetricEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MetricEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const MetricEvent* internal_default_instance() {
    return reinterpret_cast<const MetricEvent*>(
               &_MetricEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(MetricEvent& a, MetricEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(MetricEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MetricEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MetricEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MetricEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MetricEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MetricEvent& from) {
    MetricEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MetricEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.observability.v1.MetricEvent";
  }
  protected:
  explicit MetricEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventIdFieldNumber = 1,
    kEventTypeFieldNumber = 3,
    kTimestampFieldNumber = 2,
    kTraceContextFieldNumber = 5,
    kResourceFieldNumber = 6,
    kMetricFieldNumber = 10,
    kDestinationsFieldNumber = 20,
    kPartitionInfoFieldNumber = 25,
    kSequenceNumberFieldNumber = 4,
  };
  // string event_id = 1;
  void clear_event_id();
  const std::string& event_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_event_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_event_id();
  PROTOBUF_NODISCARD std::string* release_event_id();
  void set_allocated_event_id(std::string* event_id);
  private:
  const std::string& _internal_event_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_event_id(const std::string& value);
  std::string* _internal_mutable_event_id();
  public:

  // string event_type = 3;
  void clear_event_type();
  const std::string& event_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_event_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_event_type();
  PROTOBUF_NODISCARD std::string* release_event_type();
  void set_allocated_event_type(std::string* event_type);
  private:
  const std::string& _internal_event_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_event_type(const std::string& value);
  std::string* _internal_mutable_event_type();
  public:

  // .google.protobuf.Timestamp timestamp = 2;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // .unhinged.observability.v1.TraceContext trace_context = 5;
  bool has_trace_context() const;
  private:
  bool _internal_has_trace_context() const;
  public:
  void clear_trace_context();
  const ::unhinged::observability::v1::TraceContext& trace_context() const;
  PROTOBUF_NODISCARD ::unhinged::observability::v1::TraceContext* release_trace_context();
  ::unhinged::observability::v1::TraceContext* mutable_trace_context();
  void set_allocated_trace_context(::unhinged::observability::v1::TraceContext* trace_context);
  private:
  const ::unhinged::observability::v1::TraceContext& _internal_trace_context() const;
  ::unhinged::observability::v1::TraceContext* _internal_mutable_trace_context();
  public:
  void unsafe_arena_set_allocated_trace_context(
      ::unhinged::observability::v1::TraceContext* trace_context);
  ::unhinged::observability::v1::TraceContext* unsafe_arena_release_trace_context();

  // .unhinged.observability.v1.Resource resource = 6;
  bool has_resource() const;
  private:
  bool _internal_has_resource() const;
  public:
  void clear_resource();
  const ::unhinged::observability::v1::Resource& resource() const;
  PROTOBUF_NODISCARD ::unhinged::observability::v1::Resource* release_resource();
  ::unhinged::observability::v1::Resource* mutable_resource();
  void set_allocated_resource(::unhinged::observability::v1::Resource* resource);
  private:
  const ::unhinged::observability::v1::Resource& _internal_resource() const;
  ::unhinged::observability::v1::Resource* _internal_mutable_resource();
  public:
  void unsafe_arena_set_allocated_resource(
      ::unhinged::observability::v1::Resource* resource);
  ::unhinged::observability::v1::Resource* unsafe_arena_release_resource();

  // .unhinged.observability.v1.MetricData metric = 10;
  bool has_metric() const;
  private:
  bool _internal_has_metric() const;
  public:
  void clear_metric();
  const ::unhinged::observability::v1::MetricData& metric() const;
  PROTOBUF_NODISCARD ::unhinged::observability::v1::MetricData* release_metric();
  ::unhinged::observability::v1::MetricData* mutable_metric();
  void set_allocated_metric(::unhinged::observability::v1::MetricData* metric);
  private:
  const ::unhinged::observability::v1::MetricData& _internal_metric() const;
  ::unhinged::observability::v1::MetricData* _internal_mutable_metric();
  public:
  void unsafe_arena_set_allocated_metric(
      ::unhinged::observability::v1::MetricData* metric);
  ::unhinged::observability::v1::MetricData* unsafe_arena_release_metric();

  // .unhinged.observability.v1.DestinationFlags destinations = 20;
  bool has_destinations() const;
  private:
  bool _internal_has_destinations() const;
  public:
  void clear_destinations();
  const ::unhinged::observability::v1::DestinationFlags& destinations() const;
  PROTOBUF_NODISCARD ::unhinged::observability::v1::DestinationFlags* release_destinations();
  ::unhinged::observability::v1::DestinationFlags* mutable_destinations();
  void set_allocated_destinations(::unhinged::observability::v1::DestinationFlags* destinations);
  private:
  const ::unhinged::observability::v1::DestinationFlags& _internal_destinations() const;
  ::unhinged::observability::v1::DestinationFlags* _internal_mutable_destinations();
  public:
  void unsafe_arena_set_allocated_destinations(
      ::unhinged::observability::v1::DestinationFlags* destinations);
  ::unhinged::observability::v1::DestinationFlags* unsafe_arena_release_destinations();

  // .unhinged.observability.v1.PartitionInfo partition_info = 25;
  bool has_partition_info() const;
  private:
  bool _internal_has_partition_info() const;
  public:
  void clear_partition_info();
  const ::unhinged::observability::v1::PartitionInfo& partition_info() const;
  PROTOBUF_NODISCARD ::unhinged::observability::v1::PartitionInfo* release_partition_info();
  ::unhinged::observability::v1::PartitionInfo* mutable_partition_info();
  void set_allocated_partition_info(::unhinged::observability::v1::PartitionInfo* partition_info);
  private:
  const ::unhinged::observability::v1::PartitionInfo& _internal_partition_info() const;
  ::unhinged::observability::v1::PartitionInfo* _internal_mutable_partition_info();
  public:
  void unsafe_arena_set_allocated_partition_info(
      ::unhinged::observability::v1::PartitionInfo* partition_info);
  ::unhinged::observability::v1::PartitionInfo* unsafe_arena_release_partition_info();

  // int64 sequence_number = 4;
  void clear_sequence_number();
  int64_t sequence_number() const;
  void set_sequence_number(int64_t value);
  private:
  int64_t _internal_sequence_number() const;
  void _internal_set_sequence_number(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.observability.v1.MetricEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr event_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr event_type_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
    ::unhinged::observability::v1::TraceContext* trace_context_;
    ::unhinged::observability::v1::Resource* resource_;
    ::unhinged::observability::v1::MetricData* metric_;
    ::unhinged::observability::v1::DestinationFlags* destinations_;
    ::unhinged::observability::v1::PartitionInfo* partition_info_;
    int64_t sequence_number_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_observability_2eproto;
};
// -------------------------------------------------------------------

class MetricData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.observability.v1.MetricData) */ {
 public:
  inline MetricData() : MetricData(nullptr) {}
  ~MetricData() override;
  explicit PROTOBUF_CONSTEXPR MetricData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MetricData(const MetricData& from);
  MetricData(MetricData&& from) noexcept
    : MetricData() {
    *this = ::std::move(from);
  }

  inline MetricData& operator=(const MetricData& from) {
    CopyFrom(from);
    return *this;
  }
  inline MetricData& operator=(MetricData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MetricData& default_instance() {
    return *internal_default_instance();
  }
  enum DataCase {
    kGauge = 10,
    kCounter = 11,
    kHistogram = 12,
    kSummary = 13,
    DATA_NOT_SET = 0,
  };

  static inline const MetricData* internal_default_instance() {
    return reinterpret_cast<const MetricData*>(
               &_MetricData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(MetricData& a, MetricData& b) {
    a.Swap(&b);
  }
  inline void Swap(MetricData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MetricData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MetricData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MetricData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MetricData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MetricData& from) {
    MetricData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MetricData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.observability.v1.MetricData";
  }
  protected:
  explicit MetricData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kUnitFieldNumber = 3,
    kInstrumentationLibraryFieldNumber = 20,
    kGaugeFieldNumber = 10,
    kCounterFieldNumber = 11,
    kHistogramFieldNumber = 12,
    kSummaryFieldNumber = 13,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string description = 2;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string unit = 3;
  void clear_unit();
  const std::string& unit() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_unit(ArgT0&& arg0, ArgT... args);
  std::string* mutable_unit();
  PROTOBUF_NODISCARD std::string* release_unit();
  void set_allocated_unit(std::string* unit);
  private:
  const std::string& _internal_unit() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_unit(const std::string& value);
  std::string* _internal_mutable_unit();
  public:

  // .unhinged.observability.v1.InstrumentationLibrary instrumentation_library = 20;
  bool has_instrumentation_library() const;
  private:
  bool _internal_has_instrumentation_library() const;
  public:
  void clear_instrumentation_library();
  const ::unhinged::observability::v1::InstrumentationLibrary& instrumentation_library() const;
  PROTOBUF_NODISCARD ::unhinged::observability::v1::InstrumentationLibrary* release_instrumentation_library();
  ::unhinged::observability::v1::InstrumentationLibrary* mutable_instrumentation_library();
  void set_allocated_instrumentation_library(::unhinged::observability::v1::InstrumentationLibrary* instrumentation_library);
  private:
  const ::unhinged::observability::v1::InstrumentationLibrary& _internal_instrumentation_library() const;
  ::unhinged::observability::v1::InstrumentationLibrary* _internal_mutable_instrumentation_library();
  public:
  void unsafe_arena_set_allocated_instrumentation_library(
      ::unhinged::observability::v1::InstrumentationLibrary* instrumentation_library);
  ::unhinged::observability::v1::InstrumentationLibrary* unsafe_arena_release_instrumentation_library();

  // .unhinged.observability.v1.GaugeData gauge = 10;
  bool has_gauge() const;
  private:
  bool _internal_has_gauge() const;
  public:
  void clear_gauge();
  const ::unhinged::observability::v1::GaugeData& gauge() const;
  PROTOBUF_NODISCARD ::unhinged::observability::v1::GaugeData* release_gauge();
  ::unhinged::observability::v1::GaugeData* mutable_gauge();
  void set_allocated_gauge(::unhinged::observability::v1::GaugeData* gauge);
  private:
  const ::unhinged::observability::v1::GaugeData& _internal_gauge() const;
  ::unhinged::observability::v1::GaugeData* _internal_mutable_gauge();
  public:
  void unsafe_arena_set_allocated_gauge(
      ::unhinged::observability::v1::GaugeData* gauge);
  ::unhinged::observability::v1::GaugeData* unsafe_arena_release_gauge();

  // .unhinged.observability.v1.CounterData counter = 11;
  bool has_counter() const;
  private:
  bool _internal_has_counter() const;
  public:
  void clear_counter();
  const ::unhinged::observability::v1::CounterData& counter() const;
  PROTOBUF_NODISCARD ::unhinged::observability::v1::CounterData* release_counter();
  ::unhinged::observability::v1::CounterData* mutable_counter();
  void set_allocated_counter(::unhinged::observability::v1::CounterData* counter);
  private:
  const ::unhinged::observability::v1::CounterData& _internal_counter() const;
  ::unhinged::observability::v1::CounterData* _internal_mutable_counter();
  public:
  void unsafe_arena_set_allocated_counter(
      ::unhinged::observability::v1::CounterData* counter);
  ::unhinged::observability::v1::CounterData* unsafe_arena_release_counter();

  // .unhinged.observability.v1.HistogramData histogram = 12;
  bool has_histogram() const;
  private:
  bool _internal_has_histogram() const;
  public:
  void clear_histogram();
  const ::unhinged::observability::v1::HistogramData& histogram() const;
  PROTOBUF_NODISCARD ::unhinged::observability::v1::HistogramData* release_histogram();
  ::unhinged::observability::v1::HistogramData* mutable_histogram();
  void set_allocated_histogram(::unhinged::observability::v1::HistogramData* histogram);
  private:
  const ::unhinged::observability::v1::HistogramData& _internal_histogram() const;
  ::unhinged::observability::v1::HistogramData* _internal_mutable_histogram();
  public:
  void unsafe_arena_set_allocated_histogram(
      ::unhinged::observability::v1::HistogramData* histogram);
  ::unhinged::observability::v1::HistogramData* unsafe_arena_release_histogram();

  // .unhinged.observability.v1.SummaryData summary = 13;
  bool has_summary() const;
  private:
  bool _internal_has_summary() const;
  public:
  void clear_summary();
  const ::unhinged::observability::v1::SummaryData& summary() const;
  PROTOBUF_NODISCARD ::unhinged::observability::v1::SummaryData* release_summary();
  ::unhinged::observability::v1::SummaryData* mutable_summary();
  void set_allocated_summary(::unhinged::observability::v1::SummaryData* summary);
  private:
  const ::unhinged::observability::v1::SummaryData& _internal_summary() const;
  ::unhinged::observability::v1::SummaryData* _internal_mutable_summary();
  public:
  void unsafe_arena_set_allocated_summary(
      ::unhinged::observability::v1::SummaryData* summary);
  ::unhinged::observability::v1::SummaryData* unsafe_arena_release_summary();

  void clear_data();
  DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:unhinged.observability.v1.MetricData)
 private:
  class _Internal;
  void set_has_gauge();
  void set_has_counter();
  void set_has_histogram();
  void set_has_summary();

  inline bool has_data() const;
  inline void clear_has_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr unit_;
    ::unhinged::observability::v1::InstrumentationLibrary* instrumentation_library_;
    union DataUnion {
      constexpr DataUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::unhinged::observability::v1::GaugeData* gauge_;
      ::unhinged::observability::v1::CounterData* counter_;
      ::unhinged::observability::v1::HistogramData* histogram_;
      ::unhinged::observability::v1::SummaryData* summary_;
    } data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_observability_2eproto;
};
// -------------------------------------------------------------------

class GaugeData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.observability.v1.GaugeData) */ {
 public:
  inline GaugeData() : GaugeData(nullptr) {}
  ~GaugeData() override;
  explicit PROTOBUF_CONSTEXPR GaugeData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GaugeData(const GaugeData& from);
  GaugeData(GaugeData&& from) noexcept
    : GaugeData() {
    *this = ::std::move(from);
  }

  inline GaugeData& operator=(const GaugeData& from) {
    CopyFrom(from);
    return *this;
  }
  inline GaugeData& operator=(GaugeData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GaugeData& default_instance() {
    return *internal_default_instance();
  }
  static inline const GaugeData* internal_default_instance() {
    return reinterpret_cast<const GaugeData*>(
               &_GaugeData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(GaugeData& a, GaugeData& b) {
    a.Swap(&b);
  }
  inline void Swap(GaugeData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GaugeData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GaugeData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GaugeData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GaugeData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GaugeData& from) {
    GaugeData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GaugeData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.observability.v1.GaugeData";
  }
  protected:
  explicit GaugeData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataPointsFieldNumber = 1,
  };
  // repeated .unhinged.observability.v1.NumberDataPoint data_points = 1;
  int data_points_size() const;
  private:
  int _internal_data_points_size() const;
  public:
  void clear_data_points();
  ::unhinged::observability::v1::NumberDataPoint* mutable_data_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::NumberDataPoint >*
      mutable_data_points();
  private:
  const ::unhinged::observability::v1::NumberDataPoint& _internal_data_points(int index) const;
  ::unhinged::observability::v1::NumberDataPoint* _internal_add_data_points();
  public:
  const ::unhinged::observability::v1::NumberDataPoint& data_points(int index) const;
  ::unhinged::observability::v1::NumberDataPoint* add_data_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::NumberDataPoint >&
      data_points() const;

  // @@protoc_insertion_point(class_scope:unhinged.observability.v1.GaugeData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::NumberDataPoint > data_points_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_observability_2eproto;
};
// -------------------------------------------------------------------

class CounterData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.observability.v1.CounterData) */ {
 public:
  inline CounterData() : CounterData(nullptr) {}
  ~CounterData() override;
  explicit PROTOBUF_CONSTEXPR CounterData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CounterData(const CounterData& from);
  CounterData(CounterData&& from) noexcept
    : CounterData() {
    *this = ::std::move(from);
  }

  inline CounterData& operator=(const CounterData& from) {
    CopyFrom(from);
    return *this;
  }
  inline CounterData& operator=(CounterData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CounterData& default_instance() {
    return *internal_default_instance();
  }
  static inline const CounterData* internal_default_instance() {
    return reinterpret_cast<const CounterData*>(
               &_CounterData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(CounterData& a, CounterData& b) {
    a.Swap(&b);
  }
  inline void Swap(CounterData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CounterData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CounterData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CounterData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CounterData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CounterData& from) {
    CounterData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CounterData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.observability.v1.CounterData";
  }
  protected:
  explicit CounterData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataPointsFieldNumber = 1,
    kIsMonotonicFieldNumber = 2,
  };
  // repeated .unhinged.observability.v1.NumberDataPoint data_points = 1;
  int data_points_size() const;
  private:
  int _internal_data_points_size() const;
  public:
  void clear_data_points();
  ::unhinged::observability::v1::NumberDataPoint* mutable_data_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::NumberDataPoint >*
      mutable_data_points();
  private:
  const ::unhinged::observability::v1::NumberDataPoint& _internal_data_points(int index) const;
  ::unhinged::observability::v1::NumberDataPoint* _internal_add_data_points();
  public:
  const ::unhinged::observability::v1::NumberDataPoint& data_points(int index) const;
  ::unhinged::observability::v1::NumberDataPoint* add_data_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::NumberDataPoint >&
      data_points() const;

  // bool is_monotonic = 2;
  void clear_is_monotonic();
  bool is_monotonic() const;
  void set_is_monotonic(bool value);
  private:
  bool _internal_is_monotonic() const;
  void _internal_set_is_monotonic(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.observability.v1.CounterData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::NumberDataPoint > data_points_;
    bool is_monotonic_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_observability_2eproto;
};
// -------------------------------------------------------------------

class HistogramData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.observability.v1.HistogramData) */ {
 public:
  inline HistogramData() : HistogramData(nullptr) {}
  ~HistogramData() override;
  explicit PROTOBUF_CONSTEXPR HistogramData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HistogramData(const HistogramData& from);
  HistogramData(HistogramData&& from) noexcept
    : HistogramData() {
    *this = ::std::move(from);
  }

  inline HistogramData& operator=(const HistogramData& from) {
    CopyFrom(from);
    return *this;
  }
  inline HistogramData& operator=(HistogramData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HistogramData& default_instance() {
    return *internal_default_instance();
  }
  static inline const HistogramData* internal_default_instance() {
    return reinterpret_cast<const HistogramData*>(
               &_HistogramData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(HistogramData& a, HistogramData& b) {
    a.Swap(&b);
  }
  inline void Swap(HistogramData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HistogramData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HistogramData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HistogramData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HistogramData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HistogramData& from) {
    HistogramData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HistogramData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.observability.v1.HistogramData";
  }
  protected:
  explicit HistogramData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataPointsFieldNumber = 1,
    kAggregationTemporalityFieldNumber = 2,
  };
  // repeated .unhinged.observability.v1.HistogramDataPoint data_points = 1;
  int data_points_size() const;
  private:
  int _internal_data_points_size() const;
  public:
  void clear_data_points();
  ::unhinged::observability::v1::HistogramDataPoint* mutable_data_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::HistogramDataPoint >*
      mutable_data_points();
  private:
  const ::unhinged::observability::v1::HistogramDataPoint& _internal_data_points(int index) const;
  ::unhinged::observability::v1::HistogramDataPoint* _internal_add_data_points();
  public:
  const ::unhinged::observability::v1::HistogramDataPoint& data_points(int index) const;
  ::unhinged::observability::v1::HistogramDataPoint* add_data_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::HistogramDataPoint >&
      data_points() const;

  // .unhinged.observability.v1.AggregationTemporality aggregation_temporality = 2;
  void clear_aggregation_temporality();
  ::unhinged::observability::v1::AggregationTemporality aggregation_temporality() const;
  void set_aggregation_temporality(::unhinged::observability::v1::AggregationTemporality value);
  private:
  ::unhinged::observability::v1::AggregationTemporality _internal_aggregation_temporality() const;
  void _internal_set_aggregation_temporality(::unhinged::observability::v1::AggregationTemporality value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.observability.v1.HistogramData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::HistogramDataPoint > data_points_;
    int aggregation_temporality_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_observability_2eproto;
};
// -------------------------------------------------------------------

class SummaryData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.observability.v1.SummaryData) */ {
 public:
  inline SummaryData() : SummaryData(nullptr) {}
  ~SummaryData() override;
  explicit PROTOBUF_CONSTEXPR SummaryData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SummaryData(const SummaryData& from);
  SummaryData(SummaryData&& from) noexcept
    : SummaryData() {
    *this = ::std::move(from);
  }

  inline SummaryData& operator=(const SummaryData& from) {
    CopyFrom(from);
    return *this;
  }
  inline SummaryData& operator=(SummaryData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SummaryData& default_instance() {
    return *internal_default_instance();
  }
  static inline const SummaryData* internal_default_instance() {
    return reinterpret_cast<const SummaryData*>(
               &_SummaryData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(SummaryData& a, SummaryData& b) {
    a.Swap(&b);
  }
  inline void Swap(SummaryData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SummaryData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SummaryData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SummaryData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SummaryData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SummaryData& from) {
    SummaryData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SummaryData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.observability.v1.SummaryData";
  }
  protected:
  explicit SummaryData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataPointsFieldNumber = 1,
  };
  // repeated .unhinged.observability.v1.SummaryDataPoint data_points = 1;
  int data_points_size() const;
  private:
  int _internal_data_points_size() const;
  public:
  void clear_data_points();
  ::unhinged::observability::v1::SummaryDataPoint* mutable_data_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::SummaryDataPoint >*
      mutable_data_points();
  private:
  const ::unhinged::observability::v1::SummaryDataPoint& _internal_data_points(int index) const;
  ::unhinged::observability::v1::SummaryDataPoint* _internal_add_data_points();
  public:
  const ::unhinged::observability::v1::SummaryDataPoint& data_points(int index) const;
  ::unhinged::observability::v1::SummaryDataPoint* add_data_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::SummaryDataPoint >&
      data_points() const;

  // @@protoc_insertion_point(class_scope:unhinged.observability.v1.SummaryData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::SummaryDataPoint > data_points_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_observability_2eproto;
};
// -------------------------------------------------------------------

class NumberDataPoint_AttributesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<NumberDataPoint_AttributesEntry_DoNotUse, 
    std::string, ::unhinged::observability::v1::AttributeValue,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<NumberDataPoint_AttributesEntry_DoNotUse, 
    std::string, ::unhinged::observability::v1::AttributeValue,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  NumberDataPoint_AttributesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR NumberDataPoint_AttributesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit NumberDataPoint_AttributesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const NumberDataPoint_AttributesEntry_DoNotUse& other);
  static const NumberDataPoint_AttributesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const NumberDataPoint_AttributesEntry_DoNotUse*>(&_NumberDataPoint_AttributesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "unhinged.observability.v1.NumberDataPoint.AttributesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_observability_2eproto;
};

// -------------------------------------------------------------------

class NumberDataPoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.observability.v1.NumberDataPoint) */ {
 public:
  inline NumberDataPoint() : NumberDataPoint(nullptr) {}
  ~NumberDataPoint() override;
  explicit PROTOBUF_CONSTEXPR NumberDataPoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NumberDataPoint(const NumberDataPoint& from);
  NumberDataPoint(NumberDataPoint&& from) noexcept
    : NumberDataPoint() {
    *this = ::std::move(from);
  }

  inline NumberDataPoint& operator=(const NumberDataPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline NumberDataPoint& operator=(NumberDataPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NumberDataPoint& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kAsDouble = 10,
    kAsInt = 11,
    VALUE_NOT_SET = 0,
  };

  static inline const NumberDataPoint* internal_default_instance() {
    return reinterpret_cast<const NumberDataPoint*>(
               &_NumberDataPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(NumberDataPoint& a, NumberDataPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(NumberDataPoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NumberDataPoint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NumberDataPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NumberDataPoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NumberDataPoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NumberDataPoint& from) {
    NumberDataPoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NumberDataPoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.observability.v1.NumberDataPoint";
  }
  protected:
  explicit NumberDataPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kAttributesFieldNumber = 1,
    kExemplarsFieldNumber = 20,
    kStartTimeFieldNumber = 2,
    kTimeFieldNumber = 3,
    kAsDoubleFieldNumber = 10,
    kAsIntFieldNumber = 11,
  };
  // map<string, .unhinged.observability.v1.AttributeValue> attributes = 1;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;
  public:
  void clear_attributes();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::unhinged::observability::v1::AttributeValue >&
      _internal_attributes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::unhinged::observability::v1::AttributeValue >*
      _internal_mutable_attributes();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::unhinged::observability::v1::AttributeValue >&
      attributes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::unhinged::observability::v1::AttributeValue >*
      mutable_attributes();

  // repeated .unhinged.observability.v1.Exemplar exemplars = 20;
  int exemplars_size() const;
  private:
  int _internal_exemplars_size() const;
  public:
  void clear_exemplars();
  ::unhinged::observability::v1::Exemplar* mutable_exemplars(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::Exemplar >*
      mutable_exemplars();
  private:
  const ::unhinged::observability::v1::Exemplar& _internal_exemplars(int index) const;
  ::unhinged::observability::v1::Exemplar* _internal_add_exemplars();
  public:
  const ::unhinged::observability::v1::Exemplar& exemplars(int index) const;
  ::unhinged::observability::v1::Exemplar* add_exemplars();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::Exemplar >&
      exemplars() const;

  // .google.protobuf.Timestamp start_time = 2;
  bool has_start_time() const;
  private:
  bool _internal_has_start_time() const;
  public:
  void clear_start_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& start_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_start_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_start_time();
  void set_allocated_start_time(::PROTOBUF_NAMESPACE_ID::Timestamp* start_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_start_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_start_time();
  public:
  void unsafe_arena_set_allocated_start_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_start_time();

  // .google.protobuf.Timestamp time = 3;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_time();
  void set_allocated_time(::PROTOBUF_NAMESPACE_ID::Timestamp* time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_time();
  public:
  void unsafe_arena_set_allocated_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_time();

  // double as_double = 10;
  bool has_as_double() const;
  private:
  bool _internal_has_as_double() const;
  public:
  void clear_as_double();
  double as_double() const;
  void set_as_double(double value);
  private:
  double _internal_as_double() const;
  void _internal_set_as_double(double value);
  public:

  // int64 as_int = 11;
  bool has_as_int() const;
  private:
  bool _internal_has_as_int() const;
  public:
  void clear_as_int();
  int64_t as_int() const;
  void set_as_int(int64_t value);
  private:
  int64_t _internal_as_int() const;
  void _internal_set_as_int(int64_t value);
  public:

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:unhinged.observability.v1.NumberDataPoint)
 private:
  class _Internal;
  void set_has_as_double();
  void set_has_as_int();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        NumberDataPoint_AttributesEntry_DoNotUse,
        std::string, ::unhinged::observability::v1::AttributeValue,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> attributes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::Exemplar > exemplars_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* time_;
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      double as_double_;
      int64_t as_int_;
    } value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_observability_2eproto;
};
// -------------------------------------------------------------------

class HistogramDataPoint_AttributesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<HistogramDataPoint_AttributesEntry_DoNotUse, 
    std::string, ::unhinged::observability::v1::AttributeValue,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<HistogramDataPoint_AttributesEntry_DoNotUse, 
    std::string, ::unhinged::observability::v1::AttributeValue,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  HistogramDataPoint_AttributesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR HistogramDataPoint_AttributesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit HistogramDataPoint_AttributesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const HistogramDataPoint_AttributesEntry_DoNotUse& other);
  static const HistogramDataPoint_AttributesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const HistogramDataPoint_AttributesEntry_DoNotUse*>(&_HistogramDataPoint_AttributesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "unhinged.observability.v1.HistogramDataPoint.AttributesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_observability_2eproto;
};

// -------------------------------------------------------------------

class HistogramDataPoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.observability.v1.HistogramDataPoint) */ {
 public:
  inline HistogramDataPoint() : HistogramDataPoint(nullptr) {}
  ~HistogramDataPoint() override;
  explicit PROTOBUF_CONSTEXPR HistogramDataPoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HistogramDataPoint(const HistogramDataPoint& from);
  HistogramDataPoint(HistogramDataPoint&& from) noexcept
    : HistogramDataPoint() {
    *this = ::std::move(from);
  }

  inline HistogramDataPoint& operator=(const HistogramDataPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline HistogramDataPoint& operator=(HistogramDataPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HistogramDataPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const HistogramDataPoint* internal_default_instance() {
    return reinterpret_cast<const HistogramDataPoint*>(
               &_HistogramDataPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(HistogramDataPoint& a, HistogramDataPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(HistogramDataPoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HistogramDataPoint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HistogramDataPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HistogramDataPoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HistogramDataPoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HistogramDataPoint& from) {
    HistogramDataPoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HistogramDataPoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.observability.v1.HistogramDataPoint";
  }
  protected:
  explicit HistogramDataPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kAttributesFieldNumber = 1,
    kExplicitBoundsFieldNumber = 12,
    kBucketCountsFieldNumber = 13,
    kExemplarsFieldNumber = 20,
    kStartTimeFieldNumber = 2,
    kTimeFieldNumber = 3,
    kCountFieldNumber = 10,
    kSumFieldNumber = 11,
  };
  // map<string, .unhinged.observability.v1.AttributeValue> attributes = 1;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;
  public:
  void clear_attributes();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::unhinged::observability::v1::AttributeValue >&
      _internal_attributes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::unhinged::observability::v1::AttributeValue >*
      _internal_mutable_attributes();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::unhinged::observability::v1::AttributeValue >&
      attributes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::unhinged::observability::v1::AttributeValue >*
      mutable_attributes();

  // repeated double explicit_bounds = 12;
  int explicit_bounds_size() const;
  private:
  int _internal_explicit_bounds_size() const;
  public:
  void clear_explicit_bounds();
  private:
  double _internal_explicit_bounds(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_explicit_bounds() const;
  void _internal_add_explicit_bounds(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_explicit_bounds();
  public:
  double explicit_bounds(int index) const;
  void set_explicit_bounds(int index, double value);
  void add_explicit_bounds(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      explicit_bounds() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_explicit_bounds();

  // repeated uint64 bucket_counts = 13;
  int bucket_counts_size() const;
  private:
  int _internal_bucket_counts_size() const;
  public:
  void clear_bucket_counts();
  private:
  uint64_t _internal_bucket_counts(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_bucket_counts() const;
  void _internal_add_bucket_counts(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_bucket_counts();
  public:
  uint64_t bucket_counts(int index) const;
  void set_bucket_counts(int index, uint64_t value);
  void add_bucket_counts(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      bucket_counts() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_bucket_counts();

  // repeated .unhinged.observability.v1.Exemplar exemplars = 20;
  int exemplars_size() const;
  private:
  int _internal_exemplars_size() const;
  public:
  void clear_exemplars();
  ::unhinged::observability::v1::Exemplar* mutable_exemplars(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::Exemplar >*
      mutable_exemplars();
  private:
  const ::unhinged::observability::v1::Exemplar& _internal_exemplars(int index) const;
  ::unhinged::observability::v1::Exemplar* _internal_add_exemplars();
  public:
  const ::unhinged::observability::v1::Exemplar& exemplars(int index) const;
  ::unhinged::observability::v1::Exemplar* add_exemplars();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::Exemplar >&
      exemplars() const;

  // .google.protobuf.Timestamp start_time = 2;
  bool has_start_time() const;
  private:
  bool _internal_has_start_time() const;
  public:
  void clear_start_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& start_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_start_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_start_time();
  void set_allocated_start_time(::PROTOBUF_NAMESPACE_ID::Timestamp* start_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_start_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_start_time();
  public:
  void unsafe_arena_set_allocated_start_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_start_time();

  // .google.protobuf.Timestamp time = 3;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_time();
  void set_allocated_time(::PROTOBUF_NAMESPACE_ID::Timestamp* time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_time();
  public:
  void unsafe_arena_set_allocated_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_time();

  // uint64 count = 10;
  void clear_count();
  uint64_t count() const;
  void set_count(uint64_t value);
  private:
  uint64_t _internal_count() const;
  void _internal_set_count(uint64_t value);
  public:

  // double sum = 11;
  void clear_sum();
  double sum() const;
  void set_sum(double value);
  private:
  double _internal_sum() const;
  void _internal_set_sum(double value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.observability.v1.HistogramDataPoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        HistogramDataPoint_AttributesEntry_DoNotUse,
        std::string, ::unhinged::observability::v1::AttributeValue,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> attributes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > explicit_bounds_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > bucket_counts_;
    mutable std::atomic<int> _bucket_counts_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::Exemplar > exemplars_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* time_;
    uint64_t count_;
    double sum_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_observability_2eproto;
};
// -------------------------------------------------------------------

class SummaryDataPoint_AttributesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SummaryDataPoint_AttributesEntry_DoNotUse, 
    std::string, ::unhinged::observability::v1::AttributeValue,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SummaryDataPoint_AttributesEntry_DoNotUse, 
    std::string, ::unhinged::observability::v1::AttributeValue,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  SummaryDataPoint_AttributesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR SummaryDataPoint_AttributesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit SummaryDataPoint_AttributesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SummaryDataPoint_AttributesEntry_DoNotUse& other);
  static const SummaryDataPoint_AttributesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SummaryDataPoint_AttributesEntry_DoNotUse*>(&_SummaryDataPoint_AttributesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "unhinged.observability.v1.SummaryDataPoint.AttributesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_observability_2eproto;
};

// -------------------------------------------------------------------

class SummaryDataPoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.observability.v1.SummaryDataPoint) */ {
 public:
  inline SummaryDataPoint() : SummaryDataPoint(nullptr) {}
  ~SummaryDataPoint() override;
  explicit PROTOBUF_CONSTEXPR SummaryDataPoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SummaryDataPoint(const SummaryDataPoint& from);
  SummaryDataPoint(SummaryDataPoint&& from) noexcept
    : SummaryDataPoint() {
    *this = ::std::move(from);
  }

  inline SummaryDataPoint& operator=(const SummaryDataPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline SummaryDataPoint& operator=(SummaryDataPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SummaryDataPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const SummaryDataPoint* internal_default_instance() {
    return reinterpret_cast<const SummaryDataPoint*>(
               &_SummaryDataPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(SummaryDataPoint& a, SummaryDataPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(SummaryDataPoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SummaryDataPoint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SummaryDataPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SummaryDataPoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SummaryDataPoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SummaryDataPoint& from) {
    SummaryDataPoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SummaryDataPoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.observability.v1.SummaryDataPoint";
  }
  protected:
  explicit SummaryDataPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kAttributesFieldNumber = 1,
    kQuantileValuesFieldNumber = 12,
    kStartTimeFieldNumber = 2,
    kTimeFieldNumber = 3,
    kCountFieldNumber = 10,
    kSumFieldNumber = 11,
  };
  // map<string, .unhinged.observability.v1.AttributeValue> attributes = 1;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;
  public:
  void clear_attributes();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::unhinged::observability::v1::AttributeValue >&
      _internal_attributes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::unhinged::observability::v1::AttributeValue >*
      _internal_mutable_attributes();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::unhinged::observability::v1::AttributeValue >&
      attributes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::unhinged::observability::v1::AttributeValue >*
      mutable_attributes();

  // repeated .unhinged.observability.v1.QuantileValue quantile_values = 12;
  int quantile_values_size() const;
  private:
  int _internal_quantile_values_size() const;
  public:
  void clear_quantile_values();
  ::unhinged::observability::v1::QuantileValue* mutable_quantile_values(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::QuantileValue >*
      mutable_quantile_values();
  private:
  const ::unhinged::observability::v1::QuantileValue& _internal_quantile_values(int index) const;
  ::unhinged::observability::v1::QuantileValue* _internal_add_quantile_values();
  public:
  const ::unhinged::observability::v1::QuantileValue& quantile_values(int index) const;
  ::unhinged::observability::v1::QuantileValue* add_quantile_values();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::QuantileValue >&
      quantile_values() const;

  // .google.protobuf.Timestamp start_time = 2;
  bool has_start_time() const;
  private:
  bool _internal_has_start_time() const;
  public:
  void clear_start_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& start_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_start_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_start_time();
  void set_allocated_start_time(::PROTOBUF_NAMESPACE_ID::Timestamp* start_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_start_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_start_time();
  public:
  void unsafe_arena_set_allocated_start_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_start_time();

  // .google.protobuf.Timestamp time = 3;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_time();
  void set_allocated_time(::PROTOBUF_NAMESPACE_ID::Timestamp* time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_time();
  public:
  void unsafe_arena_set_allocated_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_time();

  // uint64 count = 10;
  void clear_count();
  uint64_t count() const;
  void set_count(uint64_t value);
  private:
  uint64_t _internal_count() const;
  void _internal_set_count(uint64_t value);
  public:

  // double sum = 11;
  void clear_sum();
  double sum() const;
  void set_sum(double value);
  private:
  double _internal_sum() const;
  void _internal_set_sum(double value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.observability.v1.SummaryDataPoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        SummaryDataPoint_AttributesEntry_DoNotUse,
        std::string, ::unhinged::observability::v1::AttributeValue,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> attributes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::QuantileValue > quantile_values_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* time_;
    uint64_t count_;
    double sum_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_observability_2eproto;
};
// -------------------------------------------------------------------

class QuantileValue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.observability.v1.QuantileValue) */ {
 public:
  inline QuantileValue() : QuantileValue(nullptr) {}
  ~QuantileValue() override;
  explicit PROTOBUF_CONSTEXPR QuantileValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QuantileValue(const QuantileValue& from);
  QuantileValue(QuantileValue&& from) noexcept
    : QuantileValue() {
    *this = ::std::move(from);
  }

  inline QuantileValue& operator=(const QuantileValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuantileValue& operator=(QuantileValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuantileValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const QuantileValue* internal_default_instance() {
    return reinterpret_cast<const QuantileValue*>(
               &_QuantileValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(QuantileValue& a, QuantileValue& b) {
    a.Swap(&b);
  }
  inline void Swap(QuantileValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuantileValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QuantileValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QuantileValue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QuantileValue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QuantileValue& from) {
    QuantileValue::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QuantileValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.observability.v1.QuantileValue";
  }
  protected:
  explicit QuantileValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQuantileFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // double quantile = 1;
  void clear_quantile();
  double quantile() const;
  void set_quantile(double value);
  private:
  double _internal_quantile() const;
  void _internal_set_quantile(double value);
  public:

  // double value = 2;
  void clear_value();
  double value() const;
  void set_value(double value);
  private:
  double _internal_value() const;
  void _internal_set_value(double value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.observability.v1.QuantileValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double quantile_;
    double value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_observability_2eproto;
};
// -------------------------------------------------------------------

class Exemplar_FilteredAttributesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Exemplar_FilteredAttributesEntry_DoNotUse, 
    std::string, ::unhinged::observability::v1::AttributeValue,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Exemplar_FilteredAttributesEntry_DoNotUse, 
    std::string, ::unhinged::observability::v1::AttributeValue,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Exemplar_FilteredAttributesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Exemplar_FilteredAttributesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Exemplar_FilteredAttributesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Exemplar_FilteredAttributesEntry_DoNotUse& other);
  static const Exemplar_FilteredAttributesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Exemplar_FilteredAttributesEntry_DoNotUse*>(&_Exemplar_FilteredAttributesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "unhinged.observability.v1.Exemplar.FilteredAttributesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_observability_2eproto;
};

// -------------------------------------------------------------------

class Exemplar final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.observability.v1.Exemplar) */ {
 public:
  inline Exemplar() : Exemplar(nullptr) {}
  ~Exemplar() override;
  explicit PROTOBUF_CONSTEXPR Exemplar(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Exemplar(const Exemplar& from);
  Exemplar(Exemplar&& from) noexcept
    : Exemplar() {
    *this = ::std::move(from);
  }

  inline Exemplar& operator=(const Exemplar& from) {
    CopyFrom(from);
    return *this;
  }
  inline Exemplar& operator=(Exemplar&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Exemplar& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kAsDouble = 10,
    kAsInt = 11,
    VALUE_NOT_SET = 0,
  };

  static inline const Exemplar* internal_default_instance() {
    return reinterpret_cast<const Exemplar*>(
               &_Exemplar_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(Exemplar& a, Exemplar& b) {
    a.Swap(&b);
  }
  inline void Swap(Exemplar* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Exemplar* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Exemplar* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Exemplar>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Exemplar& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Exemplar& from) {
    Exemplar::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Exemplar* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.observability.v1.Exemplar";
  }
  protected:
  explicit Exemplar(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kFilteredAttributesFieldNumber = 1,
    kSpanIdFieldNumber = 20,
    kTraceIdFieldNumber = 21,
    kTimestampFieldNumber = 2,
    kAsDoubleFieldNumber = 10,
    kAsIntFieldNumber = 11,
  };
  // map<string, .unhinged.observability.v1.AttributeValue> filtered_attributes = 1;
  int filtered_attributes_size() const;
  private:
  int _internal_filtered_attributes_size() const;
  public:
  void clear_filtered_attributes();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::unhinged::observability::v1::AttributeValue >&
      _internal_filtered_attributes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::unhinged::observability::v1::AttributeValue >*
      _internal_mutable_filtered_attributes();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::unhinged::observability::v1::AttributeValue >&
      filtered_attributes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::unhinged::observability::v1::AttributeValue >*
      mutable_filtered_attributes();

  // string span_id = 20;
  void clear_span_id();
  const std::string& span_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_span_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_span_id();
  PROTOBUF_NODISCARD std::string* release_span_id();
  void set_allocated_span_id(std::string* span_id);
  private:
  const std::string& _internal_span_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_span_id(const std::string& value);
  std::string* _internal_mutable_span_id();
  public:

  // string trace_id = 21;
  void clear_trace_id();
  const std::string& trace_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_trace_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_trace_id();
  PROTOBUF_NODISCARD std::string* release_trace_id();
  void set_allocated_trace_id(std::string* trace_id);
  private:
  const std::string& _internal_trace_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trace_id(const std::string& value);
  std::string* _internal_mutable_trace_id();
  public:

  // .google.protobuf.Timestamp timestamp = 2;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // double as_double = 10;
  bool has_as_double() const;
  private:
  bool _internal_has_as_double() const;
  public:
  void clear_as_double();
  double as_double() const;
  void set_as_double(double value);
  private:
  double _internal_as_double() const;
  void _internal_set_as_double(double value);
  public:

  // int64 as_int = 11;
  bool has_as_int() const;
  private:
  bool _internal_has_as_int() const;
  public:
  void clear_as_int();
  int64_t as_int() const;
  void set_as_int(int64_t value);
  private:
  int64_t _internal_as_int() const;
  void _internal_set_as_int(int64_t value);
  public:

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:unhinged.observability.v1.Exemplar)
 private:
  class _Internal;
  void set_has_as_double();
  void set_has_as_int();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Exemplar_FilteredAttributesEntry_DoNotUse,
        std::string, ::unhinged::observability::v1::AttributeValue,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> filtered_attributes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr span_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trace_id_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      double as_double_;
      int64_t as_int_;
    } value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_observability_2eproto;
};
// -------------------------------------------------------------------

class ServiceHealthEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.observability.v1.ServiceHealthEvent) */ {
 public:
  inline ServiceHealthEvent() : ServiceHealthEvent(nullptr) {}
  ~ServiceHealthEvent() override;
  explicit PROTOBUF_CONSTEXPR ServiceHealthEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServiceHealthEvent(const ServiceHealthEvent& from);
  ServiceHealthEvent(ServiceHealthEvent&& from) noexcept
    : ServiceHealthEvent() {
    *this = ::std::move(from);
  }

  inline ServiceHealthEvent& operator=(const ServiceHealthEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServiceHealthEvent& operator=(ServiceHealthEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServiceHealthEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServiceHealthEvent* internal_default_instance() {
    return reinterpret_cast<const ServiceHealthEvent*>(
               &_ServiceHealthEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(ServiceHealthEvent& a, ServiceHealthEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(ServiceHealthEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServiceHealthEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServiceHealthEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServiceHealthEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServiceHealthEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ServiceHealthEvent& from) {
    ServiceHealthEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServiceHealthEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.observability.v1.ServiceHealthEvent";
  }
  protected:
  explicit ServiceHealthEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventIdFieldNumber = 1,
    kEventTypeFieldNumber = 3,
    kTimestampFieldNumber = 2,
    kResourceFieldNumber = 5,
    kHealthFieldNumber = 10,
    kDestinationsFieldNumber = 20,
    kPartitionInfoFieldNumber = 25,
    kSequenceNumberFieldNumber = 4,
  };
  // string event_id = 1;
  void clear_event_id();
  const std::string& event_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_event_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_event_id();
  PROTOBUF_NODISCARD std::string* release_event_id();
  void set_allocated_event_id(std::string* event_id);
  private:
  const std::string& _internal_event_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_event_id(const std::string& value);
  std::string* _internal_mutable_event_id();
  public:

  // string event_type = 3;
  void clear_event_type();
  const std::string& event_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_event_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_event_type();
  PROTOBUF_NODISCARD std::string* release_event_type();
  void set_allocated_event_type(std::string* event_type);
  private:
  const std::string& _internal_event_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_event_type(const std::string& value);
  std::string* _internal_mutable_event_type();
  public:

  // .google.protobuf.Timestamp timestamp = 2;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // .unhinged.observability.v1.Resource resource = 5;
  bool has_resource() const;
  private:
  bool _internal_has_resource() const;
  public:
  void clear_resource();
  const ::unhinged::observability::v1::Resource& resource() const;
  PROTOBUF_NODISCARD ::unhinged::observability::v1::Resource* release_resource();
  ::unhinged::observability::v1::Resource* mutable_resource();
  void set_allocated_resource(::unhinged::observability::v1::Resource* resource);
  private:
  const ::unhinged::observability::v1::Resource& _internal_resource() const;
  ::unhinged::observability::v1::Resource* _internal_mutable_resource();
  public:
  void unsafe_arena_set_allocated_resource(
      ::unhinged::observability::v1::Resource* resource);
  ::unhinged::observability::v1::Resource* unsafe_arena_release_resource();

  // .unhinged.observability.v1.ServiceHealth health = 10;
  bool has_health() const;
  private:
  bool _internal_has_health() const;
  public:
  void clear_health();
  const ::unhinged::observability::v1::ServiceHealth& health() const;
  PROTOBUF_NODISCARD ::unhinged::observability::v1::ServiceHealth* release_health();
  ::unhinged::observability::v1::ServiceHealth* mutable_health();
  void set_allocated_health(::unhinged::observability::v1::ServiceHealth* health);
  private:
  const ::unhinged::observability::v1::ServiceHealth& _internal_health() const;
  ::unhinged::observability::v1::ServiceHealth* _internal_mutable_health();
  public:
  void unsafe_arena_set_allocated_health(
      ::unhinged::observability::v1::ServiceHealth* health);
  ::unhinged::observability::v1::ServiceHealth* unsafe_arena_release_health();

  // .unhinged.observability.v1.DestinationFlags destinations = 20;
  bool has_destinations() const;
  private:
  bool _internal_has_destinations() const;
  public:
  void clear_destinations();
  const ::unhinged::observability::v1::DestinationFlags& destinations() const;
  PROTOBUF_NODISCARD ::unhinged::observability::v1::DestinationFlags* release_destinations();
  ::unhinged::observability::v1::DestinationFlags* mutable_destinations();
  void set_allocated_destinations(::unhinged::observability::v1::DestinationFlags* destinations);
  private:
  const ::unhinged::observability::v1::DestinationFlags& _internal_destinations() const;
  ::unhinged::observability::v1::DestinationFlags* _internal_mutable_destinations();
  public:
  void unsafe_arena_set_allocated_destinations(
      ::unhinged::observability::v1::DestinationFlags* destinations);
  ::unhinged::observability::v1::DestinationFlags* unsafe_arena_release_destinations();

  // .unhinged.observability.v1.PartitionInfo partition_info = 25;
  bool has_partition_info() const;
  private:
  bool _internal_has_partition_info() const;
  public:
  void clear_partition_info();
  const ::unhinged::observability::v1::PartitionInfo& partition_info() const;
  PROTOBUF_NODISCARD ::unhinged::observability::v1::PartitionInfo* release_partition_info();
  ::unhinged::observability::v1::PartitionInfo* mutable_partition_info();
  void set_allocated_partition_info(::unhinged::observability::v1::PartitionInfo* partition_info);
  private:
  const ::unhinged::observability::v1::PartitionInfo& _internal_partition_info() const;
  ::unhinged::observability::v1::PartitionInfo* _internal_mutable_partition_info();
  public:
  void unsafe_arena_set_allocated_partition_info(
      ::unhinged::observability::v1::PartitionInfo* partition_info);
  ::unhinged::observability::v1::PartitionInfo* unsafe_arena_release_partition_info();

  // int64 sequence_number = 4;
  void clear_sequence_number();
  int64_t sequence_number() const;
  void set_sequence_number(int64_t value);
  private:
  int64_t _internal_sequence_number() const;
  void _internal_set_sequence_number(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.observability.v1.ServiceHealthEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr event_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr event_type_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
    ::unhinged::observability::v1::Resource* resource_;
    ::unhinged::observability::v1::ServiceHealth* health_;
    ::unhinged::observability::v1::DestinationFlags* destinations_;
    ::unhinged::observability::v1::PartitionInfo* partition_info_;
    int64_t sequence_number_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_observability_2eproto;
};
// -------------------------------------------------------------------

class ServiceHealth final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.observability.v1.ServiceHealth) */ {
 public:
  inline ServiceHealth() : ServiceHealth(nullptr) {}
  ~ServiceHealth() override;
  explicit PROTOBUF_CONSTEXPR ServiceHealth(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServiceHealth(const ServiceHealth& from);
  ServiceHealth(ServiceHealth&& from) noexcept
    : ServiceHealth() {
    *this = ::std::move(from);
  }

  inline ServiceHealth& operator=(const ServiceHealth& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServiceHealth& operator=(ServiceHealth&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServiceHealth& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServiceHealth* internal_default_instance() {
    return reinterpret_cast<const ServiceHealth*>(
               &_ServiceHealth_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(ServiceHealth& a, ServiceHealth& b) {
    a.Swap(&b);
  }
  inline void Swap(ServiceHealth* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServiceHealth* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServiceHealth* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServiceHealth>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServiceHealth& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ServiceHealth& from) {
    ServiceHealth::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServiceHealth* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.observability.v1.ServiceHealth";
  }
  protected:
  explicit ServiceHealth(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHealthChecksFieldNumber = 10,
    kDependenciesFieldNumber = 15,
    kServiceNameFieldNumber = 1,
    kStatusMessageFieldNumber = 3,
    kSlisFieldNumber = 20,
    kSystemMetricsFieldNumber = 25,
    kUptimeFieldNumber = 30,
    kStatusFieldNumber = 2,
  };
  // repeated .unhinged.observability.v1.HealthCheck health_checks = 10;
  int health_checks_size() const;
  private:
  int _internal_health_checks_size() const;
  public:
  void clear_health_checks();
  ::unhinged::observability::v1::HealthCheck* mutable_health_checks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::HealthCheck >*
      mutable_health_checks();
  private:
  const ::unhinged::observability::v1::HealthCheck& _internal_health_checks(int index) const;
  ::unhinged::observability::v1::HealthCheck* _internal_add_health_checks();
  public:
  const ::unhinged::observability::v1::HealthCheck& health_checks(int index) const;
  ::unhinged::observability::v1::HealthCheck* add_health_checks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::HealthCheck >&
      health_checks() const;

  // repeated .unhinged.observability.v1.DependencyHealth dependencies = 15;
  int dependencies_size() const;
  private:
  int _internal_dependencies_size() const;
  public:
  void clear_dependencies();
  ::unhinged::observability::v1::DependencyHealth* mutable_dependencies(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::DependencyHealth >*
      mutable_dependencies();
  private:
  const ::unhinged::observability::v1::DependencyHealth& _internal_dependencies(int index) const;
  ::unhinged::observability::v1::DependencyHealth* _internal_add_dependencies();
  public:
  const ::unhinged::observability::v1::DependencyHealth& dependencies(int index) const;
  ::unhinged::observability::v1::DependencyHealth* add_dependencies();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::DependencyHealth >&
      dependencies() const;

  // string service_name = 1;
  void clear_service_name();
  const std::string& service_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // string status_message = 3;
  void clear_status_message();
  const std::string& status_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status_message();
  PROTOBUF_NODISCARD std::string* release_status_message();
  void set_allocated_status_message(std::string* status_message);
  private:
  const std::string& _internal_status_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status_message(const std::string& value);
  std::string* _internal_mutable_status_message();
  public:

  // .unhinged.observability.v1.ServiceLevelIndicators slis = 20;
  bool has_slis() const;
  private:
  bool _internal_has_slis() const;
  public:
  void clear_slis();
  const ::unhinged::observability::v1::ServiceLevelIndicators& slis() const;
  PROTOBUF_NODISCARD ::unhinged::observability::v1::ServiceLevelIndicators* release_slis();
  ::unhinged::observability::v1::ServiceLevelIndicators* mutable_slis();
  void set_allocated_slis(::unhinged::observability::v1::ServiceLevelIndicators* slis);
  private:
  const ::unhinged::observability::v1::ServiceLevelIndicators& _internal_slis() const;
  ::unhinged::observability::v1::ServiceLevelIndicators* _internal_mutable_slis();
  public:
  void unsafe_arena_set_allocated_slis(
      ::unhinged::observability::v1::ServiceLevelIndicators* slis);
  ::unhinged::observability::v1::ServiceLevelIndicators* unsafe_arena_release_slis();

  // .unhinged.observability.v1.SystemMetrics system_metrics = 25;
  bool has_system_metrics() const;
  private:
  bool _internal_has_system_metrics() const;
  public:
  void clear_system_metrics();
  const ::unhinged::observability::v1::SystemMetrics& system_metrics() const;
  PROTOBUF_NODISCARD ::unhinged::observability::v1::SystemMetrics* release_system_metrics();
  ::unhinged::observability::v1::SystemMetrics* mutable_system_metrics();
  void set_allocated_system_metrics(::unhinged::observability::v1::SystemMetrics* system_metrics);
  private:
  const ::unhinged::observability::v1::SystemMetrics& _internal_system_metrics() const;
  ::unhinged::observability::v1::SystemMetrics* _internal_mutable_system_metrics();
  public:
  void unsafe_arena_set_allocated_system_metrics(
      ::unhinged::observability::v1::SystemMetrics* system_metrics);
  ::unhinged::observability::v1::SystemMetrics* unsafe_arena_release_system_metrics();

  // .unhinged.observability.v1.UptimeInfo uptime = 30;
  bool has_uptime() const;
  private:
  bool _internal_has_uptime() const;
  public:
  void clear_uptime();
  const ::unhinged::observability::v1::UptimeInfo& uptime() const;
  PROTOBUF_NODISCARD ::unhinged::observability::v1::UptimeInfo* release_uptime();
  ::unhinged::observability::v1::UptimeInfo* mutable_uptime();
  void set_allocated_uptime(::unhinged::observability::v1::UptimeInfo* uptime);
  private:
  const ::unhinged::observability::v1::UptimeInfo& _internal_uptime() const;
  ::unhinged::observability::v1::UptimeInfo* _internal_mutable_uptime();
  public:
  void unsafe_arena_set_allocated_uptime(
      ::unhinged::observability::v1::UptimeInfo* uptime);
  ::unhinged::observability::v1::UptimeInfo* unsafe_arena_release_uptime();

  // .unhinged.observability.v1.HealthStatus status = 2;
  void clear_status();
  ::unhinged::observability::v1::HealthStatus status() const;
  void set_status(::unhinged::observability::v1::HealthStatus value);
  private:
  ::unhinged::observability::v1::HealthStatus _internal_status() const;
  void _internal_set_status(::unhinged::observability::v1::HealthStatus value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.observability.v1.ServiceHealth)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::HealthCheck > health_checks_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::DependencyHealth > dependencies_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_message_;
    ::unhinged::observability::v1::ServiceLevelIndicators* slis_;
    ::unhinged::observability::v1::SystemMetrics* system_metrics_;
    ::unhinged::observability::v1::UptimeInfo* uptime_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_observability_2eproto;
};
// -------------------------------------------------------------------

class HealthCheck_MetadataEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<HealthCheck_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<HealthCheck_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  HealthCheck_MetadataEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR HealthCheck_MetadataEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit HealthCheck_MetadataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const HealthCheck_MetadataEntry_DoNotUse& other);
  static const HealthCheck_MetadataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const HealthCheck_MetadataEntry_DoNotUse*>(&_HealthCheck_MetadataEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "unhinged.observability.v1.HealthCheck.MetadataEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "unhinged.observability.v1.HealthCheck.MetadataEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_observability_2eproto;
};

// -------------------------------------------------------------------

class HealthCheck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.observability.v1.HealthCheck) */ {
 public:
  inline HealthCheck() : HealthCheck(nullptr) {}
  ~HealthCheck() override;
  explicit PROTOBUF_CONSTEXPR HealthCheck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HealthCheck(const HealthCheck& from);
  HealthCheck(HealthCheck&& from) noexcept
    : HealthCheck() {
    *this = ::std::move(from);
  }

  inline HealthCheck& operator=(const HealthCheck& from) {
    CopyFrom(from);
    return *this;
  }
  inline HealthCheck& operator=(HealthCheck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HealthCheck& default_instance() {
    return *internal_default_instance();
  }
  static inline const HealthCheck* internal_default_instance() {
    return reinterpret_cast<const HealthCheck*>(
               &_HealthCheck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(HealthCheck& a, HealthCheck& b) {
    a.Swap(&b);
  }
  inline void Swap(HealthCheck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HealthCheck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HealthCheck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HealthCheck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HealthCheck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HealthCheck& from) {
    HealthCheck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HealthCheck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.observability.v1.HealthCheck";
  }
  protected:
  explicit HealthCheck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 10,
    kNameFieldNumber = 1,
    kMessageFieldNumber = 3,
    kLastCheckFieldNumber = 4,
    kResponseTimeMsFieldNumber = 5,
    kStatusFieldNumber = 2,
  };
  // map<string, string> metadata = 10;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;
  public:
  void clear_metadata();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_metadata();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_metadata();

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .google.protobuf.Timestamp last_check = 4;
  bool has_last_check() const;
  private:
  bool _internal_has_last_check() const;
  public:
  void clear_last_check();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& last_check() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_last_check();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_last_check();
  void set_allocated_last_check(::PROTOBUF_NAMESPACE_ID::Timestamp* last_check);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_last_check() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_last_check();
  public:
  void unsafe_arena_set_allocated_last_check(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* last_check);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_last_check();

  // int64 response_time_ms = 5;
  void clear_response_time_ms();
  int64_t response_time_ms() const;
  void set_response_time_ms(int64_t value);
  private:
  int64_t _internal_response_time_ms() const;
  void _internal_set_response_time_ms(int64_t value);
  public:

  // .unhinged.observability.v1.HealthStatus status = 2;
  void clear_status();
  ::unhinged::observability::v1::HealthStatus status() const;
  void set_status(::unhinged::observability::v1::HealthStatus value);
  private:
  ::unhinged::observability::v1::HealthStatus _internal_status() const;
  void _internal_set_status(::unhinged::observability::v1::HealthStatus value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.observability.v1.HealthCheck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        HealthCheck_MetadataEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> metadata_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_check_;
    int64_t response_time_ms_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_observability_2eproto;
};
// -------------------------------------------------------------------

class DependencyHealth final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.observability.v1.DependencyHealth) */ {
 public:
  inline DependencyHealth() : DependencyHealth(nullptr) {}
  ~DependencyHealth() override;
  explicit PROTOBUF_CONSTEXPR DependencyHealth(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DependencyHealth(const DependencyHealth& from);
  DependencyHealth(DependencyHealth&& from) noexcept
    : DependencyHealth() {
    *this = ::std::move(from);
  }

  inline DependencyHealth& operator=(const DependencyHealth& from) {
    CopyFrom(from);
    return *this;
  }
  inline DependencyHealth& operator=(DependencyHealth&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DependencyHealth& default_instance() {
    return *internal_default_instance();
  }
  static inline const DependencyHealth* internal_default_instance() {
    return reinterpret_cast<const DependencyHealth*>(
               &_DependencyHealth_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(DependencyHealth& a, DependencyHealth& b) {
    a.Swap(&b);
  }
  inline void Swap(DependencyHealth* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DependencyHealth* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DependencyHealth* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DependencyHealth>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DependencyHealth& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DependencyHealth& from) {
    DependencyHealth::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DependencyHealth* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.observability.v1.DependencyHealth";
  }
  protected:
  explicit DependencyHealth(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kTypeFieldNumber = 2,
    kEndpointFieldNumber = 4,
    kVersionFieldNumber = 6,
    kLastCheckFieldNumber = 10,
    kResponseTimeMsFieldNumber = 5,
    kStatusFieldNumber = 3,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string type = 2;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // string endpoint = 4;
  void clear_endpoint();
  const std::string& endpoint() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_endpoint(ArgT0&& arg0, ArgT... args);
  std::string* mutable_endpoint();
  PROTOBUF_NODISCARD std::string* release_endpoint();
  void set_allocated_endpoint(std::string* endpoint);
  private:
  const std::string& _internal_endpoint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_endpoint(const std::string& value);
  std::string* _internal_mutable_endpoint();
  public:

  // string version = 6;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // .google.protobuf.Timestamp last_check = 10;
  bool has_last_check() const;
  private:
  bool _internal_has_last_check() const;
  public:
  void clear_last_check();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& last_check() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_last_check();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_last_check();
  void set_allocated_last_check(::PROTOBUF_NAMESPACE_ID::Timestamp* last_check);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_last_check() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_last_check();
  public:
  void unsafe_arena_set_allocated_last_check(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* last_check);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_last_check();

  // int64 response_time_ms = 5;
  void clear_response_time_ms();
  int64_t response_time_ms() const;
  void set_response_time_ms(int64_t value);
  private:
  int64_t _internal_response_time_ms() const;
  void _internal_set_response_time_ms(int64_t value);
  public:

  // .unhinged.observability.v1.HealthStatus status = 3;
  void clear_status();
  ::unhinged::observability::v1::HealthStatus status() const;
  void set_status(::unhinged::observability::v1::HealthStatus value);
  private:
  ::unhinged::observability::v1::HealthStatus _internal_status() const;
  void _internal_set_status(::unhinged::observability::v1::HealthStatus value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.observability.v1.DependencyHealth)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr endpoint_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_check_;
    int64_t response_time_ms_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_observability_2eproto;
};
// -------------------------------------------------------------------

class ServiceLevelIndicators final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.observability.v1.ServiceLevelIndicators) */ {
 public:
  inline ServiceLevelIndicators() : ServiceLevelIndicators(nullptr) {}
  ~ServiceLevelIndicators() override;
  explicit PROTOBUF_CONSTEXPR ServiceLevelIndicators(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServiceLevelIndicators(const ServiceLevelIndicators& from);
  ServiceLevelIndicators(ServiceLevelIndicators&& from) noexcept
    : ServiceLevelIndicators() {
    *this = ::std::move(from);
  }

  inline ServiceLevelIndicators& operator=(const ServiceLevelIndicators& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServiceLevelIndicators& operator=(ServiceLevelIndicators&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServiceLevelIndicators& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServiceLevelIndicators* internal_default_instance() {
    return reinterpret_cast<const ServiceLevelIndicators*>(
               &_ServiceLevelIndicators_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(ServiceLevelIndicators& a, ServiceLevelIndicators& b) {
    a.Swap(&b);
  }
  inline void Swap(ServiceLevelIndicators* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServiceLevelIndicators* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServiceLevelIndicators* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServiceLevelIndicators>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServiceLevelIndicators& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ServiceLevelIndicators& from) {
    ServiceLevelIndicators::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServiceLevelIndicators* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.observability.v1.ServiceLevelIndicators";
  }
  protected:
  explicit ServiceLevelIndicators(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWindowStartFieldNumber = 10,
    kWindowEndFieldNumber = 11,
    kAvailabilityPercentFieldNumber = 1,
    kErrorRatePercentFieldNumber = 2,
    kLatencyP50MsFieldNumber = 3,
    kLatencyP95MsFieldNumber = 4,
    kLatencyP99MsFieldNumber = 5,
    kThroughputRpsFieldNumber = 6,
  };
  // .google.protobuf.Timestamp window_start = 10;
  bool has_window_start() const;
  private:
  bool _internal_has_window_start() const;
  public:
  void clear_window_start();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& window_start() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_window_start();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_window_start();
  void set_allocated_window_start(::PROTOBUF_NAMESPACE_ID::Timestamp* window_start);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_window_start() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_window_start();
  public:
  void unsafe_arena_set_allocated_window_start(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* window_start);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_window_start();

  // .google.protobuf.Timestamp window_end = 11;
  bool has_window_end() const;
  private:
  bool _internal_has_window_end() const;
  public:
  void clear_window_end();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& window_end() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_window_end();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_window_end();
  void set_allocated_window_end(::PROTOBUF_NAMESPACE_ID::Timestamp* window_end);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_window_end() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_window_end();
  public:
  void unsafe_arena_set_allocated_window_end(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* window_end);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_window_end();

  // double availability_percent = 1;
  void clear_availability_percent();
  double availability_percent() const;
  void set_availability_percent(double value);
  private:
  double _internal_availability_percent() const;
  void _internal_set_availability_percent(double value);
  public:

  // double error_rate_percent = 2;
  void clear_error_rate_percent();
  double error_rate_percent() const;
  void set_error_rate_percent(double value);
  private:
  double _internal_error_rate_percent() const;
  void _internal_set_error_rate_percent(double value);
  public:

  // double latency_p50_ms = 3;
  void clear_latency_p50_ms();
  double latency_p50_ms() const;
  void set_latency_p50_ms(double value);
  private:
  double _internal_latency_p50_ms() const;
  void _internal_set_latency_p50_ms(double value);
  public:

  // double latency_p95_ms = 4;
  void clear_latency_p95_ms();
  double latency_p95_ms() const;
  void set_latency_p95_ms(double value);
  private:
  double _internal_latency_p95_ms() const;
  void _internal_set_latency_p95_ms(double value);
  public:

  // double latency_p99_ms = 5;
  void clear_latency_p99_ms();
  double latency_p99_ms() const;
  void set_latency_p99_ms(double value);
  private:
  double _internal_latency_p99_ms() const;
  void _internal_set_latency_p99_ms(double value);
  public:

  // double throughput_rps = 6;
  void clear_throughput_rps();
  double throughput_rps() const;
  void set_throughput_rps(double value);
  private:
  double _internal_throughput_rps() const;
  void _internal_set_throughput_rps(double value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.observability.v1.ServiceLevelIndicators)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::Timestamp* window_start_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* window_end_;
    double availability_percent_;
    double error_rate_percent_;
    double latency_p50_ms_;
    double latency_p95_ms_;
    double latency_p99_ms_;
    double throughput_rps_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_observability_2eproto;
};
// -------------------------------------------------------------------

class SystemMetrics final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.observability.v1.SystemMetrics) */ {
 public:
  inline SystemMetrics() : SystemMetrics(nullptr) {}
  ~SystemMetrics() override;
  explicit PROTOBUF_CONSTEXPR SystemMetrics(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SystemMetrics(const SystemMetrics& from);
  SystemMetrics(SystemMetrics&& from) noexcept
    : SystemMetrics() {
    *this = ::std::move(from);
  }

  inline SystemMetrics& operator=(const SystemMetrics& from) {
    CopyFrom(from);
    return *this;
  }
  inline SystemMetrics& operator=(SystemMetrics&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SystemMetrics& default_instance() {
    return *internal_default_instance();
  }
  static inline const SystemMetrics* internal_default_instance() {
    return reinterpret_cast<const SystemMetrics*>(
               &_SystemMetrics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(SystemMetrics& a, SystemMetrics& b) {
    a.Swap(&b);
  }
  inline void Swap(SystemMetrics* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SystemMetrics* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SystemMetrics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SystemMetrics>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SystemMetrics& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SystemMetrics& from) {
    SystemMetrics::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SystemMetrics* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.observability.v1.SystemMetrics";
  }
  protected:
  explicit SystemMetrics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCpuUsagePercentFieldNumber = 1,
    kCpuLoad1MFieldNumber = 2,
    kCpuLoad5MFieldNumber = 3,
    kCpuLoad15MFieldNumber = 4,
    kMemoryTotalBytesFieldNumber = 10,
    kMemoryUsedBytesFieldNumber = 11,
    kMemoryAvailableBytesFieldNumber = 12,
    kMemoryUsagePercentFieldNumber = 13,
    kDiskTotalBytesFieldNumber = 20,
    kDiskUsedBytesFieldNumber = 21,
    kDiskAvailableBytesFieldNumber = 22,
    kDiskUsagePercentFieldNumber = 23,
    kNetworkBytesSentFieldNumber = 30,
    kNetworkBytesReceivedFieldNumber = 31,
    kNetworkPacketsSentFieldNumber = 32,
    kNetworkPacketsReceivedFieldNumber = 33,
    kProcessCountFieldNumber = 40,
    kThreadCountFieldNumber = 41,
    kFileDescriptorCountFieldNumber = 42,
  };
  // double cpu_usage_percent = 1;
  void clear_cpu_usage_percent();
  double cpu_usage_percent() const;
  void set_cpu_usage_percent(double value);
  private:
  double _internal_cpu_usage_percent() const;
  void _internal_set_cpu_usage_percent(double value);
  public:

  // double cpu_load_1m = 2;
  void clear_cpu_load_1m();
  double cpu_load_1m() const;
  void set_cpu_load_1m(double value);
  private:
  double _internal_cpu_load_1m() const;
  void _internal_set_cpu_load_1m(double value);
  public:

  // double cpu_load_5m = 3;
  void clear_cpu_load_5m();
  double cpu_load_5m() const;
  void set_cpu_load_5m(double value);
  private:
  double _internal_cpu_load_5m() const;
  void _internal_set_cpu_load_5m(double value);
  public:

  // double cpu_load_15m = 4;
  void clear_cpu_load_15m();
  double cpu_load_15m() const;
  void set_cpu_load_15m(double value);
  private:
  double _internal_cpu_load_15m() const;
  void _internal_set_cpu_load_15m(double value);
  public:

  // uint64 memory_total_bytes = 10;
  void clear_memory_total_bytes();
  uint64_t memory_total_bytes() const;
  void set_memory_total_bytes(uint64_t value);
  private:
  uint64_t _internal_memory_total_bytes() const;
  void _internal_set_memory_total_bytes(uint64_t value);
  public:

  // uint64 memory_used_bytes = 11;
  void clear_memory_used_bytes();
  uint64_t memory_used_bytes() const;
  void set_memory_used_bytes(uint64_t value);
  private:
  uint64_t _internal_memory_used_bytes() const;
  void _internal_set_memory_used_bytes(uint64_t value);
  public:

  // uint64 memory_available_bytes = 12;
  void clear_memory_available_bytes();
  uint64_t memory_available_bytes() const;
  void set_memory_available_bytes(uint64_t value);
  private:
  uint64_t _internal_memory_available_bytes() const;
  void _internal_set_memory_available_bytes(uint64_t value);
  public:

  // double memory_usage_percent = 13;
  void clear_memory_usage_percent();
  double memory_usage_percent() const;
  void set_memory_usage_percent(double value);
  private:
  double _internal_memory_usage_percent() const;
  void _internal_set_memory_usage_percent(double value);
  public:

  // uint64 disk_total_bytes = 20;
  void clear_disk_total_bytes();
  uint64_t disk_total_bytes() const;
  void set_disk_total_bytes(uint64_t value);
  private:
  uint64_t _internal_disk_total_bytes() const;
  void _internal_set_disk_total_bytes(uint64_t value);
  public:

  // uint64 disk_used_bytes = 21;
  void clear_disk_used_bytes();
  uint64_t disk_used_bytes() const;
  void set_disk_used_bytes(uint64_t value);
  private:
  uint64_t _internal_disk_used_bytes() const;
  void _internal_set_disk_used_bytes(uint64_t value);
  public:

  // uint64 disk_available_bytes = 22;
  void clear_disk_available_bytes();
  uint64_t disk_available_bytes() const;
  void set_disk_available_bytes(uint64_t value);
  private:
  uint64_t _internal_disk_available_bytes() const;
  void _internal_set_disk_available_bytes(uint64_t value);
  public:

  // double disk_usage_percent = 23;
  void clear_disk_usage_percent();
  double disk_usage_percent() const;
  void set_disk_usage_percent(double value);
  private:
  double _internal_disk_usage_percent() const;
  void _internal_set_disk_usage_percent(double value);
  public:

  // uint64 network_bytes_sent = 30;
  void clear_network_bytes_sent();
  uint64_t network_bytes_sent() const;
  void set_network_bytes_sent(uint64_t value);
  private:
  uint64_t _internal_network_bytes_sent() const;
  void _internal_set_network_bytes_sent(uint64_t value);
  public:

  // uint64 network_bytes_received = 31;
  void clear_network_bytes_received();
  uint64_t network_bytes_received() const;
  void set_network_bytes_received(uint64_t value);
  private:
  uint64_t _internal_network_bytes_received() const;
  void _internal_set_network_bytes_received(uint64_t value);
  public:

  // uint64 network_packets_sent = 32;
  void clear_network_packets_sent();
  uint64_t network_packets_sent() const;
  void set_network_packets_sent(uint64_t value);
  private:
  uint64_t _internal_network_packets_sent() const;
  void _internal_set_network_packets_sent(uint64_t value);
  public:

  // uint64 network_packets_received = 33;
  void clear_network_packets_received();
  uint64_t network_packets_received() const;
  void set_network_packets_received(uint64_t value);
  private:
  uint64_t _internal_network_packets_received() const;
  void _internal_set_network_packets_received(uint64_t value);
  public:

  // uint32 process_count = 40;
  void clear_process_count();
  uint32_t process_count() const;
  void set_process_count(uint32_t value);
  private:
  uint32_t _internal_process_count() const;
  void _internal_set_process_count(uint32_t value);
  public:

  // uint32 thread_count = 41;
  void clear_thread_count();
  uint32_t thread_count() const;
  void set_thread_count(uint32_t value);
  private:
  uint32_t _internal_thread_count() const;
  void _internal_set_thread_count(uint32_t value);
  public:

  // uint32 file_descriptor_count = 42;
  void clear_file_descriptor_count();
  uint32_t file_descriptor_count() const;
  void set_file_descriptor_count(uint32_t value);
  private:
  uint32_t _internal_file_descriptor_count() const;
  void _internal_set_file_descriptor_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.observability.v1.SystemMetrics)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double cpu_usage_percent_;
    double cpu_load_1m_;
    double cpu_load_5m_;
    double cpu_load_15m_;
    uint64_t memory_total_bytes_;
    uint64_t memory_used_bytes_;
    uint64_t memory_available_bytes_;
    double memory_usage_percent_;
    uint64_t disk_total_bytes_;
    uint64_t disk_used_bytes_;
    uint64_t disk_available_bytes_;
    double disk_usage_percent_;
    uint64_t network_bytes_sent_;
    uint64_t network_bytes_received_;
    uint64_t network_packets_sent_;
    uint64_t network_packets_received_;
    uint32_t process_count_;
    uint32_t thread_count_;
    uint32_t file_descriptor_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_observability_2eproto;
};
// -------------------------------------------------------------------

class UptimeInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.observability.v1.UptimeInfo) */ {
 public:
  inline UptimeInfo() : UptimeInfo(nullptr) {}
  ~UptimeInfo() override;
  explicit PROTOBUF_CONSTEXPR UptimeInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UptimeInfo(const UptimeInfo& from);
  UptimeInfo(UptimeInfo&& from) noexcept
    : UptimeInfo() {
    *this = ::std::move(from);
  }

  inline UptimeInfo& operator=(const UptimeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline UptimeInfo& operator=(UptimeInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UptimeInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const UptimeInfo* internal_default_instance() {
    return reinterpret_cast<const UptimeInfo*>(
               &_UptimeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(UptimeInfo& a, UptimeInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(UptimeInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UptimeInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UptimeInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UptimeInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UptimeInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UptimeInfo& from) {
    UptimeInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UptimeInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.observability.v1.UptimeInfo";
  }
  protected:
  explicit UptimeInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartTimeFieldNumber = 1,
    kLastRestartFieldNumber = 4,
    kUptimeSecondsFieldNumber = 2,
    kRestartCountFieldNumber = 3,
  };
  // .google.protobuf.Timestamp start_time = 1;
  bool has_start_time() const;
  private:
  bool _internal_has_start_time() const;
  public:
  void clear_start_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& start_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_start_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_start_time();
  void set_allocated_start_time(::PROTOBUF_NAMESPACE_ID::Timestamp* start_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_start_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_start_time();
  public:
  void unsafe_arena_set_allocated_start_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_start_time();

  // .google.protobuf.Timestamp last_restart = 4;
  bool has_last_restart() const;
  private:
  bool _internal_has_last_restart() const;
  public:
  void clear_last_restart();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& last_restart() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_last_restart();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_last_restart();
  void set_allocated_last_restart(::PROTOBUF_NAMESPACE_ID::Timestamp* last_restart);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_last_restart() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_last_restart();
  public:
  void unsafe_arena_set_allocated_last_restart(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* last_restart);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_last_restart();

  // int64 uptime_seconds = 2;
  void clear_uptime_seconds();
  int64_t uptime_seconds() const;
  void set_uptime_seconds(int64_t value);
  private:
  int64_t _internal_uptime_seconds() const;
  void _internal_set_uptime_seconds(int64_t value);
  public:

  // uint32 restart_count = 3;
  void clear_restart_count();
  uint32_t restart_count() const;
  void set_restart_count(uint32_t value);
  private:
  uint32_t _internal_restart_count() const;
  void _internal_set_restart_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.observability.v1.UptimeInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_restart_;
    int64_t uptime_seconds_;
    uint32_t restart_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_observability_2eproto;
};
// -------------------------------------------------------------------

class IncidentEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.observability.v1.IncidentEvent) */ {
 public:
  inline IncidentEvent() : IncidentEvent(nullptr) {}
  ~IncidentEvent() override;
  explicit PROTOBUF_CONSTEXPR IncidentEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IncidentEvent(const IncidentEvent& from);
  IncidentEvent(IncidentEvent&& from) noexcept
    : IncidentEvent() {
    *this = ::std::move(from);
  }

  inline IncidentEvent& operator=(const IncidentEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline IncidentEvent& operator=(IncidentEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IncidentEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const IncidentEvent* internal_default_instance() {
    return reinterpret_cast<const IncidentEvent*>(
               &_IncidentEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(IncidentEvent& a, IncidentEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(IncidentEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IncidentEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IncidentEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IncidentEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IncidentEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IncidentEvent& from) {
    IncidentEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IncidentEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.observability.v1.IncidentEvent";
  }
  protected:
  explicit IncidentEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventIdFieldNumber = 1,
    kEventTypeFieldNumber = 3,
    kTimestampFieldNumber = 2,
    kIncidentFieldNumber = 10,
    kDestinationsFieldNumber = 20,
    kPartitionInfoFieldNumber = 25,
    kSequenceNumberFieldNumber = 4,
  };
  // string event_id = 1;
  void clear_event_id();
  const std::string& event_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_event_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_event_id();
  PROTOBUF_NODISCARD std::string* release_event_id();
  void set_allocated_event_id(std::string* event_id);
  private:
  const std::string& _internal_event_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_event_id(const std::string& value);
  std::string* _internal_mutable_event_id();
  public:

  // string event_type = 3;
  void clear_event_type();
  const std::string& event_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_event_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_event_type();
  PROTOBUF_NODISCARD std::string* release_event_type();
  void set_allocated_event_type(std::string* event_type);
  private:
  const std::string& _internal_event_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_event_type(const std::string& value);
  std::string* _internal_mutable_event_type();
  public:

  // .google.protobuf.Timestamp timestamp = 2;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // .unhinged.observability.v1.IncidentData incident = 10;
  bool has_incident() const;
  private:
  bool _internal_has_incident() const;
  public:
  void clear_incident();
  const ::unhinged::observability::v1::IncidentData& incident() const;
  PROTOBUF_NODISCARD ::unhinged::observability::v1::IncidentData* release_incident();
  ::unhinged::observability::v1::IncidentData* mutable_incident();
  void set_allocated_incident(::unhinged::observability::v1::IncidentData* incident);
  private:
  const ::unhinged::observability::v1::IncidentData& _internal_incident() const;
  ::unhinged::observability::v1::IncidentData* _internal_mutable_incident();
  public:
  void unsafe_arena_set_allocated_incident(
      ::unhinged::observability::v1::IncidentData* incident);
  ::unhinged::observability::v1::IncidentData* unsafe_arena_release_incident();

  // .unhinged.observability.v1.DestinationFlags destinations = 20;
  bool has_destinations() const;
  private:
  bool _internal_has_destinations() const;
  public:
  void clear_destinations();
  const ::unhinged::observability::v1::DestinationFlags& destinations() const;
  PROTOBUF_NODISCARD ::unhinged::observability::v1::DestinationFlags* release_destinations();
  ::unhinged::observability::v1::DestinationFlags* mutable_destinations();
  void set_allocated_destinations(::unhinged::observability::v1::DestinationFlags* destinations);
  private:
  const ::unhinged::observability::v1::DestinationFlags& _internal_destinations() const;
  ::unhinged::observability::v1::DestinationFlags* _internal_mutable_destinations();
  public:
  void unsafe_arena_set_allocated_destinations(
      ::unhinged::observability::v1::DestinationFlags* destinations);
  ::unhinged::observability::v1::DestinationFlags* unsafe_arena_release_destinations();

  // .unhinged.observability.v1.PartitionInfo partition_info = 25;
  bool has_partition_info() const;
  private:
  bool _internal_has_partition_info() const;
  public:
  void clear_partition_info();
  const ::unhinged::observability::v1::PartitionInfo& partition_info() const;
  PROTOBUF_NODISCARD ::unhinged::observability::v1::PartitionInfo* release_partition_info();
  ::unhinged::observability::v1::PartitionInfo* mutable_partition_info();
  void set_allocated_partition_info(::unhinged::observability::v1::PartitionInfo* partition_info);
  private:
  const ::unhinged::observability::v1::PartitionInfo& _internal_partition_info() const;
  ::unhinged::observability::v1::PartitionInfo* _internal_mutable_partition_info();
  public:
  void unsafe_arena_set_allocated_partition_info(
      ::unhinged::observability::v1::PartitionInfo* partition_info);
  ::unhinged::observability::v1::PartitionInfo* unsafe_arena_release_partition_info();

  // int64 sequence_number = 4;
  void clear_sequence_number();
  int64_t sequence_number() const;
  void set_sequence_number(int64_t value);
  private:
  int64_t _internal_sequence_number() const;
  void _internal_set_sequence_number(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.observability.v1.IncidentEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr event_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr event_type_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
    ::unhinged::observability::v1::IncidentData* incident_;
    ::unhinged::observability::v1::DestinationFlags* destinations_;
    ::unhinged::observability::v1::PartitionInfo* partition_info_;
    int64_t sequence_number_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_observability_2eproto;
};
// -------------------------------------------------------------------

class IncidentData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.observability.v1.IncidentData) */ {
 public:
  inline IncidentData() : IncidentData(nullptr) {}
  ~IncidentData() override;
  explicit PROTOBUF_CONSTEXPR IncidentData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IncidentData(const IncidentData& from);
  IncidentData(IncidentData&& from) noexcept
    : IncidentData() {
    *this = ::std::move(from);
  }

  inline IncidentData& operator=(const IncidentData& from) {
    CopyFrom(from);
    return *this;
  }
  inline IncidentData& operator=(IncidentData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IncidentData& default_instance() {
    return *internal_default_instance();
  }
  static inline const IncidentData* internal_default_instance() {
    return reinterpret_cast<const IncidentData*>(
               &_IncidentData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(IncidentData& a, IncidentData& b) {
    a.Swap(&b);
  }
  inline void Swap(IncidentData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IncidentData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IncidentData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IncidentData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IncidentData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IncidentData& from) {
    IncidentData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IncidentData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.observability.v1.IncidentData";
  }
  protected:
  explicit IncidentData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAffectedServicesFieldNumber = 15,
    kAffectedComponentsFieldNumber = 16,
    kUpdatesFieldNumber = 20,
    kIncidentIdFieldNumber = 1,
    kTitleFieldNumber = 2,
    kDescriptionFieldNumber = 3,
    kCreatedAtFieldNumber = 10,
    kUpdatedAtFieldNumber = 11,
    kResolvedAtFieldNumber = 12,
    kImpactFieldNumber = 25,
    kResolutionFieldNumber = 30,
    kSeverityFieldNumber = 4,
    kStatusFieldNumber = 5,
  };
  // repeated string affected_services = 15;
  int affected_services_size() const;
  private:
  int _internal_affected_services_size() const;
  public:
  void clear_affected_services();
  const std::string& affected_services(int index) const;
  std::string* mutable_affected_services(int index);
  void set_affected_services(int index, const std::string& value);
  void set_affected_services(int index, std::string&& value);
  void set_affected_services(int index, const char* value);
  void set_affected_services(int index, const char* value, size_t size);
  std::string* add_affected_services();
  void add_affected_services(const std::string& value);
  void add_affected_services(std::string&& value);
  void add_affected_services(const char* value);
  void add_affected_services(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& affected_services() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_affected_services();
  private:
  const std::string& _internal_affected_services(int index) const;
  std::string* _internal_add_affected_services();
  public:

  // repeated string affected_components = 16;
  int affected_components_size() const;
  private:
  int _internal_affected_components_size() const;
  public:
  void clear_affected_components();
  const std::string& affected_components(int index) const;
  std::string* mutable_affected_components(int index);
  void set_affected_components(int index, const std::string& value);
  void set_affected_components(int index, std::string&& value);
  void set_affected_components(int index, const char* value);
  void set_affected_components(int index, const char* value, size_t size);
  std::string* add_affected_components();
  void add_affected_components(const std::string& value);
  void add_affected_components(std::string&& value);
  void add_affected_components(const char* value);
  void add_affected_components(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& affected_components() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_affected_components();
  private:
  const std::string& _internal_affected_components(int index) const;
  std::string* _internal_add_affected_components();
  public:

  // repeated .unhinged.observability.v1.IncidentUpdate updates = 20;
  int updates_size() const;
  private:
  int _internal_updates_size() const;
  public:
  void clear_updates();
  ::unhinged::observability::v1::IncidentUpdate* mutable_updates(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::IncidentUpdate >*
      mutable_updates();
  private:
  const ::unhinged::observability::v1::IncidentUpdate& _internal_updates(int index) const;
  ::unhinged::observability::v1::IncidentUpdate* _internal_add_updates();
  public:
  const ::unhinged::observability::v1::IncidentUpdate& updates(int index) const;
  ::unhinged::observability::v1::IncidentUpdate* add_updates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::IncidentUpdate >&
      updates() const;

  // string incident_id = 1;
  void clear_incident_id();
  const std::string& incident_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_incident_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_incident_id();
  PROTOBUF_NODISCARD std::string* release_incident_id();
  void set_allocated_incident_id(std::string* incident_id);
  private:
  const std::string& _internal_incident_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_incident_id(const std::string& value);
  std::string* _internal_mutable_incident_id();
  public:

  // string title = 2;
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // string description = 3;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // .google.protobuf.Timestamp created_at = 10;
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_at();
  void set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_at();

  // .google.protobuf.Timestamp updated_at = 11;
  bool has_updated_at() const;
  private:
  bool _internal_has_updated_at() const;
  public:
  void clear_updated_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& updated_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_updated_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_updated_at();
  void set_allocated_updated_at(::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_updated_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_updated_at();
  public:
  void unsafe_arena_set_allocated_updated_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_updated_at();

  // .google.protobuf.Timestamp resolved_at = 12;
  bool has_resolved_at() const;
  private:
  bool _internal_has_resolved_at() const;
  public:
  void clear_resolved_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& resolved_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_resolved_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_resolved_at();
  void set_allocated_resolved_at(::PROTOBUF_NAMESPACE_ID::Timestamp* resolved_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_resolved_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_resolved_at();
  public:
  void unsafe_arena_set_allocated_resolved_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* resolved_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_resolved_at();

  // .unhinged.observability.v1.IncidentImpact impact = 25;
  bool has_impact() const;
  private:
  bool _internal_has_impact() const;
  public:
  void clear_impact();
  const ::unhinged::observability::v1::IncidentImpact& impact() const;
  PROTOBUF_NODISCARD ::unhinged::observability::v1::IncidentImpact* release_impact();
  ::unhinged::observability::v1::IncidentImpact* mutable_impact();
  void set_allocated_impact(::unhinged::observability::v1::IncidentImpact* impact);
  private:
  const ::unhinged::observability::v1::IncidentImpact& _internal_impact() const;
  ::unhinged::observability::v1::IncidentImpact* _internal_mutable_impact();
  public:
  void unsafe_arena_set_allocated_impact(
      ::unhinged::observability::v1::IncidentImpact* impact);
  ::unhinged::observability::v1::IncidentImpact* unsafe_arena_release_impact();

  // .unhinged.observability.v1.IncidentResolution resolution = 30;
  bool has_resolution() const;
  private:
  bool _internal_has_resolution() const;
  public:
  void clear_resolution();
  const ::unhinged::observability::v1::IncidentResolution& resolution() const;
  PROTOBUF_NODISCARD ::unhinged::observability::v1::IncidentResolution* release_resolution();
  ::unhinged::observability::v1::IncidentResolution* mutable_resolution();
  void set_allocated_resolution(::unhinged::observability::v1::IncidentResolution* resolution);
  private:
  const ::unhinged::observability::v1::IncidentResolution& _internal_resolution() const;
  ::unhinged::observability::v1::IncidentResolution* _internal_mutable_resolution();
  public:
  void unsafe_arena_set_allocated_resolution(
      ::unhinged::observability::v1::IncidentResolution* resolution);
  ::unhinged::observability::v1::IncidentResolution* unsafe_arena_release_resolution();

  // .unhinged.observability.v1.IncidentSeverity severity = 4;
  void clear_severity();
  ::unhinged::observability::v1::IncidentSeverity severity() const;
  void set_severity(::unhinged::observability::v1::IncidentSeverity value);
  private:
  ::unhinged::observability::v1::IncidentSeverity _internal_severity() const;
  void _internal_set_severity(::unhinged::observability::v1::IncidentSeverity value);
  public:

  // .unhinged.observability.v1.IncidentStatus status = 5;
  void clear_status();
  ::unhinged::observability::v1::IncidentStatus status() const;
  void set_status(::unhinged::observability::v1::IncidentStatus value);
  private:
  ::unhinged::observability::v1::IncidentStatus _internal_status() const;
  void _internal_set_status(::unhinged::observability::v1::IncidentStatus value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.observability.v1.IncidentData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> affected_services_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> affected_components_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::IncidentUpdate > updates_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr incident_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* resolved_at_;
    ::unhinged::observability::v1::IncidentImpact* impact_;
    ::unhinged::observability::v1::IncidentResolution* resolution_;
    int severity_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_observability_2eproto;
};
// -------------------------------------------------------------------

class IncidentUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.observability.v1.IncidentUpdate) */ {
 public:
  inline IncidentUpdate() : IncidentUpdate(nullptr) {}
  ~IncidentUpdate() override;
  explicit PROTOBUF_CONSTEXPR IncidentUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IncidentUpdate(const IncidentUpdate& from);
  IncidentUpdate(IncidentUpdate&& from) noexcept
    : IncidentUpdate() {
    *this = ::std::move(from);
  }

  inline IncidentUpdate& operator=(const IncidentUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline IncidentUpdate& operator=(IncidentUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IncidentUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const IncidentUpdate* internal_default_instance() {
    return reinterpret_cast<const IncidentUpdate*>(
               &_IncidentUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(IncidentUpdate& a, IncidentUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(IncidentUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IncidentUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IncidentUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IncidentUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IncidentUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IncidentUpdate& from) {
    IncidentUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IncidentUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.observability.v1.IncidentUpdate";
  }
  protected:
  explicit IncidentUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUpdateIdFieldNumber = 1,
    kMessageFieldNumber = 4,
    kAuthorFieldNumber = 5,
    kTimestampFieldNumber = 2,
    kStatusFieldNumber = 3,
    kTypeFieldNumber = 6,
  };
  // string update_id = 1;
  void clear_update_id();
  const std::string& update_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_update_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_update_id();
  PROTOBUF_NODISCARD std::string* release_update_id();
  void set_allocated_update_id(std::string* update_id);
  private:
  const std::string& _internal_update_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_update_id(const std::string& value);
  std::string* _internal_mutable_update_id();
  public:

  // string message = 4;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // string author = 5;
  void clear_author();
  const std::string& author() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_author(ArgT0&& arg0, ArgT... args);
  std::string* mutable_author();
  PROTOBUF_NODISCARD std::string* release_author();
  void set_allocated_author(std::string* author);
  private:
  const std::string& _internal_author() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_author(const std::string& value);
  std::string* _internal_mutable_author();
  public:

  // .google.protobuf.Timestamp timestamp = 2;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // .unhinged.observability.v1.IncidentStatus status = 3;
  void clear_status();
  ::unhinged::observability::v1::IncidentStatus status() const;
  void set_status(::unhinged::observability::v1::IncidentStatus value);
  private:
  ::unhinged::observability::v1::IncidentStatus _internal_status() const;
  void _internal_set_status(::unhinged::observability::v1::IncidentStatus value);
  public:

  // .unhinged.observability.v1.UpdateType type = 6;
  void clear_type();
  ::unhinged::observability::v1::UpdateType type() const;
  void set_type(::unhinged::observability::v1::UpdateType value);
  private:
  ::unhinged::observability::v1::UpdateType _internal_type() const;
  void _internal_set_type(::unhinged::observability::v1::UpdateType value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.observability.v1.IncidentUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr update_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr author_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
    int status_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_observability_2eproto;
};
// -------------------------------------------------------------------

class IncidentImpact final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.observability.v1.IncidentImpact) */ {
 public:
  inline IncidentImpact() : IncidentImpact(nullptr) {}
  ~IncidentImpact() override;
  explicit PROTOBUF_CONSTEXPR IncidentImpact(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IncidentImpact(const IncidentImpact& from);
  IncidentImpact(IncidentImpact&& from) noexcept
    : IncidentImpact() {
    *this = ::std::move(from);
  }

  inline IncidentImpact& operator=(const IncidentImpact& from) {
    CopyFrom(from);
    return *this;
  }
  inline IncidentImpact& operator=(IncidentImpact&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IncidentImpact& default_instance() {
    return *internal_default_instance();
  }
  static inline const IncidentImpact* internal_default_instance() {
    return reinterpret_cast<const IncidentImpact*>(
               &_IncidentImpact_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(IncidentImpact& a, IncidentImpact& b) {
    a.Swap(&b);
  }
  inline void Swap(IncidentImpact* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IncidentImpact* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IncidentImpact* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IncidentImpact>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IncidentImpact& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IncidentImpact& from) {
    IncidentImpact::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IncidentImpact* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.observability.v1.IncidentImpact";
  }
  protected:
  explicit IncidentImpact(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAffectedRegionsFieldNumber = 4,
    kBusinessImpactFieldNumber = 5,
    kAvailabilityImpactFieldNumber = 1,
    kPerformanceImpactFieldNumber = 2,
    kAffectedUsersFieldNumber = 3,
  };
  // repeated string affected_regions = 4;
  int affected_regions_size() const;
  private:
  int _internal_affected_regions_size() const;
  public:
  void clear_affected_regions();
  const std::string& affected_regions(int index) const;
  std::string* mutable_affected_regions(int index);
  void set_affected_regions(int index, const std::string& value);
  void set_affected_regions(int index, std::string&& value);
  void set_affected_regions(int index, const char* value);
  void set_affected_regions(int index, const char* value, size_t size);
  std::string* add_affected_regions();
  void add_affected_regions(const std::string& value);
  void add_affected_regions(std::string&& value);
  void add_affected_regions(const char* value);
  void add_affected_regions(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& affected_regions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_affected_regions();
  private:
  const std::string& _internal_affected_regions(int index) const;
  std::string* _internal_add_affected_regions();
  public:

  // string business_impact = 5;
  void clear_business_impact();
  const std::string& business_impact() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_business_impact(ArgT0&& arg0, ArgT... args);
  std::string* mutable_business_impact();
  PROTOBUF_NODISCARD std::string* release_business_impact();
  void set_allocated_business_impact(std::string* business_impact);
  private:
  const std::string& _internal_business_impact() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_business_impact(const std::string& value);
  std::string* _internal_mutable_business_impact();
  public:

  // double availability_impact = 1;
  void clear_availability_impact();
  double availability_impact() const;
  void set_availability_impact(double value);
  private:
  double _internal_availability_impact() const;
  void _internal_set_availability_impact(double value);
  public:

  // double performance_impact = 2;
  void clear_performance_impact();
  double performance_impact() const;
  void set_performance_impact(double value);
  private:
  double _internal_performance_impact() const;
  void _internal_set_performance_impact(double value);
  public:

  // uint32 affected_users = 3;
  void clear_affected_users();
  uint32_t affected_users() const;
  void set_affected_users(uint32_t value);
  private:
  uint32_t _internal_affected_users() const;
  void _internal_set_affected_users(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.observability.v1.IncidentImpact)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> affected_regions_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr business_impact_;
    double availability_impact_;
    double performance_impact_;
    uint32_t affected_users_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_observability_2eproto;
};
// -------------------------------------------------------------------

class IncidentResolution final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.observability.v1.IncidentResolution) */ {
 public:
  inline IncidentResolution() : IncidentResolution(nullptr) {}
  ~IncidentResolution() override;
  explicit PROTOBUF_CONSTEXPR IncidentResolution(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IncidentResolution(const IncidentResolution& from);
  IncidentResolution(IncidentResolution&& from) noexcept
    : IncidentResolution() {
    *this = ::std::move(from);
  }

  inline IncidentResolution& operator=(const IncidentResolution& from) {
    CopyFrom(from);
    return *this;
  }
  inline IncidentResolution& operator=(IncidentResolution&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IncidentResolution& default_instance() {
    return *internal_default_instance();
  }
  static inline const IncidentResolution* internal_default_instance() {
    return reinterpret_cast<const IncidentResolution*>(
               &_IncidentResolution_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(IncidentResolution& a, IncidentResolution& b) {
    a.Swap(&b);
  }
  inline void Swap(IncidentResolution* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IncidentResolution* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IncidentResolution* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IncidentResolution>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IncidentResolution& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IncidentResolution& from) {
    IncidentResolution::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IncidentResolution* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.observability.v1.IncidentResolution";
  }
  protected:
  explicit IncidentResolution(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLessonsLearnedFieldNumber = 4,
    kRootCauseFieldNumber = 1,
    kResolutionStepsFieldNumber = 2,
    kPreventionMeasuresFieldNumber = 3,
    kPostmortemUrlFieldNumber = 5,
  };
  // repeated string lessons_learned = 4;
  int lessons_learned_size() const;
  private:
  int _internal_lessons_learned_size() const;
  public:
  void clear_lessons_learned();
  const std::string& lessons_learned(int index) const;
  std::string* mutable_lessons_learned(int index);
  void set_lessons_learned(int index, const std::string& value);
  void set_lessons_learned(int index, std::string&& value);
  void set_lessons_learned(int index, const char* value);
  void set_lessons_learned(int index, const char* value, size_t size);
  std::string* add_lessons_learned();
  void add_lessons_learned(const std::string& value);
  void add_lessons_learned(std::string&& value);
  void add_lessons_learned(const char* value);
  void add_lessons_learned(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& lessons_learned() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_lessons_learned();
  private:
  const std::string& _internal_lessons_learned(int index) const;
  std::string* _internal_add_lessons_learned();
  public:

  // string root_cause = 1;
  void clear_root_cause();
  const std::string& root_cause() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_root_cause(ArgT0&& arg0, ArgT... args);
  std::string* mutable_root_cause();
  PROTOBUF_NODISCARD std::string* release_root_cause();
  void set_allocated_root_cause(std::string* root_cause);
  private:
  const std::string& _internal_root_cause() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_root_cause(const std::string& value);
  std::string* _internal_mutable_root_cause();
  public:

  // string resolution_steps = 2;
  void clear_resolution_steps();
  const std::string& resolution_steps() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resolution_steps(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resolution_steps();
  PROTOBUF_NODISCARD std::string* release_resolution_steps();
  void set_allocated_resolution_steps(std::string* resolution_steps);
  private:
  const std::string& _internal_resolution_steps() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resolution_steps(const std::string& value);
  std::string* _internal_mutable_resolution_steps();
  public:

  // string prevention_measures = 3;
  void clear_prevention_measures();
  const std::string& prevention_measures() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_prevention_measures(ArgT0&& arg0, ArgT... args);
  std::string* mutable_prevention_measures();
  PROTOBUF_NODISCARD std::string* release_prevention_measures();
  void set_allocated_prevention_measures(std::string* prevention_measures);
  private:
  const std::string& _internal_prevention_measures() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_prevention_measures(const std::string& value);
  std::string* _internal_mutable_prevention_measures();
  public:

  // string postmortem_url = 5;
  void clear_postmortem_url();
  const std::string& postmortem_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_postmortem_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_postmortem_url();
  PROTOBUF_NODISCARD std::string* release_postmortem_url();
  void set_allocated_postmortem_url(std::string* postmortem_url);
  private:
  const std::string& _internal_postmortem_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_postmortem_url(const std::string& value);
  std::string* _internal_mutable_postmortem_url();
  public:

  // @@protoc_insertion_point(class_scope:unhinged.observability.v1.IncidentResolution)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> lessons_learned_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr root_cause_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resolution_steps_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr prevention_measures_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr postmortem_url_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_observability_2eproto;
};
// -------------------------------------------------------------------

class IngestResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.observability.v1.IngestResponse) */ {
 public:
  inline IngestResponse() : IngestResponse(nullptr) {}
  ~IngestResponse() override;
  explicit PROTOBUF_CONSTEXPR IngestResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IngestResponse(const IngestResponse& from);
  IngestResponse(IngestResponse&& from) noexcept
    : IngestResponse() {
    *this = ::std::move(from);
  }

  inline IngestResponse& operator=(const IngestResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline IngestResponse& operator=(IngestResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IngestResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const IngestResponse* internal_default_instance() {
    return reinterpret_cast<const IngestResponse*>(
               &_IngestResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(IngestResponse& a, IngestResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(IngestResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IngestResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IngestResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IngestResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IngestResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IngestResponse& from) {
    IngestResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IngestResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.observability.v1.IngestResponse";
  }
  protected:
  explicit IngestResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kSuccessFieldNumber = 1,
    kProcessedCountFieldNumber = 3,
    kFailedCountFieldNumber = 4,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // uint32 processed_count = 3;
  void clear_processed_count();
  uint32_t processed_count() const;
  void set_processed_count(uint32_t value);
  private:
  uint32_t _internal_processed_count() const;
  void _internal_set_processed_count(uint32_t value);
  public:

  // uint32 failed_count = 4;
  void clear_failed_count();
  uint32_t failed_count() const;
  void set_failed_count(uint32_t value);
  private:
  uint32_t _internal_failed_count() const;
  void _internal_set_failed_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.observability.v1.IngestResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    bool success_;
    uint32_t processed_count_;
    uint32_t failed_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_observability_2eproto;
};
// -------------------------------------------------------------------

class HealthResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.observability.v1.HealthResponse) */ {
 public:
  inline HealthResponse() : HealthResponse(nullptr) {}
  ~HealthResponse() override;
  explicit PROTOBUF_CONSTEXPR HealthResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HealthResponse(const HealthResponse& from);
  HealthResponse(HealthResponse&& from) noexcept
    : HealthResponse() {
    *this = ::std::move(from);
  }

  inline HealthResponse& operator=(const HealthResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline HealthResponse& operator=(HealthResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HealthResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const HealthResponse* internal_default_instance() {
    return reinterpret_cast<const HealthResponse*>(
               &_HealthResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(HealthResponse& a, HealthResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(HealthResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HealthResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HealthResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HealthResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HealthResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HealthResponse& from) {
    HealthResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HealthResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.observability.v1.HealthResponse";
  }
  protected:
  explicit HealthResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kNextCheckFieldNumber = 3,
    kSuccessFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .google.protobuf.Timestamp next_check = 3;
  bool has_next_check() const;
  private:
  bool _internal_has_next_check() const;
  public:
  void clear_next_check();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& next_check() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_next_check();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_next_check();
  void set_allocated_next_check(::PROTOBUF_NAMESPACE_ID::Timestamp* next_check);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_next_check() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_next_check();
  public:
  void unsafe_arena_set_allocated_next_check(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* next_check);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_next_check();

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.observability.v1.HealthResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* next_check_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_observability_2eproto;
};
// -------------------------------------------------------------------

class IncidentResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.observability.v1.IncidentResponse) */ {
 public:
  inline IncidentResponse() : IncidentResponse(nullptr) {}
  ~IncidentResponse() override;
  explicit PROTOBUF_CONSTEXPR IncidentResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IncidentResponse(const IncidentResponse& from);
  IncidentResponse(IncidentResponse&& from) noexcept
    : IncidentResponse() {
    *this = ::std::move(from);
  }

  inline IncidentResponse& operator=(const IncidentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline IncidentResponse& operator=(IncidentResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IncidentResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const IncidentResponse* internal_default_instance() {
    return reinterpret_cast<const IncidentResponse*>(
               &_IncidentResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(IncidentResponse& a, IncidentResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(IncidentResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IncidentResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IncidentResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IncidentResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IncidentResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IncidentResponse& from) {
    IncidentResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IncidentResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.observability.v1.IncidentResponse";
  }
  protected:
  explicit IncidentResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kIncidentIdFieldNumber = 3,
    kSuccessFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // string incident_id = 3;
  void clear_incident_id();
  const std::string& incident_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_incident_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_incident_id();
  PROTOBUF_NODISCARD std::string* release_incident_id();
  void set_allocated_incident_id(std::string* incident_id);
  private:
  const std::string& _internal_incident_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_incident_id(const std::string& value);
  std::string* _internal_mutable_incident_id();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.observability.v1.IncidentResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr incident_id_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_observability_2eproto;
};
// -------------------------------------------------------------------

class HealthQuery final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.observability.v1.HealthQuery) */ {
 public:
  inline HealthQuery() : HealthQuery(nullptr) {}
  ~HealthQuery() override;
  explicit PROTOBUF_CONSTEXPR HealthQuery(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HealthQuery(const HealthQuery& from);
  HealthQuery(HealthQuery&& from) noexcept
    : HealthQuery() {
    *this = ::std::move(from);
  }

  inline HealthQuery& operator=(const HealthQuery& from) {
    CopyFrom(from);
    return *this;
  }
  inline HealthQuery& operator=(HealthQuery&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HealthQuery& default_instance() {
    return *internal_default_instance();
  }
  static inline const HealthQuery* internal_default_instance() {
    return reinterpret_cast<const HealthQuery*>(
               &_HealthQuery_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(HealthQuery& a, HealthQuery& b) {
    a.Swap(&b);
  }
  inline void Swap(HealthQuery* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HealthQuery* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HealthQuery* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HealthQuery>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HealthQuery& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HealthQuery& from) {
    HealthQuery::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HealthQuery* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.observability.v1.HealthQuery";
  }
  protected:
  explicit HealthQuery(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceNamesFieldNumber = 1,
    kSinceFieldNumber = 2,
  };
  // repeated string service_names = 1;
  int service_names_size() const;
  private:
  int _internal_service_names_size() const;
  public:
  void clear_service_names();
  const std::string& service_names(int index) const;
  std::string* mutable_service_names(int index);
  void set_service_names(int index, const std::string& value);
  void set_service_names(int index, std::string&& value);
  void set_service_names(int index, const char* value);
  void set_service_names(int index, const char* value, size_t size);
  std::string* add_service_names();
  void add_service_names(const std::string& value);
  void add_service_names(std::string&& value);
  void add_service_names(const char* value);
  void add_service_names(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& service_names() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_service_names();
  private:
  const std::string& _internal_service_names(int index) const;
  std::string* _internal_add_service_names();
  public:

  // .google.protobuf.Timestamp since = 2;
  bool has_since() const;
  private:
  bool _internal_has_since() const;
  public:
  void clear_since();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& since() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_since();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_since();
  void set_allocated_since(::PROTOBUF_NAMESPACE_ID::Timestamp* since);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_since() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_since();
  public:
  void unsafe_arena_set_allocated_since(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* since);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_since();

  // @@protoc_insertion_point(class_scope:unhinged.observability.v1.HealthQuery)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> service_names_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* since_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_observability_2eproto;
};
// -------------------------------------------------------------------

class HealthQueryResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.observability.v1.HealthQueryResponse) */ {
 public:
  inline HealthQueryResponse() : HealthQueryResponse(nullptr) {}
  ~HealthQueryResponse() override;
  explicit PROTOBUF_CONSTEXPR HealthQueryResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HealthQueryResponse(const HealthQueryResponse& from);
  HealthQueryResponse(HealthQueryResponse&& from) noexcept
    : HealthQueryResponse() {
    *this = ::std::move(from);
  }

  inline HealthQueryResponse& operator=(const HealthQueryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline HealthQueryResponse& operator=(HealthQueryResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HealthQueryResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const HealthQueryResponse* internal_default_instance() {
    return reinterpret_cast<const HealthQueryResponse*>(
               &_HealthQueryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(HealthQueryResponse& a, HealthQueryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(HealthQueryResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HealthQueryResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HealthQueryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HealthQueryResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HealthQueryResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HealthQueryResponse& from) {
    HealthQueryResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HealthQueryResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.observability.v1.HealthQueryResponse";
  }
  protected:
  explicit HealthQueryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServicesFieldNumber = 1,
  };
  // repeated .unhinged.observability.v1.ServiceHealth services = 1;
  int services_size() const;
  private:
  int _internal_services_size() const;
  public:
  void clear_services();
  ::unhinged::observability::v1::ServiceHealth* mutable_services(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::ServiceHealth >*
      mutable_services();
  private:
  const ::unhinged::observability::v1::ServiceHealth& _internal_services(int index) const;
  ::unhinged::observability::v1::ServiceHealth* _internal_add_services();
  public:
  const ::unhinged::observability::v1::ServiceHealth& services(int index) const;
  ::unhinged::observability::v1::ServiceHealth* add_services();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::ServiceHealth >&
      services() const;

  // @@protoc_insertion_point(class_scope:unhinged.observability.v1.HealthQueryResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::ServiceHealth > services_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_observability_2eproto;
};
// -------------------------------------------------------------------

class IncidentQuery final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.observability.v1.IncidentQuery) */ {
 public:
  inline IncidentQuery() : IncidentQuery(nullptr) {}
  ~IncidentQuery() override;
  explicit PROTOBUF_CONSTEXPR IncidentQuery(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IncidentQuery(const IncidentQuery& from);
  IncidentQuery(IncidentQuery&& from) noexcept
    : IncidentQuery() {
    *this = ::std::move(from);
  }

  inline IncidentQuery& operator=(const IncidentQuery& from) {
    CopyFrom(from);
    return *this;
  }
  inline IncidentQuery& operator=(IncidentQuery&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IncidentQuery& default_instance() {
    return *internal_default_instance();
  }
  static inline const IncidentQuery* internal_default_instance() {
    return reinterpret_cast<const IncidentQuery*>(
               &_IncidentQuery_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(IncidentQuery& a, IncidentQuery& b) {
    a.Swap(&b);
  }
  inline void Swap(IncidentQuery* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IncidentQuery* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IncidentQuery* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IncidentQuery>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IncidentQuery& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IncidentQuery& from) {
    IncidentQuery::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IncidentQuery* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.observability.v1.IncidentQuery";
  }
  protected:
  explicit IncidentQuery(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusesFieldNumber = 1,
    kSeveritiesFieldNumber = 2,
    kSinceFieldNumber = 3,
  };
  // repeated .unhinged.observability.v1.IncidentStatus statuses = 1;
  int statuses_size() const;
  private:
  int _internal_statuses_size() const;
  public:
  void clear_statuses();
  private:
  ::unhinged::observability::v1::IncidentStatus _internal_statuses(int index) const;
  void _internal_add_statuses(::unhinged::observability::v1::IncidentStatus value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_statuses();
  public:
  ::unhinged::observability::v1::IncidentStatus statuses(int index) const;
  void set_statuses(int index, ::unhinged::observability::v1::IncidentStatus value);
  void add_statuses(::unhinged::observability::v1::IncidentStatus value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& statuses() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_statuses();

  // repeated .unhinged.observability.v1.IncidentSeverity severities = 2;
  int severities_size() const;
  private:
  int _internal_severities_size() const;
  public:
  void clear_severities();
  private:
  ::unhinged::observability::v1::IncidentSeverity _internal_severities(int index) const;
  void _internal_add_severities(::unhinged::observability::v1::IncidentSeverity value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_severities();
  public:
  ::unhinged::observability::v1::IncidentSeverity severities(int index) const;
  void set_severities(int index, ::unhinged::observability::v1::IncidentSeverity value);
  void add_severities(::unhinged::observability::v1::IncidentSeverity value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& severities() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_severities();

  // .google.protobuf.Timestamp since = 3;
  bool has_since() const;
  private:
  bool _internal_has_since() const;
  public:
  void clear_since();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& since() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_since();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_since();
  void set_allocated_since(::PROTOBUF_NAMESPACE_ID::Timestamp* since);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_since() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_since();
  public:
  void unsafe_arena_set_allocated_since(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* since);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_since();

  // @@protoc_insertion_point(class_scope:unhinged.observability.v1.IncidentQuery)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> statuses_;
    mutable std::atomic<int> _statuses_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> severities_;
    mutable std::atomic<int> _severities_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* since_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_observability_2eproto;
};
// -------------------------------------------------------------------

class IncidentQueryResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.observability.v1.IncidentQueryResponse) */ {
 public:
  inline IncidentQueryResponse() : IncidentQueryResponse(nullptr) {}
  ~IncidentQueryResponse() override;
  explicit PROTOBUF_CONSTEXPR IncidentQueryResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IncidentQueryResponse(const IncidentQueryResponse& from);
  IncidentQueryResponse(IncidentQueryResponse&& from) noexcept
    : IncidentQueryResponse() {
    *this = ::std::move(from);
  }

  inline IncidentQueryResponse& operator=(const IncidentQueryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline IncidentQueryResponse& operator=(IncidentQueryResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IncidentQueryResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const IncidentQueryResponse* internal_default_instance() {
    return reinterpret_cast<const IncidentQueryResponse*>(
               &_IncidentQueryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(IncidentQueryResponse& a, IncidentQueryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(IncidentQueryResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IncidentQueryResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IncidentQueryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IncidentQueryResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IncidentQueryResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IncidentQueryResponse& from) {
    IncidentQueryResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IncidentQueryResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.observability.v1.IncidentQueryResponse";
  }
  protected:
  explicit IncidentQueryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIncidentsFieldNumber = 1,
  };
  // repeated .unhinged.observability.v1.IncidentData incidents = 1;
  int incidents_size() const;
  private:
  int _internal_incidents_size() const;
  public:
  void clear_incidents();
  ::unhinged::observability::v1::IncidentData* mutable_incidents(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::IncidentData >*
      mutable_incidents();
  private:
  const ::unhinged::observability::v1::IncidentData& _internal_incidents(int index) const;
  ::unhinged::observability::v1::IncidentData* _internal_add_incidents();
  public:
  const ::unhinged::observability::v1::IncidentData& incidents(int index) const;
  ::unhinged::observability::v1::IncidentData* add_incidents();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::IncidentData >&
      incidents() const;

  // @@protoc_insertion_point(class_scope:unhinged.observability.v1.IncidentQueryResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::IncidentData > incidents_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_observability_2eproto;
};
// -------------------------------------------------------------------

class MetricQuery_LabelsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<MetricQuery_LabelsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<MetricQuery_LabelsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  MetricQuery_LabelsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR MetricQuery_LabelsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit MetricQuery_LabelsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const MetricQuery_LabelsEntry_DoNotUse& other);
  static const MetricQuery_LabelsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const MetricQuery_LabelsEntry_DoNotUse*>(&_MetricQuery_LabelsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "unhinged.observability.v1.MetricQuery.LabelsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "unhinged.observability.v1.MetricQuery.LabelsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_observability_2eproto;
};

// -------------------------------------------------------------------

class MetricQuery final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.observability.v1.MetricQuery) */ {
 public:
  inline MetricQuery() : MetricQuery(nullptr) {}
  ~MetricQuery() override;
  explicit PROTOBUF_CONSTEXPR MetricQuery(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MetricQuery(const MetricQuery& from);
  MetricQuery(MetricQuery&& from) noexcept
    : MetricQuery() {
    *this = ::std::move(from);
  }

  inline MetricQuery& operator=(const MetricQuery& from) {
    CopyFrom(from);
    return *this;
  }
  inline MetricQuery& operator=(MetricQuery&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MetricQuery& default_instance() {
    return *internal_default_instance();
  }
  static inline const MetricQuery* internal_default_instance() {
    return reinterpret_cast<const MetricQuery*>(
               &_MetricQuery_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(MetricQuery& a, MetricQuery& b) {
    a.Swap(&b);
  }
  inline void Swap(MetricQuery* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MetricQuery* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MetricQuery* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MetricQuery>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MetricQuery& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MetricQuery& from) {
    MetricQuery::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MetricQuery* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.observability.v1.MetricQuery";
  }
  protected:
  explicit MetricQuery(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kLabelsFieldNumber = 2,
    kMetricNameFieldNumber = 1,
    kStartTimeFieldNumber = 3,
    kEndTimeFieldNumber = 4,
  };
  // map<string, string> labels = 2;
  int labels_size() const;
  private:
  int _internal_labels_size() const;
  public:
  void clear_labels();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_labels() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_labels();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      labels() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_labels();

  // string metric_name = 1;
  void clear_metric_name();
  const std::string& metric_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_metric_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_metric_name();
  PROTOBUF_NODISCARD std::string* release_metric_name();
  void set_allocated_metric_name(std::string* metric_name);
  private:
  const std::string& _internal_metric_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_metric_name(const std::string& value);
  std::string* _internal_mutable_metric_name();
  public:

  // .google.protobuf.Timestamp start_time = 3;
  bool has_start_time() const;
  private:
  bool _internal_has_start_time() const;
  public:
  void clear_start_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& start_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_start_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_start_time();
  void set_allocated_start_time(::PROTOBUF_NAMESPACE_ID::Timestamp* start_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_start_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_start_time();
  public:
  void unsafe_arena_set_allocated_start_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_start_time();

  // .google.protobuf.Timestamp end_time = 4;
  bool has_end_time() const;
  private:
  bool _internal_has_end_time() const;
  public:
  void clear_end_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& end_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_end_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_end_time();
  void set_allocated_end_time(::PROTOBUF_NAMESPACE_ID::Timestamp* end_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_end_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_end_time();
  public:
  void unsafe_arena_set_allocated_end_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_end_time();

  // @@protoc_insertion_point(class_scope:unhinged.observability.v1.MetricQuery)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        MetricQuery_LabelsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> labels_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr metric_name_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_observability_2eproto;
};
// -------------------------------------------------------------------

class MetricQueryResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.observability.v1.MetricQueryResponse) */ {
 public:
  inline MetricQueryResponse() : MetricQueryResponse(nullptr) {}
  ~MetricQueryResponse() override;
  explicit PROTOBUF_CONSTEXPR MetricQueryResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MetricQueryResponse(const MetricQueryResponse& from);
  MetricQueryResponse(MetricQueryResponse&& from) noexcept
    : MetricQueryResponse() {
    *this = ::std::move(from);
  }

  inline MetricQueryResponse& operator=(const MetricQueryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MetricQueryResponse& operator=(MetricQueryResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MetricQueryResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MetricQueryResponse* internal_default_instance() {
    return reinterpret_cast<const MetricQueryResponse*>(
               &_MetricQueryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(MetricQueryResponse& a, MetricQueryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MetricQueryResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MetricQueryResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MetricQueryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MetricQueryResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MetricQueryResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MetricQueryResponse& from) {
    MetricQueryResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MetricQueryResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.observability.v1.MetricQueryResponse";
  }
  protected:
  explicit MetricQueryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetricsFieldNumber = 1,
  };
  // repeated .unhinged.observability.v1.MetricData metrics = 1;
  int metrics_size() const;
  private:
  int _internal_metrics_size() const;
  public:
  void clear_metrics();
  ::unhinged::observability::v1::MetricData* mutable_metrics(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::MetricData >*
      mutable_metrics();
  private:
  const ::unhinged::observability::v1::MetricData& _internal_metrics(int index) const;
  ::unhinged::observability::v1::MetricData* _internal_add_metrics();
  public:
  const ::unhinged::observability::v1::MetricData& metrics(int index) const;
  ::unhinged::observability::v1::MetricData* add_metrics();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::MetricData >&
      metrics() const;

  // @@protoc_insertion_point(class_scope:unhinged.observability.v1.MetricQueryResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::MetricData > metrics_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_observability_2eproto;
};
// -------------------------------------------------------------------

class TraceQuery final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.observability.v1.TraceQuery) */ {
 public:
  inline TraceQuery() : TraceQuery(nullptr) {}
  ~TraceQuery() override;
  explicit PROTOBUF_CONSTEXPR TraceQuery(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TraceQuery(const TraceQuery& from);
  TraceQuery(TraceQuery&& from) noexcept
    : TraceQuery() {
    *this = ::std::move(from);
  }

  inline TraceQuery& operator=(const TraceQuery& from) {
    CopyFrom(from);
    return *this;
  }
  inline TraceQuery& operator=(TraceQuery&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TraceQuery& default_instance() {
    return *internal_default_instance();
  }
  static inline const TraceQuery* internal_default_instance() {
    return reinterpret_cast<const TraceQuery*>(
               &_TraceQuery_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(TraceQuery& a, TraceQuery& b) {
    a.Swap(&b);
  }
  inline void Swap(TraceQuery* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TraceQuery* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TraceQuery* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TraceQuery>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TraceQuery& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TraceQuery& from) {
    TraceQuery::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TraceQuery* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.observability.v1.TraceQuery";
  }
  protected:
  explicit TraceQuery(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTraceIdFieldNumber = 1,
    kServiceNameFieldNumber = 2,
    kStartTimeFieldNumber = 3,
    kEndTimeFieldNumber = 4,
    kLimitFieldNumber = 5,
  };
  // string trace_id = 1;
  void clear_trace_id();
  const std::string& trace_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_trace_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_trace_id();
  PROTOBUF_NODISCARD std::string* release_trace_id();
  void set_allocated_trace_id(std::string* trace_id);
  private:
  const std::string& _internal_trace_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trace_id(const std::string& value);
  std::string* _internal_mutable_trace_id();
  public:

  // string service_name = 2;
  void clear_service_name();
  const std::string& service_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // .google.protobuf.Timestamp start_time = 3;
  bool has_start_time() const;
  private:
  bool _internal_has_start_time() const;
  public:
  void clear_start_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& start_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_start_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_start_time();
  void set_allocated_start_time(::PROTOBUF_NAMESPACE_ID::Timestamp* start_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_start_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_start_time();
  public:
  void unsafe_arena_set_allocated_start_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_start_time();

  // .google.protobuf.Timestamp end_time = 4;
  bool has_end_time() const;
  private:
  bool _internal_has_end_time() const;
  public:
  void clear_end_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& end_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_end_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_end_time();
  void set_allocated_end_time(::PROTOBUF_NAMESPACE_ID::Timestamp* end_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_end_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_end_time();
  public:
  void unsafe_arena_set_allocated_end_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_end_time();

  // int32 limit = 5;
  void clear_limit();
  int32_t limit() const;
  void set_limit(int32_t value);
  private:
  int32_t _internal_limit() const;
  void _internal_set_limit(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.observability.v1.TraceQuery)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trace_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time_;
    int32_t limit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_observability_2eproto;
};
// -------------------------------------------------------------------

class TraceQueryResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.observability.v1.TraceQueryResponse) */ {
 public:
  inline TraceQueryResponse() : TraceQueryResponse(nullptr) {}
  ~TraceQueryResponse() override;
  explicit PROTOBUF_CONSTEXPR TraceQueryResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TraceQueryResponse(const TraceQueryResponse& from);
  TraceQueryResponse(TraceQueryResponse&& from) noexcept
    : TraceQueryResponse() {
    *this = ::std::move(from);
  }

  inline TraceQueryResponse& operator=(const TraceQueryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TraceQueryResponse& operator=(TraceQueryResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TraceQueryResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TraceQueryResponse* internal_default_instance() {
    return reinterpret_cast<const TraceQueryResponse*>(
               &_TraceQueryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  friend void swap(TraceQueryResponse& a, TraceQueryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TraceQueryResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TraceQueryResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TraceQueryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TraceQueryResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TraceQueryResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TraceQueryResponse& from) {
    TraceQueryResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TraceQueryResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.observability.v1.TraceQueryResponse";
  }
  protected:
  explicit TraceQueryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTracesFieldNumber = 1,
  };
  // repeated .unhinged.observability.v1.TraceEvent traces = 1;
  int traces_size() const;
  private:
  int _internal_traces_size() const;
  public:
  void clear_traces();
  ::unhinged::observability::v1::TraceEvent* mutable_traces(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::TraceEvent >*
      mutable_traces();
  private:
  const ::unhinged::observability::v1::TraceEvent& _internal_traces(int index) const;
  ::unhinged::observability::v1::TraceEvent* _internal_add_traces();
  public:
  const ::unhinged::observability::v1::TraceEvent& traces(int index) const;
  ::unhinged::observability::v1::TraceEvent* add_traces();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::TraceEvent >&
      traces() const;

  // @@protoc_insertion_point(class_scope:unhinged.observability.v1.TraceQueryResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::TraceEvent > traces_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_observability_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TraceContext

// string trace_id = 1;
inline void TraceContext::clear_trace_id() {
  _impl_.trace_id_.ClearToEmpty();
}
inline const std::string& TraceContext::trace_id() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.TraceContext.trace_id)
  return _internal_trace_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TraceContext::set_trace_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.trace_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.TraceContext.trace_id)
}
inline std::string* TraceContext::mutable_trace_id() {
  std::string* _s = _internal_mutable_trace_id();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.TraceContext.trace_id)
  return _s;
}
inline const std::string& TraceContext::_internal_trace_id() const {
  return _impl_.trace_id_.Get();
}
inline void TraceContext::_internal_set_trace_id(const std::string& value) {
  
  _impl_.trace_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TraceContext::_internal_mutable_trace_id() {
  
  return _impl_.trace_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TraceContext::release_trace_id() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.TraceContext.trace_id)
  return _impl_.trace_id_.Release();
}
inline void TraceContext::set_allocated_trace_id(std::string* trace_id) {
  if (trace_id != nullptr) {
    
  } else {
    
  }
  _impl_.trace_id_.SetAllocated(trace_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.trace_id_.IsDefault()) {
    _impl_.trace_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.TraceContext.trace_id)
}

// string span_id = 2;
inline void TraceContext::clear_span_id() {
  _impl_.span_id_.ClearToEmpty();
}
inline const std::string& TraceContext::span_id() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.TraceContext.span_id)
  return _internal_span_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TraceContext::set_span_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.span_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.TraceContext.span_id)
}
inline std::string* TraceContext::mutable_span_id() {
  std::string* _s = _internal_mutable_span_id();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.TraceContext.span_id)
  return _s;
}
inline const std::string& TraceContext::_internal_span_id() const {
  return _impl_.span_id_.Get();
}
inline void TraceContext::_internal_set_span_id(const std::string& value) {
  
  _impl_.span_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TraceContext::_internal_mutable_span_id() {
  
  return _impl_.span_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TraceContext::release_span_id() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.TraceContext.span_id)
  return _impl_.span_id_.Release();
}
inline void TraceContext::set_allocated_span_id(std::string* span_id) {
  if (span_id != nullptr) {
    
  } else {
    
  }
  _impl_.span_id_.SetAllocated(span_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.span_id_.IsDefault()) {
    _impl_.span_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.TraceContext.span_id)
}

// string parent_span_id = 3;
inline void TraceContext::clear_parent_span_id() {
  _impl_.parent_span_id_.ClearToEmpty();
}
inline const std::string& TraceContext::parent_span_id() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.TraceContext.parent_span_id)
  return _internal_parent_span_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TraceContext::set_parent_span_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.parent_span_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.TraceContext.parent_span_id)
}
inline std::string* TraceContext::mutable_parent_span_id() {
  std::string* _s = _internal_mutable_parent_span_id();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.TraceContext.parent_span_id)
  return _s;
}
inline const std::string& TraceContext::_internal_parent_span_id() const {
  return _impl_.parent_span_id_.Get();
}
inline void TraceContext::_internal_set_parent_span_id(const std::string& value) {
  
  _impl_.parent_span_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TraceContext::_internal_mutable_parent_span_id() {
  
  return _impl_.parent_span_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TraceContext::release_parent_span_id() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.TraceContext.parent_span_id)
  return _impl_.parent_span_id_.Release();
}
inline void TraceContext::set_allocated_parent_span_id(std::string* parent_span_id) {
  if (parent_span_id != nullptr) {
    
  } else {
    
  }
  _impl_.parent_span_id_.SetAllocated(parent_span_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parent_span_id_.IsDefault()) {
    _impl_.parent_span_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.TraceContext.parent_span_id)
}

// .unhinged.observability.v1.TraceFlags trace_flags = 4;
inline bool TraceContext::_internal_has_trace_flags() const {
  return this != internal_default_instance() && _impl_.trace_flags_ != nullptr;
}
inline bool TraceContext::has_trace_flags() const {
  return _internal_has_trace_flags();
}
inline void TraceContext::clear_trace_flags() {
  if (GetArenaForAllocation() == nullptr && _impl_.trace_flags_ != nullptr) {
    delete _impl_.trace_flags_;
  }
  _impl_.trace_flags_ = nullptr;
}
inline const ::unhinged::observability::v1::TraceFlags& TraceContext::_internal_trace_flags() const {
  const ::unhinged::observability::v1::TraceFlags* p = _impl_.trace_flags_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::observability::v1::TraceFlags&>(
      ::unhinged::observability::v1::_TraceFlags_default_instance_);
}
inline const ::unhinged::observability::v1::TraceFlags& TraceContext::trace_flags() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.TraceContext.trace_flags)
  return _internal_trace_flags();
}
inline void TraceContext::unsafe_arena_set_allocated_trace_flags(
    ::unhinged::observability::v1::TraceFlags* trace_flags) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.trace_flags_);
  }
  _impl_.trace_flags_ = trace_flags;
  if (trace_flags) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.TraceContext.trace_flags)
}
inline ::unhinged::observability::v1::TraceFlags* TraceContext::release_trace_flags() {
  
  ::unhinged::observability::v1::TraceFlags* temp = _impl_.trace_flags_;
  _impl_.trace_flags_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::observability::v1::TraceFlags* TraceContext::unsafe_arena_release_trace_flags() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.TraceContext.trace_flags)
  
  ::unhinged::observability::v1::TraceFlags* temp = _impl_.trace_flags_;
  _impl_.trace_flags_ = nullptr;
  return temp;
}
inline ::unhinged::observability::v1::TraceFlags* TraceContext::_internal_mutable_trace_flags() {
  
  if (_impl_.trace_flags_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::observability::v1::TraceFlags>(GetArenaForAllocation());
    _impl_.trace_flags_ = p;
  }
  return _impl_.trace_flags_;
}
inline ::unhinged::observability::v1::TraceFlags* TraceContext::mutable_trace_flags() {
  ::unhinged::observability::v1::TraceFlags* _msg = _internal_mutable_trace_flags();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.TraceContext.trace_flags)
  return _msg;
}
inline void TraceContext::set_allocated_trace_flags(::unhinged::observability::v1::TraceFlags* trace_flags) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.trace_flags_;
  }
  if (trace_flags) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(trace_flags);
    if (message_arena != submessage_arena) {
      trace_flags = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trace_flags, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.trace_flags_ = trace_flags;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.TraceContext.trace_flags)
}

// string trace_state = 5;
inline void TraceContext::clear_trace_state() {
  _impl_.trace_state_.ClearToEmpty();
}
inline const std::string& TraceContext::trace_state() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.TraceContext.trace_state)
  return _internal_trace_state();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TraceContext::set_trace_state(ArgT0&& arg0, ArgT... args) {
 
 _impl_.trace_state_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.TraceContext.trace_state)
}
inline std::string* TraceContext::mutable_trace_state() {
  std::string* _s = _internal_mutable_trace_state();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.TraceContext.trace_state)
  return _s;
}
inline const std::string& TraceContext::_internal_trace_state() const {
  return _impl_.trace_state_.Get();
}
inline void TraceContext::_internal_set_trace_state(const std::string& value) {
  
  _impl_.trace_state_.Set(value, GetArenaForAllocation());
}
inline std::string* TraceContext::_internal_mutable_trace_state() {
  
  return _impl_.trace_state_.Mutable(GetArenaForAllocation());
}
inline std::string* TraceContext::release_trace_state() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.TraceContext.trace_state)
  return _impl_.trace_state_.Release();
}
inline void TraceContext::set_allocated_trace_state(std::string* trace_state) {
  if (trace_state != nullptr) {
    
  } else {
    
  }
  _impl_.trace_state_.SetAllocated(trace_state, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.trace_state_.IsDefault()) {
    _impl_.trace_state_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.TraceContext.trace_state)
}

// string correlation_id = 10;
inline void TraceContext::clear_correlation_id() {
  _impl_.correlation_id_.ClearToEmpty();
}
inline const std::string& TraceContext::correlation_id() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.TraceContext.correlation_id)
  return _internal_correlation_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TraceContext::set_correlation_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.correlation_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.TraceContext.correlation_id)
}
inline std::string* TraceContext::mutable_correlation_id() {
  std::string* _s = _internal_mutable_correlation_id();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.TraceContext.correlation_id)
  return _s;
}
inline const std::string& TraceContext::_internal_correlation_id() const {
  return _impl_.correlation_id_.Get();
}
inline void TraceContext::_internal_set_correlation_id(const std::string& value) {
  
  _impl_.correlation_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TraceContext::_internal_mutable_correlation_id() {
  
  return _impl_.correlation_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TraceContext::release_correlation_id() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.TraceContext.correlation_id)
  return _impl_.correlation_id_.Release();
}
inline void TraceContext::set_allocated_correlation_id(std::string* correlation_id) {
  if (correlation_id != nullptr) {
    
  } else {
    
  }
  _impl_.correlation_id_.SetAllocated(correlation_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.correlation_id_.IsDefault()) {
    _impl_.correlation_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.TraceContext.correlation_id)
}

// string request_id = 11;
inline void TraceContext::clear_request_id() {
  _impl_.request_id_.ClearToEmpty();
}
inline const std::string& TraceContext::request_id() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.TraceContext.request_id)
  return _internal_request_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TraceContext::set_request_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.request_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.TraceContext.request_id)
}
inline std::string* TraceContext::mutable_request_id() {
  std::string* _s = _internal_mutable_request_id();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.TraceContext.request_id)
  return _s;
}
inline const std::string& TraceContext::_internal_request_id() const {
  return _impl_.request_id_.Get();
}
inline void TraceContext::_internal_set_request_id(const std::string& value) {
  
  _impl_.request_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TraceContext::_internal_mutable_request_id() {
  
  return _impl_.request_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TraceContext::release_request_id() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.TraceContext.request_id)
  return _impl_.request_id_.Release();
}
inline void TraceContext::set_allocated_request_id(std::string* request_id) {
  if (request_id != nullptr) {
    
  } else {
    
  }
  _impl_.request_id_.SetAllocated(request_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.request_id_.IsDefault()) {
    _impl_.request_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.TraceContext.request_id)
}

// string session_id = 12;
inline void TraceContext::clear_session_id() {
  _impl_.session_id_.ClearToEmpty();
}
inline const std::string& TraceContext::session_id() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.TraceContext.session_id)
  return _internal_session_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TraceContext::set_session_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.session_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.TraceContext.session_id)
}
inline std::string* TraceContext::mutable_session_id() {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.TraceContext.session_id)
  return _s;
}
inline const std::string& TraceContext::_internal_session_id() const {
  return _impl_.session_id_.Get();
}
inline void TraceContext::_internal_set_session_id(const std::string& value) {
  
  _impl_.session_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TraceContext::_internal_mutable_session_id() {
  
  return _impl_.session_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TraceContext::release_session_id() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.TraceContext.session_id)
  return _impl_.session_id_.Release();
}
inline void TraceContext::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  _impl_.session_id_.SetAllocated(session_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.session_id_.IsDefault()) {
    _impl_.session_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.TraceContext.session_id)
}

// string user_id = 13;
inline void TraceContext::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& TraceContext::user_id() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.TraceContext.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TraceContext::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.TraceContext.user_id)
}
inline std::string* TraceContext::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.TraceContext.user_id)
  return _s;
}
inline const std::string& TraceContext::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void TraceContext::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TraceContext::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TraceContext::release_user_id() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.TraceContext.user_id)
  return _impl_.user_id_.Release();
}
inline void TraceContext::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.TraceContext.user_id)
}

// -------------------------------------------------------------------

// TraceFlags

// bool sampled = 1;
inline void TraceFlags::clear_sampled() {
  _impl_.sampled_ = false;
}
inline bool TraceFlags::_internal_sampled() const {
  return _impl_.sampled_;
}
inline bool TraceFlags::sampled() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.TraceFlags.sampled)
  return _internal_sampled();
}
inline void TraceFlags::_internal_set_sampled(bool value) {
  
  _impl_.sampled_ = value;
}
inline void TraceFlags::set_sampled(bool value) {
  _internal_set_sampled(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.TraceFlags.sampled)
}

// bool random_trace_id = 2;
inline void TraceFlags::clear_random_trace_id() {
  _impl_.random_trace_id_ = false;
}
inline bool TraceFlags::_internal_random_trace_id() const {
  return _impl_.random_trace_id_;
}
inline bool TraceFlags::random_trace_id() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.TraceFlags.random_trace_id)
  return _internal_random_trace_id();
}
inline void TraceFlags::_internal_set_random_trace_id(bool value) {
  
  _impl_.random_trace_id_ = value;
}
inline void TraceFlags::set_random_trace_id(bool value) {
  _internal_set_random_trace_id(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.TraceFlags.random_trace_id)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Resource

// string service_name = 1;
inline void Resource::clear_service_name() {
  _impl_.service_name_.ClearToEmpty();
}
inline const std::string& Resource::service_name() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.Resource.service_name)
  return _internal_service_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Resource::set_service_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.Resource.service_name)
}
inline std::string* Resource::mutable_service_name() {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.Resource.service_name)
  return _s;
}
inline const std::string& Resource::_internal_service_name() const {
  return _impl_.service_name_.Get();
}
inline void Resource::_internal_set_service_name(const std::string& value) {
  
  _impl_.service_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Resource::_internal_mutable_service_name() {
  
  return _impl_.service_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Resource::release_service_name() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.Resource.service_name)
  return _impl_.service_name_.Release();
}
inline void Resource::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  _impl_.service_name_.SetAllocated(service_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_name_.IsDefault()) {
    _impl_.service_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.Resource.service_name)
}

// string service_version = 2;
inline void Resource::clear_service_version() {
  _impl_.service_version_.ClearToEmpty();
}
inline const std::string& Resource::service_version() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.Resource.service_version)
  return _internal_service_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Resource::set_service_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.Resource.service_version)
}
inline std::string* Resource::mutable_service_version() {
  std::string* _s = _internal_mutable_service_version();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.Resource.service_version)
  return _s;
}
inline const std::string& Resource::_internal_service_version() const {
  return _impl_.service_version_.Get();
}
inline void Resource::_internal_set_service_version(const std::string& value) {
  
  _impl_.service_version_.Set(value, GetArenaForAllocation());
}
inline std::string* Resource::_internal_mutable_service_version() {
  
  return _impl_.service_version_.Mutable(GetArenaForAllocation());
}
inline std::string* Resource::release_service_version() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.Resource.service_version)
  return _impl_.service_version_.Release();
}
inline void Resource::set_allocated_service_version(std::string* service_version) {
  if (service_version != nullptr) {
    
  } else {
    
  }
  _impl_.service_version_.SetAllocated(service_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_version_.IsDefault()) {
    _impl_.service_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.Resource.service_version)
}

// string service_instance_id = 3;
inline void Resource::clear_service_instance_id() {
  _impl_.service_instance_id_.ClearToEmpty();
}
inline const std::string& Resource::service_instance_id() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.Resource.service_instance_id)
  return _internal_service_instance_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Resource::set_service_instance_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_instance_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.Resource.service_instance_id)
}
inline std::string* Resource::mutable_service_instance_id() {
  std::string* _s = _internal_mutable_service_instance_id();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.Resource.service_instance_id)
  return _s;
}
inline const std::string& Resource::_internal_service_instance_id() const {
  return _impl_.service_instance_id_.Get();
}
inline void Resource::_internal_set_service_instance_id(const std::string& value) {
  
  _impl_.service_instance_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Resource::_internal_mutable_service_instance_id() {
  
  return _impl_.service_instance_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Resource::release_service_instance_id() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.Resource.service_instance_id)
  return _impl_.service_instance_id_.Release();
}
inline void Resource::set_allocated_service_instance_id(std::string* service_instance_id) {
  if (service_instance_id != nullptr) {
    
  } else {
    
  }
  _impl_.service_instance_id_.SetAllocated(service_instance_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_instance_id_.IsDefault()) {
    _impl_.service_instance_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.Resource.service_instance_id)
}

// string deployment_environment = 4;
inline void Resource::clear_deployment_environment() {
  _impl_.deployment_environment_.ClearToEmpty();
}
inline const std::string& Resource::deployment_environment() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.Resource.deployment_environment)
  return _internal_deployment_environment();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Resource::set_deployment_environment(ArgT0&& arg0, ArgT... args) {
 
 _impl_.deployment_environment_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.Resource.deployment_environment)
}
inline std::string* Resource::mutable_deployment_environment() {
  std::string* _s = _internal_mutable_deployment_environment();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.Resource.deployment_environment)
  return _s;
}
inline const std::string& Resource::_internal_deployment_environment() const {
  return _impl_.deployment_environment_.Get();
}
inline void Resource::_internal_set_deployment_environment(const std::string& value) {
  
  _impl_.deployment_environment_.Set(value, GetArenaForAllocation());
}
inline std::string* Resource::_internal_mutable_deployment_environment() {
  
  return _impl_.deployment_environment_.Mutable(GetArenaForAllocation());
}
inline std::string* Resource::release_deployment_environment() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.Resource.deployment_environment)
  return _impl_.deployment_environment_.Release();
}
inline void Resource::set_allocated_deployment_environment(std::string* deployment_environment) {
  if (deployment_environment != nullptr) {
    
  } else {
    
  }
  _impl_.deployment_environment_.SetAllocated(deployment_environment, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.deployment_environment_.IsDefault()) {
    _impl_.deployment_environment_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.Resource.deployment_environment)
}

// string k8s_cluster_name = 5;
inline void Resource::clear_k8s_cluster_name() {
  _impl_.k8s_cluster_name_.ClearToEmpty();
}
inline const std::string& Resource::k8s_cluster_name() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.Resource.k8s_cluster_name)
  return _internal_k8s_cluster_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Resource::set_k8s_cluster_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.k8s_cluster_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.Resource.k8s_cluster_name)
}
inline std::string* Resource::mutable_k8s_cluster_name() {
  std::string* _s = _internal_mutable_k8s_cluster_name();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.Resource.k8s_cluster_name)
  return _s;
}
inline const std::string& Resource::_internal_k8s_cluster_name() const {
  return _impl_.k8s_cluster_name_.Get();
}
inline void Resource::_internal_set_k8s_cluster_name(const std::string& value) {
  
  _impl_.k8s_cluster_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Resource::_internal_mutable_k8s_cluster_name() {
  
  return _impl_.k8s_cluster_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Resource::release_k8s_cluster_name() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.Resource.k8s_cluster_name)
  return _impl_.k8s_cluster_name_.Release();
}
inline void Resource::set_allocated_k8s_cluster_name(std::string* k8s_cluster_name) {
  if (k8s_cluster_name != nullptr) {
    
  } else {
    
  }
  _impl_.k8s_cluster_name_.SetAllocated(k8s_cluster_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.k8s_cluster_name_.IsDefault()) {
    _impl_.k8s_cluster_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.Resource.k8s_cluster_name)
}

// string k8s_namespace = 6;
inline void Resource::clear_k8s_namespace() {
  _impl_.k8s_namespace_.ClearToEmpty();
}
inline const std::string& Resource::k8s_namespace() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.Resource.k8s_namespace)
  return _internal_k8s_namespace();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Resource::set_k8s_namespace(ArgT0&& arg0, ArgT... args) {
 
 _impl_.k8s_namespace_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.Resource.k8s_namespace)
}
inline std::string* Resource::mutable_k8s_namespace() {
  std::string* _s = _internal_mutable_k8s_namespace();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.Resource.k8s_namespace)
  return _s;
}
inline const std::string& Resource::_internal_k8s_namespace() const {
  return _impl_.k8s_namespace_.Get();
}
inline void Resource::_internal_set_k8s_namespace(const std::string& value) {
  
  _impl_.k8s_namespace_.Set(value, GetArenaForAllocation());
}
inline std::string* Resource::_internal_mutable_k8s_namespace() {
  
  return _impl_.k8s_namespace_.Mutable(GetArenaForAllocation());
}
inline std::string* Resource::release_k8s_namespace() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.Resource.k8s_namespace)
  return _impl_.k8s_namespace_.Release();
}
inline void Resource::set_allocated_k8s_namespace(std::string* k8s_namespace) {
  if (k8s_namespace != nullptr) {
    
  } else {
    
  }
  _impl_.k8s_namespace_.SetAllocated(k8s_namespace, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.k8s_namespace_.IsDefault()) {
    _impl_.k8s_namespace_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.Resource.k8s_namespace)
}

// string k8s_pod_name = 7;
inline void Resource::clear_k8s_pod_name() {
  _impl_.k8s_pod_name_.ClearToEmpty();
}
inline const std::string& Resource::k8s_pod_name() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.Resource.k8s_pod_name)
  return _internal_k8s_pod_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Resource::set_k8s_pod_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.k8s_pod_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.Resource.k8s_pod_name)
}
inline std::string* Resource::mutable_k8s_pod_name() {
  std::string* _s = _internal_mutable_k8s_pod_name();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.Resource.k8s_pod_name)
  return _s;
}
inline const std::string& Resource::_internal_k8s_pod_name() const {
  return _impl_.k8s_pod_name_.Get();
}
inline void Resource::_internal_set_k8s_pod_name(const std::string& value) {
  
  _impl_.k8s_pod_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Resource::_internal_mutable_k8s_pod_name() {
  
  return _impl_.k8s_pod_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Resource::release_k8s_pod_name() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.Resource.k8s_pod_name)
  return _impl_.k8s_pod_name_.Release();
}
inline void Resource::set_allocated_k8s_pod_name(std::string* k8s_pod_name) {
  if (k8s_pod_name != nullptr) {
    
  } else {
    
  }
  _impl_.k8s_pod_name_.SetAllocated(k8s_pod_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.k8s_pod_name_.IsDefault()) {
    _impl_.k8s_pod_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.Resource.k8s_pod_name)
}

// string host_name = 8;
inline void Resource::clear_host_name() {
  _impl_.host_name_.ClearToEmpty();
}
inline const std::string& Resource::host_name() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.Resource.host_name)
  return _internal_host_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Resource::set_host_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.host_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.Resource.host_name)
}
inline std::string* Resource::mutable_host_name() {
  std::string* _s = _internal_mutable_host_name();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.Resource.host_name)
  return _s;
}
inline const std::string& Resource::_internal_host_name() const {
  return _impl_.host_name_.Get();
}
inline void Resource::_internal_set_host_name(const std::string& value) {
  
  _impl_.host_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Resource::_internal_mutable_host_name() {
  
  return _impl_.host_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Resource::release_host_name() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.Resource.host_name)
  return _impl_.host_name_.Release();
}
inline void Resource::set_allocated_host_name(std::string* host_name) {
  if (host_name != nullptr) {
    
  } else {
    
  }
  _impl_.host_name_.SetAllocated(host_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.host_name_.IsDefault()) {
    _impl_.host_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.Resource.host_name)
}

// string host_arch = 9;
inline void Resource::clear_host_arch() {
  _impl_.host_arch_.ClearToEmpty();
}
inline const std::string& Resource::host_arch() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.Resource.host_arch)
  return _internal_host_arch();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Resource::set_host_arch(ArgT0&& arg0, ArgT... args) {
 
 _impl_.host_arch_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.Resource.host_arch)
}
inline std::string* Resource::mutable_host_arch() {
  std::string* _s = _internal_mutable_host_arch();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.Resource.host_arch)
  return _s;
}
inline const std::string& Resource::_internal_host_arch() const {
  return _impl_.host_arch_.Get();
}
inline void Resource::_internal_set_host_arch(const std::string& value) {
  
  _impl_.host_arch_.Set(value, GetArenaForAllocation());
}
inline std::string* Resource::_internal_mutable_host_arch() {
  
  return _impl_.host_arch_.Mutable(GetArenaForAllocation());
}
inline std::string* Resource::release_host_arch() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.Resource.host_arch)
  return _impl_.host_arch_.Release();
}
inline void Resource::set_allocated_host_arch(std::string* host_arch) {
  if (host_arch != nullptr) {
    
  } else {
    
  }
  _impl_.host_arch_.SetAllocated(host_arch, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.host_arch_.IsDefault()) {
    _impl_.host_arch_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.Resource.host_arch)
}

// map<string, string> attributes = 20;
inline int Resource::_internal_attributes_size() const {
  return _impl_.attributes_.size();
}
inline int Resource::attributes_size() const {
  return _internal_attributes_size();
}
inline void Resource::clear_attributes() {
  _impl_.attributes_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Resource::_internal_attributes() const {
  return _impl_.attributes_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Resource::attributes() const {
  // @@protoc_insertion_point(field_map:unhinged.observability.v1.Resource.attributes)
  return _internal_attributes();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Resource::_internal_mutable_attributes() {
  return _impl_.attributes_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Resource::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_map:unhinged.observability.v1.Resource.attributes)
  return _internal_mutable_attributes();
}

// -------------------------------------------------------------------

// LogEvent

// string event_id = 1;
inline void LogEvent::clear_event_id() {
  _impl_.event_id_.ClearToEmpty();
}
inline const std::string& LogEvent::event_id() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.LogEvent.event_id)
  return _internal_event_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogEvent::set_event_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.event_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.LogEvent.event_id)
}
inline std::string* LogEvent::mutable_event_id() {
  std::string* _s = _internal_mutable_event_id();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.LogEvent.event_id)
  return _s;
}
inline const std::string& LogEvent::_internal_event_id() const {
  return _impl_.event_id_.Get();
}
inline void LogEvent::_internal_set_event_id(const std::string& value) {
  
  _impl_.event_id_.Set(value, GetArenaForAllocation());
}
inline std::string* LogEvent::_internal_mutable_event_id() {
  
  return _impl_.event_id_.Mutable(GetArenaForAllocation());
}
inline std::string* LogEvent::release_event_id() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.LogEvent.event_id)
  return _impl_.event_id_.Release();
}
inline void LogEvent::set_allocated_event_id(std::string* event_id) {
  if (event_id != nullptr) {
    
  } else {
    
  }
  _impl_.event_id_.SetAllocated(event_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.event_id_.IsDefault()) {
    _impl_.event_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.LogEvent.event_id)
}

// .google.protobuf.Timestamp timestamp = 2;
inline bool LogEvent::_internal_has_timestamp() const {
  return this != internal_default_instance() && _impl_.timestamp_ != nullptr;
}
inline bool LogEvent::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& LogEvent::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& LogEvent::timestamp() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.LogEvent.timestamp)
  return _internal_timestamp();
}
inline void LogEvent::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.LogEvent.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LogEvent::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LogEvent::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.LogEvent.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LogEvent::_internal_mutable_timestamp() {
  
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LogEvent::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.LogEvent.timestamp)
  return _msg;
}
inline void LogEvent::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.LogEvent.timestamp)
}

// string event_type = 3;
inline void LogEvent::clear_event_type() {
  _impl_.event_type_.ClearToEmpty();
}
inline const std::string& LogEvent::event_type() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.LogEvent.event_type)
  return _internal_event_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogEvent::set_event_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.event_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.LogEvent.event_type)
}
inline std::string* LogEvent::mutable_event_type() {
  std::string* _s = _internal_mutable_event_type();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.LogEvent.event_type)
  return _s;
}
inline const std::string& LogEvent::_internal_event_type() const {
  return _impl_.event_type_.Get();
}
inline void LogEvent::_internal_set_event_type(const std::string& value) {
  
  _impl_.event_type_.Set(value, GetArenaForAllocation());
}
inline std::string* LogEvent::_internal_mutable_event_type() {
  
  return _impl_.event_type_.Mutable(GetArenaForAllocation());
}
inline std::string* LogEvent::release_event_type() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.LogEvent.event_type)
  return _impl_.event_type_.Release();
}
inline void LogEvent::set_allocated_event_type(std::string* event_type) {
  if (event_type != nullptr) {
    
  } else {
    
  }
  _impl_.event_type_.SetAllocated(event_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.event_type_.IsDefault()) {
    _impl_.event_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.LogEvent.event_type)
}

// int64 sequence_number = 4;
inline void LogEvent::clear_sequence_number() {
  _impl_.sequence_number_ = int64_t{0};
}
inline int64_t LogEvent::_internal_sequence_number() const {
  return _impl_.sequence_number_;
}
inline int64_t LogEvent::sequence_number() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.LogEvent.sequence_number)
  return _internal_sequence_number();
}
inline void LogEvent::_internal_set_sequence_number(int64_t value) {
  
  _impl_.sequence_number_ = value;
}
inline void LogEvent::set_sequence_number(int64_t value) {
  _internal_set_sequence_number(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.LogEvent.sequence_number)
}

// .unhinged.observability.v1.TraceContext trace_context = 5;
inline bool LogEvent::_internal_has_trace_context() const {
  return this != internal_default_instance() && _impl_.trace_context_ != nullptr;
}
inline bool LogEvent::has_trace_context() const {
  return _internal_has_trace_context();
}
inline void LogEvent::clear_trace_context() {
  if (GetArenaForAllocation() == nullptr && _impl_.trace_context_ != nullptr) {
    delete _impl_.trace_context_;
  }
  _impl_.trace_context_ = nullptr;
}
inline const ::unhinged::observability::v1::TraceContext& LogEvent::_internal_trace_context() const {
  const ::unhinged::observability::v1::TraceContext* p = _impl_.trace_context_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::observability::v1::TraceContext&>(
      ::unhinged::observability::v1::_TraceContext_default_instance_);
}
inline const ::unhinged::observability::v1::TraceContext& LogEvent::trace_context() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.LogEvent.trace_context)
  return _internal_trace_context();
}
inline void LogEvent::unsafe_arena_set_allocated_trace_context(
    ::unhinged::observability::v1::TraceContext* trace_context) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.trace_context_);
  }
  _impl_.trace_context_ = trace_context;
  if (trace_context) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.LogEvent.trace_context)
}
inline ::unhinged::observability::v1::TraceContext* LogEvent::release_trace_context() {
  
  ::unhinged::observability::v1::TraceContext* temp = _impl_.trace_context_;
  _impl_.trace_context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::observability::v1::TraceContext* LogEvent::unsafe_arena_release_trace_context() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.LogEvent.trace_context)
  
  ::unhinged::observability::v1::TraceContext* temp = _impl_.trace_context_;
  _impl_.trace_context_ = nullptr;
  return temp;
}
inline ::unhinged::observability::v1::TraceContext* LogEvent::_internal_mutable_trace_context() {
  
  if (_impl_.trace_context_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::observability::v1::TraceContext>(GetArenaForAllocation());
    _impl_.trace_context_ = p;
  }
  return _impl_.trace_context_;
}
inline ::unhinged::observability::v1::TraceContext* LogEvent::mutable_trace_context() {
  ::unhinged::observability::v1::TraceContext* _msg = _internal_mutable_trace_context();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.LogEvent.trace_context)
  return _msg;
}
inline void LogEvent::set_allocated_trace_context(::unhinged::observability::v1::TraceContext* trace_context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.trace_context_;
  }
  if (trace_context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(trace_context);
    if (message_arena != submessage_arena) {
      trace_context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trace_context, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.trace_context_ = trace_context;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.LogEvent.trace_context)
}

// .unhinged.observability.v1.Resource resource = 6;
inline bool LogEvent::_internal_has_resource() const {
  return this != internal_default_instance() && _impl_.resource_ != nullptr;
}
inline bool LogEvent::has_resource() const {
  return _internal_has_resource();
}
inline void LogEvent::clear_resource() {
  if (GetArenaForAllocation() == nullptr && _impl_.resource_ != nullptr) {
    delete _impl_.resource_;
  }
  _impl_.resource_ = nullptr;
}
inline const ::unhinged::observability::v1::Resource& LogEvent::_internal_resource() const {
  const ::unhinged::observability::v1::Resource* p = _impl_.resource_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::observability::v1::Resource&>(
      ::unhinged::observability::v1::_Resource_default_instance_);
}
inline const ::unhinged::observability::v1::Resource& LogEvent::resource() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.LogEvent.resource)
  return _internal_resource();
}
inline void LogEvent::unsafe_arena_set_allocated_resource(
    ::unhinged::observability::v1::Resource* resource) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.resource_);
  }
  _impl_.resource_ = resource;
  if (resource) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.LogEvent.resource)
}
inline ::unhinged::observability::v1::Resource* LogEvent::release_resource() {
  
  ::unhinged::observability::v1::Resource* temp = _impl_.resource_;
  _impl_.resource_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::observability::v1::Resource* LogEvent::unsafe_arena_release_resource() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.LogEvent.resource)
  
  ::unhinged::observability::v1::Resource* temp = _impl_.resource_;
  _impl_.resource_ = nullptr;
  return temp;
}
inline ::unhinged::observability::v1::Resource* LogEvent::_internal_mutable_resource() {
  
  if (_impl_.resource_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::observability::v1::Resource>(GetArenaForAllocation());
    _impl_.resource_ = p;
  }
  return _impl_.resource_;
}
inline ::unhinged::observability::v1::Resource* LogEvent::mutable_resource() {
  ::unhinged::observability::v1::Resource* _msg = _internal_mutable_resource();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.LogEvent.resource)
  return _msg;
}
inline void LogEvent::set_allocated_resource(::unhinged::observability::v1::Resource* resource) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.resource_;
  }
  if (resource) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(resource);
    if (message_arena != submessage_arena) {
      resource = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, resource, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.resource_ = resource;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.LogEvent.resource)
}

// .unhinged.observability.v1.LogLevel level = 10;
inline void LogEvent::clear_level() {
  _impl_.level_ = 0;
}
inline ::unhinged::observability::v1::LogLevel LogEvent::_internal_level() const {
  return static_cast< ::unhinged::observability::v1::LogLevel >(_impl_.level_);
}
inline ::unhinged::observability::v1::LogLevel LogEvent::level() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.LogEvent.level)
  return _internal_level();
}
inline void LogEvent::_internal_set_level(::unhinged::observability::v1::LogLevel value) {
  
  _impl_.level_ = value;
}
inline void LogEvent::set_level(::unhinged::observability::v1::LogLevel value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.LogEvent.level)
}

// string message = 11;
inline void LogEvent::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& LogEvent::message() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.LogEvent.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogEvent::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.LogEvent.message)
}
inline std::string* LogEvent::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.LogEvent.message)
  return _s;
}
inline const std::string& LogEvent::_internal_message() const {
  return _impl_.message_.Get();
}
inline void LogEvent::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* LogEvent::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* LogEvent::release_message() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.LogEvent.message)
  return _impl_.message_.Release();
}
inline void LogEvent::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.LogEvent.message)
}

// .google.protobuf.Struct metadata = 12;
inline bool LogEvent::_internal_has_metadata() const {
  return this != internal_default_instance() && _impl_.metadata_ != nullptr;
}
inline bool LogEvent::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& LogEvent::_internal_metadata() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& LogEvent::metadata() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.LogEvent.metadata)
  return _internal_metadata();
}
inline void LogEvent::unsafe_arena_set_allocated_metadata(
    ::PROTOBUF_NAMESPACE_ID::Struct* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.LogEvent.metadata)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* LogEvent::release_metadata() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* LogEvent::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.LogEvent.metadata)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* LogEvent::_internal_mutable_metadata() {
  
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* LogEvent::mutable_metadata() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.LogEvent.metadata)
  return _msg;
}
inline void LogEvent::set_allocated_metadata(::PROTOBUF_NAMESPACE_ID::Struct* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.LogEvent.metadata)
}

// .unhinged.observability.v1.ErrorInfo error = 15;
inline bool LogEvent::_internal_has_error() const {
  return this != internal_default_instance() && _impl_.error_ != nullptr;
}
inline bool LogEvent::has_error() const {
  return _internal_has_error();
}
inline void LogEvent::clear_error() {
  if (GetArenaForAllocation() == nullptr && _impl_.error_ != nullptr) {
    delete _impl_.error_;
  }
  _impl_.error_ = nullptr;
}
inline const ::unhinged::observability::v1::ErrorInfo& LogEvent::_internal_error() const {
  const ::unhinged::observability::v1::ErrorInfo* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::observability::v1::ErrorInfo&>(
      ::unhinged::observability::v1::_ErrorInfo_default_instance_);
}
inline const ::unhinged::observability::v1::ErrorInfo& LogEvent::error() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.LogEvent.error)
  return _internal_error();
}
inline void LogEvent::unsafe_arena_set_allocated_error(
    ::unhinged::observability::v1::ErrorInfo* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.LogEvent.error)
}
inline ::unhinged::observability::v1::ErrorInfo* LogEvent::release_error() {
  
  ::unhinged::observability::v1::ErrorInfo* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::observability::v1::ErrorInfo* LogEvent::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.LogEvent.error)
  
  ::unhinged::observability::v1::ErrorInfo* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::unhinged::observability::v1::ErrorInfo* LogEvent::_internal_mutable_error() {
  
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::observability::v1::ErrorInfo>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::unhinged::observability::v1::ErrorInfo* LogEvent::mutable_error() {
  ::unhinged::observability::v1::ErrorInfo* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.LogEvent.error)
  return _msg;
}
inline void LogEvent::set_allocated_error(::unhinged::observability::v1::ErrorInfo* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.LogEvent.error)
}

// .unhinged.observability.v1.DestinationFlags destinations = 20;
inline bool LogEvent::_internal_has_destinations() const {
  return this != internal_default_instance() && _impl_.destinations_ != nullptr;
}
inline bool LogEvent::has_destinations() const {
  return _internal_has_destinations();
}
inline void LogEvent::clear_destinations() {
  if (GetArenaForAllocation() == nullptr && _impl_.destinations_ != nullptr) {
    delete _impl_.destinations_;
  }
  _impl_.destinations_ = nullptr;
}
inline const ::unhinged::observability::v1::DestinationFlags& LogEvent::_internal_destinations() const {
  const ::unhinged::observability::v1::DestinationFlags* p = _impl_.destinations_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::observability::v1::DestinationFlags&>(
      ::unhinged::observability::v1::_DestinationFlags_default_instance_);
}
inline const ::unhinged::observability::v1::DestinationFlags& LogEvent::destinations() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.LogEvent.destinations)
  return _internal_destinations();
}
inline void LogEvent::unsafe_arena_set_allocated_destinations(
    ::unhinged::observability::v1::DestinationFlags* destinations) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.destinations_);
  }
  _impl_.destinations_ = destinations;
  if (destinations) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.LogEvent.destinations)
}
inline ::unhinged::observability::v1::DestinationFlags* LogEvent::release_destinations() {
  
  ::unhinged::observability::v1::DestinationFlags* temp = _impl_.destinations_;
  _impl_.destinations_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::observability::v1::DestinationFlags* LogEvent::unsafe_arena_release_destinations() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.LogEvent.destinations)
  
  ::unhinged::observability::v1::DestinationFlags* temp = _impl_.destinations_;
  _impl_.destinations_ = nullptr;
  return temp;
}
inline ::unhinged::observability::v1::DestinationFlags* LogEvent::_internal_mutable_destinations() {
  
  if (_impl_.destinations_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::observability::v1::DestinationFlags>(GetArenaForAllocation());
    _impl_.destinations_ = p;
  }
  return _impl_.destinations_;
}
inline ::unhinged::observability::v1::DestinationFlags* LogEvent::mutable_destinations() {
  ::unhinged::observability::v1::DestinationFlags* _msg = _internal_mutable_destinations();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.LogEvent.destinations)
  return _msg;
}
inline void LogEvent::set_allocated_destinations(::unhinged::observability::v1::DestinationFlags* destinations) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.destinations_;
  }
  if (destinations) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(destinations);
    if (message_arena != submessage_arena) {
      destinations = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, destinations, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.destinations_ = destinations;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.LogEvent.destinations)
}

// .unhinged.observability.v1.PartitionInfo partition_info = 25;
inline bool LogEvent::_internal_has_partition_info() const {
  return this != internal_default_instance() && _impl_.partition_info_ != nullptr;
}
inline bool LogEvent::has_partition_info() const {
  return _internal_has_partition_info();
}
inline void LogEvent::clear_partition_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.partition_info_ != nullptr) {
    delete _impl_.partition_info_;
  }
  _impl_.partition_info_ = nullptr;
}
inline const ::unhinged::observability::v1::PartitionInfo& LogEvent::_internal_partition_info() const {
  const ::unhinged::observability::v1::PartitionInfo* p = _impl_.partition_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::observability::v1::PartitionInfo&>(
      ::unhinged::observability::v1::_PartitionInfo_default_instance_);
}
inline const ::unhinged::observability::v1::PartitionInfo& LogEvent::partition_info() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.LogEvent.partition_info)
  return _internal_partition_info();
}
inline void LogEvent::unsafe_arena_set_allocated_partition_info(
    ::unhinged::observability::v1::PartitionInfo* partition_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.partition_info_);
  }
  _impl_.partition_info_ = partition_info;
  if (partition_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.LogEvent.partition_info)
}
inline ::unhinged::observability::v1::PartitionInfo* LogEvent::release_partition_info() {
  
  ::unhinged::observability::v1::PartitionInfo* temp = _impl_.partition_info_;
  _impl_.partition_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::observability::v1::PartitionInfo* LogEvent::unsafe_arena_release_partition_info() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.LogEvent.partition_info)
  
  ::unhinged::observability::v1::PartitionInfo* temp = _impl_.partition_info_;
  _impl_.partition_info_ = nullptr;
  return temp;
}
inline ::unhinged::observability::v1::PartitionInfo* LogEvent::_internal_mutable_partition_info() {
  
  if (_impl_.partition_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::observability::v1::PartitionInfo>(GetArenaForAllocation());
    _impl_.partition_info_ = p;
  }
  return _impl_.partition_info_;
}
inline ::unhinged::observability::v1::PartitionInfo* LogEvent::mutable_partition_info() {
  ::unhinged::observability::v1::PartitionInfo* _msg = _internal_mutable_partition_info();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.LogEvent.partition_info)
  return _msg;
}
inline void LogEvent::set_allocated_partition_info(::unhinged::observability::v1::PartitionInfo* partition_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.partition_info_;
  }
  if (partition_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(partition_info);
    if (message_arena != submessage_arena) {
      partition_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, partition_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.partition_info_ = partition_info;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.LogEvent.partition_info)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ErrorInfo

// string error_type = 1;
inline void ErrorInfo::clear_error_type() {
  _impl_.error_type_.ClearToEmpty();
}
inline const std::string& ErrorInfo::error_type() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.ErrorInfo.error_type)
  return _internal_error_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ErrorInfo::set_error_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.ErrorInfo.error_type)
}
inline std::string* ErrorInfo::mutable_error_type() {
  std::string* _s = _internal_mutable_error_type();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.ErrorInfo.error_type)
  return _s;
}
inline const std::string& ErrorInfo::_internal_error_type() const {
  return _impl_.error_type_.Get();
}
inline void ErrorInfo::_internal_set_error_type(const std::string& value) {
  
  _impl_.error_type_.Set(value, GetArenaForAllocation());
}
inline std::string* ErrorInfo::_internal_mutable_error_type() {
  
  return _impl_.error_type_.Mutable(GetArenaForAllocation());
}
inline std::string* ErrorInfo::release_error_type() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.ErrorInfo.error_type)
  return _impl_.error_type_.Release();
}
inline void ErrorInfo::set_allocated_error_type(std::string* error_type) {
  if (error_type != nullptr) {
    
  } else {
    
  }
  _impl_.error_type_.SetAllocated(error_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_type_.IsDefault()) {
    _impl_.error_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.ErrorInfo.error_type)
}

// string error_message = 2;
inline void ErrorInfo::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& ErrorInfo::error_message() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.ErrorInfo.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ErrorInfo::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.ErrorInfo.error_message)
}
inline std::string* ErrorInfo::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.ErrorInfo.error_message)
  return _s;
}
inline const std::string& ErrorInfo::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void ErrorInfo::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* ErrorInfo::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* ErrorInfo::release_error_message() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.ErrorInfo.error_message)
  return _impl_.error_message_.Release();
}
inline void ErrorInfo::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.ErrorInfo.error_message)
}

// string stack_trace = 3;
inline void ErrorInfo::clear_stack_trace() {
  _impl_.stack_trace_.ClearToEmpty();
}
inline const std::string& ErrorInfo::stack_trace() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.ErrorInfo.stack_trace)
  return _internal_stack_trace();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ErrorInfo::set_stack_trace(ArgT0&& arg0, ArgT... args) {
 
 _impl_.stack_trace_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.ErrorInfo.stack_trace)
}
inline std::string* ErrorInfo::mutable_stack_trace() {
  std::string* _s = _internal_mutable_stack_trace();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.ErrorInfo.stack_trace)
  return _s;
}
inline const std::string& ErrorInfo::_internal_stack_trace() const {
  return _impl_.stack_trace_.Get();
}
inline void ErrorInfo::_internal_set_stack_trace(const std::string& value) {
  
  _impl_.stack_trace_.Set(value, GetArenaForAllocation());
}
inline std::string* ErrorInfo::_internal_mutable_stack_trace() {
  
  return _impl_.stack_trace_.Mutable(GetArenaForAllocation());
}
inline std::string* ErrorInfo::release_stack_trace() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.ErrorInfo.stack_trace)
  return _impl_.stack_trace_.Release();
}
inline void ErrorInfo::set_allocated_stack_trace(std::string* stack_trace) {
  if (stack_trace != nullptr) {
    
  } else {
    
  }
  _impl_.stack_trace_.SetAllocated(stack_trace, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stack_trace_.IsDefault()) {
    _impl_.stack_trace_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.ErrorInfo.stack_trace)
}

// string error_code = 4;
inline void ErrorInfo::clear_error_code() {
  _impl_.error_code_.ClearToEmpty();
}
inline const std::string& ErrorInfo::error_code() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.ErrorInfo.error_code)
  return _internal_error_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ErrorInfo::set_error_code(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.ErrorInfo.error_code)
}
inline std::string* ErrorInfo::mutable_error_code() {
  std::string* _s = _internal_mutable_error_code();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.ErrorInfo.error_code)
  return _s;
}
inline const std::string& ErrorInfo::_internal_error_code() const {
  return _impl_.error_code_.Get();
}
inline void ErrorInfo::_internal_set_error_code(const std::string& value) {
  
  _impl_.error_code_.Set(value, GetArenaForAllocation());
}
inline std::string* ErrorInfo::_internal_mutable_error_code() {
  
  return _impl_.error_code_.Mutable(GetArenaForAllocation());
}
inline std::string* ErrorInfo::release_error_code() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.ErrorInfo.error_code)
  return _impl_.error_code_.Release();
}
inline void ErrorInfo::set_allocated_error_code(std::string* error_code) {
  if (error_code != nullptr) {
    
  } else {
    
  }
  _impl_.error_code_.SetAllocated(error_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_code_.IsDefault()) {
    _impl_.error_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.ErrorInfo.error_code)
}

// map<string, string> error_attributes = 5;
inline int ErrorInfo::_internal_error_attributes_size() const {
  return _impl_.error_attributes_.size();
}
inline int ErrorInfo::error_attributes_size() const {
  return _internal_error_attributes_size();
}
inline void ErrorInfo::clear_error_attributes() {
  _impl_.error_attributes_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ErrorInfo::_internal_error_attributes() const {
  return _impl_.error_attributes_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ErrorInfo::error_attributes() const {
  // @@protoc_insertion_point(field_map:unhinged.observability.v1.ErrorInfo.error_attributes)
  return _internal_error_attributes();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ErrorInfo::_internal_mutable_error_attributes() {
  return _impl_.error_attributes_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ErrorInfo::mutable_error_attributes() {
  // @@protoc_insertion_point(field_mutable_map:unhinged.observability.v1.ErrorInfo.error_attributes)
  return _internal_mutable_error_attributes();
}

// -------------------------------------------------------------------

// DestinationFlags

// bool console = 1;
inline void DestinationFlags::clear_console() {
  _impl_.console_ = false;
}
inline bool DestinationFlags::_internal_console() const {
  return _impl_.console_;
}
inline bool DestinationFlags::console() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.DestinationFlags.console)
  return _internal_console();
}
inline void DestinationFlags::_internal_set_console(bool value) {
  
  _impl_.console_ = value;
}
inline void DestinationFlags::set_console(bool value) {
  _internal_set_console(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.DestinationFlags.console)
}

// bool cdc_stream = 2;
inline void DestinationFlags::clear_cdc_stream() {
  _impl_.cdc_stream_ = false;
}
inline bool DestinationFlags::_internal_cdc_stream() const {
  return _impl_.cdc_stream_;
}
inline bool DestinationFlags::cdc_stream() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.DestinationFlags.cdc_stream)
  return _internal_cdc_stream();
}
inline void DestinationFlags::_internal_set_cdc_stream(bool value) {
  
  _impl_.cdc_stream_ = value;
}
inline void DestinationFlags::set_cdc_stream(bool value) {
  _internal_set_cdc_stream(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.DestinationFlags.cdc_stream)
}

// bool data_lake = 3;
inline void DestinationFlags::clear_data_lake() {
  _impl_.data_lake_ = false;
}
inline bool DestinationFlags::_internal_data_lake() const {
  return _impl_.data_lake_;
}
inline bool DestinationFlags::data_lake() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.DestinationFlags.data_lake)
  return _internal_data_lake();
}
inline void DestinationFlags::_internal_set_data_lake(bool value) {
  
  _impl_.data_lake_ = value;
}
inline void DestinationFlags::set_data_lake(bool value) {
  _internal_set_data_lake(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.DestinationFlags.data_lake)
}

// .unhinged.observability.v1.DataLakeOptions data_lake_options = 10;
inline bool DestinationFlags::_internal_has_data_lake_options() const {
  return this != internal_default_instance() && _impl_.data_lake_options_ != nullptr;
}
inline bool DestinationFlags::has_data_lake_options() const {
  return _internal_has_data_lake_options();
}
inline void DestinationFlags::clear_data_lake_options() {
  if (GetArenaForAllocation() == nullptr && _impl_.data_lake_options_ != nullptr) {
    delete _impl_.data_lake_options_;
  }
  _impl_.data_lake_options_ = nullptr;
}
inline const ::unhinged::observability::v1::DataLakeOptions& DestinationFlags::_internal_data_lake_options() const {
  const ::unhinged::observability::v1::DataLakeOptions* p = _impl_.data_lake_options_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::observability::v1::DataLakeOptions&>(
      ::unhinged::observability::v1::_DataLakeOptions_default_instance_);
}
inline const ::unhinged::observability::v1::DataLakeOptions& DestinationFlags::data_lake_options() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.DestinationFlags.data_lake_options)
  return _internal_data_lake_options();
}
inline void DestinationFlags::unsafe_arena_set_allocated_data_lake_options(
    ::unhinged::observability::v1::DataLakeOptions* data_lake_options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_lake_options_);
  }
  _impl_.data_lake_options_ = data_lake_options;
  if (data_lake_options) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.DestinationFlags.data_lake_options)
}
inline ::unhinged::observability::v1::DataLakeOptions* DestinationFlags::release_data_lake_options() {
  
  ::unhinged::observability::v1::DataLakeOptions* temp = _impl_.data_lake_options_;
  _impl_.data_lake_options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::observability::v1::DataLakeOptions* DestinationFlags::unsafe_arena_release_data_lake_options() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.DestinationFlags.data_lake_options)
  
  ::unhinged::observability::v1::DataLakeOptions* temp = _impl_.data_lake_options_;
  _impl_.data_lake_options_ = nullptr;
  return temp;
}
inline ::unhinged::observability::v1::DataLakeOptions* DestinationFlags::_internal_mutable_data_lake_options() {
  
  if (_impl_.data_lake_options_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::observability::v1::DataLakeOptions>(GetArenaForAllocation());
    _impl_.data_lake_options_ = p;
  }
  return _impl_.data_lake_options_;
}
inline ::unhinged::observability::v1::DataLakeOptions* DestinationFlags::mutable_data_lake_options() {
  ::unhinged::observability::v1::DataLakeOptions* _msg = _internal_mutable_data_lake_options();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.DestinationFlags.data_lake_options)
  return _msg;
}
inline void DestinationFlags::set_allocated_data_lake_options(::unhinged::observability::v1::DataLakeOptions* data_lake_options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.data_lake_options_;
  }
  if (data_lake_options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(data_lake_options);
    if (message_arena != submessage_arena) {
      data_lake_options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data_lake_options, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_lake_options_ = data_lake_options;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.DestinationFlags.data_lake_options)
}

// -------------------------------------------------------------------

// DataLakeOptions

// string table_name = 1;
inline void DataLakeOptions::clear_table_name() {
  _impl_.table_name_.ClearToEmpty();
}
inline const std::string& DataLakeOptions::table_name() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.DataLakeOptions.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataLakeOptions::set_table_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.table_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.DataLakeOptions.table_name)
}
inline std::string* DataLakeOptions::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.DataLakeOptions.table_name)
  return _s;
}
inline const std::string& DataLakeOptions::_internal_table_name() const {
  return _impl_.table_name_.Get();
}
inline void DataLakeOptions::_internal_set_table_name(const std::string& value) {
  
  _impl_.table_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DataLakeOptions::_internal_mutable_table_name() {
  
  return _impl_.table_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DataLakeOptions::release_table_name() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.DataLakeOptions.table_name)
  return _impl_.table_name_.Release();
}
inline void DataLakeOptions::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    
  } else {
    
  }
  _impl_.table_name_.SetAllocated(table_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.table_name_.IsDefault()) {
    _impl_.table_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.DataLakeOptions.table_name)
}

// string partition_strategy = 2;
inline void DataLakeOptions::clear_partition_strategy() {
  _impl_.partition_strategy_.ClearToEmpty();
}
inline const std::string& DataLakeOptions::partition_strategy() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.DataLakeOptions.partition_strategy)
  return _internal_partition_strategy();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataLakeOptions::set_partition_strategy(ArgT0&& arg0, ArgT... args) {
 
 _impl_.partition_strategy_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.DataLakeOptions.partition_strategy)
}
inline std::string* DataLakeOptions::mutable_partition_strategy() {
  std::string* _s = _internal_mutable_partition_strategy();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.DataLakeOptions.partition_strategy)
  return _s;
}
inline const std::string& DataLakeOptions::_internal_partition_strategy() const {
  return _impl_.partition_strategy_.Get();
}
inline void DataLakeOptions::_internal_set_partition_strategy(const std::string& value) {
  
  _impl_.partition_strategy_.Set(value, GetArenaForAllocation());
}
inline std::string* DataLakeOptions::_internal_mutable_partition_strategy() {
  
  return _impl_.partition_strategy_.Mutable(GetArenaForAllocation());
}
inline std::string* DataLakeOptions::release_partition_strategy() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.DataLakeOptions.partition_strategy)
  return _impl_.partition_strategy_.Release();
}
inline void DataLakeOptions::set_allocated_partition_strategy(std::string* partition_strategy) {
  if (partition_strategy != nullptr) {
    
  } else {
    
  }
  _impl_.partition_strategy_.SetAllocated(partition_strategy, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.partition_strategy_.IsDefault()) {
    _impl_.partition_strategy_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.DataLakeOptions.partition_strategy)
}

// int32 batch_size = 3;
inline void DataLakeOptions::clear_batch_size() {
  _impl_.batch_size_ = 0;
}
inline int32_t DataLakeOptions::_internal_batch_size() const {
  return _impl_.batch_size_;
}
inline int32_t DataLakeOptions::batch_size() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.DataLakeOptions.batch_size)
  return _internal_batch_size();
}
inline void DataLakeOptions::_internal_set_batch_size(int32_t value) {
  
  _impl_.batch_size_ = value;
}
inline void DataLakeOptions::set_batch_size(int32_t value) {
  _internal_set_batch_size(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.DataLakeOptions.batch_size)
}

// int32 flush_interval_seconds = 4;
inline void DataLakeOptions::clear_flush_interval_seconds() {
  _impl_.flush_interval_seconds_ = 0;
}
inline int32_t DataLakeOptions::_internal_flush_interval_seconds() const {
  return _impl_.flush_interval_seconds_;
}
inline int32_t DataLakeOptions::flush_interval_seconds() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.DataLakeOptions.flush_interval_seconds)
  return _internal_flush_interval_seconds();
}
inline void DataLakeOptions::_internal_set_flush_interval_seconds(int32_t value) {
  
  _impl_.flush_interval_seconds_ = value;
}
inline void DataLakeOptions::set_flush_interval_seconds(int32_t value) {
  _internal_set_flush_interval_seconds(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.DataLakeOptions.flush_interval_seconds)
}

// .unhinged.observability.v1.CompressionType compression = 5;
inline void DataLakeOptions::clear_compression() {
  _impl_.compression_ = 0;
}
inline ::unhinged::observability::v1::CompressionType DataLakeOptions::_internal_compression() const {
  return static_cast< ::unhinged::observability::v1::CompressionType >(_impl_.compression_);
}
inline ::unhinged::observability::v1::CompressionType DataLakeOptions::compression() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.DataLakeOptions.compression)
  return _internal_compression();
}
inline void DataLakeOptions::_internal_set_compression(::unhinged::observability::v1::CompressionType value) {
  
  _impl_.compression_ = value;
}
inline void DataLakeOptions::set_compression(::unhinged::observability::v1::CompressionType value) {
  _internal_set_compression(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.DataLakeOptions.compression)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// PartitionInfo

// string date_partition = 1;
inline void PartitionInfo::clear_date_partition() {
  _impl_.date_partition_.ClearToEmpty();
}
inline const std::string& PartitionInfo::date_partition() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.PartitionInfo.date_partition)
  return _internal_date_partition();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PartitionInfo::set_date_partition(ArgT0&& arg0, ArgT... args) {
 
 _impl_.date_partition_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.PartitionInfo.date_partition)
}
inline std::string* PartitionInfo::mutable_date_partition() {
  std::string* _s = _internal_mutable_date_partition();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.PartitionInfo.date_partition)
  return _s;
}
inline const std::string& PartitionInfo::_internal_date_partition() const {
  return _impl_.date_partition_.Get();
}
inline void PartitionInfo::_internal_set_date_partition(const std::string& value) {
  
  _impl_.date_partition_.Set(value, GetArenaForAllocation());
}
inline std::string* PartitionInfo::_internal_mutable_date_partition() {
  
  return _impl_.date_partition_.Mutable(GetArenaForAllocation());
}
inline std::string* PartitionInfo::release_date_partition() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.PartitionInfo.date_partition)
  return _impl_.date_partition_.Release();
}
inline void PartitionInfo::set_allocated_date_partition(std::string* date_partition) {
  if (date_partition != nullptr) {
    
  } else {
    
  }
  _impl_.date_partition_.SetAllocated(date_partition, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.date_partition_.IsDefault()) {
    _impl_.date_partition_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.PartitionInfo.date_partition)
}

// string hour_partition = 2;
inline void PartitionInfo::clear_hour_partition() {
  _impl_.hour_partition_.ClearToEmpty();
}
inline const std::string& PartitionInfo::hour_partition() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.PartitionInfo.hour_partition)
  return _internal_hour_partition();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PartitionInfo::set_hour_partition(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hour_partition_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.PartitionInfo.hour_partition)
}
inline std::string* PartitionInfo::mutable_hour_partition() {
  std::string* _s = _internal_mutable_hour_partition();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.PartitionInfo.hour_partition)
  return _s;
}
inline const std::string& PartitionInfo::_internal_hour_partition() const {
  return _impl_.hour_partition_.Get();
}
inline void PartitionInfo::_internal_set_hour_partition(const std::string& value) {
  
  _impl_.hour_partition_.Set(value, GetArenaForAllocation());
}
inline std::string* PartitionInfo::_internal_mutable_hour_partition() {
  
  return _impl_.hour_partition_.Mutable(GetArenaForAllocation());
}
inline std::string* PartitionInfo::release_hour_partition() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.PartitionInfo.hour_partition)
  return _impl_.hour_partition_.Release();
}
inline void PartitionInfo::set_allocated_hour_partition(std::string* hour_partition) {
  if (hour_partition != nullptr) {
    
  } else {
    
  }
  _impl_.hour_partition_.SetAllocated(hour_partition, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hour_partition_.IsDefault()) {
    _impl_.hour_partition_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.PartitionInfo.hour_partition)
}

// string service_partition = 3;
inline void PartitionInfo::clear_service_partition() {
  _impl_.service_partition_.ClearToEmpty();
}
inline const std::string& PartitionInfo::service_partition() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.PartitionInfo.service_partition)
  return _internal_service_partition();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PartitionInfo::set_service_partition(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_partition_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.PartitionInfo.service_partition)
}
inline std::string* PartitionInfo::mutable_service_partition() {
  std::string* _s = _internal_mutable_service_partition();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.PartitionInfo.service_partition)
  return _s;
}
inline const std::string& PartitionInfo::_internal_service_partition() const {
  return _impl_.service_partition_.Get();
}
inline void PartitionInfo::_internal_set_service_partition(const std::string& value) {
  
  _impl_.service_partition_.Set(value, GetArenaForAllocation());
}
inline std::string* PartitionInfo::_internal_mutable_service_partition() {
  
  return _impl_.service_partition_.Mutable(GetArenaForAllocation());
}
inline std::string* PartitionInfo::release_service_partition() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.PartitionInfo.service_partition)
  return _impl_.service_partition_.Release();
}
inline void PartitionInfo::set_allocated_service_partition(std::string* service_partition) {
  if (service_partition != nullptr) {
    
  } else {
    
  }
  _impl_.service_partition_.SetAllocated(service_partition, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_partition_.IsDefault()) {
    _impl_.service_partition_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.PartitionInfo.service_partition)
}

// string level_partition = 4;
inline void PartitionInfo::clear_level_partition() {
  _impl_.level_partition_.ClearToEmpty();
}
inline const std::string& PartitionInfo::level_partition() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.PartitionInfo.level_partition)
  return _internal_level_partition();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PartitionInfo::set_level_partition(ArgT0&& arg0, ArgT... args) {
 
 _impl_.level_partition_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.PartitionInfo.level_partition)
}
inline std::string* PartitionInfo::mutable_level_partition() {
  std::string* _s = _internal_mutable_level_partition();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.PartitionInfo.level_partition)
  return _s;
}
inline const std::string& PartitionInfo::_internal_level_partition() const {
  return _impl_.level_partition_.Get();
}
inline void PartitionInfo::_internal_set_level_partition(const std::string& value) {
  
  _impl_.level_partition_.Set(value, GetArenaForAllocation());
}
inline std::string* PartitionInfo::_internal_mutable_level_partition() {
  
  return _impl_.level_partition_.Mutable(GetArenaForAllocation());
}
inline std::string* PartitionInfo::release_level_partition() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.PartitionInfo.level_partition)
  return _impl_.level_partition_.Release();
}
inline void PartitionInfo::set_allocated_level_partition(std::string* level_partition) {
  if (level_partition != nullptr) {
    
  } else {
    
  }
  _impl_.level_partition_.SetAllocated(level_partition, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.level_partition_.IsDefault()) {
    _impl_.level_partition_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.PartitionInfo.level_partition)
}

// map<string, string> custom_partitions = 10;
inline int PartitionInfo::_internal_custom_partitions_size() const {
  return _impl_.custom_partitions_.size();
}
inline int PartitionInfo::custom_partitions_size() const {
  return _internal_custom_partitions_size();
}
inline void PartitionInfo::clear_custom_partitions() {
  _impl_.custom_partitions_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
PartitionInfo::_internal_custom_partitions() const {
  return _impl_.custom_partitions_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
PartitionInfo::custom_partitions() const {
  // @@protoc_insertion_point(field_map:unhinged.observability.v1.PartitionInfo.custom_partitions)
  return _internal_custom_partitions();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
PartitionInfo::_internal_mutable_custom_partitions() {
  return _impl_.custom_partitions_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
PartitionInfo::mutable_custom_partitions() {
  // @@protoc_insertion_point(field_mutable_map:unhinged.observability.v1.PartitionInfo.custom_partitions)
  return _internal_mutable_custom_partitions();
}

// -------------------------------------------------------------------

// TraceEvent

// string event_id = 1;
inline void TraceEvent::clear_event_id() {
  _impl_.event_id_.ClearToEmpty();
}
inline const std::string& TraceEvent::event_id() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.TraceEvent.event_id)
  return _internal_event_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TraceEvent::set_event_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.event_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.TraceEvent.event_id)
}
inline std::string* TraceEvent::mutable_event_id() {
  std::string* _s = _internal_mutable_event_id();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.TraceEvent.event_id)
  return _s;
}
inline const std::string& TraceEvent::_internal_event_id() const {
  return _impl_.event_id_.Get();
}
inline void TraceEvent::_internal_set_event_id(const std::string& value) {
  
  _impl_.event_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TraceEvent::_internal_mutable_event_id() {
  
  return _impl_.event_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TraceEvent::release_event_id() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.TraceEvent.event_id)
  return _impl_.event_id_.Release();
}
inline void TraceEvent::set_allocated_event_id(std::string* event_id) {
  if (event_id != nullptr) {
    
  } else {
    
  }
  _impl_.event_id_.SetAllocated(event_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.event_id_.IsDefault()) {
    _impl_.event_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.TraceEvent.event_id)
}

// .google.protobuf.Timestamp timestamp = 2;
inline bool TraceEvent::_internal_has_timestamp() const {
  return this != internal_default_instance() && _impl_.timestamp_ != nullptr;
}
inline bool TraceEvent::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& TraceEvent::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& TraceEvent::timestamp() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.TraceEvent.timestamp)
  return _internal_timestamp();
}
inline void TraceEvent::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.TraceEvent.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TraceEvent::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TraceEvent::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.TraceEvent.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TraceEvent::_internal_mutable_timestamp() {
  
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TraceEvent::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.TraceEvent.timestamp)
  return _msg;
}
inline void TraceEvent::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.TraceEvent.timestamp)
}

// string event_type = 3;
inline void TraceEvent::clear_event_type() {
  _impl_.event_type_.ClearToEmpty();
}
inline const std::string& TraceEvent::event_type() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.TraceEvent.event_type)
  return _internal_event_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TraceEvent::set_event_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.event_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.TraceEvent.event_type)
}
inline std::string* TraceEvent::mutable_event_type() {
  std::string* _s = _internal_mutable_event_type();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.TraceEvent.event_type)
  return _s;
}
inline const std::string& TraceEvent::_internal_event_type() const {
  return _impl_.event_type_.Get();
}
inline void TraceEvent::_internal_set_event_type(const std::string& value) {
  
  _impl_.event_type_.Set(value, GetArenaForAllocation());
}
inline std::string* TraceEvent::_internal_mutable_event_type() {
  
  return _impl_.event_type_.Mutable(GetArenaForAllocation());
}
inline std::string* TraceEvent::release_event_type() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.TraceEvent.event_type)
  return _impl_.event_type_.Release();
}
inline void TraceEvent::set_allocated_event_type(std::string* event_type) {
  if (event_type != nullptr) {
    
  } else {
    
  }
  _impl_.event_type_.SetAllocated(event_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.event_type_.IsDefault()) {
    _impl_.event_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.TraceEvent.event_type)
}

// int64 sequence_number = 4;
inline void TraceEvent::clear_sequence_number() {
  _impl_.sequence_number_ = int64_t{0};
}
inline int64_t TraceEvent::_internal_sequence_number() const {
  return _impl_.sequence_number_;
}
inline int64_t TraceEvent::sequence_number() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.TraceEvent.sequence_number)
  return _internal_sequence_number();
}
inline void TraceEvent::_internal_set_sequence_number(int64_t value) {
  
  _impl_.sequence_number_ = value;
}
inline void TraceEvent::set_sequence_number(int64_t value) {
  _internal_set_sequence_number(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.TraceEvent.sequence_number)
}

// .unhinged.observability.v1.TraceContext trace_context = 5;
inline bool TraceEvent::_internal_has_trace_context() const {
  return this != internal_default_instance() && _impl_.trace_context_ != nullptr;
}
inline bool TraceEvent::has_trace_context() const {
  return _internal_has_trace_context();
}
inline void TraceEvent::clear_trace_context() {
  if (GetArenaForAllocation() == nullptr && _impl_.trace_context_ != nullptr) {
    delete _impl_.trace_context_;
  }
  _impl_.trace_context_ = nullptr;
}
inline const ::unhinged::observability::v1::TraceContext& TraceEvent::_internal_trace_context() const {
  const ::unhinged::observability::v1::TraceContext* p = _impl_.trace_context_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::observability::v1::TraceContext&>(
      ::unhinged::observability::v1::_TraceContext_default_instance_);
}
inline const ::unhinged::observability::v1::TraceContext& TraceEvent::trace_context() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.TraceEvent.trace_context)
  return _internal_trace_context();
}
inline void TraceEvent::unsafe_arena_set_allocated_trace_context(
    ::unhinged::observability::v1::TraceContext* trace_context) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.trace_context_);
  }
  _impl_.trace_context_ = trace_context;
  if (trace_context) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.TraceEvent.trace_context)
}
inline ::unhinged::observability::v1::TraceContext* TraceEvent::release_trace_context() {
  
  ::unhinged::observability::v1::TraceContext* temp = _impl_.trace_context_;
  _impl_.trace_context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::observability::v1::TraceContext* TraceEvent::unsafe_arena_release_trace_context() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.TraceEvent.trace_context)
  
  ::unhinged::observability::v1::TraceContext* temp = _impl_.trace_context_;
  _impl_.trace_context_ = nullptr;
  return temp;
}
inline ::unhinged::observability::v1::TraceContext* TraceEvent::_internal_mutable_trace_context() {
  
  if (_impl_.trace_context_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::observability::v1::TraceContext>(GetArenaForAllocation());
    _impl_.trace_context_ = p;
  }
  return _impl_.trace_context_;
}
inline ::unhinged::observability::v1::TraceContext* TraceEvent::mutable_trace_context() {
  ::unhinged::observability::v1::TraceContext* _msg = _internal_mutable_trace_context();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.TraceEvent.trace_context)
  return _msg;
}
inline void TraceEvent::set_allocated_trace_context(::unhinged::observability::v1::TraceContext* trace_context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.trace_context_;
  }
  if (trace_context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(trace_context);
    if (message_arena != submessage_arena) {
      trace_context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trace_context, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.trace_context_ = trace_context;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.TraceEvent.trace_context)
}

// .unhinged.observability.v1.Resource resource = 6;
inline bool TraceEvent::_internal_has_resource() const {
  return this != internal_default_instance() && _impl_.resource_ != nullptr;
}
inline bool TraceEvent::has_resource() const {
  return _internal_has_resource();
}
inline void TraceEvent::clear_resource() {
  if (GetArenaForAllocation() == nullptr && _impl_.resource_ != nullptr) {
    delete _impl_.resource_;
  }
  _impl_.resource_ = nullptr;
}
inline const ::unhinged::observability::v1::Resource& TraceEvent::_internal_resource() const {
  const ::unhinged::observability::v1::Resource* p = _impl_.resource_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::observability::v1::Resource&>(
      ::unhinged::observability::v1::_Resource_default_instance_);
}
inline const ::unhinged::observability::v1::Resource& TraceEvent::resource() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.TraceEvent.resource)
  return _internal_resource();
}
inline void TraceEvent::unsafe_arena_set_allocated_resource(
    ::unhinged::observability::v1::Resource* resource) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.resource_);
  }
  _impl_.resource_ = resource;
  if (resource) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.TraceEvent.resource)
}
inline ::unhinged::observability::v1::Resource* TraceEvent::release_resource() {
  
  ::unhinged::observability::v1::Resource* temp = _impl_.resource_;
  _impl_.resource_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::observability::v1::Resource* TraceEvent::unsafe_arena_release_resource() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.TraceEvent.resource)
  
  ::unhinged::observability::v1::Resource* temp = _impl_.resource_;
  _impl_.resource_ = nullptr;
  return temp;
}
inline ::unhinged::observability::v1::Resource* TraceEvent::_internal_mutable_resource() {
  
  if (_impl_.resource_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::observability::v1::Resource>(GetArenaForAllocation());
    _impl_.resource_ = p;
  }
  return _impl_.resource_;
}
inline ::unhinged::observability::v1::Resource* TraceEvent::mutable_resource() {
  ::unhinged::observability::v1::Resource* _msg = _internal_mutable_resource();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.TraceEvent.resource)
  return _msg;
}
inline void TraceEvent::set_allocated_resource(::unhinged::observability::v1::Resource* resource) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.resource_;
  }
  if (resource) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(resource);
    if (message_arena != submessage_arena) {
      resource = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, resource, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.resource_ = resource;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.TraceEvent.resource)
}

// .unhinged.observability.v1.SpanData span = 10;
inline bool TraceEvent::_internal_has_span() const {
  return this != internal_default_instance() && _impl_.span_ != nullptr;
}
inline bool TraceEvent::has_span() const {
  return _internal_has_span();
}
inline void TraceEvent::clear_span() {
  if (GetArenaForAllocation() == nullptr && _impl_.span_ != nullptr) {
    delete _impl_.span_;
  }
  _impl_.span_ = nullptr;
}
inline const ::unhinged::observability::v1::SpanData& TraceEvent::_internal_span() const {
  const ::unhinged::observability::v1::SpanData* p = _impl_.span_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::observability::v1::SpanData&>(
      ::unhinged::observability::v1::_SpanData_default_instance_);
}
inline const ::unhinged::observability::v1::SpanData& TraceEvent::span() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.TraceEvent.span)
  return _internal_span();
}
inline void TraceEvent::unsafe_arena_set_allocated_span(
    ::unhinged::observability::v1::SpanData* span) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.span_);
  }
  _impl_.span_ = span;
  if (span) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.TraceEvent.span)
}
inline ::unhinged::observability::v1::SpanData* TraceEvent::release_span() {
  
  ::unhinged::observability::v1::SpanData* temp = _impl_.span_;
  _impl_.span_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::observability::v1::SpanData* TraceEvent::unsafe_arena_release_span() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.TraceEvent.span)
  
  ::unhinged::observability::v1::SpanData* temp = _impl_.span_;
  _impl_.span_ = nullptr;
  return temp;
}
inline ::unhinged::observability::v1::SpanData* TraceEvent::_internal_mutable_span() {
  
  if (_impl_.span_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::observability::v1::SpanData>(GetArenaForAllocation());
    _impl_.span_ = p;
  }
  return _impl_.span_;
}
inline ::unhinged::observability::v1::SpanData* TraceEvent::mutable_span() {
  ::unhinged::observability::v1::SpanData* _msg = _internal_mutable_span();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.TraceEvent.span)
  return _msg;
}
inline void TraceEvent::set_allocated_span(::unhinged::observability::v1::SpanData* span) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.span_;
  }
  if (span) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(span);
    if (message_arena != submessage_arena) {
      span = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, span, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.span_ = span;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.TraceEvent.span)
}

// .unhinged.observability.v1.DestinationFlags destinations = 20;
inline bool TraceEvent::_internal_has_destinations() const {
  return this != internal_default_instance() && _impl_.destinations_ != nullptr;
}
inline bool TraceEvent::has_destinations() const {
  return _internal_has_destinations();
}
inline void TraceEvent::clear_destinations() {
  if (GetArenaForAllocation() == nullptr && _impl_.destinations_ != nullptr) {
    delete _impl_.destinations_;
  }
  _impl_.destinations_ = nullptr;
}
inline const ::unhinged::observability::v1::DestinationFlags& TraceEvent::_internal_destinations() const {
  const ::unhinged::observability::v1::DestinationFlags* p = _impl_.destinations_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::observability::v1::DestinationFlags&>(
      ::unhinged::observability::v1::_DestinationFlags_default_instance_);
}
inline const ::unhinged::observability::v1::DestinationFlags& TraceEvent::destinations() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.TraceEvent.destinations)
  return _internal_destinations();
}
inline void TraceEvent::unsafe_arena_set_allocated_destinations(
    ::unhinged::observability::v1::DestinationFlags* destinations) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.destinations_);
  }
  _impl_.destinations_ = destinations;
  if (destinations) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.TraceEvent.destinations)
}
inline ::unhinged::observability::v1::DestinationFlags* TraceEvent::release_destinations() {
  
  ::unhinged::observability::v1::DestinationFlags* temp = _impl_.destinations_;
  _impl_.destinations_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::observability::v1::DestinationFlags* TraceEvent::unsafe_arena_release_destinations() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.TraceEvent.destinations)
  
  ::unhinged::observability::v1::DestinationFlags* temp = _impl_.destinations_;
  _impl_.destinations_ = nullptr;
  return temp;
}
inline ::unhinged::observability::v1::DestinationFlags* TraceEvent::_internal_mutable_destinations() {
  
  if (_impl_.destinations_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::observability::v1::DestinationFlags>(GetArenaForAllocation());
    _impl_.destinations_ = p;
  }
  return _impl_.destinations_;
}
inline ::unhinged::observability::v1::DestinationFlags* TraceEvent::mutable_destinations() {
  ::unhinged::observability::v1::DestinationFlags* _msg = _internal_mutable_destinations();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.TraceEvent.destinations)
  return _msg;
}
inline void TraceEvent::set_allocated_destinations(::unhinged::observability::v1::DestinationFlags* destinations) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.destinations_;
  }
  if (destinations) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(destinations);
    if (message_arena != submessage_arena) {
      destinations = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, destinations, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.destinations_ = destinations;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.TraceEvent.destinations)
}

// .unhinged.observability.v1.PartitionInfo partition_info = 25;
inline bool TraceEvent::_internal_has_partition_info() const {
  return this != internal_default_instance() && _impl_.partition_info_ != nullptr;
}
inline bool TraceEvent::has_partition_info() const {
  return _internal_has_partition_info();
}
inline void TraceEvent::clear_partition_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.partition_info_ != nullptr) {
    delete _impl_.partition_info_;
  }
  _impl_.partition_info_ = nullptr;
}
inline const ::unhinged::observability::v1::PartitionInfo& TraceEvent::_internal_partition_info() const {
  const ::unhinged::observability::v1::PartitionInfo* p = _impl_.partition_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::observability::v1::PartitionInfo&>(
      ::unhinged::observability::v1::_PartitionInfo_default_instance_);
}
inline const ::unhinged::observability::v1::PartitionInfo& TraceEvent::partition_info() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.TraceEvent.partition_info)
  return _internal_partition_info();
}
inline void TraceEvent::unsafe_arena_set_allocated_partition_info(
    ::unhinged::observability::v1::PartitionInfo* partition_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.partition_info_);
  }
  _impl_.partition_info_ = partition_info;
  if (partition_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.TraceEvent.partition_info)
}
inline ::unhinged::observability::v1::PartitionInfo* TraceEvent::release_partition_info() {
  
  ::unhinged::observability::v1::PartitionInfo* temp = _impl_.partition_info_;
  _impl_.partition_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::observability::v1::PartitionInfo* TraceEvent::unsafe_arena_release_partition_info() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.TraceEvent.partition_info)
  
  ::unhinged::observability::v1::PartitionInfo* temp = _impl_.partition_info_;
  _impl_.partition_info_ = nullptr;
  return temp;
}
inline ::unhinged::observability::v1::PartitionInfo* TraceEvent::_internal_mutable_partition_info() {
  
  if (_impl_.partition_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::observability::v1::PartitionInfo>(GetArenaForAllocation());
    _impl_.partition_info_ = p;
  }
  return _impl_.partition_info_;
}
inline ::unhinged::observability::v1::PartitionInfo* TraceEvent::mutable_partition_info() {
  ::unhinged::observability::v1::PartitionInfo* _msg = _internal_mutable_partition_info();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.TraceEvent.partition_info)
  return _msg;
}
inline void TraceEvent::set_allocated_partition_info(::unhinged::observability::v1::PartitionInfo* partition_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.partition_info_;
  }
  if (partition_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(partition_info);
    if (message_arena != submessage_arena) {
      partition_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, partition_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.partition_info_ = partition_info;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.TraceEvent.partition_info)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SpanData

// string name = 1;
inline void SpanData::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& SpanData::name() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.SpanData.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SpanData::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.SpanData.name)
}
inline std::string* SpanData::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.SpanData.name)
  return _s;
}
inline const std::string& SpanData::_internal_name() const {
  return _impl_.name_.Get();
}
inline void SpanData::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* SpanData::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* SpanData::release_name() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.SpanData.name)
  return _impl_.name_.Release();
}
inline void SpanData::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.SpanData.name)
}

// .unhinged.observability.v1.SpanKind kind = 2;
inline void SpanData::clear_kind() {
  _impl_.kind_ = 0;
}
inline ::unhinged::observability::v1::SpanKind SpanData::_internal_kind() const {
  return static_cast< ::unhinged::observability::v1::SpanKind >(_impl_.kind_);
}
inline ::unhinged::observability::v1::SpanKind SpanData::kind() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.SpanData.kind)
  return _internal_kind();
}
inline void SpanData::_internal_set_kind(::unhinged::observability::v1::SpanKind value) {
  
  _impl_.kind_ = value;
}
inline void SpanData::set_kind(::unhinged::observability::v1::SpanKind value) {
  _internal_set_kind(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.SpanData.kind)
}

// .google.protobuf.Timestamp start_time = 3;
inline bool SpanData::_internal_has_start_time() const {
  return this != internal_default_instance() && _impl_.start_time_ != nullptr;
}
inline bool SpanData::has_start_time() const {
  return _internal_has_start_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SpanData::_internal_start_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.start_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SpanData::start_time() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.SpanData.start_time)
  return _internal_start_time();
}
inline void SpanData::unsafe_arena_set_allocated_start_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_time_);
  }
  _impl_.start_time_ = start_time;
  if (start_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.SpanData.start_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SpanData::release_start_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.start_time_;
  _impl_.start_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SpanData::unsafe_arena_release_start_time() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.SpanData.start_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.start_time_;
  _impl_.start_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SpanData::_internal_mutable_start_time() {
  
  if (_impl_.start_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.start_time_ = p;
  }
  return _impl_.start_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SpanData::mutable_start_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_start_time();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.SpanData.start_time)
  return _msg;
}
inline void SpanData::set_allocated_start_time(::PROTOBUF_NAMESPACE_ID::Timestamp* start_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_time_);
  }
  if (start_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_time));
    if (message_arena != submessage_arena) {
      start_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.start_time_ = start_time;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.SpanData.start_time)
}

// .google.protobuf.Timestamp end_time = 4;
inline bool SpanData::_internal_has_end_time() const {
  return this != internal_default_instance() && _impl_.end_time_ != nullptr;
}
inline bool SpanData::has_end_time() const {
  return _internal_has_end_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SpanData::_internal_end_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.end_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SpanData::end_time() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.SpanData.end_time)
  return _internal_end_time();
}
inline void SpanData::unsafe_arena_set_allocated_end_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_time_);
  }
  _impl_.end_time_ = end_time;
  if (end_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.SpanData.end_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SpanData::release_end_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.end_time_;
  _impl_.end_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SpanData::unsafe_arena_release_end_time() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.SpanData.end_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.end_time_;
  _impl_.end_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SpanData::_internal_mutable_end_time() {
  
  if (_impl_.end_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.end_time_ = p;
  }
  return _impl_.end_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SpanData::mutable_end_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_end_time();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.SpanData.end_time)
  return _msg;
}
inline void SpanData::set_allocated_end_time(::PROTOBUF_NAMESPACE_ID::Timestamp* end_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_time_);
  }
  if (end_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_time));
    if (message_arena != submessage_arena) {
      end_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.end_time_ = end_time;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.SpanData.end_time)
}

// int64 duration_nanos = 5;
inline void SpanData::clear_duration_nanos() {
  _impl_.duration_nanos_ = int64_t{0};
}
inline int64_t SpanData::_internal_duration_nanos() const {
  return _impl_.duration_nanos_;
}
inline int64_t SpanData::duration_nanos() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.SpanData.duration_nanos)
  return _internal_duration_nanos();
}
inline void SpanData::_internal_set_duration_nanos(int64_t value) {
  
  _impl_.duration_nanos_ = value;
}
inline void SpanData::set_duration_nanos(int64_t value) {
  _internal_set_duration_nanos(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.SpanData.duration_nanos)
}

// .unhinged.observability.v1.SpanStatus status = 10;
inline bool SpanData::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool SpanData::has_status() const {
  return _internal_has_status();
}
inline void SpanData::clear_status() {
  if (GetArenaForAllocation() == nullptr && _impl_.status_ != nullptr) {
    delete _impl_.status_;
  }
  _impl_.status_ = nullptr;
}
inline const ::unhinged::observability::v1::SpanStatus& SpanData::_internal_status() const {
  const ::unhinged::observability::v1::SpanStatus* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::observability::v1::SpanStatus&>(
      ::unhinged::observability::v1::_SpanStatus_default_instance_);
}
inline const ::unhinged::observability::v1::SpanStatus& SpanData::status() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.SpanData.status)
  return _internal_status();
}
inline void SpanData::unsafe_arena_set_allocated_status(
    ::unhinged::observability::v1::SpanStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.SpanData.status)
}
inline ::unhinged::observability::v1::SpanStatus* SpanData::release_status() {
  
  ::unhinged::observability::v1::SpanStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::observability::v1::SpanStatus* SpanData::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.SpanData.status)
  
  ::unhinged::observability::v1::SpanStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::unhinged::observability::v1::SpanStatus* SpanData::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::observability::v1::SpanStatus>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::unhinged::observability::v1::SpanStatus* SpanData::mutable_status() {
  ::unhinged::observability::v1::SpanStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.SpanData.status)
  return _msg;
}
inline void SpanData::set_allocated_status(::unhinged::observability::v1::SpanStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.SpanData.status)
}

// map<string, .unhinged.observability.v1.AttributeValue> attributes = 15;
inline int SpanData::_internal_attributes_size() const {
  return _impl_.attributes_.size();
}
inline int SpanData::attributes_size() const {
  return _internal_attributes_size();
}
inline void SpanData::clear_attributes() {
  _impl_.attributes_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::unhinged::observability::v1::AttributeValue >&
SpanData::_internal_attributes() const {
  return _impl_.attributes_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::unhinged::observability::v1::AttributeValue >&
SpanData::attributes() const {
  // @@protoc_insertion_point(field_map:unhinged.observability.v1.SpanData.attributes)
  return _internal_attributes();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::unhinged::observability::v1::AttributeValue >*
SpanData::_internal_mutable_attributes() {
  return _impl_.attributes_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::unhinged::observability::v1::AttributeValue >*
SpanData::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_map:unhinged.observability.v1.SpanData.attributes)
  return _internal_mutable_attributes();
}

// repeated .unhinged.observability.v1.SpanEvent events = 20;
inline int SpanData::_internal_events_size() const {
  return _impl_.events_.size();
}
inline int SpanData::events_size() const {
  return _internal_events_size();
}
inline void SpanData::clear_events() {
  _impl_.events_.Clear();
}
inline ::unhinged::observability::v1::SpanEvent* SpanData::mutable_events(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.SpanData.events)
  return _impl_.events_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::SpanEvent >*
SpanData::mutable_events() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.observability.v1.SpanData.events)
  return &_impl_.events_;
}
inline const ::unhinged::observability::v1::SpanEvent& SpanData::_internal_events(int index) const {
  return _impl_.events_.Get(index);
}
inline const ::unhinged::observability::v1::SpanEvent& SpanData::events(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.SpanData.events)
  return _internal_events(index);
}
inline ::unhinged::observability::v1::SpanEvent* SpanData::_internal_add_events() {
  return _impl_.events_.Add();
}
inline ::unhinged::observability::v1::SpanEvent* SpanData::add_events() {
  ::unhinged::observability::v1::SpanEvent* _add = _internal_add_events();
  // @@protoc_insertion_point(field_add:unhinged.observability.v1.SpanData.events)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::SpanEvent >&
SpanData::events() const {
  // @@protoc_insertion_point(field_list:unhinged.observability.v1.SpanData.events)
  return _impl_.events_;
}

// repeated .unhinged.observability.v1.SpanLink links = 25;
inline int SpanData::_internal_links_size() const {
  return _impl_.links_.size();
}
inline int SpanData::links_size() const {
  return _internal_links_size();
}
inline void SpanData::clear_links() {
  _impl_.links_.Clear();
}
inline ::unhinged::observability::v1::SpanLink* SpanData::mutable_links(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.SpanData.links)
  return _impl_.links_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::SpanLink >*
SpanData::mutable_links() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.observability.v1.SpanData.links)
  return &_impl_.links_;
}
inline const ::unhinged::observability::v1::SpanLink& SpanData::_internal_links(int index) const {
  return _impl_.links_.Get(index);
}
inline const ::unhinged::observability::v1::SpanLink& SpanData::links(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.SpanData.links)
  return _internal_links(index);
}
inline ::unhinged::observability::v1::SpanLink* SpanData::_internal_add_links() {
  return _impl_.links_.Add();
}
inline ::unhinged::observability::v1::SpanLink* SpanData::add_links() {
  ::unhinged::observability::v1::SpanLink* _add = _internal_add_links();
  // @@protoc_insertion_point(field_add:unhinged.observability.v1.SpanData.links)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::SpanLink >&
SpanData::links() const {
  // @@protoc_insertion_point(field_list:unhinged.observability.v1.SpanData.links)
  return _impl_.links_;
}

// .unhinged.observability.v1.InstrumentationLibrary instrumentation_library = 30;
inline bool SpanData::_internal_has_instrumentation_library() const {
  return this != internal_default_instance() && _impl_.instrumentation_library_ != nullptr;
}
inline bool SpanData::has_instrumentation_library() const {
  return _internal_has_instrumentation_library();
}
inline void SpanData::clear_instrumentation_library() {
  if (GetArenaForAllocation() == nullptr && _impl_.instrumentation_library_ != nullptr) {
    delete _impl_.instrumentation_library_;
  }
  _impl_.instrumentation_library_ = nullptr;
}
inline const ::unhinged::observability::v1::InstrumentationLibrary& SpanData::_internal_instrumentation_library() const {
  const ::unhinged::observability::v1::InstrumentationLibrary* p = _impl_.instrumentation_library_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::observability::v1::InstrumentationLibrary&>(
      ::unhinged::observability::v1::_InstrumentationLibrary_default_instance_);
}
inline const ::unhinged::observability::v1::InstrumentationLibrary& SpanData::instrumentation_library() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.SpanData.instrumentation_library)
  return _internal_instrumentation_library();
}
inline void SpanData::unsafe_arena_set_allocated_instrumentation_library(
    ::unhinged::observability::v1::InstrumentationLibrary* instrumentation_library) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.instrumentation_library_);
  }
  _impl_.instrumentation_library_ = instrumentation_library;
  if (instrumentation_library) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.SpanData.instrumentation_library)
}
inline ::unhinged::observability::v1::InstrumentationLibrary* SpanData::release_instrumentation_library() {
  
  ::unhinged::observability::v1::InstrumentationLibrary* temp = _impl_.instrumentation_library_;
  _impl_.instrumentation_library_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::observability::v1::InstrumentationLibrary* SpanData::unsafe_arena_release_instrumentation_library() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.SpanData.instrumentation_library)
  
  ::unhinged::observability::v1::InstrumentationLibrary* temp = _impl_.instrumentation_library_;
  _impl_.instrumentation_library_ = nullptr;
  return temp;
}
inline ::unhinged::observability::v1::InstrumentationLibrary* SpanData::_internal_mutable_instrumentation_library() {
  
  if (_impl_.instrumentation_library_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::observability::v1::InstrumentationLibrary>(GetArenaForAllocation());
    _impl_.instrumentation_library_ = p;
  }
  return _impl_.instrumentation_library_;
}
inline ::unhinged::observability::v1::InstrumentationLibrary* SpanData::mutable_instrumentation_library() {
  ::unhinged::observability::v1::InstrumentationLibrary* _msg = _internal_mutable_instrumentation_library();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.SpanData.instrumentation_library)
  return _msg;
}
inline void SpanData::set_allocated_instrumentation_library(::unhinged::observability::v1::InstrumentationLibrary* instrumentation_library) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.instrumentation_library_;
  }
  if (instrumentation_library) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(instrumentation_library);
    if (message_arena != submessage_arena) {
      instrumentation_library = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, instrumentation_library, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.instrumentation_library_ = instrumentation_library;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.SpanData.instrumentation_library)
}

// -------------------------------------------------------------------

// SpanStatus

// .unhinged.observability.v1.StatusCode code = 1;
inline void SpanStatus::clear_code() {
  _impl_.code_ = 0;
}
inline ::unhinged::observability::v1::StatusCode SpanStatus::_internal_code() const {
  return static_cast< ::unhinged::observability::v1::StatusCode >(_impl_.code_);
}
inline ::unhinged::observability::v1::StatusCode SpanStatus::code() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.SpanStatus.code)
  return _internal_code();
}
inline void SpanStatus::_internal_set_code(::unhinged::observability::v1::StatusCode value) {
  
  _impl_.code_ = value;
}
inline void SpanStatus::set_code(::unhinged::observability::v1::StatusCode value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.SpanStatus.code)
}

// string message = 2;
inline void SpanStatus::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& SpanStatus::message() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.SpanStatus.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SpanStatus::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.SpanStatus.message)
}
inline std::string* SpanStatus::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.SpanStatus.message)
  return _s;
}
inline const std::string& SpanStatus::_internal_message() const {
  return _impl_.message_.Get();
}
inline void SpanStatus::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* SpanStatus::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* SpanStatus::release_message() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.SpanStatus.message)
  return _impl_.message_.Release();
}
inline void SpanStatus::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.SpanStatus.message)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SpanEvent

// .google.protobuf.Timestamp timestamp = 1;
inline bool SpanEvent::_internal_has_timestamp() const {
  return this != internal_default_instance() && _impl_.timestamp_ != nullptr;
}
inline bool SpanEvent::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SpanEvent::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SpanEvent::timestamp() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.SpanEvent.timestamp)
  return _internal_timestamp();
}
inline void SpanEvent::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.SpanEvent.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SpanEvent::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SpanEvent::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.SpanEvent.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SpanEvent::_internal_mutable_timestamp() {
  
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SpanEvent::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.SpanEvent.timestamp)
  return _msg;
}
inline void SpanEvent::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.SpanEvent.timestamp)
}

// string name = 2;
inline void SpanEvent::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& SpanEvent::name() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.SpanEvent.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SpanEvent::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.SpanEvent.name)
}
inline std::string* SpanEvent::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.SpanEvent.name)
  return _s;
}
inline const std::string& SpanEvent::_internal_name() const {
  return _impl_.name_.Get();
}
inline void SpanEvent::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* SpanEvent::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* SpanEvent::release_name() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.SpanEvent.name)
  return _impl_.name_.Release();
}
inline void SpanEvent::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.SpanEvent.name)
}

// map<string, .unhinged.observability.v1.AttributeValue> attributes = 3;
inline int SpanEvent::_internal_attributes_size() const {
  return _impl_.attributes_.size();
}
inline int SpanEvent::attributes_size() const {
  return _internal_attributes_size();
}
inline void SpanEvent::clear_attributes() {
  _impl_.attributes_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::unhinged::observability::v1::AttributeValue >&
SpanEvent::_internal_attributes() const {
  return _impl_.attributes_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::unhinged::observability::v1::AttributeValue >&
SpanEvent::attributes() const {
  // @@protoc_insertion_point(field_map:unhinged.observability.v1.SpanEvent.attributes)
  return _internal_attributes();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::unhinged::observability::v1::AttributeValue >*
SpanEvent::_internal_mutable_attributes() {
  return _impl_.attributes_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::unhinged::observability::v1::AttributeValue >*
SpanEvent::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_map:unhinged.observability.v1.SpanEvent.attributes)
  return _internal_mutable_attributes();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SpanLink

// .unhinged.observability.v1.TraceContext trace_context = 1;
inline bool SpanLink::_internal_has_trace_context() const {
  return this != internal_default_instance() && _impl_.trace_context_ != nullptr;
}
inline bool SpanLink::has_trace_context() const {
  return _internal_has_trace_context();
}
inline void SpanLink::clear_trace_context() {
  if (GetArenaForAllocation() == nullptr && _impl_.trace_context_ != nullptr) {
    delete _impl_.trace_context_;
  }
  _impl_.trace_context_ = nullptr;
}
inline const ::unhinged::observability::v1::TraceContext& SpanLink::_internal_trace_context() const {
  const ::unhinged::observability::v1::TraceContext* p = _impl_.trace_context_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::observability::v1::TraceContext&>(
      ::unhinged::observability::v1::_TraceContext_default_instance_);
}
inline const ::unhinged::observability::v1::TraceContext& SpanLink::trace_context() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.SpanLink.trace_context)
  return _internal_trace_context();
}
inline void SpanLink::unsafe_arena_set_allocated_trace_context(
    ::unhinged::observability::v1::TraceContext* trace_context) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.trace_context_);
  }
  _impl_.trace_context_ = trace_context;
  if (trace_context) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.SpanLink.trace_context)
}
inline ::unhinged::observability::v1::TraceContext* SpanLink::release_trace_context() {
  
  ::unhinged::observability::v1::TraceContext* temp = _impl_.trace_context_;
  _impl_.trace_context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::observability::v1::TraceContext* SpanLink::unsafe_arena_release_trace_context() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.SpanLink.trace_context)
  
  ::unhinged::observability::v1::TraceContext* temp = _impl_.trace_context_;
  _impl_.trace_context_ = nullptr;
  return temp;
}
inline ::unhinged::observability::v1::TraceContext* SpanLink::_internal_mutable_trace_context() {
  
  if (_impl_.trace_context_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::observability::v1::TraceContext>(GetArenaForAllocation());
    _impl_.trace_context_ = p;
  }
  return _impl_.trace_context_;
}
inline ::unhinged::observability::v1::TraceContext* SpanLink::mutable_trace_context() {
  ::unhinged::observability::v1::TraceContext* _msg = _internal_mutable_trace_context();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.SpanLink.trace_context)
  return _msg;
}
inline void SpanLink::set_allocated_trace_context(::unhinged::observability::v1::TraceContext* trace_context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.trace_context_;
  }
  if (trace_context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(trace_context);
    if (message_arena != submessage_arena) {
      trace_context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trace_context, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.trace_context_ = trace_context;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.SpanLink.trace_context)
}

// map<string, .unhinged.observability.v1.AttributeValue> attributes = 2;
inline int SpanLink::_internal_attributes_size() const {
  return _impl_.attributes_.size();
}
inline int SpanLink::attributes_size() const {
  return _internal_attributes_size();
}
inline void SpanLink::clear_attributes() {
  _impl_.attributes_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::unhinged::observability::v1::AttributeValue >&
SpanLink::_internal_attributes() const {
  return _impl_.attributes_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::unhinged::observability::v1::AttributeValue >&
SpanLink::attributes() const {
  // @@protoc_insertion_point(field_map:unhinged.observability.v1.SpanLink.attributes)
  return _internal_attributes();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::unhinged::observability::v1::AttributeValue >*
SpanLink::_internal_mutable_attributes() {
  return _impl_.attributes_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::unhinged::observability::v1::AttributeValue >*
SpanLink::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_map:unhinged.observability.v1.SpanLink.attributes)
  return _internal_mutable_attributes();
}

// -------------------------------------------------------------------

// InstrumentationLibrary

// string name = 1;
inline void InstrumentationLibrary::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& InstrumentationLibrary::name() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.InstrumentationLibrary.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InstrumentationLibrary::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.InstrumentationLibrary.name)
}
inline std::string* InstrumentationLibrary::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.InstrumentationLibrary.name)
  return _s;
}
inline const std::string& InstrumentationLibrary::_internal_name() const {
  return _impl_.name_.Get();
}
inline void InstrumentationLibrary::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* InstrumentationLibrary::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* InstrumentationLibrary::release_name() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.InstrumentationLibrary.name)
  return _impl_.name_.Release();
}
inline void InstrumentationLibrary::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.InstrumentationLibrary.name)
}

// string version = 2;
inline void InstrumentationLibrary::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& InstrumentationLibrary::version() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.InstrumentationLibrary.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InstrumentationLibrary::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.InstrumentationLibrary.version)
}
inline std::string* InstrumentationLibrary::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.InstrumentationLibrary.version)
  return _s;
}
inline const std::string& InstrumentationLibrary::_internal_version() const {
  return _impl_.version_.Get();
}
inline void InstrumentationLibrary::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* InstrumentationLibrary::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* InstrumentationLibrary::release_version() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.InstrumentationLibrary.version)
  return _impl_.version_.Release();
}
inline void InstrumentationLibrary::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.InstrumentationLibrary.version)
}

// string schema_url = 3;
inline void InstrumentationLibrary::clear_schema_url() {
  _impl_.schema_url_.ClearToEmpty();
}
inline const std::string& InstrumentationLibrary::schema_url() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.InstrumentationLibrary.schema_url)
  return _internal_schema_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InstrumentationLibrary::set_schema_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.schema_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.InstrumentationLibrary.schema_url)
}
inline std::string* InstrumentationLibrary::mutable_schema_url() {
  std::string* _s = _internal_mutable_schema_url();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.InstrumentationLibrary.schema_url)
  return _s;
}
inline const std::string& InstrumentationLibrary::_internal_schema_url() const {
  return _impl_.schema_url_.Get();
}
inline void InstrumentationLibrary::_internal_set_schema_url(const std::string& value) {
  
  _impl_.schema_url_.Set(value, GetArenaForAllocation());
}
inline std::string* InstrumentationLibrary::_internal_mutable_schema_url() {
  
  return _impl_.schema_url_.Mutable(GetArenaForAllocation());
}
inline std::string* InstrumentationLibrary::release_schema_url() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.InstrumentationLibrary.schema_url)
  return _impl_.schema_url_.Release();
}
inline void InstrumentationLibrary::set_allocated_schema_url(std::string* schema_url) {
  if (schema_url != nullptr) {
    
  } else {
    
  }
  _impl_.schema_url_.SetAllocated(schema_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.schema_url_.IsDefault()) {
    _impl_.schema_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.InstrumentationLibrary.schema_url)
}

// -------------------------------------------------------------------

// AttributeValue

// string string_value = 1;
inline bool AttributeValue::_internal_has_string_value() const {
  return value_case() == kStringValue;
}
inline bool AttributeValue::has_string_value() const {
  return _internal_has_string_value();
}
inline void AttributeValue::set_has_string_value() {
  _impl_._oneof_case_[0] = kStringValue;
}
inline void AttributeValue::clear_string_value() {
  if (_internal_has_string_value()) {
    _impl_.value_.string_value_.Destroy();
    clear_has_value();
  }
}
inline const std::string& AttributeValue::string_value() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.AttributeValue.string_value)
  return _internal_string_value();
}
template <typename ArgT0, typename... ArgT>
inline void AttributeValue::set_string_value(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_string_value()) {
    clear_value();
    set_has_string_value();
    _impl_.value_.string_value_.InitDefault();
  }
  _impl_.value_.string_value_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.AttributeValue.string_value)
}
inline std::string* AttributeValue::mutable_string_value() {
  std::string* _s = _internal_mutable_string_value();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.AttributeValue.string_value)
  return _s;
}
inline const std::string& AttributeValue::_internal_string_value() const {
  if (_internal_has_string_value()) {
    return _impl_.value_.string_value_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void AttributeValue::_internal_set_string_value(const std::string& value) {
  if (!_internal_has_string_value()) {
    clear_value();
    set_has_string_value();
    _impl_.value_.string_value_.InitDefault();
  }
  _impl_.value_.string_value_.Set(value, GetArenaForAllocation());
}
inline std::string* AttributeValue::_internal_mutable_string_value() {
  if (!_internal_has_string_value()) {
    clear_value();
    set_has_string_value();
    _impl_.value_.string_value_.InitDefault();
  }
  return _impl_.value_.string_value_.Mutable(      GetArenaForAllocation());
}
inline std::string* AttributeValue::release_string_value() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.AttributeValue.string_value)
  if (_internal_has_string_value()) {
    clear_has_value();
    return _impl_.value_.string_value_.Release();
  } else {
    return nullptr;
  }
}
inline void AttributeValue::set_allocated_string_value(std::string* string_value) {
  if (has_value()) {
    clear_value();
  }
  if (string_value != nullptr) {
    set_has_string_value();
    _impl_.value_.string_value_.InitAllocated(string_value, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.AttributeValue.string_value)
}

// bool bool_value = 2;
inline bool AttributeValue::_internal_has_bool_value() const {
  return value_case() == kBoolValue;
}
inline bool AttributeValue::has_bool_value() const {
  return _internal_has_bool_value();
}
inline void AttributeValue::set_has_bool_value() {
  _impl_._oneof_case_[0] = kBoolValue;
}
inline void AttributeValue::clear_bool_value() {
  if (_internal_has_bool_value()) {
    _impl_.value_.bool_value_ = false;
    clear_has_value();
  }
}
inline bool AttributeValue::_internal_bool_value() const {
  if (_internal_has_bool_value()) {
    return _impl_.value_.bool_value_;
  }
  return false;
}
inline void AttributeValue::_internal_set_bool_value(bool value) {
  if (!_internal_has_bool_value()) {
    clear_value();
    set_has_bool_value();
  }
  _impl_.value_.bool_value_ = value;
}
inline bool AttributeValue::bool_value() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.AttributeValue.bool_value)
  return _internal_bool_value();
}
inline void AttributeValue::set_bool_value(bool value) {
  _internal_set_bool_value(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.AttributeValue.bool_value)
}

// int64 int_value = 3;
inline bool AttributeValue::_internal_has_int_value() const {
  return value_case() == kIntValue;
}
inline bool AttributeValue::has_int_value() const {
  return _internal_has_int_value();
}
inline void AttributeValue::set_has_int_value() {
  _impl_._oneof_case_[0] = kIntValue;
}
inline void AttributeValue::clear_int_value() {
  if (_internal_has_int_value()) {
    _impl_.value_.int_value_ = int64_t{0};
    clear_has_value();
  }
}
inline int64_t AttributeValue::_internal_int_value() const {
  if (_internal_has_int_value()) {
    return _impl_.value_.int_value_;
  }
  return int64_t{0};
}
inline void AttributeValue::_internal_set_int_value(int64_t value) {
  if (!_internal_has_int_value()) {
    clear_value();
    set_has_int_value();
  }
  _impl_.value_.int_value_ = value;
}
inline int64_t AttributeValue::int_value() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.AttributeValue.int_value)
  return _internal_int_value();
}
inline void AttributeValue::set_int_value(int64_t value) {
  _internal_set_int_value(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.AttributeValue.int_value)
}

// double double_value = 4;
inline bool AttributeValue::_internal_has_double_value() const {
  return value_case() == kDoubleValue;
}
inline bool AttributeValue::has_double_value() const {
  return _internal_has_double_value();
}
inline void AttributeValue::set_has_double_value() {
  _impl_._oneof_case_[0] = kDoubleValue;
}
inline void AttributeValue::clear_double_value() {
  if (_internal_has_double_value()) {
    _impl_.value_.double_value_ = 0;
    clear_has_value();
  }
}
inline double AttributeValue::_internal_double_value() const {
  if (_internal_has_double_value()) {
    return _impl_.value_.double_value_;
  }
  return 0;
}
inline void AttributeValue::_internal_set_double_value(double value) {
  if (!_internal_has_double_value()) {
    clear_value();
    set_has_double_value();
  }
  _impl_.value_.double_value_ = value;
}
inline double AttributeValue::double_value() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.AttributeValue.double_value)
  return _internal_double_value();
}
inline void AttributeValue::set_double_value(double value) {
  _internal_set_double_value(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.AttributeValue.double_value)
}

// bytes bytes_value = 5;
inline bool AttributeValue::_internal_has_bytes_value() const {
  return value_case() == kBytesValue;
}
inline bool AttributeValue::has_bytes_value() const {
  return _internal_has_bytes_value();
}
inline void AttributeValue::set_has_bytes_value() {
  _impl_._oneof_case_[0] = kBytesValue;
}
inline void AttributeValue::clear_bytes_value() {
  if (_internal_has_bytes_value()) {
    _impl_.value_.bytes_value_.Destroy();
    clear_has_value();
  }
}
inline const std::string& AttributeValue::bytes_value() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.AttributeValue.bytes_value)
  return _internal_bytes_value();
}
template <typename ArgT0, typename... ArgT>
inline void AttributeValue::set_bytes_value(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_bytes_value()) {
    clear_value();
    set_has_bytes_value();
    _impl_.value_.bytes_value_.InitDefault();
  }
  _impl_.value_.bytes_value_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.AttributeValue.bytes_value)
}
inline std::string* AttributeValue::mutable_bytes_value() {
  std::string* _s = _internal_mutable_bytes_value();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.AttributeValue.bytes_value)
  return _s;
}
inline const std::string& AttributeValue::_internal_bytes_value() const {
  if (_internal_has_bytes_value()) {
    return _impl_.value_.bytes_value_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void AttributeValue::_internal_set_bytes_value(const std::string& value) {
  if (!_internal_has_bytes_value()) {
    clear_value();
    set_has_bytes_value();
    _impl_.value_.bytes_value_.InitDefault();
  }
  _impl_.value_.bytes_value_.Set(value, GetArenaForAllocation());
}
inline std::string* AttributeValue::_internal_mutable_bytes_value() {
  if (!_internal_has_bytes_value()) {
    clear_value();
    set_has_bytes_value();
    _impl_.value_.bytes_value_.InitDefault();
  }
  return _impl_.value_.bytes_value_.Mutable(      GetArenaForAllocation());
}
inline std::string* AttributeValue::release_bytes_value() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.AttributeValue.bytes_value)
  if (_internal_has_bytes_value()) {
    clear_has_value();
    return _impl_.value_.bytes_value_.Release();
  } else {
    return nullptr;
  }
}
inline void AttributeValue::set_allocated_bytes_value(std::string* bytes_value) {
  if (has_value()) {
    clear_value();
  }
  if (bytes_value != nullptr) {
    set_has_bytes_value();
    _impl_.value_.bytes_value_.InitAllocated(bytes_value, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.AttributeValue.bytes_value)
}

// .unhinged.observability.v1.AttributeArray array_value = 6;
inline bool AttributeValue::_internal_has_array_value() const {
  return value_case() == kArrayValue;
}
inline bool AttributeValue::has_array_value() const {
  return _internal_has_array_value();
}
inline void AttributeValue::set_has_array_value() {
  _impl_._oneof_case_[0] = kArrayValue;
}
inline void AttributeValue::clear_array_value() {
  if (_internal_has_array_value()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.array_value_;
    }
    clear_has_value();
  }
}
inline ::unhinged::observability::v1::AttributeArray* AttributeValue::release_array_value() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.AttributeValue.array_value)
  if (_internal_has_array_value()) {
    clear_has_value();
    ::unhinged::observability::v1::AttributeArray* temp = _impl_.value_.array_value_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.array_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::observability::v1::AttributeArray& AttributeValue::_internal_array_value() const {
  return _internal_has_array_value()
      ? *_impl_.value_.array_value_
      : reinterpret_cast< ::unhinged::observability::v1::AttributeArray&>(::unhinged::observability::v1::_AttributeArray_default_instance_);
}
inline const ::unhinged::observability::v1::AttributeArray& AttributeValue::array_value() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.AttributeValue.array_value)
  return _internal_array_value();
}
inline ::unhinged::observability::v1::AttributeArray* AttributeValue::unsafe_arena_release_array_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.observability.v1.AttributeValue.array_value)
  if (_internal_has_array_value()) {
    clear_has_value();
    ::unhinged::observability::v1::AttributeArray* temp = _impl_.value_.array_value_;
    _impl_.value_.array_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AttributeValue::unsafe_arena_set_allocated_array_value(::unhinged::observability::v1::AttributeArray* array_value) {
  clear_value();
  if (array_value) {
    set_has_array_value();
    _impl_.value_.array_value_ = array_value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.AttributeValue.array_value)
}
inline ::unhinged::observability::v1::AttributeArray* AttributeValue::_internal_mutable_array_value() {
  if (!_internal_has_array_value()) {
    clear_value();
    set_has_array_value();
    _impl_.value_.array_value_ = CreateMaybeMessage< ::unhinged::observability::v1::AttributeArray >(GetArenaForAllocation());
  }
  return _impl_.value_.array_value_;
}
inline ::unhinged::observability::v1::AttributeArray* AttributeValue::mutable_array_value() {
  ::unhinged::observability::v1::AttributeArray* _msg = _internal_mutable_array_value();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.AttributeValue.array_value)
  return _msg;
}

// .unhinged.observability.v1.AttributeKeyValueList kvlist_value = 7;
inline bool AttributeValue::_internal_has_kvlist_value() const {
  return value_case() == kKvlistValue;
}
inline bool AttributeValue::has_kvlist_value() const {
  return _internal_has_kvlist_value();
}
inline void AttributeValue::set_has_kvlist_value() {
  _impl_._oneof_case_[0] = kKvlistValue;
}
inline void AttributeValue::clear_kvlist_value() {
  if (_internal_has_kvlist_value()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.kvlist_value_;
    }
    clear_has_value();
  }
}
inline ::unhinged::observability::v1::AttributeKeyValueList* AttributeValue::release_kvlist_value() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.AttributeValue.kvlist_value)
  if (_internal_has_kvlist_value()) {
    clear_has_value();
    ::unhinged::observability::v1::AttributeKeyValueList* temp = _impl_.value_.kvlist_value_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.kvlist_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::observability::v1::AttributeKeyValueList& AttributeValue::_internal_kvlist_value() const {
  return _internal_has_kvlist_value()
      ? *_impl_.value_.kvlist_value_
      : reinterpret_cast< ::unhinged::observability::v1::AttributeKeyValueList&>(::unhinged::observability::v1::_AttributeKeyValueList_default_instance_);
}
inline const ::unhinged::observability::v1::AttributeKeyValueList& AttributeValue::kvlist_value() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.AttributeValue.kvlist_value)
  return _internal_kvlist_value();
}
inline ::unhinged::observability::v1::AttributeKeyValueList* AttributeValue::unsafe_arena_release_kvlist_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.observability.v1.AttributeValue.kvlist_value)
  if (_internal_has_kvlist_value()) {
    clear_has_value();
    ::unhinged::observability::v1::AttributeKeyValueList* temp = _impl_.value_.kvlist_value_;
    _impl_.value_.kvlist_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AttributeValue::unsafe_arena_set_allocated_kvlist_value(::unhinged::observability::v1::AttributeKeyValueList* kvlist_value) {
  clear_value();
  if (kvlist_value) {
    set_has_kvlist_value();
    _impl_.value_.kvlist_value_ = kvlist_value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.AttributeValue.kvlist_value)
}
inline ::unhinged::observability::v1::AttributeKeyValueList* AttributeValue::_internal_mutable_kvlist_value() {
  if (!_internal_has_kvlist_value()) {
    clear_value();
    set_has_kvlist_value();
    _impl_.value_.kvlist_value_ = CreateMaybeMessage< ::unhinged::observability::v1::AttributeKeyValueList >(GetArenaForAllocation());
  }
  return _impl_.value_.kvlist_value_;
}
inline ::unhinged::observability::v1::AttributeKeyValueList* AttributeValue::mutable_kvlist_value() {
  ::unhinged::observability::v1::AttributeKeyValueList* _msg = _internal_mutable_kvlist_value();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.AttributeValue.kvlist_value)
  return _msg;
}

inline bool AttributeValue::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void AttributeValue::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline AttributeValue::ValueCase AttributeValue::value_case() const {
  return AttributeValue::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// AttributeArray

// repeated .unhinged.observability.v1.AttributeValue values = 1;
inline int AttributeArray::_internal_values_size() const {
  return _impl_.values_.size();
}
inline int AttributeArray::values_size() const {
  return _internal_values_size();
}
inline void AttributeArray::clear_values() {
  _impl_.values_.Clear();
}
inline ::unhinged::observability::v1::AttributeValue* AttributeArray::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.AttributeArray.values)
  return _impl_.values_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::AttributeValue >*
AttributeArray::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.observability.v1.AttributeArray.values)
  return &_impl_.values_;
}
inline const ::unhinged::observability::v1::AttributeValue& AttributeArray::_internal_values(int index) const {
  return _impl_.values_.Get(index);
}
inline const ::unhinged::observability::v1::AttributeValue& AttributeArray::values(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.AttributeArray.values)
  return _internal_values(index);
}
inline ::unhinged::observability::v1::AttributeValue* AttributeArray::_internal_add_values() {
  return _impl_.values_.Add();
}
inline ::unhinged::observability::v1::AttributeValue* AttributeArray::add_values() {
  ::unhinged::observability::v1::AttributeValue* _add = _internal_add_values();
  // @@protoc_insertion_point(field_add:unhinged.observability.v1.AttributeArray.values)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::AttributeValue >&
AttributeArray::values() const {
  // @@protoc_insertion_point(field_list:unhinged.observability.v1.AttributeArray.values)
  return _impl_.values_;
}

// -------------------------------------------------------------------

// AttributeKeyValueList

// repeated .unhinged.observability.v1.AttributeKeyValue values = 1;
inline int AttributeKeyValueList::_internal_values_size() const {
  return _impl_.values_.size();
}
inline int AttributeKeyValueList::values_size() const {
  return _internal_values_size();
}
inline void AttributeKeyValueList::clear_values() {
  _impl_.values_.Clear();
}
inline ::unhinged::observability::v1::AttributeKeyValue* AttributeKeyValueList::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.AttributeKeyValueList.values)
  return _impl_.values_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::AttributeKeyValue >*
AttributeKeyValueList::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.observability.v1.AttributeKeyValueList.values)
  return &_impl_.values_;
}
inline const ::unhinged::observability::v1::AttributeKeyValue& AttributeKeyValueList::_internal_values(int index) const {
  return _impl_.values_.Get(index);
}
inline const ::unhinged::observability::v1::AttributeKeyValue& AttributeKeyValueList::values(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.AttributeKeyValueList.values)
  return _internal_values(index);
}
inline ::unhinged::observability::v1::AttributeKeyValue* AttributeKeyValueList::_internal_add_values() {
  return _impl_.values_.Add();
}
inline ::unhinged::observability::v1::AttributeKeyValue* AttributeKeyValueList::add_values() {
  ::unhinged::observability::v1::AttributeKeyValue* _add = _internal_add_values();
  // @@protoc_insertion_point(field_add:unhinged.observability.v1.AttributeKeyValueList.values)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::AttributeKeyValue >&
AttributeKeyValueList::values() const {
  // @@protoc_insertion_point(field_list:unhinged.observability.v1.AttributeKeyValueList.values)
  return _impl_.values_;
}

// -------------------------------------------------------------------

// AttributeKeyValue

// string key = 1;
inline void AttributeKeyValue::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& AttributeKeyValue::key() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.AttributeKeyValue.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AttributeKeyValue::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.AttributeKeyValue.key)
}
inline std::string* AttributeKeyValue::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.AttributeKeyValue.key)
  return _s;
}
inline const std::string& AttributeKeyValue::_internal_key() const {
  return _impl_.key_.Get();
}
inline void AttributeKeyValue::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* AttributeKeyValue::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* AttributeKeyValue::release_key() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.AttributeKeyValue.key)
  return _impl_.key_.Release();
}
inline void AttributeKeyValue::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.AttributeKeyValue.key)
}

// .unhinged.observability.v1.AttributeValue value = 2;
inline bool AttributeKeyValue::_internal_has_value() const {
  return this != internal_default_instance() && _impl_.value_ != nullptr;
}
inline bool AttributeKeyValue::has_value() const {
  return _internal_has_value();
}
inline void AttributeKeyValue::clear_value() {
  if (GetArenaForAllocation() == nullptr && _impl_.value_ != nullptr) {
    delete _impl_.value_;
  }
  _impl_.value_ = nullptr;
}
inline const ::unhinged::observability::v1::AttributeValue& AttributeKeyValue::_internal_value() const {
  const ::unhinged::observability::v1::AttributeValue* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::observability::v1::AttributeValue&>(
      ::unhinged::observability::v1::_AttributeValue_default_instance_);
}
inline const ::unhinged::observability::v1::AttributeValue& AttributeKeyValue::value() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.AttributeKeyValue.value)
  return _internal_value();
}
inline void AttributeKeyValue::unsafe_arena_set_allocated_value(
    ::unhinged::observability::v1::AttributeValue* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.AttributeKeyValue.value)
}
inline ::unhinged::observability::v1::AttributeValue* AttributeKeyValue::release_value() {
  
  ::unhinged::observability::v1::AttributeValue* temp = _impl_.value_;
  _impl_.value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::observability::v1::AttributeValue* AttributeKeyValue::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.AttributeKeyValue.value)
  
  ::unhinged::observability::v1::AttributeValue* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::unhinged::observability::v1::AttributeValue* AttributeKeyValue::_internal_mutable_value() {
  
  if (_impl_.value_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::observability::v1::AttributeValue>(GetArenaForAllocation());
    _impl_.value_ = p;
  }
  return _impl_.value_;
}
inline ::unhinged::observability::v1::AttributeValue* AttributeKeyValue::mutable_value() {
  ::unhinged::observability::v1::AttributeValue* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.AttributeKeyValue.value)
  return _msg;
}
inline void AttributeKeyValue::set_allocated_value(::unhinged::observability::v1::AttributeValue* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(value);
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.value_ = value;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.AttributeKeyValue.value)
}

// -------------------------------------------------------------------

// MetricEvent

// string event_id = 1;
inline void MetricEvent::clear_event_id() {
  _impl_.event_id_.ClearToEmpty();
}
inline const std::string& MetricEvent::event_id() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.MetricEvent.event_id)
  return _internal_event_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MetricEvent::set_event_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.event_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.MetricEvent.event_id)
}
inline std::string* MetricEvent::mutable_event_id() {
  std::string* _s = _internal_mutable_event_id();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.MetricEvent.event_id)
  return _s;
}
inline const std::string& MetricEvent::_internal_event_id() const {
  return _impl_.event_id_.Get();
}
inline void MetricEvent::_internal_set_event_id(const std::string& value) {
  
  _impl_.event_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MetricEvent::_internal_mutable_event_id() {
  
  return _impl_.event_id_.Mutable(GetArenaForAllocation());
}
inline std::string* MetricEvent::release_event_id() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.MetricEvent.event_id)
  return _impl_.event_id_.Release();
}
inline void MetricEvent::set_allocated_event_id(std::string* event_id) {
  if (event_id != nullptr) {
    
  } else {
    
  }
  _impl_.event_id_.SetAllocated(event_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.event_id_.IsDefault()) {
    _impl_.event_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.MetricEvent.event_id)
}

// .google.protobuf.Timestamp timestamp = 2;
inline bool MetricEvent::_internal_has_timestamp() const {
  return this != internal_default_instance() && _impl_.timestamp_ != nullptr;
}
inline bool MetricEvent::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& MetricEvent::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& MetricEvent::timestamp() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.MetricEvent.timestamp)
  return _internal_timestamp();
}
inline void MetricEvent::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.MetricEvent.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* MetricEvent::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* MetricEvent::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.MetricEvent.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* MetricEvent::_internal_mutable_timestamp() {
  
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* MetricEvent::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.MetricEvent.timestamp)
  return _msg;
}
inline void MetricEvent::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.MetricEvent.timestamp)
}

// string event_type = 3;
inline void MetricEvent::clear_event_type() {
  _impl_.event_type_.ClearToEmpty();
}
inline const std::string& MetricEvent::event_type() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.MetricEvent.event_type)
  return _internal_event_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MetricEvent::set_event_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.event_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.MetricEvent.event_type)
}
inline std::string* MetricEvent::mutable_event_type() {
  std::string* _s = _internal_mutable_event_type();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.MetricEvent.event_type)
  return _s;
}
inline const std::string& MetricEvent::_internal_event_type() const {
  return _impl_.event_type_.Get();
}
inline void MetricEvent::_internal_set_event_type(const std::string& value) {
  
  _impl_.event_type_.Set(value, GetArenaForAllocation());
}
inline std::string* MetricEvent::_internal_mutable_event_type() {
  
  return _impl_.event_type_.Mutable(GetArenaForAllocation());
}
inline std::string* MetricEvent::release_event_type() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.MetricEvent.event_type)
  return _impl_.event_type_.Release();
}
inline void MetricEvent::set_allocated_event_type(std::string* event_type) {
  if (event_type != nullptr) {
    
  } else {
    
  }
  _impl_.event_type_.SetAllocated(event_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.event_type_.IsDefault()) {
    _impl_.event_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.MetricEvent.event_type)
}

// int64 sequence_number = 4;
inline void MetricEvent::clear_sequence_number() {
  _impl_.sequence_number_ = int64_t{0};
}
inline int64_t MetricEvent::_internal_sequence_number() const {
  return _impl_.sequence_number_;
}
inline int64_t MetricEvent::sequence_number() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.MetricEvent.sequence_number)
  return _internal_sequence_number();
}
inline void MetricEvent::_internal_set_sequence_number(int64_t value) {
  
  _impl_.sequence_number_ = value;
}
inline void MetricEvent::set_sequence_number(int64_t value) {
  _internal_set_sequence_number(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.MetricEvent.sequence_number)
}

// .unhinged.observability.v1.TraceContext trace_context = 5;
inline bool MetricEvent::_internal_has_trace_context() const {
  return this != internal_default_instance() && _impl_.trace_context_ != nullptr;
}
inline bool MetricEvent::has_trace_context() const {
  return _internal_has_trace_context();
}
inline void MetricEvent::clear_trace_context() {
  if (GetArenaForAllocation() == nullptr && _impl_.trace_context_ != nullptr) {
    delete _impl_.trace_context_;
  }
  _impl_.trace_context_ = nullptr;
}
inline const ::unhinged::observability::v1::TraceContext& MetricEvent::_internal_trace_context() const {
  const ::unhinged::observability::v1::TraceContext* p = _impl_.trace_context_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::observability::v1::TraceContext&>(
      ::unhinged::observability::v1::_TraceContext_default_instance_);
}
inline const ::unhinged::observability::v1::TraceContext& MetricEvent::trace_context() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.MetricEvent.trace_context)
  return _internal_trace_context();
}
inline void MetricEvent::unsafe_arena_set_allocated_trace_context(
    ::unhinged::observability::v1::TraceContext* trace_context) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.trace_context_);
  }
  _impl_.trace_context_ = trace_context;
  if (trace_context) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.MetricEvent.trace_context)
}
inline ::unhinged::observability::v1::TraceContext* MetricEvent::release_trace_context() {
  
  ::unhinged::observability::v1::TraceContext* temp = _impl_.trace_context_;
  _impl_.trace_context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::observability::v1::TraceContext* MetricEvent::unsafe_arena_release_trace_context() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.MetricEvent.trace_context)
  
  ::unhinged::observability::v1::TraceContext* temp = _impl_.trace_context_;
  _impl_.trace_context_ = nullptr;
  return temp;
}
inline ::unhinged::observability::v1::TraceContext* MetricEvent::_internal_mutable_trace_context() {
  
  if (_impl_.trace_context_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::observability::v1::TraceContext>(GetArenaForAllocation());
    _impl_.trace_context_ = p;
  }
  return _impl_.trace_context_;
}
inline ::unhinged::observability::v1::TraceContext* MetricEvent::mutable_trace_context() {
  ::unhinged::observability::v1::TraceContext* _msg = _internal_mutable_trace_context();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.MetricEvent.trace_context)
  return _msg;
}
inline void MetricEvent::set_allocated_trace_context(::unhinged::observability::v1::TraceContext* trace_context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.trace_context_;
  }
  if (trace_context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(trace_context);
    if (message_arena != submessage_arena) {
      trace_context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trace_context, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.trace_context_ = trace_context;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.MetricEvent.trace_context)
}

// .unhinged.observability.v1.Resource resource = 6;
inline bool MetricEvent::_internal_has_resource() const {
  return this != internal_default_instance() && _impl_.resource_ != nullptr;
}
inline bool MetricEvent::has_resource() const {
  return _internal_has_resource();
}
inline void MetricEvent::clear_resource() {
  if (GetArenaForAllocation() == nullptr && _impl_.resource_ != nullptr) {
    delete _impl_.resource_;
  }
  _impl_.resource_ = nullptr;
}
inline const ::unhinged::observability::v1::Resource& MetricEvent::_internal_resource() const {
  const ::unhinged::observability::v1::Resource* p = _impl_.resource_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::observability::v1::Resource&>(
      ::unhinged::observability::v1::_Resource_default_instance_);
}
inline const ::unhinged::observability::v1::Resource& MetricEvent::resource() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.MetricEvent.resource)
  return _internal_resource();
}
inline void MetricEvent::unsafe_arena_set_allocated_resource(
    ::unhinged::observability::v1::Resource* resource) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.resource_);
  }
  _impl_.resource_ = resource;
  if (resource) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.MetricEvent.resource)
}
inline ::unhinged::observability::v1::Resource* MetricEvent::release_resource() {
  
  ::unhinged::observability::v1::Resource* temp = _impl_.resource_;
  _impl_.resource_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::observability::v1::Resource* MetricEvent::unsafe_arena_release_resource() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.MetricEvent.resource)
  
  ::unhinged::observability::v1::Resource* temp = _impl_.resource_;
  _impl_.resource_ = nullptr;
  return temp;
}
inline ::unhinged::observability::v1::Resource* MetricEvent::_internal_mutable_resource() {
  
  if (_impl_.resource_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::observability::v1::Resource>(GetArenaForAllocation());
    _impl_.resource_ = p;
  }
  return _impl_.resource_;
}
inline ::unhinged::observability::v1::Resource* MetricEvent::mutable_resource() {
  ::unhinged::observability::v1::Resource* _msg = _internal_mutable_resource();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.MetricEvent.resource)
  return _msg;
}
inline void MetricEvent::set_allocated_resource(::unhinged::observability::v1::Resource* resource) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.resource_;
  }
  if (resource) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(resource);
    if (message_arena != submessage_arena) {
      resource = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, resource, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.resource_ = resource;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.MetricEvent.resource)
}

// .unhinged.observability.v1.MetricData metric = 10;
inline bool MetricEvent::_internal_has_metric() const {
  return this != internal_default_instance() && _impl_.metric_ != nullptr;
}
inline bool MetricEvent::has_metric() const {
  return _internal_has_metric();
}
inline void MetricEvent::clear_metric() {
  if (GetArenaForAllocation() == nullptr && _impl_.metric_ != nullptr) {
    delete _impl_.metric_;
  }
  _impl_.metric_ = nullptr;
}
inline const ::unhinged::observability::v1::MetricData& MetricEvent::_internal_metric() const {
  const ::unhinged::observability::v1::MetricData* p = _impl_.metric_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::observability::v1::MetricData&>(
      ::unhinged::observability::v1::_MetricData_default_instance_);
}
inline const ::unhinged::observability::v1::MetricData& MetricEvent::metric() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.MetricEvent.metric)
  return _internal_metric();
}
inline void MetricEvent::unsafe_arena_set_allocated_metric(
    ::unhinged::observability::v1::MetricData* metric) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metric_);
  }
  _impl_.metric_ = metric;
  if (metric) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.MetricEvent.metric)
}
inline ::unhinged::observability::v1::MetricData* MetricEvent::release_metric() {
  
  ::unhinged::observability::v1::MetricData* temp = _impl_.metric_;
  _impl_.metric_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::observability::v1::MetricData* MetricEvent::unsafe_arena_release_metric() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.MetricEvent.metric)
  
  ::unhinged::observability::v1::MetricData* temp = _impl_.metric_;
  _impl_.metric_ = nullptr;
  return temp;
}
inline ::unhinged::observability::v1::MetricData* MetricEvent::_internal_mutable_metric() {
  
  if (_impl_.metric_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::observability::v1::MetricData>(GetArenaForAllocation());
    _impl_.metric_ = p;
  }
  return _impl_.metric_;
}
inline ::unhinged::observability::v1::MetricData* MetricEvent::mutable_metric() {
  ::unhinged::observability::v1::MetricData* _msg = _internal_mutable_metric();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.MetricEvent.metric)
  return _msg;
}
inline void MetricEvent::set_allocated_metric(::unhinged::observability::v1::MetricData* metric) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.metric_;
  }
  if (metric) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(metric);
    if (message_arena != submessage_arena) {
      metric = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metric, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.metric_ = metric;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.MetricEvent.metric)
}

// .unhinged.observability.v1.DestinationFlags destinations = 20;
inline bool MetricEvent::_internal_has_destinations() const {
  return this != internal_default_instance() && _impl_.destinations_ != nullptr;
}
inline bool MetricEvent::has_destinations() const {
  return _internal_has_destinations();
}
inline void MetricEvent::clear_destinations() {
  if (GetArenaForAllocation() == nullptr && _impl_.destinations_ != nullptr) {
    delete _impl_.destinations_;
  }
  _impl_.destinations_ = nullptr;
}
inline const ::unhinged::observability::v1::DestinationFlags& MetricEvent::_internal_destinations() const {
  const ::unhinged::observability::v1::DestinationFlags* p = _impl_.destinations_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::observability::v1::DestinationFlags&>(
      ::unhinged::observability::v1::_DestinationFlags_default_instance_);
}
inline const ::unhinged::observability::v1::DestinationFlags& MetricEvent::destinations() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.MetricEvent.destinations)
  return _internal_destinations();
}
inline void MetricEvent::unsafe_arena_set_allocated_destinations(
    ::unhinged::observability::v1::DestinationFlags* destinations) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.destinations_);
  }
  _impl_.destinations_ = destinations;
  if (destinations) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.MetricEvent.destinations)
}
inline ::unhinged::observability::v1::DestinationFlags* MetricEvent::release_destinations() {
  
  ::unhinged::observability::v1::DestinationFlags* temp = _impl_.destinations_;
  _impl_.destinations_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::observability::v1::DestinationFlags* MetricEvent::unsafe_arena_release_destinations() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.MetricEvent.destinations)
  
  ::unhinged::observability::v1::DestinationFlags* temp = _impl_.destinations_;
  _impl_.destinations_ = nullptr;
  return temp;
}
inline ::unhinged::observability::v1::DestinationFlags* MetricEvent::_internal_mutable_destinations() {
  
  if (_impl_.destinations_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::observability::v1::DestinationFlags>(GetArenaForAllocation());
    _impl_.destinations_ = p;
  }
  return _impl_.destinations_;
}
inline ::unhinged::observability::v1::DestinationFlags* MetricEvent::mutable_destinations() {
  ::unhinged::observability::v1::DestinationFlags* _msg = _internal_mutable_destinations();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.MetricEvent.destinations)
  return _msg;
}
inline void MetricEvent::set_allocated_destinations(::unhinged::observability::v1::DestinationFlags* destinations) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.destinations_;
  }
  if (destinations) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(destinations);
    if (message_arena != submessage_arena) {
      destinations = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, destinations, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.destinations_ = destinations;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.MetricEvent.destinations)
}

// .unhinged.observability.v1.PartitionInfo partition_info = 25;
inline bool MetricEvent::_internal_has_partition_info() const {
  return this != internal_default_instance() && _impl_.partition_info_ != nullptr;
}
inline bool MetricEvent::has_partition_info() const {
  return _internal_has_partition_info();
}
inline void MetricEvent::clear_partition_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.partition_info_ != nullptr) {
    delete _impl_.partition_info_;
  }
  _impl_.partition_info_ = nullptr;
}
inline const ::unhinged::observability::v1::PartitionInfo& MetricEvent::_internal_partition_info() const {
  const ::unhinged::observability::v1::PartitionInfo* p = _impl_.partition_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::observability::v1::PartitionInfo&>(
      ::unhinged::observability::v1::_PartitionInfo_default_instance_);
}
inline const ::unhinged::observability::v1::PartitionInfo& MetricEvent::partition_info() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.MetricEvent.partition_info)
  return _internal_partition_info();
}
inline void MetricEvent::unsafe_arena_set_allocated_partition_info(
    ::unhinged::observability::v1::PartitionInfo* partition_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.partition_info_);
  }
  _impl_.partition_info_ = partition_info;
  if (partition_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.MetricEvent.partition_info)
}
inline ::unhinged::observability::v1::PartitionInfo* MetricEvent::release_partition_info() {
  
  ::unhinged::observability::v1::PartitionInfo* temp = _impl_.partition_info_;
  _impl_.partition_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::observability::v1::PartitionInfo* MetricEvent::unsafe_arena_release_partition_info() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.MetricEvent.partition_info)
  
  ::unhinged::observability::v1::PartitionInfo* temp = _impl_.partition_info_;
  _impl_.partition_info_ = nullptr;
  return temp;
}
inline ::unhinged::observability::v1::PartitionInfo* MetricEvent::_internal_mutable_partition_info() {
  
  if (_impl_.partition_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::observability::v1::PartitionInfo>(GetArenaForAllocation());
    _impl_.partition_info_ = p;
  }
  return _impl_.partition_info_;
}
inline ::unhinged::observability::v1::PartitionInfo* MetricEvent::mutable_partition_info() {
  ::unhinged::observability::v1::PartitionInfo* _msg = _internal_mutable_partition_info();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.MetricEvent.partition_info)
  return _msg;
}
inline void MetricEvent::set_allocated_partition_info(::unhinged::observability::v1::PartitionInfo* partition_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.partition_info_;
  }
  if (partition_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(partition_info);
    if (message_arena != submessage_arena) {
      partition_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, partition_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.partition_info_ = partition_info;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.MetricEvent.partition_info)
}

// -------------------------------------------------------------------

// MetricData

// string name = 1;
inline void MetricData::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& MetricData::name() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.MetricData.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MetricData::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.MetricData.name)
}
inline std::string* MetricData::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.MetricData.name)
  return _s;
}
inline const std::string& MetricData::_internal_name() const {
  return _impl_.name_.Get();
}
inline void MetricData::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* MetricData::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* MetricData::release_name() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.MetricData.name)
  return _impl_.name_.Release();
}
inline void MetricData::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.MetricData.name)
}

// string description = 2;
inline void MetricData::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& MetricData::description() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.MetricData.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MetricData::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.MetricData.description)
}
inline std::string* MetricData::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.MetricData.description)
  return _s;
}
inline const std::string& MetricData::_internal_description() const {
  return _impl_.description_.Get();
}
inline void MetricData::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* MetricData::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* MetricData::release_description() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.MetricData.description)
  return _impl_.description_.Release();
}
inline void MetricData::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.MetricData.description)
}

// string unit = 3;
inline void MetricData::clear_unit() {
  _impl_.unit_.ClearToEmpty();
}
inline const std::string& MetricData::unit() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.MetricData.unit)
  return _internal_unit();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MetricData::set_unit(ArgT0&& arg0, ArgT... args) {
 
 _impl_.unit_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.MetricData.unit)
}
inline std::string* MetricData::mutable_unit() {
  std::string* _s = _internal_mutable_unit();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.MetricData.unit)
  return _s;
}
inline const std::string& MetricData::_internal_unit() const {
  return _impl_.unit_.Get();
}
inline void MetricData::_internal_set_unit(const std::string& value) {
  
  _impl_.unit_.Set(value, GetArenaForAllocation());
}
inline std::string* MetricData::_internal_mutable_unit() {
  
  return _impl_.unit_.Mutable(GetArenaForAllocation());
}
inline std::string* MetricData::release_unit() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.MetricData.unit)
  return _impl_.unit_.Release();
}
inline void MetricData::set_allocated_unit(std::string* unit) {
  if (unit != nullptr) {
    
  } else {
    
  }
  _impl_.unit_.SetAllocated(unit, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.unit_.IsDefault()) {
    _impl_.unit_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.MetricData.unit)
}

// .unhinged.observability.v1.GaugeData gauge = 10;
inline bool MetricData::_internal_has_gauge() const {
  return data_case() == kGauge;
}
inline bool MetricData::has_gauge() const {
  return _internal_has_gauge();
}
inline void MetricData::set_has_gauge() {
  _impl_._oneof_case_[0] = kGauge;
}
inline void MetricData::clear_gauge() {
  if (_internal_has_gauge()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.data_.gauge_;
    }
    clear_has_data();
  }
}
inline ::unhinged::observability::v1::GaugeData* MetricData::release_gauge() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.MetricData.gauge)
  if (_internal_has_gauge()) {
    clear_has_data();
    ::unhinged::observability::v1::GaugeData* temp = _impl_.data_.gauge_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.gauge_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::observability::v1::GaugeData& MetricData::_internal_gauge() const {
  return _internal_has_gauge()
      ? *_impl_.data_.gauge_
      : reinterpret_cast< ::unhinged::observability::v1::GaugeData&>(::unhinged::observability::v1::_GaugeData_default_instance_);
}
inline const ::unhinged::observability::v1::GaugeData& MetricData::gauge() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.MetricData.gauge)
  return _internal_gauge();
}
inline ::unhinged::observability::v1::GaugeData* MetricData::unsafe_arena_release_gauge() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.observability.v1.MetricData.gauge)
  if (_internal_has_gauge()) {
    clear_has_data();
    ::unhinged::observability::v1::GaugeData* temp = _impl_.data_.gauge_;
    _impl_.data_.gauge_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MetricData::unsafe_arena_set_allocated_gauge(::unhinged::observability::v1::GaugeData* gauge) {
  clear_data();
  if (gauge) {
    set_has_gauge();
    _impl_.data_.gauge_ = gauge;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.MetricData.gauge)
}
inline ::unhinged::observability::v1::GaugeData* MetricData::_internal_mutable_gauge() {
  if (!_internal_has_gauge()) {
    clear_data();
    set_has_gauge();
    _impl_.data_.gauge_ = CreateMaybeMessage< ::unhinged::observability::v1::GaugeData >(GetArenaForAllocation());
  }
  return _impl_.data_.gauge_;
}
inline ::unhinged::observability::v1::GaugeData* MetricData::mutable_gauge() {
  ::unhinged::observability::v1::GaugeData* _msg = _internal_mutable_gauge();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.MetricData.gauge)
  return _msg;
}

// .unhinged.observability.v1.CounterData counter = 11;
inline bool MetricData::_internal_has_counter() const {
  return data_case() == kCounter;
}
inline bool MetricData::has_counter() const {
  return _internal_has_counter();
}
inline void MetricData::set_has_counter() {
  _impl_._oneof_case_[0] = kCounter;
}
inline void MetricData::clear_counter() {
  if (_internal_has_counter()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.data_.counter_;
    }
    clear_has_data();
  }
}
inline ::unhinged::observability::v1::CounterData* MetricData::release_counter() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.MetricData.counter)
  if (_internal_has_counter()) {
    clear_has_data();
    ::unhinged::observability::v1::CounterData* temp = _impl_.data_.counter_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.counter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::observability::v1::CounterData& MetricData::_internal_counter() const {
  return _internal_has_counter()
      ? *_impl_.data_.counter_
      : reinterpret_cast< ::unhinged::observability::v1::CounterData&>(::unhinged::observability::v1::_CounterData_default_instance_);
}
inline const ::unhinged::observability::v1::CounterData& MetricData::counter() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.MetricData.counter)
  return _internal_counter();
}
inline ::unhinged::observability::v1::CounterData* MetricData::unsafe_arena_release_counter() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.observability.v1.MetricData.counter)
  if (_internal_has_counter()) {
    clear_has_data();
    ::unhinged::observability::v1::CounterData* temp = _impl_.data_.counter_;
    _impl_.data_.counter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MetricData::unsafe_arena_set_allocated_counter(::unhinged::observability::v1::CounterData* counter) {
  clear_data();
  if (counter) {
    set_has_counter();
    _impl_.data_.counter_ = counter;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.MetricData.counter)
}
inline ::unhinged::observability::v1::CounterData* MetricData::_internal_mutable_counter() {
  if (!_internal_has_counter()) {
    clear_data();
    set_has_counter();
    _impl_.data_.counter_ = CreateMaybeMessage< ::unhinged::observability::v1::CounterData >(GetArenaForAllocation());
  }
  return _impl_.data_.counter_;
}
inline ::unhinged::observability::v1::CounterData* MetricData::mutable_counter() {
  ::unhinged::observability::v1::CounterData* _msg = _internal_mutable_counter();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.MetricData.counter)
  return _msg;
}

// .unhinged.observability.v1.HistogramData histogram = 12;
inline bool MetricData::_internal_has_histogram() const {
  return data_case() == kHistogram;
}
inline bool MetricData::has_histogram() const {
  return _internal_has_histogram();
}
inline void MetricData::set_has_histogram() {
  _impl_._oneof_case_[0] = kHistogram;
}
inline void MetricData::clear_histogram() {
  if (_internal_has_histogram()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.data_.histogram_;
    }
    clear_has_data();
  }
}
inline ::unhinged::observability::v1::HistogramData* MetricData::release_histogram() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.MetricData.histogram)
  if (_internal_has_histogram()) {
    clear_has_data();
    ::unhinged::observability::v1::HistogramData* temp = _impl_.data_.histogram_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.histogram_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::observability::v1::HistogramData& MetricData::_internal_histogram() const {
  return _internal_has_histogram()
      ? *_impl_.data_.histogram_
      : reinterpret_cast< ::unhinged::observability::v1::HistogramData&>(::unhinged::observability::v1::_HistogramData_default_instance_);
}
inline const ::unhinged::observability::v1::HistogramData& MetricData::histogram() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.MetricData.histogram)
  return _internal_histogram();
}
inline ::unhinged::observability::v1::HistogramData* MetricData::unsafe_arena_release_histogram() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.observability.v1.MetricData.histogram)
  if (_internal_has_histogram()) {
    clear_has_data();
    ::unhinged::observability::v1::HistogramData* temp = _impl_.data_.histogram_;
    _impl_.data_.histogram_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MetricData::unsafe_arena_set_allocated_histogram(::unhinged::observability::v1::HistogramData* histogram) {
  clear_data();
  if (histogram) {
    set_has_histogram();
    _impl_.data_.histogram_ = histogram;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.MetricData.histogram)
}
inline ::unhinged::observability::v1::HistogramData* MetricData::_internal_mutable_histogram() {
  if (!_internal_has_histogram()) {
    clear_data();
    set_has_histogram();
    _impl_.data_.histogram_ = CreateMaybeMessage< ::unhinged::observability::v1::HistogramData >(GetArenaForAllocation());
  }
  return _impl_.data_.histogram_;
}
inline ::unhinged::observability::v1::HistogramData* MetricData::mutable_histogram() {
  ::unhinged::observability::v1::HistogramData* _msg = _internal_mutable_histogram();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.MetricData.histogram)
  return _msg;
}

// .unhinged.observability.v1.SummaryData summary = 13;
inline bool MetricData::_internal_has_summary() const {
  return data_case() == kSummary;
}
inline bool MetricData::has_summary() const {
  return _internal_has_summary();
}
inline void MetricData::set_has_summary() {
  _impl_._oneof_case_[0] = kSummary;
}
inline void MetricData::clear_summary() {
  if (_internal_has_summary()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.data_.summary_;
    }
    clear_has_data();
  }
}
inline ::unhinged::observability::v1::SummaryData* MetricData::release_summary() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.MetricData.summary)
  if (_internal_has_summary()) {
    clear_has_data();
    ::unhinged::observability::v1::SummaryData* temp = _impl_.data_.summary_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.summary_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::observability::v1::SummaryData& MetricData::_internal_summary() const {
  return _internal_has_summary()
      ? *_impl_.data_.summary_
      : reinterpret_cast< ::unhinged::observability::v1::SummaryData&>(::unhinged::observability::v1::_SummaryData_default_instance_);
}
inline const ::unhinged::observability::v1::SummaryData& MetricData::summary() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.MetricData.summary)
  return _internal_summary();
}
inline ::unhinged::observability::v1::SummaryData* MetricData::unsafe_arena_release_summary() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.observability.v1.MetricData.summary)
  if (_internal_has_summary()) {
    clear_has_data();
    ::unhinged::observability::v1::SummaryData* temp = _impl_.data_.summary_;
    _impl_.data_.summary_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MetricData::unsafe_arena_set_allocated_summary(::unhinged::observability::v1::SummaryData* summary) {
  clear_data();
  if (summary) {
    set_has_summary();
    _impl_.data_.summary_ = summary;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.MetricData.summary)
}
inline ::unhinged::observability::v1::SummaryData* MetricData::_internal_mutable_summary() {
  if (!_internal_has_summary()) {
    clear_data();
    set_has_summary();
    _impl_.data_.summary_ = CreateMaybeMessage< ::unhinged::observability::v1::SummaryData >(GetArenaForAllocation());
  }
  return _impl_.data_.summary_;
}
inline ::unhinged::observability::v1::SummaryData* MetricData::mutable_summary() {
  ::unhinged::observability::v1::SummaryData* _msg = _internal_mutable_summary();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.MetricData.summary)
  return _msg;
}

// .unhinged.observability.v1.InstrumentationLibrary instrumentation_library = 20;
inline bool MetricData::_internal_has_instrumentation_library() const {
  return this != internal_default_instance() && _impl_.instrumentation_library_ != nullptr;
}
inline bool MetricData::has_instrumentation_library() const {
  return _internal_has_instrumentation_library();
}
inline void MetricData::clear_instrumentation_library() {
  if (GetArenaForAllocation() == nullptr && _impl_.instrumentation_library_ != nullptr) {
    delete _impl_.instrumentation_library_;
  }
  _impl_.instrumentation_library_ = nullptr;
}
inline const ::unhinged::observability::v1::InstrumentationLibrary& MetricData::_internal_instrumentation_library() const {
  const ::unhinged::observability::v1::InstrumentationLibrary* p = _impl_.instrumentation_library_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::observability::v1::InstrumentationLibrary&>(
      ::unhinged::observability::v1::_InstrumentationLibrary_default_instance_);
}
inline const ::unhinged::observability::v1::InstrumentationLibrary& MetricData::instrumentation_library() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.MetricData.instrumentation_library)
  return _internal_instrumentation_library();
}
inline void MetricData::unsafe_arena_set_allocated_instrumentation_library(
    ::unhinged::observability::v1::InstrumentationLibrary* instrumentation_library) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.instrumentation_library_);
  }
  _impl_.instrumentation_library_ = instrumentation_library;
  if (instrumentation_library) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.MetricData.instrumentation_library)
}
inline ::unhinged::observability::v1::InstrumentationLibrary* MetricData::release_instrumentation_library() {
  
  ::unhinged::observability::v1::InstrumentationLibrary* temp = _impl_.instrumentation_library_;
  _impl_.instrumentation_library_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::observability::v1::InstrumentationLibrary* MetricData::unsafe_arena_release_instrumentation_library() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.MetricData.instrumentation_library)
  
  ::unhinged::observability::v1::InstrumentationLibrary* temp = _impl_.instrumentation_library_;
  _impl_.instrumentation_library_ = nullptr;
  return temp;
}
inline ::unhinged::observability::v1::InstrumentationLibrary* MetricData::_internal_mutable_instrumentation_library() {
  
  if (_impl_.instrumentation_library_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::observability::v1::InstrumentationLibrary>(GetArenaForAllocation());
    _impl_.instrumentation_library_ = p;
  }
  return _impl_.instrumentation_library_;
}
inline ::unhinged::observability::v1::InstrumentationLibrary* MetricData::mutable_instrumentation_library() {
  ::unhinged::observability::v1::InstrumentationLibrary* _msg = _internal_mutable_instrumentation_library();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.MetricData.instrumentation_library)
  return _msg;
}
inline void MetricData::set_allocated_instrumentation_library(::unhinged::observability::v1::InstrumentationLibrary* instrumentation_library) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.instrumentation_library_;
  }
  if (instrumentation_library) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(instrumentation_library);
    if (message_arena != submessage_arena) {
      instrumentation_library = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, instrumentation_library, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.instrumentation_library_ = instrumentation_library;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.MetricData.instrumentation_library)
}

inline bool MetricData::has_data() const {
  return data_case() != DATA_NOT_SET;
}
inline void MetricData::clear_has_data() {
  _impl_._oneof_case_[0] = DATA_NOT_SET;
}
inline MetricData::DataCase MetricData::data_case() const {
  return MetricData::DataCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// GaugeData

// repeated .unhinged.observability.v1.NumberDataPoint data_points = 1;
inline int GaugeData::_internal_data_points_size() const {
  return _impl_.data_points_.size();
}
inline int GaugeData::data_points_size() const {
  return _internal_data_points_size();
}
inline void GaugeData::clear_data_points() {
  _impl_.data_points_.Clear();
}
inline ::unhinged::observability::v1::NumberDataPoint* GaugeData::mutable_data_points(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.GaugeData.data_points)
  return _impl_.data_points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::NumberDataPoint >*
GaugeData::mutable_data_points() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.observability.v1.GaugeData.data_points)
  return &_impl_.data_points_;
}
inline const ::unhinged::observability::v1::NumberDataPoint& GaugeData::_internal_data_points(int index) const {
  return _impl_.data_points_.Get(index);
}
inline const ::unhinged::observability::v1::NumberDataPoint& GaugeData::data_points(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.GaugeData.data_points)
  return _internal_data_points(index);
}
inline ::unhinged::observability::v1::NumberDataPoint* GaugeData::_internal_add_data_points() {
  return _impl_.data_points_.Add();
}
inline ::unhinged::observability::v1::NumberDataPoint* GaugeData::add_data_points() {
  ::unhinged::observability::v1::NumberDataPoint* _add = _internal_add_data_points();
  // @@protoc_insertion_point(field_add:unhinged.observability.v1.GaugeData.data_points)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::NumberDataPoint >&
GaugeData::data_points() const {
  // @@protoc_insertion_point(field_list:unhinged.observability.v1.GaugeData.data_points)
  return _impl_.data_points_;
}

// -------------------------------------------------------------------

// CounterData

// repeated .unhinged.observability.v1.NumberDataPoint data_points = 1;
inline int CounterData::_internal_data_points_size() const {
  return _impl_.data_points_.size();
}
inline int CounterData::data_points_size() const {
  return _internal_data_points_size();
}
inline void CounterData::clear_data_points() {
  _impl_.data_points_.Clear();
}
inline ::unhinged::observability::v1::NumberDataPoint* CounterData::mutable_data_points(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.CounterData.data_points)
  return _impl_.data_points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::NumberDataPoint >*
CounterData::mutable_data_points() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.observability.v1.CounterData.data_points)
  return &_impl_.data_points_;
}
inline const ::unhinged::observability::v1::NumberDataPoint& CounterData::_internal_data_points(int index) const {
  return _impl_.data_points_.Get(index);
}
inline const ::unhinged::observability::v1::NumberDataPoint& CounterData::data_points(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.CounterData.data_points)
  return _internal_data_points(index);
}
inline ::unhinged::observability::v1::NumberDataPoint* CounterData::_internal_add_data_points() {
  return _impl_.data_points_.Add();
}
inline ::unhinged::observability::v1::NumberDataPoint* CounterData::add_data_points() {
  ::unhinged::observability::v1::NumberDataPoint* _add = _internal_add_data_points();
  // @@protoc_insertion_point(field_add:unhinged.observability.v1.CounterData.data_points)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::NumberDataPoint >&
CounterData::data_points() const {
  // @@protoc_insertion_point(field_list:unhinged.observability.v1.CounterData.data_points)
  return _impl_.data_points_;
}

// bool is_monotonic = 2;
inline void CounterData::clear_is_monotonic() {
  _impl_.is_monotonic_ = false;
}
inline bool CounterData::_internal_is_monotonic() const {
  return _impl_.is_monotonic_;
}
inline bool CounterData::is_monotonic() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.CounterData.is_monotonic)
  return _internal_is_monotonic();
}
inline void CounterData::_internal_set_is_monotonic(bool value) {
  
  _impl_.is_monotonic_ = value;
}
inline void CounterData::set_is_monotonic(bool value) {
  _internal_set_is_monotonic(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.CounterData.is_monotonic)
}

// -------------------------------------------------------------------

// HistogramData

// repeated .unhinged.observability.v1.HistogramDataPoint data_points = 1;
inline int HistogramData::_internal_data_points_size() const {
  return _impl_.data_points_.size();
}
inline int HistogramData::data_points_size() const {
  return _internal_data_points_size();
}
inline void HistogramData::clear_data_points() {
  _impl_.data_points_.Clear();
}
inline ::unhinged::observability::v1::HistogramDataPoint* HistogramData::mutable_data_points(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.HistogramData.data_points)
  return _impl_.data_points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::HistogramDataPoint >*
HistogramData::mutable_data_points() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.observability.v1.HistogramData.data_points)
  return &_impl_.data_points_;
}
inline const ::unhinged::observability::v1::HistogramDataPoint& HistogramData::_internal_data_points(int index) const {
  return _impl_.data_points_.Get(index);
}
inline const ::unhinged::observability::v1::HistogramDataPoint& HistogramData::data_points(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.HistogramData.data_points)
  return _internal_data_points(index);
}
inline ::unhinged::observability::v1::HistogramDataPoint* HistogramData::_internal_add_data_points() {
  return _impl_.data_points_.Add();
}
inline ::unhinged::observability::v1::HistogramDataPoint* HistogramData::add_data_points() {
  ::unhinged::observability::v1::HistogramDataPoint* _add = _internal_add_data_points();
  // @@protoc_insertion_point(field_add:unhinged.observability.v1.HistogramData.data_points)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::HistogramDataPoint >&
HistogramData::data_points() const {
  // @@protoc_insertion_point(field_list:unhinged.observability.v1.HistogramData.data_points)
  return _impl_.data_points_;
}

// .unhinged.observability.v1.AggregationTemporality aggregation_temporality = 2;
inline void HistogramData::clear_aggregation_temporality() {
  _impl_.aggregation_temporality_ = 0;
}
inline ::unhinged::observability::v1::AggregationTemporality HistogramData::_internal_aggregation_temporality() const {
  return static_cast< ::unhinged::observability::v1::AggregationTemporality >(_impl_.aggregation_temporality_);
}
inline ::unhinged::observability::v1::AggregationTemporality HistogramData::aggregation_temporality() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.HistogramData.aggregation_temporality)
  return _internal_aggregation_temporality();
}
inline void HistogramData::_internal_set_aggregation_temporality(::unhinged::observability::v1::AggregationTemporality value) {
  
  _impl_.aggregation_temporality_ = value;
}
inline void HistogramData::set_aggregation_temporality(::unhinged::observability::v1::AggregationTemporality value) {
  _internal_set_aggregation_temporality(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.HistogramData.aggregation_temporality)
}

// -------------------------------------------------------------------

// SummaryData

// repeated .unhinged.observability.v1.SummaryDataPoint data_points = 1;
inline int SummaryData::_internal_data_points_size() const {
  return _impl_.data_points_.size();
}
inline int SummaryData::data_points_size() const {
  return _internal_data_points_size();
}
inline void SummaryData::clear_data_points() {
  _impl_.data_points_.Clear();
}
inline ::unhinged::observability::v1::SummaryDataPoint* SummaryData::mutable_data_points(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.SummaryData.data_points)
  return _impl_.data_points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::SummaryDataPoint >*
SummaryData::mutable_data_points() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.observability.v1.SummaryData.data_points)
  return &_impl_.data_points_;
}
inline const ::unhinged::observability::v1::SummaryDataPoint& SummaryData::_internal_data_points(int index) const {
  return _impl_.data_points_.Get(index);
}
inline const ::unhinged::observability::v1::SummaryDataPoint& SummaryData::data_points(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.SummaryData.data_points)
  return _internal_data_points(index);
}
inline ::unhinged::observability::v1::SummaryDataPoint* SummaryData::_internal_add_data_points() {
  return _impl_.data_points_.Add();
}
inline ::unhinged::observability::v1::SummaryDataPoint* SummaryData::add_data_points() {
  ::unhinged::observability::v1::SummaryDataPoint* _add = _internal_add_data_points();
  // @@protoc_insertion_point(field_add:unhinged.observability.v1.SummaryData.data_points)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::SummaryDataPoint >&
SummaryData::data_points() const {
  // @@protoc_insertion_point(field_list:unhinged.observability.v1.SummaryData.data_points)
  return _impl_.data_points_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// NumberDataPoint

// map<string, .unhinged.observability.v1.AttributeValue> attributes = 1;
inline int NumberDataPoint::_internal_attributes_size() const {
  return _impl_.attributes_.size();
}
inline int NumberDataPoint::attributes_size() const {
  return _internal_attributes_size();
}
inline void NumberDataPoint::clear_attributes() {
  _impl_.attributes_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::unhinged::observability::v1::AttributeValue >&
NumberDataPoint::_internal_attributes() const {
  return _impl_.attributes_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::unhinged::observability::v1::AttributeValue >&
NumberDataPoint::attributes() const {
  // @@protoc_insertion_point(field_map:unhinged.observability.v1.NumberDataPoint.attributes)
  return _internal_attributes();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::unhinged::observability::v1::AttributeValue >*
NumberDataPoint::_internal_mutable_attributes() {
  return _impl_.attributes_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::unhinged::observability::v1::AttributeValue >*
NumberDataPoint::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_map:unhinged.observability.v1.NumberDataPoint.attributes)
  return _internal_mutable_attributes();
}

// .google.protobuf.Timestamp start_time = 2;
inline bool NumberDataPoint::_internal_has_start_time() const {
  return this != internal_default_instance() && _impl_.start_time_ != nullptr;
}
inline bool NumberDataPoint::has_start_time() const {
  return _internal_has_start_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& NumberDataPoint::_internal_start_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.start_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& NumberDataPoint::start_time() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.NumberDataPoint.start_time)
  return _internal_start_time();
}
inline void NumberDataPoint::unsafe_arena_set_allocated_start_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_time_);
  }
  _impl_.start_time_ = start_time;
  if (start_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.NumberDataPoint.start_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* NumberDataPoint::release_start_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.start_time_;
  _impl_.start_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* NumberDataPoint::unsafe_arena_release_start_time() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.NumberDataPoint.start_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.start_time_;
  _impl_.start_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* NumberDataPoint::_internal_mutable_start_time() {
  
  if (_impl_.start_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.start_time_ = p;
  }
  return _impl_.start_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* NumberDataPoint::mutable_start_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_start_time();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.NumberDataPoint.start_time)
  return _msg;
}
inline void NumberDataPoint::set_allocated_start_time(::PROTOBUF_NAMESPACE_ID::Timestamp* start_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_time_);
  }
  if (start_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_time));
    if (message_arena != submessage_arena) {
      start_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.start_time_ = start_time;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.NumberDataPoint.start_time)
}

// .google.protobuf.Timestamp time = 3;
inline bool NumberDataPoint::_internal_has_time() const {
  return this != internal_default_instance() && _impl_.time_ != nullptr;
}
inline bool NumberDataPoint::has_time() const {
  return _internal_has_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& NumberDataPoint::_internal_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& NumberDataPoint::time() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.NumberDataPoint.time)
  return _internal_time();
}
inline void NumberDataPoint::unsafe_arena_set_allocated_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_);
  }
  _impl_.time_ = time;
  if (time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.NumberDataPoint.time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* NumberDataPoint::release_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.time_;
  _impl_.time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* NumberDataPoint::unsafe_arena_release_time() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.NumberDataPoint.time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.time_;
  _impl_.time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* NumberDataPoint::_internal_mutable_time() {
  
  if (_impl_.time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.time_ = p;
  }
  return _impl_.time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* NumberDataPoint::mutable_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.NumberDataPoint.time)
  return _msg;
}
inline void NumberDataPoint::set_allocated_time(::PROTOBUF_NAMESPACE_ID::Timestamp* time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_);
  }
  if (time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time));
    if (message_arena != submessage_arena) {
      time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.time_ = time;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.NumberDataPoint.time)
}

// double as_double = 10;
inline bool NumberDataPoint::_internal_has_as_double() const {
  return value_case() == kAsDouble;
}
inline bool NumberDataPoint::has_as_double() const {
  return _internal_has_as_double();
}
inline void NumberDataPoint::set_has_as_double() {
  _impl_._oneof_case_[0] = kAsDouble;
}
inline void NumberDataPoint::clear_as_double() {
  if (_internal_has_as_double()) {
    _impl_.value_.as_double_ = 0;
    clear_has_value();
  }
}
inline double NumberDataPoint::_internal_as_double() const {
  if (_internal_has_as_double()) {
    return _impl_.value_.as_double_;
  }
  return 0;
}
inline void NumberDataPoint::_internal_set_as_double(double value) {
  if (!_internal_has_as_double()) {
    clear_value();
    set_has_as_double();
  }
  _impl_.value_.as_double_ = value;
}
inline double NumberDataPoint::as_double() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.NumberDataPoint.as_double)
  return _internal_as_double();
}
inline void NumberDataPoint::set_as_double(double value) {
  _internal_set_as_double(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.NumberDataPoint.as_double)
}

// int64 as_int = 11;
inline bool NumberDataPoint::_internal_has_as_int() const {
  return value_case() == kAsInt;
}
inline bool NumberDataPoint::has_as_int() const {
  return _internal_has_as_int();
}
inline void NumberDataPoint::set_has_as_int() {
  _impl_._oneof_case_[0] = kAsInt;
}
inline void NumberDataPoint::clear_as_int() {
  if (_internal_has_as_int()) {
    _impl_.value_.as_int_ = int64_t{0};
    clear_has_value();
  }
}
inline int64_t NumberDataPoint::_internal_as_int() const {
  if (_internal_has_as_int()) {
    return _impl_.value_.as_int_;
  }
  return int64_t{0};
}
inline void NumberDataPoint::_internal_set_as_int(int64_t value) {
  if (!_internal_has_as_int()) {
    clear_value();
    set_has_as_int();
  }
  _impl_.value_.as_int_ = value;
}
inline int64_t NumberDataPoint::as_int() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.NumberDataPoint.as_int)
  return _internal_as_int();
}
inline void NumberDataPoint::set_as_int(int64_t value) {
  _internal_set_as_int(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.NumberDataPoint.as_int)
}

// repeated .unhinged.observability.v1.Exemplar exemplars = 20;
inline int NumberDataPoint::_internal_exemplars_size() const {
  return _impl_.exemplars_.size();
}
inline int NumberDataPoint::exemplars_size() const {
  return _internal_exemplars_size();
}
inline void NumberDataPoint::clear_exemplars() {
  _impl_.exemplars_.Clear();
}
inline ::unhinged::observability::v1::Exemplar* NumberDataPoint::mutable_exemplars(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.NumberDataPoint.exemplars)
  return _impl_.exemplars_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::Exemplar >*
NumberDataPoint::mutable_exemplars() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.observability.v1.NumberDataPoint.exemplars)
  return &_impl_.exemplars_;
}
inline const ::unhinged::observability::v1::Exemplar& NumberDataPoint::_internal_exemplars(int index) const {
  return _impl_.exemplars_.Get(index);
}
inline const ::unhinged::observability::v1::Exemplar& NumberDataPoint::exemplars(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.NumberDataPoint.exemplars)
  return _internal_exemplars(index);
}
inline ::unhinged::observability::v1::Exemplar* NumberDataPoint::_internal_add_exemplars() {
  return _impl_.exemplars_.Add();
}
inline ::unhinged::observability::v1::Exemplar* NumberDataPoint::add_exemplars() {
  ::unhinged::observability::v1::Exemplar* _add = _internal_add_exemplars();
  // @@protoc_insertion_point(field_add:unhinged.observability.v1.NumberDataPoint.exemplars)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::Exemplar >&
NumberDataPoint::exemplars() const {
  // @@protoc_insertion_point(field_list:unhinged.observability.v1.NumberDataPoint.exemplars)
  return _impl_.exemplars_;
}

inline bool NumberDataPoint::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void NumberDataPoint::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline NumberDataPoint::ValueCase NumberDataPoint::value_case() const {
  return NumberDataPoint::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// HistogramDataPoint

// map<string, .unhinged.observability.v1.AttributeValue> attributes = 1;
inline int HistogramDataPoint::_internal_attributes_size() const {
  return _impl_.attributes_.size();
}
inline int HistogramDataPoint::attributes_size() const {
  return _internal_attributes_size();
}
inline void HistogramDataPoint::clear_attributes() {
  _impl_.attributes_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::unhinged::observability::v1::AttributeValue >&
HistogramDataPoint::_internal_attributes() const {
  return _impl_.attributes_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::unhinged::observability::v1::AttributeValue >&
HistogramDataPoint::attributes() const {
  // @@protoc_insertion_point(field_map:unhinged.observability.v1.HistogramDataPoint.attributes)
  return _internal_attributes();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::unhinged::observability::v1::AttributeValue >*
HistogramDataPoint::_internal_mutable_attributes() {
  return _impl_.attributes_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::unhinged::observability::v1::AttributeValue >*
HistogramDataPoint::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_map:unhinged.observability.v1.HistogramDataPoint.attributes)
  return _internal_mutable_attributes();
}

// .google.protobuf.Timestamp start_time = 2;
inline bool HistogramDataPoint::_internal_has_start_time() const {
  return this != internal_default_instance() && _impl_.start_time_ != nullptr;
}
inline bool HistogramDataPoint::has_start_time() const {
  return _internal_has_start_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& HistogramDataPoint::_internal_start_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.start_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& HistogramDataPoint::start_time() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.HistogramDataPoint.start_time)
  return _internal_start_time();
}
inline void HistogramDataPoint::unsafe_arena_set_allocated_start_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_time_);
  }
  _impl_.start_time_ = start_time;
  if (start_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.HistogramDataPoint.start_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* HistogramDataPoint::release_start_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.start_time_;
  _impl_.start_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* HistogramDataPoint::unsafe_arena_release_start_time() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.HistogramDataPoint.start_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.start_time_;
  _impl_.start_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* HistogramDataPoint::_internal_mutable_start_time() {
  
  if (_impl_.start_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.start_time_ = p;
  }
  return _impl_.start_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* HistogramDataPoint::mutable_start_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_start_time();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.HistogramDataPoint.start_time)
  return _msg;
}
inline void HistogramDataPoint::set_allocated_start_time(::PROTOBUF_NAMESPACE_ID::Timestamp* start_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_time_);
  }
  if (start_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_time));
    if (message_arena != submessage_arena) {
      start_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.start_time_ = start_time;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.HistogramDataPoint.start_time)
}

// .google.protobuf.Timestamp time = 3;
inline bool HistogramDataPoint::_internal_has_time() const {
  return this != internal_default_instance() && _impl_.time_ != nullptr;
}
inline bool HistogramDataPoint::has_time() const {
  return _internal_has_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& HistogramDataPoint::_internal_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& HistogramDataPoint::time() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.HistogramDataPoint.time)
  return _internal_time();
}
inline void HistogramDataPoint::unsafe_arena_set_allocated_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_);
  }
  _impl_.time_ = time;
  if (time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.HistogramDataPoint.time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* HistogramDataPoint::release_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.time_;
  _impl_.time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* HistogramDataPoint::unsafe_arena_release_time() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.HistogramDataPoint.time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.time_;
  _impl_.time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* HistogramDataPoint::_internal_mutable_time() {
  
  if (_impl_.time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.time_ = p;
  }
  return _impl_.time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* HistogramDataPoint::mutable_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.HistogramDataPoint.time)
  return _msg;
}
inline void HistogramDataPoint::set_allocated_time(::PROTOBUF_NAMESPACE_ID::Timestamp* time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_);
  }
  if (time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time));
    if (message_arena != submessage_arena) {
      time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.time_ = time;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.HistogramDataPoint.time)
}

// uint64 count = 10;
inline void HistogramDataPoint::clear_count() {
  _impl_.count_ = uint64_t{0u};
}
inline uint64_t HistogramDataPoint::_internal_count() const {
  return _impl_.count_;
}
inline uint64_t HistogramDataPoint::count() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.HistogramDataPoint.count)
  return _internal_count();
}
inline void HistogramDataPoint::_internal_set_count(uint64_t value) {
  
  _impl_.count_ = value;
}
inline void HistogramDataPoint::set_count(uint64_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.HistogramDataPoint.count)
}

// double sum = 11;
inline void HistogramDataPoint::clear_sum() {
  _impl_.sum_ = 0;
}
inline double HistogramDataPoint::_internal_sum() const {
  return _impl_.sum_;
}
inline double HistogramDataPoint::sum() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.HistogramDataPoint.sum)
  return _internal_sum();
}
inline void HistogramDataPoint::_internal_set_sum(double value) {
  
  _impl_.sum_ = value;
}
inline void HistogramDataPoint::set_sum(double value) {
  _internal_set_sum(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.HistogramDataPoint.sum)
}

// repeated double explicit_bounds = 12;
inline int HistogramDataPoint::_internal_explicit_bounds_size() const {
  return _impl_.explicit_bounds_.size();
}
inline int HistogramDataPoint::explicit_bounds_size() const {
  return _internal_explicit_bounds_size();
}
inline void HistogramDataPoint::clear_explicit_bounds() {
  _impl_.explicit_bounds_.Clear();
}
inline double HistogramDataPoint::_internal_explicit_bounds(int index) const {
  return _impl_.explicit_bounds_.Get(index);
}
inline double HistogramDataPoint::explicit_bounds(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.HistogramDataPoint.explicit_bounds)
  return _internal_explicit_bounds(index);
}
inline void HistogramDataPoint::set_explicit_bounds(int index, double value) {
  _impl_.explicit_bounds_.Set(index, value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.HistogramDataPoint.explicit_bounds)
}
inline void HistogramDataPoint::_internal_add_explicit_bounds(double value) {
  _impl_.explicit_bounds_.Add(value);
}
inline void HistogramDataPoint::add_explicit_bounds(double value) {
  _internal_add_explicit_bounds(value);
  // @@protoc_insertion_point(field_add:unhinged.observability.v1.HistogramDataPoint.explicit_bounds)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
HistogramDataPoint::_internal_explicit_bounds() const {
  return _impl_.explicit_bounds_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
HistogramDataPoint::explicit_bounds() const {
  // @@protoc_insertion_point(field_list:unhinged.observability.v1.HistogramDataPoint.explicit_bounds)
  return _internal_explicit_bounds();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
HistogramDataPoint::_internal_mutable_explicit_bounds() {
  return &_impl_.explicit_bounds_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
HistogramDataPoint::mutable_explicit_bounds() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.observability.v1.HistogramDataPoint.explicit_bounds)
  return _internal_mutable_explicit_bounds();
}

// repeated uint64 bucket_counts = 13;
inline int HistogramDataPoint::_internal_bucket_counts_size() const {
  return _impl_.bucket_counts_.size();
}
inline int HistogramDataPoint::bucket_counts_size() const {
  return _internal_bucket_counts_size();
}
inline void HistogramDataPoint::clear_bucket_counts() {
  _impl_.bucket_counts_.Clear();
}
inline uint64_t HistogramDataPoint::_internal_bucket_counts(int index) const {
  return _impl_.bucket_counts_.Get(index);
}
inline uint64_t HistogramDataPoint::bucket_counts(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.HistogramDataPoint.bucket_counts)
  return _internal_bucket_counts(index);
}
inline void HistogramDataPoint::set_bucket_counts(int index, uint64_t value) {
  _impl_.bucket_counts_.Set(index, value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.HistogramDataPoint.bucket_counts)
}
inline void HistogramDataPoint::_internal_add_bucket_counts(uint64_t value) {
  _impl_.bucket_counts_.Add(value);
}
inline void HistogramDataPoint::add_bucket_counts(uint64_t value) {
  _internal_add_bucket_counts(value);
  // @@protoc_insertion_point(field_add:unhinged.observability.v1.HistogramDataPoint.bucket_counts)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
HistogramDataPoint::_internal_bucket_counts() const {
  return _impl_.bucket_counts_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
HistogramDataPoint::bucket_counts() const {
  // @@protoc_insertion_point(field_list:unhinged.observability.v1.HistogramDataPoint.bucket_counts)
  return _internal_bucket_counts();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
HistogramDataPoint::_internal_mutable_bucket_counts() {
  return &_impl_.bucket_counts_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
HistogramDataPoint::mutable_bucket_counts() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.observability.v1.HistogramDataPoint.bucket_counts)
  return _internal_mutable_bucket_counts();
}

// repeated .unhinged.observability.v1.Exemplar exemplars = 20;
inline int HistogramDataPoint::_internal_exemplars_size() const {
  return _impl_.exemplars_.size();
}
inline int HistogramDataPoint::exemplars_size() const {
  return _internal_exemplars_size();
}
inline void HistogramDataPoint::clear_exemplars() {
  _impl_.exemplars_.Clear();
}
inline ::unhinged::observability::v1::Exemplar* HistogramDataPoint::mutable_exemplars(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.HistogramDataPoint.exemplars)
  return _impl_.exemplars_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::Exemplar >*
HistogramDataPoint::mutable_exemplars() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.observability.v1.HistogramDataPoint.exemplars)
  return &_impl_.exemplars_;
}
inline const ::unhinged::observability::v1::Exemplar& HistogramDataPoint::_internal_exemplars(int index) const {
  return _impl_.exemplars_.Get(index);
}
inline const ::unhinged::observability::v1::Exemplar& HistogramDataPoint::exemplars(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.HistogramDataPoint.exemplars)
  return _internal_exemplars(index);
}
inline ::unhinged::observability::v1::Exemplar* HistogramDataPoint::_internal_add_exemplars() {
  return _impl_.exemplars_.Add();
}
inline ::unhinged::observability::v1::Exemplar* HistogramDataPoint::add_exemplars() {
  ::unhinged::observability::v1::Exemplar* _add = _internal_add_exemplars();
  // @@protoc_insertion_point(field_add:unhinged.observability.v1.HistogramDataPoint.exemplars)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::Exemplar >&
HistogramDataPoint::exemplars() const {
  // @@protoc_insertion_point(field_list:unhinged.observability.v1.HistogramDataPoint.exemplars)
  return _impl_.exemplars_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SummaryDataPoint

// map<string, .unhinged.observability.v1.AttributeValue> attributes = 1;
inline int SummaryDataPoint::_internal_attributes_size() const {
  return _impl_.attributes_.size();
}
inline int SummaryDataPoint::attributes_size() const {
  return _internal_attributes_size();
}
inline void SummaryDataPoint::clear_attributes() {
  _impl_.attributes_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::unhinged::observability::v1::AttributeValue >&
SummaryDataPoint::_internal_attributes() const {
  return _impl_.attributes_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::unhinged::observability::v1::AttributeValue >&
SummaryDataPoint::attributes() const {
  // @@protoc_insertion_point(field_map:unhinged.observability.v1.SummaryDataPoint.attributes)
  return _internal_attributes();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::unhinged::observability::v1::AttributeValue >*
SummaryDataPoint::_internal_mutable_attributes() {
  return _impl_.attributes_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::unhinged::observability::v1::AttributeValue >*
SummaryDataPoint::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_map:unhinged.observability.v1.SummaryDataPoint.attributes)
  return _internal_mutable_attributes();
}

// .google.protobuf.Timestamp start_time = 2;
inline bool SummaryDataPoint::_internal_has_start_time() const {
  return this != internal_default_instance() && _impl_.start_time_ != nullptr;
}
inline bool SummaryDataPoint::has_start_time() const {
  return _internal_has_start_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SummaryDataPoint::_internal_start_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.start_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SummaryDataPoint::start_time() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.SummaryDataPoint.start_time)
  return _internal_start_time();
}
inline void SummaryDataPoint::unsafe_arena_set_allocated_start_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_time_);
  }
  _impl_.start_time_ = start_time;
  if (start_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.SummaryDataPoint.start_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SummaryDataPoint::release_start_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.start_time_;
  _impl_.start_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SummaryDataPoint::unsafe_arena_release_start_time() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.SummaryDataPoint.start_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.start_time_;
  _impl_.start_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SummaryDataPoint::_internal_mutable_start_time() {
  
  if (_impl_.start_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.start_time_ = p;
  }
  return _impl_.start_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SummaryDataPoint::mutable_start_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_start_time();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.SummaryDataPoint.start_time)
  return _msg;
}
inline void SummaryDataPoint::set_allocated_start_time(::PROTOBUF_NAMESPACE_ID::Timestamp* start_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_time_);
  }
  if (start_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_time));
    if (message_arena != submessage_arena) {
      start_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.start_time_ = start_time;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.SummaryDataPoint.start_time)
}

// .google.protobuf.Timestamp time = 3;
inline bool SummaryDataPoint::_internal_has_time() const {
  return this != internal_default_instance() && _impl_.time_ != nullptr;
}
inline bool SummaryDataPoint::has_time() const {
  return _internal_has_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SummaryDataPoint::_internal_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SummaryDataPoint::time() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.SummaryDataPoint.time)
  return _internal_time();
}
inline void SummaryDataPoint::unsafe_arena_set_allocated_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_);
  }
  _impl_.time_ = time;
  if (time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.SummaryDataPoint.time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SummaryDataPoint::release_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.time_;
  _impl_.time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SummaryDataPoint::unsafe_arena_release_time() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.SummaryDataPoint.time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.time_;
  _impl_.time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SummaryDataPoint::_internal_mutable_time() {
  
  if (_impl_.time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.time_ = p;
  }
  return _impl_.time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SummaryDataPoint::mutable_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.SummaryDataPoint.time)
  return _msg;
}
inline void SummaryDataPoint::set_allocated_time(::PROTOBUF_NAMESPACE_ID::Timestamp* time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.time_);
  }
  if (time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time));
    if (message_arena != submessage_arena) {
      time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.time_ = time;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.SummaryDataPoint.time)
}

// uint64 count = 10;
inline void SummaryDataPoint::clear_count() {
  _impl_.count_ = uint64_t{0u};
}
inline uint64_t SummaryDataPoint::_internal_count() const {
  return _impl_.count_;
}
inline uint64_t SummaryDataPoint::count() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.SummaryDataPoint.count)
  return _internal_count();
}
inline void SummaryDataPoint::_internal_set_count(uint64_t value) {
  
  _impl_.count_ = value;
}
inline void SummaryDataPoint::set_count(uint64_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.SummaryDataPoint.count)
}

// double sum = 11;
inline void SummaryDataPoint::clear_sum() {
  _impl_.sum_ = 0;
}
inline double SummaryDataPoint::_internal_sum() const {
  return _impl_.sum_;
}
inline double SummaryDataPoint::sum() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.SummaryDataPoint.sum)
  return _internal_sum();
}
inline void SummaryDataPoint::_internal_set_sum(double value) {
  
  _impl_.sum_ = value;
}
inline void SummaryDataPoint::set_sum(double value) {
  _internal_set_sum(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.SummaryDataPoint.sum)
}

// repeated .unhinged.observability.v1.QuantileValue quantile_values = 12;
inline int SummaryDataPoint::_internal_quantile_values_size() const {
  return _impl_.quantile_values_.size();
}
inline int SummaryDataPoint::quantile_values_size() const {
  return _internal_quantile_values_size();
}
inline void SummaryDataPoint::clear_quantile_values() {
  _impl_.quantile_values_.Clear();
}
inline ::unhinged::observability::v1::QuantileValue* SummaryDataPoint::mutable_quantile_values(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.SummaryDataPoint.quantile_values)
  return _impl_.quantile_values_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::QuantileValue >*
SummaryDataPoint::mutable_quantile_values() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.observability.v1.SummaryDataPoint.quantile_values)
  return &_impl_.quantile_values_;
}
inline const ::unhinged::observability::v1::QuantileValue& SummaryDataPoint::_internal_quantile_values(int index) const {
  return _impl_.quantile_values_.Get(index);
}
inline const ::unhinged::observability::v1::QuantileValue& SummaryDataPoint::quantile_values(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.SummaryDataPoint.quantile_values)
  return _internal_quantile_values(index);
}
inline ::unhinged::observability::v1::QuantileValue* SummaryDataPoint::_internal_add_quantile_values() {
  return _impl_.quantile_values_.Add();
}
inline ::unhinged::observability::v1::QuantileValue* SummaryDataPoint::add_quantile_values() {
  ::unhinged::observability::v1::QuantileValue* _add = _internal_add_quantile_values();
  // @@protoc_insertion_point(field_add:unhinged.observability.v1.SummaryDataPoint.quantile_values)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::QuantileValue >&
SummaryDataPoint::quantile_values() const {
  // @@protoc_insertion_point(field_list:unhinged.observability.v1.SummaryDataPoint.quantile_values)
  return _impl_.quantile_values_;
}

// -------------------------------------------------------------------

// QuantileValue

// double quantile = 1;
inline void QuantileValue::clear_quantile() {
  _impl_.quantile_ = 0;
}
inline double QuantileValue::_internal_quantile() const {
  return _impl_.quantile_;
}
inline double QuantileValue::quantile() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.QuantileValue.quantile)
  return _internal_quantile();
}
inline void QuantileValue::_internal_set_quantile(double value) {
  
  _impl_.quantile_ = value;
}
inline void QuantileValue::set_quantile(double value) {
  _internal_set_quantile(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.QuantileValue.quantile)
}

// double value = 2;
inline void QuantileValue::clear_value() {
  _impl_.value_ = 0;
}
inline double QuantileValue::_internal_value() const {
  return _impl_.value_;
}
inline double QuantileValue::value() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.QuantileValue.value)
  return _internal_value();
}
inline void QuantileValue::_internal_set_value(double value) {
  
  _impl_.value_ = value;
}
inline void QuantileValue::set_value(double value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.QuantileValue.value)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Exemplar

// map<string, .unhinged.observability.v1.AttributeValue> filtered_attributes = 1;
inline int Exemplar::_internal_filtered_attributes_size() const {
  return _impl_.filtered_attributes_.size();
}
inline int Exemplar::filtered_attributes_size() const {
  return _internal_filtered_attributes_size();
}
inline void Exemplar::clear_filtered_attributes() {
  _impl_.filtered_attributes_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::unhinged::observability::v1::AttributeValue >&
Exemplar::_internal_filtered_attributes() const {
  return _impl_.filtered_attributes_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::unhinged::observability::v1::AttributeValue >&
Exemplar::filtered_attributes() const {
  // @@protoc_insertion_point(field_map:unhinged.observability.v1.Exemplar.filtered_attributes)
  return _internal_filtered_attributes();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::unhinged::observability::v1::AttributeValue >*
Exemplar::_internal_mutable_filtered_attributes() {
  return _impl_.filtered_attributes_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::unhinged::observability::v1::AttributeValue >*
Exemplar::mutable_filtered_attributes() {
  // @@protoc_insertion_point(field_mutable_map:unhinged.observability.v1.Exemplar.filtered_attributes)
  return _internal_mutable_filtered_attributes();
}

// .google.protobuf.Timestamp timestamp = 2;
inline bool Exemplar::_internal_has_timestamp() const {
  return this != internal_default_instance() && _impl_.timestamp_ != nullptr;
}
inline bool Exemplar::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Exemplar::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Exemplar::timestamp() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.Exemplar.timestamp)
  return _internal_timestamp();
}
inline void Exemplar::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.Exemplar.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Exemplar::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Exemplar::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.Exemplar.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Exemplar::_internal_mutable_timestamp() {
  
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Exemplar::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.Exemplar.timestamp)
  return _msg;
}
inline void Exemplar::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.Exemplar.timestamp)
}

// double as_double = 10;
inline bool Exemplar::_internal_has_as_double() const {
  return value_case() == kAsDouble;
}
inline bool Exemplar::has_as_double() const {
  return _internal_has_as_double();
}
inline void Exemplar::set_has_as_double() {
  _impl_._oneof_case_[0] = kAsDouble;
}
inline void Exemplar::clear_as_double() {
  if (_internal_has_as_double()) {
    _impl_.value_.as_double_ = 0;
    clear_has_value();
  }
}
inline double Exemplar::_internal_as_double() const {
  if (_internal_has_as_double()) {
    return _impl_.value_.as_double_;
  }
  return 0;
}
inline void Exemplar::_internal_set_as_double(double value) {
  if (!_internal_has_as_double()) {
    clear_value();
    set_has_as_double();
  }
  _impl_.value_.as_double_ = value;
}
inline double Exemplar::as_double() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.Exemplar.as_double)
  return _internal_as_double();
}
inline void Exemplar::set_as_double(double value) {
  _internal_set_as_double(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.Exemplar.as_double)
}

// int64 as_int = 11;
inline bool Exemplar::_internal_has_as_int() const {
  return value_case() == kAsInt;
}
inline bool Exemplar::has_as_int() const {
  return _internal_has_as_int();
}
inline void Exemplar::set_has_as_int() {
  _impl_._oneof_case_[0] = kAsInt;
}
inline void Exemplar::clear_as_int() {
  if (_internal_has_as_int()) {
    _impl_.value_.as_int_ = int64_t{0};
    clear_has_value();
  }
}
inline int64_t Exemplar::_internal_as_int() const {
  if (_internal_has_as_int()) {
    return _impl_.value_.as_int_;
  }
  return int64_t{0};
}
inline void Exemplar::_internal_set_as_int(int64_t value) {
  if (!_internal_has_as_int()) {
    clear_value();
    set_has_as_int();
  }
  _impl_.value_.as_int_ = value;
}
inline int64_t Exemplar::as_int() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.Exemplar.as_int)
  return _internal_as_int();
}
inline void Exemplar::set_as_int(int64_t value) {
  _internal_set_as_int(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.Exemplar.as_int)
}

// string span_id = 20;
inline void Exemplar::clear_span_id() {
  _impl_.span_id_.ClearToEmpty();
}
inline const std::string& Exemplar::span_id() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.Exemplar.span_id)
  return _internal_span_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Exemplar::set_span_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.span_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.Exemplar.span_id)
}
inline std::string* Exemplar::mutable_span_id() {
  std::string* _s = _internal_mutable_span_id();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.Exemplar.span_id)
  return _s;
}
inline const std::string& Exemplar::_internal_span_id() const {
  return _impl_.span_id_.Get();
}
inline void Exemplar::_internal_set_span_id(const std::string& value) {
  
  _impl_.span_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Exemplar::_internal_mutable_span_id() {
  
  return _impl_.span_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Exemplar::release_span_id() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.Exemplar.span_id)
  return _impl_.span_id_.Release();
}
inline void Exemplar::set_allocated_span_id(std::string* span_id) {
  if (span_id != nullptr) {
    
  } else {
    
  }
  _impl_.span_id_.SetAllocated(span_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.span_id_.IsDefault()) {
    _impl_.span_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.Exemplar.span_id)
}

// string trace_id = 21;
inline void Exemplar::clear_trace_id() {
  _impl_.trace_id_.ClearToEmpty();
}
inline const std::string& Exemplar::trace_id() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.Exemplar.trace_id)
  return _internal_trace_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Exemplar::set_trace_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.trace_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.Exemplar.trace_id)
}
inline std::string* Exemplar::mutable_trace_id() {
  std::string* _s = _internal_mutable_trace_id();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.Exemplar.trace_id)
  return _s;
}
inline const std::string& Exemplar::_internal_trace_id() const {
  return _impl_.trace_id_.Get();
}
inline void Exemplar::_internal_set_trace_id(const std::string& value) {
  
  _impl_.trace_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Exemplar::_internal_mutable_trace_id() {
  
  return _impl_.trace_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Exemplar::release_trace_id() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.Exemplar.trace_id)
  return _impl_.trace_id_.Release();
}
inline void Exemplar::set_allocated_trace_id(std::string* trace_id) {
  if (trace_id != nullptr) {
    
  } else {
    
  }
  _impl_.trace_id_.SetAllocated(trace_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.trace_id_.IsDefault()) {
    _impl_.trace_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.Exemplar.trace_id)
}

inline bool Exemplar::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void Exemplar::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline Exemplar::ValueCase Exemplar::value_case() const {
  return Exemplar::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ServiceHealthEvent

// string event_id = 1;
inline void ServiceHealthEvent::clear_event_id() {
  _impl_.event_id_.ClearToEmpty();
}
inline const std::string& ServiceHealthEvent::event_id() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.ServiceHealthEvent.event_id)
  return _internal_event_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceHealthEvent::set_event_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.event_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.ServiceHealthEvent.event_id)
}
inline std::string* ServiceHealthEvent::mutable_event_id() {
  std::string* _s = _internal_mutable_event_id();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.ServiceHealthEvent.event_id)
  return _s;
}
inline const std::string& ServiceHealthEvent::_internal_event_id() const {
  return _impl_.event_id_.Get();
}
inline void ServiceHealthEvent::_internal_set_event_id(const std::string& value) {
  
  _impl_.event_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceHealthEvent::_internal_mutable_event_id() {
  
  return _impl_.event_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ServiceHealthEvent::release_event_id() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.ServiceHealthEvent.event_id)
  return _impl_.event_id_.Release();
}
inline void ServiceHealthEvent::set_allocated_event_id(std::string* event_id) {
  if (event_id != nullptr) {
    
  } else {
    
  }
  _impl_.event_id_.SetAllocated(event_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.event_id_.IsDefault()) {
    _impl_.event_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.ServiceHealthEvent.event_id)
}

// .google.protobuf.Timestamp timestamp = 2;
inline bool ServiceHealthEvent::_internal_has_timestamp() const {
  return this != internal_default_instance() && _impl_.timestamp_ != nullptr;
}
inline bool ServiceHealthEvent::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ServiceHealthEvent::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ServiceHealthEvent::timestamp() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.ServiceHealthEvent.timestamp)
  return _internal_timestamp();
}
inline void ServiceHealthEvent::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.ServiceHealthEvent.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ServiceHealthEvent::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ServiceHealthEvent::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.ServiceHealthEvent.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ServiceHealthEvent::_internal_mutable_timestamp() {
  
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ServiceHealthEvent::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.ServiceHealthEvent.timestamp)
  return _msg;
}
inline void ServiceHealthEvent::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.ServiceHealthEvent.timestamp)
}

// string event_type = 3;
inline void ServiceHealthEvent::clear_event_type() {
  _impl_.event_type_.ClearToEmpty();
}
inline const std::string& ServiceHealthEvent::event_type() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.ServiceHealthEvent.event_type)
  return _internal_event_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceHealthEvent::set_event_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.event_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.ServiceHealthEvent.event_type)
}
inline std::string* ServiceHealthEvent::mutable_event_type() {
  std::string* _s = _internal_mutable_event_type();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.ServiceHealthEvent.event_type)
  return _s;
}
inline const std::string& ServiceHealthEvent::_internal_event_type() const {
  return _impl_.event_type_.Get();
}
inline void ServiceHealthEvent::_internal_set_event_type(const std::string& value) {
  
  _impl_.event_type_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceHealthEvent::_internal_mutable_event_type() {
  
  return _impl_.event_type_.Mutable(GetArenaForAllocation());
}
inline std::string* ServiceHealthEvent::release_event_type() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.ServiceHealthEvent.event_type)
  return _impl_.event_type_.Release();
}
inline void ServiceHealthEvent::set_allocated_event_type(std::string* event_type) {
  if (event_type != nullptr) {
    
  } else {
    
  }
  _impl_.event_type_.SetAllocated(event_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.event_type_.IsDefault()) {
    _impl_.event_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.ServiceHealthEvent.event_type)
}

// int64 sequence_number = 4;
inline void ServiceHealthEvent::clear_sequence_number() {
  _impl_.sequence_number_ = int64_t{0};
}
inline int64_t ServiceHealthEvent::_internal_sequence_number() const {
  return _impl_.sequence_number_;
}
inline int64_t ServiceHealthEvent::sequence_number() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.ServiceHealthEvent.sequence_number)
  return _internal_sequence_number();
}
inline void ServiceHealthEvent::_internal_set_sequence_number(int64_t value) {
  
  _impl_.sequence_number_ = value;
}
inline void ServiceHealthEvent::set_sequence_number(int64_t value) {
  _internal_set_sequence_number(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.ServiceHealthEvent.sequence_number)
}

// .unhinged.observability.v1.Resource resource = 5;
inline bool ServiceHealthEvent::_internal_has_resource() const {
  return this != internal_default_instance() && _impl_.resource_ != nullptr;
}
inline bool ServiceHealthEvent::has_resource() const {
  return _internal_has_resource();
}
inline void ServiceHealthEvent::clear_resource() {
  if (GetArenaForAllocation() == nullptr && _impl_.resource_ != nullptr) {
    delete _impl_.resource_;
  }
  _impl_.resource_ = nullptr;
}
inline const ::unhinged::observability::v1::Resource& ServiceHealthEvent::_internal_resource() const {
  const ::unhinged::observability::v1::Resource* p = _impl_.resource_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::observability::v1::Resource&>(
      ::unhinged::observability::v1::_Resource_default_instance_);
}
inline const ::unhinged::observability::v1::Resource& ServiceHealthEvent::resource() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.ServiceHealthEvent.resource)
  return _internal_resource();
}
inline void ServiceHealthEvent::unsafe_arena_set_allocated_resource(
    ::unhinged::observability::v1::Resource* resource) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.resource_);
  }
  _impl_.resource_ = resource;
  if (resource) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.ServiceHealthEvent.resource)
}
inline ::unhinged::observability::v1::Resource* ServiceHealthEvent::release_resource() {
  
  ::unhinged::observability::v1::Resource* temp = _impl_.resource_;
  _impl_.resource_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::observability::v1::Resource* ServiceHealthEvent::unsafe_arena_release_resource() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.ServiceHealthEvent.resource)
  
  ::unhinged::observability::v1::Resource* temp = _impl_.resource_;
  _impl_.resource_ = nullptr;
  return temp;
}
inline ::unhinged::observability::v1::Resource* ServiceHealthEvent::_internal_mutable_resource() {
  
  if (_impl_.resource_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::observability::v1::Resource>(GetArenaForAllocation());
    _impl_.resource_ = p;
  }
  return _impl_.resource_;
}
inline ::unhinged::observability::v1::Resource* ServiceHealthEvent::mutable_resource() {
  ::unhinged::observability::v1::Resource* _msg = _internal_mutable_resource();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.ServiceHealthEvent.resource)
  return _msg;
}
inline void ServiceHealthEvent::set_allocated_resource(::unhinged::observability::v1::Resource* resource) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.resource_;
  }
  if (resource) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(resource);
    if (message_arena != submessage_arena) {
      resource = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, resource, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.resource_ = resource;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.ServiceHealthEvent.resource)
}

// .unhinged.observability.v1.ServiceHealth health = 10;
inline bool ServiceHealthEvent::_internal_has_health() const {
  return this != internal_default_instance() && _impl_.health_ != nullptr;
}
inline bool ServiceHealthEvent::has_health() const {
  return _internal_has_health();
}
inline void ServiceHealthEvent::clear_health() {
  if (GetArenaForAllocation() == nullptr && _impl_.health_ != nullptr) {
    delete _impl_.health_;
  }
  _impl_.health_ = nullptr;
}
inline const ::unhinged::observability::v1::ServiceHealth& ServiceHealthEvent::_internal_health() const {
  const ::unhinged::observability::v1::ServiceHealth* p = _impl_.health_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::observability::v1::ServiceHealth&>(
      ::unhinged::observability::v1::_ServiceHealth_default_instance_);
}
inline const ::unhinged::observability::v1::ServiceHealth& ServiceHealthEvent::health() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.ServiceHealthEvent.health)
  return _internal_health();
}
inline void ServiceHealthEvent::unsafe_arena_set_allocated_health(
    ::unhinged::observability::v1::ServiceHealth* health) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.health_);
  }
  _impl_.health_ = health;
  if (health) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.ServiceHealthEvent.health)
}
inline ::unhinged::observability::v1::ServiceHealth* ServiceHealthEvent::release_health() {
  
  ::unhinged::observability::v1::ServiceHealth* temp = _impl_.health_;
  _impl_.health_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::observability::v1::ServiceHealth* ServiceHealthEvent::unsafe_arena_release_health() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.ServiceHealthEvent.health)
  
  ::unhinged::observability::v1::ServiceHealth* temp = _impl_.health_;
  _impl_.health_ = nullptr;
  return temp;
}
inline ::unhinged::observability::v1::ServiceHealth* ServiceHealthEvent::_internal_mutable_health() {
  
  if (_impl_.health_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::observability::v1::ServiceHealth>(GetArenaForAllocation());
    _impl_.health_ = p;
  }
  return _impl_.health_;
}
inline ::unhinged::observability::v1::ServiceHealth* ServiceHealthEvent::mutable_health() {
  ::unhinged::observability::v1::ServiceHealth* _msg = _internal_mutable_health();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.ServiceHealthEvent.health)
  return _msg;
}
inline void ServiceHealthEvent::set_allocated_health(::unhinged::observability::v1::ServiceHealth* health) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.health_;
  }
  if (health) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(health);
    if (message_arena != submessage_arena) {
      health = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, health, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.health_ = health;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.ServiceHealthEvent.health)
}

// .unhinged.observability.v1.DestinationFlags destinations = 20;
inline bool ServiceHealthEvent::_internal_has_destinations() const {
  return this != internal_default_instance() && _impl_.destinations_ != nullptr;
}
inline bool ServiceHealthEvent::has_destinations() const {
  return _internal_has_destinations();
}
inline void ServiceHealthEvent::clear_destinations() {
  if (GetArenaForAllocation() == nullptr && _impl_.destinations_ != nullptr) {
    delete _impl_.destinations_;
  }
  _impl_.destinations_ = nullptr;
}
inline const ::unhinged::observability::v1::DestinationFlags& ServiceHealthEvent::_internal_destinations() const {
  const ::unhinged::observability::v1::DestinationFlags* p = _impl_.destinations_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::observability::v1::DestinationFlags&>(
      ::unhinged::observability::v1::_DestinationFlags_default_instance_);
}
inline const ::unhinged::observability::v1::DestinationFlags& ServiceHealthEvent::destinations() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.ServiceHealthEvent.destinations)
  return _internal_destinations();
}
inline void ServiceHealthEvent::unsafe_arena_set_allocated_destinations(
    ::unhinged::observability::v1::DestinationFlags* destinations) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.destinations_);
  }
  _impl_.destinations_ = destinations;
  if (destinations) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.ServiceHealthEvent.destinations)
}
inline ::unhinged::observability::v1::DestinationFlags* ServiceHealthEvent::release_destinations() {
  
  ::unhinged::observability::v1::DestinationFlags* temp = _impl_.destinations_;
  _impl_.destinations_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::observability::v1::DestinationFlags* ServiceHealthEvent::unsafe_arena_release_destinations() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.ServiceHealthEvent.destinations)
  
  ::unhinged::observability::v1::DestinationFlags* temp = _impl_.destinations_;
  _impl_.destinations_ = nullptr;
  return temp;
}
inline ::unhinged::observability::v1::DestinationFlags* ServiceHealthEvent::_internal_mutable_destinations() {
  
  if (_impl_.destinations_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::observability::v1::DestinationFlags>(GetArenaForAllocation());
    _impl_.destinations_ = p;
  }
  return _impl_.destinations_;
}
inline ::unhinged::observability::v1::DestinationFlags* ServiceHealthEvent::mutable_destinations() {
  ::unhinged::observability::v1::DestinationFlags* _msg = _internal_mutable_destinations();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.ServiceHealthEvent.destinations)
  return _msg;
}
inline void ServiceHealthEvent::set_allocated_destinations(::unhinged::observability::v1::DestinationFlags* destinations) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.destinations_;
  }
  if (destinations) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(destinations);
    if (message_arena != submessage_arena) {
      destinations = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, destinations, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.destinations_ = destinations;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.ServiceHealthEvent.destinations)
}

// .unhinged.observability.v1.PartitionInfo partition_info = 25;
inline bool ServiceHealthEvent::_internal_has_partition_info() const {
  return this != internal_default_instance() && _impl_.partition_info_ != nullptr;
}
inline bool ServiceHealthEvent::has_partition_info() const {
  return _internal_has_partition_info();
}
inline void ServiceHealthEvent::clear_partition_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.partition_info_ != nullptr) {
    delete _impl_.partition_info_;
  }
  _impl_.partition_info_ = nullptr;
}
inline const ::unhinged::observability::v1::PartitionInfo& ServiceHealthEvent::_internal_partition_info() const {
  const ::unhinged::observability::v1::PartitionInfo* p = _impl_.partition_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::observability::v1::PartitionInfo&>(
      ::unhinged::observability::v1::_PartitionInfo_default_instance_);
}
inline const ::unhinged::observability::v1::PartitionInfo& ServiceHealthEvent::partition_info() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.ServiceHealthEvent.partition_info)
  return _internal_partition_info();
}
inline void ServiceHealthEvent::unsafe_arena_set_allocated_partition_info(
    ::unhinged::observability::v1::PartitionInfo* partition_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.partition_info_);
  }
  _impl_.partition_info_ = partition_info;
  if (partition_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.ServiceHealthEvent.partition_info)
}
inline ::unhinged::observability::v1::PartitionInfo* ServiceHealthEvent::release_partition_info() {
  
  ::unhinged::observability::v1::PartitionInfo* temp = _impl_.partition_info_;
  _impl_.partition_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::observability::v1::PartitionInfo* ServiceHealthEvent::unsafe_arena_release_partition_info() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.ServiceHealthEvent.partition_info)
  
  ::unhinged::observability::v1::PartitionInfo* temp = _impl_.partition_info_;
  _impl_.partition_info_ = nullptr;
  return temp;
}
inline ::unhinged::observability::v1::PartitionInfo* ServiceHealthEvent::_internal_mutable_partition_info() {
  
  if (_impl_.partition_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::observability::v1::PartitionInfo>(GetArenaForAllocation());
    _impl_.partition_info_ = p;
  }
  return _impl_.partition_info_;
}
inline ::unhinged::observability::v1::PartitionInfo* ServiceHealthEvent::mutable_partition_info() {
  ::unhinged::observability::v1::PartitionInfo* _msg = _internal_mutable_partition_info();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.ServiceHealthEvent.partition_info)
  return _msg;
}
inline void ServiceHealthEvent::set_allocated_partition_info(::unhinged::observability::v1::PartitionInfo* partition_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.partition_info_;
  }
  if (partition_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(partition_info);
    if (message_arena != submessage_arena) {
      partition_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, partition_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.partition_info_ = partition_info;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.ServiceHealthEvent.partition_info)
}

// -------------------------------------------------------------------

// ServiceHealth

// string service_name = 1;
inline void ServiceHealth::clear_service_name() {
  _impl_.service_name_.ClearToEmpty();
}
inline const std::string& ServiceHealth::service_name() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.ServiceHealth.service_name)
  return _internal_service_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceHealth::set_service_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.ServiceHealth.service_name)
}
inline std::string* ServiceHealth::mutable_service_name() {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.ServiceHealth.service_name)
  return _s;
}
inline const std::string& ServiceHealth::_internal_service_name() const {
  return _impl_.service_name_.Get();
}
inline void ServiceHealth::_internal_set_service_name(const std::string& value) {
  
  _impl_.service_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceHealth::_internal_mutable_service_name() {
  
  return _impl_.service_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ServiceHealth::release_service_name() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.ServiceHealth.service_name)
  return _impl_.service_name_.Release();
}
inline void ServiceHealth::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  _impl_.service_name_.SetAllocated(service_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_name_.IsDefault()) {
    _impl_.service_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.ServiceHealth.service_name)
}

// .unhinged.observability.v1.HealthStatus status = 2;
inline void ServiceHealth::clear_status() {
  _impl_.status_ = 0;
}
inline ::unhinged::observability::v1::HealthStatus ServiceHealth::_internal_status() const {
  return static_cast< ::unhinged::observability::v1::HealthStatus >(_impl_.status_);
}
inline ::unhinged::observability::v1::HealthStatus ServiceHealth::status() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.ServiceHealth.status)
  return _internal_status();
}
inline void ServiceHealth::_internal_set_status(::unhinged::observability::v1::HealthStatus value) {
  
  _impl_.status_ = value;
}
inline void ServiceHealth::set_status(::unhinged::observability::v1::HealthStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.ServiceHealth.status)
}

// string status_message = 3;
inline void ServiceHealth::clear_status_message() {
  _impl_.status_message_.ClearToEmpty();
}
inline const std::string& ServiceHealth::status_message() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.ServiceHealth.status_message)
  return _internal_status_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceHealth::set_status_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.status_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.ServiceHealth.status_message)
}
inline std::string* ServiceHealth::mutable_status_message() {
  std::string* _s = _internal_mutable_status_message();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.ServiceHealth.status_message)
  return _s;
}
inline const std::string& ServiceHealth::_internal_status_message() const {
  return _impl_.status_message_.Get();
}
inline void ServiceHealth::_internal_set_status_message(const std::string& value) {
  
  _impl_.status_message_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceHealth::_internal_mutable_status_message() {
  
  return _impl_.status_message_.Mutable(GetArenaForAllocation());
}
inline std::string* ServiceHealth::release_status_message() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.ServiceHealth.status_message)
  return _impl_.status_message_.Release();
}
inline void ServiceHealth::set_allocated_status_message(std::string* status_message) {
  if (status_message != nullptr) {
    
  } else {
    
  }
  _impl_.status_message_.SetAllocated(status_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_message_.IsDefault()) {
    _impl_.status_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.ServiceHealth.status_message)
}

// repeated .unhinged.observability.v1.HealthCheck health_checks = 10;
inline int ServiceHealth::_internal_health_checks_size() const {
  return _impl_.health_checks_.size();
}
inline int ServiceHealth::health_checks_size() const {
  return _internal_health_checks_size();
}
inline void ServiceHealth::clear_health_checks() {
  _impl_.health_checks_.Clear();
}
inline ::unhinged::observability::v1::HealthCheck* ServiceHealth::mutable_health_checks(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.ServiceHealth.health_checks)
  return _impl_.health_checks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::HealthCheck >*
ServiceHealth::mutable_health_checks() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.observability.v1.ServiceHealth.health_checks)
  return &_impl_.health_checks_;
}
inline const ::unhinged::observability::v1::HealthCheck& ServiceHealth::_internal_health_checks(int index) const {
  return _impl_.health_checks_.Get(index);
}
inline const ::unhinged::observability::v1::HealthCheck& ServiceHealth::health_checks(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.ServiceHealth.health_checks)
  return _internal_health_checks(index);
}
inline ::unhinged::observability::v1::HealthCheck* ServiceHealth::_internal_add_health_checks() {
  return _impl_.health_checks_.Add();
}
inline ::unhinged::observability::v1::HealthCheck* ServiceHealth::add_health_checks() {
  ::unhinged::observability::v1::HealthCheck* _add = _internal_add_health_checks();
  // @@protoc_insertion_point(field_add:unhinged.observability.v1.ServiceHealth.health_checks)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::HealthCheck >&
ServiceHealth::health_checks() const {
  // @@protoc_insertion_point(field_list:unhinged.observability.v1.ServiceHealth.health_checks)
  return _impl_.health_checks_;
}

// repeated .unhinged.observability.v1.DependencyHealth dependencies = 15;
inline int ServiceHealth::_internal_dependencies_size() const {
  return _impl_.dependencies_.size();
}
inline int ServiceHealth::dependencies_size() const {
  return _internal_dependencies_size();
}
inline void ServiceHealth::clear_dependencies() {
  _impl_.dependencies_.Clear();
}
inline ::unhinged::observability::v1::DependencyHealth* ServiceHealth::mutable_dependencies(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.ServiceHealth.dependencies)
  return _impl_.dependencies_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::DependencyHealth >*
ServiceHealth::mutable_dependencies() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.observability.v1.ServiceHealth.dependencies)
  return &_impl_.dependencies_;
}
inline const ::unhinged::observability::v1::DependencyHealth& ServiceHealth::_internal_dependencies(int index) const {
  return _impl_.dependencies_.Get(index);
}
inline const ::unhinged::observability::v1::DependencyHealth& ServiceHealth::dependencies(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.ServiceHealth.dependencies)
  return _internal_dependencies(index);
}
inline ::unhinged::observability::v1::DependencyHealth* ServiceHealth::_internal_add_dependencies() {
  return _impl_.dependencies_.Add();
}
inline ::unhinged::observability::v1::DependencyHealth* ServiceHealth::add_dependencies() {
  ::unhinged::observability::v1::DependencyHealth* _add = _internal_add_dependencies();
  // @@protoc_insertion_point(field_add:unhinged.observability.v1.ServiceHealth.dependencies)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::DependencyHealth >&
ServiceHealth::dependencies() const {
  // @@protoc_insertion_point(field_list:unhinged.observability.v1.ServiceHealth.dependencies)
  return _impl_.dependencies_;
}

// .unhinged.observability.v1.ServiceLevelIndicators slis = 20;
inline bool ServiceHealth::_internal_has_slis() const {
  return this != internal_default_instance() && _impl_.slis_ != nullptr;
}
inline bool ServiceHealth::has_slis() const {
  return _internal_has_slis();
}
inline void ServiceHealth::clear_slis() {
  if (GetArenaForAllocation() == nullptr && _impl_.slis_ != nullptr) {
    delete _impl_.slis_;
  }
  _impl_.slis_ = nullptr;
}
inline const ::unhinged::observability::v1::ServiceLevelIndicators& ServiceHealth::_internal_slis() const {
  const ::unhinged::observability::v1::ServiceLevelIndicators* p = _impl_.slis_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::observability::v1::ServiceLevelIndicators&>(
      ::unhinged::observability::v1::_ServiceLevelIndicators_default_instance_);
}
inline const ::unhinged::observability::v1::ServiceLevelIndicators& ServiceHealth::slis() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.ServiceHealth.slis)
  return _internal_slis();
}
inline void ServiceHealth::unsafe_arena_set_allocated_slis(
    ::unhinged::observability::v1::ServiceLevelIndicators* slis) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.slis_);
  }
  _impl_.slis_ = slis;
  if (slis) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.ServiceHealth.slis)
}
inline ::unhinged::observability::v1::ServiceLevelIndicators* ServiceHealth::release_slis() {
  
  ::unhinged::observability::v1::ServiceLevelIndicators* temp = _impl_.slis_;
  _impl_.slis_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::observability::v1::ServiceLevelIndicators* ServiceHealth::unsafe_arena_release_slis() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.ServiceHealth.slis)
  
  ::unhinged::observability::v1::ServiceLevelIndicators* temp = _impl_.slis_;
  _impl_.slis_ = nullptr;
  return temp;
}
inline ::unhinged::observability::v1::ServiceLevelIndicators* ServiceHealth::_internal_mutable_slis() {
  
  if (_impl_.slis_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::observability::v1::ServiceLevelIndicators>(GetArenaForAllocation());
    _impl_.slis_ = p;
  }
  return _impl_.slis_;
}
inline ::unhinged::observability::v1::ServiceLevelIndicators* ServiceHealth::mutable_slis() {
  ::unhinged::observability::v1::ServiceLevelIndicators* _msg = _internal_mutable_slis();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.ServiceHealth.slis)
  return _msg;
}
inline void ServiceHealth::set_allocated_slis(::unhinged::observability::v1::ServiceLevelIndicators* slis) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.slis_;
  }
  if (slis) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(slis);
    if (message_arena != submessage_arena) {
      slis = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, slis, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.slis_ = slis;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.ServiceHealth.slis)
}

// .unhinged.observability.v1.SystemMetrics system_metrics = 25;
inline bool ServiceHealth::_internal_has_system_metrics() const {
  return this != internal_default_instance() && _impl_.system_metrics_ != nullptr;
}
inline bool ServiceHealth::has_system_metrics() const {
  return _internal_has_system_metrics();
}
inline void ServiceHealth::clear_system_metrics() {
  if (GetArenaForAllocation() == nullptr && _impl_.system_metrics_ != nullptr) {
    delete _impl_.system_metrics_;
  }
  _impl_.system_metrics_ = nullptr;
}
inline const ::unhinged::observability::v1::SystemMetrics& ServiceHealth::_internal_system_metrics() const {
  const ::unhinged::observability::v1::SystemMetrics* p = _impl_.system_metrics_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::observability::v1::SystemMetrics&>(
      ::unhinged::observability::v1::_SystemMetrics_default_instance_);
}
inline const ::unhinged::observability::v1::SystemMetrics& ServiceHealth::system_metrics() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.ServiceHealth.system_metrics)
  return _internal_system_metrics();
}
inline void ServiceHealth::unsafe_arena_set_allocated_system_metrics(
    ::unhinged::observability::v1::SystemMetrics* system_metrics) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.system_metrics_);
  }
  _impl_.system_metrics_ = system_metrics;
  if (system_metrics) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.ServiceHealth.system_metrics)
}
inline ::unhinged::observability::v1::SystemMetrics* ServiceHealth::release_system_metrics() {
  
  ::unhinged::observability::v1::SystemMetrics* temp = _impl_.system_metrics_;
  _impl_.system_metrics_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::observability::v1::SystemMetrics* ServiceHealth::unsafe_arena_release_system_metrics() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.ServiceHealth.system_metrics)
  
  ::unhinged::observability::v1::SystemMetrics* temp = _impl_.system_metrics_;
  _impl_.system_metrics_ = nullptr;
  return temp;
}
inline ::unhinged::observability::v1::SystemMetrics* ServiceHealth::_internal_mutable_system_metrics() {
  
  if (_impl_.system_metrics_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::observability::v1::SystemMetrics>(GetArenaForAllocation());
    _impl_.system_metrics_ = p;
  }
  return _impl_.system_metrics_;
}
inline ::unhinged::observability::v1::SystemMetrics* ServiceHealth::mutable_system_metrics() {
  ::unhinged::observability::v1::SystemMetrics* _msg = _internal_mutable_system_metrics();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.ServiceHealth.system_metrics)
  return _msg;
}
inline void ServiceHealth::set_allocated_system_metrics(::unhinged::observability::v1::SystemMetrics* system_metrics) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.system_metrics_;
  }
  if (system_metrics) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(system_metrics);
    if (message_arena != submessage_arena) {
      system_metrics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, system_metrics, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.system_metrics_ = system_metrics;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.ServiceHealth.system_metrics)
}

// .unhinged.observability.v1.UptimeInfo uptime = 30;
inline bool ServiceHealth::_internal_has_uptime() const {
  return this != internal_default_instance() && _impl_.uptime_ != nullptr;
}
inline bool ServiceHealth::has_uptime() const {
  return _internal_has_uptime();
}
inline void ServiceHealth::clear_uptime() {
  if (GetArenaForAllocation() == nullptr && _impl_.uptime_ != nullptr) {
    delete _impl_.uptime_;
  }
  _impl_.uptime_ = nullptr;
}
inline const ::unhinged::observability::v1::UptimeInfo& ServiceHealth::_internal_uptime() const {
  const ::unhinged::observability::v1::UptimeInfo* p = _impl_.uptime_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::observability::v1::UptimeInfo&>(
      ::unhinged::observability::v1::_UptimeInfo_default_instance_);
}
inline const ::unhinged::observability::v1::UptimeInfo& ServiceHealth::uptime() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.ServiceHealth.uptime)
  return _internal_uptime();
}
inline void ServiceHealth::unsafe_arena_set_allocated_uptime(
    ::unhinged::observability::v1::UptimeInfo* uptime) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.uptime_);
  }
  _impl_.uptime_ = uptime;
  if (uptime) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.ServiceHealth.uptime)
}
inline ::unhinged::observability::v1::UptimeInfo* ServiceHealth::release_uptime() {
  
  ::unhinged::observability::v1::UptimeInfo* temp = _impl_.uptime_;
  _impl_.uptime_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::observability::v1::UptimeInfo* ServiceHealth::unsafe_arena_release_uptime() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.ServiceHealth.uptime)
  
  ::unhinged::observability::v1::UptimeInfo* temp = _impl_.uptime_;
  _impl_.uptime_ = nullptr;
  return temp;
}
inline ::unhinged::observability::v1::UptimeInfo* ServiceHealth::_internal_mutable_uptime() {
  
  if (_impl_.uptime_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::observability::v1::UptimeInfo>(GetArenaForAllocation());
    _impl_.uptime_ = p;
  }
  return _impl_.uptime_;
}
inline ::unhinged::observability::v1::UptimeInfo* ServiceHealth::mutable_uptime() {
  ::unhinged::observability::v1::UptimeInfo* _msg = _internal_mutable_uptime();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.ServiceHealth.uptime)
  return _msg;
}
inline void ServiceHealth::set_allocated_uptime(::unhinged::observability::v1::UptimeInfo* uptime) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.uptime_;
  }
  if (uptime) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(uptime);
    if (message_arena != submessage_arena) {
      uptime = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, uptime, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.uptime_ = uptime;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.ServiceHealth.uptime)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// HealthCheck

// string name = 1;
inline void HealthCheck::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& HealthCheck::name() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.HealthCheck.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HealthCheck::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.HealthCheck.name)
}
inline std::string* HealthCheck::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.HealthCheck.name)
  return _s;
}
inline const std::string& HealthCheck::_internal_name() const {
  return _impl_.name_.Get();
}
inline void HealthCheck::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* HealthCheck::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* HealthCheck::release_name() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.HealthCheck.name)
  return _impl_.name_.Release();
}
inline void HealthCheck::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.HealthCheck.name)
}

// .unhinged.observability.v1.HealthStatus status = 2;
inline void HealthCheck::clear_status() {
  _impl_.status_ = 0;
}
inline ::unhinged::observability::v1::HealthStatus HealthCheck::_internal_status() const {
  return static_cast< ::unhinged::observability::v1::HealthStatus >(_impl_.status_);
}
inline ::unhinged::observability::v1::HealthStatus HealthCheck::status() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.HealthCheck.status)
  return _internal_status();
}
inline void HealthCheck::_internal_set_status(::unhinged::observability::v1::HealthStatus value) {
  
  _impl_.status_ = value;
}
inline void HealthCheck::set_status(::unhinged::observability::v1::HealthStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.HealthCheck.status)
}

// string message = 3;
inline void HealthCheck::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& HealthCheck::message() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.HealthCheck.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HealthCheck::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.HealthCheck.message)
}
inline std::string* HealthCheck::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.HealthCheck.message)
  return _s;
}
inline const std::string& HealthCheck::_internal_message() const {
  return _impl_.message_.Get();
}
inline void HealthCheck::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* HealthCheck::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* HealthCheck::release_message() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.HealthCheck.message)
  return _impl_.message_.Release();
}
inline void HealthCheck::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.HealthCheck.message)
}

// .google.protobuf.Timestamp last_check = 4;
inline bool HealthCheck::_internal_has_last_check() const {
  return this != internal_default_instance() && _impl_.last_check_ != nullptr;
}
inline bool HealthCheck::has_last_check() const {
  return _internal_has_last_check();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& HealthCheck::_internal_last_check() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.last_check_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& HealthCheck::last_check() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.HealthCheck.last_check)
  return _internal_last_check();
}
inline void HealthCheck::unsafe_arena_set_allocated_last_check(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_check) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_check_);
  }
  _impl_.last_check_ = last_check;
  if (last_check) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.HealthCheck.last_check)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* HealthCheck::release_last_check() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.last_check_;
  _impl_.last_check_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* HealthCheck::unsafe_arena_release_last_check() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.HealthCheck.last_check)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.last_check_;
  _impl_.last_check_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* HealthCheck::_internal_mutable_last_check() {
  
  if (_impl_.last_check_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.last_check_ = p;
  }
  return _impl_.last_check_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* HealthCheck::mutable_last_check() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_last_check();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.HealthCheck.last_check)
  return _msg;
}
inline void HealthCheck::set_allocated_last_check(::PROTOBUF_NAMESPACE_ID::Timestamp* last_check) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_check_);
  }
  if (last_check) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_check));
    if (message_arena != submessage_arena) {
      last_check = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_check, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.last_check_ = last_check;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.HealthCheck.last_check)
}

// int64 response_time_ms = 5;
inline void HealthCheck::clear_response_time_ms() {
  _impl_.response_time_ms_ = int64_t{0};
}
inline int64_t HealthCheck::_internal_response_time_ms() const {
  return _impl_.response_time_ms_;
}
inline int64_t HealthCheck::response_time_ms() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.HealthCheck.response_time_ms)
  return _internal_response_time_ms();
}
inline void HealthCheck::_internal_set_response_time_ms(int64_t value) {
  
  _impl_.response_time_ms_ = value;
}
inline void HealthCheck::set_response_time_ms(int64_t value) {
  _internal_set_response_time_ms(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.HealthCheck.response_time_ms)
}

// map<string, string> metadata = 10;
inline int HealthCheck::_internal_metadata_size() const {
  return _impl_.metadata_.size();
}
inline int HealthCheck::metadata_size() const {
  return _internal_metadata_size();
}
inline void HealthCheck::clear_metadata() {
  _impl_.metadata_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
HealthCheck::_internal_metadata() const {
  return _impl_.metadata_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
HealthCheck::metadata() const {
  // @@protoc_insertion_point(field_map:unhinged.observability.v1.HealthCheck.metadata)
  return _internal_metadata();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
HealthCheck::_internal_mutable_metadata() {
  return _impl_.metadata_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
HealthCheck::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_map:unhinged.observability.v1.HealthCheck.metadata)
  return _internal_mutable_metadata();
}

// -------------------------------------------------------------------

// DependencyHealth

// string name = 1;
inline void DependencyHealth::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& DependencyHealth::name() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.DependencyHealth.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DependencyHealth::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.DependencyHealth.name)
}
inline std::string* DependencyHealth::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.DependencyHealth.name)
  return _s;
}
inline const std::string& DependencyHealth::_internal_name() const {
  return _impl_.name_.Get();
}
inline void DependencyHealth::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* DependencyHealth::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* DependencyHealth::release_name() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.DependencyHealth.name)
  return _impl_.name_.Release();
}
inline void DependencyHealth::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.DependencyHealth.name)
}

// string type = 2;
inline void DependencyHealth::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& DependencyHealth::type() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.DependencyHealth.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DependencyHealth::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.DependencyHealth.type)
}
inline std::string* DependencyHealth::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.DependencyHealth.type)
  return _s;
}
inline const std::string& DependencyHealth::_internal_type() const {
  return _impl_.type_.Get();
}
inline void DependencyHealth::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* DependencyHealth::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* DependencyHealth::release_type() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.DependencyHealth.type)
  return _impl_.type_.Release();
}
inline void DependencyHealth::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.DependencyHealth.type)
}

// .unhinged.observability.v1.HealthStatus status = 3;
inline void DependencyHealth::clear_status() {
  _impl_.status_ = 0;
}
inline ::unhinged::observability::v1::HealthStatus DependencyHealth::_internal_status() const {
  return static_cast< ::unhinged::observability::v1::HealthStatus >(_impl_.status_);
}
inline ::unhinged::observability::v1::HealthStatus DependencyHealth::status() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.DependencyHealth.status)
  return _internal_status();
}
inline void DependencyHealth::_internal_set_status(::unhinged::observability::v1::HealthStatus value) {
  
  _impl_.status_ = value;
}
inline void DependencyHealth::set_status(::unhinged::observability::v1::HealthStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.DependencyHealth.status)
}

// string endpoint = 4;
inline void DependencyHealth::clear_endpoint() {
  _impl_.endpoint_.ClearToEmpty();
}
inline const std::string& DependencyHealth::endpoint() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.DependencyHealth.endpoint)
  return _internal_endpoint();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DependencyHealth::set_endpoint(ArgT0&& arg0, ArgT... args) {
 
 _impl_.endpoint_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.DependencyHealth.endpoint)
}
inline std::string* DependencyHealth::mutable_endpoint() {
  std::string* _s = _internal_mutable_endpoint();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.DependencyHealth.endpoint)
  return _s;
}
inline const std::string& DependencyHealth::_internal_endpoint() const {
  return _impl_.endpoint_.Get();
}
inline void DependencyHealth::_internal_set_endpoint(const std::string& value) {
  
  _impl_.endpoint_.Set(value, GetArenaForAllocation());
}
inline std::string* DependencyHealth::_internal_mutable_endpoint() {
  
  return _impl_.endpoint_.Mutable(GetArenaForAllocation());
}
inline std::string* DependencyHealth::release_endpoint() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.DependencyHealth.endpoint)
  return _impl_.endpoint_.Release();
}
inline void DependencyHealth::set_allocated_endpoint(std::string* endpoint) {
  if (endpoint != nullptr) {
    
  } else {
    
  }
  _impl_.endpoint_.SetAllocated(endpoint, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.endpoint_.IsDefault()) {
    _impl_.endpoint_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.DependencyHealth.endpoint)
}

// int64 response_time_ms = 5;
inline void DependencyHealth::clear_response_time_ms() {
  _impl_.response_time_ms_ = int64_t{0};
}
inline int64_t DependencyHealth::_internal_response_time_ms() const {
  return _impl_.response_time_ms_;
}
inline int64_t DependencyHealth::response_time_ms() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.DependencyHealth.response_time_ms)
  return _internal_response_time_ms();
}
inline void DependencyHealth::_internal_set_response_time_ms(int64_t value) {
  
  _impl_.response_time_ms_ = value;
}
inline void DependencyHealth::set_response_time_ms(int64_t value) {
  _internal_set_response_time_ms(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.DependencyHealth.response_time_ms)
}

// string version = 6;
inline void DependencyHealth::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& DependencyHealth::version() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.DependencyHealth.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DependencyHealth::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.DependencyHealth.version)
}
inline std::string* DependencyHealth::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.DependencyHealth.version)
  return _s;
}
inline const std::string& DependencyHealth::_internal_version() const {
  return _impl_.version_.Get();
}
inline void DependencyHealth::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* DependencyHealth::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* DependencyHealth::release_version() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.DependencyHealth.version)
  return _impl_.version_.Release();
}
inline void DependencyHealth::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.DependencyHealth.version)
}

// .google.protobuf.Timestamp last_check = 10;
inline bool DependencyHealth::_internal_has_last_check() const {
  return this != internal_default_instance() && _impl_.last_check_ != nullptr;
}
inline bool DependencyHealth::has_last_check() const {
  return _internal_has_last_check();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& DependencyHealth::_internal_last_check() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.last_check_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& DependencyHealth::last_check() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.DependencyHealth.last_check)
  return _internal_last_check();
}
inline void DependencyHealth::unsafe_arena_set_allocated_last_check(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_check) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_check_);
  }
  _impl_.last_check_ = last_check;
  if (last_check) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.DependencyHealth.last_check)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DependencyHealth::release_last_check() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.last_check_;
  _impl_.last_check_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DependencyHealth::unsafe_arena_release_last_check() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.DependencyHealth.last_check)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.last_check_;
  _impl_.last_check_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DependencyHealth::_internal_mutable_last_check() {
  
  if (_impl_.last_check_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.last_check_ = p;
  }
  return _impl_.last_check_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DependencyHealth::mutable_last_check() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_last_check();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.DependencyHealth.last_check)
  return _msg;
}
inline void DependencyHealth::set_allocated_last_check(::PROTOBUF_NAMESPACE_ID::Timestamp* last_check) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_check_);
  }
  if (last_check) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_check));
    if (message_arena != submessage_arena) {
      last_check = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_check, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.last_check_ = last_check;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.DependencyHealth.last_check)
}

// -------------------------------------------------------------------

// ServiceLevelIndicators

// double availability_percent = 1;
inline void ServiceLevelIndicators::clear_availability_percent() {
  _impl_.availability_percent_ = 0;
}
inline double ServiceLevelIndicators::_internal_availability_percent() const {
  return _impl_.availability_percent_;
}
inline double ServiceLevelIndicators::availability_percent() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.ServiceLevelIndicators.availability_percent)
  return _internal_availability_percent();
}
inline void ServiceLevelIndicators::_internal_set_availability_percent(double value) {
  
  _impl_.availability_percent_ = value;
}
inline void ServiceLevelIndicators::set_availability_percent(double value) {
  _internal_set_availability_percent(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.ServiceLevelIndicators.availability_percent)
}

// double error_rate_percent = 2;
inline void ServiceLevelIndicators::clear_error_rate_percent() {
  _impl_.error_rate_percent_ = 0;
}
inline double ServiceLevelIndicators::_internal_error_rate_percent() const {
  return _impl_.error_rate_percent_;
}
inline double ServiceLevelIndicators::error_rate_percent() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.ServiceLevelIndicators.error_rate_percent)
  return _internal_error_rate_percent();
}
inline void ServiceLevelIndicators::_internal_set_error_rate_percent(double value) {
  
  _impl_.error_rate_percent_ = value;
}
inline void ServiceLevelIndicators::set_error_rate_percent(double value) {
  _internal_set_error_rate_percent(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.ServiceLevelIndicators.error_rate_percent)
}

// double latency_p50_ms = 3;
inline void ServiceLevelIndicators::clear_latency_p50_ms() {
  _impl_.latency_p50_ms_ = 0;
}
inline double ServiceLevelIndicators::_internal_latency_p50_ms() const {
  return _impl_.latency_p50_ms_;
}
inline double ServiceLevelIndicators::latency_p50_ms() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.ServiceLevelIndicators.latency_p50_ms)
  return _internal_latency_p50_ms();
}
inline void ServiceLevelIndicators::_internal_set_latency_p50_ms(double value) {
  
  _impl_.latency_p50_ms_ = value;
}
inline void ServiceLevelIndicators::set_latency_p50_ms(double value) {
  _internal_set_latency_p50_ms(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.ServiceLevelIndicators.latency_p50_ms)
}

// double latency_p95_ms = 4;
inline void ServiceLevelIndicators::clear_latency_p95_ms() {
  _impl_.latency_p95_ms_ = 0;
}
inline double ServiceLevelIndicators::_internal_latency_p95_ms() const {
  return _impl_.latency_p95_ms_;
}
inline double ServiceLevelIndicators::latency_p95_ms() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.ServiceLevelIndicators.latency_p95_ms)
  return _internal_latency_p95_ms();
}
inline void ServiceLevelIndicators::_internal_set_latency_p95_ms(double value) {
  
  _impl_.latency_p95_ms_ = value;
}
inline void ServiceLevelIndicators::set_latency_p95_ms(double value) {
  _internal_set_latency_p95_ms(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.ServiceLevelIndicators.latency_p95_ms)
}

// double latency_p99_ms = 5;
inline void ServiceLevelIndicators::clear_latency_p99_ms() {
  _impl_.latency_p99_ms_ = 0;
}
inline double ServiceLevelIndicators::_internal_latency_p99_ms() const {
  return _impl_.latency_p99_ms_;
}
inline double ServiceLevelIndicators::latency_p99_ms() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.ServiceLevelIndicators.latency_p99_ms)
  return _internal_latency_p99_ms();
}
inline void ServiceLevelIndicators::_internal_set_latency_p99_ms(double value) {
  
  _impl_.latency_p99_ms_ = value;
}
inline void ServiceLevelIndicators::set_latency_p99_ms(double value) {
  _internal_set_latency_p99_ms(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.ServiceLevelIndicators.latency_p99_ms)
}

// double throughput_rps = 6;
inline void ServiceLevelIndicators::clear_throughput_rps() {
  _impl_.throughput_rps_ = 0;
}
inline double ServiceLevelIndicators::_internal_throughput_rps() const {
  return _impl_.throughput_rps_;
}
inline double ServiceLevelIndicators::throughput_rps() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.ServiceLevelIndicators.throughput_rps)
  return _internal_throughput_rps();
}
inline void ServiceLevelIndicators::_internal_set_throughput_rps(double value) {
  
  _impl_.throughput_rps_ = value;
}
inline void ServiceLevelIndicators::set_throughput_rps(double value) {
  _internal_set_throughput_rps(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.ServiceLevelIndicators.throughput_rps)
}

// .google.protobuf.Timestamp window_start = 10;
inline bool ServiceLevelIndicators::_internal_has_window_start() const {
  return this != internal_default_instance() && _impl_.window_start_ != nullptr;
}
inline bool ServiceLevelIndicators::has_window_start() const {
  return _internal_has_window_start();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ServiceLevelIndicators::_internal_window_start() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.window_start_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ServiceLevelIndicators::window_start() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.ServiceLevelIndicators.window_start)
  return _internal_window_start();
}
inline void ServiceLevelIndicators::unsafe_arena_set_allocated_window_start(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* window_start) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.window_start_);
  }
  _impl_.window_start_ = window_start;
  if (window_start) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.ServiceLevelIndicators.window_start)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ServiceLevelIndicators::release_window_start() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.window_start_;
  _impl_.window_start_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ServiceLevelIndicators::unsafe_arena_release_window_start() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.ServiceLevelIndicators.window_start)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.window_start_;
  _impl_.window_start_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ServiceLevelIndicators::_internal_mutable_window_start() {
  
  if (_impl_.window_start_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.window_start_ = p;
  }
  return _impl_.window_start_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ServiceLevelIndicators::mutable_window_start() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_window_start();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.ServiceLevelIndicators.window_start)
  return _msg;
}
inline void ServiceLevelIndicators::set_allocated_window_start(::PROTOBUF_NAMESPACE_ID::Timestamp* window_start) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.window_start_);
  }
  if (window_start) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(window_start));
    if (message_arena != submessage_arena) {
      window_start = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, window_start, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.window_start_ = window_start;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.ServiceLevelIndicators.window_start)
}

// .google.protobuf.Timestamp window_end = 11;
inline bool ServiceLevelIndicators::_internal_has_window_end() const {
  return this != internal_default_instance() && _impl_.window_end_ != nullptr;
}
inline bool ServiceLevelIndicators::has_window_end() const {
  return _internal_has_window_end();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ServiceLevelIndicators::_internal_window_end() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.window_end_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ServiceLevelIndicators::window_end() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.ServiceLevelIndicators.window_end)
  return _internal_window_end();
}
inline void ServiceLevelIndicators::unsafe_arena_set_allocated_window_end(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* window_end) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.window_end_);
  }
  _impl_.window_end_ = window_end;
  if (window_end) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.ServiceLevelIndicators.window_end)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ServiceLevelIndicators::release_window_end() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.window_end_;
  _impl_.window_end_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ServiceLevelIndicators::unsafe_arena_release_window_end() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.ServiceLevelIndicators.window_end)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.window_end_;
  _impl_.window_end_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ServiceLevelIndicators::_internal_mutable_window_end() {
  
  if (_impl_.window_end_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.window_end_ = p;
  }
  return _impl_.window_end_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ServiceLevelIndicators::mutable_window_end() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_window_end();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.ServiceLevelIndicators.window_end)
  return _msg;
}
inline void ServiceLevelIndicators::set_allocated_window_end(::PROTOBUF_NAMESPACE_ID::Timestamp* window_end) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.window_end_);
  }
  if (window_end) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(window_end));
    if (message_arena != submessage_arena) {
      window_end = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, window_end, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.window_end_ = window_end;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.ServiceLevelIndicators.window_end)
}

// -------------------------------------------------------------------

// SystemMetrics

// double cpu_usage_percent = 1;
inline void SystemMetrics::clear_cpu_usage_percent() {
  _impl_.cpu_usage_percent_ = 0;
}
inline double SystemMetrics::_internal_cpu_usage_percent() const {
  return _impl_.cpu_usage_percent_;
}
inline double SystemMetrics::cpu_usage_percent() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.SystemMetrics.cpu_usage_percent)
  return _internal_cpu_usage_percent();
}
inline void SystemMetrics::_internal_set_cpu_usage_percent(double value) {
  
  _impl_.cpu_usage_percent_ = value;
}
inline void SystemMetrics::set_cpu_usage_percent(double value) {
  _internal_set_cpu_usage_percent(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.SystemMetrics.cpu_usage_percent)
}

// double cpu_load_1m = 2;
inline void SystemMetrics::clear_cpu_load_1m() {
  _impl_.cpu_load_1m_ = 0;
}
inline double SystemMetrics::_internal_cpu_load_1m() const {
  return _impl_.cpu_load_1m_;
}
inline double SystemMetrics::cpu_load_1m() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.SystemMetrics.cpu_load_1m)
  return _internal_cpu_load_1m();
}
inline void SystemMetrics::_internal_set_cpu_load_1m(double value) {
  
  _impl_.cpu_load_1m_ = value;
}
inline void SystemMetrics::set_cpu_load_1m(double value) {
  _internal_set_cpu_load_1m(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.SystemMetrics.cpu_load_1m)
}

// double cpu_load_5m = 3;
inline void SystemMetrics::clear_cpu_load_5m() {
  _impl_.cpu_load_5m_ = 0;
}
inline double SystemMetrics::_internal_cpu_load_5m() const {
  return _impl_.cpu_load_5m_;
}
inline double SystemMetrics::cpu_load_5m() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.SystemMetrics.cpu_load_5m)
  return _internal_cpu_load_5m();
}
inline void SystemMetrics::_internal_set_cpu_load_5m(double value) {
  
  _impl_.cpu_load_5m_ = value;
}
inline void SystemMetrics::set_cpu_load_5m(double value) {
  _internal_set_cpu_load_5m(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.SystemMetrics.cpu_load_5m)
}

// double cpu_load_15m = 4;
inline void SystemMetrics::clear_cpu_load_15m() {
  _impl_.cpu_load_15m_ = 0;
}
inline double SystemMetrics::_internal_cpu_load_15m() const {
  return _impl_.cpu_load_15m_;
}
inline double SystemMetrics::cpu_load_15m() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.SystemMetrics.cpu_load_15m)
  return _internal_cpu_load_15m();
}
inline void SystemMetrics::_internal_set_cpu_load_15m(double value) {
  
  _impl_.cpu_load_15m_ = value;
}
inline void SystemMetrics::set_cpu_load_15m(double value) {
  _internal_set_cpu_load_15m(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.SystemMetrics.cpu_load_15m)
}

// uint64 memory_total_bytes = 10;
inline void SystemMetrics::clear_memory_total_bytes() {
  _impl_.memory_total_bytes_ = uint64_t{0u};
}
inline uint64_t SystemMetrics::_internal_memory_total_bytes() const {
  return _impl_.memory_total_bytes_;
}
inline uint64_t SystemMetrics::memory_total_bytes() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.SystemMetrics.memory_total_bytes)
  return _internal_memory_total_bytes();
}
inline void SystemMetrics::_internal_set_memory_total_bytes(uint64_t value) {
  
  _impl_.memory_total_bytes_ = value;
}
inline void SystemMetrics::set_memory_total_bytes(uint64_t value) {
  _internal_set_memory_total_bytes(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.SystemMetrics.memory_total_bytes)
}

// uint64 memory_used_bytes = 11;
inline void SystemMetrics::clear_memory_used_bytes() {
  _impl_.memory_used_bytes_ = uint64_t{0u};
}
inline uint64_t SystemMetrics::_internal_memory_used_bytes() const {
  return _impl_.memory_used_bytes_;
}
inline uint64_t SystemMetrics::memory_used_bytes() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.SystemMetrics.memory_used_bytes)
  return _internal_memory_used_bytes();
}
inline void SystemMetrics::_internal_set_memory_used_bytes(uint64_t value) {
  
  _impl_.memory_used_bytes_ = value;
}
inline void SystemMetrics::set_memory_used_bytes(uint64_t value) {
  _internal_set_memory_used_bytes(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.SystemMetrics.memory_used_bytes)
}

// uint64 memory_available_bytes = 12;
inline void SystemMetrics::clear_memory_available_bytes() {
  _impl_.memory_available_bytes_ = uint64_t{0u};
}
inline uint64_t SystemMetrics::_internal_memory_available_bytes() const {
  return _impl_.memory_available_bytes_;
}
inline uint64_t SystemMetrics::memory_available_bytes() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.SystemMetrics.memory_available_bytes)
  return _internal_memory_available_bytes();
}
inline void SystemMetrics::_internal_set_memory_available_bytes(uint64_t value) {
  
  _impl_.memory_available_bytes_ = value;
}
inline void SystemMetrics::set_memory_available_bytes(uint64_t value) {
  _internal_set_memory_available_bytes(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.SystemMetrics.memory_available_bytes)
}

// double memory_usage_percent = 13;
inline void SystemMetrics::clear_memory_usage_percent() {
  _impl_.memory_usage_percent_ = 0;
}
inline double SystemMetrics::_internal_memory_usage_percent() const {
  return _impl_.memory_usage_percent_;
}
inline double SystemMetrics::memory_usage_percent() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.SystemMetrics.memory_usage_percent)
  return _internal_memory_usage_percent();
}
inline void SystemMetrics::_internal_set_memory_usage_percent(double value) {
  
  _impl_.memory_usage_percent_ = value;
}
inline void SystemMetrics::set_memory_usage_percent(double value) {
  _internal_set_memory_usage_percent(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.SystemMetrics.memory_usage_percent)
}

// uint64 disk_total_bytes = 20;
inline void SystemMetrics::clear_disk_total_bytes() {
  _impl_.disk_total_bytes_ = uint64_t{0u};
}
inline uint64_t SystemMetrics::_internal_disk_total_bytes() const {
  return _impl_.disk_total_bytes_;
}
inline uint64_t SystemMetrics::disk_total_bytes() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.SystemMetrics.disk_total_bytes)
  return _internal_disk_total_bytes();
}
inline void SystemMetrics::_internal_set_disk_total_bytes(uint64_t value) {
  
  _impl_.disk_total_bytes_ = value;
}
inline void SystemMetrics::set_disk_total_bytes(uint64_t value) {
  _internal_set_disk_total_bytes(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.SystemMetrics.disk_total_bytes)
}

// uint64 disk_used_bytes = 21;
inline void SystemMetrics::clear_disk_used_bytes() {
  _impl_.disk_used_bytes_ = uint64_t{0u};
}
inline uint64_t SystemMetrics::_internal_disk_used_bytes() const {
  return _impl_.disk_used_bytes_;
}
inline uint64_t SystemMetrics::disk_used_bytes() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.SystemMetrics.disk_used_bytes)
  return _internal_disk_used_bytes();
}
inline void SystemMetrics::_internal_set_disk_used_bytes(uint64_t value) {
  
  _impl_.disk_used_bytes_ = value;
}
inline void SystemMetrics::set_disk_used_bytes(uint64_t value) {
  _internal_set_disk_used_bytes(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.SystemMetrics.disk_used_bytes)
}

// uint64 disk_available_bytes = 22;
inline void SystemMetrics::clear_disk_available_bytes() {
  _impl_.disk_available_bytes_ = uint64_t{0u};
}
inline uint64_t SystemMetrics::_internal_disk_available_bytes() const {
  return _impl_.disk_available_bytes_;
}
inline uint64_t SystemMetrics::disk_available_bytes() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.SystemMetrics.disk_available_bytes)
  return _internal_disk_available_bytes();
}
inline void SystemMetrics::_internal_set_disk_available_bytes(uint64_t value) {
  
  _impl_.disk_available_bytes_ = value;
}
inline void SystemMetrics::set_disk_available_bytes(uint64_t value) {
  _internal_set_disk_available_bytes(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.SystemMetrics.disk_available_bytes)
}

// double disk_usage_percent = 23;
inline void SystemMetrics::clear_disk_usage_percent() {
  _impl_.disk_usage_percent_ = 0;
}
inline double SystemMetrics::_internal_disk_usage_percent() const {
  return _impl_.disk_usage_percent_;
}
inline double SystemMetrics::disk_usage_percent() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.SystemMetrics.disk_usage_percent)
  return _internal_disk_usage_percent();
}
inline void SystemMetrics::_internal_set_disk_usage_percent(double value) {
  
  _impl_.disk_usage_percent_ = value;
}
inline void SystemMetrics::set_disk_usage_percent(double value) {
  _internal_set_disk_usage_percent(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.SystemMetrics.disk_usage_percent)
}

// uint64 network_bytes_sent = 30;
inline void SystemMetrics::clear_network_bytes_sent() {
  _impl_.network_bytes_sent_ = uint64_t{0u};
}
inline uint64_t SystemMetrics::_internal_network_bytes_sent() const {
  return _impl_.network_bytes_sent_;
}
inline uint64_t SystemMetrics::network_bytes_sent() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.SystemMetrics.network_bytes_sent)
  return _internal_network_bytes_sent();
}
inline void SystemMetrics::_internal_set_network_bytes_sent(uint64_t value) {
  
  _impl_.network_bytes_sent_ = value;
}
inline void SystemMetrics::set_network_bytes_sent(uint64_t value) {
  _internal_set_network_bytes_sent(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.SystemMetrics.network_bytes_sent)
}

// uint64 network_bytes_received = 31;
inline void SystemMetrics::clear_network_bytes_received() {
  _impl_.network_bytes_received_ = uint64_t{0u};
}
inline uint64_t SystemMetrics::_internal_network_bytes_received() const {
  return _impl_.network_bytes_received_;
}
inline uint64_t SystemMetrics::network_bytes_received() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.SystemMetrics.network_bytes_received)
  return _internal_network_bytes_received();
}
inline void SystemMetrics::_internal_set_network_bytes_received(uint64_t value) {
  
  _impl_.network_bytes_received_ = value;
}
inline void SystemMetrics::set_network_bytes_received(uint64_t value) {
  _internal_set_network_bytes_received(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.SystemMetrics.network_bytes_received)
}

// uint64 network_packets_sent = 32;
inline void SystemMetrics::clear_network_packets_sent() {
  _impl_.network_packets_sent_ = uint64_t{0u};
}
inline uint64_t SystemMetrics::_internal_network_packets_sent() const {
  return _impl_.network_packets_sent_;
}
inline uint64_t SystemMetrics::network_packets_sent() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.SystemMetrics.network_packets_sent)
  return _internal_network_packets_sent();
}
inline void SystemMetrics::_internal_set_network_packets_sent(uint64_t value) {
  
  _impl_.network_packets_sent_ = value;
}
inline void SystemMetrics::set_network_packets_sent(uint64_t value) {
  _internal_set_network_packets_sent(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.SystemMetrics.network_packets_sent)
}

// uint64 network_packets_received = 33;
inline void SystemMetrics::clear_network_packets_received() {
  _impl_.network_packets_received_ = uint64_t{0u};
}
inline uint64_t SystemMetrics::_internal_network_packets_received() const {
  return _impl_.network_packets_received_;
}
inline uint64_t SystemMetrics::network_packets_received() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.SystemMetrics.network_packets_received)
  return _internal_network_packets_received();
}
inline void SystemMetrics::_internal_set_network_packets_received(uint64_t value) {
  
  _impl_.network_packets_received_ = value;
}
inline void SystemMetrics::set_network_packets_received(uint64_t value) {
  _internal_set_network_packets_received(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.SystemMetrics.network_packets_received)
}

// uint32 process_count = 40;
inline void SystemMetrics::clear_process_count() {
  _impl_.process_count_ = 0u;
}
inline uint32_t SystemMetrics::_internal_process_count() const {
  return _impl_.process_count_;
}
inline uint32_t SystemMetrics::process_count() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.SystemMetrics.process_count)
  return _internal_process_count();
}
inline void SystemMetrics::_internal_set_process_count(uint32_t value) {
  
  _impl_.process_count_ = value;
}
inline void SystemMetrics::set_process_count(uint32_t value) {
  _internal_set_process_count(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.SystemMetrics.process_count)
}

// uint32 thread_count = 41;
inline void SystemMetrics::clear_thread_count() {
  _impl_.thread_count_ = 0u;
}
inline uint32_t SystemMetrics::_internal_thread_count() const {
  return _impl_.thread_count_;
}
inline uint32_t SystemMetrics::thread_count() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.SystemMetrics.thread_count)
  return _internal_thread_count();
}
inline void SystemMetrics::_internal_set_thread_count(uint32_t value) {
  
  _impl_.thread_count_ = value;
}
inline void SystemMetrics::set_thread_count(uint32_t value) {
  _internal_set_thread_count(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.SystemMetrics.thread_count)
}

// uint32 file_descriptor_count = 42;
inline void SystemMetrics::clear_file_descriptor_count() {
  _impl_.file_descriptor_count_ = 0u;
}
inline uint32_t SystemMetrics::_internal_file_descriptor_count() const {
  return _impl_.file_descriptor_count_;
}
inline uint32_t SystemMetrics::file_descriptor_count() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.SystemMetrics.file_descriptor_count)
  return _internal_file_descriptor_count();
}
inline void SystemMetrics::_internal_set_file_descriptor_count(uint32_t value) {
  
  _impl_.file_descriptor_count_ = value;
}
inline void SystemMetrics::set_file_descriptor_count(uint32_t value) {
  _internal_set_file_descriptor_count(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.SystemMetrics.file_descriptor_count)
}

// -------------------------------------------------------------------

// UptimeInfo

// .google.protobuf.Timestamp start_time = 1;
inline bool UptimeInfo::_internal_has_start_time() const {
  return this != internal_default_instance() && _impl_.start_time_ != nullptr;
}
inline bool UptimeInfo::has_start_time() const {
  return _internal_has_start_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& UptimeInfo::_internal_start_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.start_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& UptimeInfo::start_time() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.UptimeInfo.start_time)
  return _internal_start_time();
}
inline void UptimeInfo::unsafe_arena_set_allocated_start_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_time_);
  }
  _impl_.start_time_ = start_time;
  if (start_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.UptimeInfo.start_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UptimeInfo::release_start_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.start_time_;
  _impl_.start_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UptimeInfo::unsafe_arena_release_start_time() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.UptimeInfo.start_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.start_time_;
  _impl_.start_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UptimeInfo::_internal_mutable_start_time() {
  
  if (_impl_.start_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.start_time_ = p;
  }
  return _impl_.start_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UptimeInfo::mutable_start_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_start_time();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.UptimeInfo.start_time)
  return _msg;
}
inline void UptimeInfo::set_allocated_start_time(::PROTOBUF_NAMESPACE_ID::Timestamp* start_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_time_);
  }
  if (start_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_time));
    if (message_arena != submessage_arena) {
      start_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.start_time_ = start_time;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.UptimeInfo.start_time)
}

// int64 uptime_seconds = 2;
inline void UptimeInfo::clear_uptime_seconds() {
  _impl_.uptime_seconds_ = int64_t{0};
}
inline int64_t UptimeInfo::_internal_uptime_seconds() const {
  return _impl_.uptime_seconds_;
}
inline int64_t UptimeInfo::uptime_seconds() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.UptimeInfo.uptime_seconds)
  return _internal_uptime_seconds();
}
inline void UptimeInfo::_internal_set_uptime_seconds(int64_t value) {
  
  _impl_.uptime_seconds_ = value;
}
inline void UptimeInfo::set_uptime_seconds(int64_t value) {
  _internal_set_uptime_seconds(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.UptimeInfo.uptime_seconds)
}

// uint32 restart_count = 3;
inline void UptimeInfo::clear_restart_count() {
  _impl_.restart_count_ = 0u;
}
inline uint32_t UptimeInfo::_internal_restart_count() const {
  return _impl_.restart_count_;
}
inline uint32_t UptimeInfo::restart_count() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.UptimeInfo.restart_count)
  return _internal_restart_count();
}
inline void UptimeInfo::_internal_set_restart_count(uint32_t value) {
  
  _impl_.restart_count_ = value;
}
inline void UptimeInfo::set_restart_count(uint32_t value) {
  _internal_set_restart_count(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.UptimeInfo.restart_count)
}

// .google.protobuf.Timestamp last_restart = 4;
inline bool UptimeInfo::_internal_has_last_restart() const {
  return this != internal_default_instance() && _impl_.last_restart_ != nullptr;
}
inline bool UptimeInfo::has_last_restart() const {
  return _internal_has_last_restart();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& UptimeInfo::_internal_last_restart() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.last_restart_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& UptimeInfo::last_restart() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.UptimeInfo.last_restart)
  return _internal_last_restart();
}
inline void UptimeInfo::unsafe_arena_set_allocated_last_restart(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_restart) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_restart_);
  }
  _impl_.last_restart_ = last_restart;
  if (last_restart) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.UptimeInfo.last_restart)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UptimeInfo::release_last_restart() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.last_restart_;
  _impl_.last_restart_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UptimeInfo::unsafe_arena_release_last_restart() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.UptimeInfo.last_restart)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.last_restart_;
  _impl_.last_restart_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UptimeInfo::_internal_mutable_last_restart() {
  
  if (_impl_.last_restart_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.last_restart_ = p;
  }
  return _impl_.last_restart_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UptimeInfo::mutable_last_restart() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_last_restart();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.UptimeInfo.last_restart)
  return _msg;
}
inline void UptimeInfo::set_allocated_last_restart(::PROTOBUF_NAMESPACE_ID::Timestamp* last_restart) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_restart_);
  }
  if (last_restart) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_restart));
    if (message_arena != submessage_arena) {
      last_restart = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_restart, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.last_restart_ = last_restart;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.UptimeInfo.last_restart)
}

// -------------------------------------------------------------------

// IncidentEvent

// string event_id = 1;
inline void IncidentEvent::clear_event_id() {
  _impl_.event_id_.ClearToEmpty();
}
inline const std::string& IncidentEvent::event_id() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.IncidentEvent.event_id)
  return _internal_event_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IncidentEvent::set_event_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.event_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.IncidentEvent.event_id)
}
inline std::string* IncidentEvent::mutable_event_id() {
  std::string* _s = _internal_mutable_event_id();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.IncidentEvent.event_id)
  return _s;
}
inline const std::string& IncidentEvent::_internal_event_id() const {
  return _impl_.event_id_.Get();
}
inline void IncidentEvent::_internal_set_event_id(const std::string& value) {
  
  _impl_.event_id_.Set(value, GetArenaForAllocation());
}
inline std::string* IncidentEvent::_internal_mutable_event_id() {
  
  return _impl_.event_id_.Mutable(GetArenaForAllocation());
}
inline std::string* IncidentEvent::release_event_id() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.IncidentEvent.event_id)
  return _impl_.event_id_.Release();
}
inline void IncidentEvent::set_allocated_event_id(std::string* event_id) {
  if (event_id != nullptr) {
    
  } else {
    
  }
  _impl_.event_id_.SetAllocated(event_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.event_id_.IsDefault()) {
    _impl_.event_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.IncidentEvent.event_id)
}

// .google.protobuf.Timestamp timestamp = 2;
inline bool IncidentEvent::_internal_has_timestamp() const {
  return this != internal_default_instance() && _impl_.timestamp_ != nullptr;
}
inline bool IncidentEvent::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& IncidentEvent::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& IncidentEvent::timestamp() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.IncidentEvent.timestamp)
  return _internal_timestamp();
}
inline void IncidentEvent::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.IncidentEvent.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* IncidentEvent::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* IncidentEvent::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.IncidentEvent.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* IncidentEvent::_internal_mutable_timestamp() {
  
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* IncidentEvent::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.IncidentEvent.timestamp)
  return _msg;
}
inline void IncidentEvent::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.IncidentEvent.timestamp)
}

// string event_type = 3;
inline void IncidentEvent::clear_event_type() {
  _impl_.event_type_.ClearToEmpty();
}
inline const std::string& IncidentEvent::event_type() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.IncidentEvent.event_type)
  return _internal_event_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IncidentEvent::set_event_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.event_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.IncidentEvent.event_type)
}
inline std::string* IncidentEvent::mutable_event_type() {
  std::string* _s = _internal_mutable_event_type();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.IncidentEvent.event_type)
  return _s;
}
inline const std::string& IncidentEvent::_internal_event_type() const {
  return _impl_.event_type_.Get();
}
inline void IncidentEvent::_internal_set_event_type(const std::string& value) {
  
  _impl_.event_type_.Set(value, GetArenaForAllocation());
}
inline std::string* IncidentEvent::_internal_mutable_event_type() {
  
  return _impl_.event_type_.Mutable(GetArenaForAllocation());
}
inline std::string* IncidentEvent::release_event_type() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.IncidentEvent.event_type)
  return _impl_.event_type_.Release();
}
inline void IncidentEvent::set_allocated_event_type(std::string* event_type) {
  if (event_type != nullptr) {
    
  } else {
    
  }
  _impl_.event_type_.SetAllocated(event_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.event_type_.IsDefault()) {
    _impl_.event_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.IncidentEvent.event_type)
}

// int64 sequence_number = 4;
inline void IncidentEvent::clear_sequence_number() {
  _impl_.sequence_number_ = int64_t{0};
}
inline int64_t IncidentEvent::_internal_sequence_number() const {
  return _impl_.sequence_number_;
}
inline int64_t IncidentEvent::sequence_number() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.IncidentEvent.sequence_number)
  return _internal_sequence_number();
}
inline void IncidentEvent::_internal_set_sequence_number(int64_t value) {
  
  _impl_.sequence_number_ = value;
}
inline void IncidentEvent::set_sequence_number(int64_t value) {
  _internal_set_sequence_number(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.IncidentEvent.sequence_number)
}

// .unhinged.observability.v1.IncidentData incident = 10;
inline bool IncidentEvent::_internal_has_incident() const {
  return this != internal_default_instance() && _impl_.incident_ != nullptr;
}
inline bool IncidentEvent::has_incident() const {
  return _internal_has_incident();
}
inline void IncidentEvent::clear_incident() {
  if (GetArenaForAllocation() == nullptr && _impl_.incident_ != nullptr) {
    delete _impl_.incident_;
  }
  _impl_.incident_ = nullptr;
}
inline const ::unhinged::observability::v1::IncidentData& IncidentEvent::_internal_incident() const {
  const ::unhinged::observability::v1::IncidentData* p = _impl_.incident_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::observability::v1::IncidentData&>(
      ::unhinged::observability::v1::_IncidentData_default_instance_);
}
inline const ::unhinged::observability::v1::IncidentData& IncidentEvent::incident() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.IncidentEvent.incident)
  return _internal_incident();
}
inline void IncidentEvent::unsafe_arena_set_allocated_incident(
    ::unhinged::observability::v1::IncidentData* incident) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.incident_);
  }
  _impl_.incident_ = incident;
  if (incident) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.IncidentEvent.incident)
}
inline ::unhinged::observability::v1::IncidentData* IncidentEvent::release_incident() {
  
  ::unhinged::observability::v1::IncidentData* temp = _impl_.incident_;
  _impl_.incident_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::observability::v1::IncidentData* IncidentEvent::unsafe_arena_release_incident() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.IncidentEvent.incident)
  
  ::unhinged::observability::v1::IncidentData* temp = _impl_.incident_;
  _impl_.incident_ = nullptr;
  return temp;
}
inline ::unhinged::observability::v1::IncidentData* IncidentEvent::_internal_mutable_incident() {
  
  if (_impl_.incident_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::observability::v1::IncidentData>(GetArenaForAllocation());
    _impl_.incident_ = p;
  }
  return _impl_.incident_;
}
inline ::unhinged::observability::v1::IncidentData* IncidentEvent::mutable_incident() {
  ::unhinged::observability::v1::IncidentData* _msg = _internal_mutable_incident();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.IncidentEvent.incident)
  return _msg;
}
inline void IncidentEvent::set_allocated_incident(::unhinged::observability::v1::IncidentData* incident) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.incident_;
  }
  if (incident) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(incident);
    if (message_arena != submessage_arena) {
      incident = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, incident, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.incident_ = incident;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.IncidentEvent.incident)
}

// .unhinged.observability.v1.DestinationFlags destinations = 20;
inline bool IncidentEvent::_internal_has_destinations() const {
  return this != internal_default_instance() && _impl_.destinations_ != nullptr;
}
inline bool IncidentEvent::has_destinations() const {
  return _internal_has_destinations();
}
inline void IncidentEvent::clear_destinations() {
  if (GetArenaForAllocation() == nullptr && _impl_.destinations_ != nullptr) {
    delete _impl_.destinations_;
  }
  _impl_.destinations_ = nullptr;
}
inline const ::unhinged::observability::v1::DestinationFlags& IncidentEvent::_internal_destinations() const {
  const ::unhinged::observability::v1::DestinationFlags* p = _impl_.destinations_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::observability::v1::DestinationFlags&>(
      ::unhinged::observability::v1::_DestinationFlags_default_instance_);
}
inline const ::unhinged::observability::v1::DestinationFlags& IncidentEvent::destinations() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.IncidentEvent.destinations)
  return _internal_destinations();
}
inline void IncidentEvent::unsafe_arena_set_allocated_destinations(
    ::unhinged::observability::v1::DestinationFlags* destinations) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.destinations_);
  }
  _impl_.destinations_ = destinations;
  if (destinations) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.IncidentEvent.destinations)
}
inline ::unhinged::observability::v1::DestinationFlags* IncidentEvent::release_destinations() {
  
  ::unhinged::observability::v1::DestinationFlags* temp = _impl_.destinations_;
  _impl_.destinations_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::observability::v1::DestinationFlags* IncidentEvent::unsafe_arena_release_destinations() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.IncidentEvent.destinations)
  
  ::unhinged::observability::v1::DestinationFlags* temp = _impl_.destinations_;
  _impl_.destinations_ = nullptr;
  return temp;
}
inline ::unhinged::observability::v1::DestinationFlags* IncidentEvent::_internal_mutable_destinations() {
  
  if (_impl_.destinations_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::observability::v1::DestinationFlags>(GetArenaForAllocation());
    _impl_.destinations_ = p;
  }
  return _impl_.destinations_;
}
inline ::unhinged::observability::v1::DestinationFlags* IncidentEvent::mutable_destinations() {
  ::unhinged::observability::v1::DestinationFlags* _msg = _internal_mutable_destinations();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.IncidentEvent.destinations)
  return _msg;
}
inline void IncidentEvent::set_allocated_destinations(::unhinged::observability::v1::DestinationFlags* destinations) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.destinations_;
  }
  if (destinations) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(destinations);
    if (message_arena != submessage_arena) {
      destinations = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, destinations, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.destinations_ = destinations;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.IncidentEvent.destinations)
}

// .unhinged.observability.v1.PartitionInfo partition_info = 25;
inline bool IncidentEvent::_internal_has_partition_info() const {
  return this != internal_default_instance() && _impl_.partition_info_ != nullptr;
}
inline bool IncidentEvent::has_partition_info() const {
  return _internal_has_partition_info();
}
inline void IncidentEvent::clear_partition_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.partition_info_ != nullptr) {
    delete _impl_.partition_info_;
  }
  _impl_.partition_info_ = nullptr;
}
inline const ::unhinged::observability::v1::PartitionInfo& IncidentEvent::_internal_partition_info() const {
  const ::unhinged::observability::v1::PartitionInfo* p = _impl_.partition_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::observability::v1::PartitionInfo&>(
      ::unhinged::observability::v1::_PartitionInfo_default_instance_);
}
inline const ::unhinged::observability::v1::PartitionInfo& IncidentEvent::partition_info() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.IncidentEvent.partition_info)
  return _internal_partition_info();
}
inline void IncidentEvent::unsafe_arena_set_allocated_partition_info(
    ::unhinged::observability::v1::PartitionInfo* partition_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.partition_info_);
  }
  _impl_.partition_info_ = partition_info;
  if (partition_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.IncidentEvent.partition_info)
}
inline ::unhinged::observability::v1::PartitionInfo* IncidentEvent::release_partition_info() {
  
  ::unhinged::observability::v1::PartitionInfo* temp = _impl_.partition_info_;
  _impl_.partition_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::observability::v1::PartitionInfo* IncidentEvent::unsafe_arena_release_partition_info() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.IncidentEvent.partition_info)
  
  ::unhinged::observability::v1::PartitionInfo* temp = _impl_.partition_info_;
  _impl_.partition_info_ = nullptr;
  return temp;
}
inline ::unhinged::observability::v1::PartitionInfo* IncidentEvent::_internal_mutable_partition_info() {
  
  if (_impl_.partition_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::observability::v1::PartitionInfo>(GetArenaForAllocation());
    _impl_.partition_info_ = p;
  }
  return _impl_.partition_info_;
}
inline ::unhinged::observability::v1::PartitionInfo* IncidentEvent::mutable_partition_info() {
  ::unhinged::observability::v1::PartitionInfo* _msg = _internal_mutable_partition_info();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.IncidentEvent.partition_info)
  return _msg;
}
inline void IncidentEvent::set_allocated_partition_info(::unhinged::observability::v1::PartitionInfo* partition_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.partition_info_;
  }
  if (partition_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(partition_info);
    if (message_arena != submessage_arena) {
      partition_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, partition_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.partition_info_ = partition_info;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.IncidentEvent.partition_info)
}

// -------------------------------------------------------------------

// IncidentData

// string incident_id = 1;
inline void IncidentData::clear_incident_id() {
  _impl_.incident_id_.ClearToEmpty();
}
inline const std::string& IncidentData::incident_id() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.IncidentData.incident_id)
  return _internal_incident_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IncidentData::set_incident_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.incident_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.IncidentData.incident_id)
}
inline std::string* IncidentData::mutable_incident_id() {
  std::string* _s = _internal_mutable_incident_id();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.IncidentData.incident_id)
  return _s;
}
inline const std::string& IncidentData::_internal_incident_id() const {
  return _impl_.incident_id_.Get();
}
inline void IncidentData::_internal_set_incident_id(const std::string& value) {
  
  _impl_.incident_id_.Set(value, GetArenaForAllocation());
}
inline std::string* IncidentData::_internal_mutable_incident_id() {
  
  return _impl_.incident_id_.Mutable(GetArenaForAllocation());
}
inline std::string* IncidentData::release_incident_id() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.IncidentData.incident_id)
  return _impl_.incident_id_.Release();
}
inline void IncidentData::set_allocated_incident_id(std::string* incident_id) {
  if (incident_id != nullptr) {
    
  } else {
    
  }
  _impl_.incident_id_.SetAllocated(incident_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.incident_id_.IsDefault()) {
    _impl_.incident_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.IncidentData.incident_id)
}

// string title = 2;
inline void IncidentData::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& IncidentData::title() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.IncidentData.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IncidentData::set_title(ArgT0&& arg0, ArgT... args) {
 
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.IncidentData.title)
}
inline std::string* IncidentData::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.IncidentData.title)
  return _s;
}
inline const std::string& IncidentData::_internal_title() const {
  return _impl_.title_.Get();
}
inline void IncidentData::_internal_set_title(const std::string& value) {
  
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* IncidentData::_internal_mutable_title() {
  
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* IncidentData::release_title() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.IncidentData.title)
  return _impl_.title_.Release();
}
inline void IncidentData::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.IncidentData.title)
}

// string description = 3;
inline void IncidentData::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& IncidentData::description() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.IncidentData.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IncidentData::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.IncidentData.description)
}
inline std::string* IncidentData::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.IncidentData.description)
  return _s;
}
inline const std::string& IncidentData::_internal_description() const {
  return _impl_.description_.Get();
}
inline void IncidentData::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* IncidentData::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* IncidentData::release_description() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.IncidentData.description)
  return _impl_.description_.Release();
}
inline void IncidentData::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.IncidentData.description)
}

// .unhinged.observability.v1.IncidentSeverity severity = 4;
inline void IncidentData::clear_severity() {
  _impl_.severity_ = 0;
}
inline ::unhinged::observability::v1::IncidentSeverity IncidentData::_internal_severity() const {
  return static_cast< ::unhinged::observability::v1::IncidentSeverity >(_impl_.severity_);
}
inline ::unhinged::observability::v1::IncidentSeverity IncidentData::severity() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.IncidentData.severity)
  return _internal_severity();
}
inline void IncidentData::_internal_set_severity(::unhinged::observability::v1::IncidentSeverity value) {
  
  _impl_.severity_ = value;
}
inline void IncidentData::set_severity(::unhinged::observability::v1::IncidentSeverity value) {
  _internal_set_severity(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.IncidentData.severity)
}

// .unhinged.observability.v1.IncidentStatus status = 5;
inline void IncidentData::clear_status() {
  _impl_.status_ = 0;
}
inline ::unhinged::observability::v1::IncidentStatus IncidentData::_internal_status() const {
  return static_cast< ::unhinged::observability::v1::IncidentStatus >(_impl_.status_);
}
inline ::unhinged::observability::v1::IncidentStatus IncidentData::status() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.IncidentData.status)
  return _internal_status();
}
inline void IncidentData::_internal_set_status(::unhinged::observability::v1::IncidentStatus value) {
  
  _impl_.status_ = value;
}
inline void IncidentData::set_status(::unhinged::observability::v1::IncidentStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.IncidentData.status)
}

// .google.protobuf.Timestamp created_at = 10;
inline bool IncidentData::_internal_has_created_at() const {
  return this != internal_default_instance() && _impl_.created_at_ != nullptr;
}
inline bool IncidentData::has_created_at() const {
  return _internal_has_created_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& IncidentData::_internal_created_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& IncidentData::created_at() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.IncidentData.created_at)
  return _internal_created_at();
}
inline void IncidentData::unsafe_arena_set_allocated_created_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.IncidentData.created_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* IncidentData::release_created_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* IncidentData::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.IncidentData.created_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* IncidentData::_internal_mutable_created_at() {
  
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.created_at_ = p;
  }
  return _impl_.created_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* IncidentData::mutable_created_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.IncidentData.created_at)
  return _msg;
}
inline void IncidentData::set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at));
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.IncidentData.created_at)
}

// .google.protobuf.Timestamp updated_at = 11;
inline bool IncidentData::_internal_has_updated_at() const {
  return this != internal_default_instance() && _impl_.updated_at_ != nullptr;
}
inline bool IncidentData::has_updated_at() const {
  return _internal_has_updated_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& IncidentData::_internal_updated_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.updated_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& IncidentData::updated_at() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.IncidentData.updated_at)
  return _internal_updated_at();
}
inline void IncidentData::unsafe_arena_set_allocated_updated_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.updated_at_);
  }
  _impl_.updated_at_ = updated_at;
  if (updated_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.IncidentData.updated_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* IncidentData::release_updated_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.updated_at_;
  _impl_.updated_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* IncidentData::unsafe_arena_release_updated_at() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.IncidentData.updated_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.updated_at_;
  _impl_.updated_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* IncidentData::_internal_mutable_updated_at() {
  
  if (_impl_.updated_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.updated_at_ = p;
  }
  return _impl_.updated_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* IncidentData::mutable_updated_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_updated_at();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.IncidentData.updated_at)
  return _msg;
}
inline void IncidentData::set_allocated_updated_at(::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.updated_at_);
  }
  if (updated_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(updated_at));
    if (message_arena != submessage_arena) {
      updated_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, updated_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.updated_at_ = updated_at;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.IncidentData.updated_at)
}

// .google.protobuf.Timestamp resolved_at = 12;
inline bool IncidentData::_internal_has_resolved_at() const {
  return this != internal_default_instance() && _impl_.resolved_at_ != nullptr;
}
inline bool IncidentData::has_resolved_at() const {
  return _internal_has_resolved_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& IncidentData::_internal_resolved_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.resolved_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& IncidentData::resolved_at() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.IncidentData.resolved_at)
  return _internal_resolved_at();
}
inline void IncidentData::unsafe_arena_set_allocated_resolved_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* resolved_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.resolved_at_);
  }
  _impl_.resolved_at_ = resolved_at;
  if (resolved_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.IncidentData.resolved_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* IncidentData::release_resolved_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.resolved_at_;
  _impl_.resolved_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* IncidentData::unsafe_arena_release_resolved_at() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.IncidentData.resolved_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.resolved_at_;
  _impl_.resolved_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* IncidentData::_internal_mutable_resolved_at() {
  
  if (_impl_.resolved_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.resolved_at_ = p;
  }
  return _impl_.resolved_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* IncidentData::mutable_resolved_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_resolved_at();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.IncidentData.resolved_at)
  return _msg;
}
inline void IncidentData::set_allocated_resolved_at(::PROTOBUF_NAMESPACE_ID::Timestamp* resolved_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.resolved_at_);
  }
  if (resolved_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(resolved_at));
    if (message_arena != submessage_arena) {
      resolved_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, resolved_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.resolved_at_ = resolved_at;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.IncidentData.resolved_at)
}

// repeated string affected_services = 15;
inline int IncidentData::_internal_affected_services_size() const {
  return _impl_.affected_services_.size();
}
inline int IncidentData::affected_services_size() const {
  return _internal_affected_services_size();
}
inline void IncidentData::clear_affected_services() {
  _impl_.affected_services_.Clear();
}
inline std::string* IncidentData::add_affected_services() {
  std::string* _s = _internal_add_affected_services();
  // @@protoc_insertion_point(field_add_mutable:unhinged.observability.v1.IncidentData.affected_services)
  return _s;
}
inline const std::string& IncidentData::_internal_affected_services(int index) const {
  return _impl_.affected_services_.Get(index);
}
inline const std::string& IncidentData::affected_services(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.IncidentData.affected_services)
  return _internal_affected_services(index);
}
inline std::string* IncidentData::mutable_affected_services(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.IncidentData.affected_services)
  return _impl_.affected_services_.Mutable(index);
}
inline void IncidentData::set_affected_services(int index, const std::string& value) {
  _impl_.affected_services_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.IncidentData.affected_services)
}
inline void IncidentData::set_affected_services(int index, std::string&& value) {
  _impl_.affected_services_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.IncidentData.affected_services)
}
inline void IncidentData::set_affected_services(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.affected_services_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.observability.v1.IncidentData.affected_services)
}
inline void IncidentData::set_affected_services(int index, const char* value, size_t size) {
  _impl_.affected_services_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.observability.v1.IncidentData.affected_services)
}
inline std::string* IncidentData::_internal_add_affected_services() {
  return _impl_.affected_services_.Add();
}
inline void IncidentData::add_affected_services(const std::string& value) {
  _impl_.affected_services_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.observability.v1.IncidentData.affected_services)
}
inline void IncidentData::add_affected_services(std::string&& value) {
  _impl_.affected_services_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.observability.v1.IncidentData.affected_services)
}
inline void IncidentData::add_affected_services(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.affected_services_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.observability.v1.IncidentData.affected_services)
}
inline void IncidentData::add_affected_services(const char* value, size_t size) {
  _impl_.affected_services_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.observability.v1.IncidentData.affected_services)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
IncidentData::affected_services() const {
  // @@protoc_insertion_point(field_list:unhinged.observability.v1.IncidentData.affected_services)
  return _impl_.affected_services_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
IncidentData::mutable_affected_services() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.observability.v1.IncidentData.affected_services)
  return &_impl_.affected_services_;
}

// repeated string affected_components = 16;
inline int IncidentData::_internal_affected_components_size() const {
  return _impl_.affected_components_.size();
}
inline int IncidentData::affected_components_size() const {
  return _internal_affected_components_size();
}
inline void IncidentData::clear_affected_components() {
  _impl_.affected_components_.Clear();
}
inline std::string* IncidentData::add_affected_components() {
  std::string* _s = _internal_add_affected_components();
  // @@protoc_insertion_point(field_add_mutable:unhinged.observability.v1.IncidentData.affected_components)
  return _s;
}
inline const std::string& IncidentData::_internal_affected_components(int index) const {
  return _impl_.affected_components_.Get(index);
}
inline const std::string& IncidentData::affected_components(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.IncidentData.affected_components)
  return _internal_affected_components(index);
}
inline std::string* IncidentData::mutable_affected_components(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.IncidentData.affected_components)
  return _impl_.affected_components_.Mutable(index);
}
inline void IncidentData::set_affected_components(int index, const std::string& value) {
  _impl_.affected_components_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.IncidentData.affected_components)
}
inline void IncidentData::set_affected_components(int index, std::string&& value) {
  _impl_.affected_components_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.IncidentData.affected_components)
}
inline void IncidentData::set_affected_components(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.affected_components_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.observability.v1.IncidentData.affected_components)
}
inline void IncidentData::set_affected_components(int index, const char* value, size_t size) {
  _impl_.affected_components_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.observability.v1.IncidentData.affected_components)
}
inline std::string* IncidentData::_internal_add_affected_components() {
  return _impl_.affected_components_.Add();
}
inline void IncidentData::add_affected_components(const std::string& value) {
  _impl_.affected_components_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.observability.v1.IncidentData.affected_components)
}
inline void IncidentData::add_affected_components(std::string&& value) {
  _impl_.affected_components_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.observability.v1.IncidentData.affected_components)
}
inline void IncidentData::add_affected_components(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.affected_components_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.observability.v1.IncidentData.affected_components)
}
inline void IncidentData::add_affected_components(const char* value, size_t size) {
  _impl_.affected_components_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.observability.v1.IncidentData.affected_components)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
IncidentData::affected_components() const {
  // @@protoc_insertion_point(field_list:unhinged.observability.v1.IncidentData.affected_components)
  return _impl_.affected_components_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
IncidentData::mutable_affected_components() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.observability.v1.IncidentData.affected_components)
  return &_impl_.affected_components_;
}

// repeated .unhinged.observability.v1.IncidentUpdate updates = 20;
inline int IncidentData::_internal_updates_size() const {
  return _impl_.updates_.size();
}
inline int IncidentData::updates_size() const {
  return _internal_updates_size();
}
inline void IncidentData::clear_updates() {
  _impl_.updates_.Clear();
}
inline ::unhinged::observability::v1::IncidentUpdate* IncidentData::mutable_updates(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.IncidentData.updates)
  return _impl_.updates_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::IncidentUpdate >*
IncidentData::mutable_updates() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.observability.v1.IncidentData.updates)
  return &_impl_.updates_;
}
inline const ::unhinged::observability::v1::IncidentUpdate& IncidentData::_internal_updates(int index) const {
  return _impl_.updates_.Get(index);
}
inline const ::unhinged::observability::v1::IncidentUpdate& IncidentData::updates(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.IncidentData.updates)
  return _internal_updates(index);
}
inline ::unhinged::observability::v1::IncidentUpdate* IncidentData::_internal_add_updates() {
  return _impl_.updates_.Add();
}
inline ::unhinged::observability::v1::IncidentUpdate* IncidentData::add_updates() {
  ::unhinged::observability::v1::IncidentUpdate* _add = _internal_add_updates();
  // @@protoc_insertion_point(field_add:unhinged.observability.v1.IncidentData.updates)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::IncidentUpdate >&
IncidentData::updates() const {
  // @@protoc_insertion_point(field_list:unhinged.observability.v1.IncidentData.updates)
  return _impl_.updates_;
}

// .unhinged.observability.v1.IncidentImpact impact = 25;
inline bool IncidentData::_internal_has_impact() const {
  return this != internal_default_instance() && _impl_.impact_ != nullptr;
}
inline bool IncidentData::has_impact() const {
  return _internal_has_impact();
}
inline void IncidentData::clear_impact() {
  if (GetArenaForAllocation() == nullptr && _impl_.impact_ != nullptr) {
    delete _impl_.impact_;
  }
  _impl_.impact_ = nullptr;
}
inline const ::unhinged::observability::v1::IncidentImpact& IncidentData::_internal_impact() const {
  const ::unhinged::observability::v1::IncidentImpact* p = _impl_.impact_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::observability::v1::IncidentImpact&>(
      ::unhinged::observability::v1::_IncidentImpact_default_instance_);
}
inline const ::unhinged::observability::v1::IncidentImpact& IncidentData::impact() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.IncidentData.impact)
  return _internal_impact();
}
inline void IncidentData::unsafe_arena_set_allocated_impact(
    ::unhinged::observability::v1::IncidentImpact* impact) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.impact_);
  }
  _impl_.impact_ = impact;
  if (impact) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.IncidentData.impact)
}
inline ::unhinged::observability::v1::IncidentImpact* IncidentData::release_impact() {
  
  ::unhinged::observability::v1::IncidentImpact* temp = _impl_.impact_;
  _impl_.impact_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::observability::v1::IncidentImpact* IncidentData::unsafe_arena_release_impact() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.IncidentData.impact)
  
  ::unhinged::observability::v1::IncidentImpact* temp = _impl_.impact_;
  _impl_.impact_ = nullptr;
  return temp;
}
inline ::unhinged::observability::v1::IncidentImpact* IncidentData::_internal_mutable_impact() {
  
  if (_impl_.impact_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::observability::v1::IncidentImpact>(GetArenaForAllocation());
    _impl_.impact_ = p;
  }
  return _impl_.impact_;
}
inline ::unhinged::observability::v1::IncidentImpact* IncidentData::mutable_impact() {
  ::unhinged::observability::v1::IncidentImpact* _msg = _internal_mutable_impact();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.IncidentData.impact)
  return _msg;
}
inline void IncidentData::set_allocated_impact(::unhinged::observability::v1::IncidentImpact* impact) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.impact_;
  }
  if (impact) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(impact);
    if (message_arena != submessage_arena) {
      impact = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, impact, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.impact_ = impact;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.IncidentData.impact)
}

// .unhinged.observability.v1.IncidentResolution resolution = 30;
inline bool IncidentData::_internal_has_resolution() const {
  return this != internal_default_instance() && _impl_.resolution_ != nullptr;
}
inline bool IncidentData::has_resolution() const {
  return _internal_has_resolution();
}
inline void IncidentData::clear_resolution() {
  if (GetArenaForAllocation() == nullptr && _impl_.resolution_ != nullptr) {
    delete _impl_.resolution_;
  }
  _impl_.resolution_ = nullptr;
}
inline const ::unhinged::observability::v1::IncidentResolution& IncidentData::_internal_resolution() const {
  const ::unhinged::observability::v1::IncidentResolution* p = _impl_.resolution_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::observability::v1::IncidentResolution&>(
      ::unhinged::observability::v1::_IncidentResolution_default_instance_);
}
inline const ::unhinged::observability::v1::IncidentResolution& IncidentData::resolution() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.IncidentData.resolution)
  return _internal_resolution();
}
inline void IncidentData::unsafe_arena_set_allocated_resolution(
    ::unhinged::observability::v1::IncidentResolution* resolution) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.resolution_);
  }
  _impl_.resolution_ = resolution;
  if (resolution) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.IncidentData.resolution)
}
inline ::unhinged::observability::v1::IncidentResolution* IncidentData::release_resolution() {
  
  ::unhinged::observability::v1::IncidentResolution* temp = _impl_.resolution_;
  _impl_.resolution_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::observability::v1::IncidentResolution* IncidentData::unsafe_arena_release_resolution() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.IncidentData.resolution)
  
  ::unhinged::observability::v1::IncidentResolution* temp = _impl_.resolution_;
  _impl_.resolution_ = nullptr;
  return temp;
}
inline ::unhinged::observability::v1::IncidentResolution* IncidentData::_internal_mutable_resolution() {
  
  if (_impl_.resolution_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::observability::v1::IncidentResolution>(GetArenaForAllocation());
    _impl_.resolution_ = p;
  }
  return _impl_.resolution_;
}
inline ::unhinged::observability::v1::IncidentResolution* IncidentData::mutable_resolution() {
  ::unhinged::observability::v1::IncidentResolution* _msg = _internal_mutable_resolution();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.IncidentData.resolution)
  return _msg;
}
inline void IncidentData::set_allocated_resolution(::unhinged::observability::v1::IncidentResolution* resolution) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.resolution_;
  }
  if (resolution) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(resolution);
    if (message_arena != submessage_arena) {
      resolution = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, resolution, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.resolution_ = resolution;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.IncidentData.resolution)
}

// -------------------------------------------------------------------

// IncidentUpdate

// string update_id = 1;
inline void IncidentUpdate::clear_update_id() {
  _impl_.update_id_.ClearToEmpty();
}
inline const std::string& IncidentUpdate::update_id() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.IncidentUpdate.update_id)
  return _internal_update_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IncidentUpdate::set_update_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.update_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.IncidentUpdate.update_id)
}
inline std::string* IncidentUpdate::mutable_update_id() {
  std::string* _s = _internal_mutable_update_id();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.IncidentUpdate.update_id)
  return _s;
}
inline const std::string& IncidentUpdate::_internal_update_id() const {
  return _impl_.update_id_.Get();
}
inline void IncidentUpdate::_internal_set_update_id(const std::string& value) {
  
  _impl_.update_id_.Set(value, GetArenaForAllocation());
}
inline std::string* IncidentUpdate::_internal_mutable_update_id() {
  
  return _impl_.update_id_.Mutable(GetArenaForAllocation());
}
inline std::string* IncidentUpdate::release_update_id() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.IncidentUpdate.update_id)
  return _impl_.update_id_.Release();
}
inline void IncidentUpdate::set_allocated_update_id(std::string* update_id) {
  if (update_id != nullptr) {
    
  } else {
    
  }
  _impl_.update_id_.SetAllocated(update_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.update_id_.IsDefault()) {
    _impl_.update_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.IncidentUpdate.update_id)
}

// .google.protobuf.Timestamp timestamp = 2;
inline bool IncidentUpdate::_internal_has_timestamp() const {
  return this != internal_default_instance() && _impl_.timestamp_ != nullptr;
}
inline bool IncidentUpdate::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& IncidentUpdate::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& IncidentUpdate::timestamp() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.IncidentUpdate.timestamp)
  return _internal_timestamp();
}
inline void IncidentUpdate::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.IncidentUpdate.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* IncidentUpdate::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* IncidentUpdate::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.IncidentUpdate.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* IncidentUpdate::_internal_mutable_timestamp() {
  
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* IncidentUpdate::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.IncidentUpdate.timestamp)
  return _msg;
}
inline void IncidentUpdate::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.IncidentUpdate.timestamp)
}

// .unhinged.observability.v1.IncidentStatus status = 3;
inline void IncidentUpdate::clear_status() {
  _impl_.status_ = 0;
}
inline ::unhinged::observability::v1::IncidentStatus IncidentUpdate::_internal_status() const {
  return static_cast< ::unhinged::observability::v1::IncidentStatus >(_impl_.status_);
}
inline ::unhinged::observability::v1::IncidentStatus IncidentUpdate::status() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.IncidentUpdate.status)
  return _internal_status();
}
inline void IncidentUpdate::_internal_set_status(::unhinged::observability::v1::IncidentStatus value) {
  
  _impl_.status_ = value;
}
inline void IncidentUpdate::set_status(::unhinged::observability::v1::IncidentStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.IncidentUpdate.status)
}

// string message = 4;
inline void IncidentUpdate::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& IncidentUpdate::message() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.IncidentUpdate.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IncidentUpdate::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.IncidentUpdate.message)
}
inline std::string* IncidentUpdate::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.IncidentUpdate.message)
  return _s;
}
inline const std::string& IncidentUpdate::_internal_message() const {
  return _impl_.message_.Get();
}
inline void IncidentUpdate::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* IncidentUpdate::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* IncidentUpdate::release_message() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.IncidentUpdate.message)
  return _impl_.message_.Release();
}
inline void IncidentUpdate::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.IncidentUpdate.message)
}

// string author = 5;
inline void IncidentUpdate::clear_author() {
  _impl_.author_.ClearToEmpty();
}
inline const std::string& IncidentUpdate::author() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.IncidentUpdate.author)
  return _internal_author();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IncidentUpdate::set_author(ArgT0&& arg0, ArgT... args) {
 
 _impl_.author_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.IncidentUpdate.author)
}
inline std::string* IncidentUpdate::mutable_author() {
  std::string* _s = _internal_mutable_author();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.IncidentUpdate.author)
  return _s;
}
inline const std::string& IncidentUpdate::_internal_author() const {
  return _impl_.author_.Get();
}
inline void IncidentUpdate::_internal_set_author(const std::string& value) {
  
  _impl_.author_.Set(value, GetArenaForAllocation());
}
inline std::string* IncidentUpdate::_internal_mutable_author() {
  
  return _impl_.author_.Mutable(GetArenaForAllocation());
}
inline std::string* IncidentUpdate::release_author() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.IncidentUpdate.author)
  return _impl_.author_.Release();
}
inline void IncidentUpdate::set_allocated_author(std::string* author) {
  if (author != nullptr) {
    
  } else {
    
  }
  _impl_.author_.SetAllocated(author, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.author_.IsDefault()) {
    _impl_.author_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.IncidentUpdate.author)
}

// .unhinged.observability.v1.UpdateType type = 6;
inline void IncidentUpdate::clear_type() {
  _impl_.type_ = 0;
}
inline ::unhinged::observability::v1::UpdateType IncidentUpdate::_internal_type() const {
  return static_cast< ::unhinged::observability::v1::UpdateType >(_impl_.type_);
}
inline ::unhinged::observability::v1::UpdateType IncidentUpdate::type() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.IncidentUpdate.type)
  return _internal_type();
}
inline void IncidentUpdate::_internal_set_type(::unhinged::observability::v1::UpdateType value) {
  
  _impl_.type_ = value;
}
inline void IncidentUpdate::set_type(::unhinged::observability::v1::UpdateType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.IncidentUpdate.type)
}

// -------------------------------------------------------------------

// IncidentImpact

// double availability_impact = 1;
inline void IncidentImpact::clear_availability_impact() {
  _impl_.availability_impact_ = 0;
}
inline double IncidentImpact::_internal_availability_impact() const {
  return _impl_.availability_impact_;
}
inline double IncidentImpact::availability_impact() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.IncidentImpact.availability_impact)
  return _internal_availability_impact();
}
inline void IncidentImpact::_internal_set_availability_impact(double value) {
  
  _impl_.availability_impact_ = value;
}
inline void IncidentImpact::set_availability_impact(double value) {
  _internal_set_availability_impact(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.IncidentImpact.availability_impact)
}

// double performance_impact = 2;
inline void IncidentImpact::clear_performance_impact() {
  _impl_.performance_impact_ = 0;
}
inline double IncidentImpact::_internal_performance_impact() const {
  return _impl_.performance_impact_;
}
inline double IncidentImpact::performance_impact() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.IncidentImpact.performance_impact)
  return _internal_performance_impact();
}
inline void IncidentImpact::_internal_set_performance_impact(double value) {
  
  _impl_.performance_impact_ = value;
}
inline void IncidentImpact::set_performance_impact(double value) {
  _internal_set_performance_impact(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.IncidentImpact.performance_impact)
}

// uint32 affected_users = 3;
inline void IncidentImpact::clear_affected_users() {
  _impl_.affected_users_ = 0u;
}
inline uint32_t IncidentImpact::_internal_affected_users() const {
  return _impl_.affected_users_;
}
inline uint32_t IncidentImpact::affected_users() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.IncidentImpact.affected_users)
  return _internal_affected_users();
}
inline void IncidentImpact::_internal_set_affected_users(uint32_t value) {
  
  _impl_.affected_users_ = value;
}
inline void IncidentImpact::set_affected_users(uint32_t value) {
  _internal_set_affected_users(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.IncidentImpact.affected_users)
}

// repeated string affected_regions = 4;
inline int IncidentImpact::_internal_affected_regions_size() const {
  return _impl_.affected_regions_.size();
}
inline int IncidentImpact::affected_regions_size() const {
  return _internal_affected_regions_size();
}
inline void IncidentImpact::clear_affected_regions() {
  _impl_.affected_regions_.Clear();
}
inline std::string* IncidentImpact::add_affected_regions() {
  std::string* _s = _internal_add_affected_regions();
  // @@protoc_insertion_point(field_add_mutable:unhinged.observability.v1.IncidentImpact.affected_regions)
  return _s;
}
inline const std::string& IncidentImpact::_internal_affected_regions(int index) const {
  return _impl_.affected_regions_.Get(index);
}
inline const std::string& IncidentImpact::affected_regions(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.IncidentImpact.affected_regions)
  return _internal_affected_regions(index);
}
inline std::string* IncidentImpact::mutable_affected_regions(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.IncidentImpact.affected_regions)
  return _impl_.affected_regions_.Mutable(index);
}
inline void IncidentImpact::set_affected_regions(int index, const std::string& value) {
  _impl_.affected_regions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.IncidentImpact.affected_regions)
}
inline void IncidentImpact::set_affected_regions(int index, std::string&& value) {
  _impl_.affected_regions_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.IncidentImpact.affected_regions)
}
inline void IncidentImpact::set_affected_regions(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.affected_regions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.observability.v1.IncidentImpact.affected_regions)
}
inline void IncidentImpact::set_affected_regions(int index, const char* value, size_t size) {
  _impl_.affected_regions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.observability.v1.IncidentImpact.affected_regions)
}
inline std::string* IncidentImpact::_internal_add_affected_regions() {
  return _impl_.affected_regions_.Add();
}
inline void IncidentImpact::add_affected_regions(const std::string& value) {
  _impl_.affected_regions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.observability.v1.IncidentImpact.affected_regions)
}
inline void IncidentImpact::add_affected_regions(std::string&& value) {
  _impl_.affected_regions_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.observability.v1.IncidentImpact.affected_regions)
}
inline void IncidentImpact::add_affected_regions(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.affected_regions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.observability.v1.IncidentImpact.affected_regions)
}
inline void IncidentImpact::add_affected_regions(const char* value, size_t size) {
  _impl_.affected_regions_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.observability.v1.IncidentImpact.affected_regions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
IncidentImpact::affected_regions() const {
  // @@protoc_insertion_point(field_list:unhinged.observability.v1.IncidentImpact.affected_regions)
  return _impl_.affected_regions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
IncidentImpact::mutable_affected_regions() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.observability.v1.IncidentImpact.affected_regions)
  return &_impl_.affected_regions_;
}

// string business_impact = 5;
inline void IncidentImpact::clear_business_impact() {
  _impl_.business_impact_.ClearToEmpty();
}
inline const std::string& IncidentImpact::business_impact() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.IncidentImpact.business_impact)
  return _internal_business_impact();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IncidentImpact::set_business_impact(ArgT0&& arg0, ArgT... args) {
 
 _impl_.business_impact_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.IncidentImpact.business_impact)
}
inline std::string* IncidentImpact::mutable_business_impact() {
  std::string* _s = _internal_mutable_business_impact();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.IncidentImpact.business_impact)
  return _s;
}
inline const std::string& IncidentImpact::_internal_business_impact() const {
  return _impl_.business_impact_.Get();
}
inline void IncidentImpact::_internal_set_business_impact(const std::string& value) {
  
  _impl_.business_impact_.Set(value, GetArenaForAllocation());
}
inline std::string* IncidentImpact::_internal_mutable_business_impact() {
  
  return _impl_.business_impact_.Mutable(GetArenaForAllocation());
}
inline std::string* IncidentImpact::release_business_impact() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.IncidentImpact.business_impact)
  return _impl_.business_impact_.Release();
}
inline void IncidentImpact::set_allocated_business_impact(std::string* business_impact) {
  if (business_impact != nullptr) {
    
  } else {
    
  }
  _impl_.business_impact_.SetAllocated(business_impact, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.business_impact_.IsDefault()) {
    _impl_.business_impact_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.IncidentImpact.business_impact)
}

// -------------------------------------------------------------------

// IncidentResolution

// string root_cause = 1;
inline void IncidentResolution::clear_root_cause() {
  _impl_.root_cause_.ClearToEmpty();
}
inline const std::string& IncidentResolution::root_cause() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.IncidentResolution.root_cause)
  return _internal_root_cause();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IncidentResolution::set_root_cause(ArgT0&& arg0, ArgT... args) {
 
 _impl_.root_cause_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.IncidentResolution.root_cause)
}
inline std::string* IncidentResolution::mutable_root_cause() {
  std::string* _s = _internal_mutable_root_cause();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.IncidentResolution.root_cause)
  return _s;
}
inline const std::string& IncidentResolution::_internal_root_cause() const {
  return _impl_.root_cause_.Get();
}
inline void IncidentResolution::_internal_set_root_cause(const std::string& value) {
  
  _impl_.root_cause_.Set(value, GetArenaForAllocation());
}
inline std::string* IncidentResolution::_internal_mutable_root_cause() {
  
  return _impl_.root_cause_.Mutable(GetArenaForAllocation());
}
inline std::string* IncidentResolution::release_root_cause() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.IncidentResolution.root_cause)
  return _impl_.root_cause_.Release();
}
inline void IncidentResolution::set_allocated_root_cause(std::string* root_cause) {
  if (root_cause != nullptr) {
    
  } else {
    
  }
  _impl_.root_cause_.SetAllocated(root_cause, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.root_cause_.IsDefault()) {
    _impl_.root_cause_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.IncidentResolution.root_cause)
}

// string resolution_steps = 2;
inline void IncidentResolution::clear_resolution_steps() {
  _impl_.resolution_steps_.ClearToEmpty();
}
inline const std::string& IncidentResolution::resolution_steps() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.IncidentResolution.resolution_steps)
  return _internal_resolution_steps();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IncidentResolution::set_resolution_steps(ArgT0&& arg0, ArgT... args) {
 
 _impl_.resolution_steps_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.IncidentResolution.resolution_steps)
}
inline std::string* IncidentResolution::mutable_resolution_steps() {
  std::string* _s = _internal_mutable_resolution_steps();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.IncidentResolution.resolution_steps)
  return _s;
}
inline const std::string& IncidentResolution::_internal_resolution_steps() const {
  return _impl_.resolution_steps_.Get();
}
inline void IncidentResolution::_internal_set_resolution_steps(const std::string& value) {
  
  _impl_.resolution_steps_.Set(value, GetArenaForAllocation());
}
inline std::string* IncidentResolution::_internal_mutable_resolution_steps() {
  
  return _impl_.resolution_steps_.Mutable(GetArenaForAllocation());
}
inline std::string* IncidentResolution::release_resolution_steps() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.IncidentResolution.resolution_steps)
  return _impl_.resolution_steps_.Release();
}
inline void IncidentResolution::set_allocated_resolution_steps(std::string* resolution_steps) {
  if (resolution_steps != nullptr) {
    
  } else {
    
  }
  _impl_.resolution_steps_.SetAllocated(resolution_steps, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.resolution_steps_.IsDefault()) {
    _impl_.resolution_steps_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.IncidentResolution.resolution_steps)
}

// string prevention_measures = 3;
inline void IncidentResolution::clear_prevention_measures() {
  _impl_.prevention_measures_.ClearToEmpty();
}
inline const std::string& IncidentResolution::prevention_measures() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.IncidentResolution.prevention_measures)
  return _internal_prevention_measures();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IncidentResolution::set_prevention_measures(ArgT0&& arg0, ArgT... args) {
 
 _impl_.prevention_measures_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.IncidentResolution.prevention_measures)
}
inline std::string* IncidentResolution::mutable_prevention_measures() {
  std::string* _s = _internal_mutable_prevention_measures();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.IncidentResolution.prevention_measures)
  return _s;
}
inline const std::string& IncidentResolution::_internal_prevention_measures() const {
  return _impl_.prevention_measures_.Get();
}
inline void IncidentResolution::_internal_set_prevention_measures(const std::string& value) {
  
  _impl_.prevention_measures_.Set(value, GetArenaForAllocation());
}
inline std::string* IncidentResolution::_internal_mutable_prevention_measures() {
  
  return _impl_.prevention_measures_.Mutable(GetArenaForAllocation());
}
inline std::string* IncidentResolution::release_prevention_measures() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.IncidentResolution.prevention_measures)
  return _impl_.prevention_measures_.Release();
}
inline void IncidentResolution::set_allocated_prevention_measures(std::string* prevention_measures) {
  if (prevention_measures != nullptr) {
    
  } else {
    
  }
  _impl_.prevention_measures_.SetAllocated(prevention_measures, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.prevention_measures_.IsDefault()) {
    _impl_.prevention_measures_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.IncidentResolution.prevention_measures)
}

// repeated string lessons_learned = 4;
inline int IncidentResolution::_internal_lessons_learned_size() const {
  return _impl_.lessons_learned_.size();
}
inline int IncidentResolution::lessons_learned_size() const {
  return _internal_lessons_learned_size();
}
inline void IncidentResolution::clear_lessons_learned() {
  _impl_.lessons_learned_.Clear();
}
inline std::string* IncidentResolution::add_lessons_learned() {
  std::string* _s = _internal_add_lessons_learned();
  // @@protoc_insertion_point(field_add_mutable:unhinged.observability.v1.IncidentResolution.lessons_learned)
  return _s;
}
inline const std::string& IncidentResolution::_internal_lessons_learned(int index) const {
  return _impl_.lessons_learned_.Get(index);
}
inline const std::string& IncidentResolution::lessons_learned(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.IncidentResolution.lessons_learned)
  return _internal_lessons_learned(index);
}
inline std::string* IncidentResolution::mutable_lessons_learned(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.IncidentResolution.lessons_learned)
  return _impl_.lessons_learned_.Mutable(index);
}
inline void IncidentResolution::set_lessons_learned(int index, const std::string& value) {
  _impl_.lessons_learned_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.IncidentResolution.lessons_learned)
}
inline void IncidentResolution::set_lessons_learned(int index, std::string&& value) {
  _impl_.lessons_learned_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.IncidentResolution.lessons_learned)
}
inline void IncidentResolution::set_lessons_learned(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.lessons_learned_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.observability.v1.IncidentResolution.lessons_learned)
}
inline void IncidentResolution::set_lessons_learned(int index, const char* value, size_t size) {
  _impl_.lessons_learned_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.observability.v1.IncidentResolution.lessons_learned)
}
inline std::string* IncidentResolution::_internal_add_lessons_learned() {
  return _impl_.lessons_learned_.Add();
}
inline void IncidentResolution::add_lessons_learned(const std::string& value) {
  _impl_.lessons_learned_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.observability.v1.IncidentResolution.lessons_learned)
}
inline void IncidentResolution::add_lessons_learned(std::string&& value) {
  _impl_.lessons_learned_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.observability.v1.IncidentResolution.lessons_learned)
}
inline void IncidentResolution::add_lessons_learned(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.lessons_learned_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.observability.v1.IncidentResolution.lessons_learned)
}
inline void IncidentResolution::add_lessons_learned(const char* value, size_t size) {
  _impl_.lessons_learned_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.observability.v1.IncidentResolution.lessons_learned)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
IncidentResolution::lessons_learned() const {
  // @@protoc_insertion_point(field_list:unhinged.observability.v1.IncidentResolution.lessons_learned)
  return _impl_.lessons_learned_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
IncidentResolution::mutable_lessons_learned() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.observability.v1.IncidentResolution.lessons_learned)
  return &_impl_.lessons_learned_;
}

// string postmortem_url = 5;
inline void IncidentResolution::clear_postmortem_url() {
  _impl_.postmortem_url_.ClearToEmpty();
}
inline const std::string& IncidentResolution::postmortem_url() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.IncidentResolution.postmortem_url)
  return _internal_postmortem_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IncidentResolution::set_postmortem_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.postmortem_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.IncidentResolution.postmortem_url)
}
inline std::string* IncidentResolution::mutable_postmortem_url() {
  std::string* _s = _internal_mutable_postmortem_url();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.IncidentResolution.postmortem_url)
  return _s;
}
inline const std::string& IncidentResolution::_internal_postmortem_url() const {
  return _impl_.postmortem_url_.Get();
}
inline void IncidentResolution::_internal_set_postmortem_url(const std::string& value) {
  
  _impl_.postmortem_url_.Set(value, GetArenaForAllocation());
}
inline std::string* IncidentResolution::_internal_mutable_postmortem_url() {
  
  return _impl_.postmortem_url_.Mutable(GetArenaForAllocation());
}
inline std::string* IncidentResolution::release_postmortem_url() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.IncidentResolution.postmortem_url)
  return _impl_.postmortem_url_.Release();
}
inline void IncidentResolution::set_allocated_postmortem_url(std::string* postmortem_url) {
  if (postmortem_url != nullptr) {
    
  } else {
    
  }
  _impl_.postmortem_url_.SetAllocated(postmortem_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.postmortem_url_.IsDefault()) {
    _impl_.postmortem_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.IncidentResolution.postmortem_url)
}

// -------------------------------------------------------------------

// IngestResponse

// bool success = 1;
inline void IngestResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool IngestResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool IngestResponse::success() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.IngestResponse.success)
  return _internal_success();
}
inline void IngestResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void IngestResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.IngestResponse.success)
}

// string message = 2;
inline void IngestResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& IngestResponse::message() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.IngestResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IngestResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.IngestResponse.message)
}
inline std::string* IngestResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.IngestResponse.message)
  return _s;
}
inline const std::string& IngestResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void IngestResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* IngestResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* IngestResponse::release_message() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.IngestResponse.message)
  return _impl_.message_.Release();
}
inline void IngestResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.IngestResponse.message)
}

// uint32 processed_count = 3;
inline void IngestResponse::clear_processed_count() {
  _impl_.processed_count_ = 0u;
}
inline uint32_t IngestResponse::_internal_processed_count() const {
  return _impl_.processed_count_;
}
inline uint32_t IngestResponse::processed_count() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.IngestResponse.processed_count)
  return _internal_processed_count();
}
inline void IngestResponse::_internal_set_processed_count(uint32_t value) {
  
  _impl_.processed_count_ = value;
}
inline void IngestResponse::set_processed_count(uint32_t value) {
  _internal_set_processed_count(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.IngestResponse.processed_count)
}

// uint32 failed_count = 4;
inline void IngestResponse::clear_failed_count() {
  _impl_.failed_count_ = 0u;
}
inline uint32_t IngestResponse::_internal_failed_count() const {
  return _impl_.failed_count_;
}
inline uint32_t IngestResponse::failed_count() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.IngestResponse.failed_count)
  return _internal_failed_count();
}
inline void IngestResponse::_internal_set_failed_count(uint32_t value) {
  
  _impl_.failed_count_ = value;
}
inline void IngestResponse::set_failed_count(uint32_t value) {
  _internal_set_failed_count(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.IngestResponse.failed_count)
}

// -------------------------------------------------------------------

// HealthResponse

// bool success = 1;
inline void HealthResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool HealthResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool HealthResponse::success() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.HealthResponse.success)
  return _internal_success();
}
inline void HealthResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void HealthResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.HealthResponse.success)
}

// string message = 2;
inline void HealthResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& HealthResponse::message() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.HealthResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HealthResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.HealthResponse.message)
}
inline std::string* HealthResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.HealthResponse.message)
  return _s;
}
inline const std::string& HealthResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void HealthResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* HealthResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* HealthResponse::release_message() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.HealthResponse.message)
  return _impl_.message_.Release();
}
inline void HealthResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.HealthResponse.message)
}

// .google.protobuf.Timestamp next_check = 3;
inline bool HealthResponse::_internal_has_next_check() const {
  return this != internal_default_instance() && _impl_.next_check_ != nullptr;
}
inline bool HealthResponse::has_next_check() const {
  return _internal_has_next_check();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& HealthResponse::_internal_next_check() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.next_check_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& HealthResponse::next_check() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.HealthResponse.next_check)
  return _internal_next_check();
}
inline void HealthResponse::unsafe_arena_set_allocated_next_check(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* next_check) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.next_check_);
  }
  _impl_.next_check_ = next_check;
  if (next_check) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.HealthResponse.next_check)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* HealthResponse::release_next_check() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.next_check_;
  _impl_.next_check_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* HealthResponse::unsafe_arena_release_next_check() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.HealthResponse.next_check)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.next_check_;
  _impl_.next_check_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* HealthResponse::_internal_mutable_next_check() {
  
  if (_impl_.next_check_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.next_check_ = p;
  }
  return _impl_.next_check_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* HealthResponse::mutable_next_check() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_next_check();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.HealthResponse.next_check)
  return _msg;
}
inline void HealthResponse::set_allocated_next_check(::PROTOBUF_NAMESPACE_ID::Timestamp* next_check) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.next_check_);
  }
  if (next_check) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(next_check));
    if (message_arena != submessage_arena) {
      next_check = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, next_check, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.next_check_ = next_check;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.HealthResponse.next_check)
}

// -------------------------------------------------------------------

// IncidentResponse

// bool success = 1;
inline void IncidentResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool IncidentResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool IncidentResponse::success() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.IncidentResponse.success)
  return _internal_success();
}
inline void IncidentResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void IncidentResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.IncidentResponse.success)
}

// string message = 2;
inline void IncidentResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& IncidentResponse::message() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.IncidentResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IncidentResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.IncidentResponse.message)
}
inline std::string* IncidentResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.IncidentResponse.message)
  return _s;
}
inline const std::string& IncidentResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void IncidentResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* IncidentResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* IncidentResponse::release_message() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.IncidentResponse.message)
  return _impl_.message_.Release();
}
inline void IncidentResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.IncidentResponse.message)
}

// string incident_id = 3;
inline void IncidentResponse::clear_incident_id() {
  _impl_.incident_id_.ClearToEmpty();
}
inline const std::string& IncidentResponse::incident_id() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.IncidentResponse.incident_id)
  return _internal_incident_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IncidentResponse::set_incident_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.incident_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.IncidentResponse.incident_id)
}
inline std::string* IncidentResponse::mutable_incident_id() {
  std::string* _s = _internal_mutable_incident_id();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.IncidentResponse.incident_id)
  return _s;
}
inline const std::string& IncidentResponse::_internal_incident_id() const {
  return _impl_.incident_id_.Get();
}
inline void IncidentResponse::_internal_set_incident_id(const std::string& value) {
  
  _impl_.incident_id_.Set(value, GetArenaForAllocation());
}
inline std::string* IncidentResponse::_internal_mutable_incident_id() {
  
  return _impl_.incident_id_.Mutable(GetArenaForAllocation());
}
inline std::string* IncidentResponse::release_incident_id() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.IncidentResponse.incident_id)
  return _impl_.incident_id_.Release();
}
inline void IncidentResponse::set_allocated_incident_id(std::string* incident_id) {
  if (incident_id != nullptr) {
    
  } else {
    
  }
  _impl_.incident_id_.SetAllocated(incident_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.incident_id_.IsDefault()) {
    _impl_.incident_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.IncidentResponse.incident_id)
}

// -------------------------------------------------------------------

// HealthQuery

// repeated string service_names = 1;
inline int HealthQuery::_internal_service_names_size() const {
  return _impl_.service_names_.size();
}
inline int HealthQuery::service_names_size() const {
  return _internal_service_names_size();
}
inline void HealthQuery::clear_service_names() {
  _impl_.service_names_.Clear();
}
inline std::string* HealthQuery::add_service_names() {
  std::string* _s = _internal_add_service_names();
  // @@protoc_insertion_point(field_add_mutable:unhinged.observability.v1.HealthQuery.service_names)
  return _s;
}
inline const std::string& HealthQuery::_internal_service_names(int index) const {
  return _impl_.service_names_.Get(index);
}
inline const std::string& HealthQuery::service_names(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.HealthQuery.service_names)
  return _internal_service_names(index);
}
inline std::string* HealthQuery::mutable_service_names(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.HealthQuery.service_names)
  return _impl_.service_names_.Mutable(index);
}
inline void HealthQuery::set_service_names(int index, const std::string& value) {
  _impl_.service_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.HealthQuery.service_names)
}
inline void HealthQuery::set_service_names(int index, std::string&& value) {
  _impl_.service_names_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.HealthQuery.service_names)
}
inline void HealthQuery::set_service_names(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.service_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.observability.v1.HealthQuery.service_names)
}
inline void HealthQuery::set_service_names(int index, const char* value, size_t size) {
  _impl_.service_names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.observability.v1.HealthQuery.service_names)
}
inline std::string* HealthQuery::_internal_add_service_names() {
  return _impl_.service_names_.Add();
}
inline void HealthQuery::add_service_names(const std::string& value) {
  _impl_.service_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.observability.v1.HealthQuery.service_names)
}
inline void HealthQuery::add_service_names(std::string&& value) {
  _impl_.service_names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.observability.v1.HealthQuery.service_names)
}
inline void HealthQuery::add_service_names(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.service_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.observability.v1.HealthQuery.service_names)
}
inline void HealthQuery::add_service_names(const char* value, size_t size) {
  _impl_.service_names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.observability.v1.HealthQuery.service_names)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
HealthQuery::service_names() const {
  // @@protoc_insertion_point(field_list:unhinged.observability.v1.HealthQuery.service_names)
  return _impl_.service_names_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
HealthQuery::mutable_service_names() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.observability.v1.HealthQuery.service_names)
  return &_impl_.service_names_;
}

// .google.protobuf.Timestamp since = 2;
inline bool HealthQuery::_internal_has_since() const {
  return this != internal_default_instance() && _impl_.since_ != nullptr;
}
inline bool HealthQuery::has_since() const {
  return _internal_has_since();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& HealthQuery::_internal_since() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.since_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& HealthQuery::since() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.HealthQuery.since)
  return _internal_since();
}
inline void HealthQuery::unsafe_arena_set_allocated_since(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* since) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.since_);
  }
  _impl_.since_ = since;
  if (since) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.HealthQuery.since)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* HealthQuery::release_since() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.since_;
  _impl_.since_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* HealthQuery::unsafe_arena_release_since() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.HealthQuery.since)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.since_;
  _impl_.since_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* HealthQuery::_internal_mutable_since() {
  
  if (_impl_.since_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.since_ = p;
  }
  return _impl_.since_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* HealthQuery::mutable_since() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_since();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.HealthQuery.since)
  return _msg;
}
inline void HealthQuery::set_allocated_since(::PROTOBUF_NAMESPACE_ID::Timestamp* since) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.since_);
  }
  if (since) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(since));
    if (message_arena != submessage_arena) {
      since = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, since, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.since_ = since;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.HealthQuery.since)
}

// -------------------------------------------------------------------

// HealthQueryResponse

// repeated .unhinged.observability.v1.ServiceHealth services = 1;
inline int HealthQueryResponse::_internal_services_size() const {
  return _impl_.services_.size();
}
inline int HealthQueryResponse::services_size() const {
  return _internal_services_size();
}
inline void HealthQueryResponse::clear_services() {
  _impl_.services_.Clear();
}
inline ::unhinged::observability::v1::ServiceHealth* HealthQueryResponse::mutable_services(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.HealthQueryResponse.services)
  return _impl_.services_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::ServiceHealth >*
HealthQueryResponse::mutable_services() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.observability.v1.HealthQueryResponse.services)
  return &_impl_.services_;
}
inline const ::unhinged::observability::v1::ServiceHealth& HealthQueryResponse::_internal_services(int index) const {
  return _impl_.services_.Get(index);
}
inline const ::unhinged::observability::v1::ServiceHealth& HealthQueryResponse::services(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.HealthQueryResponse.services)
  return _internal_services(index);
}
inline ::unhinged::observability::v1::ServiceHealth* HealthQueryResponse::_internal_add_services() {
  return _impl_.services_.Add();
}
inline ::unhinged::observability::v1::ServiceHealth* HealthQueryResponse::add_services() {
  ::unhinged::observability::v1::ServiceHealth* _add = _internal_add_services();
  // @@protoc_insertion_point(field_add:unhinged.observability.v1.HealthQueryResponse.services)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::ServiceHealth >&
HealthQueryResponse::services() const {
  // @@protoc_insertion_point(field_list:unhinged.observability.v1.HealthQueryResponse.services)
  return _impl_.services_;
}

// -------------------------------------------------------------------

// IncidentQuery

// repeated .unhinged.observability.v1.IncidentStatus statuses = 1;
inline int IncidentQuery::_internal_statuses_size() const {
  return _impl_.statuses_.size();
}
inline int IncidentQuery::statuses_size() const {
  return _internal_statuses_size();
}
inline void IncidentQuery::clear_statuses() {
  _impl_.statuses_.Clear();
}
inline ::unhinged::observability::v1::IncidentStatus IncidentQuery::_internal_statuses(int index) const {
  return static_cast< ::unhinged::observability::v1::IncidentStatus >(_impl_.statuses_.Get(index));
}
inline ::unhinged::observability::v1::IncidentStatus IncidentQuery::statuses(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.IncidentQuery.statuses)
  return _internal_statuses(index);
}
inline void IncidentQuery::set_statuses(int index, ::unhinged::observability::v1::IncidentStatus value) {
  _impl_.statuses_.Set(index, value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.IncidentQuery.statuses)
}
inline void IncidentQuery::_internal_add_statuses(::unhinged::observability::v1::IncidentStatus value) {
  _impl_.statuses_.Add(value);
}
inline void IncidentQuery::add_statuses(::unhinged::observability::v1::IncidentStatus value) {
  _internal_add_statuses(value);
  // @@protoc_insertion_point(field_add:unhinged.observability.v1.IncidentQuery.statuses)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
IncidentQuery::statuses() const {
  // @@protoc_insertion_point(field_list:unhinged.observability.v1.IncidentQuery.statuses)
  return _impl_.statuses_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
IncidentQuery::_internal_mutable_statuses() {
  return &_impl_.statuses_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
IncidentQuery::mutable_statuses() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.observability.v1.IncidentQuery.statuses)
  return _internal_mutable_statuses();
}

// repeated .unhinged.observability.v1.IncidentSeverity severities = 2;
inline int IncidentQuery::_internal_severities_size() const {
  return _impl_.severities_.size();
}
inline int IncidentQuery::severities_size() const {
  return _internal_severities_size();
}
inline void IncidentQuery::clear_severities() {
  _impl_.severities_.Clear();
}
inline ::unhinged::observability::v1::IncidentSeverity IncidentQuery::_internal_severities(int index) const {
  return static_cast< ::unhinged::observability::v1::IncidentSeverity >(_impl_.severities_.Get(index));
}
inline ::unhinged::observability::v1::IncidentSeverity IncidentQuery::severities(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.IncidentQuery.severities)
  return _internal_severities(index);
}
inline void IncidentQuery::set_severities(int index, ::unhinged::observability::v1::IncidentSeverity value) {
  _impl_.severities_.Set(index, value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.IncidentQuery.severities)
}
inline void IncidentQuery::_internal_add_severities(::unhinged::observability::v1::IncidentSeverity value) {
  _impl_.severities_.Add(value);
}
inline void IncidentQuery::add_severities(::unhinged::observability::v1::IncidentSeverity value) {
  _internal_add_severities(value);
  // @@protoc_insertion_point(field_add:unhinged.observability.v1.IncidentQuery.severities)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
IncidentQuery::severities() const {
  // @@protoc_insertion_point(field_list:unhinged.observability.v1.IncidentQuery.severities)
  return _impl_.severities_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
IncidentQuery::_internal_mutable_severities() {
  return &_impl_.severities_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
IncidentQuery::mutable_severities() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.observability.v1.IncidentQuery.severities)
  return _internal_mutable_severities();
}

// .google.protobuf.Timestamp since = 3;
inline bool IncidentQuery::_internal_has_since() const {
  return this != internal_default_instance() && _impl_.since_ != nullptr;
}
inline bool IncidentQuery::has_since() const {
  return _internal_has_since();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& IncidentQuery::_internal_since() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.since_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& IncidentQuery::since() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.IncidentQuery.since)
  return _internal_since();
}
inline void IncidentQuery::unsafe_arena_set_allocated_since(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* since) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.since_);
  }
  _impl_.since_ = since;
  if (since) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.IncidentQuery.since)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* IncidentQuery::release_since() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.since_;
  _impl_.since_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* IncidentQuery::unsafe_arena_release_since() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.IncidentQuery.since)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.since_;
  _impl_.since_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* IncidentQuery::_internal_mutable_since() {
  
  if (_impl_.since_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.since_ = p;
  }
  return _impl_.since_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* IncidentQuery::mutable_since() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_since();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.IncidentQuery.since)
  return _msg;
}
inline void IncidentQuery::set_allocated_since(::PROTOBUF_NAMESPACE_ID::Timestamp* since) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.since_);
  }
  if (since) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(since));
    if (message_arena != submessage_arena) {
      since = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, since, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.since_ = since;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.IncidentQuery.since)
}

// -------------------------------------------------------------------

// IncidentQueryResponse

// repeated .unhinged.observability.v1.IncidentData incidents = 1;
inline int IncidentQueryResponse::_internal_incidents_size() const {
  return _impl_.incidents_.size();
}
inline int IncidentQueryResponse::incidents_size() const {
  return _internal_incidents_size();
}
inline void IncidentQueryResponse::clear_incidents() {
  _impl_.incidents_.Clear();
}
inline ::unhinged::observability::v1::IncidentData* IncidentQueryResponse::mutable_incidents(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.IncidentQueryResponse.incidents)
  return _impl_.incidents_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::IncidentData >*
IncidentQueryResponse::mutable_incidents() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.observability.v1.IncidentQueryResponse.incidents)
  return &_impl_.incidents_;
}
inline const ::unhinged::observability::v1::IncidentData& IncidentQueryResponse::_internal_incidents(int index) const {
  return _impl_.incidents_.Get(index);
}
inline const ::unhinged::observability::v1::IncidentData& IncidentQueryResponse::incidents(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.IncidentQueryResponse.incidents)
  return _internal_incidents(index);
}
inline ::unhinged::observability::v1::IncidentData* IncidentQueryResponse::_internal_add_incidents() {
  return _impl_.incidents_.Add();
}
inline ::unhinged::observability::v1::IncidentData* IncidentQueryResponse::add_incidents() {
  ::unhinged::observability::v1::IncidentData* _add = _internal_add_incidents();
  // @@protoc_insertion_point(field_add:unhinged.observability.v1.IncidentQueryResponse.incidents)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::IncidentData >&
IncidentQueryResponse::incidents() const {
  // @@protoc_insertion_point(field_list:unhinged.observability.v1.IncidentQueryResponse.incidents)
  return _impl_.incidents_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// MetricQuery

// string metric_name = 1;
inline void MetricQuery::clear_metric_name() {
  _impl_.metric_name_.ClearToEmpty();
}
inline const std::string& MetricQuery::metric_name() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.MetricQuery.metric_name)
  return _internal_metric_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MetricQuery::set_metric_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.metric_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.MetricQuery.metric_name)
}
inline std::string* MetricQuery::mutable_metric_name() {
  std::string* _s = _internal_mutable_metric_name();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.MetricQuery.metric_name)
  return _s;
}
inline const std::string& MetricQuery::_internal_metric_name() const {
  return _impl_.metric_name_.Get();
}
inline void MetricQuery::_internal_set_metric_name(const std::string& value) {
  
  _impl_.metric_name_.Set(value, GetArenaForAllocation());
}
inline std::string* MetricQuery::_internal_mutable_metric_name() {
  
  return _impl_.metric_name_.Mutable(GetArenaForAllocation());
}
inline std::string* MetricQuery::release_metric_name() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.MetricQuery.metric_name)
  return _impl_.metric_name_.Release();
}
inline void MetricQuery::set_allocated_metric_name(std::string* metric_name) {
  if (metric_name != nullptr) {
    
  } else {
    
  }
  _impl_.metric_name_.SetAllocated(metric_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.metric_name_.IsDefault()) {
    _impl_.metric_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.MetricQuery.metric_name)
}

// map<string, string> labels = 2;
inline int MetricQuery::_internal_labels_size() const {
  return _impl_.labels_.size();
}
inline int MetricQuery::labels_size() const {
  return _internal_labels_size();
}
inline void MetricQuery::clear_labels() {
  _impl_.labels_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
MetricQuery::_internal_labels() const {
  return _impl_.labels_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
MetricQuery::labels() const {
  // @@protoc_insertion_point(field_map:unhinged.observability.v1.MetricQuery.labels)
  return _internal_labels();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
MetricQuery::_internal_mutable_labels() {
  return _impl_.labels_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
MetricQuery::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_map:unhinged.observability.v1.MetricQuery.labels)
  return _internal_mutable_labels();
}

// .google.protobuf.Timestamp start_time = 3;
inline bool MetricQuery::_internal_has_start_time() const {
  return this != internal_default_instance() && _impl_.start_time_ != nullptr;
}
inline bool MetricQuery::has_start_time() const {
  return _internal_has_start_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& MetricQuery::_internal_start_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.start_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& MetricQuery::start_time() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.MetricQuery.start_time)
  return _internal_start_time();
}
inline void MetricQuery::unsafe_arena_set_allocated_start_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_time_);
  }
  _impl_.start_time_ = start_time;
  if (start_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.MetricQuery.start_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* MetricQuery::release_start_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.start_time_;
  _impl_.start_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* MetricQuery::unsafe_arena_release_start_time() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.MetricQuery.start_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.start_time_;
  _impl_.start_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* MetricQuery::_internal_mutable_start_time() {
  
  if (_impl_.start_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.start_time_ = p;
  }
  return _impl_.start_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* MetricQuery::mutable_start_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_start_time();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.MetricQuery.start_time)
  return _msg;
}
inline void MetricQuery::set_allocated_start_time(::PROTOBUF_NAMESPACE_ID::Timestamp* start_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_time_);
  }
  if (start_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_time));
    if (message_arena != submessage_arena) {
      start_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.start_time_ = start_time;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.MetricQuery.start_time)
}

// .google.protobuf.Timestamp end_time = 4;
inline bool MetricQuery::_internal_has_end_time() const {
  return this != internal_default_instance() && _impl_.end_time_ != nullptr;
}
inline bool MetricQuery::has_end_time() const {
  return _internal_has_end_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& MetricQuery::_internal_end_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.end_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& MetricQuery::end_time() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.MetricQuery.end_time)
  return _internal_end_time();
}
inline void MetricQuery::unsafe_arena_set_allocated_end_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_time_);
  }
  _impl_.end_time_ = end_time;
  if (end_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.MetricQuery.end_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* MetricQuery::release_end_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.end_time_;
  _impl_.end_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* MetricQuery::unsafe_arena_release_end_time() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.MetricQuery.end_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.end_time_;
  _impl_.end_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* MetricQuery::_internal_mutable_end_time() {
  
  if (_impl_.end_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.end_time_ = p;
  }
  return _impl_.end_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* MetricQuery::mutable_end_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_end_time();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.MetricQuery.end_time)
  return _msg;
}
inline void MetricQuery::set_allocated_end_time(::PROTOBUF_NAMESPACE_ID::Timestamp* end_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_time_);
  }
  if (end_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_time));
    if (message_arena != submessage_arena) {
      end_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.end_time_ = end_time;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.MetricQuery.end_time)
}

// -------------------------------------------------------------------

// MetricQueryResponse

// repeated .unhinged.observability.v1.MetricData metrics = 1;
inline int MetricQueryResponse::_internal_metrics_size() const {
  return _impl_.metrics_.size();
}
inline int MetricQueryResponse::metrics_size() const {
  return _internal_metrics_size();
}
inline void MetricQueryResponse::clear_metrics() {
  _impl_.metrics_.Clear();
}
inline ::unhinged::observability::v1::MetricData* MetricQueryResponse::mutable_metrics(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.MetricQueryResponse.metrics)
  return _impl_.metrics_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::MetricData >*
MetricQueryResponse::mutable_metrics() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.observability.v1.MetricQueryResponse.metrics)
  return &_impl_.metrics_;
}
inline const ::unhinged::observability::v1::MetricData& MetricQueryResponse::_internal_metrics(int index) const {
  return _impl_.metrics_.Get(index);
}
inline const ::unhinged::observability::v1::MetricData& MetricQueryResponse::metrics(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.MetricQueryResponse.metrics)
  return _internal_metrics(index);
}
inline ::unhinged::observability::v1::MetricData* MetricQueryResponse::_internal_add_metrics() {
  return _impl_.metrics_.Add();
}
inline ::unhinged::observability::v1::MetricData* MetricQueryResponse::add_metrics() {
  ::unhinged::observability::v1::MetricData* _add = _internal_add_metrics();
  // @@protoc_insertion_point(field_add:unhinged.observability.v1.MetricQueryResponse.metrics)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::MetricData >&
MetricQueryResponse::metrics() const {
  // @@protoc_insertion_point(field_list:unhinged.observability.v1.MetricQueryResponse.metrics)
  return _impl_.metrics_;
}

// -------------------------------------------------------------------

// TraceQuery

// string trace_id = 1;
inline void TraceQuery::clear_trace_id() {
  _impl_.trace_id_.ClearToEmpty();
}
inline const std::string& TraceQuery::trace_id() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.TraceQuery.trace_id)
  return _internal_trace_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TraceQuery::set_trace_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.trace_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.TraceQuery.trace_id)
}
inline std::string* TraceQuery::mutable_trace_id() {
  std::string* _s = _internal_mutable_trace_id();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.TraceQuery.trace_id)
  return _s;
}
inline const std::string& TraceQuery::_internal_trace_id() const {
  return _impl_.trace_id_.Get();
}
inline void TraceQuery::_internal_set_trace_id(const std::string& value) {
  
  _impl_.trace_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TraceQuery::_internal_mutable_trace_id() {
  
  return _impl_.trace_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TraceQuery::release_trace_id() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.TraceQuery.trace_id)
  return _impl_.trace_id_.Release();
}
inline void TraceQuery::set_allocated_trace_id(std::string* trace_id) {
  if (trace_id != nullptr) {
    
  } else {
    
  }
  _impl_.trace_id_.SetAllocated(trace_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.trace_id_.IsDefault()) {
    _impl_.trace_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.TraceQuery.trace_id)
}

// string service_name = 2;
inline void TraceQuery::clear_service_name() {
  _impl_.service_name_.ClearToEmpty();
}
inline const std::string& TraceQuery::service_name() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.TraceQuery.service_name)
  return _internal_service_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TraceQuery::set_service_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.TraceQuery.service_name)
}
inline std::string* TraceQuery::mutable_service_name() {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.TraceQuery.service_name)
  return _s;
}
inline const std::string& TraceQuery::_internal_service_name() const {
  return _impl_.service_name_.Get();
}
inline void TraceQuery::_internal_set_service_name(const std::string& value) {
  
  _impl_.service_name_.Set(value, GetArenaForAllocation());
}
inline std::string* TraceQuery::_internal_mutable_service_name() {
  
  return _impl_.service_name_.Mutable(GetArenaForAllocation());
}
inline std::string* TraceQuery::release_service_name() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.TraceQuery.service_name)
  return _impl_.service_name_.Release();
}
inline void TraceQuery::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  _impl_.service_name_.SetAllocated(service_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_name_.IsDefault()) {
    _impl_.service_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.TraceQuery.service_name)
}

// .google.protobuf.Timestamp start_time = 3;
inline bool TraceQuery::_internal_has_start_time() const {
  return this != internal_default_instance() && _impl_.start_time_ != nullptr;
}
inline bool TraceQuery::has_start_time() const {
  return _internal_has_start_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& TraceQuery::_internal_start_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.start_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& TraceQuery::start_time() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.TraceQuery.start_time)
  return _internal_start_time();
}
inline void TraceQuery::unsafe_arena_set_allocated_start_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_time_);
  }
  _impl_.start_time_ = start_time;
  if (start_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.TraceQuery.start_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TraceQuery::release_start_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.start_time_;
  _impl_.start_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TraceQuery::unsafe_arena_release_start_time() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.TraceQuery.start_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.start_time_;
  _impl_.start_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TraceQuery::_internal_mutable_start_time() {
  
  if (_impl_.start_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.start_time_ = p;
  }
  return _impl_.start_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TraceQuery::mutable_start_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_start_time();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.TraceQuery.start_time)
  return _msg;
}
inline void TraceQuery::set_allocated_start_time(::PROTOBUF_NAMESPACE_ID::Timestamp* start_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_time_);
  }
  if (start_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_time));
    if (message_arena != submessage_arena) {
      start_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.start_time_ = start_time;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.TraceQuery.start_time)
}

// .google.protobuf.Timestamp end_time = 4;
inline bool TraceQuery::_internal_has_end_time() const {
  return this != internal_default_instance() && _impl_.end_time_ != nullptr;
}
inline bool TraceQuery::has_end_time() const {
  return _internal_has_end_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& TraceQuery::_internal_end_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.end_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& TraceQuery::end_time() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.TraceQuery.end_time)
  return _internal_end_time();
}
inline void TraceQuery::unsafe_arena_set_allocated_end_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_time_);
  }
  _impl_.end_time_ = end_time;
  if (end_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.observability.v1.TraceQuery.end_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TraceQuery::release_end_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.end_time_;
  _impl_.end_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TraceQuery::unsafe_arena_release_end_time() {
  // @@protoc_insertion_point(field_release:unhinged.observability.v1.TraceQuery.end_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.end_time_;
  _impl_.end_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TraceQuery::_internal_mutable_end_time() {
  
  if (_impl_.end_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.end_time_ = p;
  }
  return _impl_.end_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TraceQuery::mutable_end_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_end_time();
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.TraceQuery.end_time)
  return _msg;
}
inline void TraceQuery::set_allocated_end_time(::PROTOBUF_NAMESPACE_ID::Timestamp* end_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_time_);
  }
  if (end_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_time));
    if (message_arena != submessage_arena) {
      end_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.end_time_ = end_time;
  // @@protoc_insertion_point(field_set_allocated:unhinged.observability.v1.TraceQuery.end_time)
}

// int32 limit = 5;
inline void TraceQuery::clear_limit() {
  _impl_.limit_ = 0;
}
inline int32_t TraceQuery::_internal_limit() const {
  return _impl_.limit_;
}
inline int32_t TraceQuery::limit() const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.TraceQuery.limit)
  return _internal_limit();
}
inline void TraceQuery::_internal_set_limit(int32_t value) {
  
  _impl_.limit_ = value;
}
inline void TraceQuery::set_limit(int32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:unhinged.observability.v1.TraceQuery.limit)
}

// -------------------------------------------------------------------

// TraceQueryResponse

// repeated .unhinged.observability.v1.TraceEvent traces = 1;
inline int TraceQueryResponse::_internal_traces_size() const {
  return _impl_.traces_.size();
}
inline int TraceQueryResponse::traces_size() const {
  return _internal_traces_size();
}
inline void TraceQueryResponse::clear_traces() {
  _impl_.traces_.Clear();
}
inline ::unhinged::observability::v1::TraceEvent* TraceQueryResponse::mutable_traces(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.observability.v1.TraceQueryResponse.traces)
  return _impl_.traces_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::TraceEvent >*
TraceQueryResponse::mutable_traces() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.observability.v1.TraceQueryResponse.traces)
  return &_impl_.traces_;
}
inline const ::unhinged::observability::v1::TraceEvent& TraceQueryResponse::_internal_traces(int index) const {
  return _impl_.traces_.Get(index);
}
inline const ::unhinged::observability::v1::TraceEvent& TraceQueryResponse::traces(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.observability.v1.TraceQueryResponse.traces)
  return _internal_traces(index);
}
inline ::unhinged::observability::v1::TraceEvent* TraceQueryResponse::_internal_add_traces() {
  return _impl_.traces_.Add();
}
inline ::unhinged::observability::v1::TraceEvent* TraceQueryResponse::add_traces() {
  ::unhinged::observability::v1::TraceEvent* _add = _internal_add_traces();
  // @@protoc_insertion_point(field_add:unhinged.observability.v1.TraceQueryResponse.traces)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::observability::v1::TraceEvent >&
TraceQueryResponse::traces() const {
  // @@protoc_insertion_point(field_list:unhinged.observability.v1.TraceQueryResponse.traces)
  return _impl_.traces_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace observability
}  // namespace unhinged

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::unhinged::observability::v1::LogLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::unhinged::observability::v1::LogLevel>() {
  return ::unhinged::observability::v1::LogLevel_descriptor();
}
template <> struct is_proto_enum< ::unhinged::observability::v1::CompressionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::unhinged::observability::v1::CompressionType>() {
  return ::unhinged::observability::v1::CompressionType_descriptor();
}
template <> struct is_proto_enum< ::unhinged::observability::v1::SpanKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::unhinged::observability::v1::SpanKind>() {
  return ::unhinged::observability::v1::SpanKind_descriptor();
}
template <> struct is_proto_enum< ::unhinged::observability::v1::StatusCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::unhinged::observability::v1::StatusCode>() {
  return ::unhinged::observability::v1::StatusCode_descriptor();
}
template <> struct is_proto_enum< ::unhinged::observability::v1::AggregationTemporality> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::unhinged::observability::v1::AggregationTemporality>() {
  return ::unhinged::observability::v1::AggregationTemporality_descriptor();
}
template <> struct is_proto_enum< ::unhinged::observability::v1::HealthStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::unhinged::observability::v1::HealthStatus>() {
  return ::unhinged::observability::v1::HealthStatus_descriptor();
}
template <> struct is_proto_enum< ::unhinged::observability::v1::IncidentSeverity> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::unhinged::observability::v1::IncidentSeverity>() {
  return ::unhinged::observability::v1::IncidentSeverity_descriptor();
}
template <> struct is_proto_enum< ::unhinged::observability::v1::IncidentStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::unhinged::observability::v1::IncidentStatus>() {
  return ::unhinged::observability::v1::IncidentStatus_descriptor();
}
template <> struct is_proto_enum< ::unhinged::observability::v1::UpdateType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::unhinged::observability::v1::UpdateType>() {
  return ::unhinged::observability::v1::UpdateType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_observability_2eproto
