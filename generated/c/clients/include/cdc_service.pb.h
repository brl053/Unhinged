// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cdc_service.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_cdc_5fservice_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_cdc_5fservice_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
#include <google/protobuf/struct.pb.h>
#include "cdc_events.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_cdc_5fservice_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_cdc_5fservice_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_cdc_5fservice_2eproto;
namespace unhinged {
namespace cdc {
class AcknowledgeEventsRequest;
struct AcknowledgeEventsRequestDefaultTypeInternal;
extern AcknowledgeEventsRequestDefaultTypeInternal _AcknowledgeEventsRequest_default_instance_;
class AcknowledgeEventsResponse;
struct AcknowledgeEventsResponseDefaultTypeInternal;
extern AcknowledgeEventsResponseDefaultTypeInternal _AcknowledgeEventsResponse_default_instance_;
class DeadLetterEvent;
struct DeadLetterEventDefaultTypeInternal;
extern DeadLetterEventDefaultTypeInternal _DeadLetterEvent_default_instance_;
class DeleteSubscriptionRequest;
struct DeleteSubscriptionRequestDefaultTypeInternal;
extern DeleteSubscriptionRequestDefaultTypeInternal _DeleteSubscriptionRequest_default_instance_;
class DeleteSubscriptionResponse;
struct DeleteSubscriptionResponseDefaultTypeInternal;
extern DeleteSubscriptionResponseDefaultTypeInternal _DeleteSubscriptionResponse_default_instance_;
class EventBatch;
struct EventBatchDefaultTypeInternal;
extern EventBatchDefaultTypeInternal _EventBatch_default_instance_;
class EventFilter;
struct EventFilterDefaultTypeInternal;
extern EventFilterDefaultTypeInternal _EventFilter_default_instance_;
class EventStats;
struct EventStatsDefaultTypeInternal;
extern EventStatsDefaultTypeInternal _EventStats_default_instance_;
class EventStreamResponse;
struct EventStreamResponseDefaultTypeInternal;
extern EventStreamResponseDefaultTypeInternal _EventStreamResponse_default_instance_;
class GetEventStatsRequest;
struct GetEventStatsRequestDefaultTypeInternal;
extern GetEventStatsRequestDefaultTypeInternal _GetEventStatsRequest_default_instance_;
class GetEventStatsResponse;
struct GetEventStatsResponseDefaultTypeInternal;
extern GetEventStatsResponseDefaultTypeInternal _GetEventStatsResponse_default_instance_;
class GetServiceStatusRequest;
struct GetServiceStatusRequestDefaultTypeInternal;
extern GetServiceStatusRequestDefaultTypeInternal _GetServiceStatusRequest_default_instance_;
class GetServiceStatusResponse;
struct GetServiceStatusResponseDefaultTypeInternal;
extern GetServiceStatusResponseDefaultTypeInternal _GetServiceStatusResponse_default_instance_;
class Heartbeat;
struct HeartbeatDefaultTypeInternal;
extern HeartbeatDefaultTypeInternal _Heartbeat_default_instance_;
class ListDeadLetterEventsRequest;
struct ListDeadLetterEventsRequestDefaultTypeInternal;
extern ListDeadLetterEventsRequestDefaultTypeInternal _ListDeadLetterEventsRequest_default_instance_;
class ListDeadLetterEventsResponse;
struct ListDeadLetterEventsResponseDefaultTypeInternal;
extern ListDeadLetterEventsResponseDefaultTypeInternal _ListDeadLetterEventsResponse_default_instance_;
class ListSubscriptionsRequest;
struct ListSubscriptionsRequestDefaultTypeInternal;
extern ListSubscriptionsRequestDefaultTypeInternal _ListSubscriptionsRequest_default_instance_;
class ListSubscriptionsResponse;
struct ListSubscriptionsResponseDefaultTypeInternal;
extern ListSubscriptionsResponseDefaultTypeInternal _ListSubscriptionsResponse_default_instance_;
class PublishEventRequest;
struct PublishEventRequestDefaultTypeInternal;
extern PublishEventRequestDefaultTypeInternal _PublishEventRequest_default_instance_;
class PublishEventResponse;
struct PublishEventResponseDefaultTypeInternal;
extern PublishEventResponseDefaultTypeInternal _PublishEventResponse_default_instance_;
class PublishEventResult;
struct PublishEventResultDefaultTypeInternal;
extern PublishEventResultDefaultTypeInternal _PublishEventResult_default_instance_;
class PublishEventsRequest;
struct PublishEventsRequestDefaultTypeInternal;
extern PublishEventsRequestDefaultTypeInternal _PublishEventsRequest_default_instance_;
class PublishEventsResponse;
struct PublishEventsResponseDefaultTypeInternal;
extern PublishEventsResponseDefaultTypeInternal _PublishEventsResponse_default_instance_;
class ReplayEventsRequest;
struct ReplayEventsRequestDefaultTypeInternal;
extern ReplayEventsRequestDefaultTypeInternal _ReplayEventsRequest_default_instance_;
class ReprocessDeadLetterEventsRequest;
struct ReprocessDeadLetterEventsRequestDefaultTypeInternal;
extern ReprocessDeadLetterEventsRequestDefaultTypeInternal _ReprocessDeadLetterEventsRequest_default_instance_;
class ReprocessDeadLetterEventsResponse;
struct ReprocessDeadLetterEventsResponseDefaultTypeInternal;
extern ReprocessDeadLetterEventsResponseDefaultTypeInternal _ReprocessDeadLetterEventsResponse_default_instance_;
class SequenceRange;
struct SequenceRangeDefaultTypeInternal;
extern SequenceRangeDefaultTypeInternal _SequenceRange_default_instance_;
class ServiceMetrics;
struct ServiceMetricsDefaultTypeInternal;
extern ServiceMetricsDefaultTypeInternal _ServiceMetrics_default_instance_;
class SubscribeRequest;
struct SubscribeRequestDefaultTypeInternal;
extern SubscribeRequestDefaultTypeInternal _SubscribeRequest_default_instance_;
class SubscriptionError;
struct SubscriptionErrorDefaultTypeInternal;
extern SubscriptionErrorDefaultTypeInternal _SubscriptionError_default_instance_;
class SubscriptionInfo;
struct SubscriptionInfoDefaultTypeInternal;
extern SubscriptionInfoDefaultTypeInternal _SubscriptionInfo_default_instance_;
class SubscriptionOptions;
struct SubscriptionOptionsDefaultTypeInternal;
extern SubscriptionOptionsDefaultTypeInternal _SubscriptionOptions_default_instance_;
class SubscriptionStatus;
struct SubscriptionStatusDefaultTypeInternal;
extern SubscriptionStatusDefaultTypeInternal _SubscriptionStatus_default_instance_;
class TimeRange;
struct TimeRangeDefaultTypeInternal;
extern TimeRangeDefaultTypeInternal _TimeRange_default_instance_;
class UpdateSubscriptionRequest;
struct UpdateSubscriptionRequestDefaultTypeInternal;
extern UpdateSubscriptionRequestDefaultTypeInternal _UpdateSubscriptionRequest_default_instance_;
class UpdateSubscriptionResponse;
struct UpdateSubscriptionResponseDefaultTypeInternal;
extern UpdateSubscriptionResponseDefaultTypeInternal _UpdateSubscriptionResponse_default_instance_;
}  // namespace cdc
}  // namespace unhinged
PROTOBUF_NAMESPACE_OPEN
template<> ::unhinged::cdc::AcknowledgeEventsRequest* Arena::CreateMaybeMessage<::unhinged::cdc::AcknowledgeEventsRequest>(Arena*);
template<> ::unhinged::cdc::AcknowledgeEventsResponse* Arena::CreateMaybeMessage<::unhinged::cdc::AcknowledgeEventsResponse>(Arena*);
template<> ::unhinged::cdc::DeadLetterEvent* Arena::CreateMaybeMessage<::unhinged::cdc::DeadLetterEvent>(Arena*);
template<> ::unhinged::cdc::DeleteSubscriptionRequest* Arena::CreateMaybeMessage<::unhinged::cdc::DeleteSubscriptionRequest>(Arena*);
template<> ::unhinged::cdc::DeleteSubscriptionResponse* Arena::CreateMaybeMessage<::unhinged::cdc::DeleteSubscriptionResponse>(Arena*);
template<> ::unhinged::cdc::EventBatch* Arena::CreateMaybeMessage<::unhinged::cdc::EventBatch>(Arena*);
template<> ::unhinged::cdc::EventFilter* Arena::CreateMaybeMessage<::unhinged::cdc::EventFilter>(Arena*);
template<> ::unhinged::cdc::EventStats* Arena::CreateMaybeMessage<::unhinged::cdc::EventStats>(Arena*);
template<> ::unhinged::cdc::EventStreamResponse* Arena::CreateMaybeMessage<::unhinged::cdc::EventStreamResponse>(Arena*);
template<> ::unhinged::cdc::GetEventStatsRequest* Arena::CreateMaybeMessage<::unhinged::cdc::GetEventStatsRequest>(Arena*);
template<> ::unhinged::cdc::GetEventStatsResponse* Arena::CreateMaybeMessage<::unhinged::cdc::GetEventStatsResponse>(Arena*);
template<> ::unhinged::cdc::GetServiceStatusRequest* Arena::CreateMaybeMessage<::unhinged::cdc::GetServiceStatusRequest>(Arena*);
template<> ::unhinged::cdc::GetServiceStatusResponse* Arena::CreateMaybeMessage<::unhinged::cdc::GetServiceStatusResponse>(Arena*);
template<> ::unhinged::cdc::Heartbeat* Arena::CreateMaybeMessage<::unhinged::cdc::Heartbeat>(Arena*);
template<> ::unhinged::cdc::ListDeadLetterEventsRequest* Arena::CreateMaybeMessage<::unhinged::cdc::ListDeadLetterEventsRequest>(Arena*);
template<> ::unhinged::cdc::ListDeadLetterEventsResponse* Arena::CreateMaybeMessage<::unhinged::cdc::ListDeadLetterEventsResponse>(Arena*);
template<> ::unhinged::cdc::ListSubscriptionsRequest* Arena::CreateMaybeMessage<::unhinged::cdc::ListSubscriptionsRequest>(Arena*);
template<> ::unhinged::cdc::ListSubscriptionsResponse* Arena::CreateMaybeMessage<::unhinged::cdc::ListSubscriptionsResponse>(Arena*);
template<> ::unhinged::cdc::PublishEventRequest* Arena::CreateMaybeMessage<::unhinged::cdc::PublishEventRequest>(Arena*);
template<> ::unhinged::cdc::PublishEventResponse* Arena::CreateMaybeMessage<::unhinged::cdc::PublishEventResponse>(Arena*);
template<> ::unhinged::cdc::PublishEventResult* Arena::CreateMaybeMessage<::unhinged::cdc::PublishEventResult>(Arena*);
template<> ::unhinged::cdc::PublishEventsRequest* Arena::CreateMaybeMessage<::unhinged::cdc::PublishEventsRequest>(Arena*);
template<> ::unhinged::cdc::PublishEventsResponse* Arena::CreateMaybeMessage<::unhinged::cdc::PublishEventsResponse>(Arena*);
template<> ::unhinged::cdc::ReplayEventsRequest* Arena::CreateMaybeMessage<::unhinged::cdc::ReplayEventsRequest>(Arena*);
template<> ::unhinged::cdc::ReprocessDeadLetterEventsRequest* Arena::CreateMaybeMessage<::unhinged::cdc::ReprocessDeadLetterEventsRequest>(Arena*);
template<> ::unhinged::cdc::ReprocessDeadLetterEventsResponse* Arena::CreateMaybeMessage<::unhinged::cdc::ReprocessDeadLetterEventsResponse>(Arena*);
template<> ::unhinged::cdc::SequenceRange* Arena::CreateMaybeMessage<::unhinged::cdc::SequenceRange>(Arena*);
template<> ::unhinged::cdc::ServiceMetrics* Arena::CreateMaybeMessage<::unhinged::cdc::ServiceMetrics>(Arena*);
template<> ::unhinged::cdc::SubscribeRequest* Arena::CreateMaybeMessage<::unhinged::cdc::SubscribeRequest>(Arena*);
template<> ::unhinged::cdc::SubscriptionError* Arena::CreateMaybeMessage<::unhinged::cdc::SubscriptionError>(Arena*);
template<> ::unhinged::cdc::SubscriptionInfo* Arena::CreateMaybeMessage<::unhinged::cdc::SubscriptionInfo>(Arena*);
template<> ::unhinged::cdc::SubscriptionOptions* Arena::CreateMaybeMessage<::unhinged::cdc::SubscriptionOptions>(Arena*);
template<> ::unhinged::cdc::SubscriptionStatus* Arena::CreateMaybeMessage<::unhinged::cdc::SubscriptionStatus>(Arena*);
template<> ::unhinged::cdc::TimeRange* Arena::CreateMaybeMessage<::unhinged::cdc::TimeRange>(Arena*);
template<> ::unhinged::cdc::UpdateSubscriptionRequest* Arena::CreateMaybeMessage<::unhinged::cdc::UpdateSubscriptionRequest>(Arena*);
template<> ::unhinged::cdc::UpdateSubscriptionResponse* Arena::CreateMaybeMessage<::unhinged::cdc::UpdateSubscriptionResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace unhinged {
namespace cdc {

// ===================================================================

class PublishEventRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.PublishEventRequest) */ {
 public:
  inline PublishEventRequest() : PublishEventRequest(nullptr) {}
  ~PublishEventRequest() override;
  explicit PROTOBUF_CONSTEXPR PublishEventRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PublishEventRequest(const PublishEventRequest& from);
  PublishEventRequest(PublishEventRequest&& from) noexcept
    : PublishEventRequest() {
    *this = ::std::move(from);
  }

  inline PublishEventRequest& operator=(const PublishEventRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PublishEventRequest& operator=(PublishEventRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PublishEventRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PublishEventRequest* internal_default_instance() {
    return reinterpret_cast<const PublishEventRequest*>(
               &_PublishEventRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(PublishEventRequest& a, PublishEventRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PublishEventRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PublishEventRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PublishEventRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PublishEventRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PublishEventRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PublishEventRequest& from) {
    PublishEventRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PublishEventRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.PublishEventRequest";
  }
  protected:
  explicit PublishEventRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetSubscribersFieldNumber = 5,
    kRoutingStrategyFieldNumber = 6,
    kEventFieldNumber = 1,
    kDeliveryDeadlineFieldNumber = 4,
    kEnsureDeliveryFieldNumber = 2,
    kRetryAttemptsFieldNumber = 3,
  };
  // repeated string target_subscribers = 5;
  int target_subscribers_size() const;
  private:
  int _internal_target_subscribers_size() const;
  public:
  void clear_target_subscribers();
  const std::string& target_subscribers(int index) const;
  std::string* mutable_target_subscribers(int index);
  void set_target_subscribers(int index, const std::string& value);
  void set_target_subscribers(int index, std::string&& value);
  void set_target_subscribers(int index, const char* value);
  void set_target_subscribers(int index, const char* value, size_t size);
  std::string* add_target_subscribers();
  void add_target_subscribers(const std::string& value);
  void add_target_subscribers(std::string&& value);
  void add_target_subscribers(const char* value);
  void add_target_subscribers(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& target_subscribers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_target_subscribers();
  private:
  const std::string& _internal_target_subscribers(int index) const;
  std::string* _internal_add_target_subscribers();
  public:

  // string routing_strategy = 6;
  void clear_routing_strategy();
  const std::string& routing_strategy() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_routing_strategy(ArgT0&& arg0, ArgT... args);
  std::string* mutable_routing_strategy();
  PROTOBUF_NODISCARD std::string* release_routing_strategy();
  void set_allocated_routing_strategy(std::string* routing_strategy);
  private:
  const std::string& _internal_routing_strategy() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_routing_strategy(const std::string& value);
  std::string* _internal_mutable_routing_strategy();
  public:

  // .unhinged.cdc.UniversalEvent event = 1;
  bool has_event() const;
  private:
  bool _internal_has_event() const;
  public:
  void clear_event();
  const ::unhinged::cdc::UniversalEvent& event() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::UniversalEvent* release_event();
  ::unhinged::cdc::UniversalEvent* mutable_event();
  void set_allocated_event(::unhinged::cdc::UniversalEvent* event);
  private:
  const ::unhinged::cdc::UniversalEvent& _internal_event() const;
  ::unhinged::cdc::UniversalEvent* _internal_mutable_event();
  public:
  void unsafe_arena_set_allocated_event(
      ::unhinged::cdc::UniversalEvent* event);
  ::unhinged::cdc::UniversalEvent* unsafe_arena_release_event();

  // .google.protobuf.Timestamp delivery_deadline = 4;
  bool has_delivery_deadline() const;
  private:
  bool _internal_has_delivery_deadline() const;
  public:
  void clear_delivery_deadline();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& delivery_deadline() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_delivery_deadline();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_delivery_deadline();
  void set_allocated_delivery_deadline(::PROTOBUF_NAMESPACE_ID::Timestamp* delivery_deadline);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_delivery_deadline() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_delivery_deadline();
  public:
  void unsafe_arena_set_allocated_delivery_deadline(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* delivery_deadline);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_delivery_deadline();

  // bool ensure_delivery = 2;
  void clear_ensure_delivery();
  bool ensure_delivery() const;
  void set_ensure_delivery(bool value);
  private:
  bool _internal_ensure_delivery() const;
  void _internal_set_ensure_delivery(bool value);
  public:

  // int32 retry_attempts = 3;
  void clear_retry_attempts();
  int32_t retry_attempts() const;
  void set_retry_attempts(int32_t value);
  private:
  int32_t _internal_retry_attempts() const;
  void _internal_set_retry_attempts(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.cdc.PublishEventRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> target_subscribers_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr routing_strategy_;
    ::unhinged::cdc::UniversalEvent* event_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* delivery_deadline_;
    bool ensure_delivery_;
    int32_t retry_attempts_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class PublishEventResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.PublishEventResponse) */ {
 public:
  inline PublishEventResponse() : PublishEventResponse(nullptr) {}
  ~PublishEventResponse() override;
  explicit PROTOBUF_CONSTEXPR PublishEventResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PublishEventResponse(const PublishEventResponse& from);
  PublishEventResponse(PublishEventResponse&& from) noexcept
    : PublishEventResponse() {
    *this = ::std::move(from);
  }

  inline PublishEventResponse& operator=(const PublishEventResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PublishEventResponse& operator=(PublishEventResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PublishEventResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PublishEventResponse* internal_default_instance() {
    return reinterpret_cast<const PublishEventResponse*>(
               &_PublishEventResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PublishEventResponse& a, PublishEventResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PublishEventResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PublishEventResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PublishEventResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PublishEventResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PublishEventResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PublishEventResponse& from) {
    PublishEventResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PublishEventResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.PublishEventResponse";
  }
  protected:
  explicit PublishEventResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kEventIdFieldNumber = 3,
    kPublishedAtFieldNumber = 5,
    kSequenceNumberFieldNumber = 4,
    kSuccessFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // string event_id = 3;
  void clear_event_id();
  const std::string& event_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_event_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_event_id();
  PROTOBUF_NODISCARD std::string* release_event_id();
  void set_allocated_event_id(std::string* event_id);
  private:
  const std::string& _internal_event_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_event_id(const std::string& value);
  std::string* _internal_mutable_event_id();
  public:

  // .google.protobuf.Timestamp published_at = 5;
  bool has_published_at() const;
  private:
  bool _internal_has_published_at() const;
  public:
  void clear_published_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& published_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_published_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_published_at();
  void set_allocated_published_at(::PROTOBUF_NAMESPACE_ID::Timestamp* published_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_published_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_published_at();
  public:
  void unsafe_arena_set_allocated_published_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* published_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_published_at();

  // int64 sequence_number = 4;
  void clear_sequence_number();
  int64_t sequence_number() const;
  void set_sequence_number(int64_t value);
  private:
  int64_t _internal_sequence_number() const;
  void _internal_set_sequence_number(int64_t value);
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.cdc.PublishEventResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr event_id_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* published_at_;
    int64_t sequence_number_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class PublishEventsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.PublishEventsRequest) */ {
 public:
  inline PublishEventsRequest() : PublishEventsRequest(nullptr) {}
  ~PublishEventsRequest() override;
  explicit PROTOBUF_CONSTEXPR PublishEventsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PublishEventsRequest(const PublishEventsRequest& from);
  PublishEventsRequest(PublishEventsRequest&& from) noexcept
    : PublishEventsRequest() {
    *this = ::std::move(from);
  }

  inline PublishEventsRequest& operator=(const PublishEventsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PublishEventsRequest& operator=(PublishEventsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PublishEventsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PublishEventsRequest* internal_default_instance() {
    return reinterpret_cast<const PublishEventsRequest*>(
               &_PublishEventsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PublishEventsRequest& a, PublishEventsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PublishEventsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PublishEventsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PublishEventsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PublishEventsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PublishEventsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PublishEventsRequest& from) {
    PublishEventsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PublishEventsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.PublishEventsRequest";
  }
  protected:
  explicit PublishEventsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventsFieldNumber = 1,
    kAtomicFieldNumber = 2,
    kEnsureDeliveryFieldNumber = 3,
    kRetryAttemptsFieldNumber = 4,
  };
  // repeated .unhinged.cdc.UniversalEvent events = 1;
  int events_size() const;
  private:
  int _internal_events_size() const;
  public:
  void clear_events();
  ::unhinged::cdc::UniversalEvent* mutable_events(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::cdc::UniversalEvent >*
      mutable_events();
  private:
  const ::unhinged::cdc::UniversalEvent& _internal_events(int index) const;
  ::unhinged::cdc::UniversalEvent* _internal_add_events();
  public:
  const ::unhinged::cdc::UniversalEvent& events(int index) const;
  ::unhinged::cdc::UniversalEvent* add_events();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::cdc::UniversalEvent >&
      events() const;

  // bool atomic = 2;
  void clear_atomic();
  bool atomic() const;
  void set_atomic(bool value);
  private:
  bool _internal_atomic() const;
  void _internal_set_atomic(bool value);
  public:

  // bool ensure_delivery = 3;
  void clear_ensure_delivery();
  bool ensure_delivery() const;
  void set_ensure_delivery(bool value);
  private:
  bool _internal_ensure_delivery() const;
  void _internal_set_ensure_delivery(bool value);
  public:

  // int32 retry_attempts = 4;
  void clear_retry_attempts();
  int32_t retry_attempts() const;
  void set_retry_attempts(int32_t value);
  private:
  int32_t _internal_retry_attempts() const;
  void _internal_set_retry_attempts(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.cdc.PublishEventsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::cdc::UniversalEvent > events_;
    bool atomic_;
    bool ensure_delivery_;
    int32_t retry_attempts_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class PublishEventResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.PublishEventResult) */ {
 public:
  inline PublishEventResult() : PublishEventResult(nullptr) {}
  ~PublishEventResult() override;
  explicit PROTOBUF_CONSTEXPR PublishEventResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PublishEventResult(const PublishEventResult& from);
  PublishEventResult(PublishEventResult&& from) noexcept
    : PublishEventResult() {
    *this = ::std::move(from);
  }

  inline PublishEventResult& operator=(const PublishEventResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline PublishEventResult& operator=(PublishEventResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PublishEventResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const PublishEventResult* internal_default_instance() {
    return reinterpret_cast<const PublishEventResult*>(
               &_PublishEventResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PublishEventResult& a, PublishEventResult& b) {
    a.Swap(&b);
  }
  inline void Swap(PublishEventResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PublishEventResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PublishEventResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PublishEventResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PublishEventResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PublishEventResult& from) {
    PublishEventResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PublishEventResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.PublishEventResult";
  }
  protected:
  explicit PublishEventResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventIdFieldNumber = 1,
    kErrorMessageFieldNumber = 3,
    kSequenceNumberFieldNumber = 4,
    kSuccessFieldNumber = 2,
  };
  // string event_id = 1;
  void clear_event_id();
  const std::string& event_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_event_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_event_id();
  PROTOBUF_NODISCARD std::string* release_event_id();
  void set_allocated_event_id(std::string* event_id);
  private:
  const std::string& _internal_event_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_event_id(const std::string& value);
  std::string* _internal_mutable_event_id();
  public:

  // string error_message = 3;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // int64 sequence_number = 4;
  void clear_sequence_number();
  int64_t sequence_number() const;
  void set_sequence_number(int64_t value);
  private:
  int64_t _internal_sequence_number() const;
  void _internal_set_sequence_number(int64_t value);
  public:

  // bool success = 2;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.cdc.PublishEventResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr event_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    int64_t sequence_number_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class PublishEventsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.PublishEventsResponse) */ {
 public:
  inline PublishEventsResponse() : PublishEventsResponse(nullptr) {}
  ~PublishEventsResponse() override;
  explicit PROTOBUF_CONSTEXPR PublishEventsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PublishEventsResponse(const PublishEventsResponse& from);
  PublishEventsResponse(PublishEventsResponse&& from) noexcept
    : PublishEventsResponse() {
    *this = ::std::move(from);
  }

  inline PublishEventsResponse& operator=(const PublishEventsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PublishEventsResponse& operator=(PublishEventsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PublishEventsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PublishEventsResponse* internal_default_instance() {
    return reinterpret_cast<const PublishEventsResponse*>(
               &_PublishEventsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(PublishEventsResponse& a, PublishEventsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PublishEventsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PublishEventsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PublishEventsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PublishEventsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PublishEventsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PublishEventsResponse& from) {
    PublishEventsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PublishEventsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.PublishEventsResponse";
  }
  protected:
  explicit PublishEventsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultsFieldNumber = 3,
    kMessageFieldNumber = 2,
    kSuccessFieldNumber = 1,
    kSuccessfulCountFieldNumber = 4,
    kFailedCountFieldNumber = 5,
  };
  // repeated .unhinged.cdc.PublishEventResult results = 3;
  int results_size() const;
  private:
  int _internal_results_size() const;
  public:
  void clear_results();
  ::unhinged::cdc::PublishEventResult* mutable_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::cdc::PublishEventResult >*
      mutable_results();
  private:
  const ::unhinged::cdc::PublishEventResult& _internal_results(int index) const;
  ::unhinged::cdc::PublishEventResult* _internal_add_results();
  public:
  const ::unhinged::cdc::PublishEventResult& results(int index) const;
  ::unhinged::cdc::PublishEventResult* add_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::cdc::PublishEventResult >&
      results() const;

  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // int32 successful_count = 4;
  void clear_successful_count();
  int32_t successful_count() const;
  void set_successful_count(int32_t value);
  private:
  int32_t _internal_successful_count() const;
  void _internal_set_successful_count(int32_t value);
  public:

  // int32 failed_count = 5;
  void clear_failed_count();
  int32_t failed_count() const;
  void set_failed_count(int32_t value);
  private:
  int32_t _internal_failed_count() const;
  void _internal_set_failed_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.cdc.PublishEventsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::cdc::PublishEventResult > results_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    bool success_;
    int32_t successful_count_;
    int32_t failed_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class SubscribeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.SubscribeRequest) */ {
 public:
  inline SubscribeRequest() : SubscribeRequest(nullptr) {}
  ~SubscribeRequest() override;
  explicit PROTOBUF_CONSTEXPR SubscribeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscribeRequest(const SubscribeRequest& from);
  SubscribeRequest(SubscribeRequest&& from) noexcept
    : SubscribeRequest() {
    *this = ::std::move(from);
  }

  inline SubscribeRequest& operator=(const SubscribeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeRequest& operator=(SubscribeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscribeRequest* internal_default_instance() {
    return reinterpret_cast<const SubscribeRequest*>(
               &_SubscribeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SubscribeRequest& a, SubscribeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscribeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubscribeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubscribeRequest& from) {
    SubscribeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscribeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.SubscribeRequest";
  }
  protected:
  explicit SubscribeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubscriberIdFieldNumber = 1,
    kSubscriberNameFieldNumber = 2,
    kFilterFieldNumber = 3,
    kOptionsFieldNumber = 4,
  };
  // string subscriber_id = 1;
  void clear_subscriber_id();
  const std::string& subscriber_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_subscriber_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_subscriber_id();
  PROTOBUF_NODISCARD std::string* release_subscriber_id();
  void set_allocated_subscriber_id(std::string* subscriber_id);
  private:
  const std::string& _internal_subscriber_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subscriber_id(const std::string& value);
  std::string* _internal_mutable_subscriber_id();
  public:

  // string subscriber_name = 2;
  void clear_subscriber_name();
  const std::string& subscriber_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_subscriber_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_subscriber_name();
  PROTOBUF_NODISCARD std::string* release_subscriber_name();
  void set_allocated_subscriber_name(std::string* subscriber_name);
  private:
  const std::string& _internal_subscriber_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subscriber_name(const std::string& value);
  std::string* _internal_mutable_subscriber_name();
  public:

  // .unhinged.cdc.EventFilter filter = 3;
  bool has_filter() const;
  private:
  bool _internal_has_filter() const;
  public:
  void clear_filter();
  const ::unhinged::cdc::EventFilter& filter() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::EventFilter* release_filter();
  ::unhinged::cdc::EventFilter* mutable_filter();
  void set_allocated_filter(::unhinged::cdc::EventFilter* filter);
  private:
  const ::unhinged::cdc::EventFilter& _internal_filter() const;
  ::unhinged::cdc::EventFilter* _internal_mutable_filter();
  public:
  void unsafe_arena_set_allocated_filter(
      ::unhinged::cdc::EventFilter* filter);
  ::unhinged::cdc::EventFilter* unsafe_arena_release_filter();

  // .unhinged.cdc.SubscriptionOptions options = 4;
  bool has_options() const;
  private:
  bool _internal_has_options() const;
  public:
  void clear_options();
  const ::unhinged::cdc::SubscriptionOptions& options() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::SubscriptionOptions* release_options();
  ::unhinged::cdc::SubscriptionOptions* mutable_options();
  void set_allocated_options(::unhinged::cdc::SubscriptionOptions* options);
  private:
  const ::unhinged::cdc::SubscriptionOptions& _internal_options() const;
  ::unhinged::cdc::SubscriptionOptions* _internal_mutable_options();
  public:
  void unsafe_arena_set_allocated_options(
      ::unhinged::cdc::SubscriptionOptions* options);
  ::unhinged::cdc::SubscriptionOptions* unsafe_arena_release_options();

  // @@protoc_insertion_point(class_scope:unhinged.cdc.SubscribeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subscriber_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subscriber_name_;
    ::unhinged::cdc::EventFilter* filter_;
    ::unhinged::cdc::SubscriptionOptions* options_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class EventFilter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.EventFilter) */ {
 public:
  inline EventFilter() : EventFilter(nullptr) {}
  ~EventFilter() override;
  explicit PROTOBUF_CONSTEXPR EventFilter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventFilter(const EventFilter& from);
  EventFilter(EventFilter&& from) noexcept
    : EventFilter() {
    *this = ::std::move(from);
  }

  inline EventFilter& operator=(const EventFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventFilter& operator=(EventFilter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventFilter& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventFilter* internal_default_instance() {
    return reinterpret_cast<const EventFilter*>(
               &_EventFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(EventFilter& a, EventFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(EventFilter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventFilter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventFilter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventFilter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventFilter& from) {
    EventFilter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventFilter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.EventFilter";
  }
  protected:
  explicit EventFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventTypesFieldNumber = 1,
    kSourceServicesFieldNumber = 2,
    kUserIdsFieldNumber = 3,
    kSessionIdsFieldNumber = 4,
    kTagsFieldNumber = 5,
    kJqFilterFieldNumber = 8,
    kStartTimeFieldNumber = 6,
    kEndTimeFieldNumber = 7,
    kMetadataFilterFieldNumber = 9,
  };
  // repeated string event_types = 1;
  int event_types_size() const;
  private:
  int _internal_event_types_size() const;
  public:
  void clear_event_types();
  const std::string& event_types(int index) const;
  std::string* mutable_event_types(int index);
  void set_event_types(int index, const std::string& value);
  void set_event_types(int index, std::string&& value);
  void set_event_types(int index, const char* value);
  void set_event_types(int index, const char* value, size_t size);
  std::string* add_event_types();
  void add_event_types(const std::string& value);
  void add_event_types(std::string&& value);
  void add_event_types(const char* value);
  void add_event_types(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& event_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_event_types();
  private:
  const std::string& _internal_event_types(int index) const;
  std::string* _internal_add_event_types();
  public:

  // repeated string source_services = 2;
  int source_services_size() const;
  private:
  int _internal_source_services_size() const;
  public:
  void clear_source_services();
  const std::string& source_services(int index) const;
  std::string* mutable_source_services(int index);
  void set_source_services(int index, const std::string& value);
  void set_source_services(int index, std::string&& value);
  void set_source_services(int index, const char* value);
  void set_source_services(int index, const char* value, size_t size);
  std::string* add_source_services();
  void add_source_services(const std::string& value);
  void add_source_services(std::string&& value);
  void add_source_services(const char* value);
  void add_source_services(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& source_services() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_source_services();
  private:
  const std::string& _internal_source_services(int index) const;
  std::string* _internal_add_source_services();
  public:

  // repeated string user_ids = 3;
  int user_ids_size() const;
  private:
  int _internal_user_ids_size() const;
  public:
  void clear_user_ids();
  const std::string& user_ids(int index) const;
  std::string* mutable_user_ids(int index);
  void set_user_ids(int index, const std::string& value);
  void set_user_ids(int index, std::string&& value);
  void set_user_ids(int index, const char* value);
  void set_user_ids(int index, const char* value, size_t size);
  std::string* add_user_ids();
  void add_user_ids(const std::string& value);
  void add_user_ids(std::string&& value);
  void add_user_ids(const char* value);
  void add_user_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& user_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_user_ids();
  private:
  const std::string& _internal_user_ids(int index) const;
  std::string* _internal_add_user_ids();
  public:

  // repeated string session_ids = 4;
  int session_ids_size() const;
  private:
  int _internal_session_ids_size() const;
  public:
  void clear_session_ids();
  const std::string& session_ids(int index) const;
  std::string* mutable_session_ids(int index);
  void set_session_ids(int index, const std::string& value);
  void set_session_ids(int index, std::string&& value);
  void set_session_ids(int index, const char* value);
  void set_session_ids(int index, const char* value, size_t size);
  std::string* add_session_ids();
  void add_session_ids(const std::string& value);
  void add_session_ids(std::string&& value);
  void add_session_ids(const char* value);
  void add_session_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& session_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_session_ids();
  private:
  const std::string& _internal_session_ids(int index) const;
  std::string* _internal_add_session_ids();
  public:

  // repeated string tags = 5;
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  const std::string& tags(int index) const;
  std::string* mutable_tags(int index);
  void set_tags(int index, const std::string& value);
  void set_tags(int index, std::string&& value);
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, size_t size);
  std::string* add_tags();
  void add_tags(const std::string& value);
  void add_tags(std::string&& value);
  void add_tags(const char* value);
  void add_tags(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tags();
  private:
  const std::string& _internal_tags(int index) const;
  std::string* _internal_add_tags();
  public:

  // string jq_filter = 8;
  void clear_jq_filter();
  const std::string& jq_filter() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_jq_filter(ArgT0&& arg0, ArgT... args);
  std::string* mutable_jq_filter();
  PROTOBUF_NODISCARD std::string* release_jq_filter();
  void set_allocated_jq_filter(std::string* jq_filter);
  private:
  const std::string& _internal_jq_filter() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_jq_filter(const std::string& value);
  std::string* _internal_mutable_jq_filter();
  public:

  // .google.protobuf.Timestamp start_time = 6;
  bool has_start_time() const;
  private:
  bool _internal_has_start_time() const;
  public:
  void clear_start_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& start_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_start_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_start_time();
  void set_allocated_start_time(::PROTOBUF_NAMESPACE_ID::Timestamp* start_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_start_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_start_time();
  public:
  void unsafe_arena_set_allocated_start_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_start_time();

  // .google.protobuf.Timestamp end_time = 7;
  bool has_end_time() const;
  private:
  bool _internal_has_end_time() const;
  public:
  void clear_end_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& end_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_end_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_end_time();
  void set_allocated_end_time(::PROTOBUF_NAMESPACE_ID::Timestamp* end_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_end_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_end_time();
  public:
  void unsafe_arena_set_allocated_end_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_end_time();

  // .google.protobuf.Struct metadata_filter = 9;
  bool has_metadata_filter() const;
  private:
  bool _internal_has_metadata_filter() const;
  public:
  void clear_metadata_filter();
  const ::PROTOBUF_NAMESPACE_ID::Struct& metadata_filter() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_metadata_filter();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_metadata_filter();
  void set_allocated_metadata_filter(::PROTOBUF_NAMESPACE_ID::Struct* metadata_filter);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_metadata_filter() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_metadata_filter();
  public:
  void unsafe_arena_set_allocated_metadata_filter(
      ::PROTOBUF_NAMESPACE_ID::Struct* metadata_filter);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_metadata_filter();

  // @@protoc_insertion_point(class_scope:unhinged.cdc.EventFilter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> event_types_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> source_services_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> user_ids_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> session_ids_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tags_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr jq_filter_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time_;
    ::PROTOBUF_NAMESPACE_ID::Struct* metadata_filter_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class SubscriptionOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.SubscriptionOptions) */ {
 public:
  inline SubscriptionOptions() : SubscriptionOptions(nullptr) {}
  ~SubscriptionOptions() override;
  explicit PROTOBUF_CONSTEXPR SubscriptionOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscriptionOptions(const SubscriptionOptions& from);
  SubscriptionOptions(SubscriptionOptions&& from) noexcept
    : SubscriptionOptions() {
    *this = ::std::move(from);
  }

  inline SubscriptionOptions& operator=(const SubscriptionOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscriptionOptions& operator=(SubscriptionOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscriptionOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscriptionOptions* internal_default_instance() {
    return reinterpret_cast<const SubscriptionOptions*>(
               &_SubscriptionOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SubscriptionOptions& a, SubscriptionOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscriptionOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscriptionOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscriptionOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscriptionOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubscriptionOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubscriptionOptions& from) {
    SubscriptionOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscriptionOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.SubscriptionOptions";
  }
  protected:
  explicit SubscriptionOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeliveryModeFieldNumber = 1,
    kReplayFromTimeFieldNumber = 6,
    kBatchSizeFieldNumber = 2,
    kBatchTimeoutMsFieldNumber = 3,
    kReplayFromSequenceFieldNumber = 5,
    kReplayFromBeginningFieldNumber = 4,
    kSendToDlqOnFailureFieldNumber = 9,
    kMaxRetryAttemptsFieldNumber = 7,
    kRetryBackoffMsFieldNumber = 8,
  };
  // string delivery_mode = 1;
  void clear_delivery_mode();
  const std::string& delivery_mode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_delivery_mode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_delivery_mode();
  PROTOBUF_NODISCARD std::string* release_delivery_mode();
  void set_allocated_delivery_mode(std::string* delivery_mode);
  private:
  const std::string& _internal_delivery_mode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_delivery_mode(const std::string& value);
  std::string* _internal_mutable_delivery_mode();
  public:

  // .google.protobuf.Timestamp replay_from_time = 6;
  bool has_replay_from_time() const;
  private:
  bool _internal_has_replay_from_time() const;
  public:
  void clear_replay_from_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& replay_from_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_replay_from_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_replay_from_time();
  void set_allocated_replay_from_time(::PROTOBUF_NAMESPACE_ID::Timestamp* replay_from_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_replay_from_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_replay_from_time();
  public:
  void unsafe_arena_set_allocated_replay_from_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* replay_from_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_replay_from_time();

  // int32 batch_size = 2;
  void clear_batch_size();
  int32_t batch_size() const;
  void set_batch_size(int32_t value);
  private:
  int32_t _internal_batch_size() const;
  void _internal_set_batch_size(int32_t value);
  public:

  // int32 batch_timeout_ms = 3;
  void clear_batch_timeout_ms();
  int32_t batch_timeout_ms() const;
  void set_batch_timeout_ms(int32_t value);
  private:
  int32_t _internal_batch_timeout_ms() const;
  void _internal_set_batch_timeout_ms(int32_t value);
  public:

  // int64 replay_from_sequence = 5;
  void clear_replay_from_sequence();
  int64_t replay_from_sequence() const;
  void set_replay_from_sequence(int64_t value);
  private:
  int64_t _internal_replay_from_sequence() const;
  void _internal_set_replay_from_sequence(int64_t value);
  public:

  // bool replay_from_beginning = 4;
  void clear_replay_from_beginning();
  bool replay_from_beginning() const;
  void set_replay_from_beginning(bool value);
  private:
  bool _internal_replay_from_beginning() const;
  void _internal_set_replay_from_beginning(bool value);
  public:

  // bool send_to_dlq_on_failure = 9;
  void clear_send_to_dlq_on_failure();
  bool send_to_dlq_on_failure() const;
  void set_send_to_dlq_on_failure(bool value);
  private:
  bool _internal_send_to_dlq_on_failure() const;
  void _internal_set_send_to_dlq_on_failure(bool value);
  public:

  // int32 max_retry_attempts = 7;
  void clear_max_retry_attempts();
  int32_t max_retry_attempts() const;
  void set_max_retry_attempts(int32_t value);
  private:
  int32_t _internal_max_retry_attempts() const;
  void _internal_set_max_retry_attempts(int32_t value);
  public:

  // int32 retry_backoff_ms = 8;
  void clear_retry_backoff_ms();
  int32_t retry_backoff_ms() const;
  void set_retry_backoff_ms(int32_t value);
  private:
  int32_t _internal_retry_backoff_ms() const;
  void _internal_set_retry_backoff_ms(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.cdc.SubscriptionOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr delivery_mode_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* replay_from_time_;
    int32_t batch_size_;
    int32_t batch_timeout_ms_;
    int64_t replay_from_sequence_;
    bool replay_from_beginning_;
    bool send_to_dlq_on_failure_;
    int32_t max_retry_attempts_;
    int32_t retry_backoff_ms_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class EventStreamResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.EventStreamResponse) */ {
 public:
  inline EventStreamResponse() : EventStreamResponse(nullptr) {}
  ~EventStreamResponse() override;
  explicit PROTOBUF_CONSTEXPR EventStreamResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventStreamResponse(const EventStreamResponse& from);
  EventStreamResponse(EventStreamResponse&& from) noexcept
    : EventStreamResponse() {
    *this = ::std::move(from);
  }

  inline EventStreamResponse& operator=(const EventStreamResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventStreamResponse& operator=(EventStreamResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventStreamResponse& default_instance() {
    return *internal_default_instance();
  }
  enum ResponseTypeCase {
    kEventBatch = 1,
    kStatus = 2,
    kError = 3,
    kHeartbeat = 4,
    RESPONSE_TYPE_NOT_SET = 0,
  };

  static inline const EventStreamResponse* internal_default_instance() {
    return reinterpret_cast<const EventStreamResponse*>(
               &_EventStreamResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(EventStreamResponse& a, EventStreamResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(EventStreamResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventStreamResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventStreamResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventStreamResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventStreamResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventStreamResponse& from) {
    EventStreamResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventStreamResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.EventStreamResponse";
  }
  protected:
  explicit EventStreamResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventBatchFieldNumber = 1,
    kStatusFieldNumber = 2,
    kErrorFieldNumber = 3,
    kHeartbeatFieldNumber = 4,
  };
  // .unhinged.cdc.EventBatch event_batch = 1;
  bool has_event_batch() const;
  private:
  bool _internal_has_event_batch() const;
  public:
  void clear_event_batch();
  const ::unhinged::cdc::EventBatch& event_batch() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::EventBatch* release_event_batch();
  ::unhinged::cdc::EventBatch* mutable_event_batch();
  void set_allocated_event_batch(::unhinged::cdc::EventBatch* event_batch);
  private:
  const ::unhinged::cdc::EventBatch& _internal_event_batch() const;
  ::unhinged::cdc::EventBatch* _internal_mutable_event_batch();
  public:
  void unsafe_arena_set_allocated_event_batch(
      ::unhinged::cdc::EventBatch* event_batch);
  ::unhinged::cdc::EventBatch* unsafe_arena_release_event_batch();

  // .unhinged.cdc.SubscriptionStatus status = 2;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::unhinged::cdc::SubscriptionStatus& status() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::SubscriptionStatus* release_status();
  ::unhinged::cdc::SubscriptionStatus* mutable_status();
  void set_allocated_status(::unhinged::cdc::SubscriptionStatus* status);
  private:
  const ::unhinged::cdc::SubscriptionStatus& _internal_status() const;
  ::unhinged::cdc::SubscriptionStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::unhinged::cdc::SubscriptionStatus* status);
  ::unhinged::cdc::SubscriptionStatus* unsafe_arena_release_status();

  // .unhinged.cdc.SubscriptionError error = 3;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::unhinged::cdc::SubscriptionError& error() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::SubscriptionError* release_error();
  ::unhinged::cdc::SubscriptionError* mutable_error();
  void set_allocated_error(::unhinged::cdc::SubscriptionError* error);
  private:
  const ::unhinged::cdc::SubscriptionError& _internal_error() const;
  ::unhinged::cdc::SubscriptionError* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::unhinged::cdc::SubscriptionError* error);
  ::unhinged::cdc::SubscriptionError* unsafe_arena_release_error();

  // .unhinged.cdc.Heartbeat heartbeat = 4;
  bool has_heartbeat() const;
  private:
  bool _internal_has_heartbeat() const;
  public:
  void clear_heartbeat();
  const ::unhinged::cdc::Heartbeat& heartbeat() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::Heartbeat* release_heartbeat();
  ::unhinged::cdc::Heartbeat* mutable_heartbeat();
  void set_allocated_heartbeat(::unhinged::cdc::Heartbeat* heartbeat);
  private:
  const ::unhinged::cdc::Heartbeat& _internal_heartbeat() const;
  ::unhinged::cdc::Heartbeat* _internal_mutable_heartbeat();
  public:
  void unsafe_arena_set_allocated_heartbeat(
      ::unhinged::cdc::Heartbeat* heartbeat);
  ::unhinged::cdc::Heartbeat* unsafe_arena_release_heartbeat();

  void clear_response_type();
  ResponseTypeCase response_type_case() const;
  // @@protoc_insertion_point(class_scope:unhinged.cdc.EventStreamResponse)
 private:
  class _Internal;
  void set_has_event_batch();
  void set_has_status();
  void set_has_error();
  void set_has_heartbeat();

  inline bool has_response_type() const;
  inline void clear_has_response_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ResponseTypeUnion {
      constexpr ResponseTypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::unhinged::cdc::EventBatch* event_batch_;
      ::unhinged::cdc::SubscriptionStatus* status_;
      ::unhinged::cdc::SubscriptionError* error_;
      ::unhinged::cdc::Heartbeat* heartbeat_;
    } response_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class EventBatch final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.EventBatch) */ {
 public:
  inline EventBatch() : EventBatch(nullptr) {}
  ~EventBatch() override;
  explicit PROTOBUF_CONSTEXPR EventBatch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventBatch(const EventBatch& from);
  EventBatch(EventBatch&& from) noexcept
    : EventBatch() {
    *this = ::std::move(from);
  }

  inline EventBatch& operator=(const EventBatch& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventBatch& operator=(EventBatch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventBatch& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventBatch* internal_default_instance() {
    return reinterpret_cast<const EventBatch*>(
               &_EventBatch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(EventBatch& a, EventBatch& b) {
    a.Swap(&b);
  }
  inline void Swap(EventBatch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventBatch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventBatch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventBatch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventBatch& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventBatch& from) {
    EventBatch::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventBatch* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.EventBatch";
  }
  protected:
  explicit EventBatch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventsFieldNumber = 1,
    kCheckpointTokenFieldNumber = 4,
    kBatchTimeFieldNumber = 3,
    kBatchSequenceFieldNumber = 2,
  };
  // repeated .unhinged.cdc.UniversalEvent events = 1;
  int events_size() const;
  private:
  int _internal_events_size() const;
  public:
  void clear_events();
  ::unhinged::cdc::UniversalEvent* mutable_events(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::cdc::UniversalEvent >*
      mutable_events();
  private:
  const ::unhinged::cdc::UniversalEvent& _internal_events(int index) const;
  ::unhinged::cdc::UniversalEvent* _internal_add_events();
  public:
  const ::unhinged::cdc::UniversalEvent& events(int index) const;
  ::unhinged::cdc::UniversalEvent* add_events();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::cdc::UniversalEvent >&
      events() const;

  // string checkpoint_token = 4;
  void clear_checkpoint_token();
  const std::string& checkpoint_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_checkpoint_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_checkpoint_token();
  PROTOBUF_NODISCARD std::string* release_checkpoint_token();
  void set_allocated_checkpoint_token(std::string* checkpoint_token);
  private:
  const std::string& _internal_checkpoint_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_checkpoint_token(const std::string& value);
  std::string* _internal_mutable_checkpoint_token();
  public:

  // .google.protobuf.Timestamp batch_time = 3;
  bool has_batch_time() const;
  private:
  bool _internal_has_batch_time() const;
  public:
  void clear_batch_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& batch_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_batch_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_batch_time();
  void set_allocated_batch_time(::PROTOBUF_NAMESPACE_ID::Timestamp* batch_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_batch_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_batch_time();
  public:
  void unsafe_arena_set_allocated_batch_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* batch_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_batch_time();

  // int64 batch_sequence = 2;
  void clear_batch_sequence();
  int64_t batch_sequence() const;
  void set_batch_sequence(int64_t value);
  private:
  int64_t _internal_batch_sequence() const;
  void _internal_set_batch_sequence(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.cdc.EventBatch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::cdc::UniversalEvent > events_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr checkpoint_token_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* batch_time_;
    int64_t batch_sequence_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class SubscriptionStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.SubscriptionStatus) */ {
 public:
  inline SubscriptionStatus() : SubscriptionStatus(nullptr) {}
  ~SubscriptionStatus() override;
  explicit PROTOBUF_CONSTEXPR SubscriptionStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscriptionStatus(const SubscriptionStatus& from);
  SubscriptionStatus(SubscriptionStatus&& from) noexcept
    : SubscriptionStatus() {
    *this = ::std::move(from);
  }

  inline SubscriptionStatus& operator=(const SubscriptionStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscriptionStatus& operator=(SubscriptionStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscriptionStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscriptionStatus* internal_default_instance() {
    return reinterpret_cast<const SubscriptionStatus*>(
               &_SubscriptionStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SubscriptionStatus& a, SubscriptionStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscriptionStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscriptionStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscriptionStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscriptionStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubscriptionStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubscriptionStatus& from) {
    SubscriptionStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscriptionStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.SubscriptionStatus";
  }
  protected:
  explicit SubscriptionStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kLastProcessedSequenceFieldNumber = 2,
    kEventsProcessedFieldNumber = 3,
    kEventsFailedFieldNumber = 4,
  };
  // string status = 1;
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // int64 last_processed_sequence = 2;
  void clear_last_processed_sequence();
  int64_t last_processed_sequence() const;
  void set_last_processed_sequence(int64_t value);
  private:
  int64_t _internal_last_processed_sequence() const;
  void _internal_set_last_processed_sequence(int64_t value);
  public:

  // int32 events_processed = 3;
  void clear_events_processed();
  int32_t events_processed() const;
  void set_events_processed(int32_t value);
  private:
  int32_t _internal_events_processed() const;
  void _internal_set_events_processed(int32_t value);
  public:

  // int32 events_failed = 4;
  void clear_events_failed();
  int32_t events_failed() const;
  void set_events_failed(int32_t value);
  private:
  int32_t _internal_events_failed() const;
  void _internal_set_events_failed(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.cdc.SubscriptionStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
    int64_t last_processed_sequence_;
    int32_t events_processed_;
    int32_t events_failed_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class SubscriptionError final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.SubscriptionError) */ {
 public:
  inline SubscriptionError() : SubscriptionError(nullptr) {}
  ~SubscriptionError() override;
  explicit PROTOBUF_CONSTEXPR SubscriptionError(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscriptionError(const SubscriptionError& from);
  SubscriptionError(SubscriptionError&& from) noexcept
    : SubscriptionError() {
    *this = ::std::move(from);
  }

  inline SubscriptionError& operator=(const SubscriptionError& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscriptionError& operator=(SubscriptionError&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscriptionError& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscriptionError* internal_default_instance() {
    return reinterpret_cast<const SubscriptionError*>(
               &_SubscriptionError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SubscriptionError& a, SubscriptionError& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscriptionError* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscriptionError* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscriptionError* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscriptionError>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubscriptionError& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubscriptionError& from) {
    SubscriptionError::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscriptionError* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.SubscriptionError";
  }
  protected:
  explicit SubscriptionError(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorCodeFieldNumber = 1,
    kErrorMessageFieldNumber = 2,
    kIsRecoverableFieldNumber = 3,
    kRetryCountFieldNumber = 4,
  };
  // string error_code = 1;
  void clear_error_code();
  const std::string& error_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_code();
  PROTOBUF_NODISCARD std::string* release_error_code();
  void set_allocated_error_code(std::string* error_code);
  private:
  const std::string& _internal_error_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_code(const std::string& value);
  std::string* _internal_mutable_error_code();
  public:

  // string error_message = 2;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // bool is_recoverable = 3;
  void clear_is_recoverable();
  bool is_recoverable() const;
  void set_is_recoverable(bool value);
  private:
  bool _internal_is_recoverable() const;
  void _internal_set_is_recoverable(bool value);
  public:

  // int32 retry_count = 4;
  void clear_retry_count();
  int32_t retry_count() const;
  void set_retry_count(int32_t value);
  private:
  int32_t _internal_retry_count() const;
  void _internal_set_retry_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.cdc.SubscriptionError)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_code_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    bool is_recoverable_;
    int32_t retry_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class Heartbeat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.Heartbeat) */ {
 public:
  inline Heartbeat() : Heartbeat(nullptr) {}
  ~Heartbeat() override;
  explicit PROTOBUF_CONSTEXPR Heartbeat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Heartbeat(const Heartbeat& from);
  Heartbeat(Heartbeat&& from) noexcept
    : Heartbeat() {
    *this = ::std::move(from);
  }

  inline Heartbeat& operator=(const Heartbeat& from) {
    CopyFrom(from);
    return *this;
  }
  inline Heartbeat& operator=(Heartbeat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Heartbeat& default_instance() {
    return *internal_default_instance();
  }
  static inline const Heartbeat* internal_default_instance() {
    return reinterpret_cast<const Heartbeat*>(
               &_Heartbeat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Heartbeat& a, Heartbeat& b) {
    a.Swap(&b);
  }
  inline void Swap(Heartbeat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Heartbeat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Heartbeat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Heartbeat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Heartbeat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Heartbeat& from) {
    Heartbeat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Heartbeat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.Heartbeat";
  }
  protected:
  explicit Heartbeat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
    kCurrentSequenceFieldNumber = 2,
  };
  // .google.protobuf.Timestamp timestamp = 1;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // int64 current_sequence = 2;
  void clear_current_sequence();
  int64_t current_sequence() const;
  void set_current_sequence(int64_t value);
  private:
  int64_t _internal_current_sequence() const;
  void _internal_set_current_sequence(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.cdc.Heartbeat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
    int64_t current_sequence_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class AcknowledgeEventsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.AcknowledgeEventsRequest) */ {
 public:
  inline AcknowledgeEventsRequest() : AcknowledgeEventsRequest(nullptr) {}
  ~AcknowledgeEventsRequest() override;
  explicit PROTOBUF_CONSTEXPR AcknowledgeEventsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AcknowledgeEventsRequest(const AcknowledgeEventsRequest& from);
  AcknowledgeEventsRequest(AcknowledgeEventsRequest&& from) noexcept
    : AcknowledgeEventsRequest() {
    *this = ::std::move(from);
  }

  inline AcknowledgeEventsRequest& operator=(const AcknowledgeEventsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AcknowledgeEventsRequest& operator=(AcknowledgeEventsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AcknowledgeEventsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AcknowledgeEventsRequest* internal_default_instance() {
    return reinterpret_cast<const AcknowledgeEventsRequest*>(
               &_AcknowledgeEventsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(AcknowledgeEventsRequest& a, AcknowledgeEventsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AcknowledgeEventsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AcknowledgeEventsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AcknowledgeEventsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AcknowledgeEventsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AcknowledgeEventsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AcknowledgeEventsRequest& from) {
    AcknowledgeEventsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AcknowledgeEventsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.AcknowledgeEventsRequest";
  }
  protected:
  explicit AcknowledgeEventsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventIdsFieldNumber = 2,
    kSubscriberIdFieldNumber = 1,
    kCheckpointTokenFieldNumber = 3,
  };
  // repeated string event_ids = 2;
  int event_ids_size() const;
  private:
  int _internal_event_ids_size() const;
  public:
  void clear_event_ids();
  const std::string& event_ids(int index) const;
  std::string* mutable_event_ids(int index);
  void set_event_ids(int index, const std::string& value);
  void set_event_ids(int index, std::string&& value);
  void set_event_ids(int index, const char* value);
  void set_event_ids(int index, const char* value, size_t size);
  std::string* add_event_ids();
  void add_event_ids(const std::string& value);
  void add_event_ids(std::string&& value);
  void add_event_ids(const char* value);
  void add_event_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& event_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_event_ids();
  private:
  const std::string& _internal_event_ids(int index) const;
  std::string* _internal_add_event_ids();
  public:

  // string subscriber_id = 1;
  void clear_subscriber_id();
  const std::string& subscriber_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_subscriber_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_subscriber_id();
  PROTOBUF_NODISCARD std::string* release_subscriber_id();
  void set_allocated_subscriber_id(std::string* subscriber_id);
  private:
  const std::string& _internal_subscriber_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subscriber_id(const std::string& value);
  std::string* _internal_mutable_subscriber_id();
  public:

  // string checkpoint_token = 3;
  void clear_checkpoint_token();
  const std::string& checkpoint_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_checkpoint_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_checkpoint_token();
  PROTOBUF_NODISCARD std::string* release_checkpoint_token();
  void set_allocated_checkpoint_token(std::string* checkpoint_token);
  private:
  const std::string& _internal_checkpoint_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_checkpoint_token(const std::string& value);
  std::string* _internal_mutable_checkpoint_token();
  public:

  // @@protoc_insertion_point(class_scope:unhinged.cdc.AcknowledgeEventsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> event_ids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subscriber_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr checkpoint_token_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class AcknowledgeEventsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.AcknowledgeEventsResponse) */ {
 public:
  inline AcknowledgeEventsResponse() : AcknowledgeEventsResponse(nullptr) {}
  ~AcknowledgeEventsResponse() override;
  explicit PROTOBUF_CONSTEXPR AcknowledgeEventsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AcknowledgeEventsResponse(const AcknowledgeEventsResponse& from);
  AcknowledgeEventsResponse(AcknowledgeEventsResponse&& from) noexcept
    : AcknowledgeEventsResponse() {
    *this = ::std::move(from);
  }

  inline AcknowledgeEventsResponse& operator=(const AcknowledgeEventsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AcknowledgeEventsResponse& operator=(AcknowledgeEventsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AcknowledgeEventsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AcknowledgeEventsResponse* internal_default_instance() {
    return reinterpret_cast<const AcknowledgeEventsResponse*>(
               &_AcknowledgeEventsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(AcknowledgeEventsResponse& a, AcknowledgeEventsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AcknowledgeEventsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AcknowledgeEventsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AcknowledgeEventsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AcknowledgeEventsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AcknowledgeEventsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AcknowledgeEventsResponse& from) {
    AcknowledgeEventsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AcknowledgeEventsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.AcknowledgeEventsResponse";
  }
  protected:
  explicit AcknowledgeEventsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kSuccessFieldNumber = 1,
    kAcknowledgedCountFieldNumber = 3,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // int32 acknowledged_count = 3;
  void clear_acknowledged_count();
  int32_t acknowledged_count() const;
  void set_acknowledged_count(int32_t value);
  private:
  int32_t _internal_acknowledged_count() const;
  void _internal_set_acknowledged_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.cdc.AcknowledgeEventsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    bool success_;
    int32_t acknowledged_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ReplayEventsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.ReplayEventsRequest) */ {
 public:
  inline ReplayEventsRequest() : ReplayEventsRequest(nullptr) {}
  ~ReplayEventsRequest() override;
  explicit PROTOBUF_CONSTEXPR ReplayEventsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReplayEventsRequest(const ReplayEventsRequest& from);
  ReplayEventsRequest(ReplayEventsRequest&& from) noexcept
    : ReplayEventsRequest() {
    *this = ::std::move(from);
  }

  inline ReplayEventsRequest& operator=(const ReplayEventsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReplayEventsRequest& operator=(ReplayEventsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReplayEventsRequest& default_instance() {
    return *internal_default_instance();
  }
  enum ReplayRangeCase {
    kTimeRange = 2,
    kSequenceRange = 3,
    kCheckpointToken = 4,
    REPLAY_RANGE_NOT_SET = 0,
  };

  static inline const ReplayEventsRequest* internal_default_instance() {
    return reinterpret_cast<const ReplayEventsRequest*>(
               &_ReplayEventsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ReplayEventsRequest& a, ReplayEventsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ReplayEventsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReplayEventsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReplayEventsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReplayEventsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReplayEventsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReplayEventsRequest& from) {
    ReplayEventsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReplayEventsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.ReplayEventsRequest";
  }
  protected:
  explicit ReplayEventsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubscriberIdFieldNumber = 1,
    kFilterFieldNumber = 5,
    kBatchSizeFieldNumber = 6,
    kIncludeFailedEventsFieldNumber = 7,
    kTimeRangeFieldNumber = 2,
    kSequenceRangeFieldNumber = 3,
    kCheckpointTokenFieldNumber = 4,
  };
  // string subscriber_id = 1;
  void clear_subscriber_id();
  const std::string& subscriber_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_subscriber_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_subscriber_id();
  PROTOBUF_NODISCARD std::string* release_subscriber_id();
  void set_allocated_subscriber_id(std::string* subscriber_id);
  private:
  const std::string& _internal_subscriber_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subscriber_id(const std::string& value);
  std::string* _internal_mutable_subscriber_id();
  public:

  // .unhinged.cdc.EventFilter filter = 5;
  bool has_filter() const;
  private:
  bool _internal_has_filter() const;
  public:
  void clear_filter();
  const ::unhinged::cdc::EventFilter& filter() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::EventFilter* release_filter();
  ::unhinged::cdc::EventFilter* mutable_filter();
  void set_allocated_filter(::unhinged::cdc::EventFilter* filter);
  private:
  const ::unhinged::cdc::EventFilter& _internal_filter() const;
  ::unhinged::cdc::EventFilter* _internal_mutable_filter();
  public:
  void unsafe_arena_set_allocated_filter(
      ::unhinged::cdc::EventFilter* filter);
  ::unhinged::cdc::EventFilter* unsafe_arena_release_filter();

  // int32 batch_size = 6;
  void clear_batch_size();
  int32_t batch_size() const;
  void set_batch_size(int32_t value);
  private:
  int32_t _internal_batch_size() const;
  void _internal_set_batch_size(int32_t value);
  public:

  // bool include_failed_events = 7;
  void clear_include_failed_events();
  bool include_failed_events() const;
  void set_include_failed_events(bool value);
  private:
  bool _internal_include_failed_events() const;
  void _internal_set_include_failed_events(bool value);
  public:

  // .unhinged.cdc.TimeRange time_range = 2;
  bool has_time_range() const;
  private:
  bool _internal_has_time_range() const;
  public:
  void clear_time_range();
  const ::unhinged::cdc::TimeRange& time_range() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::TimeRange* release_time_range();
  ::unhinged::cdc::TimeRange* mutable_time_range();
  void set_allocated_time_range(::unhinged::cdc::TimeRange* time_range);
  private:
  const ::unhinged::cdc::TimeRange& _internal_time_range() const;
  ::unhinged::cdc::TimeRange* _internal_mutable_time_range();
  public:
  void unsafe_arena_set_allocated_time_range(
      ::unhinged::cdc::TimeRange* time_range);
  ::unhinged::cdc::TimeRange* unsafe_arena_release_time_range();

  // .unhinged.cdc.SequenceRange sequence_range = 3;
  bool has_sequence_range() const;
  private:
  bool _internal_has_sequence_range() const;
  public:
  void clear_sequence_range();
  const ::unhinged::cdc::SequenceRange& sequence_range() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::SequenceRange* release_sequence_range();
  ::unhinged::cdc::SequenceRange* mutable_sequence_range();
  void set_allocated_sequence_range(::unhinged::cdc::SequenceRange* sequence_range);
  private:
  const ::unhinged::cdc::SequenceRange& _internal_sequence_range() const;
  ::unhinged::cdc::SequenceRange* _internal_mutable_sequence_range();
  public:
  void unsafe_arena_set_allocated_sequence_range(
      ::unhinged::cdc::SequenceRange* sequence_range);
  ::unhinged::cdc::SequenceRange* unsafe_arena_release_sequence_range();

  // string checkpoint_token = 4;
  bool has_checkpoint_token() const;
  private:
  bool _internal_has_checkpoint_token() const;
  public:
  void clear_checkpoint_token();
  const std::string& checkpoint_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_checkpoint_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_checkpoint_token();
  PROTOBUF_NODISCARD std::string* release_checkpoint_token();
  void set_allocated_checkpoint_token(std::string* checkpoint_token);
  private:
  const std::string& _internal_checkpoint_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_checkpoint_token(const std::string& value);
  std::string* _internal_mutable_checkpoint_token();
  public:

  void clear_replay_range();
  ReplayRangeCase replay_range_case() const;
  // @@protoc_insertion_point(class_scope:unhinged.cdc.ReplayEventsRequest)
 private:
  class _Internal;
  void set_has_time_range();
  void set_has_sequence_range();
  void set_has_checkpoint_token();

  inline bool has_replay_range() const;
  inline void clear_has_replay_range();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subscriber_id_;
    ::unhinged::cdc::EventFilter* filter_;
    int32_t batch_size_;
    bool include_failed_events_;
    union ReplayRangeUnion {
      constexpr ReplayRangeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::unhinged::cdc::TimeRange* time_range_;
      ::unhinged::cdc::SequenceRange* sequence_range_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr checkpoint_token_;
    } replay_range_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class TimeRange final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.TimeRange) */ {
 public:
  inline TimeRange() : TimeRange(nullptr) {}
  ~TimeRange() override;
  explicit PROTOBUF_CONSTEXPR TimeRange(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TimeRange(const TimeRange& from);
  TimeRange(TimeRange&& from) noexcept
    : TimeRange() {
    *this = ::std::move(from);
  }

  inline TimeRange& operator=(const TimeRange& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimeRange& operator=(TimeRange&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TimeRange& default_instance() {
    return *internal_default_instance();
  }
  static inline const TimeRange* internal_default_instance() {
    return reinterpret_cast<const TimeRange*>(
               &_TimeRange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(TimeRange& a, TimeRange& b) {
    a.Swap(&b);
  }
  inline void Swap(TimeRange* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TimeRange* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TimeRange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TimeRange>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TimeRange& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TimeRange& from) {
    TimeRange::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TimeRange* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.TimeRange";
  }
  protected:
  explicit TimeRange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartTimeFieldNumber = 1,
    kEndTimeFieldNumber = 2,
  };
  // .google.protobuf.Timestamp start_time = 1;
  bool has_start_time() const;
  private:
  bool _internal_has_start_time() const;
  public:
  void clear_start_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& start_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_start_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_start_time();
  void set_allocated_start_time(::PROTOBUF_NAMESPACE_ID::Timestamp* start_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_start_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_start_time();
  public:
  void unsafe_arena_set_allocated_start_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_start_time();

  // .google.protobuf.Timestamp end_time = 2;
  bool has_end_time() const;
  private:
  bool _internal_has_end_time() const;
  public:
  void clear_end_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& end_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_end_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_end_time();
  void set_allocated_end_time(::PROTOBUF_NAMESPACE_ID::Timestamp* end_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_end_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_end_time();
  public:
  void unsafe_arena_set_allocated_end_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_end_time();

  // @@protoc_insertion_point(class_scope:unhinged.cdc.TimeRange)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class SequenceRange final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.SequenceRange) */ {
 public:
  inline SequenceRange() : SequenceRange(nullptr) {}
  ~SequenceRange() override;
  explicit PROTOBUF_CONSTEXPR SequenceRange(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SequenceRange(const SequenceRange& from);
  SequenceRange(SequenceRange&& from) noexcept
    : SequenceRange() {
    *this = ::std::move(from);
  }

  inline SequenceRange& operator=(const SequenceRange& from) {
    CopyFrom(from);
    return *this;
  }
  inline SequenceRange& operator=(SequenceRange&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SequenceRange& default_instance() {
    return *internal_default_instance();
  }
  static inline const SequenceRange* internal_default_instance() {
    return reinterpret_cast<const SequenceRange*>(
               &_SequenceRange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(SequenceRange& a, SequenceRange& b) {
    a.Swap(&b);
  }
  inline void Swap(SequenceRange* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SequenceRange* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SequenceRange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SequenceRange>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SequenceRange& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SequenceRange& from) {
    SequenceRange::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SequenceRange* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.SequenceRange";
  }
  protected:
  explicit SequenceRange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartSequenceFieldNumber = 1,
    kEndSequenceFieldNumber = 2,
  };
  // int64 start_sequence = 1;
  void clear_start_sequence();
  int64_t start_sequence() const;
  void set_start_sequence(int64_t value);
  private:
  int64_t _internal_start_sequence() const;
  void _internal_set_start_sequence(int64_t value);
  public:

  // int64 end_sequence = 2;
  void clear_end_sequence();
  int64_t end_sequence() const;
  void set_end_sequence(int64_t value);
  private:
  int64_t _internal_end_sequence() const;
  void _internal_set_end_sequence(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.cdc.SequenceRange)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t start_sequence_;
    int64_t end_sequence_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ListDeadLetterEventsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.ListDeadLetterEventsRequest) */ {
 public:
  inline ListDeadLetterEventsRequest() : ListDeadLetterEventsRequest(nullptr) {}
  ~ListDeadLetterEventsRequest() override;
  explicit PROTOBUF_CONSTEXPR ListDeadLetterEventsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListDeadLetterEventsRequest(const ListDeadLetterEventsRequest& from);
  ListDeadLetterEventsRequest(ListDeadLetterEventsRequest&& from) noexcept
    : ListDeadLetterEventsRequest() {
    *this = ::std::move(from);
  }

  inline ListDeadLetterEventsRequest& operator=(const ListDeadLetterEventsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListDeadLetterEventsRequest& operator=(ListDeadLetterEventsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListDeadLetterEventsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListDeadLetterEventsRequest* internal_default_instance() {
    return reinterpret_cast<const ListDeadLetterEventsRequest*>(
               &_ListDeadLetterEventsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ListDeadLetterEventsRequest& a, ListDeadLetterEventsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListDeadLetterEventsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListDeadLetterEventsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListDeadLetterEventsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListDeadLetterEventsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListDeadLetterEventsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListDeadLetterEventsRequest& from) {
    ListDeadLetterEventsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListDeadLetterEventsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.ListDeadLetterEventsRequest";
  }
  protected:
  explicit ListDeadLetterEventsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubscriberIdFieldNumber = 1,
    kPageTokenFieldNumber = 4,
    kSinceFieldNumber = 2,
    kPageSizeFieldNumber = 3,
  };
  // string subscriber_id = 1;
  void clear_subscriber_id();
  const std::string& subscriber_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_subscriber_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_subscriber_id();
  PROTOBUF_NODISCARD std::string* release_subscriber_id();
  void set_allocated_subscriber_id(std::string* subscriber_id);
  private:
  const std::string& _internal_subscriber_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subscriber_id(const std::string& value);
  std::string* _internal_mutable_subscriber_id();
  public:

  // string page_token = 4;
  void clear_page_token();
  const std::string& page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_page_token();
  PROTOBUF_NODISCARD std::string* release_page_token();
  void set_allocated_page_token(std::string* page_token);
  private:
  const std::string& _internal_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(const std::string& value);
  std::string* _internal_mutable_page_token();
  public:

  // .google.protobuf.Timestamp since = 2;
  bool has_since() const;
  private:
  bool _internal_has_since() const;
  public:
  void clear_since();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& since() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_since();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_since();
  void set_allocated_since(::PROTOBUF_NAMESPACE_ID::Timestamp* since);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_since() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_since();
  public:
  void unsafe_arena_set_allocated_since(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* since);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_since();

  // int32 page_size = 3;
  void clear_page_size();
  int32_t page_size() const;
  void set_page_size(int32_t value);
  private:
  int32_t _internal_page_size() const;
  void _internal_set_page_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.cdc.ListDeadLetterEventsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subscriber_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr page_token_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* since_;
    int32_t page_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ListDeadLetterEventsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.ListDeadLetterEventsResponse) */ {
 public:
  inline ListDeadLetterEventsResponse() : ListDeadLetterEventsResponse(nullptr) {}
  ~ListDeadLetterEventsResponse() override;
  explicit PROTOBUF_CONSTEXPR ListDeadLetterEventsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListDeadLetterEventsResponse(const ListDeadLetterEventsResponse& from);
  ListDeadLetterEventsResponse(ListDeadLetterEventsResponse&& from) noexcept
    : ListDeadLetterEventsResponse() {
    *this = ::std::move(from);
  }

  inline ListDeadLetterEventsResponse& operator=(const ListDeadLetterEventsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListDeadLetterEventsResponse& operator=(ListDeadLetterEventsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListDeadLetterEventsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListDeadLetterEventsResponse* internal_default_instance() {
    return reinterpret_cast<const ListDeadLetterEventsResponse*>(
               &_ListDeadLetterEventsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ListDeadLetterEventsResponse& a, ListDeadLetterEventsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListDeadLetterEventsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListDeadLetterEventsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListDeadLetterEventsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListDeadLetterEventsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListDeadLetterEventsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListDeadLetterEventsResponse& from) {
    ListDeadLetterEventsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListDeadLetterEventsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.ListDeadLetterEventsResponse";
  }
  protected:
  explicit ListDeadLetterEventsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventsFieldNumber = 1,
    kNextPageTokenFieldNumber = 2,
    kTotalCountFieldNumber = 3,
  };
  // repeated .unhinged.cdc.DeadLetterEvent events = 1;
  int events_size() const;
  private:
  int _internal_events_size() const;
  public:
  void clear_events();
  ::unhinged::cdc::DeadLetterEvent* mutable_events(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::cdc::DeadLetterEvent >*
      mutable_events();
  private:
  const ::unhinged::cdc::DeadLetterEvent& _internal_events(int index) const;
  ::unhinged::cdc::DeadLetterEvent* _internal_add_events();
  public:
  const ::unhinged::cdc::DeadLetterEvent& events(int index) const;
  ::unhinged::cdc::DeadLetterEvent* add_events();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::cdc::DeadLetterEvent >&
      events() const;

  // string next_page_token = 2;
  void clear_next_page_token();
  const std::string& next_page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_page_token();
  PROTOBUF_NODISCARD std::string* release_next_page_token();
  void set_allocated_next_page_token(std::string* next_page_token);
  private:
  const std::string& _internal_next_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(const std::string& value);
  std::string* _internal_mutable_next_page_token();
  public:

  // int32 total_count = 3;
  void clear_total_count();
  int32_t total_count() const;
  void set_total_count(int32_t value);
  private:
  int32_t _internal_total_count() const;
  void _internal_set_total_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.cdc.ListDeadLetterEventsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::cdc::DeadLetterEvent > events_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_page_token_;
    int32_t total_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class DeadLetterEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.DeadLetterEvent) */ {
 public:
  inline DeadLetterEvent() : DeadLetterEvent(nullptr) {}
  ~DeadLetterEvent() override;
  explicit PROTOBUF_CONSTEXPR DeadLetterEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeadLetterEvent(const DeadLetterEvent& from);
  DeadLetterEvent(DeadLetterEvent&& from) noexcept
    : DeadLetterEvent() {
    *this = ::std::move(from);
  }

  inline DeadLetterEvent& operator=(const DeadLetterEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeadLetterEvent& operator=(DeadLetterEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeadLetterEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeadLetterEvent* internal_default_instance() {
    return reinterpret_cast<const DeadLetterEvent*>(
               &_DeadLetterEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(DeadLetterEvent& a, DeadLetterEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(DeadLetterEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeadLetterEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeadLetterEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeadLetterEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeadLetterEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeadLetterEvent& from) {
    DeadLetterEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeadLetterEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.DeadLetterEvent";
  }
  protected:
  explicit DeadLetterEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFailureReasonFieldNumber = 2,
    kOriginalEventFieldNumber = 1,
    kFailedAtFieldNumber = 4,
    kLastRetryAtFieldNumber = 5,
    kRetryCountFieldNumber = 3,
  };
  // string failure_reason = 2;
  void clear_failure_reason();
  const std::string& failure_reason() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_failure_reason(ArgT0&& arg0, ArgT... args);
  std::string* mutable_failure_reason();
  PROTOBUF_NODISCARD std::string* release_failure_reason();
  void set_allocated_failure_reason(std::string* failure_reason);
  private:
  const std::string& _internal_failure_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_failure_reason(const std::string& value);
  std::string* _internal_mutable_failure_reason();
  public:

  // .unhinged.cdc.UniversalEvent original_event = 1;
  bool has_original_event() const;
  private:
  bool _internal_has_original_event() const;
  public:
  void clear_original_event();
  const ::unhinged::cdc::UniversalEvent& original_event() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::UniversalEvent* release_original_event();
  ::unhinged::cdc::UniversalEvent* mutable_original_event();
  void set_allocated_original_event(::unhinged::cdc::UniversalEvent* original_event);
  private:
  const ::unhinged::cdc::UniversalEvent& _internal_original_event() const;
  ::unhinged::cdc::UniversalEvent* _internal_mutable_original_event();
  public:
  void unsafe_arena_set_allocated_original_event(
      ::unhinged::cdc::UniversalEvent* original_event);
  ::unhinged::cdc::UniversalEvent* unsafe_arena_release_original_event();

  // .google.protobuf.Timestamp failed_at = 4;
  bool has_failed_at() const;
  private:
  bool _internal_has_failed_at() const;
  public:
  void clear_failed_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& failed_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_failed_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_failed_at();
  void set_allocated_failed_at(::PROTOBUF_NAMESPACE_ID::Timestamp* failed_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_failed_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_failed_at();
  public:
  void unsafe_arena_set_allocated_failed_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* failed_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_failed_at();

  // .google.protobuf.Timestamp last_retry_at = 5;
  bool has_last_retry_at() const;
  private:
  bool _internal_has_last_retry_at() const;
  public:
  void clear_last_retry_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& last_retry_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_last_retry_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_last_retry_at();
  void set_allocated_last_retry_at(::PROTOBUF_NAMESPACE_ID::Timestamp* last_retry_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_last_retry_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_last_retry_at();
  public:
  void unsafe_arena_set_allocated_last_retry_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* last_retry_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_last_retry_at();

  // int32 retry_count = 3;
  void clear_retry_count();
  int32_t retry_count() const;
  void set_retry_count(int32_t value);
  private:
  int32_t _internal_retry_count() const;
  void _internal_set_retry_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.cdc.DeadLetterEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr failure_reason_;
    ::unhinged::cdc::UniversalEvent* original_event_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* failed_at_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_retry_at_;
    int32_t retry_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ReprocessDeadLetterEventsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.ReprocessDeadLetterEventsRequest) */ {
 public:
  inline ReprocessDeadLetterEventsRequest() : ReprocessDeadLetterEventsRequest(nullptr) {}
  ~ReprocessDeadLetterEventsRequest() override;
  explicit PROTOBUF_CONSTEXPR ReprocessDeadLetterEventsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReprocessDeadLetterEventsRequest(const ReprocessDeadLetterEventsRequest& from);
  ReprocessDeadLetterEventsRequest(ReprocessDeadLetterEventsRequest&& from) noexcept
    : ReprocessDeadLetterEventsRequest() {
    *this = ::std::move(from);
  }

  inline ReprocessDeadLetterEventsRequest& operator=(const ReprocessDeadLetterEventsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReprocessDeadLetterEventsRequest& operator=(ReprocessDeadLetterEventsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReprocessDeadLetterEventsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReprocessDeadLetterEventsRequest* internal_default_instance() {
    return reinterpret_cast<const ReprocessDeadLetterEventsRequest*>(
               &_ReprocessDeadLetterEventsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(ReprocessDeadLetterEventsRequest& a, ReprocessDeadLetterEventsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ReprocessDeadLetterEventsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReprocessDeadLetterEventsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReprocessDeadLetterEventsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReprocessDeadLetterEventsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReprocessDeadLetterEventsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReprocessDeadLetterEventsRequest& from) {
    ReprocessDeadLetterEventsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReprocessDeadLetterEventsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.ReprocessDeadLetterEventsRequest";
  }
  protected:
  explicit ReprocessDeadLetterEventsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventIdsFieldNumber = 2,
    kSubscriberIdFieldNumber = 1,
    kResetRetryCountFieldNumber = 3,
  };
  // repeated string event_ids = 2;
  int event_ids_size() const;
  private:
  int _internal_event_ids_size() const;
  public:
  void clear_event_ids();
  const std::string& event_ids(int index) const;
  std::string* mutable_event_ids(int index);
  void set_event_ids(int index, const std::string& value);
  void set_event_ids(int index, std::string&& value);
  void set_event_ids(int index, const char* value);
  void set_event_ids(int index, const char* value, size_t size);
  std::string* add_event_ids();
  void add_event_ids(const std::string& value);
  void add_event_ids(std::string&& value);
  void add_event_ids(const char* value);
  void add_event_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& event_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_event_ids();
  private:
  const std::string& _internal_event_ids(int index) const;
  std::string* _internal_add_event_ids();
  public:

  // string subscriber_id = 1;
  void clear_subscriber_id();
  const std::string& subscriber_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_subscriber_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_subscriber_id();
  PROTOBUF_NODISCARD std::string* release_subscriber_id();
  void set_allocated_subscriber_id(std::string* subscriber_id);
  private:
  const std::string& _internal_subscriber_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subscriber_id(const std::string& value);
  std::string* _internal_mutable_subscriber_id();
  public:

  // bool reset_retry_count = 3;
  void clear_reset_retry_count();
  bool reset_retry_count() const;
  void set_reset_retry_count(bool value);
  private:
  bool _internal_reset_retry_count() const;
  void _internal_set_reset_retry_count(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.cdc.ReprocessDeadLetterEventsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> event_ids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subscriber_id_;
    bool reset_retry_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ReprocessDeadLetterEventsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.ReprocessDeadLetterEventsResponse) */ {
 public:
  inline ReprocessDeadLetterEventsResponse() : ReprocessDeadLetterEventsResponse(nullptr) {}
  ~ReprocessDeadLetterEventsResponse() override;
  explicit PROTOBUF_CONSTEXPR ReprocessDeadLetterEventsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReprocessDeadLetterEventsResponse(const ReprocessDeadLetterEventsResponse& from);
  ReprocessDeadLetterEventsResponse(ReprocessDeadLetterEventsResponse&& from) noexcept
    : ReprocessDeadLetterEventsResponse() {
    *this = ::std::move(from);
  }

  inline ReprocessDeadLetterEventsResponse& operator=(const ReprocessDeadLetterEventsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReprocessDeadLetterEventsResponse& operator=(ReprocessDeadLetterEventsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReprocessDeadLetterEventsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReprocessDeadLetterEventsResponse* internal_default_instance() {
    return reinterpret_cast<const ReprocessDeadLetterEventsResponse*>(
               &_ReprocessDeadLetterEventsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(ReprocessDeadLetterEventsResponse& a, ReprocessDeadLetterEventsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ReprocessDeadLetterEventsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReprocessDeadLetterEventsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReprocessDeadLetterEventsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReprocessDeadLetterEventsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReprocessDeadLetterEventsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReprocessDeadLetterEventsResponse& from) {
    ReprocessDeadLetterEventsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReprocessDeadLetterEventsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.ReprocessDeadLetterEventsResponse";
  }
  protected:
  explicit ReprocessDeadLetterEventsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kSuccessFieldNumber = 1,
    kReprocessedCountFieldNumber = 3,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // int32 reprocessed_count = 3;
  void clear_reprocessed_count();
  int32_t reprocessed_count() const;
  void set_reprocessed_count(int32_t value);
  private:
  int32_t _internal_reprocessed_count() const;
  void _internal_set_reprocessed_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.cdc.ReprocessDeadLetterEventsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    bool success_;
    int32_t reprocessed_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class GetEventStatsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.GetEventStatsRequest) */ {
 public:
  inline GetEventStatsRequest() : GetEventStatsRequest(nullptr) {}
  ~GetEventStatsRequest() override;
  explicit PROTOBUF_CONSTEXPR GetEventStatsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetEventStatsRequest(const GetEventStatsRequest& from);
  GetEventStatsRequest(GetEventStatsRequest&& from) noexcept
    : GetEventStatsRequest() {
    *this = ::std::move(from);
  }

  inline GetEventStatsRequest& operator=(const GetEventStatsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetEventStatsRequest& operator=(GetEventStatsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetEventStatsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetEventStatsRequest* internal_default_instance() {
    return reinterpret_cast<const GetEventStatsRequest*>(
               &_GetEventStatsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(GetEventStatsRequest& a, GetEventStatsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetEventStatsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetEventStatsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetEventStatsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetEventStatsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetEventStatsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetEventStatsRequest& from) {
    GetEventStatsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetEventStatsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.GetEventStatsRequest";
  }
  protected:
  explicit GetEventStatsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventTypesFieldNumber = 3,
    kSourceServicesFieldNumber = 4,
    kAggregationIntervalFieldNumber = 5,
    kStartTimeFieldNumber = 1,
    kEndTimeFieldNumber = 2,
  };
  // repeated string event_types = 3;
  int event_types_size() const;
  private:
  int _internal_event_types_size() const;
  public:
  void clear_event_types();
  const std::string& event_types(int index) const;
  std::string* mutable_event_types(int index);
  void set_event_types(int index, const std::string& value);
  void set_event_types(int index, std::string&& value);
  void set_event_types(int index, const char* value);
  void set_event_types(int index, const char* value, size_t size);
  std::string* add_event_types();
  void add_event_types(const std::string& value);
  void add_event_types(std::string&& value);
  void add_event_types(const char* value);
  void add_event_types(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& event_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_event_types();
  private:
  const std::string& _internal_event_types(int index) const;
  std::string* _internal_add_event_types();
  public:

  // repeated string source_services = 4;
  int source_services_size() const;
  private:
  int _internal_source_services_size() const;
  public:
  void clear_source_services();
  const std::string& source_services(int index) const;
  std::string* mutable_source_services(int index);
  void set_source_services(int index, const std::string& value);
  void set_source_services(int index, std::string&& value);
  void set_source_services(int index, const char* value);
  void set_source_services(int index, const char* value, size_t size);
  std::string* add_source_services();
  void add_source_services(const std::string& value);
  void add_source_services(std::string&& value);
  void add_source_services(const char* value);
  void add_source_services(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& source_services() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_source_services();
  private:
  const std::string& _internal_source_services(int index) const;
  std::string* _internal_add_source_services();
  public:

  // string aggregation_interval = 5;
  void clear_aggregation_interval();
  const std::string& aggregation_interval() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_aggregation_interval(ArgT0&& arg0, ArgT... args);
  std::string* mutable_aggregation_interval();
  PROTOBUF_NODISCARD std::string* release_aggregation_interval();
  void set_allocated_aggregation_interval(std::string* aggregation_interval);
  private:
  const std::string& _internal_aggregation_interval() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_aggregation_interval(const std::string& value);
  std::string* _internal_mutable_aggregation_interval();
  public:

  // .google.protobuf.Timestamp start_time = 1;
  bool has_start_time() const;
  private:
  bool _internal_has_start_time() const;
  public:
  void clear_start_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& start_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_start_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_start_time();
  void set_allocated_start_time(::PROTOBUF_NAMESPACE_ID::Timestamp* start_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_start_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_start_time();
  public:
  void unsafe_arena_set_allocated_start_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_start_time();

  // .google.protobuf.Timestamp end_time = 2;
  bool has_end_time() const;
  private:
  bool _internal_has_end_time() const;
  public:
  void clear_end_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& end_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_end_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_end_time();
  void set_allocated_end_time(::PROTOBUF_NAMESPACE_ID::Timestamp* end_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_end_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_end_time();
  public:
  void unsafe_arena_set_allocated_end_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_end_time();

  // @@protoc_insertion_point(class_scope:unhinged.cdc.GetEventStatsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> event_types_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> source_services_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr aggregation_interval_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class GetEventStatsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.GetEventStatsResponse) */ {
 public:
  inline GetEventStatsResponse() : GetEventStatsResponse(nullptr) {}
  ~GetEventStatsResponse() override;
  explicit PROTOBUF_CONSTEXPR GetEventStatsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetEventStatsResponse(const GetEventStatsResponse& from);
  GetEventStatsResponse(GetEventStatsResponse&& from) noexcept
    : GetEventStatsResponse() {
    *this = ::std::move(from);
  }

  inline GetEventStatsResponse& operator=(const GetEventStatsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetEventStatsResponse& operator=(GetEventStatsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetEventStatsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetEventStatsResponse* internal_default_instance() {
    return reinterpret_cast<const GetEventStatsResponse*>(
               &_GetEventStatsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(GetEventStatsResponse& a, GetEventStatsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetEventStatsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetEventStatsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetEventStatsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetEventStatsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetEventStatsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetEventStatsResponse& from) {
    GetEventStatsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetEventStatsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.GetEventStatsResponse";
  }
  protected:
  explicit GetEventStatsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatsFieldNumber = 1,
  };
  // repeated .unhinged.cdc.EventStats stats = 1;
  int stats_size() const;
  private:
  int _internal_stats_size() const;
  public:
  void clear_stats();
  ::unhinged::cdc::EventStats* mutable_stats(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::cdc::EventStats >*
      mutable_stats();
  private:
  const ::unhinged::cdc::EventStats& _internal_stats(int index) const;
  ::unhinged::cdc::EventStats* _internal_add_stats();
  public:
  const ::unhinged::cdc::EventStats& stats(int index) const;
  ::unhinged::cdc::EventStats* add_stats();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::cdc::EventStats >&
      stats() const;

  // @@protoc_insertion_point(class_scope:unhinged.cdc.GetEventStatsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::cdc::EventStats > stats_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class EventStats final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.EventStats) */ {
 public:
  inline EventStats() : EventStats(nullptr) {}
  ~EventStats() override;
  explicit PROTOBUF_CONSTEXPR EventStats(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventStats(const EventStats& from);
  EventStats(EventStats&& from) noexcept
    : EventStats() {
    *this = ::std::move(from);
  }

  inline EventStats& operator=(const EventStats& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventStats& operator=(EventStats&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventStats& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventStats* internal_default_instance() {
    return reinterpret_cast<const EventStats*>(
               &_EventStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(EventStats& a, EventStats& b) {
    a.Swap(&b);
  }
  inline void Swap(EventStats* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventStats* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventStats* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventStats>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventStats& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventStats& from) {
    EventStats::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventStats* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.EventStats";
  }
  protected:
  explicit EventStats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventTypeFieldNumber = 2,
    kSourceServiceFieldNumber = 3,
    kTimestampFieldNumber = 1,
    kEventCountFieldNumber = 4,
    kEventsPerSecondFieldNumber = 5,
    kAvgProcessingTimeMsFieldNumber = 6,
    kFailedCountFieldNumber = 7,
  };
  // string event_type = 2;
  void clear_event_type();
  const std::string& event_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_event_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_event_type();
  PROTOBUF_NODISCARD std::string* release_event_type();
  void set_allocated_event_type(std::string* event_type);
  private:
  const std::string& _internal_event_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_event_type(const std::string& value);
  std::string* _internal_mutable_event_type();
  public:

  // string source_service = 3;
  void clear_source_service();
  const std::string& source_service() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_source_service(ArgT0&& arg0, ArgT... args);
  std::string* mutable_source_service();
  PROTOBUF_NODISCARD std::string* release_source_service();
  void set_allocated_source_service(std::string* source_service);
  private:
  const std::string& _internal_source_service() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source_service(const std::string& value);
  std::string* _internal_mutable_source_service();
  public:

  // .google.protobuf.Timestamp timestamp = 1;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // int64 event_count = 4;
  void clear_event_count();
  int64_t event_count() const;
  void set_event_count(int64_t value);
  private:
  int64_t _internal_event_count() const;
  void _internal_set_event_count(int64_t value);
  public:

  // double events_per_second = 5;
  void clear_events_per_second();
  double events_per_second() const;
  void set_events_per_second(double value);
  private:
  double _internal_events_per_second() const;
  void _internal_set_events_per_second(double value);
  public:

  // double avg_processing_time_ms = 6;
  void clear_avg_processing_time_ms();
  double avg_processing_time_ms() const;
  void set_avg_processing_time_ms(double value);
  private:
  double _internal_avg_processing_time_ms() const;
  void _internal_set_avg_processing_time_ms(double value);
  public:

  // int64 failed_count = 7;
  void clear_failed_count();
  int64_t failed_count() const;
  void set_failed_count(int64_t value);
  private:
  int64_t _internal_failed_count() const;
  void _internal_set_failed_count(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.cdc.EventStats)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr event_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_service_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
    int64_t event_count_;
    double events_per_second_;
    double avg_processing_time_ms_;
    int64_t failed_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ListSubscriptionsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.ListSubscriptionsRequest) */ {
 public:
  inline ListSubscriptionsRequest() : ListSubscriptionsRequest(nullptr) {}
  ~ListSubscriptionsRequest() override;
  explicit PROTOBUF_CONSTEXPR ListSubscriptionsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListSubscriptionsRequest(const ListSubscriptionsRequest& from);
  ListSubscriptionsRequest(ListSubscriptionsRequest&& from) noexcept
    : ListSubscriptionsRequest() {
    *this = ::std::move(from);
  }

  inline ListSubscriptionsRequest& operator=(const ListSubscriptionsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListSubscriptionsRequest& operator=(ListSubscriptionsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListSubscriptionsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListSubscriptionsRequest* internal_default_instance() {
    return reinterpret_cast<const ListSubscriptionsRequest*>(
               &_ListSubscriptionsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(ListSubscriptionsRequest& a, ListSubscriptionsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListSubscriptionsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListSubscriptionsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListSubscriptionsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListSubscriptionsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListSubscriptionsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListSubscriptionsRequest& from) {
    ListSubscriptionsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListSubscriptionsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.ListSubscriptionsRequest";
  }
  protected:
  explicit ListSubscriptionsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubscriberIdFieldNumber = 1,
    kIncludeInactiveFieldNumber = 2,
  };
  // string subscriber_id = 1;
  void clear_subscriber_id();
  const std::string& subscriber_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_subscriber_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_subscriber_id();
  PROTOBUF_NODISCARD std::string* release_subscriber_id();
  void set_allocated_subscriber_id(std::string* subscriber_id);
  private:
  const std::string& _internal_subscriber_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subscriber_id(const std::string& value);
  std::string* _internal_mutable_subscriber_id();
  public:

  // bool include_inactive = 2;
  void clear_include_inactive();
  bool include_inactive() const;
  void set_include_inactive(bool value);
  private:
  bool _internal_include_inactive() const;
  void _internal_set_include_inactive(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.cdc.ListSubscriptionsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subscriber_id_;
    bool include_inactive_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ListSubscriptionsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.ListSubscriptionsResponse) */ {
 public:
  inline ListSubscriptionsResponse() : ListSubscriptionsResponse(nullptr) {}
  ~ListSubscriptionsResponse() override;
  explicit PROTOBUF_CONSTEXPR ListSubscriptionsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListSubscriptionsResponse(const ListSubscriptionsResponse& from);
  ListSubscriptionsResponse(ListSubscriptionsResponse&& from) noexcept
    : ListSubscriptionsResponse() {
    *this = ::std::move(from);
  }

  inline ListSubscriptionsResponse& operator=(const ListSubscriptionsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListSubscriptionsResponse& operator=(ListSubscriptionsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListSubscriptionsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListSubscriptionsResponse* internal_default_instance() {
    return reinterpret_cast<const ListSubscriptionsResponse*>(
               &_ListSubscriptionsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(ListSubscriptionsResponse& a, ListSubscriptionsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListSubscriptionsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListSubscriptionsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListSubscriptionsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListSubscriptionsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListSubscriptionsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListSubscriptionsResponse& from) {
    ListSubscriptionsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListSubscriptionsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.ListSubscriptionsResponse";
  }
  protected:
  explicit ListSubscriptionsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubscriptionsFieldNumber = 1,
  };
  // repeated .unhinged.cdc.SubscriptionInfo subscriptions = 1;
  int subscriptions_size() const;
  private:
  int _internal_subscriptions_size() const;
  public:
  void clear_subscriptions();
  ::unhinged::cdc::SubscriptionInfo* mutable_subscriptions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::cdc::SubscriptionInfo >*
      mutable_subscriptions();
  private:
  const ::unhinged::cdc::SubscriptionInfo& _internal_subscriptions(int index) const;
  ::unhinged::cdc::SubscriptionInfo* _internal_add_subscriptions();
  public:
  const ::unhinged::cdc::SubscriptionInfo& subscriptions(int index) const;
  ::unhinged::cdc::SubscriptionInfo* add_subscriptions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::cdc::SubscriptionInfo >&
      subscriptions() const;

  // @@protoc_insertion_point(class_scope:unhinged.cdc.ListSubscriptionsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::cdc::SubscriptionInfo > subscriptions_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class SubscriptionInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.SubscriptionInfo) */ {
 public:
  inline SubscriptionInfo() : SubscriptionInfo(nullptr) {}
  ~SubscriptionInfo() override;
  explicit PROTOBUF_CONSTEXPR SubscriptionInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscriptionInfo(const SubscriptionInfo& from);
  SubscriptionInfo(SubscriptionInfo&& from) noexcept
    : SubscriptionInfo() {
    *this = ::std::move(from);
  }

  inline SubscriptionInfo& operator=(const SubscriptionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscriptionInfo& operator=(SubscriptionInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscriptionInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscriptionInfo* internal_default_instance() {
    return reinterpret_cast<const SubscriptionInfo*>(
               &_SubscriptionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(SubscriptionInfo& a, SubscriptionInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscriptionInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscriptionInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscriptionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscriptionInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubscriptionInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubscriptionInfo& from) {
    SubscriptionInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscriptionInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.SubscriptionInfo";
  }
  protected:
  explicit SubscriptionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubscriberIdFieldNumber = 1,
    kSubscriberNameFieldNumber = 2,
    kStatusFieldNumber = 5,
    kFilterFieldNumber = 3,
    kOptionsFieldNumber = 4,
    kCreatedAtFieldNumber = 6,
    kLastActiveAtFieldNumber = 7,
    kEventsProcessedFieldNumber = 8,
    kEventsFailedFieldNumber = 9,
  };
  // string subscriber_id = 1;
  void clear_subscriber_id();
  const std::string& subscriber_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_subscriber_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_subscriber_id();
  PROTOBUF_NODISCARD std::string* release_subscriber_id();
  void set_allocated_subscriber_id(std::string* subscriber_id);
  private:
  const std::string& _internal_subscriber_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subscriber_id(const std::string& value);
  std::string* _internal_mutable_subscriber_id();
  public:

  // string subscriber_name = 2;
  void clear_subscriber_name();
  const std::string& subscriber_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_subscriber_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_subscriber_name();
  PROTOBUF_NODISCARD std::string* release_subscriber_name();
  void set_allocated_subscriber_name(std::string* subscriber_name);
  private:
  const std::string& _internal_subscriber_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subscriber_name(const std::string& value);
  std::string* _internal_mutable_subscriber_name();
  public:

  // string status = 5;
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // .unhinged.cdc.EventFilter filter = 3;
  bool has_filter() const;
  private:
  bool _internal_has_filter() const;
  public:
  void clear_filter();
  const ::unhinged::cdc::EventFilter& filter() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::EventFilter* release_filter();
  ::unhinged::cdc::EventFilter* mutable_filter();
  void set_allocated_filter(::unhinged::cdc::EventFilter* filter);
  private:
  const ::unhinged::cdc::EventFilter& _internal_filter() const;
  ::unhinged::cdc::EventFilter* _internal_mutable_filter();
  public:
  void unsafe_arena_set_allocated_filter(
      ::unhinged::cdc::EventFilter* filter);
  ::unhinged::cdc::EventFilter* unsafe_arena_release_filter();

  // .unhinged.cdc.SubscriptionOptions options = 4;
  bool has_options() const;
  private:
  bool _internal_has_options() const;
  public:
  void clear_options();
  const ::unhinged::cdc::SubscriptionOptions& options() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::SubscriptionOptions* release_options();
  ::unhinged::cdc::SubscriptionOptions* mutable_options();
  void set_allocated_options(::unhinged::cdc::SubscriptionOptions* options);
  private:
  const ::unhinged::cdc::SubscriptionOptions& _internal_options() const;
  ::unhinged::cdc::SubscriptionOptions* _internal_mutable_options();
  public:
  void unsafe_arena_set_allocated_options(
      ::unhinged::cdc::SubscriptionOptions* options);
  ::unhinged::cdc::SubscriptionOptions* unsafe_arena_release_options();

  // .google.protobuf.Timestamp created_at = 6;
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_at();
  void set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_at();

  // .google.protobuf.Timestamp last_active_at = 7;
  bool has_last_active_at() const;
  private:
  bool _internal_has_last_active_at() const;
  public:
  void clear_last_active_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& last_active_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_last_active_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_last_active_at();
  void set_allocated_last_active_at(::PROTOBUF_NAMESPACE_ID::Timestamp* last_active_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_last_active_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_last_active_at();
  public:
  void unsafe_arena_set_allocated_last_active_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* last_active_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_last_active_at();

  // int64 events_processed = 8;
  void clear_events_processed();
  int64_t events_processed() const;
  void set_events_processed(int64_t value);
  private:
  int64_t _internal_events_processed() const;
  void _internal_set_events_processed(int64_t value);
  public:

  // int64 events_failed = 9;
  void clear_events_failed();
  int64_t events_failed() const;
  void set_events_failed(int64_t value);
  private:
  int64_t _internal_events_failed() const;
  void _internal_set_events_failed(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.cdc.SubscriptionInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subscriber_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subscriber_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
    ::unhinged::cdc::EventFilter* filter_;
    ::unhinged::cdc::SubscriptionOptions* options_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_active_at_;
    int64_t events_processed_;
    int64_t events_failed_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class UpdateSubscriptionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.UpdateSubscriptionRequest) */ {
 public:
  inline UpdateSubscriptionRequest() : UpdateSubscriptionRequest(nullptr) {}
  ~UpdateSubscriptionRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateSubscriptionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateSubscriptionRequest(const UpdateSubscriptionRequest& from);
  UpdateSubscriptionRequest(UpdateSubscriptionRequest&& from) noexcept
    : UpdateSubscriptionRequest() {
    *this = ::std::move(from);
  }

  inline UpdateSubscriptionRequest& operator=(const UpdateSubscriptionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateSubscriptionRequest& operator=(UpdateSubscriptionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateSubscriptionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateSubscriptionRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateSubscriptionRequest*>(
               &_UpdateSubscriptionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(UpdateSubscriptionRequest& a, UpdateSubscriptionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateSubscriptionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateSubscriptionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateSubscriptionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateSubscriptionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateSubscriptionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateSubscriptionRequest& from) {
    UpdateSubscriptionRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateSubscriptionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.UpdateSubscriptionRequest";
  }
  protected:
  explicit UpdateSubscriptionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubscriberIdFieldNumber = 1,
    kFilterFieldNumber = 2,
    kOptionsFieldNumber = 3,
  };
  // string subscriber_id = 1;
  void clear_subscriber_id();
  const std::string& subscriber_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_subscriber_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_subscriber_id();
  PROTOBUF_NODISCARD std::string* release_subscriber_id();
  void set_allocated_subscriber_id(std::string* subscriber_id);
  private:
  const std::string& _internal_subscriber_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subscriber_id(const std::string& value);
  std::string* _internal_mutable_subscriber_id();
  public:

  // .unhinged.cdc.EventFilter filter = 2;
  bool has_filter() const;
  private:
  bool _internal_has_filter() const;
  public:
  void clear_filter();
  const ::unhinged::cdc::EventFilter& filter() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::EventFilter* release_filter();
  ::unhinged::cdc::EventFilter* mutable_filter();
  void set_allocated_filter(::unhinged::cdc::EventFilter* filter);
  private:
  const ::unhinged::cdc::EventFilter& _internal_filter() const;
  ::unhinged::cdc::EventFilter* _internal_mutable_filter();
  public:
  void unsafe_arena_set_allocated_filter(
      ::unhinged::cdc::EventFilter* filter);
  ::unhinged::cdc::EventFilter* unsafe_arena_release_filter();

  // .unhinged.cdc.SubscriptionOptions options = 3;
  bool has_options() const;
  private:
  bool _internal_has_options() const;
  public:
  void clear_options();
  const ::unhinged::cdc::SubscriptionOptions& options() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::SubscriptionOptions* release_options();
  ::unhinged::cdc::SubscriptionOptions* mutable_options();
  void set_allocated_options(::unhinged::cdc::SubscriptionOptions* options);
  private:
  const ::unhinged::cdc::SubscriptionOptions& _internal_options() const;
  ::unhinged::cdc::SubscriptionOptions* _internal_mutable_options();
  public:
  void unsafe_arena_set_allocated_options(
      ::unhinged::cdc::SubscriptionOptions* options);
  ::unhinged::cdc::SubscriptionOptions* unsafe_arena_release_options();

  // @@protoc_insertion_point(class_scope:unhinged.cdc.UpdateSubscriptionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subscriber_id_;
    ::unhinged::cdc::EventFilter* filter_;
    ::unhinged::cdc::SubscriptionOptions* options_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class UpdateSubscriptionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.UpdateSubscriptionResponse) */ {
 public:
  inline UpdateSubscriptionResponse() : UpdateSubscriptionResponse(nullptr) {}
  ~UpdateSubscriptionResponse() override;
  explicit PROTOBUF_CONSTEXPR UpdateSubscriptionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateSubscriptionResponse(const UpdateSubscriptionResponse& from);
  UpdateSubscriptionResponse(UpdateSubscriptionResponse&& from) noexcept
    : UpdateSubscriptionResponse() {
    *this = ::std::move(from);
  }

  inline UpdateSubscriptionResponse& operator=(const UpdateSubscriptionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateSubscriptionResponse& operator=(UpdateSubscriptionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateSubscriptionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateSubscriptionResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateSubscriptionResponse*>(
               &_UpdateSubscriptionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(UpdateSubscriptionResponse& a, UpdateSubscriptionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateSubscriptionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateSubscriptionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateSubscriptionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateSubscriptionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateSubscriptionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateSubscriptionResponse& from) {
    UpdateSubscriptionResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateSubscriptionResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.UpdateSubscriptionResponse";
  }
  protected:
  explicit UpdateSubscriptionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.cdc.UpdateSubscriptionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class DeleteSubscriptionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.DeleteSubscriptionRequest) */ {
 public:
  inline DeleteSubscriptionRequest() : DeleteSubscriptionRequest(nullptr) {}
  ~DeleteSubscriptionRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteSubscriptionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteSubscriptionRequest(const DeleteSubscriptionRequest& from);
  DeleteSubscriptionRequest(DeleteSubscriptionRequest&& from) noexcept
    : DeleteSubscriptionRequest() {
    *this = ::std::move(from);
  }

  inline DeleteSubscriptionRequest& operator=(const DeleteSubscriptionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteSubscriptionRequest& operator=(DeleteSubscriptionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteSubscriptionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteSubscriptionRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteSubscriptionRequest*>(
               &_DeleteSubscriptionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(DeleteSubscriptionRequest& a, DeleteSubscriptionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteSubscriptionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteSubscriptionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteSubscriptionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteSubscriptionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteSubscriptionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteSubscriptionRequest& from) {
    DeleteSubscriptionRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteSubscriptionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.DeleteSubscriptionRequest";
  }
  protected:
  explicit DeleteSubscriptionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubscriberIdFieldNumber = 1,
  };
  // string subscriber_id = 1;
  void clear_subscriber_id();
  const std::string& subscriber_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_subscriber_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_subscriber_id();
  PROTOBUF_NODISCARD std::string* release_subscriber_id();
  void set_allocated_subscriber_id(std::string* subscriber_id);
  private:
  const std::string& _internal_subscriber_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subscriber_id(const std::string& value);
  std::string* _internal_mutable_subscriber_id();
  public:

  // @@protoc_insertion_point(class_scope:unhinged.cdc.DeleteSubscriptionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subscriber_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class DeleteSubscriptionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.DeleteSubscriptionResponse) */ {
 public:
  inline DeleteSubscriptionResponse() : DeleteSubscriptionResponse(nullptr) {}
  ~DeleteSubscriptionResponse() override;
  explicit PROTOBUF_CONSTEXPR DeleteSubscriptionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteSubscriptionResponse(const DeleteSubscriptionResponse& from);
  DeleteSubscriptionResponse(DeleteSubscriptionResponse&& from) noexcept
    : DeleteSubscriptionResponse() {
    *this = ::std::move(from);
  }

  inline DeleteSubscriptionResponse& operator=(const DeleteSubscriptionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteSubscriptionResponse& operator=(DeleteSubscriptionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteSubscriptionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteSubscriptionResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteSubscriptionResponse*>(
               &_DeleteSubscriptionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(DeleteSubscriptionResponse& a, DeleteSubscriptionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteSubscriptionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteSubscriptionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteSubscriptionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteSubscriptionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteSubscriptionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteSubscriptionResponse& from) {
    DeleteSubscriptionResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteSubscriptionResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.DeleteSubscriptionResponse";
  }
  protected:
  explicit DeleteSubscriptionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.cdc.DeleteSubscriptionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class GetServiceStatusRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:unhinged.cdc.GetServiceStatusRequest) */ {
 public:
  inline GetServiceStatusRequest() : GetServiceStatusRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetServiceStatusRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetServiceStatusRequest(const GetServiceStatusRequest& from);
  GetServiceStatusRequest(GetServiceStatusRequest&& from) noexcept
    : GetServiceStatusRequest() {
    *this = ::std::move(from);
  }

  inline GetServiceStatusRequest& operator=(const GetServiceStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetServiceStatusRequest& operator=(GetServiceStatusRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetServiceStatusRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetServiceStatusRequest* internal_default_instance() {
    return reinterpret_cast<const GetServiceStatusRequest*>(
               &_GetServiceStatusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(GetServiceStatusRequest& a, GetServiceStatusRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetServiceStatusRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetServiceStatusRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetServiceStatusRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetServiceStatusRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetServiceStatusRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetServiceStatusRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.GetServiceStatusRequest";
  }
  protected:
  explicit GetServiceStatusRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:unhinged.cdc.GetServiceStatusRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_cdc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class GetServiceStatusResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.GetServiceStatusResponse) */ {
 public:
  inline GetServiceStatusResponse() : GetServiceStatusResponse(nullptr) {}
  ~GetServiceStatusResponse() override;
  explicit PROTOBUF_CONSTEXPR GetServiceStatusResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetServiceStatusResponse(const GetServiceStatusResponse& from);
  GetServiceStatusResponse(GetServiceStatusResponse&& from) noexcept
    : GetServiceStatusResponse() {
    *this = ::std::move(from);
  }

  inline GetServiceStatusResponse& operator=(const GetServiceStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetServiceStatusResponse& operator=(GetServiceStatusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetServiceStatusResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetServiceStatusResponse* internal_default_instance() {
    return reinterpret_cast<const GetServiceStatusResponse*>(
               &_GetServiceStatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(GetServiceStatusResponse& a, GetServiceStatusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetServiceStatusResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetServiceStatusResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetServiceStatusResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetServiceStatusResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetServiceStatusResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetServiceStatusResponse& from) {
    GetServiceStatusResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetServiceStatusResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.GetServiceStatusResponse";
  }
  protected:
  explicit GetServiceStatusResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 2,
    kTimestampFieldNumber = 3,
    kMetricsFieldNumber = 4,
    kHealthyFieldNumber = 1,
  };
  // string status = 2;
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // .google.protobuf.Timestamp timestamp = 3;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // .unhinged.cdc.ServiceMetrics metrics = 4;
  bool has_metrics() const;
  private:
  bool _internal_has_metrics() const;
  public:
  void clear_metrics();
  const ::unhinged::cdc::ServiceMetrics& metrics() const;
  PROTOBUF_NODISCARD ::unhinged::cdc::ServiceMetrics* release_metrics();
  ::unhinged::cdc::ServiceMetrics* mutable_metrics();
  void set_allocated_metrics(::unhinged::cdc::ServiceMetrics* metrics);
  private:
  const ::unhinged::cdc::ServiceMetrics& _internal_metrics() const;
  ::unhinged::cdc::ServiceMetrics* _internal_mutable_metrics();
  public:
  void unsafe_arena_set_allocated_metrics(
      ::unhinged::cdc::ServiceMetrics* metrics);
  ::unhinged::cdc::ServiceMetrics* unsafe_arena_release_metrics();

  // bool healthy = 1;
  void clear_healthy();
  bool healthy() const;
  void set_healthy(bool value);
  private:
  bool _internal_healthy() const;
  void _internal_set_healthy(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.cdc.GetServiceStatusResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
    ::unhinged::cdc::ServiceMetrics* metrics_;
    bool healthy_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ServiceMetrics final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.cdc.ServiceMetrics) */ {
 public:
  inline ServiceMetrics() : ServiceMetrics(nullptr) {}
  ~ServiceMetrics() override;
  explicit PROTOBUF_CONSTEXPR ServiceMetrics(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServiceMetrics(const ServiceMetrics& from);
  ServiceMetrics(ServiceMetrics&& from) noexcept
    : ServiceMetrics() {
    *this = ::std::move(from);
  }

  inline ServiceMetrics& operator=(const ServiceMetrics& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServiceMetrics& operator=(ServiceMetrics&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServiceMetrics& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServiceMetrics* internal_default_instance() {
    return reinterpret_cast<const ServiceMetrics*>(
               &_ServiceMetrics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(ServiceMetrics& a, ServiceMetrics& b) {
    a.Swap(&b);
  }
  inline void Swap(ServiceMetrics* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServiceMetrics* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServiceMetrics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServiceMetrics>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServiceMetrics& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ServiceMetrics& from) {
    ServiceMetrics::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServiceMetrics* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.cdc.ServiceMetrics";
  }
  protected:
  explicit ServiceMetrics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTotalEventsPublishedFieldNumber = 1,
    kTotalEventsDeliveredFieldNumber = 2,
    kActiveSubscriptionsFieldNumber = 3,
    kEventsInDlqFieldNumber = 4,
    kAvgPublishLatencyMsFieldNumber = 5,
    kAvgDeliveryLatencyMsFieldNumber = 6,
  };
  // int64 total_events_published = 1;
  void clear_total_events_published();
  int64_t total_events_published() const;
  void set_total_events_published(int64_t value);
  private:
  int64_t _internal_total_events_published() const;
  void _internal_set_total_events_published(int64_t value);
  public:

  // int64 total_events_delivered = 2;
  void clear_total_events_delivered();
  int64_t total_events_delivered() const;
  void set_total_events_delivered(int64_t value);
  private:
  int64_t _internal_total_events_delivered() const;
  void _internal_set_total_events_delivered(int64_t value);
  public:

  // int64 active_subscriptions = 3;
  void clear_active_subscriptions();
  int64_t active_subscriptions() const;
  void set_active_subscriptions(int64_t value);
  private:
  int64_t _internal_active_subscriptions() const;
  void _internal_set_active_subscriptions(int64_t value);
  public:

  // int64 events_in_dlq = 4;
  void clear_events_in_dlq();
  int64_t events_in_dlq() const;
  void set_events_in_dlq(int64_t value);
  private:
  int64_t _internal_events_in_dlq() const;
  void _internal_set_events_in_dlq(int64_t value);
  public:

  // double avg_publish_latency_ms = 5;
  void clear_avg_publish_latency_ms();
  double avg_publish_latency_ms() const;
  void set_avg_publish_latency_ms(double value);
  private:
  double _internal_avg_publish_latency_ms() const;
  void _internal_set_avg_publish_latency_ms(double value);
  public:

  // double avg_delivery_latency_ms = 6;
  void clear_avg_delivery_latency_ms();
  double avg_delivery_latency_ms() const;
  void set_avg_delivery_latency_ms(double value);
  private:
  double _internal_avg_delivery_latency_ms() const;
  void _internal_set_avg_delivery_latency_ms(double value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.cdc.ServiceMetrics)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t total_events_published_;
    int64_t total_events_delivered_;
    int64_t active_subscriptions_;
    int64_t events_in_dlq_;
    double avg_publish_latency_ms_;
    double avg_delivery_latency_ms_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_cdc_5fservice_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PublishEventRequest

// .unhinged.cdc.UniversalEvent event = 1;
inline bool PublishEventRequest::_internal_has_event() const {
  return this != internal_default_instance() && _impl_.event_ != nullptr;
}
inline bool PublishEventRequest::has_event() const {
  return _internal_has_event();
}
inline const ::unhinged::cdc::UniversalEvent& PublishEventRequest::_internal_event() const {
  const ::unhinged::cdc::UniversalEvent* p = _impl_.event_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::cdc::UniversalEvent&>(
      ::unhinged::cdc::_UniversalEvent_default_instance_);
}
inline const ::unhinged::cdc::UniversalEvent& PublishEventRequest::event() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.PublishEventRequest.event)
  return _internal_event();
}
inline void PublishEventRequest::unsafe_arena_set_allocated_event(
    ::unhinged::cdc::UniversalEvent* event) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.event_);
  }
  _impl_.event_ = event;
  if (event) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.PublishEventRequest.event)
}
inline ::unhinged::cdc::UniversalEvent* PublishEventRequest::release_event() {
  
  ::unhinged::cdc::UniversalEvent* temp = _impl_.event_;
  _impl_.event_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::cdc::UniversalEvent* PublishEventRequest::unsafe_arena_release_event() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.PublishEventRequest.event)
  
  ::unhinged::cdc::UniversalEvent* temp = _impl_.event_;
  _impl_.event_ = nullptr;
  return temp;
}
inline ::unhinged::cdc::UniversalEvent* PublishEventRequest::_internal_mutable_event() {
  
  if (_impl_.event_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::cdc::UniversalEvent>(GetArenaForAllocation());
    _impl_.event_ = p;
  }
  return _impl_.event_;
}
inline ::unhinged::cdc::UniversalEvent* PublishEventRequest::mutable_event() {
  ::unhinged::cdc::UniversalEvent* _msg = _internal_mutable_event();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.PublishEventRequest.event)
  return _msg;
}
inline void PublishEventRequest::set_allocated_event(::unhinged::cdc::UniversalEvent* event) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.event_);
  }
  if (event) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(event));
    if (message_arena != submessage_arena) {
      event = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, event, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.event_ = event;
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.PublishEventRequest.event)
}

// bool ensure_delivery = 2;
inline void PublishEventRequest::clear_ensure_delivery() {
  _impl_.ensure_delivery_ = false;
}
inline bool PublishEventRequest::_internal_ensure_delivery() const {
  return _impl_.ensure_delivery_;
}
inline bool PublishEventRequest::ensure_delivery() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.PublishEventRequest.ensure_delivery)
  return _internal_ensure_delivery();
}
inline void PublishEventRequest::_internal_set_ensure_delivery(bool value) {
  
  _impl_.ensure_delivery_ = value;
}
inline void PublishEventRequest::set_ensure_delivery(bool value) {
  _internal_set_ensure_delivery(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.PublishEventRequest.ensure_delivery)
}

// int32 retry_attempts = 3;
inline void PublishEventRequest::clear_retry_attempts() {
  _impl_.retry_attempts_ = 0;
}
inline int32_t PublishEventRequest::_internal_retry_attempts() const {
  return _impl_.retry_attempts_;
}
inline int32_t PublishEventRequest::retry_attempts() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.PublishEventRequest.retry_attempts)
  return _internal_retry_attempts();
}
inline void PublishEventRequest::_internal_set_retry_attempts(int32_t value) {
  
  _impl_.retry_attempts_ = value;
}
inline void PublishEventRequest::set_retry_attempts(int32_t value) {
  _internal_set_retry_attempts(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.PublishEventRequest.retry_attempts)
}

// .google.protobuf.Timestamp delivery_deadline = 4;
inline bool PublishEventRequest::_internal_has_delivery_deadline() const {
  return this != internal_default_instance() && _impl_.delivery_deadline_ != nullptr;
}
inline bool PublishEventRequest::has_delivery_deadline() const {
  return _internal_has_delivery_deadline();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& PublishEventRequest::_internal_delivery_deadline() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.delivery_deadline_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& PublishEventRequest::delivery_deadline() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.PublishEventRequest.delivery_deadline)
  return _internal_delivery_deadline();
}
inline void PublishEventRequest::unsafe_arena_set_allocated_delivery_deadline(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* delivery_deadline) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.delivery_deadline_);
  }
  _impl_.delivery_deadline_ = delivery_deadline;
  if (delivery_deadline) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.PublishEventRequest.delivery_deadline)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* PublishEventRequest::release_delivery_deadline() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.delivery_deadline_;
  _impl_.delivery_deadline_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* PublishEventRequest::unsafe_arena_release_delivery_deadline() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.PublishEventRequest.delivery_deadline)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.delivery_deadline_;
  _impl_.delivery_deadline_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* PublishEventRequest::_internal_mutable_delivery_deadline() {
  
  if (_impl_.delivery_deadline_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.delivery_deadline_ = p;
  }
  return _impl_.delivery_deadline_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* PublishEventRequest::mutable_delivery_deadline() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_delivery_deadline();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.PublishEventRequest.delivery_deadline)
  return _msg;
}
inline void PublishEventRequest::set_allocated_delivery_deadline(::PROTOBUF_NAMESPACE_ID::Timestamp* delivery_deadline) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.delivery_deadline_);
  }
  if (delivery_deadline) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(delivery_deadline));
    if (message_arena != submessage_arena) {
      delivery_deadline = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, delivery_deadline, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.delivery_deadline_ = delivery_deadline;
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.PublishEventRequest.delivery_deadline)
}

// repeated string target_subscribers = 5;
inline int PublishEventRequest::_internal_target_subscribers_size() const {
  return _impl_.target_subscribers_.size();
}
inline int PublishEventRequest::target_subscribers_size() const {
  return _internal_target_subscribers_size();
}
inline void PublishEventRequest::clear_target_subscribers() {
  _impl_.target_subscribers_.Clear();
}
inline std::string* PublishEventRequest::add_target_subscribers() {
  std::string* _s = _internal_add_target_subscribers();
  // @@protoc_insertion_point(field_add_mutable:unhinged.cdc.PublishEventRequest.target_subscribers)
  return _s;
}
inline const std::string& PublishEventRequest::_internal_target_subscribers(int index) const {
  return _impl_.target_subscribers_.Get(index);
}
inline const std::string& PublishEventRequest::target_subscribers(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.PublishEventRequest.target_subscribers)
  return _internal_target_subscribers(index);
}
inline std::string* PublishEventRequest::mutable_target_subscribers(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.PublishEventRequest.target_subscribers)
  return _impl_.target_subscribers_.Mutable(index);
}
inline void PublishEventRequest::set_target_subscribers(int index, const std::string& value) {
  _impl_.target_subscribers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.PublishEventRequest.target_subscribers)
}
inline void PublishEventRequest::set_target_subscribers(int index, std::string&& value) {
  _impl_.target_subscribers_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.cdc.PublishEventRequest.target_subscribers)
}
inline void PublishEventRequest::set_target_subscribers(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.target_subscribers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.cdc.PublishEventRequest.target_subscribers)
}
inline void PublishEventRequest::set_target_subscribers(int index, const char* value, size_t size) {
  _impl_.target_subscribers_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.cdc.PublishEventRequest.target_subscribers)
}
inline std::string* PublishEventRequest::_internal_add_target_subscribers() {
  return _impl_.target_subscribers_.Add();
}
inline void PublishEventRequest::add_target_subscribers(const std::string& value) {
  _impl_.target_subscribers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.cdc.PublishEventRequest.target_subscribers)
}
inline void PublishEventRequest::add_target_subscribers(std::string&& value) {
  _impl_.target_subscribers_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.cdc.PublishEventRequest.target_subscribers)
}
inline void PublishEventRequest::add_target_subscribers(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.target_subscribers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.cdc.PublishEventRequest.target_subscribers)
}
inline void PublishEventRequest::add_target_subscribers(const char* value, size_t size) {
  _impl_.target_subscribers_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.cdc.PublishEventRequest.target_subscribers)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PublishEventRequest::target_subscribers() const {
  // @@protoc_insertion_point(field_list:unhinged.cdc.PublishEventRequest.target_subscribers)
  return _impl_.target_subscribers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PublishEventRequest::mutable_target_subscribers() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.cdc.PublishEventRequest.target_subscribers)
  return &_impl_.target_subscribers_;
}

// string routing_strategy = 6;
inline void PublishEventRequest::clear_routing_strategy() {
  _impl_.routing_strategy_.ClearToEmpty();
}
inline const std::string& PublishEventRequest::routing_strategy() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.PublishEventRequest.routing_strategy)
  return _internal_routing_strategy();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PublishEventRequest::set_routing_strategy(ArgT0&& arg0, ArgT... args) {
 
 _impl_.routing_strategy_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.PublishEventRequest.routing_strategy)
}
inline std::string* PublishEventRequest::mutable_routing_strategy() {
  std::string* _s = _internal_mutable_routing_strategy();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.PublishEventRequest.routing_strategy)
  return _s;
}
inline const std::string& PublishEventRequest::_internal_routing_strategy() const {
  return _impl_.routing_strategy_.Get();
}
inline void PublishEventRequest::_internal_set_routing_strategy(const std::string& value) {
  
  _impl_.routing_strategy_.Set(value, GetArenaForAllocation());
}
inline std::string* PublishEventRequest::_internal_mutable_routing_strategy() {
  
  return _impl_.routing_strategy_.Mutable(GetArenaForAllocation());
}
inline std::string* PublishEventRequest::release_routing_strategy() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.PublishEventRequest.routing_strategy)
  return _impl_.routing_strategy_.Release();
}
inline void PublishEventRequest::set_allocated_routing_strategy(std::string* routing_strategy) {
  if (routing_strategy != nullptr) {
    
  } else {
    
  }
  _impl_.routing_strategy_.SetAllocated(routing_strategy, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.routing_strategy_.IsDefault()) {
    _impl_.routing_strategy_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.PublishEventRequest.routing_strategy)
}

// -------------------------------------------------------------------

// PublishEventResponse

// bool success = 1;
inline void PublishEventResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool PublishEventResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool PublishEventResponse::success() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.PublishEventResponse.success)
  return _internal_success();
}
inline void PublishEventResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void PublishEventResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.PublishEventResponse.success)
}

// string message = 2;
inline void PublishEventResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& PublishEventResponse::message() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.PublishEventResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PublishEventResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.PublishEventResponse.message)
}
inline std::string* PublishEventResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.PublishEventResponse.message)
  return _s;
}
inline const std::string& PublishEventResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void PublishEventResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* PublishEventResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* PublishEventResponse::release_message() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.PublishEventResponse.message)
  return _impl_.message_.Release();
}
inline void PublishEventResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.PublishEventResponse.message)
}

// string event_id = 3;
inline void PublishEventResponse::clear_event_id() {
  _impl_.event_id_.ClearToEmpty();
}
inline const std::string& PublishEventResponse::event_id() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.PublishEventResponse.event_id)
  return _internal_event_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PublishEventResponse::set_event_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.event_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.PublishEventResponse.event_id)
}
inline std::string* PublishEventResponse::mutable_event_id() {
  std::string* _s = _internal_mutable_event_id();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.PublishEventResponse.event_id)
  return _s;
}
inline const std::string& PublishEventResponse::_internal_event_id() const {
  return _impl_.event_id_.Get();
}
inline void PublishEventResponse::_internal_set_event_id(const std::string& value) {
  
  _impl_.event_id_.Set(value, GetArenaForAllocation());
}
inline std::string* PublishEventResponse::_internal_mutable_event_id() {
  
  return _impl_.event_id_.Mutable(GetArenaForAllocation());
}
inline std::string* PublishEventResponse::release_event_id() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.PublishEventResponse.event_id)
  return _impl_.event_id_.Release();
}
inline void PublishEventResponse::set_allocated_event_id(std::string* event_id) {
  if (event_id != nullptr) {
    
  } else {
    
  }
  _impl_.event_id_.SetAllocated(event_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.event_id_.IsDefault()) {
    _impl_.event_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.PublishEventResponse.event_id)
}

// int64 sequence_number = 4;
inline void PublishEventResponse::clear_sequence_number() {
  _impl_.sequence_number_ = int64_t{0};
}
inline int64_t PublishEventResponse::_internal_sequence_number() const {
  return _impl_.sequence_number_;
}
inline int64_t PublishEventResponse::sequence_number() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.PublishEventResponse.sequence_number)
  return _internal_sequence_number();
}
inline void PublishEventResponse::_internal_set_sequence_number(int64_t value) {
  
  _impl_.sequence_number_ = value;
}
inline void PublishEventResponse::set_sequence_number(int64_t value) {
  _internal_set_sequence_number(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.PublishEventResponse.sequence_number)
}

// .google.protobuf.Timestamp published_at = 5;
inline bool PublishEventResponse::_internal_has_published_at() const {
  return this != internal_default_instance() && _impl_.published_at_ != nullptr;
}
inline bool PublishEventResponse::has_published_at() const {
  return _internal_has_published_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& PublishEventResponse::_internal_published_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.published_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& PublishEventResponse::published_at() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.PublishEventResponse.published_at)
  return _internal_published_at();
}
inline void PublishEventResponse::unsafe_arena_set_allocated_published_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* published_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.published_at_);
  }
  _impl_.published_at_ = published_at;
  if (published_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.PublishEventResponse.published_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* PublishEventResponse::release_published_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.published_at_;
  _impl_.published_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* PublishEventResponse::unsafe_arena_release_published_at() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.PublishEventResponse.published_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.published_at_;
  _impl_.published_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* PublishEventResponse::_internal_mutable_published_at() {
  
  if (_impl_.published_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.published_at_ = p;
  }
  return _impl_.published_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* PublishEventResponse::mutable_published_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_published_at();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.PublishEventResponse.published_at)
  return _msg;
}
inline void PublishEventResponse::set_allocated_published_at(::PROTOBUF_NAMESPACE_ID::Timestamp* published_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.published_at_);
  }
  if (published_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(published_at));
    if (message_arena != submessage_arena) {
      published_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, published_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.published_at_ = published_at;
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.PublishEventResponse.published_at)
}

// -------------------------------------------------------------------

// PublishEventsRequest

// repeated .unhinged.cdc.UniversalEvent events = 1;
inline int PublishEventsRequest::_internal_events_size() const {
  return _impl_.events_.size();
}
inline int PublishEventsRequest::events_size() const {
  return _internal_events_size();
}
inline ::unhinged::cdc::UniversalEvent* PublishEventsRequest::mutable_events(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.PublishEventsRequest.events)
  return _impl_.events_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::cdc::UniversalEvent >*
PublishEventsRequest::mutable_events() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.cdc.PublishEventsRequest.events)
  return &_impl_.events_;
}
inline const ::unhinged::cdc::UniversalEvent& PublishEventsRequest::_internal_events(int index) const {
  return _impl_.events_.Get(index);
}
inline const ::unhinged::cdc::UniversalEvent& PublishEventsRequest::events(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.PublishEventsRequest.events)
  return _internal_events(index);
}
inline ::unhinged::cdc::UniversalEvent* PublishEventsRequest::_internal_add_events() {
  return _impl_.events_.Add();
}
inline ::unhinged::cdc::UniversalEvent* PublishEventsRequest::add_events() {
  ::unhinged::cdc::UniversalEvent* _add = _internal_add_events();
  // @@protoc_insertion_point(field_add:unhinged.cdc.PublishEventsRequest.events)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::cdc::UniversalEvent >&
PublishEventsRequest::events() const {
  // @@protoc_insertion_point(field_list:unhinged.cdc.PublishEventsRequest.events)
  return _impl_.events_;
}

// bool atomic = 2;
inline void PublishEventsRequest::clear_atomic() {
  _impl_.atomic_ = false;
}
inline bool PublishEventsRequest::_internal_atomic() const {
  return _impl_.atomic_;
}
inline bool PublishEventsRequest::atomic() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.PublishEventsRequest.atomic)
  return _internal_atomic();
}
inline void PublishEventsRequest::_internal_set_atomic(bool value) {
  
  _impl_.atomic_ = value;
}
inline void PublishEventsRequest::set_atomic(bool value) {
  _internal_set_atomic(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.PublishEventsRequest.atomic)
}

// bool ensure_delivery = 3;
inline void PublishEventsRequest::clear_ensure_delivery() {
  _impl_.ensure_delivery_ = false;
}
inline bool PublishEventsRequest::_internal_ensure_delivery() const {
  return _impl_.ensure_delivery_;
}
inline bool PublishEventsRequest::ensure_delivery() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.PublishEventsRequest.ensure_delivery)
  return _internal_ensure_delivery();
}
inline void PublishEventsRequest::_internal_set_ensure_delivery(bool value) {
  
  _impl_.ensure_delivery_ = value;
}
inline void PublishEventsRequest::set_ensure_delivery(bool value) {
  _internal_set_ensure_delivery(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.PublishEventsRequest.ensure_delivery)
}

// int32 retry_attempts = 4;
inline void PublishEventsRequest::clear_retry_attempts() {
  _impl_.retry_attempts_ = 0;
}
inline int32_t PublishEventsRequest::_internal_retry_attempts() const {
  return _impl_.retry_attempts_;
}
inline int32_t PublishEventsRequest::retry_attempts() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.PublishEventsRequest.retry_attempts)
  return _internal_retry_attempts();
}
inline void PublishEventsRequest::_internal_set_retry_attempts(int32_t value) {
  
  _impl_.retry_attempts_ = value;
}
inline void PublishEventsRequest::set_retry_attempts(int32_t value) {
  _internal_set_retry_attempts(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.PublishEventsRequest.retry_attempts)
}

// -------------------------------------------------------------------

// PublishEventResult

// string event_id = 1;
inline void PublishEventResult::clear_event_id() {
  _impl_.event_id_.ClearToEmpty();
}
inline const std::string& PublishEventResult::event_id() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.PublishEventResult.event_id)
  return _internal_event_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PublishEventResult::set_event_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.event_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.PublishEventResult.event_id)
}
inline std::string* PublishEventResult::mutable_event_id() {
  std::string* _s = _internal_mutable_event_id();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.PublishEventResult.event_id)
  return _s;
}
inline const std::string& PublishEventResult::_internal_event_id() const {
  return _impl_.event_id_.Get();
}
inline void PublishEventResult::_internal_set_event_id(const std::string& value) {
  
  _impl_.event_id_.Set(value, GetArenaForAllocation());
}
inline std::string* PublishEventResult::_internal_mutable_event_id() {
  
  return _impl_.event_id_.Mutable(GetArenaForAllocation());
}
inline std::string* PublishEventResult::release_event_id() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.PublishEventResult.event_id)
  return _impl_.event_id_.Release();
}
inline void PublishEventResult::set_allocated_event_id(std::string* event_id) {
  if (event_id != nullptr) {
    
  } else {
    
  }
  _impl_.event_id_.SetAllocated(event_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.event_id_.IsDefault()) {
    _impl_.event_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.PublishEventResult.event_id)
}

// bool success = 2;
inline void PublishEventResult::clear_success() {
  _impl_.success_ = false;
}
inline bool PublishEventResult::_internal_success() const {
  return _impl_.success_;
}
inline bool PublishEventResult::success() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.PublishEventResult.success)
  return _internal_success();
}
inline void PublishEventResult::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void PublishEventResult::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.PublishEventResult.success)
}

// string error_message = 3;
inline void PublishEventResult::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& PublishEventResult::error_message() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.PublishEventResult.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PublishEventResult::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.PublishEventResult.error_message)
}
inline std::string* PublishEventResult::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.PublishEventResult.error_message)
  return _s;
}
inline const std::string& PublishEventResult::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void PublishEventResult::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* PublishEventResult::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* PublishEventResult::release_error_message() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.PublishEventResult.error_message)
  return _impl_.error_message_.Release();
}
inline void PublishEventResult::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.PublishEventResult.error_message)
}

// int64 sequence_number = 4;
inline void PublishEventResult::clear_sequence_number() {
  _impl_.sequence_number_ = int64_t{0};
}
inline int64_t PublishEventResult::_internal_sequence_number() const {
  return _impl_.sequence_number_;
}
inline int64_t PublishEventResult::sequence_number() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.PublishEventResult.sequence_number)
  return _internal_sequence_number();
}
inline void PublishEventResult::_internal_set_sequence_number(int64_t value) {
  
  _impl_.sequence_number_ = value;
}
inline void PublishEventResult::set_sequence_number(int64_t value) {
  _internal_set_sequence_number(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.PublishEventResult.sequence_number)
}

// -------------------------------------------------------------------

// PublishEventsResponse

// bool success = 1;
inline void PublishEventsResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool PublishEventsResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool PublishEventsResponse::success() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.PublishEventsResponse.success)
  return _internal_success();
}
inline void PublishEventsResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void PublishEventsResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.PublishEventsResponse.success)
}

// string message = 2;
inline void PublishEventsResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& PublishEventsResponse::message() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.PublishEventsResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PublishEventsResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.PublishEventsResponse.message)
}
inline std::string* PublishEventsResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.PublishEventsResponse.message)
  return _s;
}
inline const std::string& PublishEventsResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void PublishEventsResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* PublishEventsResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* PublishEventsResponse::release_message() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.PublishEventsResponse.message)
  return _impl_.message_.Release();
}
inline void PublishEventsResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.PublishEventsResponse.message)
}

// repeated .unhinged.cdc.PublishEventResult results = 3;
inline int PublishEventsResponse::_internal_results_size() const {
  return _impl_.results_.size();
}
inline int PublishEventsResponse::results_size() const {
  return _internal_results_size();
}
inline void PublishEventsResponse::clear_results() {
  _impl_.results_.Clear();
}
inline ::unhinged::cdc::PublishEventResult* PublishEventsResponse::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.PublishEventsResponse.results)
  return _impl_.results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::cdc::PublishEventResult >*
PublishEventsResponse::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.cdc.PublishEventsResponse.results)
  return &_impl_.results_;
}
inline const ::unhinged::cdc::PublishEventResult& PublishEventsResponse::_internal_results(int index) const {
  return _impl_.results_.Get(index);
}
inline const ::unhinged::cdc::PublishEventResult& PublishEventsResponse::results(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.PublishEventsResponse.results)
  return _internal_results(index);
}
inline ::unhinged::cdc::PublishEventResult* PublishEventsResponse::_internal_add_results() {
  return _impl_.results_.Add();
}
inline ::unhinged::cdc::PublishEventResult* PublishEventsResponse::add_results() {
  ::unhinged::cdc::PublishEventResult* _add = _internal_add_results();
  // @@protoc_insertion_point(field_add:unhinged.cdc.PublishEventsResponse.results)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::cdc::PublishEventResult >&
PublishEventsResponse::results() const {
  // @@protoc_insertion_point(field_list:unhinged.cdc.PublishEventsResponse.results)
  return _impl_.results_;
}

// int32 successful_count = 4;
inline void PublishEventsResponse::clear_successful_count() {
  _impl_.successful_count_ = 0;
}
inline int32_t PublishEventsResponse::_internal_successful_count() const {
  return _impl_.successful_count_;
}
inline int32_t PublishEventsResponse::successful_count() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.PublishEventsResponse.successful_count)
  return _internal_successful_count();
}
inline void PublishEventsResponse::_internal_set_successful_count(int32_t value) {
  
  _impl_.successful_count_ = value;
}
inline void PublishEventsResponse::set_successful_count(int32_t value) {
  _internal_set_successful_count(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.PublishEventsResponse.successful_count)
}

// int32 failed_count = 5;
inline void PublishEventsResponse::clear_failed_count() {
  _impl_.failed_count_ = 0;
}
inline int32_t PublishEventsResponse::_internal_failed_count() const {
  return _impl_.failed_count_;
}
inline int32_t PublishEventsResponse::failed_count() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.PublishEventsResponse.failed_count)
  return _internal_failed_count();
}
inline void PublishEventsResponse::_internal_set_failed_count(int32_t value) {
  
  _impl_.failed_count_ = value;
}
inline void PublishEventsResponse::set_failed_count(int32_t value) {
  _internal_set_failed_count(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.PublishEventsResponse.failed_count)
}

// -------------------------------------------------------------------

// SubscribeRequest

// string subscriber_id = 1;
inline void SubscribeRequest::clear_subscriber_id() {
  _impl_.subscriber_id_.ClearToEmpty();
}
inline const std::string& SubscribeRequest::subscriber_id() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.SubscribeRequest.subscriber_id)
  return _internal_subscriber_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubscribeRequest::set_subscriber_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.subscriber_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.SubscribeRequest.subscriber_id)
}
inline std::string* SubscribeRequest::mutable_subscriber_id() {
  std::string* _s = _internal_mutable_subscriber_id();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.SubscribeRequest.subscriber_id)
  return _s;
}
inline const std::string& SubscribeRequest::_internal_subscriber_id() const {
  return _impl_.subscriber_id_.Get();
}
inline void SubscribeRequest::_internal_set_subscriber_id(const std::string& value) {
  
  _impl_.subscriber_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SubscribeRequest::_internal_mutable_subscriber_id() {
  
  return _impl_.subscriber_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SubscribeRequest::release_subscriber_id() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.SubscribeRequest.subscriber_id)
  return _impl_.subscriber_id_.Release();
}
inline void SubscribeRequest::set_allocated_subscriber_id(std::string* subscriber_id) {
  if (subscriber_id != nullptr) {
    
  } else {
    
  }
  _impl_.subscriber_id_.SetAllocated(subscriber_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.subscriber_id_.IsDefault()) {
    _impl_.subscriber_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.SubscribeRequest.subscriber_id)
}

// string subscriber_name = 2;
inline void SubscribeRequest::clear_subscriber_name() {
  _impl_.subscriber_name_.ClearToEmpty();
}
inline const std::string& SubscribeRequest::subscriber_name() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.SubscribeRequest.subscriber_name)
  return _internal_subscriber_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubscribeRequest::set_subscriber_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.subscriber_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.SubscribeRequest.subscriber_name)
}
inline std::string* SubscribeRequest::mutable_subscriber_name() {
  std::string* _s = _internal_mutable_subscriber_name();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.SubscribeRequest.subscriber_name)
  return _s;
}
inline const std::string& SubscribeRequest::_internal_subscriber_name() const {
  return _impl_.subscriber_name_.Get();
}
inline void SubscribeRequest::_internal_set_subscriber_name(const std::string& value) {
  
  _impl_.subscriber_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SubscribeRequest::_internal_mutable_subscriber_name() {
  
  return _impl_.subscriber_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SubscribeRequest::release_subscriber_name() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.SubscribeRequest.subscriber_name)
  return _impl_.subscriber_name_.Release();
}
inline void SubscribeRequest::set_allocated_subscriber_name(std::string* subscriber_name) {
  if (subscriber_name != nullptr) {
    
  } else {
    
  }
  _impl_.subscriber_name_.SetAllocated(subscriber_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.subscriber_name_.IsDefault()) {
    _impl_.subscriber_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.SubscribeRequest.subscriber_name)
}

// .unhinged.cdc.EventFilter filter = 3;
inline bool SubscribeRequest::_internal_has_filter() const {
  return this != internal_default_instance() && _impl_.filter_ != nullptr;
}
inline bool SubscribeRequest::has_filter() const {
  return _internal_has_filter();
}
inline void SubscribeRequest::clear_filter() {
  if (GetArenaForAllocation() == nullptr && _impl_.filter_ != nullptr) {
    delete _impl_.filter_;
  }
  _impl_.filter_ = nullptr;
}
inline const ::unhinged::cdc::EventFilter& SubscribeRequest::_internal_filter() const {
  const ::unhinged::cdc::EventFilter* p = _impl_.filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::cdc::EventFilter&>(
      ::unhinged::cdc::_EventFilter_default_instance_);
}
inline const ::unhinged::cdc::EventFilter& SubscribeRequest::filter() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.SubscribeRequest.filter)
  return _internal_filter();
}
inline void SubscribeRequest::unsafe_arena_set_allocated_filter(
    ::unhinged::cdc::EventFilter* filter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.filter_);
  }
  _impl_.filter_ = filter;
  if (filter) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.SubscribeRequest.filter)
}
inline ::unhinged::cdc::EventFilter* SubscribeRequest::release_filter() {
  
  ::unhinged::cdc::EventFilter* temp = _impl_.filter_;
  _impl_.filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::cdc::EventFilter* SubscribeRequest::unsafe_arena_release_filter() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.SubscribeRequest.filter)
  
  ::unhinged::cdc::EventFilter* temp = _impl_.filter_;
  _impl_.filter_ = nullptr;
  return temp;
}
inline ::unhinged::cdc::EventFilter* SubscribeRequest::_internal_mutable_filter() {
  
  if (_impl_.filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::cdc::EventFilter>(GetArenaForAllocation());
    _impl_.filter_ = p;
  }
  return _impl_.filter_;
}
inline ::unhinged::cdc::EventFilter* SubscribeRequest::mutable_filter() {
  ::unhinged::cdc::EventFilter* _msg = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.SubscribeRequest.filter)
  return _msg;
}
inline void SubscribeRequest::set_allocated_filter(::unhinged::cdc::EventFilter* filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.filter_;
  }
  if (filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(filter);
    if (message_arena != submessage_arena) {
      filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, filter, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.filter_ = filter;
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.SubscribeRequest.filter)
}

// .unhinged.cdc.SubscriptionOptions options = 4;
inline bool SubscribeRequest::_internal_has_options() const {
  return this != internal_default_instance() && _impl_.options_ != nullptr;
}
inline bool SubscribeRequest::has_options() const {
  return _internal_has_options();
}
inline void SubscribeRequest::clear_options() {
  if (GetArenaForAllocation() == nullptr && _impl_.options_ != nullptr) {
    delete _impl_.options_;
  }
  _impl_.options_ = nullptr;
}
inline const ::unhinged::cdc::SubscriptionOptions& SubscribeRequest::_internal_options() const {
  const ::unhinged::cdc::SubscriptionOptions* p = _impl_.options_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::cdc::SubscriptionOptions&>(
      ::unhinged::cdc::_SubscriptionOptions_default_instance_);
}
inline const ::unhinged::cdc::SubscriptionOptions& SubscribeRequest::options() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.SubscribeRequest.options)
  return _internal_options();
}
inline void SubscribeRequest::unsafe_arena_set_allocated_options(
    ::unhinged::cdc::SubscriptionOptions* options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.options_);
  }
  _impl_.options_ = options;
  if (options) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.SubscribeRequest.options)
}
inline ::unhinged::cdc::SubscriptionOptions* SubscribeRequest::release_options() {
  
  ::unhinged::cdc::SubscriptionOptions* temp = _impl_.options_;
  _impl_.options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::cdc::SubscriptionOptions* SubscribeRequest::unsafe_arena_release_options() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.SubscribeRequest.options)
  
  ::unhinged::cdc::SubscriptionOptions* temp = _impl_.options_;
  _impl_.options_ = nullptr;
  return temp;
}
inline ::unhinged::cdc::SubscriptionOptions* SubscribeRequest::_internal_mutable_options() {
  
  if (_impl_.options_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::cdc::SubscriptionOptions>(GetArenaForAllocation());
    _impl_.options_ = p;
  }
  return _impl_.options_;
}
inline ::unhinged::cdc::SubscriptionOptions* SubscribeRequest::mutable_options() {
  ::unhinged::cdc::SubscriptionOptions* _msg = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.SubscribeRequest.options)
  return _msg;
}
inline void SubscribeRequest::set_allocated_options(::unhinged::cdc::SubscriptionOptions* options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.options_;
  }
  if (options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(options);
    if (message_arena != submessage_arena) {
      options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.options_ = options;
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.SubscribeRequest.options)
}

// -------------------------------------------------------------------

// EventFilter

// repeated string event_types = 1;
inline int EventFilter::_internal_event_types_size() const {
  return _impl_.event_types_.size();
}
inline int EventFilter::event_types_size() const {
  return _internal_event_types_size();
}
inline void EventFilter::clear_event_types() {
  _impl_.event_types_.Clear();
}
inline std::string* EventFilter::add_event_types() {
  std::string* _s = _internal_add_event_types();
  // @@protoc_insertion_point(field_add_mutable:unhinged.cdc.EventFilter.event_types)
  return _s;
}
inline const std::string& EventFilter::_internal_event_types(int index) const {
  return _impl_.event_types_.Get(index);
}
inline const std::string& EventFilter::event_types(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.EventFilter.event_types)
  return _internal_event_types(index);
}
inline std::string* EventFilter::mutable_event_types(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.EventFilter.event_types)
  return _impl_.event_types_.Mutable(index);
}
inline void EventFilter::set_event_types(int index, const std::string& value) {
  _impl_.event_types_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.EventFilter.event_types)
}
inline void EventFilter::set_event_types(int index, std::string&& value) {
  _impl_.event_types_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.cdc.EventFilter.event_types)
}
inline void EventFilter::set_event_types(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.event_types_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.cdc.EventFilter.event_types)
}
inline void EventFilter::set_event_types(int index, const char* value, size_t size) {
  _impl_.event_types_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.cdc.EventFilter.event_types)
}
inline std::string* EventFilter::_internal_add_event_types() {
  return _impl_.event_types_.Add();
}
inline void EventFilter::add_event_types(const std::string& value) {
  _impl_.event_types_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.cdc.EventFilter.event_types)
}
inline void EventFilter::add_event_types(std::string&& value) {
  _impl_.event_types_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.cdc.EventFilter.event_types)
}
inline void EventFilter::add_event_types(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.event_types_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.cdc.EventFilter.event_types)
}
inline void EventFilter::add_event_types(const char* value, size_t size) {
  _impl_.event_types_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.cdc.EventFilter.event_types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
EventFilter::event_types() const {
  // @@protoc_insertion_point(field_list:unhinged.cdc.EventFilter.event_types)
  return _impl_.event_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
EventFilter::mutable_event_types() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.cdc.EventFilter.event_types)
  return &_impl_.event_types_;
}

// repeated string source_services = 2;
inline int EventFilter::_internal_source_services_size() const {
  return _impl_.source_services_.size();
}
inline int EventFilter::source_services_size() const {
  return _internal_source_services_size();
}
inline void EventFilter::clear_source_services() {
  _impl_.source_services_.Clear();
}
inline std::string* EventFilter::add_source_services() {
  std::string* _s = _internal_add_source_services();
  // @@protoc_insertion_point(field_add_mutable:unhinged.cdc.EventFilter.source_services)
  return _s;
}
inline const std::string& EventFilter::_internal_source_services(int index) const {
  return _impl_.source_services_.Get(index);
}
inline const std::string& EventFilter::source_services(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.EventFilter.source_services)
  return _internal_source_services(index);
}
inline std::string* EventFilter::mutable_source_services(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.EventFilter.source_services)
  return _impl_.source_services_.Mutable(index);
}
inline void EventFilter::set_source_services(int index, const std::string& value) {
  _impl_.source_services_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.EventFilter.source_services)
}
inline void EventFilter::set_source_services(int index, std::string&& value) {
  _impl_.source_services_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.cdc.EventFilter.source_services)
}
inline void EventFilter::set_source_services(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.source_services_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.cdc.EventFilter.source_services)
}
inline void EventFilter::set_source_services(int index, const char* value, size_t size) {
  _impl_.source_services_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.cdc.EventFilter.source_services)
}
inline std::string* EventFilter::_internal_add_source_services() {
  return _impl_.source_services_.Add();
}
inline void EventFilter::add_source_services(const std::string& value) {
  _impl_.source_services_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.cdc.EventFilter.source_services)
}
inline void EventFilter::add_source_services(std::string&& value) {
  _impl_.source_services_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.cdc.EventFilter.source_services)
}
inline void EventFilter::add_source_services(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.source_services_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.cdc.EventFilter.source_services)
}
inline void EventFilter::add_source_services(const char* value, size_t size) {
  _impl_.source_services_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.cdc.EventFilter.source_services)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
EventFilter::source_services() const {
  // @@protoc_insertion_point(field_list:unhinged.cdc.EventFilter.source_services)
  return _impl_.source_services_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
EventFilter::mutable_source_services() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.cdc.EventFilter.source_services)
  return &_impl_.source_services_;
}

// repeated string user_ids = 3;
inline int EventFilter::_internal_user_ids_size() const {
  return _impl_.user_ids_.size();
}
inline int EventFilter::user_ids_size() const {
  return _internal_user_ids_size();
}
inline void EventFilter::clear_user_ids() {
  _impl_.user_ids_.Clear();
}
inline std::string* EventFilter::add_user_ids() {
  std::string* _s = _internal_add_user_ids();
  // @@protoc_insertion_point(field_add_mutable:unhinged.cdc.EventFilter.user_ids)
  return _s;
}
inline const std::string& EventFilter::_internal_user_ids(int index) const {
  return _impl_.user_ids_.Get(index);
}
inline const std::string& EventFilter::user_ids(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.EventFilter.user_ids)
  return _internal_user_ids(index);
}
inline std::string* EventFilter::mutable_user_ids(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.EventFilter.user_ids)
  return _impl_.user_ids_.Mutable(index);
}
inline void EventFilter::set_user_ids(int index, const std::string& value) {
  _impl_.user_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.EventFilter.user_ids)
}
inline void EventFilter::set_user_ids(int index, std::string&& value) {
  _impl_.user_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.cdc.EventFilter.user_ids)
}
inline void EventFilter::set_user_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.user_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.cdc.EventFilter.user_ids)
}
inline void EventFilter::set_user_ids(int index, const char* value, size_t size) {
  _impl_.user_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.cdc.EventFilter.user_ids)
}
inline std::string* EventFilter::_internal_add_user_ids() {
  return _impl_.user_ids_.Add();
}
inline void EventFilter::add_user_ids(const std::string& value) {
  _impl_.user_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.cdc.EventFilter.user_ids)
}
inline void EventFilter::add_user_ids(std::string&& value) {
  _impl_.user_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.cdc.EventFilter.user_ids)
}
inline void EventFilter::add_user_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.user_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.cdc.EventFilter.user_ids)
}
inline void EventFilter::add_user_ids(const char* value, size_t size) {
  _impl_.user_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.cdc.EventFilter.user_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
EventFilter::user_ids() const {
  // @@protoc_insertion_point(field_list:unhinged.cdc.EventFilter.user_ids)
  return _impl_.user_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
EventFilter::mutable_user_ids() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.cdc.EventFilter.user_ids)
  return &_impl_.user_ids_;
}

// repeated string session_ids = 4;
inline int EventFilter::_internal_session_ids_size() const {
  return _impl_.session_ids_.size();
}
inline int EventFilter::session_ids_size() const {
  return _internal_session_ids_size();
}
inline void EventFilter::clear_session_ids() {
  _impl_.session_ids_.Clear();
}
inline std::string* EventFilter::add_session_ids() {
  std::string* _s = _internal_add_session_ids();
  // @@protoc_insertion_point(field_add_mutable:unhinged.cdc.EventFilter.session_ids)
  return _s;
}
inline const std::string& EventFilter::_internal_session_ids(int index) const {
  return _impl_.session_ids_.Get(index);
}
inline const std::string& EventFilter::session_ids(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.EventFilter.session_ids)
  return _internal_session_ids(index);
}
inline std::string* EventFilter::mutable_session_ids(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.EventFilter.session_ids)
  return _impl_.session_ids_.Mutable(index);
}
inline void EventFilter::set_session_ids(int index, const std::string& value) {
  _impl_.session_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.EventFilter.session_ids)
}
inline void EventFilter::set_session_ids(int index, std::string&& value) {
  _impl_.session_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.cdc.EventFilter.session_ids)
}
inline void EventFilter::set_session_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.session_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.cdc.EventFilter.session_ids)
}
inline void EventFilter::set_session_ids(int index, const char* value, size_t size) {
  _impl_.session_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.cdc.EventFilter.session_ids)
}
inline std::string* EventFilter::_internal_add_session_ids() {
  return _impl_.session_ids_.Add();
}
inline void EventFilter::add_session_ids(const std::string& value) {
  _impl_.session_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.cdc.EventFilter.session_ids)
}
inline void EventFilter::add_session_ids(std::string&& value) {
  _impl_.session_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.cdc.EventFilter.session_ids)
}
inline void EventFilter::add_session_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.session_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.cdc.EventFilter.session_ids)
}
inline void EventFilter::add_session_ids(const char* value, size_t size) {
  _impl_.session_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.cdc.EventFilter.session_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
EventFilter::session_ids() const {
  // @@protoc_insertion_point(field_list:unhinged.cdc.EventFilter.session_ids)
  return _impl_.session_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
EventFilter::mutable_session_ids() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.cdc.EventFilter.session_ids)
  return &_impl_.session_ids_;
}

// repeated string tags = 5;
inline int EventFilter::_internal_tags_size() const {
  return _impl_.tags_.size();
}
inline int EventFilter::tags_size() const {
  return _internal_tags_size();
}
inline void EventFilter::clear_tags() {
  _impl_.tags_.Clear();
}
inline std::string* EventFilter::add_tags() {
  std::string* _s = _internal_add_tags();
  // @@protoc_insertion_point(field_add_mutable:unhinged.cdc.EventFilter.tags)
  return _s;
}
inline const std::string& EventFilter::_internal_tags(int index) const {
  return _impl_.tags_.Get(index);
}
inline const std::string& EventFilter::tags(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.EventFilter.tags)
  return _internal_tags(index);
}
inline std::string* EventFilter::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.EventFilter.tags)
  return _impl_.tags_.Mutable(index);
}
inline void EventFilter::set_tags(int index, const std::string& value) {
  _impl_.tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.EventFilter.tags)
}
inline void EventFilter::set_tags(int index, std::string&& value) {
  _impl_.tags_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.cdc.EventFilter.tags)
}
inline void EventFilter::set_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.cdc.EventFilter.tags)
}
inline void EventFilter::set_tags(int index, const char* value, size_t size) {
  _impl_.tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.cdc.EventFilter.tags)
}
inline std::string* EventFilter::_internal_add_tags() {
  return _impl_.tags_.Add();
}
inline void EventFilter::add_tags(const std::string& value) {
  _impl_.tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.cdc.EventFilter.tags)
}
inline void EventFilter::add_tags(std::string&& value) {
  _impl_.tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.cdc.EventFilter.tags)
}
inline void EventFilter::add_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.cdc.EventFilter.tags)
}
inline void EventFilter::add_tags(const char* value, size_t size) {
  _impl_.tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.cdc.EventFilter.tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
EventFilter::tags() const {
  // @@protoc_insertion_point(field_list:unhinged.cdc.EventFilter.tags)
  return _impl_.tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
EventFilter::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.cdc.EventFilter.tags)
  return &_impl_.tags_;
}

// .google.protobuf.Timestamp start_time = 6;
inline bool EventFilter::_internal_has_start_time() const {
  return this != internal_default_instance() && _impl_.start_time_ != nullptr;
}
inline bool EventFilter::has_start_time() const {
  return _internal_has_start_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& EventFilter::_internal_start_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.start_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& EventFilter::start_time() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.EventFilter.start_time)
  return _internal_start_time();
}
inline void EventFilter::unsafe_arena_set_allocated_start_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_time_);
  }
  _impl_.start_time_ = start_time;
  if (start_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.EventFilter.start_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* EventFilter::release_start_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.start_time_;
  _impl_.start_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* EventFilter::unsafe_arena_release_start_time() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.EventFilter.start_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.start_time_;
  _impl_.start_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* EventFilter::_internal_mutable_start_time() {
  
  if (_impl_.start_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.start_time_ = p;
  }
  return _impl_.start_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* EventFilter::mutable_start_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_start_time();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.EventFilter.start_time)
  return _msg;
}
inline void EventFilter::set_allocated_start_time(::PROTOBUF_NAMESPACE_ID::Timestamp* start_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_time_);
  }
  if (start_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_time));
    if (message_arena != submessage_arena) {
      start_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.start_time_ = start_time;
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.EventFilter.start_time)
}

// .google.protobuf.Timestamp end_time = 7;
inline bool EventFilter::_internal_has_end_time() const {
  return this != internal_default_instance() && _impl_.end_time_ != nullptr;
}
inline bool EventFilter::has_end_time() const {
  return _internal_has_end_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& EventFilter::_internal_end_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.end_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& EventFilter::end_time() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.EventFilter.end_time)
  return _internal_end_time();
}
inline void EventFilter::unsafe_arena_set_allocated_end_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_time_);
  }
  _impl_.end_time_ = end_time;
  if (end_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.EventFilter.end_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* EventFilter::release_end_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.end_time_;
  _impl_.end_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* EventFilter::unsafe_arena_release_end_time() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.EventFilter.end_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.end_time_;
  _impl_.end_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* EventFilter::_internal_mutable_end_time() {
  
  if (_impl_.end_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.end_time_ = p;
  }
  return _impl_.end_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* EventFilter::mutable_end_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_end_time();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.EventFilter.end_time)
  return _msg;
}
inline void EventFilter::set_allocated_end_time(::PROTOBUF_NAMESPACE_ID::Timestamp* end_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_time_);
  }
  if (end_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_time));
    if (message_arena != submessage_arena) {
      end_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.end_time_ = end_time;
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.EventFilter.end_time)
}

// string jq_filter = 8;
inline void EventFilter::clear_jq_filter() {
  _impl_.jq_filter_.ClearToEmpty();
}
inline const std::string& EventFilter::jq_filter() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.EventFilter.jq_filter)
  return _internal_jq_filter();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EventFilter::set_jq_filter(ArgT0&& arg0, ArgT... args) {
 
 _impl_.jq_filter_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.EventFilter.jq_filter)
}
inline std::string* EventFilter::mutable_jq_filter() {
  std::string* _s = _internal_mutable_jq_filter();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.EventFilter.jq_filter)
  return _s;
}
inline const std::string& EventFilter::_internal_jq_filter() const {
  return _impl_.jq_filter_.Get();
}
inline void EventFilter::_internal_set_jq_filter(const std::string& value) {
  
  _impl_.jq_filter_.Set(value, GetArenaForAllocation());
}
inline std::string* EventFilter::_internal_mutable_jq_filter() {
  
  return _impl_.jq_filter_.Mutable(GetArenaForAllocation());
}
inline std::string* EventFilter::release_jq_filter() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.EventFilter.jq_filter)
  return _impl_.jq_filter_.Release();
}
inline void EventFilter::set_allocated_jq_filter(std::string* jq_filter) {
  if (jq_filter != nullptr) {
    
  } else {
    
  }
  _impl_.jq_filter_.SetAllocated(jq_filter, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.jq_filter_.IsDefault()) {
    _impl_.jq_filter_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.EventFilter.jq_filter)
}

// .google.protobuf.Struct metadata_filter = 9;
inline bool EventFilter::_internal_has_metadata_filter() const {
  return this != internal_default_instance() && _impl_.metadata_filter_ != nullptr;
}
inline bool EventFilter::has_metadata_filter() const {
  return _internal_has_metadata_filter();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& EventFilter::_internal_metadata_filter() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.metadata_filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& EventFilter::metadata_filter() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.EventFilter.metadata_filter)
  return _internal_metadata_filter();
}
inline void EventFilter::unsafe_arena_set_allocated_metadata_filter(
    ::PROTOBUF_NAMESPACE_ID::Struct* metadata_filter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_filter_);
  }
  _impl_.metadata_filter_ = metadata_filter;
  if (metadata_filter) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.EventFilter.metadata_filter)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* EventFilter::release_metadata_filter() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.metadata_filter_;
  _impl_.metadata_filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* EventFilter::unsafe_arena_release_metadata_filter() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.EventFilter.metadata_filter)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.metadata_filter_;
  _impl_.metadata_filter_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* EventFilter::_internal_mutable_metadata_filter() {
  
  if (_impl_.metadata_filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.metadata_filter_ = p;
  }
  return _impl_.metadata_filter_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* EventFilter::mutable_metadata_filter() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_metadata_filter();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.EventFilter.metadata_filter)
  return _msg;
}
inline void EventFilter::set_allocated_metadata_filter(::PROTOBUF_NAMESPACE_ID::Struct* metadata_filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_filter_);
  }
  if (metadata_filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_filter));
    if (message_arena != submessage_arena) {
      metadata_filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata_filter, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.metadata_filter_ = metadata_filter;
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.EventFilter.metadata_filter)
}

// -------------------------------------------------------------------

// SubscriptionOptions

// string delivery_mode = 1;
inline void SubscriptionOptions::clear_delivery_mode() {
  _impl_.delivery_mode_.ClearToEmpty();
}
inline const std::string& SubscriptionOptions::delivery_mode() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.SubscriptionOptions.delivery_mode)
  return _internal_delivery_mode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubscriptionOptions::set_delivery_mode(ArgT0&& arg0, ArgT... args) {
 
 _impl_.delivery_mode_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.SubscriptionOptions.delivery_mode)
}
inline std::string* SubscriptionOptions::mutable_delivery_mode() {
  std::string* _s = _internal_mutable_delivery_mode();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.SubscriptionOptions.delivery_mode)
  return _s;
}
inline const std::string& SubscriptionOptions::_internal_delivery_mode() const {
  return _impl_.delivery_mode_.Get();
}
inline void SubscriptionOptions::_internal_set_delivery_mode(const std::string& value) {
  
  _impl_.delivery_mode_.Set(value, GetArenaForAllocation());
}
inline std::string* SubscriptionOptions::_internal_mutable_delivery_mode() {
  
  return _impl_.delivery_mode_.Mutable(GetArenaForAllocation());
}
inline std::string* SubscriptionOptions::release_delivery_mode() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.SubscriptionOptions.delivery_mode)
  return _impl_.delivery_mode_.Release();
}
inline void SubscriptionOptions::set_allocated_delivery_mode(std::string* delivery_mode) {
  if (delivery_mode != nullptr) {
    
  } else {
    
  }
  _impl_.delivery_mode_.SetAllocated(delivery_mode, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.delivery_mode_.IsDefault()) {
    _impl_.delivery_mode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.SubscriptionOptions.delivery_mode)
}

// int32 batch_size = 2;
inline void SubscriptionOptions::clear_batch_size() {
  _impl_.batch_size_ = 0;
}
inline int32_t SubscriptionOptions::_internal_batch_size() const {
  return _impl_.batch_size_;
}
inline int32_t SubscriptionOptions::batch_size() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.SubscriptionOptions.batch_size)
  return _internal_batch_size();
}
inline void SubscriptionOptions::_internal_set_batch_size(int32_t value) {
  
  _impl_.batch_size_ = value;
}
inline void SubscriptionOptions::set_batch_size(int32_t value) {
  _internal_set_batch_size(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.SubscriptionOptions.batch_size)
}

// int32 batch_timeout_ms = 3;
inline void SubscriptionOptions::clear_batch_timeout_ms() {
  _impl_.batch_timeout_ms_ = 0;
}
inline int32_t SubscriptionOptions::_internal_batch_timeout_ms() const {
  return _impl_.batch_timeout_ms_;
}
inline int32_t SubscriptionOptions::batch_timeout_ms() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.SubscriptionOptions.batch_timeout_ms)
  return _internal_batch_timeout_ms();
}
inline void SubscriptionOptions::_internal_set_batch_timeout_ms(int32_t value) {
  
  _impl_.batch_timeout_ms_ = value;
}
inline void SubscriptionOptions::set_batch_timeout_ms(int32_t value) {
  _internal_set_batch_timeout_ms(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.SubscriptionOptions.batch_timeout_ms)
}

// bool replay_from_beginning = 4;
inline void SubscriptionOptions::clear_replay_from_beginning() {
  _impl_.replay_from_beginning_ = false;
}
inline bool SubscriptionOptions::_internal_replay_from_beginning() const {
  return _impl_.replay_from_beginning_;
}
inline bool SubscriptionOptions::replay_from_beginning() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.SubscriptionOptions.replay_from_beginning)
  return _internal_replay_from_beginning();
}
inline void SubscriptionOptions::_internal_set_replay_from_beginning(bool value) {
  
  _impl_.replay_from_beginning_ = value;
}
inline void SubscriptionOptions::set_replay_from_beginning(bool value) {
  _internal_set_replay_from_beginning(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.SubscriptionOptions.replay_from_beginning)
}

// int64 replay_from_sequence = 5;
inline void SubscriptionOptions::clear_replay_from_sequence() {
  _impl_.replay_from_sequence_ = int64_t{0};
}
inline int64_t SubscriptionOptions::_internal_replay_from_sequence() const {
  return _impl_.replay_from_sequence_;
}
inline int64_t SubscriptionOptions::replay_from_sequence() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.SubscriptionOptions.replay_from_sequence)
  return _internal_replay_from_sequence();
}
inline void SubscriptionOptions::_internal_set_replay_from_sequence(int64_t value) {
  
  _impl_.replay_from_sequence_ = value;
}
inline void SubscriptionOptions::set_replay_from_sequence(int64_t value) {
  _internal_set_replay_from_sequence(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.SubscriptionOptions.replay_from_sequence)
}

// .google.protobuf.Timestamp replay_from_time = 6;
inline bool SubscriptionOptions::_internal_has_replay_from_time() const {
  return this != internal_default_instance() && _impl_.replay_from_time_ != nullptr;
}
inline bool SubscriptionOptions::has_replay_from_time() const {
  return _internal_has_replay_from_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SubscriptionOptions::_internal_replay_from_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.replay_from_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SubscriptionOptions::replay_from_time() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.SubscriptionOptions.replay_from_time)
  return _internal_replay_from_time();
}
inline void SubscriptionOptions::unsafe_arena_set_allocated_replay_from_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* replay_from_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.replay_from_time_);
  }
  _impl_.replay_from_time_ = replay_from_time;
  if (replay_from_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.SubscriptionOptions.replay_from_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SubscriptionOptions::release_replay_from_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.replay_from_time_;
  _impl_.replay_from_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SubscriptionOptions::unsafe_arena_release_replay_from_time() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.SubscriptionOptions.replay_from_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.replay_from_time_;
  _impl_.replay_from_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SubscriptionOptions::_internal_mutable_replay_from_time() {
  
  if (_impl_.replay_from_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.replay_from_time_ = p;
  }
  return _impl_.replay_from_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SubscriptionOptions::mutable_replay_from_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_replay_from_time();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.SubscriptionOptions.replay_from_time)
  return _msg;
}
inline void SubscriptionOptions::set_allocated_replay_from_time(::PROTOBUF_NAMESPACE_ID::Timestamp* replay_from_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.replay_from_time_);
  }
  if (replay_from_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(replay_from_time));
    if (message_arena != submessage_arena) {
      replay_from_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, replay_from_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.replay_from_time_ = replay_from_time;
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.SubscriptionOptions.replay_from_time)
}

// int32 max_retry_attempts = 7;
inline void SubscriptionOptions::clear_max_retry_attempts() {
  _impl_.max_retry_attempts_ = 0;
}
inline int32_t SubscriptionOptions::_internal_max_retry_attempts() const {
  return _impl_.max_retry_attempts_;
}
inline int32_t SubscriptionOptions::max_retry_attempts() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.SubscriptionOptions.max_retry_attempts)
  return _internal_max_retry_attempts();
}
inline void SubscriptionOptions::_internal_set_max_retry_attempts(int32_t value) {
  
  _impl_.max_retry_attempts_ = value;
}
inline void SubscriptionOptions::set_max_retry_attempts(int32_t value) {
  _internal_set_max_retry_attempts(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.SubscriptionOptions.max_retry_attempts)
}

// int32 retry_backoff_ms = 8;
inline void SubscriptionOptions::clear_retry_backoff_ms() {
  _impl_.retry_backoff_ms_ = 0;
}
inline int32_t SubscriptionOptions::_internal_retry_backoff_ms() const {
  return _impl_.retry_backoff_ms_;
}
inline int32_t SubscriptionOptions::retry_backoff_ms() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.SubscriptionOptions.retry_backoff_ms)
  return _internal_retry_backoff_ms();
}
inline void SubscriptionOptions::_internal_set_retry_backoff_ms(int32_t value) {
  
  _impl_.retry_backoff_ms_ = value;
}
inline void SubscriptionOptions::set_retry_backoff_ms(int32_t value) {
  _internal_set_retry_backoff_ms(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.SubscriptionOptions.retry_backoff_ms)
}

// bool send_to_dlq_on_failure = 9;
inline void SubscriptionOptions::clear_send_to_dlq_on_failure() {
  _impl_.send_to_dlq_on_failure_ = false;
}
inline bool SubscriptionOptions::_internal_send_to_dlq_on_failure() const {
  return _impl_.send_to_dlq_on_failure_;
}
inline bool SubscriptionOptions::send_to_dlq_on_failure() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.SubscriptionOptions.send_to_dlq_on_failure)
  return _internal_send_to_dlq_on_failure();
}
inline void SubscriptionOptions::_internal_set_send_to_dlq_on_failure(bool value) {
  
  _impl_.send_to_dlq_on_failure_ = value;
}
inline void SubscriptionOptions::set_send_to_dlq_on_failure(bool value) {
  _internal_set_send_to_dlq_on_failure(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.SubscriptionOptions.send_to_dlq_on_failure)
}

// -------------------------------------------------------------------

// EventStreamResponse

// .unhinged.cdc.EventBatch event_batch = 1;
inline bool EventStreamResponse::_internal_has_event_batch() const {
  return response_type_case() == kEventBatch;
}
inline bool EventStreamResponse::has_event_batch() const {
  return _internal_has_event_batch();
}
inline void EventStreamResponse::set_has_event_batch() {
  _impl_._oneof_case_[0] = kEventBatch;
}
inline void EventStreamResponse::clear_event_batch() {
  if (_internal_has_event_batch()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_type_.event_batch_;
    }
    clear_has_response_type();
  }
}
inline ::unhinged::cdc::EventBatch* EventStreamResponse::release_event_batch() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.EventStreamResponse.event_batch)
  if (_internal_has_event_batch()) {
    clear_has_response_type();
    ::unhinged::cdc::EventBatch* temp = _impl_.response_type_.event_batch_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.event_batch_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::cdc::EventBatch& EventStreamResponse::_internal_event_batch() const {
  return _internal_has_event_batch()
      ? *_impl_.response_type_.event_batch_
      : reinterpret_cast< ::unhinged::cdc::EventBatch&>(::unhinged::cdc::_EventBatch_default_instance_);
}
inline const ::unhinged::cdc::EventBatch& EventStreamResponse::event_batch() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.EventStreamResponse.event_batch)
  return _internal_event_batch();
}
inline ::unhinged::cdc::EventBatch* EventStreamResponse::unsafe_arena_release_event_batch() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.cdc.EventStreamResponse.event_batch)
  if (_internal_has_event_batch()) {
    clear_has_response_type();
    ::unhinged::cdc::EventBatch* temp = _impl_.response_type_.event_batch_;
    _impl_.response_type_.event_batch_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventStreamResponse::unsafe_arena_set_allocated_event_batch(::unhinged::cdc::EventBatch* event_batch) {
  clear_response_type();
  if (event_batch) {
    set_has_event_batch();
    _impl_.response_type_.event_batch_ = event_batch;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.EventStreamResponse.event_batch)
}
inline ::unhinged::cdc::EventBatch* EventStreamResponse::_internal_mutable_event_batch() {
  if (!_internal_has_event_batch()) {
    clear_response_type();
    set_has_event_batch();
    _impl_.response_type_.event_batch_ = CreateMaybeMessage< ::unhinged::cdc::EventBatch >(GetArenaForAllocation());
  }
  return _impl_.response_type_.event_batch_;
}
inline ::unhinged::cdc::EventBatch* EventStreamResponse::mutable_event_batch() {
  ::unhinged::cdc::EventBatch* _msg = _internal_mutable_event_batch();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.EventStreamResponse.event_batch)
  return _msg;
}

// .unhinged.cdc.SubscriptionStatus status = 2;
inline bool EventStreamResponse::_internal_has_status() const {
  return response_type_case() == kStatus;
}
inline bool EventStreamResponse::has_status() const {
  return _internal_has_status();
}
inline void EventStreamResponse::set_has_status() {
  _impl_._oneof_case_[0] = kStatus;
}
inline void EventStreamResponse::clear_status() {
  if (_internal_has_status()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_type_.status_;
    }
    clear_has_response_type();
  }
}
inline ::unhinged::cdc::SubscriptionStatus* EventStreamResponse::release_status() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.EventStreamResponse.status)
  if (_internal_has_status()) {
    clear_has_response_type();
    ::unhinged::cdc::SubscriptionStatus* temp = _impl_.response_type_.status_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.status_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::cdc::SubscriptionStatus& EventStreamResponse::_internal_status() const {
  return _internal_has_status()
      ? *_impl_.response_type_.status_
      : reinterpret_cast< ::unhinged::cdc::SubscriptionStatus&>(::unhinged::cdc::_SubscriptionStatus_default_instance_);
}
inline const ::unhinged::cdc::SubscriptionStatus& EventStreamResponse::status() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.EventStreamResponse.status)
  return _internal_status();
}
inline ::unhinged::cdc::SubscriptionStatus* EventStreamResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.cdc.EventStreamResponse.status)
  if (_internal_has_status()) {
    clear_has_response_type();
    ::unhinged::cdc::SubscriptionStatus* temp = _impl_.response_type_.status_;
    _impl_.response_type_.status_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventStreamResponse::unsafe_arena_set_allocated_status(::unhinged::cdc::SubscriptionStatus* status) {
  clear_response_type();
  if (status) {
    set_has_status();
    _impl_.response_type_.status_ = status;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.EventStreamResponse.status)
}
inline ::unhinged::cdc::SubscriptionStatus* EventStreamResponse::_internal_mutable_status() {
  if (!_internal_has_status()) {
    clear_response_type();
    set_has_status();
    _impl_.response_type_.status_ = CreateMaybeMessage< ::unhinged::cdc::SubscriptionStatus >(GetArenaForAllocation());
  }
  return _impl_.response_type_.status_;
}
inline ::unhinged::cdc::SubscriptionStatus* EventStreamResponse::mutable_status() {
  ::unhinged::cdc::SubscriptionStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.EventStreamResponse.status)
  return _msg;
}

// .unhinged.cdc.SubscriptionError error = 3;
inline bool EventStreamResponse::_internal_has_error() const {
  return response_type_case() == kError;
}
inline bool EventStreamResponse::has_error() const {
  return _internal_has_error();
}
inline void EventStreamResponse::set_has_error() {
  _impl_._oneof_case_[0] = kError;
}
inline void EventStreamResponse::clear_error() {
  if (_internal_has_error()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_type_.error_;
    }
    clear_has_response_type();
  }
}
inline ::unhinged::cdc::SubscriptionError* EventStreamResponse::release_error() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.EventStreamResponse.error)
  if (_internal_has_error()) {
    clear_has_response_type();
    ::unhinged::cdc::SubscriptionError* temp = _impl_.response_type_.error_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::cdc::SubscriptionError& EventStreamResponse::_internal_error() const {
  return _internal_has_error()
      ? *_impl_.response_type_.error_
      : reinterpret_cast< ::unhinged::cdc::SubscriptionError&>(::unhinged::cdc::_SubscriptionError_default_instance_);
}
inline const ::unhinged::cdc::SubscriptionError& EventStreamResponse::error() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.EventStreamResponse.error)
  return _internal_error();
}
inline ::unhinged::cdc::SubscriptionError* EventStreamResponse::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.cdc.EventStreamResponse.error)
  if (_internal_has_error()) {
    clear_has_response_type();
    ::unhinged::cdc::SubscriptionError* temp = _impl_.response_type_.error_;
    _impl_.response_type_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventStreamResponse::unsafe_arena_set_allocated_error(::unhinged::cdc::SubscriptionError* error) {
  clear_response_type();
  if (error) {
    set_has_error();
    _impl_.response_type_.error_ = error;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.EventStreamResponse.error)
}
inline ::unhinged::cdc::SubscriptionError* EventStreamResponse::_internal_mutable_error() {
  if (!_internal_has_error()) {
    clear_response_type();
    set_has_error();
    _impl_.response_type_.error_ = CreateMaybeMessage< ::unhinged::cdc::SubscriptionError >(GetArenaForAllocation());
  }
  return _impl_.response_type_.error_;
}
inline ::unhinged::cdc::SubscriptionError* EventStreamResponse::mutable_error() {
  ::unhinged::cdc::SubscriptionError* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.EventStreamResponse.error)
  return _msg;
}

// .unhinged.cdc.Heartbeat heartbeat = 4;
inline bool EventStreamResponse::_internal_has_heartbeat() const {
  return response_type_case() == kHeartbeat;
}
inline bool EventStreamResponse::has_heartbeat() const {
  return _internal_has_heartbeat();
}
inline void EventStreamResponse::set_has_heartbeat() {
  _impl_._oneof_case_[0] = kHeartbeat;
}
inline void EventStreamResponse::clear_heartbeat() {
  if (_internal_has_heartbeat()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_type_.heartbeat_;
    }
    clear_has_response_type();
  }
}
inline ::unhinged::cdc::Heartbeat* EventStreamResponse::release_heartbeat() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.EventStreamResponse.heartbeat)
  if (_internal_has_heartbeat()) {
    clear_has_response_type();
    ::unhinged::cdc::Heartbeat* temp = _impl_.response_type_.heartbeat_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.heartbeat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::cdc::Heartbeat& EventStreamResponse::_internal_heartbeat() const {
  return _internal_has_heartbeat()
      ? *_impl_.response_type_.heartbeat_
      : reinterpret_cast< ::unhinged::cdc::Heartbeat&>(::unhinged::cdc::_Heartbeat_default_instance_);
}
inline const ::unhinged::cdc::Heartbeat& EventStreamResponse::heartbeat() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.EventStreamResponse.heartbeat)
  return _internal_heartbeat();
}
inline ::unhinged::cdc::Heartbeat* EventStreamResponse::unsafe_arena_release_heartbeat() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.cdc.EventStreamResponse.heartbeat)
  if (_internal_has_heartbeat()) {
    clear_has_response_type();
    ::unhinged::cdc::Heartbeat* temp = _impl_.response_type_.heartbeat_;
    _impl_.response_type_.heartbeat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EventStreamResponse::unsafe_arena_set_allocated_heartbeat(::unhinged::cdc::Heartbeat* heartbeat) {
  clear_response_type();
  if (heartbeat) {
    set_has_heartbeat();
    _impl_.response_type_.heartbeat_ = heartbeat;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.EventStreamResponse.heartbeat)
}
inline ::unhinged::cdc::Heartbeat* EventStreamResponse::_internal_mutable_heartbeat() {
  if (!_internal_has_heartbeat()) {
    clear_response_type();
    set_has_heartbeat();
    _impl_.response_type_.heartbeat_ = CreateMaybeMessage< ::unhinged::cdc::Heartbeat >(GetArenaForAllocation());
  }
  return _impl_.response_type_.heartbeat_;
}
inline ::unhinged::cdc::Heartbeat* EventStreamResponse::mutable_heartbeat() {
  ::unhinged::cdc::Heartbeat* _msg = _internal_mutable_heartbeat();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.EventStreamResponse.heartbeat)
  return _msg;
}

inline bool EventStreamResponse::has_response_type() const {
  return response_type_case() != RESPONSE_TYPE_NOT_SET;
}
inline void EventStreamResponse::clear_has_response_type() {
  _impl_._oneof_case_[0] = RESPONSE_TYPE_NOT_SET;
}
inline EventStreamResponse::ResponseTypeCase EventStreamResponse::response_type_case() const {
  return EventStreamResponse::ResponseTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// EventBatch

// repeated .unhinged.cdc.UniversalEvent events = 1;
inline int EventBatch::_internal_events_size() const {
  return _impl_.events_.size();
}
inline int EventBatch::events_size() const {
  return _internal_events_size();
}
inline ::unhinged::cdc::UniversalEvent* EventBatch::mutable_events(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.EventBatch.events)
  return _impl_.events_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::cdc::UniversalEvent >*
EventBatch::mutable_events() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.cdc.EventBatch.events)
  return &_impl_.events_;
}
inline const ::unhinged::cdc::UniversalEvent& EventBatch::_internal_events(int index) const {
  return _impl_.events_.Get(index);
}
inline const ::unhinged::cdc::UniversalEvent& EventBatch::events(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.EventBatch.events)
  return _internal_events(index);
}
inline ::unhinged::cdc::UniversalEvent* EventBatch::_internal_add_events() {
  return _impl_.events_.Add();
}
inline ::unhinged::cdc::UniversalEvent* EventBatch::add_events() {
  ::unhinged::cdc::UniversalEvent* _add = _internal_add_events();
  // @@protoc_insertion_point(field_add:unhinged.cdc.EventBatch.events)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::cdc::UniversalEvent >&
EventBatch::events() const {
  // @@protoc_insertion_point(field_list:unhinged.cdc.EventBatch.events)
  return _impl_.events_;
}

// int64 batch_sequence = 2;
inline void EventBatch::clear_batch_sequence() {
  _impl_.batch_sequence_ = int64_t{0};
}
inline int64_t EventBatch::_internal_batch_sequence() const {
  return _impl_.batch_sequence_;
}
inline int64_t EventBatch::batch_sequence() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.EventBatch.batch_sequence)
  return _internal_batch_sequence();
}
inline void EventBatch::_internal_set_batch_sequence(int64_t value) {
  
  _impl_.batch_sequence_ = value;
}
inline void EventBatch::set_batch_sequence(int64_t value) {
  _internal_set_batch_sequence(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.EventBatch.batch_sequence)
}

// .google.protobuf.Timestamp batch_time = 3;
inline bool EventBatch::_internal_has_batch_time() const {
  return this != internal_default_instance() && _impl_.batch_time_ != nullptr;
}
inline bool EventBatch::has_batch_time() const {
  return _internal_has_batch_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& EventBatch::_internal_batch_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.batch_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& EventBatch::batch_time() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.EventBatch.batch_time)
  return _internal_batch_time();
}
inline void EventBatch::unsafe_arena_set_allocated_batch_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* batch_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.batch_time_);
  }
  _impl_.batch_time_ = batch_time;
  if (batch_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.EventBatch.batch_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* EventBatch::release_batch_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.batch_time_;
  _impl_.batch_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* EventBatch::unsafe_arena_release_batch_time() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.EventBatch.batch_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.batch_time_;
  _impl_.batch_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* EventBatch::_internal_mutable_batch_time() {
  
  if (_impl_.batch_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.batch_time_ = p;
  }
  return _impl_.batch_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* EventBatch::mutable_batch_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_batch_time();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.EventBatch.batch_time)
  return _msg;
}
inline void EventBatch::set_allocated_batch_time(::PROTOBUF_NAMESPACE_ID::Timestamp* batch_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.batch_time_);
  }
  if (batch_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(batch_time));
    if (message_arena != submessage_arena) {
      batch_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, batch_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.batch_time_ = batch_time;
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.EventBatch.batch_time)
}

// string checkpoint_token = 4;
inline void EventBatch::clear_checkpoint_token() {
  _impl_.checkpoint_token_.ClearToEmpty();
}
inline const std::string& EventBatch::checkpoint_token() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.EventBatch.checkpoint_token)
  return _internal_checkpoint_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EventBatch::set_checkpoint_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.checkpoint_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.EventBatch.checkpoint_token)
}
inline std::string* EventBatch::mutable_checkpoint_token() {
  std::string* _s = _internal_mutable_checkpoint_token();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.EventBatch.checkpoint_token)
  return _s;
}
inline const std::string& EventBatch::_internal_checkpoint_token() const {
  return _impl_.checkpoint_token_.Get();
}
inline void EventBatch::_internal_set_checkpoint_token(const std::string& value) {
  
  _impl_.checkpoint_token_.Set(value, GetArenaForAllocation());
}
inline std::string* EventBatch::_internal_mutable_checkpoint_token() {
  
  return _impl_.checkpoint_token_.Mutable(GetArenaForAllocation());
}
inline std::string* EventBatch::release_checkpoint_token() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.EventBatch.checkpoint_token)
  return _impl_.checkpoint_token_.Release();
}
inline void EventBatch::set_allocated_checkpoint_token(std::string* checkpoint_token) {
  if (checkpoint_token != nullptr) {
    
  } else {
    
  }
  _impl_.checkpoint_token_.SetAllocated(checkpoint_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.checkpoint_token_.IsDefault()) {
    _impl_.checkpoint_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.EventBatch.checkpoint_token)
}

// -------------------------------------------------------------------

// SubscriptionStatus

// string status = 1;
inline void SubscriptionStatus::clear_status() {
  _impl_.status_.ClearToEmpty();
}
inline const std::string& SubscriptionStatus::status() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.SubscriptionStatus.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubscriptionStatus::set_status(ArgT0&& arg0, ArgT... args) {
 
 _impl_.status_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.SubscriptionStatus.status)
}
inline std::string* SubscriptionStatus::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.SubscriptionStatus.status)
  return _s;
}
inline const std::string& SubscriptionStatus::_internal_status() const {
  return _impl_.status_.Get();
}
inline void SubscriptionStatus::_internal_set_status(const std::string& value) {
  
  _impl_.status_.Set(value, GetArenaForAllocation());
}
inline std::string* SubscriptionStatus::_internal_mutable_status() {
  
  return _impl_.status_.Mutable(GetArenaForAllocation());
}
inline std::string* SubscriptionStatus::release_status() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.SubscriptionStatus.status)
  return _impl_.status_.Release();
}
inline void SubscriptionStatus::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  _impl_.status_.SetAllocated(status, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.SubscriptionStatus.status)
}

// int64 last_processed_sequence = 2;
inline void SubscriptionStatus::clear_last_processed_sequence() {
  _impl_.last_processed_sequence_ = int64_t{0};
}
inline int64_t SubscriptionStatus::_internal_last_processed_sequence() const {
  return _impl_.last_processed_sequence_;
}
inline int64_t SubscriptionStatus::last_processed_sequence() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.SubscriptionStatus.last_processed_sequence)
  return _internal_last_processed_sequence();
}
inline void SubscriptionStatus::_internal_set_last_processed_sequence(int64_t value) {
  
  _impl_.last_processed_sequence_ = value;
}
inline void SubscriptionStatus::set_last_processed_sequence(int64_t value) {
  _internal_set_last_processed_sequence(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.SubscriptionStatus.last_processed_sequence)
}

// int32 events_processed = 3;
inline void SubscriptionStatus::clear_events_processed() {
  _impl_.events_processed_ = 0;
}
inline int32_t SubscriptionStatus::_internal_events_processed() const {
  return _impl_.events_processed_;
}
inline int32_t SubscriptionStatus::events_processed() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.SubscriptionStatus.events_processed)
  return _internal_events_processed();
}
inline void SubscriptionStatus::_internal_set_events_processed(int32_t value) {
  
  _impl_.events_processed_ = value;
}
inline void SubscriptionStatus::set_events_processed(int32_t value) {
  _internal_set_events_processed(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.SubscriptionStatus.events_processed)
}

// int32 events_failed = 4;
inline void SubscriptionStatus::clear_events_failed() {
  _impl_.events_failed_ = 0;
}
inline int32_t SubscriptionStatus::_internal_events_failed() const {
  return _impl_.events_failed_;
}
inline int32_t SubscriptionStatus::events_failed() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.SubscriptionStatus.events_failed)
  return _internal_events_failed();
}
inline void SubscriptionStatus::_internal_set_events_failed(int32_t value) {
  
  _impl_.events_failed_ = value;
}
inline void SubscriptionStatus::set_events_failed(int32_t value) {
  _internal_set_events_failed(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.SubscriptionStatus.events_failed)
}

// -------------------------------------------------------------------

// SubscriptionError

// string error_code = 1;
inline void SubscriptionError::clear_error_code() {
  _impl_.error_code_.ClearToEmpty();
}
inline const std::string& SubscriptionError::error_code() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.SubscriptionError.error_code)
  return _internal_error_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubscriptionError::set_error_code(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.SubscriptionError.error_code)
}
inline std::string* SubscriptionError::mutable_error_code() {
  std::string* _s = _internal_mutable_error_code();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.SubscriptionError.error_code)
  return _s;
}
inline const std::string& SubscriptionError::_internal_error_code() const {
  return _impl_.error_code_.Get();
}
inline void SubscriptionError::_internal_set_error_code(const std::string& value) {
  
  _impl_.error_code_.Set(value, GetArenaForAllocation());
}
inline std::string* SubscriptionError::_internal_mutable_error_code() {
  
  return _impl_.error_code_.Mutable(GetArenaForAllocation());
}
inline std::string* SubscriptionError::release_error_code() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.SubscriptionError.error_code)
  return _impl_.error_code_.Release();
}
inline void SubscriptionError::set_allocated_error_code(std::string* error_code) {
  if (error_code != nullptr) {
    
  } else {
    
  }
  _impl_.error_code_.SetAllocated(error_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_code_.IsDefault()) {
    _impl_.error_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.SubscriptionError.error_code)
}

// string error_message = 2;
inline void SubscriptionError::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& SubscriptionError::error_message() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.SubscriptionError.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubscriptionError::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.SubscriptionError.error_message)
}
inline std::string* SubscriptionError::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.SubscriptionError.error_message)
  return _s;
}
inline const std::string& SubscriptionError::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void SubscriptionError::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* SubscriptionError::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* SubscriptionError::release_error_message() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.SubscriptionError.error_message)
  return _impl_.error_message_.Release();
}
inline void SubscriptionError::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.SubscriptionError.error_message)
}

// bool is_recoverable = 3;
inline void SubscriptionError::clear_is_recoverable() {
  _impl_.is_recoverable_ = false;
}
inline bool SubscriptionError::_internal_is_recoverable() const {
  return _impl_.is_recoverable_;
}
inline bool SubscriptionError::is_recoverable() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.SubscriptionError.is_recoverable)
  return _internal_is_recoverable();
}
inline void SubscriptionError::_internal_set_is_recoverable(bool value) {
  
  _impl_.is_recoverable_ = value;
}
inline void SubscriptionError::set_is_recoverable(bool value) {
  _internal_set_is_recoverable(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.SubscriptionError.is_recoverable)
}

// int32 retry_count = 4;
inline void SubscriptionError::clear_retry_count() {
  _impl_.retry_count_ = 0;
}
inline int32_t SubscriptionError::_internal_retry_count() const {
  return _impl_.retry_count_;
}
inline int32_t SubscriptionError::retry_count() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.SubscriptionError.retry_count)
  return _internal_retry_count();
}
inline void SubscriptionError::_internal_set_retry_count(int32_t value) {
  
  _impl_.retry_count_ = value;
}
inline void SubscriptionError::set_retry_count(int32_t value) {
  _internal_set_retry_count(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.SubscriptionError.retry_count)
}

// -------------------------------------------------------------------

// Heartbeat

// .google.protobuf.Timestamp timestamp = 1;
inline bool Heartbeat::_internal_has_timestamp() const {
  return this != internal_default_instance() && _impl_.timestamp_ != nullptr;
}
inline bool Heartbeat::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Heartbeat::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Heartbeat::timestamp() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.Heartbeat.timestamp)
  return _internal_timestamp();
}
inline void Heartbeat::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.Heartbeat.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Heartbeat::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Heartbeat::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.Heartbeat.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Heartbeat::_internal_mutable_timestamp() {
  
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Heartbeat::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.Heartbeat.timestamp)
  return _msg;
}
inline void Heartbeat::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.Heartbeat.timestamp)
}

// int64 current_sequence = 2;
inline void Heartbeat::clear_current_sequence() {
  _impl_.current_sequence_ = int64_t{0};
}
inline int64_t Heartbeat::_internal_current_sequence() const {
  return _impl_.current_sequence_;
}
inline int64_t Heartbeat::current_sequence() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.Heartbeat.current_sequence)
  return _internal_current_sequence();
}
inline void Heartbeat::_internal_set_current_sequence(int64_t value) {
  
  _impl_.current_sequence_ = value;
}
inline void Heartbeat::set_current_sequence(int64_t value) {
  _internal_set_current_sequence(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.Heartbeat.current_sequence)
}

// -------------------------------------------------------------------

// AcknowledgeEventsRequest

// string subscriber_id = 1;
inline void AcknowledgeEventsRequest::clear_subscriber_id() {
  _impl_.subscriber_id_.ClearToEmpty();
}
inline const std::string& AcknowledgeEventsRequest::subscriber_id() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.AcknowledgeEventsRequest.subscriber_id)
  return _internal_subscriber_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AcknowledgeEventsRequest::set_subscriber_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.subscriber_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.AcknowledgeEventsRequest.subscriber_id)
}
inline std::string* AcknowledgeEventsRequest::mutable_subscriber_id() {
  std::string* _s = _internal_mutable_subscriber_id();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.AcknowledgeEventsRequest.subscriber_id)
  return _s;
}
inline const std::string& AcknowledgeEventsRequest::_internal_subscriber_id() const {
  return _impl_.subscriber_id_.Get();
}
inline void AcknowledgeEventsRequest::_internal_set_subscriber_id(const std::string& value) {
  
  _impl_.subscriber_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AcknowledgeEventsRequest::_internal_mutable_subscriber_id() {
  
  return _impl_.subscriber_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AcknowledgeEventsRequest::release_subscriber_id() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.AcknowledgeEventsRequest.subscriber_id)
  return _impl_.subscriber_id_.Release();
}
inline void AcknowledgeEventsRequest::set_allocated_subscriber_id(std::string* subscriber_id) {
  if (subscriber_id != nullptr) {
    
  } else {
    
  }
  _impl_.subscriber_id_.SetAllocated(subscriber_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.subscriber_id_.IsDefault()) {
    _impl_.subscriber_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.AcknowledgeEventsRequest.subscriber_id)
}

// repeated string event_ids = 2;
inline int AcknowledgeEventsRequest::_internal_event_ids_size() const {
  return _impl_.event_ids_.size();
}
inline int AcknowledgeEventsRequest::event_ids_size() const {
  return _internal_event_ids_size();
}
inline void AcknowledgeEventsRequest::clear_event_ids() {
  _impl_.event_ids_.Clear();
}
inline std::string* AcknowledgeEventsRequest::add_event_ids() {
  std::string* _s = _internal_add_event_ids();
  // @@protoc_insertion_point(field_add_mutable:unhinged.cdc.AcknowledgeEventsRequest.event_ids)
  return _s;
}
inline const std::string& AcknowledgeEventsRequest::_internal_event_ids(int index) const {
  return _impl_.event_ids_.Get(index);
}
inline const std::string& AcknowledgeEventsRequest::event_ids(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.AcknowledgeEventsRequest.event_ids)
  return _internal_event_ids(index);
}
inline std::string* AcknowledgeEventsRequest::mutable_event_ids(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.AcknowledgeEventsRequest.event_ids)
  return _impl_.event_ids_.Mutable(index);
}
inline void AcknowledgeEventsRequest::set_event_ids(int index, const std::string& value) {
  _impl_.event_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.AcknowledgeEventsRequest.event_ids)
}
inline void AcknowledgeEventsRequest::set_event_ids(int index, std::string&& value) {
  _impl_.event_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.cdc.AcknowledgeEventsRequest.event_ids)
}
inline void AcknowledgeEventsRequest::set_event_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.event_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.cdc.AcknowledgeEventsRequest.event_ids)
}
inline void AcknowledgeEventsRequest::set_event_ids(int index, const char* value, size_t size) {
  _impl_.event_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.cdc.AcknowledgeEventsRequest.event_ids)
}
inline std::string* AcknowledgeEventsRequest::_internal_add_event_ids() {
  return _impl_.event_ids_.Add();
}
inline void AcknowledgeEventsRequest::add_event_ids(const std::string& value) {
  _impl_.event_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.cdc.AcknowledgeEventsRequest.event_ids)
}
inline void AcknowledgeEventsRequest::add_event_ids(std::string&& value) {
  _impl_.event_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.cdc.AcknowledgeEventsRequest.event_ids)
}
inline void AcknowledgeEventsRequest::add_event_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.event_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.cdc.AcknowledgeEventsRequest.event_ids)
}
inline void AcknowledgeEventsRequest::add_event_ids(const char* value, size_t size) {
  _impl_.event_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.cdc.AcknowledgeEventsRequest.event_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AcknowledgeEventsRequest::event_ids() const {
  // @@protoc_insertion_point(field_list:unhinged.cdc.AcknowledgeEventsRequest.event_ids)
  return _impl_.event_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AcknowledgeEventsRequest::mutable_event_ids() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.cdc.AcknowledgeEventsRequest.event_ids)
  return &_impl_.event_ids_;
}

// string checkpoint_token = 3;
inline void AcknowledgeEventsRequest::clear_checkpoint_token() {
  _impl_.checkpoint_token_.ClearToEmpty();
}
inline const std::string& AcknowledgeEventsRequest::checkpoint_token() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.AcknowledgeEventsRequest.checkpoint_token)
  return _internal_checkpoint_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AcknowledgeEventsRequest::set_checkpoint_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.checkpoint_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.AcknowledgeEventsRequest.checkpoint_token)
}
inline std::string* AcknowledgeEventsRequest::mutable_checkpoint_token() {
  std::string* _s = _internal_mutable_checkpoint_token();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.AcknowledgeEventsRequest.checkpoint_token)
  return _s;
}
inline const std::string& AcknowledgeEventsRequest::_internal_checkpoint_token() const {
  return _impl_.checkpoint_token_.Get();
}
inline void AcknowledgeEventsRequest::_internal_set_checkpoint_token(const std::string& value) {
  
  _impl_.checkpoint_token_.Set(value, GetArenaForAllocation());
}
inline std::string* AcknowledgeEventsRequest::_internal_mutable_checkpoint_token() {
  
  return _impl_.checkpoint_token_.Mutable(GetArenaForAllocation());
}
inline std::string* AcknowledgeEventsRequest::release_checkpoint_token() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.AcknowledgeEventsRequest.checkpoint_token)
  return _impl_.checkpoint_token_.Release();
}
inline void AcknowledgeEventsRequest::set_allocated_checkpoint_token(std::string* checkpoint_token) {
  if (checkpoint_token != nullptr) {
    
  } else {
    
  }
  _impl_.checkpoint_token_.SetAllocated(checkpoint_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.checkpoint_token_.IsDefault()) {
    _impl_.checkpoint_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.AcknowledgeEventsRequest.checkpoint_token)
}

// -------------------------------------------------------------------

// AcknowledgeEventsResponse

// bool success = 1;
inline void AcknowledgeEventsResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool AcknowledgeEventsResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool AcknowledgeEventsResponse::success() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.AcknowledgeEventsResponse.success)
  return _internal_success();
}
inline void AcknowledgeEventsResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void AcknowledgeEventsResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.AcknowledgeEventsResponse.success)
}

// string message = 2;
inline void AcknowledgeEventsResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& AcknowledgeEventsResponse::message() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.AcknowledgeEventsResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AcknowledgeEventsResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.AcknowledgeEventsResponse.message)
}
inline std::string* AcknowledgeEventsResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.AcknowledgeEventsResponse.message)
  return _s;
}
inline const std::string& AcknowledgeEventsResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void AcknowledgeEventsResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* AcknowledgeEventsResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* AcknowledgeEventsResponse::release_message() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.AcknowledgeEventsResponse.message)
  return _impl_.message_.Release();
}
inline void AcknowledgeEventsResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.AcknowledgeEventsResponse.message)
}

// int32 acknowledged_count = 3;
inline void AcknowledgeEventsResponse::clear_acknowledged_count() {
  _impl_.acknowledged_count_ = 0;
}
inline int32_t AcknowledgeEventsResponse::_internal_acknowledged_count() const {
  return _impl_.acknowledged_count_;
}
inline int32_t AcknowledgeEventsResponse::acknowledged_count() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.AcknowledgeEventsResponse.acknowledged_count)
  return _internal_acknowledged_count();
}
inline void AcknowledgeEventsResponse::_internal_set_acknowledged_count(int32_t value) {
  
  _impl_.acknowledged_count_ = value;
}
inline void AcknowledgeEventsResponse::set_acknowledged_count(int32_t value) {
  _internal_set_acknowledged_count(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.AcknowledgeEventsResponse.acknowledged_count)
}

// -------------------------------------------------------------------

// ReplayEventsRequest

// string subscriber_id = 1;
inline void ReplayEventsRequest::clear_subscriber_id() {
  _impl_.subscriber_id_.ClearToEmpty();
}
inline const std::string& ReplayEventsRequest::subscriber_id() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.ReplayEventsRequest.subscriber_id)
  return _internal_subscriber_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReplayEventsRequest::set_subscriber_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.subscriber_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.ReplayEventsRequest.subscriber_id)
}
inline std::string* ReplayEventsRequest::mutable_subscriber_id() {
  std::string* _s = _internal_mutable_subscriber_id();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.ReplayEventsRequest.subscriber_id)
  return _s;
}
inline const std::string& ReplayEventsRequest::_internal_subscriber_id() const {
  return _impl_.subscriber_id_.Get();
}
inline void ReplayEventsRequest::_internal_set_subscriber_id(const std::string& value) {
  
  _impl_.subscriber_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ReplayEventsRequest::_internal_mutable_subscriber_id() {
  
  return _impl_.subscriber_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ReplayEventsRequest::release_subscriber_id() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.ReplayEventsRequest.subscriber_id)
  return _impl_.subscriber_id_.Release();
}
inline void ReplayEventsRequest::set_allocated_subscriber_id(std::string* subscriber_id) {
  if (subscriber_id != nullptr) {
    
  } else {
    
  }
  _impl_.subscriber_id_.SetAllocated(subscriber_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.subscriber_id_.IsDefault()) {
    _impl_.subscriber_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.ReplayEventsRequest.subscriber_id)
}

// .unhinged.cdc.TimeRange time_range = 2;
inline bool ReplayEventsRequest::_internal_has_time_range() const {
  return replay_range_case() == kTimeRange;
}
inline bool ReplayEventsRequest::has_time_range() const {
  return _internal_has_time_range();
}
inline void ReplayEventsRequest::set_has_time_range() {
  _impl_._oneof_case_[0] = kTimeRange;
}
inline void ReplayEventsRequest::clear_time_range() {
  if (_internal_has_time_range()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.replay_range_.time_range_;
    }
    clear_has_replay_range();
  }
}
inline ::unhinged::cdc::TimeRange* ReplayEventsRequest::release_time_range() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.ReplayEventsRequest.time_range)
  if (_internal_has_time_range()) {
    clear_has_replay_range();
    ::unhinged::cdc::TimeRange* temp = _impl_.replay_range_.time_range_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.replay_range_.time_range_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::cdc::TimeRange& ReplayEventsRequest::_internal_time_range() const {
  return _internal_has_time_range()
      ? *_impl_.replay_range_.time_range_
      : reinterpret_cast< ::unhinged::cdc::TimeRange&>(::unhinged::cdc::_TimeRange_default_instance_);
}
inline const ::unhinged::cdc::TimeRange& ReplayEventsRequest::time_range() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.ReplayEventsRequest.time_range)
  return _internal_time_range();
}
inline ::unhinged::cdc::TimeRange* ReplayEventsRequest::unsafe_arena_release_time_range() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.cdc.ReplayEventsRequest.time_range)
  if (_internal_has_time_range()) {
    clear_has_replay_range();
    ::unhinged::cdc::TimeRange* temp = _impl_.replay_range_.time_range_;
    _impl_.replay_range_.time_range_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ReplayEventsRequest::unsafe_arena_set_allocated_time_range(::unhinged::cdc::TimeRange* time_range) {
  clear_replay_range();
  if (time_range) {
    set_has_time_range();
    _impl_.replay_range_.time_range_ = time_range;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.ReplayEventsRequest.time_range)
}
inline ::unhinged::cdc::TimeRange* ReplayEventsRequest::_internal_mutable_time_range() {
  if (!_internal_has_time_range()) {
    clear_replay_range();
    set_has_time_range();
    _impl_.replay_range_.time_range_ = CreateMaybeMessage< ::unhinged::cdc::TimeRange >(GetArenaForAllocation());
  }
  return _impl_.replay_range_.time_range_;
}
inline ::unhinged::cdc::TimeRange* ReplayEventsRequest::mutable_time_range() {
  ::unhinged::cdc::TimeRange* _msg = _internal_mutable_time_range();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.ReplayEventsRequest.time_range)
  return _msg;
}

// .unhinged.cdc.SequenceRange sequence_range = 3;
inline bool ReplayEventsRequest::_internal_has_sequence_range() const {
  return replay_range_case() == kSequenceRange;
}
inline bool ReplayEventsRequest::has_sequence_range() const {
  return _internal_has_sequence_range();
}
inline void ReplayEventsRequest::set_has_sequence_range() {
  _impl_._oneof_case_[0] = kSequenceRange;
}
inline void ReplayEventsRequest::clear_sequence_range() {
  if (_internal_has_sequence_range()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.replay_range_.sequence_range_;
    }
    clear_has_replay_range();
  }
}
inline ::unhinged::cdc::SequenceRange* ReplayEventsRequest::release_sequence_range() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.ReplayEventsRequest.sequence_range)
  if (_internal_has_sequence_range()) {
    clear_has_replay_range();
    ::unhinged::cdc::SequenceRange* temp = _impl_.replay_range_.sequence_range_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.replay_range_.sequence_range_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::cdc::SequenceRange& ReplayEventsRequest::_internal_sequence_range() const {
  return _internal_has_sequence_range()
      ? *_impl_.replay_range_.sequence_range_
      : reinterpret_cast< ::unhinged::cdc::SequenceRange&>(::unhinged::cdc::_SequenceRange_default_instance_);
}
inline const ::unhinged::cdc::SequenceRange& ReplayEventsRequest::sequence_range() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.ReplayEventsRequest.sequence_range)
  return _internal_sequence_range();
}
inline ::unhinged::cdc::SequenceRange* ReplayEventsRequest::unsafe_arena_release_sequence_range() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.cdc.ReplayEventsRequest.sequence_range)
  if (_internal_has_sequence_range()) {
    clear_has_replay_range();
    ::unhinged::cdc::SequenceRange* temp = _impl_.replay_range_.sequence_range_;
    _impl_.replay_range_.sequence_range_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ReplayEventsRequest::unsafe_arena_set_allocated_sequence_range(::unhinged::cdc::SequenceRange* sequence_range) {
  clear_replay_range();
  if (sequence_range) {
    set_has_sequence_range();
    _impl_.replay_range_.sequence_range_ = sequence_range;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.ReplayEventsRequest.sequence_range)
}
inline ::unhinged::cdc::SequenceRange* ReplayEventsRequest::_internal_mutable_sequence_range() {
  if (!_internal_has_sequence_range()) {
    clear_replay_range();
    set_has_sequence_range();
    _impl_.replay_range_.sequence_range_ = CreateMaybeMessage< ::unhinged::cdc::SequenceRange >(GetArenaForAllocation());
  }
  return _impl_.replay_range_.sequence_range_;
}
inline ::unhinged::cdc::SequenceRange* ReplayEventsRequest::mutable_sequence_range() {
  ::unhinged::cdc::SequenceRange* _msg = _internal_mutable_sequence_range();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.ReplayEventsRequest.sequence_range)
  return _msg;
}

// string checkpoint_token = 4;
inline bool ReplayEventsRequest::_internal_has_checkpoint_token() const {
  return replay_range_case() == kCheckpointToken;
}
inline bool ReplayEventsRequest::has_checkpoint_token() const {
  return _internal_has_checkpoint_token();
}
inline void ReplayEventsRequest::set_has_checkpoint_token() {
  _impl_._oneof_case_[0] = kCheckpointToken;
}
inline void ReplayEventsRequest::clear_checkpoint_token() {
  if (_internal_has_checkpoint_token()) {
    _impl_.replay_range_.checkpoint_token_.Destroy();
    clear_has_replay_range();
  }
}
inline const std::string& ReplayEventsRequest::checkpoint_token() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.ReplayEventsRequest.checkpoint_token)
  return _internal_checkpoint_token();
}
template <typename ArgT0, typename... ArgT>
inline void ReplayEventsRequest::set_checkpoint_token(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_checkpoint_token()) {
    clear_replay_range();
    set_has_checkpoint_token();
    _impl_.replay_range_.checkpoint_token_.InitDefault();
  }
  _impl_.replay_range_.checkpoint_token_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.ReplayEventsRequest.checkpoint_token)
}
inline std::string* ReplayEventsRequest::mutable_checkpoint_token() {
  std::string* _s = _internal_mutable_checkpoint_token();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.ReplayEventsRequest.checkpoint_token)
  return _s;
}
inline const std::string& ReplayEventsRequest::_internal_checkpoint_token() const {
  if (_internal_has_checkpoint_token()) {
    return _impl_.replay_range_.checkpoint_token_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void ReplayEventsRequest::_internal_set_checkpoint_token(const std::string& value) {
  if (!_internal_has_checkpoint_token()) {
    clear_replay_range();
    set_has_checkpoint_token();
    _impl_.replay_range_.checkpoint_token_.InitDefault();
  }
  _impl_.replay_range_.checkpoint_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ReplayEventsRequest::_internal_mutable_checkpoint_token() {
  if (!_internal_has_checkpoint_token()) {
    clear_replay_range();
    set_has_checkpoint_token();
    _impl_.replay_range_.checkpoint_token_.InitDefault();
  }
  return _impl_.replay_range_.checkpoint_token_.Mutable(      GetArenaForAllocation());
}
inline std::string* ReplayEventsRequest::release_checkpoint_token() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.ReplayEventsRequest.checkpoint_token)
  if (_internal_has_checkpoint_token()) {
    clear_has_replay_range();
    return _impl_.replay_range_.checkpoint_token_.Release();
  } else {
    return nullptr;
  }
}
inline void ReplayEventsRequest::set_allocated_checkpoint_token(std::string* checkpoint_token) {
  if (has_replay_range()) {
    clear_replay_range();
  }
  if (checkpoint_token != nullptr) {
    set_has_checkpoint_token();
    _impl_.replay_range_.checkpoint_token_.InitAllocated(checkpoint_token, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.ReplayEventsRequest.checkpoint_token)
}

// .unhinged.cdc.EventFilter filter = 5;
inline bool ReplayEventsRequest::_internal_has_filter() const {
  return this != internal_default_instance() && _impl_.filter_ != nullptr;
}
inline bool ReplayEventsRequest::has_filter() const {
  return _internal_has_filter();
}
inline void ReplayEventsRequest::clear_filter() {
  if (GetArenaForAllocation() == nullptr && _impl_.filter_ != nullptr) {
    delete _impl_.filter_;
  }
  _impl_.filter_ = nullptr;
}
inline const ::unhinged::cdc::EventFilter& ReplayEventsRequest::_internal_filter() const {
  const ::unhinged::cdc::EventFilter* p = _impl_.filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::cdc::EventFilter&>(
      ::unhinged::cdc::_EventFilter_default_instance_);
}
inline const ::unhinged::cdc::EventFilter& ReplayEventsRequest::filter() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.ReplayEventsRequest.filter)
  return _internal_filter();
}
inline void ReplayEventsRequest::unsafe_arena_set_allocated_filter(
    ::unhinged::cdc::EventFilter* filter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.filter_);
  }
  _impl_.filter_ = filter;
  if (filter) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.ReplayEventsRequest.filter)
}
inline ::unhinged::cdc::EventFilter* ReplayEventsRequest::release_filter() {
  
  ::unhinged::cdc::EventFilter* temp = _impl_.filter_;
  _impl_.filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::cdc::EventFilter* ReplayEventsRequest::unsafe_arena_release_filter() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.ReplayEventsRequest.filter)
  
  ::unhinged::cdc::EventFilter* temp = _impl_.filter_;
  _impl_.filter_ = nullptr;
  return temp;
}
inline ::unhinged::cdc::EventFilter* ReplayEventsRequest::_internal_mutable_filter() {
  
  if (_impl_.filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::cdc::EventFilter>(GetArenaForAllocation());
    _impl_.filter_ = p;
  }
  return _impl_.filter_;
}
inline ::unhinged::cdc::EventFilter* ReplayEventsRequest::mutable_filter() {
  ::unhinged::cdc::EventFilter* _msg = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.ReplayEventsRequest.filter)
  return _msg;
}
inline void ReplayEventsRequest::set_allocated_filter(::unhinged::cdc::EventFilter* filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.filter_;
  }
  if (filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(filter);
    if (message_arena != submessage_arena) {
      filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, filter, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.filter_ = filter;
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.ReplayEventsRequest.filter)
}

// int32 batch_size = 6;
inline void ReplayEventsRequest::clear_batch_size() {
  _impl_.batch_size_ = 0;
}
inline int32_t ReplayEventsRequest::_internal_batch_size() const {
  return _impl_.batch_size_;
}
inline int32_t ReplayEventsRequest::batch_size() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.ReplayEventsRequest.batch_size)
  return _internal_batch_size();
}
inline void ReplayEventsRequest::_internal_set_batch_size(int32_t value) {
  
  _impl_.batch_size_ = value;
}
inline void ReplayEventsRequest::set_batch_size(int32_t value) {
  _internal_set_batch_size(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.ReplayEventsRequest.batch_size)
}

// bool include_failed_events = 7;
inline void ReplayEventsRequest::clear_include_failed_events() {
  _impl_.include_failed_events_ = false;
}
inline bool ReplayEventsRequest::_internal_include_failed_events() const {
  return _impl_.include_failed_events_;
}
inline bool ReplayEventsRequest::include_failed_events() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.ReplayEventsRequest.include_failed_events)
  return _internal_include_failed_events();
}
inline void ReplayEventsRequest::_internal_set_include_failed_events(bool value) {
  
  _impl_.include_failed_events_ = value;
}
inline void ReplayEventsRequest::set_include_failed_events(bool value) {
  _internal_set_include_failed_events(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.ReplayEventsRequest.include_failed_events)
}

inline bool ReplayEventsRequest::has_replay_range() const {
  return replay_range_case() != REPLAY_RANGE_NOT_SET;
}
inline void ReplayEventsRequest::clear_has_replay_range() {
  _impl_._oneof_case_[0] = REPLAY_RANGE_NOT_SET;
}
inline ReplayEventsRequest::ReplayRangeCase ReplayEventsRequest::replay_range_case() const {
  return ReplayEventsRequest::ReplayRangeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// TimeRange

// .google.protobuf.Timestamp start_time = 1;
inline bool TimeRange::_internal_has_start_time() const {
  return this != internal_default_instance() && _impl_.start_time_ != nullptr;
}
inline bool TimeRange::has_start_time() const {
  return _internal_has_start_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& TimeRange::_internal_start_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.start_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& TimeRange::start_time() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.TimeRange.start_time)
  return _internal_start_time();
}
inline void TimeRange::unsafe_arena_set_allocated_start_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_time_);
  }
  _impl_.start_time_ = start_time;
  if (start_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.TimeRange.start_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TimeRange::release_start_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.start_time_;
  _impl_.start_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TimeRange::unsafe_arena_release_start_time() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.TimeRange.start_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.start_time_;
  _impl_.start_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TimeRange::_internal_mutable_start_time() {
  
  if (_impl_.start_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.start_time_ = p;
  }
  return _impl_.start_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TimeRange::mutable_start_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_start_time();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.TimeRange.start_time)
  return _msg;
}
inline void TimeRange::set_allocated_start_time(::PROTOBUF_NAMESPACE_ID::Timestamp* start_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_time_);
  }
  if (start_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_time));
    if (message_arena != submessage_arena) {
      start_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.start_time_ = start_time;
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.TimeRange.start_time)
}

// .google.protobuf.Timestamp end_time = 2;
inline bool TimeRange::_internal_has_end_time() const {
  return this != internal_default_instance() && _impl_.end_time_ != nullptr;
}
inline bool TimeRange::has_end_time() const {
  return _internal_has_end_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& TimeRange::_internal_end_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.end_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& TimeRange::end_time() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.TimeRange.end_time)
  return _internal_end_time();
}
inline void TimeRange::unsafe_arena_set_allocated_end_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_time_);
  }
  _impl_.end_time_ = end_time;
  if (end_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.TimeRange.end_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TimeRange::release_end_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.end_time_;
  _impl_.end_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TimeRange::unsafe_arena_release_end_time() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.TimeRange.end_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.end_time_;
  _impl_.end_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TimeRange::_internal_mutable_end_time() {
  
  if (_impl_.end_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.end_time_ = p;
  }
  return _impl_.end_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TimeRange::mutable_end_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_end_time();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.TimeRange.end_time)
  return _msg;
}
inline void TimeRange::set_allocated_end_time(::PROTOBUF_NAMESPACE_ID::Timestamp* end_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_time_);
  }
  if (end_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_time));
    if (message_arena != submessage_arena) {
      end_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.end_time_ = end_time;
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.TimeRange.end_time)
}

// -------------------------------------------------------------------

// SequenceRange

// int64 start_sequence = 1;
inline void SequenceRange::clear_start_sequence() {
  _impl_.start_sequence_ = int64_t{0};
}
inline int64_t SequenceRange::_internal_start_sequence() const {
  return _impl_.start_sequence_;
}
inline int64_t SequenceRange::start_sequence() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.SequenceRange.start_sequence)
  return _internal_start_sequence();
}
inline void SequenceRange::_internal_set_start_sequence(int64_t value) {
  
  _impl_.start_sequence_ = value;
}
inline void SequenceRange::set_start_sequence(int64_t value) {
  _internal_set_start_sequence(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.SequenceRange.start_sequence)
}

// int64 end_sequence = 2;
inline void SequenceRange::clear_end_sequence() {
  _impl_.end_sequence_ = int64_t{0};
}
inline int64_t SequenceRange::_internal_end_sequence() const {
  return _impl_.end_sequence_;
}
inline int64_t SequenceRange::end_sequence() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.SequenceRange.end_sequence)
  return _internal_end_sequence();
}
inline void SequenceRange::_internal_set_end_sequence(int64_t value) {
  
  _impl_.end_sequence_ = value;
}
inline void SequenceRange::set_end_sequence(int64_t value) {
  _internal_set_end_sequence(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.SequenceRange.end_sequence)
}

// -------------------------------------------------------------------

// ListDeadLetterEventsRequest

// string subscriber_id = 1;
inline void ListDeadLetterEventsRequest::clear_subscriber_id() {
  _impl_.subscriber_id_.ClearToEmpty();
}
inline const std::string& ListDeadLetterEventsRequest::subscriber_id() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.ListDeadLetterEventsRequest.subscriber_id)
  return _internal_subscriber_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListDeadLetterEventsRequest::set_subscriber_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.subscriber_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.ListDeadLetterEventsRequest.subscriber_id)
}
inline std::string* ListDeadLetterEventsRequest::mutable_subscriber_id() {
  std::string* _s = _internal_mutable_subscriber_id();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.ListDeadLetterEventsRequest.subscriber_id)
  return _s;
}
inline const std::string& ListDeadLetterEventsRequest::_internal_subscriber_id() const {
  return _impl_.subscriber_id_.Get();
}
inline void ListDeadLetterEventsRequest::_internal_set_subscriber_id(const std::string& value) {
  
  _impl_.subscriber_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ListDeadLetterEventsRequest::_internal_mutable_subscriber_id() {
  
  return _impl_.subscriber_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ListDeadLetterEventsRequest::release_subscriber_id() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.ListDeadLetterEventsRequest.subscriber_id)
  return _impl_.subscriber_id_.Release();
}
inline void ListDeadLetterEventsRequest::set_allocated_subscriber_id(std::string* subscriber_id) {
  if (subscriber_id != nullptr) {
    
  } else {
    
  }
  _impl_.subscriber_id_.SetAllocated(subscriber_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.subscriber_id_.IsDefault()) {
    _impl_.subscriber_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.ListDeadLetterEventsRequest.subscriber_id)
}

// .google.protobuf.Timestamp since = 2;
inline bool ListDeadLetterEventsRequest::_internal_has_since() const {
  return this != internal_default_instance() && _impl_.since_ != nullptr;
}
inline bool ListDeadLetterEventsRequest::has_since() const {
  return _internal_has_since();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ListDeadLetterEventsRequest::_internal_since() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.since_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ListDeadLetterEventsRequest::since() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.ListDeadLetterEventsRequest.since)
  return _internal_since();
}
inline void ListDeadLetterEventsRequest::unsafe_arena_set_allocated_since(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* since) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.since_);
  }
  _impl_.since_ = since;
  if (since) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.ListDeadLetterEventsRequest.since)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ListDeadLetterEventsRequest::release_since() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.since_;
  _impl_.since_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ListDeadLetterEventsRequest::unsafe_arena_release_since() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.ListDeadLetterEventsRequest.since)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.since_;
  _impl_.since_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ListDeadLetterEventsRequest::_internal_mutable_since() {
  
  if (_impl_.since_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.since_ = p;
  }
  return _impl_.since_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ListDeadLetterEventsRequest::mutable_since() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_since();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.ListDeadLetterEventsRequest.since)
  return _msg;
}
inline void ListDeadLetterEventsRequest::set_allocated_since(::PROTOBUF_NAMESPACE_ID::Timestamp* since) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.since_);
  }
  if (since) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(since));
    if (message_arena != submessage_arena) {
      since = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, since, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.since_ = since;
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.ListDeadLetterEventsRequest.since)
}

// int32 page_size = 3;
inline void ListDeadLetterEventsRequest::clear_page_size() {
  _impl_.page_size_ = 0;
}
inline int32_t ListDeadLetterEventsRequest::_internal_page_size() const {
  return _impl_.page_size_;
}
inline int32_t ListDeadLetterEventsRequest::page_size() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.ListDeadLetterEventsRequest.page_size)
  return _internal_page_size();
}
inline void ListDeadLetterEventsRequest::_internal_set_page_size(int32_t value) {
  
  _impl_.page_size_ = value;
}
inline void ListDeadLetterEventsRequest::set_page_size(int32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.ListDeadLetterEventsRequest.page_size)
}

// string page_token = 4;
inline void ListDeadLetterEventsRequest::clear_page_token() {
  _impl_.page_token_.ClearToEmpty();
}
inline const std::string& ListDeadLetterEventsRequest::page_token() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.ListDeadLetterEventsRequest.page_token)
  return _internal_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListDeadLetterEventsRequest::set_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.ListDeadLetterEventsRequest.page_token)
}
inline std::string* ListDeadLetterEventsRequest::mutable_page_token() {
  std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.ListDeadLetterEventsRequest.page_token)
  return _s;
}
inline const std::string& ListDeadLetterEventsRequest::_internal_page_token() const {
  return _impl_.page_token_.Get();
}
inline void ListDeadLetterEventsRequest::_internal_set_page_token(const std::string& value) {
  
  _impl_.page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListDeadLetterEventsRequest::_internal_mutable_page_token() {
  
  return _impl_.page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListDeadLetterEventsRequest::release_page_token() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.ListDeadLetterEventsRequest.page_token)
  return _impl_.page_token_.Release();
}
inline void ListDeadLetterEventsRequest::set_allocated_page_token(std::string* page_token) {
  if (page_token != nullptr) {
    
  } else {
    
  }
  _impl_.page_token_.SetAllocated(page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.page_token_.IsDefault()) {
    _impl_.page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.ListDeadLetterEventsRequest.page_token)
}

// -------------------------------------------------------------------

// ListDeadLetterEventsResponse

// repeated .unhinged.cdc.DeadLetterEvent events = 1;
inline int ListDeadLetterEventsResponse::_internal_events_size() const {
  return _impl_.events_.size();
}
inline int ListDeadLetterEventsResponse::events_size() const {
  return _internal_events_size();
}
inline void ListDeadLetterEventsResponse::clear_events() {
  _impl_.events_.Clear();
}
inline ::unhinged::cdc::DeadLetterEvent* ListDeadLetterEventsResponse::mutable_events(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.ListDeadLetterEventsResponse.events)
  return _impl_.events_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::cdc::DeadLetterEvent >*
ListDeadLetterEventsResponse::mutable_events() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.cdc.ListDeadLetterEventsResponse.events)
  return &_impl_.events_;
}
inline const ::unhinged::cdc::DeadLetterEvent& ListDeadLetterEventsResponse::_internal_events(int index) const {
  return _impl_.events_.Get(index);
}
inline const ::unhinged::cdc::DeadLetterEvent& ListDeadLetterEventsResponse::events(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.ListDeadLetterEventsResponse.events)
  return _internal_events(index);
}
inline ::unhinged::cdc::DeadLetterEvent* ListDeadLetterEventsResponse::_internal_add_events() {
  return _impl_.events_.Add();
}
inline ::unhinged::cdc::DeadLetterEvent* ListDeadLetterEventsResponse::add_events() {
  ::unhinged::cdc::DeadLetterEvent* _add = _internal_add_events();
  // @@protoc_insertion_point(field_add:unhinged.cdc.ListDeadLetterEventsResponse.events)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::cdc::DeadLetterEvent >&
ListDeadLetterEventsResponse::events() const {
  // @@protoc_insertion_point(field_list:unhinged.cdc.ListDeadLetterEventsResponse.events)
  return _impl_.events_;
}

// string next_page_token = 2;
inline void ListDeadLetterEventsResponse::clear_next_page_token() {
  _impl_.next_page_token_.ClearToEmpty();
}
inline const std::string& ListDeadLetterEventsResponse::next_page_token() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.ListDeadLetterEventsResponse.next_page_token)
  return _internal_next_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListDeadLetterEventsResponse::set_next_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.next_page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.ListDeadLetterEventsResponse.next_page_token)
}
inline std::string* ListDeadLetterEventsResponse::mutable_next_page_token() {
  std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.ListDeadLetterEventsResponse.next_page_token)
  return _s;
}
inline const std::string& ListDeadLetterEventsResponse::_internal_next_page_token() const {
  return _impl_.next_page_token_.Get();
}
inline void ListDeadLetterEventsResponse::_internal_set_next_page_token(const std::string& value) {
  
  _impl_.next_page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListDeadLetterEventsResponse::_internal_mutable_next_page_token() {
  
  return _impl_.next_page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListDeadLetterEventsResponse::release_next_page_token() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.ListDeadLetterEventsResponse.next_page_token)
  return _impl_.next_page_token_.Release();
}
inline void ListDeadLetterEventsResponse::set_allocated_next_page_token(std::string* next_page_token) {
  if (next_page_token != nullptr) {
    
  } else {
    
  }
  _impl_.next_page_token_.SetAllocated(next_page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.next_page_token_.IsDefault()) {
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.ListDeadLetterEventsResponse.next_page_token)
}

// int32 total_count = 3;
inline void ListDeadLetterEventsResponse::clear_total_count() {
  _impl_.total_count_ = 0;
}
inline int32_t ListDeadLetterEventsResponse::_internal_total_count() const {
  return _impl_.total_count_;
}
inline int32_t ListDeadLetterEventsResponse::total_count() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.ListDeadLetterEventsResponse.total_count)
  return _internal_total_count();
}
inline void ListDeadLetterEventsResponse::_internal_set_total_count(int32_t value) {
  
  _impl_.total_count_ = value;
}
inline void ListDeadLetterEventsResponse::set_total_count(int32_t value) {
  _internal_set_total_count(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.ListDeadLetterEventsResponse.total_count)
}

// -------------------------------------------------------------------

// DeadLetterEvent

// .unhinged.cdc.UniversalEvent original_event = 1;
inline bool DeadLetterEvent::_internal_has_original_event() const {
  return this != internal_default_instance() && _impl_.original_event_ != nullptr;
}
inline bool DeadLetterEvent::has_original_event() const {
  return _internal_has_original_event();
}
inline const ::unhinged::cdc::UniversalEvent& DeadLetterEvent::_internal_original_event() const {
  const ::unhinged::cdc::UniversalEvent* p = _impl_.original_event_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::cdc::UniversalEvent&>(
      ::unhinged::cdc::_UniversalEvent_default_instance_);
}
inline const ::unhinged::cdc::UniversalEvent& DeadLetterEvent::original_event() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.DeadLetterEvent.original_event)
  return _internal_original_event();
}
inline void DeadLetterEvent::unsafe_arena_set_allocated_original_event(
    ::unhinged::cdc::UniversalEvent* original_event) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.original_event_);
  }
  _impl_.original_event_ = original_event;
  if (original_event) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.DeadLetterEvent.original_event)
}
inline ::unhinged::cdc::UniversalEvent* DeadLetterEvent::release_original_event() {
  
  ::unhinged::cdc::UniversalEvent* temp = _impl_.original_event_;
  _impl_.original_event_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::cdc::UniversalEvent* DeadLetterEvent::unsafe_arena_release_original_event() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.DeadLetterEvent.original_event)
  
  ::unhinged::cdc::UniversalEvent* temp = _impl_.original_event_;
  _impl_.original_event_ = nullptr;
  return temp;
}
inline ::unhinged::cdc::UniversalEvent* DeadLetterEvent::_internal_mutable_original_event() {
  
  if (_impl_.original_event_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::cdc::UniversalEvent>(GetArenaForAllocation());
    _impl_.original_event_ = p;
  }
  return _impl_.original_event_;
}
inline ::unhinged::cdc::UniversalEvent* DeadLetterEvent::mutable_original_event() {
  ::unhinged::cdc::UniversalEvent* _msg = _internal_mutable_original_event();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.DeadLetterEvent.original_event)
  return _msg;
}
inline void DeadLetterEvent::set_allocated_original_event(::unhinged::cdc::UniversalEvent* original_event) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.original_event_);
  }
  if (original_event) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(original_event));
    if (message_arena != submessage_arena) {
      original_event = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, original_event, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.original_event_ = original_event;
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.DeadLetterEvent.original_event)
}

// string failure_reason = 2;
inline void DeadLetterEvent::clear_failure_reason() {
  _impl_.failure_reason_.ClearToEmpty();
}
inline const std::string& DeadLetterEvent::failure_reason() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.DeadLetterEvent.failure_reason)
  return _internal_failure_reason();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeadLetterEvent::set_failure_reason(ArgT0&& arg0, ArgT... args) {
 
 _impl_.failure_reason_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.DeadLetterEvent.failure_reason)
}
inline std::string* DeadLetterEvent::mutable_failure_reason() {
  std::string* _s = _internal_mutable_failure_reason();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.DeadLetterEvent.failure_reason)
  return _s;
}
inline const std::string& DeadLetterEvent::_internal_failure_reason() const {
  return _impl_.failure_reason_.Get();
}
inline void DeadLetterEvent::_internal_set_failure_reason(const std::string& value) {
  
  _impl_.failure_reason_.Set(value, GetArenaForAllocation());
}
inline std::string* DeadLetterEvent::_internal_mutable_failure_reason() {
  
  return _impl_.failure_reason_.Mutable(GetArenaForAllocation());
}
inline std::string* DeadLetterEvent::release_failure_reason() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.DeadLetterEvent.failure_reason)
  return _impl_.failure_reason_.Release();
}
inline void DeadLetterEvent::set_allocated_failure_reason(std::string* failure_reason) {
  if (failure_reason != nullptr) {
    
  } else {
    
  }
  _impl_.failure_reason_.SetAllocated(failure_reason, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.failure_reason_.IsDefault()) {
    _impl_.failure_reason_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.DeadLetterEvent.failure_reason)
}

// int32 retry_count = 3;
inline void DeadLetterEvent::clear_retry_count() {
  _impl_.retry_count_ = 0;
}
inline int32_t DeadLetterEvent::_internal_retry_count() const {
  return _impl_.retry_count_;
}
inline int32_t DeadLetterEvent::retry_count() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.DeadLetterEvent.retry_count)
  return _internal_retry_count();
}
inline void DeadLetterEvent::_internal_set_retry_count(int32_t value) {
  
  _impl_.retry_count_ = value;
}
inline void DeadLetterEvent::set_retry_count(int32_t value) {
  _internal_set_retry_count(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.DeadLetterEvent.retry_count)
}

// .google.protobuf.Timestamp failed_at = 4;
inline bool DeadLetterEvent::_internal_has_failed_at() const {
  return this != internal_default_instance() && _impl_.failed_at_ != nullptr;
}
inline bool DeadLetterEvent::has_failed_at() const {
  return _internal_has_failed_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& DeadLetterEvent::_internal_failed_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.failed_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& DeadLetterEvent::failed_at() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.DeadLetterEvent.failed_at)
  return _internal_failed_at();
}
inline void DeadLetterEvent::unsafe_arena_set_allocated_failed_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* failed_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.failed_at_);
  }
  _impl_.failed_at_ = failed_at;
  if (failed_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.DeadLetterEvent.failed_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DeadLetterEvent::release_failed_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.failed_at_;
  _impl_.failed_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DeadLetterEvent::unsafe_arena_release_failed_at() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.DeadLetterEvent.failed_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.failed_at_;
  _impl_.failed_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DeadLetterEvent::_internal_mutable_failed_at() {
  
  if (_impl_.failed_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.failed_at_ = p;
  }
  return _impl_.failed_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DeadLetterEvent::mutable_failed_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_failed_at();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.DeadLetterEvent.failed_at)
  return _msg;
}
inline void DeadLetterEvent::set_allocated_failed_at(::PROTOBUF_NAMESPACE_ID::Timestamp* failed_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.failed_at_);
  }
  if (failed_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(failed_at));
    if (message_arena != submessage_arena) {
      failed_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, failed_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.failed_at_ = failed_at;
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.DeadLetterEvent.failed_at)
}

// .google.protobuf.Timestamp last_retry_at = 5;
inline bool DeadLetterEvent::_internal_has_last_retry_at() const {
  return this != internal_default_instance() && _impl_.last_retry_at_ != nullptr;
}
inline bool DeadLetterEvent::has_last_retry_at() const {
  return _internal_has_last_retry_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& DeadLetterEvent::_internal_last_retry_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.last_retry_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& DeadLetterEvent::last_retry_at() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.DeadLetterEvent.last_retry_at)
  return _internal_last_retry_at();
}
inline void DeadLetterEvent::unsafe_arena_set_allocated_last_retry_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_retry_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_retry_at_);
  }
  _impl_.last_retry_at_ = last_retry_at;
  if (last_retry_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.DeadLetterEvent.last_retry_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DeadLetterEvent::release_last_retry_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.last_retry_at_;
  _impl_.last_retry_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DeadLetterEvent::unsafe_arena_release_last_retry_at() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.DeadLetterEvent.last_retry_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.last_retry_at_;
  _impl_.last_retry_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DeadLetterEvent::_internal_mutable_last_retry_at() {
  
  if (_impl_.last_retry_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.last_retry_at_ = p;
  }
  return _impl_.last_retry_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DeadLetterEvent::mutable_last_retry_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_last_retry_at();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.DeadLetterEvent.last_retry_at)
  return _msg;
}
inline void DeadLetterEvent::set_allocated_last_retry_at(::PROTOBUF_NAMESPACE_ID::Timestamp* last_retry_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_retry_at_);
  }
  if (last_retry_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_retry_at));
    if (message_arena != submessage_arena) {
      last_retry_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_retry_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.last_retry_at_ = last_retry_at;
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.DeadLetterEvent.last_retry_at)
}

// -------------------------------------------------------------------

// ReprocessDeadLetterEventsRequest

// string subscriber_id = 1;
inline void ReprocessDeadLetterEventsRequest::clear_subscriber_id() {
  _impl_.subscriber_id_.ClearToEmpty();
}
inline const std::string& ReprocessDeadLetterEventsRequest::subscriber_id() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.ReprocessDeadLetterEventsRequest.subscriber_id)
  return _internal_subscriber_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReprocessDeadLetterEventsRequest::set_subscriber_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.subscriber_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.ReprocessDeadLetterEventsRequest.subscriber_id)
}
inline std::string* ReprocessDeadLetterEventsRequest::mutable_subscriber_id() {
  std::string* _s = _internal_mutable_subscriber_id();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.ReprocessDeadLetterEventsRequest.subscriber_id)
  return _s;
}
inline const std::string& ReprocessDeadLetterEventsRequest::_internal_subscriber_id() const {
  return _impl_.subscriber_id_.Get();
}
inline void ReprocessDeadLetterEventsRequest::_internal_set_subscriber_id(const std::string& value) {
  
  _impl_.subscriber_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ReprocessDeadLetterEventsRequest::_internal_mutable_subscriber_id() {
  
  return _impl_.subscriber_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ReprocessDeadLetterEventsRequest::release_subscriber_id() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.ReprocessDeadLetterEventsRequest.subscriber_id)
  return _impl_.subscriber_id_.Release();
}
inline void ReprocessDeadLetterEventsRequest::set_allocated_subscriber_id(std::string* subscriber_id) {
  if (subscriber_id != nullptr) {
    
  } else {
    
  }
  _impl_.subscriber_id_.SetAllocated(subscriber_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.subscriber_id_.IsDefault()) {
    _impl_.subscriber_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.ReprocessDeadLetterEventsRequest.subscriber_id)
}

// repeated string event_ids = 2;
inline int ReprocessDeadLetterEventsRequest::_internal_event_ids_size() const {
  return _impl_.event_ids_.size();
}
inline int ReprocessDeadLetterEventsRequest::event_ids_size() const {
  return _internal_event_ids_size();
}
inline void ReprocessDeadLetterEventsRequest::clear_event_ids() {
  _impl_.event_ids_.Clear();
}
inline std::string* ReprocessDeadLetterEventsRequest::add_event_ids() {
  std::string* _s = _internal_add_event_ids();
  // @@protoc_insertion_point(field_add_mutable:unhinged.cdc.ReprocessDeadLetterEventsRequest.event_ids)
  return _s;
}
inline const std::string& ReprocessDeadLetterEventsRequest::_internal_event_ids(int index) const {
  return _impl_.event_ids_.Get(index);
}
inline const std::string& ReprocessDeadLetterEventsRequest::event_ids(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.ReprocessDeadLetterEventsRequest.event_ids)
  return _internal_event_ids(index);
}
inline std::string* ReprocessDeadLetterEventsRequest::mutable_event_ids(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.ReprocessDeadLetterEventsRequest.event_ids)
  return _impl_.event_ids_.Mutable(index);
}
inline void ReprocessDeadLetterEventsRequest::set_event_ids(int index, const std::string& value) {
  _impl_.event_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.ReprocessDeadLetterEventsRequest.event_ids)
}
inline void ReprocessDeadLetterEventsRequest::set_event_ids(int index, std::string&& value) {
  _impl_.event_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.cdc.ReprocessDeadLetterEventsRequest.event_ids)
}
inline void ReprocessDeadLetterEventsRequest::set_event_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.event_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.cdc.ReprocessDeadLetterEventsRequest.event_ids)
}
inline void ReprocessDeadLetterEventsRequest::set_event_ids(int index, const char* value, size_t size) {
  _impl_.event_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.cdc.ReprocessDeadLetterEventsRequest.event_ids)
}
inline std::string* ReprocessDeadLetterEventsRequest::_internal_add_event_ids() {
  return _impl_.event_ids_.Add();
}
inline void ReprocessDeadLetterEventsRequest::add_event_ids(const std::string& value) {
  _impl_.event_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.cdc.ReprocessDeadLetterEventsRequest.event_ids)
}
inline void ReprocessDeadLetterEventsRequest::add_event_ids(std::string&& value) {
  _impl_.event_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.cdc.ReprocessDeadLetterEventsRequest.event_ids)
}
inline void ReprocessDeadLetterEventsRequest::add_event_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.event_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.cdc.ReprocessDeadLetterEventsRequest.event_ids)
}
inline void ReprocessDeadLetterEventsRequest::add_event_ids(const char* value, size_t size) {
  _impl_.event_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.cdc.ReprocessDeadLetterEventsRequest.event_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ReprocessDeadLetterEventsRequest::event_ids() const {
  // @@protoc_insertion_point(field_list:unhinged.cdc.ReprocessDeadLetterEventsRequest.event_ids)
  return _impl_.event_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ReprocessDeadLetterEventsRequest::mutable_event_ids() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.cdc.ReprocessDeadLetterEventsRequest.event_ids)
  return &_impl_.event_ids_;
}

// bool reset_retry_count = 3;
inline void ReprocessDeadLetterEventsRequest::clear_reset_retry_count() {
  _impl_.reset_retry_count_ = false;
}
inline bool ReprocessDeadLetterEventsRequest::_internal_reset_retry_count() const {
  return _impl_.reset_retry_count_;
}
inline bool ReprocessDeadLetterEventsRequest::reset_retry_count() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.ReprocessDeadLetterEventsRequest.reset_retry_count)
  return _internal_reset_retry_count();
}
inline void ReprocessDeadLetterEventsRequest::_internal_set_reset_retry_count(bool value) {
  
  _impl_.reset_retry_count_ = value;
}
inline void ReprocessDeadLetterEventsRequest::set_reset_retry_count(bool value) {
  _internal_set_reset_retry_count(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.ReprocessDeadLetterEventsRequest.reset_retry_count)
}

// -------------------------------------------------------------------

// ReprocessDeadLetterEventsResponse

// bool success = 1;
inline void ReprocessDeadLetterEventsResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool ReprocessDeadLetterEventsResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool ReprocessDeadLetterEventsResponse::success() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.ReprocessDeadLetterEventsResponse.success)
  return _internal_success();
}
inline void ReprocessDeadLetterEventsResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void ReprocessDeadLetterEventsResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.ReprocessDeadLetterEventsResponse.success)
}

// string message = 2;
inline void ReprocessDeadLetterEventsResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& ReprocessDeadLetterEventsResponse::message() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.ReprocessDeadLetterEventsResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReprocessDeadLetterEventsResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.ReprocessDeadLetterEventsResponse.message)
}
inline std::string* ReprocessDeadLetterEventsResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.ReprocessDeadLetterEventsResponse.message)
  return _s;
}
inline const std::string& ReprocessDeadLetterEventsResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void ReprocessDeadLetterEventsResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* ReprocessDeadLetterEventsResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* ReprocessDeadLetterEventsResponse::release_message() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.ReprocessDeadLetterEventsResponse.message)
  return _impl_.message_.Release();
}
inline void ReprocessDeadLetterEventsResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.ReprocessDeadLetterEventsResponse.message)
}

// int32 reprocessed_count = 3;
inline void ReprocessDeadLetterEventsResponse::clear_reprocessed_count() {
  _impl_.reprocessed_count_ = 0;
}
inline int32_t ReprocessDeadLetterEventsResponse::_internal_reprocessed_count() const {
  return _impl_.reprocessed_count_;
}
inline int32_t ReprocessDeadLetterEventsResponse::reprocessed_count() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.ReprocessDeadLetterEventsResponse.reprocessed_count)
  return _internal_reprocessed_count();
}
inline void ReprocessDeadLetterEventsResponse::_internal_set_reprocessed_count(int32_t value) {
  
  _impl_.reprocessed_count_ = value;
}
inline void ReprocessDeadLetterEventsResponse::set_reprocessed_count(int32_t value) {
  _internal_set_reprocessed_count(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.ReprocessDeadLetterEventsResponse.reprocessed_count)
}

// -------------------------------------------------------------------

// GetEventStatsRequest

// .google.protobuf.Timestamp start_time = 1;
inline bool GetEventStatsRequest::_internal_has_start_time() const {
  return this != internal_default_instance() && _impl_.start_time_ != nullptr;
}
inline bool GetEventStatsRequest::has_start_time() const {
  return _internal_has_start_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& GetEventStatsRequest::_internal_start_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.start_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& GetEventStatsRequest::start_time() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.GetEventStatsRequest.start_time)
  return _internal_start_time();
}
inline void GetEventStatsRequest::unsafe_arena_set_allocated_start_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_time_);
  }
  _impl_.start_time_ = start_time;
  if (start_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.GetEventStatsRequest.start_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetEventStatsRequest::release_start_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.start_time_;
  _impl_.start_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetEventStatsRequest::unsafe_arena_release_start_time() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.GetEventStatsRequest.start_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.start_time_;
  _impl_.start_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetEventStatsRequest::_internal_mutable_start_time() {
  
  if (_impl_.start_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.start_time_ = p;
  }
  return _impl_.start_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetEventStatsRequest::mutable_start_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_start_time();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.GetEventStatsRequest.start_time)
  return _msg;
}
inline void GetEventStatsRequest::set_allocated_start_time(::PROTOBUF_NAMESPACE_ID::Timestamp* start_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_time_);
  }
  if (start_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_time));
    if (message_arena != submessage_arena) {
      start_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.start_time_ = start_time;
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.GetEventStatsRequest.start_time)
}

// .google.protobuf.Timestamp end_time = 2;
inline bool GetEventStatsRequest::_internal_has_end_time() const {
  return this != internal_default_instance() && _impl_.end_time_ != nullptr;
}
inline bool GetEventStatsRequest::has_end_time() const {
  return _internal_has_end_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& GetEventStatsRequest::_internal_end_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.end_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& GetEventStatsRequest::end_time() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.GetEventStatsRequest.end_time)
  return _internal_end_time();
}
inline void GetEventStatsRequest::unsafe_arena_set_allocated_end_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_time_);
  }
  _impl_.end_time_ = end_time;
  if (end_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.GetEventStatsRequest.end_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetEventStatsRequest::release_end_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.end_time_;
  _impl_.end_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetEventStatsRequest::unsafe_arena_release_end_time() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.GetEventStatsRequest.end_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.end_time_;
  _impl_.end_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetEventStatsRequest::_internal_mutable_end_time() {
  
  if (_impl_.end_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.end_time_ = p;
  }
  return _impl_.end_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetEventStatsRequest::mutable_end_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_end_time();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.GetEventStatsRequest.end_time)
  return _msg;
}
inline void GetEventStatsRequest::set_allocated_end_time(::PROTOBUF_NAMESPACE_ID::Timestamp* end_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_time_);
  }
  if (end_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_time));
    if (message_arena != submessage_arena) {
      end_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.end_time_ = end_time;
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.GetEventStatsRequest.end_time)
}

// repeated string event_types = 3;
inline int GetEventStatsRequest::_internal_event_types_size() const {
  return _impl_.event_types_.size();
}
inline int GetEventStatsRequest::event_types_size() const {
  return _internal_event_types_size();
}
inline void GetEventStatsRequest::clear_event_types() {
  _impl_.event_types_.Clear();
}
inline std::string* GetEventStatsRequest::add_event_types() {
  std::string* _s = _internal_add_event_types();
  // @@protoc_insertion_point(field_add_mutable:unhinged.cdc.GetEventStatsRequest.event_types)
  return _s;
}
inline const std::string& GetEventStatsRequest::_internal_event_types(int index) const {
  return _impl_.event_types_.Get(index);
}
inline const std::string& GetEventStatsRequest::event_types(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.GetEventStatsRequest.event_types)
  return _internal_event_types(index);
}
inline std::string* GetEventStatsRequest::mutable_event_types(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.GetEventStatsRequest.event_types)
  return _impl_.event_types_.Mutable(index);
}
inline void GetEventStatsRequest::set_event_types(int index, const std::string& value) {
  _impl_.event_types_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.GetEventStatsRequest.event_types)
}
inline void GetEventStatsRequest::set_event_types(int index, std::string&& value) {
  _impl_.event_types_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.cdc.GetEventStatsRequest.event_types)
}
inline void GetEventStatsRequest::set_event_types(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.event_types_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.cdc.GetEventStatsRequest.event_types)
}
inline void GetEventStatsRequest::set_event_types(int index, const char* value, size_t size) {
  _impl_.event_types_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.cdc.GetEventStatsRequest.event_types)
}
inline std::string* GetEventStatsRequest::_internal_add_event_types() {
  return _impl_.event_types_.Add();
}
inline void GetEventStatsRequest::add_event_types(const std::string& value) {
  _impl_.event_types_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.cdc.GetEventStatsRequest.event_types)
}
inline void GetEventStatsRequest::add_event_types(std::string&& value) {
  _impl_.event_types_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.cdc.GetEventStatsRequest.event_types)
}
inline void GetEventStatsRequest::add_event_types(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.event_types_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.cdc.GetEventStatsRequest.event_types)
}
inline void GetEventStatsRequest::add_event_types(const char* value, size_t size) {
  _impl_.event_types_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.cdc.GetEventStatsRequest.event_types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetEventStatsRequest::event_types() const {
  // @@protoc_insertion_point(field_list:unhinged.cdc.GetEventStatsRequest.event_types)
  return _impl_.event_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetEventStatsRequest::mutable_event_types() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.cdc.GetEventStatsRequest.event_types)
  return &_impl_.event_types_;
}

// repeated string source_services = 4;
inline int GetEventStatsRequest::_internal_source_services_size() const {
  return _impl_.source_services_.size();
}
inline int GetEventStatsRequest::source_services_size() const {
  return _internal_source_services_size();
}
inline void GetEventStatsRequest::clear_source_services() {
  _impl_.source_services_.Clear();
}
inline std::string* GetEventStatsRequest::add_source_services() {
  std::string* _s = _internal_add_source_services();
  // @@protoc_insertion_point(field_add_mutable:unhinged.cdc.GetEventStatsRequest.source_services)
  return _s;
}
inline const std::string& GetEventStatsRequest::_internal_source_services(int index) const {
  return _impl_.source_services_.Get(index);
}
inline const std::string& GetEventStatsRequest::source_services(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.GetEventStatsRequest.source_services)
  return _internal_source_services(index);
}
inline std::string* GetEventStatsRequest::mutable_source_services(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.GetEventStatsRequest.source_services)
  return _impl_.source_services_.Mutable(index);
}
inline void GetEventStatsRequest::set_source_services(int index, const std::string& value) {
  _impl_.source_services_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.GetEventStatsRequest.source_services)
}
inline void GetEventStatsRequest::set_source_services(int index, std::string&& value) {
  _impl_.source_services_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.cdc.GetEventStatsRequest.source_services)
}
inline void GetEventStatsRequest::set_source_services(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.source_services_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.cdc.GetEventStatsRequest.source_services)
}
inline void GetEventStatsRequest::set_source_services(int index, const char* value, size_t size) {
  _impl_.source_services_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.cdc.GetEventStatsRequest.source_services)
}
inline std::string* GetEventStatsRequest::_internal_add_source_services() {
  return _impl_.source_services_.Add();
}
inline void GetEventStatsRequest::add_source_services(const std::string& value) {
  _impl_.source_services_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.cdc.GetEventStatsRequest.source_services)
}
inline void GetEventStatsRequest::add_source_services(std::string&& value) {
  _impl_.source_services_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.cdc.GetEventStatsRequest.source_services)
}
inline void GetEventStatsRequest::add_source_services(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.source_services_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.cdc.GetEventStatsRequest.source_services)
}
inline void GetEventStatsRequest::add_source_services(const char* value, size_t size) {
  _impl_.source_services_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.cdc.GetEventStatsRequest.source_services)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetEventStatsRequest::source_services() const {
  // @@protoc_insertion_point(field_list:unhinged.cdc.GetEventStatsRequest.source_services)
  return _impl_.source_services_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetEventStatsRequest::mutable_source_services() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.cdc.GetEventStatsRequest.source_services)
  return &_impl_.source_services_;
}

// string aggregation_interval = 5;
inline void GetEventStatsRequest::clear_aggregation_interval() {
  _impl_.aggregation_interval_.ClearToEmpty();
}
inline const std::string& GetEventStatsRequest::aggregation_interval() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.GetEventStatsRequest.aggregation_interval)
  return _internal_aggregation_interval();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetEventStatsRequest::set_aggregation_interval(ArgT0&& arg0, ArgT... args) {
 
 _impl_.aggregation_interval_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.GetEventStatsRequest.aggregation_interval)
}
inline std::string* GetEventStatsRequest::mutable_aggregation_interval() {
  std::string* _s = _internal_mutable_aggregation_interval();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.GetEventStatsRequest.aggregation_interval)
  return _s;
}
inline const std::string& GetEventStatsRequest::_internal_aggregation_interval() const {
  return _impl_.aggregation_interval_.Get();
}
inline void GetEventStatsRequest::_internal_set_aggregation_interval(const std::string& value) {
  
  _impl_.aggregation_interval_.Set(value, GetArenaForAllocation());
}
inline std::string* GetEventStatsRequest::_internal_mutable_aggregation_interval() {
  
  return _impl_.aggregation_interval_.Mutable(GetArenaForAllocation());
}
inline std::string* GetEventStatsRequest::release_aggregation_interval() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.GetEventStatsRequest.aggregation_interval)
  return _impl_.aggregation_interval_.Release();
}
inline void GetEventStatsRequest::set_allocated_aggregation_interval(std::string* aggregation_interval) {
  if (aggregation_interval != nullptr) {
    
  } else {
    
  }
  _impl_.aggregation_interval_.SetAllocated(aggregation_interval, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.aggregation_interval_.IsDefault()) {
    _impl_.aggregation_interval_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.GetEventStatsRequest.aggregation_interval)
}

// -------------------------------------------------------------------

// GetEventStatsResponse

// repeated .unhinged.cdc.EventStats stats = 1;
inline int GetEventStatsResponse::_internal_stats_size() const {
  return _impl_.stats_.size();
}
inline int GetEventStatsResponse::stats_size() const {
  return _internal_stats_size();
}
inline void GetEventStatsResponse::clear_stats() {
  _impl_.stats_.Clear();
}
inline ::unhinged::cdc::EventStats* GetEventStatsResponse::mutable_stats(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.GetEventStatsResponse.stats)
  return _impl_.stats_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::cdc::EventStats >*
GetEventStatsResponse::mutable_stats() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.cdc.GetEventStatsResponse.stats)
  return &_impl_.stats_;
}
inline const ::unhinged::cdc::EventStats& GetEventStatsResponse::_internal_stats(int index) const {
  return _impl_.stats_.Get(index);
}
inline const ::unhinged::cdc::EventStats& GetEventStatsResponse::stats(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.GetEventStatsResponse.stats)
  return _internal_stats(index);
}
inline ::unhinged::cdc::EventStats* GetEventStatsResponse::_internal_add_stats() {
  return _impl_.stats_.Add();
}
inline ::unhinged::cdc::EventStats* GetEventStatsResponse::add_stats() {
  ::unhinged::cdc::EventStats* _add = _internal_add_stats();
  // @@protoc_insertion_point(field_add:unhinged.cdc.GetEventStatsResponse.stats)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::cdc::EventStats >&
GetEventStatsResponse::stats() const {
  // @@protoc_insertion_point(field_list:unhinged.cdc.GetEventStatsResponse.stats)
  return _impl_.stats_;
}

// -------------------------------------------------------------------

// EventStats

// .google.protobuf.Timestamp timestamp = 1;
inline bool EventStats::_internal_has_timestamp() const {
  return this != internal_default_instance() && _impl_.timestamp_ != nullptr;
}
inline bool EventStats::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& EventStats::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& EventStats::timestamp() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.EventStats.timestamp)
  return _internal_timestamp();
}
inline void EventStats::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.EventStats.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* EventStats::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* EventStats::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.EventStats.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* EventStats::_internal_mutable_timestamp() {
  
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* EventStats::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.EventStats.timestamp)
  return _msg;
}
inline void EventStats::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.EventStats.timestamp)
}

// string event_type = 2;
inline void EventStats::clear_event_type() {
  _impl_.event_type_.ClearToEmpty();
}
inline const std::string& EventStats::event_type() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.EventStats.event_type)
  return _internal_event_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EventStats::set_event_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.event_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.EventStats.event_type)
}
inline std::string* EventStats::mutable_event_type() {
  std::string* _s = _internal_mutable_event_type();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.EventStats.event_type)
  return _s;
}
inline const std::string& EventStats::_internal_event_type() const {
  return _impl_.event_type_.Get();
}
inline void EventStats::_internal_set_event_type(const std::string& value) {
  
  _impl_.event_type_.Set(value, GetArenaForAllocation());
}
inline std::string* EventStats::_internal_mutable_event_type() {
  
  return _impl_.event_type_.Mutable(GetArenaForAllocation());
}
inline std::string* EventStats::release_event_type() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.EventStats.event_type)
  return _impl_.event_type_.Release();
}
inline void EventStats::set_allocated_event_type(std::string* event_type) {
  if (event_type != nullptr) {
    
  } else {
    
  }
  _impl_.event_type_.SetAllocated(event_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.event_type_.IsDefault()) {
    _impl_.event_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.EventStats.event_type)
}

// string source_service = 3;
inline void EventStats::clear_source_service() {
  _impl_.source_service_.ClearToEmpty();
}
inline const std::string& EventStats::source_service() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.EventStats.source_service)
  return _internal_source_service();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EventStats::set_source_service(ArgT0&& arg0, ArgT... args) {
 
 _impl_.source_service_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.EventStats.source_service)
}
inline std::string* EventStats::mutable_source_service() {
  std::string* _s = _internal_mutable_source_service();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.EventStats.source_service)
  return _s;
}
inline const std::string& EventStats::_internal_source_service() const {
  return _impl_.source_service_.Get();
}
inline void EventStats::_internal_set_source_service(const std::string& value) {
  
  _impl_.source_service_.Set(value, GetArenaForAllocation());
}
inline std::string* EventStats::_internal_mutable_source_service() {
  
  return _impl_.source_service_.Mutable(GetArenaForAllocation());
}
inline std::string* EventStats::release_source_service() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.EventStats.source_service)
  return _impl_.source_service_.Release();
}
inline void EventStats::set_allocated_source_service(std::string* source_service) {
  if (source_service != nullptr) {
    
  } else {
    
  }
  _impl_.source_service_.SetAllocated(source_service, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.source_service_.IsDefault()) {
    _impl_.source_service_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.EventStats.source_service)
}

// int64 event_count = 4;
inline void EventStats::clear_event_count() {
  _impl_.event_count_ = int64_t{0};
}
inline int64_t EventStats::_internal_event_count() const {
  return _impl_.event_count_;
}
inline int64_t EventStats::event_count() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.EventStats.event_count)
  return _internal_event_count();
}
inline void EventStats::_internal_set_event_count(int64_t value) {
  
  _impl_.event_count_ = value;
}
inline void EventStats::set_event_count(int64_t value) {
  _internal_set_event_count(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.EventStats.event_count)
}

// double events_per_second = 5;
inline void EventStats::clear_events_per_second() {
  _impl_.events_per_second_ = 0;
}
inline double EventStats::_internal_events_per_second() const {
  return _impl_.events_per_second_;
}
inline double EventStats::events_per_second() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.EventStats.events_per_second)
  return _internal_events_per_second();
}
inline void EventStats::_internal_set_events_per_second(double value) {
  
  _impl_.events_per_second_ = value;
}
inline void EventStats::set_events_per_second(double value) {
  _internal_set_events_per_second(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.EventStats.events_per_second)
}

// double avg_processing_time_ms = 6;
inline void EventStats::clear_avg_processing_time_ms() {
  _impl_.avg_processing_time_ms_ = 0;
}
inline double EventStats::_internal_avg_processing_time_ms() const {
  return _impl_.avg_processing_time_ms_;
}
inline double EventStats::avg_processing_time_ms() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.EventStats.avg_processing_time_ms)
  return _internal_avg_processing_time_ms();
}
inline void EventStats::_internal_set_avg_processing_time_ms(double value) {
  
  _impl_.avg_processing_time_ms_ = value;
}
inline void EventStats::set_avg_processing_time_ms(double value) {
  _internal_set_avg_processing_time_ms(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.EventStats.avg_processing_time_ms)
}

// int64 failed_count = 7;
inline void EventStats::clear_failed_count() {
  _impl_.failed_count_ = int64_t{0};
}
inline int64_t EventStats::_internal_failed_count() const {
  return _impl_.failed_count_;
}
inline int64_t EventStats::failed_count() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.EventStats.failed_count)
  return _internal_failed_count();
}
inline void EventStats::_internal_set_failed_count(int64_t value) {
  
  _impl_.failed_count_ = value;
}
inline void EventStats::set_failed_count(int64_t value) {
  _internal_set_failed_count(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.EventStats.failed_count)
}

// -------------------------------------------------------------------

// ListSubscriptionsRequest

// string subscriber_id = 1;
inline void ListSubscriptionsRequest::clear_subscriber_id() {
  _impl_.subscriber_id_.ClearToEmpty();
}
inline const std::string& ListSubscriptionsRequest::subscriber_id() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.ListSubscriptionsRequest.subscriber_id)
  return _internal_subscriber_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListSubscriptionsRequest::set_subscriber_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.subscriber_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.ListSubscriptionsRequest.subscriber_id)
}
inline std::string* ListSubscriptionsRequest::mutable_subscriber_id() {
  std::string* _s = _internal_mutable_subscriber_id();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.ListSubscriptionsRequest.subscriber_id)
  return _s;
}
inline const std::string& ListSubscriptionsRequest::_internal_subscriber_id() const {
  return _impl_.subscriber_id_.Get();
}
inline void ListSubscriptionsRequest::_internal_set_subscriber_id(const std::string& value) {
  
  _impl_.subscriber_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ListSubscriptionsRequest::_internal_mutable_subscriber_id() {
  
  return _impl_.subscriber_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ListSubscriptionsRequest::release_subscriber_id() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.ListSubscriptionsRequest.subscriber_id)
  return _impl_.subscriber_id_.Release();
}
inline void ListSubscriptionsRequest::set_allocated_subscriber_id(std::string* subscriber_id) {
  if (subscriber_id != nullptr) {
    
  } else {
    
  }
  _impl_.subscriber_id_.SetAllocated(subscriber_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.subscriber_id_.IsDefault()) {
    _impl_.subscriber_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.ListSubscriptionsRequest.subscriber_id)
}

// bool include_inactive = 2;
inline void ListSubscriptionsRequest::clear_include_inactive() {
  _impl_.include_inactive_ = false;
}
inline bool ListSubscriptionsRequest::_internal_include_inactive() const {
  return _impl_.include_inactive_;
}
inline bool ListSubscriptionsRequest::include_inactive() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.ListSubscriptionsRequest.include_inactive)
  return _internal_include_inactive();
}
inline void ListSubscriptionsRequest::_internal_set_include_inactive(bool value) {
  
  _impl_.include_inactive_ = value;
}
inline void ListSubscriptionsRequest::set_include_inactive(bool value) {
  _internal_set_include_inactive(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.ListSubscriptionsRequest.include_inactive)
}

// -------------------------------------------------------------------

// ListSubscriptionsResponse

// repeated .unhinged.cdc.SubscriptionInfo subscriptions = 1;
inline int ListSubscriptionsResponse::_internal_subscriptions_size() const {
  return _impl_.subscriptions_.size();
}
inline int ListSubscriptionsResponse::subscriptions_size() const {
  return _internal_subscriptions_size();
}
inline void ListSubscriptionsResponse::clear_subscriptions() {
  _impl_.subscriptions_.Clear();
}
inline ::unhinged::cdc::SubscriptionInfo* ListSubscriptionsResponse::mutable_subscriptions(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.ListSubscriptionsResponse.subscriptions)
  return _impl_.subscriptions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::cdc::SubscriptionInfo >*
ListSubscriptionsResponse::mutable_subscriptions() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.cdc.ListSubscriptionsResponse.subscriptions)
  return &_impl_.subscriptions_;
}
inline const ::unhinged::cdc::SubscriptionInfo& ListSubscriptionsResponse::_internal_subscriptions(int index) const {
  return _impl_.subscriptions_.Get(index);
}
inline const ::unhinged::cdc::SubscriptionInfo& ListSubscriptionsResponse::subscriptions(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.ListSubscriptionsResponse.subscriptions)
  return _internal_subscriptions(index);
}
inline ::unhinged::cdc::SubscriptionInfo* ListSubscriptionsResponse::_internal_add_subscriptions() {
  return _impl_.subscriptions_.Add();
}
inline ::unhinged::cdc::SubscriptionInfo* ListSubscriptionsResponse::add_subscriptions() {
  ::unhinged::cdc::SubscriptionInfo* _add = _internal_add_subscriptions();
  // @@protoc_insertion_point(field_add:unhinged.cdc.ListSubscriptionsResponse.subscriptions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::cdc::SubscriptionInfo >&
ListSubscriptionsResponse::subscriptions() const {
  // @@protoc_insertion_point(field_list:unhinged.cdc.ListSubscriptionsResponse.subscriptions)
  return _impl_.subscriptions_;
}

// -------------------------------------------------------------------

// SubscriptionInfo

// string subscriber_id = 1;
inline void SubscriptionInfo::clear_subscriber_id() {
  _impl_.subscriber_id_.ClearToEmpty();
}
inline const std::string& SubscriptionInfo::subscriber_id() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.SubscriptionInfo.subscriber_id)
  return _internal_subscriber_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubscriptionInfo::set_subscriber_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.subscriber_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.SubscriptionInfo.subscriber_id)
}
inline std::string* SubscriptionInfo::mutable_subscriber_id() {
  std::string* _s = _internal_mutable_subscriber_id();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.SubscriptionInfo.subscriber_id)
  return _s;
}
inline const std::string& SubscriptionInfo::_internal_subscriber_id() const {
  return _impl_.subscriber_id_.Get();
}
inline void SubscriptionInfo::_internal_set_subscriber_id(const std::string& value) {
  
  _impl_.subscriber_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SubscriptionInfo::_internal_mutable_subscriber_id() {
  
  return _impl_.subscriber_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SubscriptionInfo::release_subscriber_id() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.SubscriptionInfo.subscriber_id)
  return _impl_.subscriber_id_.Release();
}
inline void SubscriptionInfo::set_allocated_subscriber_id(std::string* subscriber_id) {
  if (subscriber_id != nullptr) {
    
  } else {
    
  }
  _impl_.subscriber_id_.SetAllocated(subscriber_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.subscriber_id_.IsDefault()) {
    _impl_.subscriber_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.SubscriptionInfo.subscriber_id)
}

// string subscriber_name = 2;
inline void SubscriptionInfo::clear_subscriber_name() {
  _impl_.subscriber_name_.ClearToEmpty();
}
inline const std::string& SubscriptionInfo::subscriber_name() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.SubscriptionInfo.subscriber_name)
  return _internal_subscriber_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubscriptionInfo::set_subscriber_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.subscriber_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.SubscriptionInfo.subscriber_name)
}
inline std::string* SubscriptionInfo::mutable_subscriber_name() {
  std::string* _s = _internal_mutable_subscriber_name();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.SubscriptionInfo.subscriber_name)
  return _s;
}
inline const std::string& SubscriptionInfo::_internal_subscriber_name() const {
  return _impl_.subscriber_name_.Get();
}
inline void SubscriptionInfo::_internal_set_subscriber_name(const std::string& value) {
  
  _impl_.subscriber_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SubscriptionInfo::_internal_mutable_subscriber_name() {
  
  return _impl_.subscriber_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SubscriptionInfo::release_subscriber_name() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.SubscriptionInfo.subscriber_name)
  return _impl_.subscriber_name_.Release();
}
inline void SubscriptionInfo::set_allocated_subscriber_name(std::string* subscriber_name) {
  if (subscriber_name != nullptr) {
    
  } else {
    
  }
  _impl_.subscriber_name_.SetAllocated(subscriber_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.subscriber_name_.IsDefault()) {
    _impl_.subscriber_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.SubscriptionInfo.subscriber_name)
}

// .unhinged.cdc.EventFilter filter = 3;
inline bool SubscriptionInfo::_internal_has_filter() const {
  return this != internal_default_instance() && _impl_.filter_ != nullptr;
}
inline bool SubscriptionInfo::has_filter() const {
  return _internal_has_filter();
}
inline void SubscriptionInfo::clear_filter() {
  if (GetArenaForAllocation() == nullptr && _impl_.filter_ != nullptr) {
    delete _impl_.filter_;
  }
  _impl_.filter_ = nullptr;
}
inline const ::unhinged::cdc::EventFilter& SubscriptionInfo::_internal_filter() const {
  const ::unhinged::cdc::EventFilter* p = _impl_.filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::cdc::EventFilter&>(
      ::unhinged::cdc::_EventFilter_default_instance_);
}
inline const ::unhinged::cdc::EventFilter& SubscriptionInfo::filter() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.SubscriptionInfo.filter)
  return _internal_filter();
}
inline void SubscriptionInfo::unsafe_arena_set_allocated_filter(
    ::unhinged::cdc::EventFilter* filter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.filter_);
  }
  _impl_.filter_ = filter;
  if (filter) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.SubscriptionInfo.filter)
}
inline ::unhinged::cdc::EventFilter* SubscriptionInfo::release_filter() {
  
  ::unhinged::cdc::EventFilter* temp = _impl_.filter_;
  _impl_.filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::cdc::EventFilter* SubscriptionInfo::unsafe_arena_release_filter() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.SubscriptionInfo.filter)
  
  ::unhinged::cdc::EventFilter* temp = _impl_.filter_;
  _impl_.filter_ = nullptr;
  return temp;
}
inline ::unhinged::cdc::EventFilter* SubscriptionInfo::_internal_mutable_filter() {
  
  if (_impl_.filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::cdc::EventFilter>(GetArenaForAllocation());
    _impl_.filter_ = p;
  }
  return _impl_.filter_;
}
inline ::unhinged::cdc::EventFilter* SubscriptionInfo::mutable_filter() {
  ::unhinged::cdc::EventFilter* _msg = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.SubscriptionInfo.filter)
  return _msg;
}
inline void SubscriptionInfo::set_allocated_filter(::unhinged::cdc::EventFilter* filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.filter_;
  }
  if (filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(filter);
    if (message_arena != submessage_arena) {
      filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, filter, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.filter_ = filter;
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.SubscriptionInfo.filter)
}

// .unhinged.cdc.SubscriptionOptions options = 4;
inline bool SubscriptionInfo::_internal_has_options() const {
  return this != internal_default_instance() && _impl_.options_ != nullptr;
}
inline bool SubscriptionInfo::has_options() const {
  return _internal_has_options();
}
inline void SubscriptionInfo::clear_options() {
  if (GetArenaForAllocation() == nullptr && _impl_.options_ != nullptr) {
    delete _impl_.options_;
  }
  _impl_.options_ = nullptr;
}
inline const ::unhinged::cdc::SubscriptionOptions& SubscriptionInfo::_internal_options() const {
  const ::unhinged::cdc::SubscriptionOptions* p = _impl_.options_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::cdc::SubscriptionOptions&>(
      ::unhinged::cdc::_SubscriptionOptions_default_instance_);
}
inline const ::unhinged::cdc::SubscriptionOptions& SubscriptionInfo::options() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.SubscriptionInfo.options)
  return _internal_options();
}
inline void SubscriptionInfo::unsafe_arena_set_allocated_options(
    ::unhinged::cdc::SubscriptionOptions* options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.options_);
  }
  _impl_.options_ = options;
  if (options) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.SubscriptionInfo.options)
}
inline ::unhinged::cdc::SubscriptionOptions* SubscriptionInfo::release_options() {
  
  ::unhinged::cdc::SubscriptionOptions* temp = _impl_.options_;
  _impl_.options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::cdc::SubscriptionOptions* SubscriptionInfo::unsafe_arena_release_options() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.SubscriptionInfo.options)
  
  ::unhinged::cdc::SubscriptionOptions* temp = _impl_.options_;
  _impl_.options_ = nullptr;
  return temp;
}
inline ::unhinged::cdc::SubscriptionOptions* SubscriptionInfo::_internal_mutable_options() {
  
  if (_impl_.options_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::cdc::SubscriptionOptions>(GetArenaForAllocation());
    _impl_.options_ = p;
  }
  return _impl_.options_;
}
inline ::unhinged::cdc::SubscriptionOptions* SubscriptionInfo::mutable_options() {
  ::unhinged::cdc::SubscriptionOptions* _msg = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.SubscriptionInfo.options)
  return _msg;
}
inline void SubscriptionInfo::set_allocated_options(::unhinged::cdc::SubscriptionOptions* options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.options_;
  }
  if (options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(options);
    if (message_arena != submessage_arena) {
      options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.options_ = options;
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.SubscriptionInfo.options)
}

// string status = 5;
inline void SubscriptionInfo::clear_status() {
  _impl_.status_.ClearToEmpty();
}
inline const std::string& SubscriptionInfo::status() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.SubscriptionInfo.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubscriptionInfo::set_status(ArgT0&& arg0, ArgT... args) {
 
 _impl_.status_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.SubscriptionInfo.status)
}
inline std::string* SubscriptionInfo::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.SubscriptionInfo.status)
  return _s;
}
inline const std::string& SubscriptionInfo::_internal_status() const {
  return _impl_.status_.Get();
}
inline void SubscriptionInfo::_internal_set_status(const std::string& value) {
  
  _impl_.status_.Set(value, GetArenaForAllocation());
}
inline std::string* SubscriptionInfo::_internal_mutable_status() {
  
  return _impl_.status_.Mutable(GetArenaForAllocation());
}
inline std::string* SubscriptionInfo::release_status() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.SubscriptionInfo.status)
  return _impl_.status_.Release();
}
inline void SubscriptionInfo::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  _impl_.status_.SetAllocated(status, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.SubscriptionInfo.status)
}

// .google.protobuf.Timestamp created_at = 6;
inline bool SubscriptionInfo::_internal_has_created_at() const {
  return this != internal_default_instance() && _impl_.created_at_ != nullptr;
}
inline bool SubscriptionInfo::has_created_at() const {
  return _internal_has_created_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SubscriptionInfo::_internal_created_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SubscriptionInfo::created_at() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.SubscriptionInfo.created_at)
  return _internal_created_at();
}
inline void SubscriptionInfo::unsafe_arena_set_allocated_created_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.SubscriptionInfo.created_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SubscriptionInfo::release_created_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SubscriptionInfo::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.SubscriptionInfo.created_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SubscriptionInfo::_internal_mutable_created_at() {
  
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.created_at_ = p;
  }
  return _impl_.created_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SubscriptionInfo::mutable_created_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.SubscriptionInfo.created_at)
  return _msg;
}
inline void SubscriptionInfo::set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at));
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.SubscriptionInfo.created_at)
}

// .google.protobuf.Timestamp last_active_at = 7;
inline bool SubscriptionInfo::_internal_has_last_active_at() const {
  return this != internal_default_instance() && _impl_.last_active_at_ != nullptr;
}
inline bool SubscriptionInfo::has_last_active_at() const {
  return _internal_has_last_active_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SubscriptionInfo::_internal_last_active_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.last_active_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SubscriptionInfo::last_active_at() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.SubscriptionInfo.last_active_at)
  return _internal_last_active_at();
}
inline void SubscriptionInfo::unsafe_arena_set_allocated_last_active_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_active_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_active_at_);
  }
  _impl_.last_active_at_ = last_active_at;
  if (last_active_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.SubscriptionInfo.last_active_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SubscriptionInfo::release_last_active_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.last_active_at_;
  _impl_.last_active_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SubscriptionInfo::unsafe_arena_release_last_active_at() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.SubscriptionInfo.last_active_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.last_active_at_;
  _impl_.last_active_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SubscriptionInfo::_internal_mutable_last_active_at() {
  
  if (_impl_.last_active_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.last_active_at_ = p;
  }
  return _impl_.last_active_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SubscriptionInfo::mutable_last_active_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_last_active_at();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.SubscriptionInfo.last_active_at)
  return _msg;
}
inline void SubscriptionInfo::set_allocated_last_active_at(::PROTOBUF_NAMESPACE_ID::Timestamp* last_active_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_active_at_);
  }
  if (last_active_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_active_at));
    if (message_arena != submessage_arena) {
      last_active_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_active_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.last_active_at_ = last_active_at;
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.SubscriptionInfo.last_active_at)
}

// int64 events_processed = 8;
inline void SubscriptionInfo::clear_events_processed() {
  _impl_.events_processed_ = int64_t{0};
}
inline int64_t SubscriptionInfo::_internal_events_processed() const {
  return _impl_.events_processed_;
}
inline int64_t SubscriptionInfo::events_processed() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.SubscriptionInfo.events_processed)
  return _internal_events_processed();
}
inline void SubscriptionInfo::_internal_set_events_processed(int64_t value) {
  
  _impl_.events_processed_ = value;
}
inline void SubscriptionInfo::set_events_processed(int64_t value) {
  _internal_set_events_processed(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.SubscriptionInfo.events_processed)
}

// int64 events_failed = 9;
inline void SubscriptionInfo::clear_events_failed() {
  _impl_.events_failed_ = int64_t{0};
}
inline int64_t SubscriptionInfo::_internal_events_failed() const {
  return _impl_.events_failed_;
}
inline int64_t SubscriptionInfo::events_failed() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.SubscriptionInfo.events_failed)
  return _internal_events_failed();
}
inline void SubscriptionInfo::_internal_set_events_failed(int64_t value) {
  
  _impl_.events_failed_ = value;
}
inline void SubscriptionInfo::set_events_failed(int64_t value) {
  _internal_set_events_failed(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.SubscriptionInfo.events_failed)
}

// -------------------------------------------------------------------

// UpdateSubscriptionRequest

// string subscriber_id = 1;
inline void UpdateSubscriptionRequest::clear_subscriber_id() {
  _impl_.subscriber_id_.ClearToEmpty();
}
inline const std::string& UpdateSubscriptionRequest::subscriber_id() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.UpdateSubscriptionRequest.subscriber_id)
  return _internal_subscriber_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateSubscriptionRequest::set_subscriber_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.subscriber_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.UpdateSubscriptionRequest.subscriber_id)
}
inline std::string* UpdateSubscriptionRequest::mutable_subscriber_id() {
  std::string* _s = _internal_mutable_subscriber_id();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.UpdateSubscriptionRequest.subscriber_id)
  return _s;
}
inline const std::string& UpdateSubscriptionRequest::_internal_subscriber_id() const {
  return _impl_.subscriber_id_.Get();
}
inline void UpdateSubscriptionRequest::_internal_set_subscriber_id(const std::string& value) {
  
  _impl_.subscriber_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateSubscriptionRequest::_internal_mutable_subscriber_id() {
  
  return _impl_.subscriber_id_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateSubscriptionRequest::release_subscriber_id() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.UpdateSubscriptionRequest.subscriber_id)
  return _impl_.subscriber_id_.Release();
}
inline void UpdateSubscriptionRequest::set_allocated_subscriber_id(std::string* subscriber_id) {
  if (subscriber_id != nullptr) {
    
  } else {
    
  }
  _impl_.subscriber_id_.SetAllocated(subscriber_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.subscriber_id_.IsDefault()) {
    _impl_.subscriber_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.UpdateSubscriptionRequest.subscriber_id)
}

// .unhinged.cdc.EventFilter filter = 2;
inline bool UpdateSubscriptionRequest::_internal_has_filter() const {
  return this != internal_default_instance() && _impl_.filter_ != nullptr;
}
inline bool UpdateSubscriptionRequest::has_filter() const {
  return _internal_has_filter();
}
inline void UpdateSubscriptionRequest::clear_filter() {
  if (GetArenaForAllocation() == nullptr && _impl_.filter_ != nullptr) {
    delete _impl_.filter_;
  }
  _impl_.filter_ = nullptr;
}
inline const ::unhinged::cdc::EventFilter& UpdateSubscriptionRequest::_internal_filter() const {
  const ::unhinged::cdc::EventFilter* p = _impl_.filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::cdc::EventFilter&>(
      ::unhinged::cdc::_EventFilter_default_instance_);
}
inline const ::unhinged::cdc::EventFilter& UpdateSubscriptionRequest::filter() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.UpdateSubscriptionRequest.filter)
  return _internal_filter();
}
inline void UpdateSubscriptionRequest::unsafe_arena_set_allocated_filter(
    ::unhinged::cdc::EventFilter* filter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.filter_);
  }
  _impl_.filter_ = filter;
  if (filter) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.UpdateSubscriptionRequest.filter)
}
inline ::unhinged::cdc::EventFilter* UpdateSubscriptionRequest::release_filter() {
  
  ::unhinged::cdc::EventFilter* temp = _impl_.filter_;
  _impl_.filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::cdc::EventFilter* UpdateSubscriptionRequest::unsafe_arena_release_filter() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.UpdateSubscriptionRequest.filter)
  
  ::unhinged::cdc::EventFilter* temp = _impl_.filter_;
  _impl_.filter_ = nullptr;
  return temp;
}
inline ::unhinged::cdc::EventFilter* UpdateSubscriptionRequest::_internal_mutable_filter() {
  
  if (_impl_.filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::cdc::EventFilter>(GetArenaForAllocation());
    _impl_.filter_ = p;
  }
  return _impl_.filter_;
}
inline ::unhinged::cdc::EventFilter* UpdateSubscriptionRequest::mutable_filter() {
  ::unhinged::cdc::EventFilter* _msg = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.UpdateSubscriptionRequest.filter)
  return _msg;
}
inline void UpdateSubscriptionRequest::set_allocated_filter(::unhinged::cdc::EventFilter* filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.filter_;
  }
  if (filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(filter);
    if (message_arena != submessage_arena) {
      filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, filter, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.filter_ = filter;
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.UpdateSubscriptionRequest.filter)
}

// .unhinged.cdc.SubscriptionOptions options = 3;
inline bool UpdateSubscriptionRequest::_internal_has_options() const {
  return this != internal_default_instance() && _impl_.options_ != nullptr;
}
inline bool UpdateSubscriptionRequest::has_options() const {
  return _internal_has_options();
}
inline void UpdateSubscriptionRequest::clear_options() {
  if (GetArenaForAllocation() == nullptr && _impl_.options_ != nullptr) {
    delete _impl_.options_;
  }
  _impl_.options_ = nullptr;
}
inline const ::unhinged::cdc::SubscriptionOptions& UpdateSubscriptionRequest::_internal_options() const {
  const ::unhinged::cdc::SubscriptionOptions* p = _impl_.options_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::cdc::SubscriptionOptions&>(
      ::unhinged::cdc::_SubscriptionOptions_default_instance_);
}
inline const ::unhinged::cdc::SubscriptionOptions& UpdateSubscriptionRequest::options() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.UpdateSubscriptionRequest.options)
  return _internal_options();
}
inline void UpdateSubscriptionRequest::unsafe_arena_set_allocated_options(
    ::unhinged::cdc::SubscriptionOptions* options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.options_);
  }
  _impl_.options_ = options;
  if (options) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.UpdateSubscriptionRequest.options)
}
inline ::unhinged::cdc::SubscriptionOptions* UpdateSubscriptionRequest::release_options() {
  
  ::unhinged::cdc::SubscriptionOptions* temp = _impl_.options_;
  _impl_.options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::cdc::SubscriptionOptions* UpdateSubscriptionRequest::unsafe_arena_release_options() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.UpdateSubscriptionRequest.options)
  
  ::unhinged::cdc::SubscriptionOptions* temp = _impl_.options_;
  _impl_.options_ = nullptr;
  return temp;
}
inline ::unhinged::cdc::SubscriptionOptions* UpdateSubscriptionRequest::_internal_mutable_options() {
  
  if (_impl_.options_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::cdc::SubscriptionOptions>(GetArenaForAllocation());
    _impl_.options_ = p;
  }
  return _impl_.options_;
}
inline ::unhinged::cdc::SubscriptionOptions* UpdateSubscriptionRequest::mutable_options() {
  ::unhinged::cdc::SubscriptionOptions* _msg = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.UpdateSubscriptionRequest.options)
  return _msg;
}
inline void UpdateSubscriptionRequest::set_allocated_options(::unhinged::cdc::SubscriptionOptions* options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.options_;
  }
  if (options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(options);
    if (message_arena != submessage_arena) {
      options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.options_ = options;
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.UpdateSubscriptionRequest.options)
}

// -------------------------------------------------------------------

// UpdateSubscriptionResponse

// bool success = 1;
inline void UpdateSubscriptionResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool UpdateSubscriptionResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool UpdateSubscriptionResponse::success() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.UpdateSubscriptionResponse.success)
  return _internal_success();
}
inline void UpdateSubscriptionResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void UpdateSubscriptionResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.UpdateSubscriptionResponse.success)
}

// string message = 2;
inline void UpdateSubscriptionResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& UpdateSubscriptionResponse::message() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.UpdateSubscriptionResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateSubscriptionResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.UpdateSubscriptionResponse.message)
}
inline std::string* UpdateSubscriptionResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.UpdateSubscriptionResponse.message)
  return _s;
}
inline const std::string& UpdateSubscriptionResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void UpdateSubscriptionResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateSubscriptionResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateSubscriptionResponse::release_message() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.UpdateSubscriptionResponse.message)
  return _impl_.message_.Release();
}
inline void UpdateSubscriptionResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.UpdateSubscriptionResponse.message)
}

// -------------------------------------------------------------------

// DeleteSubscriptionRequest

// string subscriber_id = 1;
inline void DeleteSubscriptionRequest::clear_subscriber_id() {
  _impl_.subscriber_id_.ClearToEmpty();
}
inline const std::string& DeleteSubscriptionRequest::subscriber_id() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.DeleteSubscriptionRequest.subscriber_id)
  return _internal_subscriber_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteSubscriptionRequest::set_subscriber_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.subscriber_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.DeleteSubscriptionRequest.subscriber_id)
}
inline std::string* DeleteSubscriptionRequest::mutable_subscriber_id() {
  std::string* _s = _internal_mutable_subscriber_id();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.DeleteSubscriptionRequest.subscriber_id)
  return _s;
}
inline const std::string& DeleteSubscriptionRequest::_internal_subscriber_id() const {
  return _impl_.subscriber_id_.Get();
}
inline void DeleteSubscriptionRequest::_internal_set_subscriber_id(const std::string& value) {
  
  _impl_.subscriber_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteSubscriptionRequest::_internal_mutable_subscriber_id() {
  
  return _impl_.subscriber_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteSubscriptionRequest::release_subscriber_id() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.DeleteSubscriptionRequest.subscriber_id)
  return _impl_.subscriber_id_.Release();
}
inline void DeleteSubscriptionRequest::set_allocated_subscriber_id(std::string* subscriber_id) {
  if (subscriber_id != nullptr) {
    
  } else {
    
  }
  _impl_.subscriber_id_.SetAllocated(subscriber_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.subscriber_id_.IsDefault()) {
    _impl_.subscriber_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.DeleteSubscriptionRequest.subscriber_id)
}

// -------------------------------------------------------------------

// DeleteSubscriptionResponse

// bool success = 1;
inline void DeleteSubscriptionResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool DeleteSubscriptionResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool DeleteSubscriptionResponse::success() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.DeleteSubscriptionResponse.success)
  return _internal_success();
}
inline void DeleteSubscriptionResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void DeleteSubscriptionResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.DeleteSubscriptionResponse.success)
}

// string message = 2;
inline void DeleteSubscriptionResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& DeleteSubscriptionResponse::message() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.DeleteSubscriptionResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteSubscriptionResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.DeleteSubscriptionResponse.message)
}
inline std::string* DeleteSubscriptionResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.DeleteSubscriptionResponse.message)
  return _s;
}
inline const std::string& DeleteSubscriptionResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void DeleteSubscriptionResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteSubscriptionResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteSubscriptionResponse::release_message() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.DeleteSubscriptionResponse.message)
  return _impl_.message_.Release();
}
inline void DeleteSubscriptionResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.DeleteSubscriptionResponse.message)
}

// -------------------------------------------------------------------

// GetServiceStatusRequest

// -------------------------------------------------------------------

// GetServiceStatusResponse

// bool healthy = 1;
inline void GetServiceStatusResponse::clear_healthy() {
  _impl_.healthy_ = false;
}
inline bool GetServiceStatusResponse::_internal_healthy() const {
  return _impl_.healthy_;
}
inline bool GetServiceStatusResponse::healthy() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.GetServiceStatusResponse.healthy)
  return _internal_healthy();
}
inline void GetServiceStatusResponse::_internal_set_healthy(bool value) {
  
  _impl_.healthy_ = value;
}
inline void GetServiceStatusResponse::set_healthy(bool value) {
  _internal_set_healthy(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.GetServiceStatusResponse.healthy)
}

// string status = 2;
inline void GetServiceStatusResponse::clear_status() {
  _impl_.status_.ClearToEmpty();
}
inline const std::string& GetServiceStatusResponse::status() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.GetServiceStatusResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetServiceStatusResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 _impl_.status_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.cdc.GetServiceStatusResponse.status)
}
inline std::string* GetServiceStatusResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.GetServiceStatusResponse.status)
  return _s;
}
inline const std::string& GetServiceStatusResponse::_internal_status() const {
  return _impl_.status_.Get();
}
inline void GetServiceStatusResponse::_internal_set_status(const std::string& value) {
  
  _impl_.status_.Set(value, GetArenaForAllocation());
}
inline std::string* GetServiceStatusResponse::_internal_mutable_status() {
  
  return _impl_.status_.Mutable(GetArenaForAllocation());
}
inline std::string* GetServiceStatusResponse::release_status() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.GetServiceStatusResponse.status)
  return _impl_.status_.Release();
}
inline void GetServiceStatusResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  _impl_.status_.SetAllocated(status, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.GetServiceStatusResponse.status)
}

// .google.protobuf.Timestamp timestamp = 3;
inline bool GetServiceStatusResponse::_internal_has_timestamp() const {
  return this != internal_default_instance() && _impl_.timestamp_ != nullptr;
}
inline bool GetServiceStatusResponse::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& GetServiceStatusResponse::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& GetServiceStatusResponse::timestamp() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.GetServiceStatusResponse.timestamp)
  return _internal_timestamp();
}
inline void GetServiceStatusResponse::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.GetServiceStatusResponse.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetServiceStatusResponse::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetServiceStatusResponse::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.GetServiceStatusResponse.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetServiceStatusResponse::_internal_mutable_timestamp() {
  
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetServiceStatusResponse::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.GetServiceStatusResponse.timestamp)
  return _msg;
}
inline void GetServiceStatusResponse::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.GetServiceStatusResponse.timestamp)
}

// .unhinged.cdc.ServiceMetrics metrics = 4;
inline bool GetServiceStatusResponse::_internal_has_metrics() const {
  return this != internal_default_instance() && _impl_.metrics_ != nullptr;
}
inline bool GetServiceStatusResponse::has_metrics() const {
  return _internal_has_metrics();
}
inline void GetServiceStatusResponse::clear_metrics() {
  if (GetArenaForAllocation() == nullptr && _impl_.metrics_ != nullptr) {
    delete _impl_.metrics_;
  }
  _impl_.metrics_ = nullptr;
}
inline const ::unhinged::cdc::ServiceMetrics& GetServiceStatusResponse::_internal_metrics() const {
  const ::unhinged::cdc::ServiceMetrics* p = _impl_.metrics_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::cdc::ServiceMetrics&>(
      ::unhinged::cdc::_ServiceMetrics_default_instance_);
}
inline const ::unhinged::cdc::ServiceMetrics& GetServiceStatusResponse::metrics() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.GetServiceStatusResponse.metrics)
  return _internal_metrics();
}
inline void GetServiceStatusResponse::unsafe_arena_set_allocated_metrics(
    ::unhinged::cdc::ServiceMetrics* metrics) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metrics_);
  }
  _impl_.metrics_ = metrics;
  if (metrics) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.cdc.GetServiceStatusResponse.metrics)
}
inline ::unhinged::cdc::ServiceMetrics* GetServiceStatusResponse::release_metrics() {
  
  ::unhinged::cdc::ServiceMetrics* temp = _impl_.metrics_;
  _impl_.metrics_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::cdc::ServiceMetrics* GetServiceStatusResponse::unsafe_arena_release_metrics() {
  // @@protoc_insertion_point(field_release:unhinged.cdc.GetServiceStatusResponse.metrics)
  
  ::unhinged::cdc::ServiceMetrics* temp = _impl_.metrics_;
  _impl_.metrics_ = nullptr;
  return temp;
}
inline ::unhinged::cdc::ServiceMetrics* GetServiceStatusResponse::_internal_mutable_metrics() {
  
  if (_impl_.metrics_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::cdc::ServiceMetrics>(GetArenaForAllocation());
    _impl_.metrics_ = p;
  }
  return _impl_.metrics_;
}
inline ::unhinged::cdc::ServiceMetrics* GetServiceStatusResponse::mutable_metrics() {
  ::unhinged::cdc::ServiceMetrics* _msg = _internal_mutable_metrics();
  // @@protoc_insertion_point(field_mutable:unhinged.cdc.GetServiceStatusResponse.metrics)
  return _msg;
}
inline void GetServiceStatusResponse::set_allocated_metrics(::unhinged::cdc::ServiceMetrics* metrics) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.metrics_;
  }
  if (metrics) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(metrics);
    if (message_arena != submessage_arena) {
      metrics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metrics, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.metrics_ = metrics;
  // @@protoc_insertion_point(field_set_allocated:unhinged.cdc.GetServiceStatusResponse.metrics)
}

// -------------------------------------------------------------------

// ServiceMetrics

// int64 total_events_published = 1;
inline void ServiceMetrics::clear_total_events_published() {
  _impl_.total_events_published_ = int64_t{0};
}
inline int64_t ServiceMetrics::_internal_total_events_published() const {
  return _impl_.total_events_published_;
}
inline int64_t ServiceMetrics::total_events_published() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.ServiceMetrics.total_events_published)
  return _internal_total_events_published();
}
inline void ServiceMetrics::_internal_set_total_events_published(int64_t value) {
  
  _impl_.total_events_published_ = value;
}
inline void ServiceMetrics::set_total_events_published(int64_t value) {
  _internal_set_total_events_published(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.ServiceMetrics.total_events_published)
}

// int64 total_events_delivered = 2;
inline void ServiceMetrics::clear_total_events_delivered() {
  _impl_.total_events_delivered_ = int64_t{0};
}
inline int64_t ServiceMetrics::_internal_total_events_delivered() const {
  return _impl_.total_events_delivered_;
}
inline int64_t ServiceMetrics::total_events_delivered() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.ServiceMetrics.total_events_delivered)
  return _internal_total_events_delivered();
}
inline void ServiceMetrics::_internal_set_total_events_delivered(int64_t value) {
  
  _impl_.total_events_delivered_ = value;
}
inline void ServiceMetrics::set_total_events_delivered(int64_t value) {
  _internal_set_total_events_delivered(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.ServiceMetrics.total_events_delivered)
}

// int64 active_subscriptions = 3;
inline void ServiceMetrics::clear_active_subscriptions() {
  _impl_.active_subscriptions_ = int64_t{0};
}
inline int64_t ServiceMetrics::_internal_active_subscriptions() const {
  return _impl_.active_subscriptions_;
}
inline int64_t ServiceMetrics::active_subscriptions() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.ServiceMetrics.active_subscriptions)
  return _internal_active_subscriptions();
}
inline void ServiceMetrics::_internal_set_active_subscriptions(int64_t value) {
  
  _impl_.active_subscriptions_ = value;
}
inline void ServiceMetrics::set_active_subscriptions(int64_t value) {
  _internal_set_active_subscriptions(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.ServiceMetrics.active_subscriptions)
}

// int64 events_in_dlq = 4;
inline void ServiceMetrics::clear_events_in_dlq() {
  _impl_.events_in_dlq_ = int64_t{0};
}
inline int64_t ServiceMetrics::_internal_events_in_dlq() const {
  return _impl_.events_in_dlq_;
}
inline int64_t ServiceMetrics::events_in_dlq() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.ServiceMetrics.events_in_dlq)
  return _internal_events_in_dlq();
}
inline void ServiceMetrics::_internal_set_events_in_dlq(int64_t value) {
  
  _impl_.events_in_dlq_ = value;
}
inline void ServiceMetrics::set_events_in_dlq(int64_t value) {
  _internal_set_events_in_dlq(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.ServiceMetrics.events_in_dlq)
}

// double avg_publish_latency_ms = 5;
inline void ServiceMetrics::clear_avg_publish_latency_ms() {
  _impl_.avg_publish_latency_ms_ = 0;
}
inline double ServiceMetrics::_internal_avg_publish_latency_ms() const {
  return _impl_.avg_publish_latency_ms_;
}
inline double ServiceMetrics::avg_publish_latency_ms() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.ServiceMetrics.avg_publish_latency_ms)
  return _internal_avg_publish_latency_ms();
}
inline void ServiceMetrics::_internal_set_avg_publish_latency_ms(double value) {
  
  _impl_.avg_publish_latency_ms_ = value;
}
inline void ServiceMetrics::set_avg_publish_latency_ms(double value) {
  _internal_set_avg_publish_latency_ms(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.ServiceMetrics.avg_publish_latency_ms)
}

// double avg_delivery_latency_ms = 6;
inline void ServiceMetrics::clear_avg_delivery_latency_ms() {
  _impl_.avg_delivery_latency_ms_ = 0;
}
inline double ServiceMetrics::_internal_avg_delivery_latency_ms() const {
  return _impl_.avg_delivery_latency_ms_;
}
inline double ServiceMetrics::avg_delivery_latency_ms() const {
  // @@protoc_insertion_point(field_get:unhinged.cdc.ServiceMetrics.avg_delivery_latency_ms)
  return _internal_avg_delivery_latency_ms();
}
inline void ServiceMetrics::_internal_set_avg_delivery_latency_ms(double value) {
  
  _impl_.avg_delivery_latency_ms_ = value;
}
inline void ServiceMetrics::set_avg_delivery_latency_ms(double value) {
  _internal_set_avg_delivery_latency_ms(value);
  // @@protoc_insertion_point(field_set:unhinged.cdc.ServiceMetrics.avg_delivery_latency_ms)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace cdc
}  // namespace unhinged

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_cdc_5fservice_2eproto
