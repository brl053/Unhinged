// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: document_store.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_document_5fstore_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_document_5fstore_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
#include <google/protobuf/struct.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_document_5fstore_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_document_5fstore_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_document_5fstore_2eproto;
namespace unhinged {
namespace document_store {
class ActiveTag;
struct ActiveTagDefaultTypeInternal;
extern ActiveTagDefaultTypeInternal _ActiveTag_default_instance_;
class DeleteDocumentRequest;
struct DeleteDocumentRequestDefaultTypeInternal;
extern DeleteDocumentRequestDefaultTypeInternal _DeleteDocumentRequest_default_instance_;
class DeleteDocumentResponse;
struct DeleteDocumentResponseDefaultTypeInternal;
extern DeleteDocumentResponseDefaultTypeInternal _DeleteDocumentResponse_default_instance_;
class Document;
struct DocumentDefaultTypeInternal;
extern DocumentDefaultTypeInternal _Document_default_instance_;
class DocumentStub;
struct DocumentStubDefaultTypeInternal;
extern DocumentStubDefaultTypeInternal _DocumentStub_default_instance_;
class GetDocumentRequest;
struct GetDocumentRequestDefaultTypeInternal;
extern GetDocumentRequestDefaultTypeInternal _GetDocumentRequest_default_instance_;
class GetDocumentResponse;
struct GetDocumentResponseDefaultTypeInternal;
extern GetDocumentResponseDefaultTypeInternal _GetDocumentResponse_default_instance_;
class GetSessionContextRequest;
struct GetSessionContextRequestDefaultTypeInternal;
extern GetSessionContextRequestDefaultTypeInternal _GetSessionContextRequest_default_instance_;
class GetSessionContextResponse;
struct GetSessionContextResponseDefaultTypeInternal;
extern GetSessionContextResponseDefaultTypeInternal _GetSessionContextResponse_default_instance_;
class HealthCheckRequest;
struct HealthCheckRequestDefaultTypeInternal;
extern HealthCheckRequestDefaultTypeInternal _HealthCheckRequest_default_instance_;
class HealthCheckResponse;
struct HealthCheckResponseDefaultTypeInternal;
extern HealthCheckResponseDefaultTypeInternal _HealthCheckResponse_default_instance_;
class ListActiveTagsRequest;
struct ListActiveTagsRequestDefaultTypeInternal;
extern ListActiveTagsRequestDefaultTypeInternal _ListActiveTagsRequest_default_instance_;
class ListActiveTagsResponse;
struct ListActiveTagsResponseDefaultTypeInternal;
extern ListActiveTagsResponseDefaultTypeInternal _ListActiveTagsResponse_default_instance_;
class ListDocumentVersionsRequest;
struct ListDocumentVersionsRequestDefaultTypeInternal;
extern ListDocumentVersionsRequestDefaultTypeInternal _ListDocumentVersionsRequest_default_instance_;
class ListDocumentVersionsResponse;
struct ListDocumentVersionsResponseDefaultTypeInternal;
extern ListDocumentVersionsResponseDefaultTypeInternal _ListDocumentVersionsResponse_default_instance_;
class ListDocumentsRequest;
struct ListDocumentsRequestDefaultTypeInternal;
extern ListDocumentsRequestDefaultTypeInternal _ListDocumentsRequest_default_instance_;
class ListDocumentsResponse;
struct ListDocumentsResponseDefaultTypeInternal;
extern ListDocumentsResponseDefaultTypeInternal _ListDocumentsResponse_default_instance_;
class ListTagEventsRequest;
struct ListTagEventsRequestDefaultTypeInternal;
extern ListTagEventsRequestDefaultTypeInternal _ListTagEventsRequest_default_instance_;
class ListTagEventsResponse;
struct ListTagEventsResponseDefaultTypeInternal;
extern ListTagEventsResponseDefaultTypeInternal _ListTagEventsResponse_default_instance_;
class PutDocumentReceipt;
struct PutDocumentReceiptDefaultTypeInternal;
extern PutDocumentReceiptDefaultTypeInternal _PutDocumentReceipt_default_instance_;
class PutDocumentRequest;
struct PutDocumentRequestDefaultTypeInternal;
extern PutDocumentRequestDefaultTypeInternal _PutDocumentRequest_default_instance_;
class PutDocumentResponse;
struct PutDocumentResponseDefaultTypeInternal;
extern PutDocumentResponseDefaultTypeInternal _PutDocumentResponse_default_instance_;
class PutDocumentsRequest;
struct PutDocumentsRequestDefaultTypeInternal;
extern PutDocumentsRequestDefaultTypeInternal _PutDocumentsRequest_default_instance_;
class PutDocumentsResponse;
struct PutDocumentsResponseDefaultTypeInternal;
extern PutDocumentsResponseDefaultTypeInternal _PutDocumentsResponse_default_instance_;
class TagDocumentRequest;
struct TagDocumentRequestDefaultTypeInternal;
extern TagDocumentRequestDefaultTypeInternal _TagDocumentRequest_default_instance_;
class TagDocumentResponse;
struct TagDocumentResponseDefaultTypeInternal;
extern TagDocumentResponseDefaultTypeInternal _TagDocumentResponse_default_instance_;
class TagEvent;
struct TagEventDefaultTypeInternal;
extern TagEventDefaultTypeInternal _TagEvent_default_instance_;
}  // namespace document_store
}  // namespace unhinged
PROTOBUF_NAMESPACE_OPEN
template<> ::unhinged::document_store::ActiveTag* Arena::CreateMaybeMessage<::unhinged::document_store::ActiveTag>(Arena*);
template<> ::unhinged::document_store::DeleteDocumentRequest* Arena::CreateMaybeMessage<::unhinged::document_store::DeleteDocumentRequest>(Arena*);
template<> ::unhinged::document_store::DeleteDocumentResponse* Arena::CreateMaybeMessage<::unhinged::document_store::DeleteDocumentResponse>(Arena*);
template<> ::unhinged::document_store::Document* Arena::CreateMaybeMessage<::unhinged::document_store::Document>(Arena*);
template<> ::unhinged::document_store::DocumentStub* Arena::CreateMaybeMessage<::unhinged::document_store::DocumentStub>(Arena*);
template<> ::unhinged::document_store::GetDocumentRequest* Arena::CreateMaybeMessage<::unhinged::document_store::GetDocumentRequest>(Arena*);
template<> ::unhinged::document_store::GetDocumentResponse* Arena::CreateMaybeMessage<::unhinged::document_store::GetDocumentResponse>(Arena*);
template<> ::unhinged::document_store::GetSessionContextRequest* Arena::CreateMaybeMessage<::unhinged::document_store::GetSessionContextRequest>(Arena*);
template<> ::unhinged::document_store::GetSessionContextResponse* Arena::CreateMaybeMessage<::unhinged::document_store::GetSessionContextResponse>(Arena*);
template<> ::unhinged::document_store::HealthCheckRequest* Arena::CreateMaybeMessage<::unhinged::document_store::HealthCheckRequest>(Arena*);
template<> ::unhinged::document_store::HealthCheckResponse* Arena::CreateMaybeMessage<::unhinged::document_store::HealthCheckResponse>(Arena*);
template<> ::unhinged::document_store::ListActiveTagsRequest* Arena::CreateMaybeMessage<::unhinged::document_store::ListActiveTagsRequest>(Arena*);
template<> ::unhinged::document_store::ListActiveTagsResponse* Arena::CreateMaybeMessage<::unhinged::document_store::ListActiveTagsResponse>(Arena*);
template<> ::unhinged::document_store::ListDocumentVersionsRequest* Arena::CreateMaybeMessage<::unhinged::document_store::ListDocumentVersionsRequest>(Arena*);
template<> ::unhinged::document_store::ListDocumentVersionsResponse* Arena::CreateMaybeMessage<::unhinged::document_store::ListDocumentVersionsResponse>(Arena*);
template<> ::unhinged::document_store::ListDocumentsRequest* Arena::CreateMaybeMessage<::unhinged::document_store::ListDocumentsRequest>(Arena*);
template<> ::unhinged::document_store::ListDocumentsResponse* Arena::CreateMaybeMessage<::unhinged::document_store::ListDocumentsResponse>(Arena*);
template<> ::unhinged::document_store::ListTagEventsRequest* Arena::CreateMaybeMessage<::unhinged::document_store::ListTagEventsRequest>(Arena*);
template<> ::unhinged::document_store::ListTagEventsResponse* Arena::CreateMaybeMessage<::unhinged::document_store::ListTagEventsResponse>(Arena*);
template<> ::unhinged::document_store::PutDocumentReceipt* Arena::CreateMaybeMessage<::unhinged::document_store::PutDocumentReceipt>(Arena*);
template<> ::unhinged::document_store::PutDocumentRequest* Arena::CreateMaybeMessage<::unhinged::document_store::PutDocumentRequest>(Arena*);
template<> ::unhinged::document_store::PutDocumentResponse* Arena::CreateMaybeMessage<::unhinged::document_store::PutDocumentResponse>(Arena*);
template<> ::unhinged::document_store::PutDocumentsRequest* Arena::CreateMaybeMessage<::unhinged::document_store::PutDocumentsRequest>(Arena*);
template<> ::unhinged::document_store::PutDocumentsResponse* Arena::CreateMaybeMessage<::unhinged::document_store::PutDocumentsResponse>(Arena*);
template<> ::unhinged::document_store::TagDocumentRequest* Arena::CreateMaybeMessage<::unhinged::document_store::TagDocumentRequest>(Arena*);
template<> ::unhinged::document_store::TagDocumentResponse* Arena::CreateMaybeMessage<::unhinged::document_store::TagDocumentResponse>(Arena*);
template<> ::unhinged::document_store::TagEvent* Arena::CreateMaybeMessage<::unhinged::document_store::TagEvent>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace unhinged {
namespace document_store {

// ===================================================================

class Document final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.document_store.Document) */ {
 public:
  inline Document() : Document(nullptr) {}
  ~Document() override;
  explicit PROTOBUF_CONSTEXPR Document(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Document(const Document& from);
  Document(Document&& from) noexcept
    : Document() {
    *this = ::std::move(from);
  }

  inline Document& operator=(const Document& from) {
    CopyFrom(from);
    return *this;
  }
  inline Document& operator=(Document&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Document& default_instance() {
    return *internal_default_instance();
  }
  static inline const Document* internal_default_instance() {
    return reinterpret_cast<const Document*>(
               &_Document_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Document& a, Document& b) {
    a.Swap(&b);
  }
  inline void Swap(Document* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Document* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Document* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Document>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Document& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Document& from) {
    Document::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Document* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.document_store.Document";
  }
  protected:
  explicit Document(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagsFieldNumber = 8,
    kDocumentUuidFieldNumber = 1,
    kTypeFieldNumber = 2,
    kNameFieldNumber = 3,
    kNamespaceFieldNumber = 4,
    kBodyJsonFieldNumber = 6,
    kCreatedByFieldNumber = 10,
    kCreatedByTypeFieldNumber = 11,
    kSessionIdFieldNumber = 12,
    kMetadataFieldNumber = 7,
    kCreatedAtFieldNumber = 9,
    kVersionFieldNumber = 5,
  };
  // repeated string tags = 8;
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  const std::string& tags(int index) const;
  std::string* mutable_tags(int index);
  void set_tags(int index, const std::string& value);
  void set_tags(int index, std::string&& value);
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, size_t size);
  std::string* add_tags();
  void add_tags(const std::string& value);
  void add_tags(std::string&& value);
  void add_tags(const char* value);
  void add_tags(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tags();
  private:
  const std::string& _internal_tags(int index) const;
  std::string* _internal_add_tags();
  public:

  // string document_uuid = 1;
  void clear_document_uuid();
  const std::string& document_uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_document_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_document_uuid();
  PROTOBUF_NODISCARD std::string* release_document_uuid();
  void set_allocated_document_uuid(std::string* document_uuid);
  private:
  const std::string& _internal_document_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_document_uuid(const std::string& value);
  std::string* _internal_mutable_document_uuid();
  public:

  // string type = 2;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // string name = 3;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string namespace = 4;
  void clear_namespace_();
  const std::string& namespace_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_namespace_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_namespace_();
  PROTOBUF_NODISCARD std::string* release_namespace_();
  void set_allocated_namespace_(std::string* namespace_);
  private:
  const std::string& _internal_namespace_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_namespace_(const std::string& value);
  std::string* _internal_mutable_namespace_();
  public:

  // string body_json = 6;
  void clear_body_json();
  const std::string& body_json() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_body_json(ArgT0&& arg0, ArgT... args);
  std::string* mutable_body_json();
  PROTOBUF_NODISCARD std::string* release_body_json();
  void set_allocated_body_json(std::string* body_json);
  private:
  const std::string& _internal_body_json() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_body_json(const std::string& value);
  std::string* _internal_mutable_body_json();
  public:

  // string created_by = 10;
  void clear_created_by();
  const std::string& created_by() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_created_by(ArgT0&& arg0, ArgT... args);
  std::string* mutable_created_by();
  PROTOBUF_NODISCARD std::string* release_created_by();
  void set_allocated_created_by(std::string* created_by);
  private:
  const std::string& _internal_created_by() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_created_by(const std::string& value);
  std::string* _internal_mutable_created_by();
  public:

  // string created_by_type = 11;
  void clear_created_by_type();
  const std::string& created_by_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_created_by_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_created_by_type();
  PROTOBUF_NODISCARD std::string* release_created_by_type();
  void set_allocated_created_by_type(std::string* created_by_type);
  private:
  const std::string& _internal_created_by_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_created_by_type(const std::string& value);
  std::string* _internal_mutable_created_by_type();
  public:

  // string session_id = 12;
  void clear_session_id();
  const std::string& session_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // .google.protobuf.Struct metadata = 7;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::PROTOBUF_NAMESPACE_ID::Struct& metadata() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_metadata();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_metadata();
  void set_allocated_metadata(::PROTOBUF_NAMESPACE_ID::Struct* metadata);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::PROTOBUF_NAMESPACE_ID::Struct* metadata);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_metadata();

  // .google.protobuf.Timestamp created_at = 9;
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_at();
  void set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_at();

  // int32 version = 5;
  void clear_version();
  int32_t version() const;
  void set_version(int32_t value);
  private:
  int32_t _internal_version() const;
  void _internal_set_version(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.document_store.Document)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tags_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr document_uuid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr namespace__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr body_json_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr created_by_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr created_by_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
    ::PROTOBUF_NAMESPACE_ID::Struct* metadata_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at_;
    int32_t version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_document_5fstore_2eproto;
};
// -------------------------------------------------------------------

class DocumentStub final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.document_store.DocumentStub) */ {
 public:
  inline DocumentStub() : DocumentStub(nullptr) {}
  ~DocumentStub() override;
  explicit PROTOBUF_CONSTEXPR DocumentStub(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DocumentStub(const DocumentStub& from);
  DocumentStub(DocumentStub&& from) noexcept
    : DocumentStub() {
    *this = ::std::move(from);
  }

  inline DocumentStub& operator=(const DocumentStub& from) {
    CopyFrom(from);
    return *this;
  }
  inline DocumentStub& operator=(DocumentStub&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DocumentStub& default_instance() {
    return *internal_default_instance();
  }
  static inline const DocumentStub* internal_default_instance() {
    return reinterpret_cast<const DocumentStub*>(
               &_DocumentStub_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DocumentStub& a, DocumentStub& b) {
    a.Swap(&b);
  }
  inline void Swap(DocumentStub* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DocumentStub* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DocumentStub* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DocumentStub>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DocumentStub& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DocumentStub& from) {
    DocumentStub::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DocumentStub* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.document_store.DocumentStub";
  }
  protected:
  explicit DocumentStub(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagsFieldNumber = 7,
    kDocumentUuidFieldNumber = 1,
    kTypeFieldNumber = 2,
    kNameFieldNumber = 3,
    kNamespaceFieldNumber = 4,
    kCreatedByFieldNumber = 9,
    kCreatedByTypeFieldNumber = 10,
    kSessionIdFieldNumber = 11,
    kMetadataFieldNumber = 6,
    kCreatedAtFieldNumber = 8,
    kVersionFieldNumber = 5,
  };
  // repeated string tags = 7;
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  const std::string& tags(int index) const;
  std::string* mutable_tags(int index);
  void set_tags(int index, const std::string& value);
  void set_tags(int index, std::string&& value);
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, size_t size);
  std::string* add_tags();
  void add_tags(const std::string& value);
  void add_tags(std::string&& value);
  void add_tags(const char* value);
  void add_tags(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tags();
  private:
  const std::string& _internal_tags(int index) const;
  std::string* _internal_add_tags();
  public:

  // string document_uuid = 1;
  void clear_document_uuid();
  const std::string& document_uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_document_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_document_uuid();
  PROTOBUF_NODISCARD std::string* release_document_uuid();
  void set_allocated_document_uuid(std::string* document_uuid);
  private:
  const std::string& _internal_document_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_document_uuid(const std::string& value);
  std::string* _internal_mutable_document_uuid();
  public:

  // string type = 2;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // string name = 3;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string namespace = 4;
  void clear_namespace_();
  const std::string& namespace_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_namespace_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_namespace_();
  PROTOBUF_NODISCARD std::string* release_namespace_();
  void set_allocated_namespace_(std::string* namespace_);
  private:
  const std::string& _internal_namespace_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_namespace_(const std::string& value);
  std::string* _internal_mutable_namespace_();
  public:

  // string created_by = 9;
  void clear_created_by();
  const std::string& created_by() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_created_by(ArgT0&& arg0, ArgT... args);
  std::string* mutable_created_by();
  PROTOBUF_NODISCARD std::string* release_created_by();
  void set_allocated_created_by(std::string* created_by);
  private:
  const std::string& _internal_created_by() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_created_by(const std::string& value);
  std::string* _internal_mutable_created_by();
  public:

  // string created_by_type = 10;
  void clear_created_by_type();
  const std::string& created_by_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_created_by_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_created_by_type();
  PROTOBUF_NODISCARD std::string* release_created_by_type();
  void set_allocated_created_by_type(std::string* created_by_type);
  private:
  const std::string& _internal_created_by_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_created_by_type(const std::string& value);
  std::string* _internal_mutable_created_by_type();
  public:

  // string session_id = 11;
  void clear_session_id();
  const std::string& session_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // .google.protobuf.Struct metadata = 6;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::PROTOBUF_NAMESPACE_ID::Struct& metadata() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_metadata();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_metadata();
  void set_allocated_metadata(::PROTOBUF_NAMESPACE_ID::Struct* metadata);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::PROTOBUF_NAMESPACE_ID::Struct* metadata);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_metadata();

  // .google.protobuf.Timestamp created_at = 8;
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_at();
  void set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_at();

  // int32 version = 5;
  void clear_version();
  int32_t version() const;
  void set_version(int32_t value);
  private:
  int32_t _internal_version() const;
  void _internal_set_version(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.document_store.DocumentStub)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tags_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr document_uuid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr namespace__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr created_by_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr created_by_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
    ::PROTOBUF_NAMESPACE_ID::Struct* metadata_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at_;
    int32_t version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_document_5fstore_2eproto;
};
// -------------------------------------------------------------------

class ActiveTag final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.document_store.ActiveTag) */ {
 public:
  inline ActiveTag() : ActiveTag(nullptr) {}
  ~ActiveTag() override;
  explicit PROTOBUF_CONSTEXPR ActiveTag(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActiveTag(const ActiveTag& from);
  ActiveTag(ActiveTag&& from) noexcept
    : ActiveTag() {
    *this = ::std::move(from);
  }

  inline ActiveTag& operator=(const ActiveTag& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActiveTag& operator=(ActiveTag&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActiveTag& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActiveTag* internal_default_instance() {
    return reinterpret_cast<const ActiveTag*>(
               &_ActiveTag_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ActiveTag& a, ActiveTag& b) {
    a.Swap(&b);
  }
  inline void Swap(ActiveTag* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActiveTag* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActiveTag* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActiveTag>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActiveTag& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ActiveTag& from) {
    ActiveTag::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActiveTag* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.document_store.ActiveTag";
  }
  protected:
  explicit ActiveTag(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDocumentUuidFieldNumber = 1,
    kTagFieldNumber = 3,
    kUpdatedByFieldNumber = 5,
    kUpdatedByTypeFieldNumber = 6,
    kSessionIdFieldNumber = 7,
    kUpdatedAtFieldNumber = 4,
    kDocumentVersionFieldNumber = 2,
  };
  // string document_uuid = 1;
  void clear_document_uuid();
  const std::string& document_uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_document_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_document_uuid();
  PROTOBUF_NODISCARD std::string* release_document_uuid();
  void set_allocated_document_uuid(std::string* document_uuid);
  private:
  const std::string& _internal_document_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_document_uuid(const std::string& value);
  std::string* _internal_mutable_document_uuid();
  public:

  // string tag = 3;
  void clear_tag();
  const std::string& tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tag();
  PROTOBUF_NODISCARD std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  private:
  const std::string& _internal_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  // string updated_by = 5;
  void clear_updated_by();
  const std::string& updated_by() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_updated_by(ArgT0&& arg0, ArgT... args);
  std::string* mutable_updated_by();
  PROTOBUF_NODISCARD std::string* release_updated_by();
  void set_allocated_updated_by(std::string* updated_by);
  private:
  const std::string& _internal_updated_by() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_updated_by(const std::string& value);
  std::string* _internal_mutable_updated_by();
  public:

  // string updated_by_type = 6;
  void clear_updated_by_type();
  const std::string& updated_by_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_updated_by_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_updated_by_type();
  PROTOBUF_NODISCARD std::string* release_updated_by_type();
  void set_allocated_updated_by_type(std::string* updated_by_type);
  private:
  const std::string& _internal_updated_by_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_updated_by_type(const std::string& value);
  std::string* _internal_mutable_updated_by_type();
  public:

  // string session_id = 7;
  void clear_session_id();
  const std::string& session_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // .google.protobuf.Timestamp updated_at = 4;
  bool has_updated_at() const;
  private:
  bool _internal_has_updated_at() const;
  public:
  void clear_updated_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& updated_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_updated_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_updated_at();
  void set_allocated_updated_at(::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_updated_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_updated_at();
  public:
  void unsafe_arena_set_allocated_updated_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_updated_at();

  // int32 document_version = 2;
  void clear_document_version();
  int32_t document_version() const;
  void set_document_version(int32_t value);
  private:
  int32_t _internal_document_version() const;
  void _internal_set_document_version(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.document_store.ActiveTag)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr document_uuid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr updated_by_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr updated_by_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at_;
    int32_t document_version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_document_5fstore_2eproto;
};
// -------------------------------------------------------------------

class TagEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.document_store.TagEvent) */ {
 public:
  inline TagEvent() : TagEvent(nullptr) {}
  ~TagEvent() override;
  explicit PROTOBUF_CONSTEXPR TagEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TagEvent(const TagEvent& from);
  TagEvent(TagEvent&& from) noexcept
    : TagEvent() {
    *this = ::std::move(from);
  }

  inline TagEvent& operator=(const TagEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagEvent& operator=(TagEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TagEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const TagEvent* internal_default_instance() {
    return reinterpret_cast<const TagEvent*>(
               &_TagEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(TagEvent& a, TagEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(TagEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TagEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TagEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TagEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TagEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TagEvent& from) {
    TagEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TagEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.document_store.TagEvent";
  }
  protected:
  explicit TagEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagEventUuidFieldNumber = 1,
    kDocumentUuidFieldNumber = 2,
    kTagFieldNumber = 4,
    kOperationFieldNumber = 5,
    kCreatedByFieldNumber = 7,
    kCreatedByTypeFieldNumber = 8,
    kSessionIdFieldNumber = 9,
    kCreatedAtFieldNumber = 6,
    kDocumentVersionFieldNumber = 3,
  };
  // string tag_event_uuid = 1;
  void clear_tag_event_uuid();
  const std::string& tag_event_uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tag_event_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tag_event_uuid();
  PROTOBUF_NODISCARD std::string* release_tag_event_uuid();
  void set_allocated_tag_event_uuid(std::string* tag_event_uuid);
  private:
  const std::string& _internal_tag_event_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tag_event_uuid(const std::string& value);
  std::string* _internal_mutable_tag_event_uuid();
  public:

  // string document_uuid = 2;
  void clear_document_uuid();
  const std::string& document_uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_document_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_document_uuid();
  PROTOBUF_NODISCARD std::string* release_document_uuid();
  void set_allocated_document_uuid(std::string* document_uuid);
  private:
  const std::string& _internal_document_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_document_uuid(const std::string& value);
  std::string* _internal_mutable_document_uuid();
  public:

  // string tag = 4;
  void clear_tag();
  const std::string& tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tag();
  PROTOBUF_NODISCARD std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  private:
  const std::string& _internal_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  // string operation = 5;
  void clear_operation();
  const std::string& operation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_operation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_operation();
  PROTOBUF_NODISCARD std::string* release_operation();
  void set_allocated_operation(std::string* operation);
  private:
  const std::string& _internal_operation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operation(const std::string& value);
  std::string* _internal_mutable_operation();
  public:

  // string created_by = 7;
  void clear_created_by();
  const std::string& created_by() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_created_by(ArgT0&& arg0, ArgT... args);
  std::string* mutable_created_by();
  PROTOBUF_NODISCARD std::string* release_created_by();
  void set_allocated_created_by(std::string* created_by);
  private:
  const std::string& _internal_created_by() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_created_by(const std::string& value);
  std::string* _internal_mutable_created_by();
  public:

  // string created_by_type = 8;
  void clear_created_by_type();
  const std::string& created_by_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_created_by_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_created_by_type();
  PROTOBUF_NODISCARD std::string* release_created_by_type();
  void set_allocated_created_by_type(std::string* created_by_type);
  private:
  const std::string& _internal_created_by_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_created_by_type(const std::string& value);
  std::string* _internal_mutable_created_by_type();
  public:

  // string session_id = 9;
  void clear_session_id();
  const std::string& session_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // .google.protobuf.Timestamp created_at = 6;
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_at();
  void set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_at();

  // int32 document_version = 3;
  void clear_document_version();
  int32_t document_version() const;
  void set_document_version(int32_t value);
  private:
  int32_t _internal_document_version() const;
  void _internal_set_document_version(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.document_store.TagEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_event_uuid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr document_uuid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr operation_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr created_by_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr created_by_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at_;
    int32_t document_version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_document_5fstore_2eproto;
};
// -------------------------------------------------------------------

class PutDocumentRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.document_store.PutDocumentRequest) */ {
 public:
  inline PutDocumentRequest() : PutDocumentRequest(nullptr) {}
  ~PutDocumentRequest() override;
  explicit PROTOBUF_CONSTEXPR PutDocumentRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PutDocumentRequest(const PutDocumentRequest& from);
  PutDocumentRequest(PutDocumentRequest&& from) noexcept
    : PutDocumentRequest() {
    *this = ::std::move(from);
  }

  inline PutDocumentRequest& operator=(const PutDocumentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PutDocumentRequest& operator=(PutDocumentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PutDocumentRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PutDocumentRequest* internal_default_instance() {
    return reinterpret_cast<const PutDocumentRequest*>(
               &_PutDocumentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(PutDocumentRequest& a, PutDocumentRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PutDocumentRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PutDocumentRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PutDocumentRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PutDocumentRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PutDocumentRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PutDocumentRequest& from) {
    PutDocumentRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PutDocumentRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.document_store.PutDocumentRequest";
  }
  protected:
  explicit PutDocumentRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDocumentFieldNumber = 1,
  };
  // .unhinged.document_store.Document document = 1;
  bool has_document() const;
  private:
  bool _internal_has_document() const;
  public:
  void clear_document();
  const ::unhinged::document_store::Document& document() const;
  PROTOBUF_NODISCARD ::unhinged::document_store::Document* release_document();
  ::unhinged::document_store::Document* mutable_document();
  void set_allocated_document(::unhinged::document_store::Document* document);
  private:
  const ::unhinged::document_store::Document& _internal_document() const;
  ::unhinged::document_store::Document* _internal_mutable_document();
  public:
  void unsafe_arena_set_allocated_document(
      ::unhinged::document_store::Document* document);
  ::unhinged::document_store::Document* unsafe_arena_release_document();

  // @@protoc_insertion_point(class_scope:unhinged.document_store.PutDocumentRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::unhinged::document_store::Document* document_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_document_5fstore_2eproto;
};
// -------------------------------------------------------------------

class PutDocumentResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.document_store.PutDocumentResponse) */ {
 public:
  inline PutDocumentResponse() : PutDocumentResponse(nullptr) {}
  ~PutDocumentResponse() override;
  explicit PROTOBUF_CONSTEXPR PutDocumentResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PutDocumentResponse(const PutDocumentResponse& from);
  PutDocumentResponse(PutDocumentResponse&& from) noexcept
    : PutDocumentResponse() {
    *this = ::std::move(from);
  }

  inline PutDocumentResponse& operator=(const PutDocumentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PutDocumentResponse& operator=(PutDocumentResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PutDocumentResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PutDocumentResponse* internal_default_instance() {
    return reinterpret_cast<const PutDocumentResponse*>(
               &_PutDocumentResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PutDocumentResponse& a, PutDocumentResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PutDocumentResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PutDocumentResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PutDocumentResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PutDocumentResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PutDocumentResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PutDocumentResponse& from) {
    PutDocumentResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PutDocumentResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.document_store.PutDocumentResponse";
  }
  protected:
  explicit PutDocumentResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kDocumentUuidFieldNumber = 3,
    kSuccessFieldNumber = 1,
    kVersionFieldNumber = 4,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // string document_uuid = 3;
  void clear_document_uuid();
  const std::string& document_uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_document_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_document_uuid();
  PROTOBUF_NODISCARD std::string* release_document_uuid();
  void set_allocated_document_uuid(std::string* document_uuid);
  private:
  const std::string& _internal_document_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_document_uuid(const std::string& value);
  std::string* _internal_mutable_document_uuid();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // int32 version = 4;
  void clear_version();
  int32_t version() const;
  void set_version(int32_t value);
  private:
  int32_t _internal_version() const;
  void _internal_set_version(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.document_store.PutDocumentResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr document_uuid_;
    bool success_;
    int32_t version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_document_5fstore_2eproto;
};
// -------------------------------------------------------------------

class PutDocumentsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.document_store.PutDocumentsRequest) */ {
 public:
  inline PutDocumentsRequest() : PutDocumentsRequest(nullptr) {}
  ~PutDocumentsRequest() override;
  explicit PROTOBUF_CONSTEXPR PutDocumentsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PutDocumentsRequest(const PutDocumentsRequest& from);
  PutDocumentsRequest(PutDocumentsRequest&& from) noexcept
    : PutDocumentsRequest() {
    *this = ::std::move(from);
  }

  inline PutDocumentsRequest& operator=(const PutDocumentsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PutDocumentsRequest& operator=(PutDocumentsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PutDocumentsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PutDocumentsRequest* internal_default_instance() {
    return reinterpret_cast<const PutDocumentsRequest*>(
               &_PutDocumentsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(PutDocumentsRequest& a, PutDocumentsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PutDocumentsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PutDocumentsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PutDocumentsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PutDocumentsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PutDocumentsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PutDocumentsRequest& from) {
    PutDocumentsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PutDocumentsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.document_store.PutDocumentsRequest";
  }
  protected:
  explicit PutDocumentsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDocumentsFieldNumber = 1,
  };
  // repeated .unhinged.document_store.Document documents = 1;
  int documents_size() const;
  private:
  int _internal_documents_size() const;
  public:
  void clear_documents();
  ::unhinged::document_store::Document* mutable_documents(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::document_store::Document >*
      mutable_documents();
  private:
  const ::unhinged::document_store::Document& _internal_documents(int index) const;
  ::unhinged::document_store::Document* _internal_add_documents();
  public:
  const ::unhinged::document_store::Document& documents(int index) const;
  ::unhinged::document_store::Document* add_documents();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::document_store::Document >&
      documents() const;

  // @@protoc_insertion_point(class_scope:unhinged.document_store.PutDocumentsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::document_store::Document > documents_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_document_5fstore_2eproto;
};
// -------------------------------------------------------------------

class PutDocumentReceipt final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.document_store.PutDocumentReceipt) */ {
 public:
  inline PutDocumentReceipt() : PutDocumentReceipt(nullptr) {}
  ~PutDocumentReceipt() override;
  explicit PROTOBUF_CONSTEXPR PutDocumentReceipt(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PutDocumentReceipt(const PutDocumentReceipt& from);
  PutDocumentReceipt(PutDocumentReceipt&& from) noexcept
    : PutDocumentReceipt() {
    *this = ::std::move(from);
  }

  inline PutDocumentReceipt& operator=(const PutDocumentReceipt& from) {
    CopyFrom(from);
    return *this;
  }
  inline PutDocumentReceipt& operator=(PutDocumentReceipt&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PutDocumentReceipt& default_instance() {
    return *internal_default_instance();
  }
  static inline const PutDocumentReceipt* internal_default_instance() {
    return reinterpret_cast<const PutDocumentReceipt*>(
               &_PutDocumentReceipt_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(PutDocumentReceipt& a, PutDocumentReceipt& b) {
    a.Swap(&b);
  }
  inline void Swap(PutDocumentReceipt* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PutDocumentReceipt* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PutDocumentReceipt* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PutDocumentReceipt>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PutDocumentReceipt& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PutDocumentReceipt& from) {
    PutDocumentReceipt::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PutDocumentReceipt* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.document_store.PutDocumentReceipt";
  }
  protected:
  explicit PutDocumentReceipt(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDocumentUuidFieldNumber = 1,
    kErrorMessageFieldNumber = 4,
    kVersionFieldNumber = 2,
    kSuccessFieldNumber = 3,
  };
  // string document_uuid = 1;
  void clear_document_uuid();
  const std::string& document_uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_document_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_document_uuid();
  PROTOBUF_NODISCARD std::string* release_document_uuid();
  void set_allocated_document_uuid(std::string* document_uuid);
  private:
  const std::string& _internal_document_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_document_uuid(const std::string& value);
  std::string* _internal_mutable_document_uuid();
  public:

  // string error_message = 4;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // int32 version = 2;
  void clear_version();
  int32_t version() const;
  void set_version(int32_t value);
  private:
  int32_t _internal_version() const;
  void _internal_set_version(int32_t value);
  public:

  // bool success = 3;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.document_store.PutDocumentReceipt)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr document_uuid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    int32_t version_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_document_5fstore_2eproto;
};
// -------------------------------------------------------------------

class PutDocumentsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.document_store.PutDocumentsResponse) */ {
 public:
  inline PutDocumentsResponse() : PutDocumentsResponse(nullptr) {}
  ~PutDocumentsResponse() override;
  explicit PROTOBUF_CONSTEXPR PutDocumentsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PutDocumentsResponse(const PutDocumentsResponse& from);
  PutDocumentsResponse(PutDocumentsResponse&& from) noexcept
    : PutDocumentsResponse() {
    *this = ::std::move(from);
  }

  inline PutDocumentsResponse& operator=(const PutDocumentsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PutDocumentsResponse& operator=(PutDocumentsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PutDocumentsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PutDocumentsResponse* internal_default_instance() {
    return reinterpret_cast<const PutDocumentsResponse*>(
               &_PutDocumentsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(PutDocumentsResponse& a, PutDocumentsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PutDocumentsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PutDocumentsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PutDocumentsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PutDocumentsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PutDocumentsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PutDocumentsResponse& from) {
    PutDocumentsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PutDocumentsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.document_store.PutDocumentsResponse";
  }
  protected:
  explicit PutDocumentsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReceiptsFieldNumber = 3,
    kMessageFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // repeated .unhinged.document_store.PutDocumentReceipt receipts = 3;
  int receipts_size() const;
  private:
  int _internal_receipts_size() const;
  public:
  void clear_receipts();
  ::unhinged::document_store::PutDocumentReceipt* mutable_receipts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::document_store::PutDocumentReceipt >*
      mutable_receipts();
  private:
  const ::unhinged::document_store::PutDocumentReceipt& _internal_receipts(int index) const;
  ::unhinged::document_store::PutDocumentReceipt* _internal_add_receipts();
  public:
  const ::unhinged::document_store::PutDocumentReceipt& receipts(int index) const;
  ::unhinged::document_store::PutDocumentReceipt* add_receipts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::document_store::PutDocumentReceipt >&
      receipts() const;

  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.document_store.PutDocumentsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::document_store::PutDocumentReceipt > receipts_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_document_5fstore_2eproto;
};
// -------------------------------------------------------------------

class GetDocumentRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.document_store.GetDocumentRequest) */ {
 public:
  inline GetDocumentRequest() : GetDocumentRequest(nullptr) {}
  ~GetDocumentRequest() override;
  explicit PROTOBUF_CONSTEXPR GetDocumentRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetDocumentRequest(const GetDocumentRequest& from);
  GetDocumentRequest(GetDocumentRequest&& from) noexcept
    : GetDocumentRequest() {
    *this = ::std::move(from);
  }

  inline GetDocumentRequest& operator=(const GetDocumentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetDocumentRequest& operator=(GetDocumentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetDocumentRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetDocumentRequest* internal_default_instance() {
    return reinterpret_cast<const GetDocumentRequest*>(
               &_GetDocumentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(GetDocumentRequest& a, GetDocumentRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetDocumentRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetDocumentRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetDocumentRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetDocumentRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetDocumentRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetDocumentRequest& from) {
    GetDocumentRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetDocumentRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.document_store.GetDocumentRequest";
  }
  protected:
  explicit GetDocumentRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDocumentUuidFieldNumber = 1,
    kTagFieldNumber = 3,
    kVersionFieldNumber = 2,
    kIncludeBodyFieldNumber = 4,
  };
  // string document_uuid = 1;
  void clear_document_uuid();
  const std::string& document_uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_document_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_document_uuid();
  PROTOBUF_NODISCARD std::string* release_document_uuid();
  void set_allocated_document_uuid(std::string* document_uuid);
  private:
  const std::string& _internal_document_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_document_uuid(const std::string& value);
  std::string* _internal_mutable_document_uuid();
  public:

  // optional string tag = 3;
  bool has_tag() const;
  private:
  bool _internal_has_tag() const;
  public:
  void clear_tag();
  const std::string& tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tag();
  PROTOBUF_NODISCARD std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  private:
  const std::string& _internal_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  // optional int32 version = 2;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  int32_t version() const;
  void set_version(int32_t value);
  private:
  int32_t _internal_version() const;
  void _internal_set_version(int32_t value);
  public:

  // bool include_body = 4;
  void clear_include_body();
  bool include_body() const;
  void set_include_body(bool value);
  private:
  bool _internal_include_body() const;
  void _internal_set_include_body(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.document_store.GetDocumentRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr document_uuid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
    int32_t version_;
    bool include_body_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_document_5fstore_2eproto;
};
// -------------------------------------------------------------------

class GetDocumentResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.document_store.GetDocumentResponse) */ {
 public:
  inline GetDocumentResponse() : GetDocumentResponse(nullptr) {}
  ~GetDocumentResponse() override;
  explicit PROTOBUF_CONSTEXPR GetDocumentResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetDocumentResponse(const GetDocumentResponse& from);
  GetDocumentResponse(GetDocumentResponse&& from) noexcept
    : GetDocumentResponse() {
    *this = ::std::move(from);
  }

  inline GetDocumentResponse& operator=(const GetDocumentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetDocumentResponse& operator=(GetDocumentResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetDocumentResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetDocumentResponse* internal_default_instance() {
    return reinterpret_cast<const GetDocumentResponse*>(
               &_GetDocumentResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(GetDocumentResponse& a, GetDocumentResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetDocumentResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetDocumentResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetDocumentResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetDocumentResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetDocumentResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetDocumentResponse& from) {
    GetDocumentResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetDocumentResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.document_store.GetDocumentResponse";
  }
  protected:
  explicit GetDocumentResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kDocumentFieldNumber = 3,
    kSuccessFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .unhinged.document_store.Document document = 3;
  bool has_document() const;
  private:
  bool _internal_has_document() const;
  public:
  void clear_document();
  const ::unhinged::document_store::Document& document() const;
  PROTOBUF_NODISCARD ::unhinged::document_store::Document* release_document();
  ::unhinged::document_store::Document* mutable_document();
  void set_allocated_document(::unhinged::document_store::Document* document);
  private:
  const ::unhinged::document_store::Document& _internal_document() const;
  ::unhinged::document_store::Document* _internal_mutable_document();
  public:
  void unsafe_arena_set_allocated_document(
      ::unhinged::document_store::Document* document);
  ::unhinged::document_store::Document* unsafe_arena_release_document();

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.document_store.GetDocumentResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::unhinged::document_store::Document* document_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_document_5fstore_2eproto;
};
// -------------------------------------------------------------------

class ListDocumentsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.document_store.ListDocumentsRequest) */ {
 public:
  inline ListDocumentsRequest() : ListDocumentsRequest(nullptr) {}
  ~ListDocumentsRequest() override;
  explicit PROTOBUF_CONSTEXPR ListDocumentsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListDocumentsRequest(const ListDocumentsRequest& from);
  ListDocumentsRequest(ListDocumentsRequest&& from) noexcept
    : ListDocumentsRequest() {
    *this = ::std::move(from);
  }

  inline ListDocumentsRequest& operator=(const ListDocumentsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListDocumentsRequest& operator=(ListDocumentsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListDocumentsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListDocumentsRequest* internal_default_instance() {
    return reinterpret_cast<const ListDocumentsRequest*>(
               &_ListDocumentsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ListDocumentsRequest& a, ListDocumentsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListDocumentsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListDocumentsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListDocumentsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListDocumentsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListDocumentsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListDocumentsRequest& from) {
    ListDocumentsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListDocumentsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.document_store.ListDocumentsRequest";
  }
  protected:
  explicit ListDocumentsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNamespaceFieldNumber = 1,
    kTypeFieldNumber = 2,
    kTagFieldNumber = 3,
    kSessionIdFieldNumber = 4,
    kPaginationTokenFieldNumber = 5,
    kPageSizeFieldNumber = 6,
    kIncludeBodyFieldNumber = 7,
    kLatestVersionsOnlyFieldNumber = 8,
  };
  // optional string namespace = 1;
  bool has_namespace_() const;
  private:
  bool _internal_has_namespace_() const;
  public:
  void clear_namespace_();
  const std::string& namespace_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_namespace_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_namespace_();
  PROTOBUF_NODISCARD std::string* release_namespace_();
  void set_allocated_namespace_(std::string* namespace_);
  private:
  const std::string& _internal_namespace_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_namespace_(const std::string& value);
  std::string* _internal_mutable_namespace_();
  public:

  // optional string type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // optional string tag = 3;
  bool has_tag() const;
  private:
  bool _internal_has_tag() const;
  public:
  void clear_tag();
  const std::string& tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tag();
  PROTOBUF_NODISCARD std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  private:
  const std::string& _internal_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  // optional string session_id = 4;
  bool has_session_id() const;
  private:
  bool _internal_has_session_id() const;
  public:
  void clear_session_id();
  const std::string& session_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // optional .google.protobuf.Timestamp pagination_token = 5;
  bool has_pagination_token() const;
  private:
  bool _internal_has_pagination_token() const;
  public:
  void clear_pagination_token();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& pagination_token() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_pagination_token();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_pagination_token();
  void set_allocated_pagination_token(::PROTOBUF_NAMESPACE_ID::Timestamp* pagination_token);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_pagination_token() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_pagination_token();
  public:
  void unsafe_arena_set_allocated_pagination_token(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* pagination_token);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_pagination_token();

  // int32 page_size = 6;
  void clear_page_size();
  int32_t page_size() const;
  void set_page_size(int32_t value);
  private:
  int32_t _internal_page_size() const;
  void _internal_set_page_size(int32_t value);
  public:

  // bool include_body = 7;
  void clear_include_body();
  bool include_body() const;
  void set_include_body(bool value);
  private:
  bool _internal_include_body() const;
  void _internal_set_include_body(bool value);
  public:

  // bool latest_versions_only = 8;
  void clear_latest_versions_only();
  bool latest_versions_only() const;
  void set_latest_versions_only(bool value);
  private:
  bool _internal_latest_versions_only() const;
  void _internal_set_latest_versions_only(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.document_store.ListDocumentsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr namespace__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* pagination_token_;
    int32_t page_size_;
    bool include_body_;
    bool latest_versions_only_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_document_5fstore_2eproto;
};
// -------------------------------------------------------------------

class ListDocumentsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.document_store.ListDocumentsResponse) */ {
 public:
  inline ListDocumentsResponse() : ListDocumentsResponse(nullptr) {}
  ~ListDocumentsResponse() override;
  explicit PROTOBUF_CONSTEXPR ListDocumentsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListDocumentsResponse(const ListDocumentsResponse& from);
  ListDocumentsResponse(ListDocumentsResponse&& from) noexcept
    : ListDocumentsResponse() {
    *this = ::std::move(from);
  }

  inline ListDocumentsResponse& operator=(const ListDocumentsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListDocumentsResponse& operator=(ListDocumentsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListDocumentsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListDocumentsResponse* internal_default_instance() {
    return reinterpret_cast<const ListDocumentsResponse*>(
               &_ListDocumentsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ListDocumentsResponse& a, ListDocumentsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListDocumentsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListDocumentsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListDocumentsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListDocumentsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListDocumentsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListDocumentsResponse& from) {
    ListDocumentsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListDocumentsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.document_store.ListDocumentsResponse";
  }
  protected:
  explicit ListDocumentsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDocumentsFieldNumber = 3,
    kMessageFieldNumber = 2,
    kNextPaginationTokenFieldNumber = 4,
    kSuccessFieldNumber = 1,
    kTotalCountFieldNumber = 5,
  };
  // repeated .unhinged.document_store.Document documents = 3;
  int documents_size() const;
  private:
  int _internal_documents_size() const;
  public:
  void clear_documents();
  ::unhinged::document_store::Document* mutable_documents(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::document_store::Document >*
      mutable_documents();
  private:
  const ::unhinged::document_store::Document& _internal_documents(int index) const;
  ::unhinged::document_store::Document* _internal_add_documents();
  public:
  const ::unhinged::document_store::Document& documents(int index) const;
  ::unhinged::document_store::Document* add_documents();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::document_store::Document >&
      documents() const;

  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .google.protobuf.Timestamp next_pagination_token = 4;
  bool has_next_pagination_token() const;
  private:
  bool _internal_has_next_pagination_token() const;
  public:
  void clear_next_pagination_token();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& next_pagination_token() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_next_pagination_token();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_next_pagination_token();
  void set_allocated_next_pagination_token(::PROTOBUF_NAMESPACE_ID::Timestamp* next_pagination_token);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_next_pagination_token() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_next_pagination_token();
  public:
  void unsafe_arena_set_allocated_next_pagination_token(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* next_pagination_token);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_next_pagination_token();

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // int32 total_count = 5;
  void clear_total_count();
  int32_t total_count() const;
  void set_total_count(int32_t value);
  private:
  int32_t _internal_total_count() const;
  void _internal_set_total_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.document_store.ListDocumentsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::document_store::Document > documents_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* next_pagination_token_;
    bool success_;
    int32_t total_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_document_5fstore_2eproto;
};
// -------------------------------------------------------------------

class ListDocumentVersionsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.document_store.ListDocumentVersionsRequest) */ {
 public:
  inline ListDocumentVersionsRequest() : ListDocumentVersionsRequest(nullptr) {}
  ~ListDocumentVersionsRequest() override;
  explicit PROTOBUF_CONSTEXPR ListDocumentVersionsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListDocumentVersionsRequest(const ListDocumentVersionsRequest& from);
  ListDocumentVersionsRequest(ListDocumentVersionsRequest&& from) noexcept
    : ListDocumentVersionsRequest() {
    *this = ::std::move(from);
  }

  inline ListDocumentVersionsRequest& operator=(const ListDocumentVersionsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListDocumentVersionsRequest& operator=(ListDocumentVersionsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListDocumentVersionsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListDocumentVersionsRequest* internal_default_instance() {
    return reinterpret_cast<const ListDocumentVersionsRequest*>(
               &_ListDocumentVersionsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ListDocumentVersionsRequest& a, ListDocumentVersionsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListDocumentVersionsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListDocumentVersionsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListDocumentVersionsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListDocumentVersionsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListDocumentVersionsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListDocumentVersionsRequest& from) {
    ListDocumentVersionsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListDocumentVersionsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.document_store.ListDocumentVersionsRequest";
  }
  protected:
  explicit ListDocumentVersionsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDocumentUuidFieldNumber = 1,
    kPaginationTokenFieldNumber = 2,
    kPageSizeFieldNumber = 3,
    kIncludeBodyFieldNumber = 4,
  };
  // string document_uuid = 1;
  void clear_document_uuid();
  const std::string& document_uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_document_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_document_uuid();
  PROTOBUF_NODISCARD std::string* release_document_uuid();
  void set_allocated_document_uuid(std::string* document_uuid);
  private:
  const std::string& _internal_document_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_document_uuid(const std::string& value);
  std::string* _internal_mutable_document_uuid();
  public:

  // optional .google.protobuf.Timestamp pagination_token = 2;
  bool has_pagination_token() const;
  private:
  bool _internal_has_pagination_token() const;
  public:
  void clear_pagination_token();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& pagination_token() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_pagination_token();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_pagination_token();
  void set_allocated_pagination_token(::PROTOBUF_NAMESPACE_ID::Timestamp* pagination_token);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_pagination_token() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_pagination_token();
  public:
  void unsafe_arena_set_allocated_pagination_token(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* pagination_token);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_pagination_token();

  // int32 page_size = 3;
  void clear_page_size();
  int32_t page_size() const;
  void set_page_size(int32_t value);
  private:
  int32_t _internal_page_size() const;
  void _internal_set_page_size(int32_t value);
  public:

  // bool include_body = 4;
  void clear_include_body();
  bool include_body() const;
  void set_include_body(bool value);
  private:
  bool _internal_include_body() const;
  void _internal_set_include_body(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.document_store.ListDocumentVersionsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr document_uuid_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* pagination_token_;
    int32_t page_size_;
    bool include_body_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_document_5fstore_2eproto;
};
// -------------------------------------------------------------------

class ListDocumentVersionsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.document_store.ListDocumentVersionsResponse) */ {
 public:
  inline ListDocumentVersionsResponse() : ListDocumentVersionsResponse(nullptr) {}
  ~ListDocumentVersionsResponse() override;
  explicit PROTOBUF_CONSTEXPR ListDocumentVersionsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListDocumentVersionsResponse(const ListDocumentVersionsResponse& from);
  ListDocumentVersionsResponse(ListDocumentVersionsResponse&& from) noexcept
    : ListDocumentVersionsResponse() {
    *this = ::std::move(from);
  }

  inline ListDocumentVersionsResponse& operator=(const ListDocumentVersionsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListDocumentVersionsResponse& operator=(ListDocumentVersionsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListDocumentVersionsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListDocumentVersionsResponse* internal_default_instance() {
    return reinterpret_cast<const ListDocumentVersionsResponse*>(
               &_ListDocumentVersionsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ListDocumentVersionsResponse& a, ListDocumentVersionsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListDocumentVersionsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListDocumentVersionsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListDocumentVersionsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListDocumentVersionsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListDocumentVersionsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListDocumentVersionsResponse& from) {
    ListDocumentVersionsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListDocumentVersionsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.document_store.ListDocumentVersionsResponse";
  }
  protected:
  explicit ListDocumentVersionsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDocumentsFieldNumber = 3,
    kMessageFieldNumber = 2,
    kNextPaginationTokenFieldNumber = 4,
    kSuccessFieldNumber = 1,
    kTotalCountFieldNumber = 5,
  };
  // repeated .unhinged.document_store.Document documents = 3;
  int documents_size() const;
  private:
  int _internal_documents_size() const;
  public:
  void clear_documents();
  ::unhinged::document_store::Document* mutable_documents(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::document_store::Document >*
      mutable_documents();
  private:
  const ::unhinged::document_store::Document& _internal_documents(int index) const;
  ::unhinged::document_store::Document* _internal_add_documents();
  public:
  const ::unhinged::document_store::Document& documents(int index) const;
  ::unhinged::document_store::Document* add_documents();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::document_store::Document >&
      documents() const;

  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .google.protobuf.Timestamp next_pagination_token = 4;
  bool has_next_pagination_token() const;
  private:
  bool _internal_has_next_pagination_token() const;
  public:
  void clear_next_pagination_token();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& next_pagination_token() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_next_pagination_token();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_next_pagination_token();
  void set_allocated_next_pagination_token(::PROTOBUF_NAMESPACE_ID::Timestamp* next_pagination_token);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_next_pagination_token() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_next_pagination_token();
  public:
  void unsafe_arena_set_allocated_next_pagination_token(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* next_pagination_token);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_next_pagination_token();

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // int32 total_count = 5;
  void clear_total_count();
  int32_t total_count() const;
  void set_total_count(int32_t value);
  private:
  int32_t _internal_total_count() const;
  void _internal_set_total_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.document_store.ListDocumentVersionsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::document_store::Document > documents_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* next_pagination_token_;
    bool success_;
    int32_t total_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_document_5fstore_2eproto;
};
// -------------------------------------------------------------------

class TagDocumentRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.document_store.TagDocumentRequest) */ {
 public:
  inline TagDocumentRequest() : TagDocumentRequest(nullptr) {}
  ~TagDocumentRequest() override;
  explicit PROTOBUF_CONSTEXPR TagDocumentRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TagDocumentRequest(const TagDocumentRequest& from);
  TagDocumentRequest(TagDocumentRequest&& from) noexcept
    : TagDocumentRequest() {
    *this = ::std::move(from);
  }

  inline TagDocumentRequest& operator=(const TagDocumentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagDocumentRequest& operator=(TagDocumentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TagDocumentRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TagDocumentRequest* internal_default_instance() {
    return reinterpret_cast<const TagDocumentRequest*>(
               &_TagDocumentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(TagDocumentRequest& a, TagDocumentRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TagDocumentRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TagDocumentRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TagDocumentRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TagDocumentRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TagDocumentRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TagDocumentRequest& from) {
    TagDocumentRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TagDocumentRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.document_store.TagDocumentRequest";
  }
  protected:
  explicit TagDocumentRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDocumentUuidFieldNumber = 1,
    kTagFieldNumber = 3,
    kTaggedByFieldNumber = 4,
    kTaggedByTypeFieldNumber = 5,
    kSessionIdFieldNumber = 6,
    kVersionFieldNumber = 2,
  };
  // string document_uuid = 1;
  void clear_document_uuid();
  const std::string& document_uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_document_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_document_uuid();
  PROTOBUF_NODISCARD std::string* release_document_uuid();
  void set_allocated_document_uuid(std::string* document_uuid);
  private:
  const std::string& _internal_document_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_document_uuid(const std::string& value);
  std::string* _internal_mutable_document_uuid();
  public:

  // string tag = 3;
  void clear_tag();
  const std::string& tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tag();
  PROTOBUF_NODISCARD std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  private:
  const std::string& _internal_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  // string tagged_by = 4;
  void clear_tagged_by();
  const std::string& tagged_by() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tagged_by(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tagged_by();
  PROTOBUF_NODISCARD std::string* release_tagged_by();
  void set_allocated_tagged_by(std::string* tagged_by);
  private:
  const std::string& _internal_tagged_by() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tagged_by(const std::string& value);
  std::string* _internal_mutable_tagged_by();
  public:

  // string tagged_by_type = 5;
  void clear_tagged_by_type();
  const std::string& tagged_by_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tagged_by_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tagged_by_type();
  PROTOBUF_NODISCARD std::string* release_tagged_by_type();
  void set_allocated_tagged_by_type(std::string* tagged_by_type);
  private:
  const std::string& _internal_tagged_by_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tagged_by_type(const std::string& value);
  std::string* _internal_mutable_tagged_by_type();
  public:

  // string session_id = 6;
  void clear_session_id();
  const std::string& session_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // int32 version = 2;
  void clear_version();
  int32_t version() const;
  void set_version(int32_t value);
  private:
  int32_t _internal_version() const;
  void _internal_set_version(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.document_store.TagDocumentRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr document_uuid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tagged_by_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tagged_by_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
    int32_t version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_document_5fstore_2eproto;
};
// -------------------------------------------------------------------

class TagDocumentResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.document_store.TagDocumentResponse) */ {
 public:
  inline TagDocumentResponse() : TagDocumentResponse(nullptr) {}
  ~TagDocumentResponse() override;
  explicit PROTOBUF_CONSTEXPR TagDocumentResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TagDocumentResponse(const TagDocumentResponse& from);
  TagDocumentResponse(TagDocumentResponse&& from) noexcept
    : TagDocumentResponse() {
    *this = ::std::move(from);
  }

  inline TagDocumentResponse& operator=(const TagDocumentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagDocumentResponse& operator=(TagDocumentResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TagDocumentResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TagDocumentResponse* internal_default_instance() {
    return reinterpret_cast<const TagDocumentResponse*>(
               &_TagDocumentResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(TagDocumentResponse& a, TagDocumentResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TagDocumentResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TagDocumentResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TagDocumentResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TagDocumentResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TagDocumentResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TagDocumentResponse& from) {
    TagDocumentResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TagDocumentResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.document_store.TagDocumentResponse";
  }
  protected:
  explicit TagDocumentResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.document_store.TagDocumentResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_document_5fstore_2eproto;
};
// -------------------------------------------------------------------

class ListActiveTagsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.document_store.ListActiveTagsRequest) */ {
 public:
  inline ListActiveTagsRequest() : ListActiveTagsRequest(nullptr) {}
  ~ListActiveTagsRequest() override;
  explicit PROTOBUF_CONSTEXPR ListActiveTagsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListActiveTagsRequest(const ListActiveTagsRequest& from);
  ListActiveTagsRequest(ListActiveTagsRequest&& from) noexcept
    : ListActiveTagsRequest() {
    *this = ::std::move(from);
  }

  inline ListActiveTagsRequest& operator=(const ListActiveTagsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListActiveTagsRequest& operator=(ListActiveTagsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListActiveTagsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListActiveTagsRequest* internal_default_instance() {
    return reinterpret_cast<const ListActiveTagsRequest*>(
               &_ListActiveTagsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ListActiveTagsRequest& a, ListActiveTagsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListActiveTagsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListActiveTagsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListActiveTagsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListActiveTagsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListActiveTagsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListActiveTagsRequest& from) {
    ListActiveTagsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListActiveTagsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.document_store.ListActiveTagsRequest";
  }
  protected:
  explicit ListActiveTagsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDocumentUuidFieldNumber = 1,
    kPaginationTokenFieldNumber = 3,
    kDocumentVersionFieldNumber = 2,
    kPageSizeFieldNumber = 4,
  };
  // string document_uuid = 1;
  void clear_document_uuid();
  const std::string& document_uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_document_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_document_uuid();
  PROTOBUF_NODISCARD std::string* release_document_uuid();
  void set_allocated_document_uuid(std::string* document_uuid);
  private:
  const std::string& _internal_document_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_document_uuid(const std::string& value);
  std::string* _internal_mutable_document_uuid();
  public:

  // optional .google.protobuf.Timestamp pagination_token = 3;
  bool has_pagination_token() const;
  private:
  bool _internal_has_pagination_token() const;
  public:
  void clear_pagination_token();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& pagination_token() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_pagination_token();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_pagination_token();
  void set_allocated_pagination_token(::PROTOBUF_NAMESPACE_ID::Timestamp* pagination_token);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_pagination_token() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_pagination_token();
  public:
  void unsafe_arena_set_allocated_pagination_token(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* pagination_token);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_pagination_token();

  // optional int32 document_version = 2;
  bool has_document_version() const;
  private:
  bool _internal_has_document_version() const;
  public:
  void clear_document_version();
  int32_t document_version() const;
  void set_document_version(int32_t value);
  private:
  int32_t _internal_document_version() const;
  void _internal_set_document_version(int32_t value);
  public:

  // int32 page_size = 4;
  void clear_page_size();
  int32_t page_size() const;
  void set_page_size(int32_t value);
  private:
  int32_t _internal_page_size() const;
  void _internal_set_page_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.document_store.ListActiveTagsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr document_uuid_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* pagination_token_;
    int32_t document_version_;
    int32_t page_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_document_5fstore_2eproto;
};
// -------------------------------------------------------------------

class ListActiveTagsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.document_store.ListActiveTagsResponse) */ {
 public:
  inline ListActiveTagsResponse() : ListActiveTagsResponse(nullptr) {}
  ~ListActiveTagsResponse() override;
  explicit PROTOBUF_CONSTEXPR ListActiveTagsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListActiveTagsResponse(const ListActiveTagsResponse& from);
  ListActiveTagsResponse(ListActiveTagsResponse&& from) noexcept
    : ListActiveTagsResponse() {
    *this = ::std::move(from);
  }

  inline ListActiveTagsResponse& operator=(const ListActiveTagsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListActiveTagsResponse& operator=(ListActiveTagsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListActiveTagsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListActiveTagsResponse* internal_default_instance() {
    return reinterpret_cast<const ListActiveTagsResponse*>(
               &_ListActiveTagsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ListActiveTagsResponse& a, ListActiveTagsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListActiveTagsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListActiveTagsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListActiveTagsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListActiveTagsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListActiveTagsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListActiveTagsResponse& from) {
    ListActiveTagsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListActiveTagsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.document_store.ListActiveTagsResponse";
  }
  protected:
  explicit ListActiveTagsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagsFieldNumber = 3,
    kMessageFieldNumber = 2,
    kNextPaginationTokenFieldNumber = 4,
    kSuccessFieldNumber = 1,
    kTotalCountFieldNumber = 5,
  };
  // repeated .unhinged.document_store.ActiveTag tags = 3;
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  ::unhinged::document_store::ActiveTag* mutable_tags(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::document_store::ActiveTag >*
      mutable_tags();
  private:
  const ::unhinged::document_store::ActiveTag& _internal_tags(int index) const;
  ::unhinged::document_store::ActiveTag* _internal_add_tags();
  public:
  const ::unhinged::document_store::ActiveTag& tags(int index) const;
  ::unhinged::document_store::ActiveTag* add_tags();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::document_store::ActiveTag >&
      tags() const;

  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .google.protobuf.Timestamp next_pagination_token = 4;
  bool has_next_pagination_token() const;
  private:
  bool _internal_has_next_pagination_token() const;
  public:
  void clear_next_pagination_token();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& next_pagination_token() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_next_pagination_token();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_next_pagination_token();
  void set_allocated_next_pagination_token(::PROTOBUF_NAMESPACE_ID::Timestamp* next_pagination_token);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_next_pagination_token() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_next_pagination_token();
  public:
  void unsafe_arena_set_allocated_next_pagination_token(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* next_pagination_token);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_next_pagination_token();

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // int32 total_count = 5;
  void clear_total_count();
  int32_t total_count() const;
  void set_total_count(int32_t value);
  private:
  int32_t _internal_total_count() const;
  void _internal_set_total_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.document_store.ListActiveTagsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::document_store::ActiveTag > tags_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* next_pagination_token_;
    bool success_;
    int32_t total_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_document_5fstore_2eproto;
};
// -------------------------------------------------------------------

class ListTagEventsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.document_store.ListTagEventsRequest) */ {
 public:
  inline ListTagEventsRequest() : ListTagEventsRequest(nullptr) {}
  ~ListTagEventsRequest() override;
  explicit PROTOBUF_CONSTEXPR ListTagEventsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListTagEventsRequest(const ListTagEventsRequest& from);
  ListTagEventsRequest(ListTagEventsRequest&& from) noexcept
    : ListTagEventsRequest() {
    *this = ::std::move(from);
  }

  inline ListTagEventsRequest& operator=(const ListTagEventsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListTagEventsRequest& operator=(ListTagEventsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListTagEventsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListTagEventsRequest* internal_default_instance() {
    return reinterpret_cast<const ListTagEventsRequest*>(
               &_ListTagEventsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ListTagEventsRequest& a, ListTagEventsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListTagEventsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListTagEventsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListTagEventsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListTagEventsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListTagEventsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListTagEventsRequest& from) {
    ListTagEventsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListTagEventsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.document_store.ListTagEventsRequest";
  }
  protected:
  explicit ListTagEventsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDocumentUuidFieldNumber = 1,
    kTagFieldNumber = 2,
    kPaginationTokenFieldNumber = 3,
    kPageSizeFieldNumber = 4,
  };
  // string document_uuid = 1;
  void clear_document_uuid();
  const std::string& document_uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_document_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_document_uuid();
  PROTOBUF_NODISCARD std::string* release_document_uuid();
  void set_allocated_document_uuid(std::string* document_uuid);
  private:
  const std::string& _internal_document_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_document_uuid(const std::string& value);
  std::string* _internal_mutable_document_uuid();
  public:

  // string tag = 2;
  void clear_tag();
  const std::string& tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tag();
  PROTOBUF_NODISCARD std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  private:
  const std::string& _internal_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  // optional .google.protobuf.Timestamp pagination_token = 3;
  bool has_pagination_token() const;
  private:
  bool _internal_has_pagination_token() const;
  public:
  void clear_pagination_token();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& pagination_token() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_pagination_token();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_pagination_token();
  void set_allocated_pagination_token(::PROTOBUF_NAMESPACE_ID::Timestamp* pagination_token);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_pagination_token() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_pagination_token();
  public:
  void unsafe_arena_set_allocated_pagination_token(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* pagination_token);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_pagination_token();

  // int32 page_size = 4;
  void clear_page_size();
  int32_t page_size() const;
  void set_page_size(int32_t value);
  private:
  int32_t _internal_page_size() const;
  void _internal_set_page_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.document_store.ListTagEventsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr document_uuid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* pagination_token_;
    int32_t page_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_document_5fstore_2eproto;
};
// -------------------------------------------------------------------

class ListTagEventsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.document_store.ListTagEventsResponse) */ {
 public:
  inline ListTagEventsResponse() : ListTagEventsResponse(nullptr) {}
  ~ListTagEventsResponse() override;
  explicit PROTOBUF_CONSTEXPR ListTagEventsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListTagEventsResponse(const ListTagEventsResponse& from);
  ListTagEventsResponse(ListTagEventsResponse&& from) noexcept
    : ListTagEventsResponse() {
    *this = ::std::move(from);
  }

  inline ListTagEventsResponse& operator=(const ListTagEventsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListTagEventsResponse& operator=(ListTagEventsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListTagEventsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListTagEventsResponse* internal_default_instance() {
    return reinterpret_cast<const ListTagEventsResponse*>(
               &_ListTagEventsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(ListTagEventsResponse& a, ListTagEventsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListTagEventsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListTagEventsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListTagEventsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListTagEventsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListTagEventsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListTagEventsResponse& from) {
    ListTagEventsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListTagEventsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.document_store.ListTagEventsResponse";
  }
  protected:
  explicit ListTagEventsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventsFieldNumber = 3,
    kMessageFieldNumber = 2,
    kNextPaginationTokenFieldNumber = 4,
    kSuccessFieldNumber = 1,
    kTotalCountFieldNumber = 5,
  };
  // repeated .unhinged.document_store.TagEvent events = 3;
  int events_size() const;
  private:
  int _internal_events_size() const;
  public:
  void clear_events();
  ::unhinged::document_store::TagEvent* mutable_events(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::document_store::TagEvent >*
      mutable_events();
  private:
  const ::unhinged::document_store::TagEvent& _internal_events(int index) const;
  ::unhinged::document_store::TagEvent* _internal_add_events();
  public:
  const ::unhinged::document_store::TagEvent& events(int index) const;
  ::unhinged::document_store::TagEvent* add_events();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::document_store::TagEvent >&
      events() const;

  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .google.protobuf.Timestamp next_pagination_token = 4;
  bool has_next_pagination_token() const;
  private:
  bool _internal_has_next_pagination_token() const;
  public:
  void clear_next_pagination_token();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& next_pagination_token() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_next_pagination_token();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_next_pagination_token();
  void set_allocated_next_pagination_token(::PROTOBUF_NAMESPACE_ID::Timestamp* next_pagination_token);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_next_pagination_token() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_next_pagination_token();
  public:
  void unsafe_arena_set_allocated_next_pagination_token(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* next_pagination_token);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_next_pagination_token();

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // int32 total_count = 5;
  void clear_total_count();
  int32_t total_count() const;
  void set_total_count(int32_t value);
  private:
  int32_t _internal_total_count() const;
  void _internal_set_total_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.document_store.ListTagEventsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::document_store::TagEvent > events_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* next_pagination_token_;
    bool success_;
    int32_t total_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_document_5fstore_2eproto;
};
// -------------------------------------------------------------------

class GetSessionContextRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.document_store.GetSessionContextRequest) */ {
 public:
  inline GetSessionContextRequest() : GetSessionContextRequest(nullptr) {}
  ~GetSessionContextRequest() override;
  explicit PROTOBUF_CONSTEXPR GetSessionContextRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSessionContextRequest(const GetSessionContextRequest& from);
  GetSessionContextRequest(GetSessionContextRequest&& from) noexcept
    : GetSessionContextRequest() {
    *this = ::std::move(from);
  }

  inline GetSessionContextRequest& operator=(const GetSessionContextRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSessionContextRequest& operator=(GetSessionContextRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSessionContextRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSessionContextRequest* internal_default_instance() {
    return reinterpret_cast<const GetSessionContextRequest*>(
               &_GetSessionContextRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(GetSessionContextRequest& a, GetSessionContextRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSessionContextRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSessionContextRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSessionContextRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSessionContextRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSessionContextRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetSessionContextRequest& from) {
    GetSessionContextRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSessionContextRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.document_store.GetSessionContextRequest";
  }
  protected:
  explicit GetSessionContextRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDocumentTypesFieldNumber = 2,
    kSessionIdFieldNumber = 1,
    kSinceFieldNumber = 3,
    kLimitFieldNumber = 4,
    kIncludeBodyFieldNumber = 5,
  };
  // repeated string document_types = 2;
  int document_types_size() const;
  private:
  int _internal_document_types_size() const;
  public:
  void clear_document_types();
  const std::string& document_types(int index) const;
  std::string* mutable_document_types(int index);
  void set_document_types(int index, const std::string& value);
  void set_document_types(int index, std::string&& value);
  void set_document_types(int index, const char* value);
  void set_document_types(int index, const char* value, size_t size);
  std::string* add_document_types();
  void add_document_types(const std::string& value);
  void add_document_types(std::string&& value);
  void add_document_types(const char* value);
  void add_document_types(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& document_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_document_types();
  private:
  const std::string& _internal_document_types(int index) const;
  std::string* _internal_add_document_types();
  public:

  // string session_id = 1;
  void clear_session_id();
  const std::string& session_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // optional .google.protobuf.Timestamp since = 3;
  bool has_since() const;
  private:
  bool _internal_has_since() const;
  public:
  void clear_since();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& since() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_since();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_since();
  void set_allocated_since(::PROTOBUF_NAMESPACE_ID::Timestamp* since);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_since() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_since();
  public:
  void unsafe_arena_set_allocated_since(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* since);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_since();

  // int32 limit = 4;
  void clear_limit();
  int32_t limit() const;
  void set_limit(int32_t value);
  private:
  int32_t _internal_limit() const;
  void _internal_set_limit(int32_t value);
  public:

  // bool include_body = 5;
  void clear_include_body();
  bool include_body() const;
  void set_include_body(bool value);
  private:
  bool _internal_include_body() const;
  void _internal_set_include_body(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.document_store.GetSessionContextRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> document_types_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* since_;
    int32_t limit_;
    bool include_body_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_document_5fstore_2eproto;
};
// -------------------------------------------------------------------

class GetSessionContextResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.document_store.GetSessionContextResponse) */ {
 public:
  inline GetSessionContextResponse() : GetSessionContextResponse(nullptr) {}
  ~GetSessionContextResponse() override;
  explicit PROTOBUF_CONSTEXPR GetSessionContextResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSessionContextResponse(const GetSessionContextResponse& from);
  GetSessionContextResponse(GetSessionContextResponse&& from) noexcept
    : GetSessionContextResponse() {
    *this = ::std::move(from);
  }

  inline GetSessionContextResponse& operator=(const GetSessionContextResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSessionContextResponse& operator=(GetSessionContextResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSessionContextResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSessionContextResponse* internal_default_instance() {
    return reinterpret_cast<const GetSessionContextResponse*>(
               &_GetSessionContextResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(GetSessionContextResponse& a, GetSessionContextResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSessionContextResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSessionContextResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSessionContextResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSessionContextResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSessionContextResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetSessionContextResponse& from) {
    GetSessionContextResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSessionContextResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.document_store.GetSessionContextResponse";
  }
  protected:
  explicit GetSessionContextResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDocumentsFieldNumber = 3,
    kMessageFieldNumber = 2,
    kSuccessFieldNumber = 1,
    kTotalCountFieldNumber = 4,
  };
  // repeated .unhinged.document_store.Document documents = 3;
  int documents_size() const;
  private:
  int _internal_documents_size() const;
  public:
  void clear_documents();
  ::unhinged::document_store::Document* mutable_documents(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::document_store::Document >*
      mutable_documents();
  private:
  const ::unhinged::document_store::Document& _internal_documents(int index) const;
  ::unhinged::document_store::Document* _internal_add_documents();
  public:
  const ::unhinged::document_store::Document& documents(int index) const;
  ::unhinged::document_store::Document* add_documents();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::document_store::Document >&
      documents() const;

  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // int32 total_count = 4;
  void clear_total_count();
  int32_t total_count() const;
  void set_total_count(int32_t value);
  private:
  int32_t _internal_total_count() const;
  void _internal_set_total_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.document_store.GetSessionContextResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::document_store::Document > documents_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    bool success_;
    int32_t total_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_document_5fstore_2eproto;
};
// -------------------------------------------------------------------

class DeleteDocumentRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.document_store.DeleteDocumentRequest) */ {
 public:
  inline DeleteDocumentRequest() : DeleteDocumentRequest(nullptr) {}
  ~DeleteDocumentRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteDocumentRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteDocumentRequest(const DeleteDocumentRequest& from);
  DeleteDocumentRequest(DeleteDocumentRequest&& from) noexcept
    : DeleteDocumentRequest() {
    *this = ::std::move(from);
  }

  inline DeleteDocumentRequest& operator=(const DeleteDocumentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteDocumentRequest& operator=(DeleteDocumentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteDocumentRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteDocumentRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteDocumentRequest*>(
               &_DeleteDocumentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(DeleteDocumentRequest& a, DeleteDocumentRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteDocumentRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteDocumentRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteDocumentRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteDocumentRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteDocumentRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteDocumentRequest& from) {
    DeleteDocumentRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteDocumentRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.document_store.DeleteDocumentRequest";
  }
  protected:
  explicit DeleteDocumentRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDocumentUuidFieldNumber = 1,
    kDeletedByFieldNumber = 3,
    kDeletedByTypeFieldNumber = 4,
    kSessionIdFieldNumber = 5,
    kVersionFieldNumber = 2,
  };
  // string document_uuid = 1;
  void clear_document_uuid();
  const std::string& document_uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_document_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_document_uuid();
  PROTOBUF_NODISCARD std::string* release_document_uuid();
  void set_allocated_document_uuid(std::string* document_uuid);
  private:
  const std::string& _internal_document_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_document_uuid(const std::string& value);
  std::string* _internal_mutable_document_uuid();
  public:

  // string deleted_by = 3;
  void clear_deleted_by();
  const std::string& deleted_by() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_deleted_by(ArgT0&& arg0, ArgT... args);
  std::string* mutable_deleted_by();
  PROTOBUF_NODISCARD std::string* release_deleted_by();
  void set_allocated_deleted_by(std::string* deleted_by);
  private:
  const std::string& _internal_deleted_by() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_deleted_by(const std::string& value);
  std::string* _internal_mutable_deleted_by();
  public:

  // string deleted_by_type = 4;
  void clear_deleted_by_type();
  const std::string& deleted_by_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_deleted_by_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_deleted_by_type();
  PROTOBUF_NODISCARD std::string* release_deleted_by_type();
  void set_allocated_deleted_by_type(std::string* deleted_by_type);
  private:
  const std::string& _internal_deleted_by_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_deleted_by_type(const std::string& value);
  std::string* _internal_mutable_deleted_by_type();
  public:

  // string session_id = 5;
  void clear_session_id();
  const std::string& session_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // optional int32 version = 2;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  int32_t version() const;
  void set_version(int32_t value);
  private:
  int32_t _internal_version() const;
  void _internal_set_version(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.document_store.DeleteDocumentRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr document_uuid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deleted_by_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deleted_by_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
    int32_t version_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_document_5fstore_2eproto;
};
// -------------------------------------------------------------------

class DeleteDocumentResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.document_store.DeleteDocumentResponse) */ {
 public:
  inline DeleteDocumentResponse() : DeleteDocumentResponse(nullptr) {}
  ~DeleteDocumentResponse() override;
  explicit PROTOBUF_CONSTEXPR DeleteDocumentResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteDocumentResponse(const DeleteDocumentResponse& from);
  DeleteDocumentResponse(DeleteDocumentResponse&& from) noexcept
    : DeleteDocumentResponse() {
    *this = ::std::move(from);
  }

  inline DeleteDocumentResponse& operator=(const DeleteDocumentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteDocumentResponse& operator=(DeleteDocumentResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteDocumentResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteDocumentResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteDocumentResponse*>(
               &_DeleteDocumentResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(DeleteDocumentResponse& a, DeleteDocumentResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteDocumentResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteDocumentResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteDocumentResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteDocumentResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteDocumentResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteDocumentResponse& from) {
    DeleteDocumentResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteDocumentResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.document_store.DeleteDocumentResponse";
  }
  protected:
  explicit DeleteDocumentResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kSuccessFieldNumber = 1,
    kVersionsDeletedFieldNumber = 3,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // int32 versions_deleted = 3;
  void clear_versions_deleted();
  int32_t versions_deleted() const;
  void set_versions_deleted(int32_t value);
  private:
  int32_t _internal_versions_deleted() const;
  void _internal_set_versions_deleted(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.document_store.DeleteDocumentResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    bool success_;
    int32_t versions_deleted_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_document_5fstore_2eproto;
};
// -------------------------------------------------------------------

class HealthCheckRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:unhinged.document_store.HealthCheckRequest) */ {
 public:
  inline HealthCheckRequest() : HealthCheckRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR HealthCheckRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HealthCheckRequest(const HealthCheckRequest& from);
  HealthCheckRequest(HealthCheckRequest&& from) noexcept
    : HealthCheckRequest() {
    *this = ::std::move(from);
  }

  inline HealthCheckRequest& operator=(const HealthCheckRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HealthCheckRequest& operator=(HealthCheckRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HealthCheckRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HealthCheckRequest* internal_default_instance() {
    return reinterpret_cast<const HealthCheckRequest*>(
               &_HealthCheckRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(HealthCheckRequest& a, HealthCheckRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HealthCheckRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HealthCheckRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HealthCheckRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HealthCheckRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const HealthCheckRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const HealthCheckRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.document_store.HealthCheckRequest";
  }
  protected:
  explicit HealthCheckRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:unhinged.document_store.HealthCheckRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_document_5fstore_2eproto;
};
// -------------------------------------------------------------------

class HealthCheckResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.document_store.HealthCheckResponse) */ {
 public:
  inline HealthCheckResponse() : HealthCheckResponse(nullptr) {}
  ~HealthCheckResponse() override;
  explicit PROTOBUF_CONSTEXPR HealthCheckResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HealthCheckResponse(const HealthCheckResponse& from);
  HealthCheckResponse(HealthCheckResponse&& from) noexcept
    : HealthCheckResponse() {
    *this = ::std::move(from);
  }

  inline HealthCheckResponse& operator=(const HealthCheckResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline HealthCheckResponse& operator=(HealthCheckResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HealthCheckResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const HealthCheckResponse* internal_default_instance() {
    return reinterpret_cast<const HealthCheckResponse*>(
               &_HealthCheckResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(HealthCheckResponse& a, HealthCheckResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(HealthCheckResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HealthCheckResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HealthCheckResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HealthCheckResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HealthCheckResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HealthCheckResponse& from) {
    HealthCheckResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HealthCheckResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.document_store.HealthCheckResponse";
  }
  protected:
  explicit HealthCheckResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 2,
    kTimestampFieldNumber = 3,
    kHealthyFieldNumber = 1,
  };
  // string status = 2;
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // .google.protobuf.Timestamp timestamp = 3;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // bool healthy = 1;
  void clear_healthy();
  bool healthy() const;
  void set_healthy(bool value);
  private:
  bool _internal_healthy() const;
  void _internal_set_healthy(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.document_store.HealthCheckResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
    bool healthy_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_document_5fstore_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Document

// string document_uuid = 1;
inline void Document::clear_document_uuid() {
  _impl_.document_uuid_.ClearToEmpty();
}
inline const std::string& Document::document_uuid() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.Document.document_uuid)
  return _internal_document_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Document::set_document_uuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.document_uuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.document_store.Document.document_uuid)
}
inline std::string* Document::mutable_document_uuid() {
  std::string* _s = _internal_mutable_document_uuid();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.Document.document_uuid)
  return _s;
}
inline const std::string& Document::_internal_document_uuid() const {
  return _impl_.document_uuid_.Get();
}
inline void Document::_internal_set_document_uuid(const std::string& value) {
  
  _impl_.document_uuid_.Set(value, GetArenaForAllocation());
}
inline std::string* Document::_internal_mutable_document_uuid() {
  
  return _impl_.document_uuid_.Mutable(GetArenaForAllocation());
}
inline std::string* Document::release_document_uuid() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.Document.document_uuid)
  return _impl_.document_uuid_.Release();
}
inline void Document::set_allocated_document_uuid(std::string* document_uuid) {
  if (document_uuid != nullptr) {
    
  } else {
    
  }
  _impl_.document_uuid_.SetAllocated(document_uuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.document_uuid_.IsDefault()) {
    _impl_.document_uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.Document.document_uuid)
}

// string type = 2;
inline void Document::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& Document::type() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.Document.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Document::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.document_store.Document.type)
}
inline std::string* Document::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.Document.type)
  return _s;
}
inline const std::string& Document::_internal_type() const {
  return _impl_.type_.Get();
}
inline void Document::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* Document::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* Document::release_type() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.Document.type)
  return _impl_.type_.Release();
}
inline void Document::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.Document.type)
}

// string name = 3;
inline void Document::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Document::name() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.Document.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Document::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.document_store.Document.name)
}
inline std::string* Document::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.Document.name)
  return _s;
}
inline const std::string& Document::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Document::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Document::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Document::release_name() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.Document.name)
  return _impl_.name_.Release();
}
inline void Document::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.Document.name)
}

// string namespace = 4;
inline void Document::clear_namespace_() {
  _impl_.namespace__.ClearToEmpty();
}
inline const std::string& Document::namespace_() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.Document.namespace)
  return _internal_namespace_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Document::set_namespace_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.namespace__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.document_store.Document.namespace)
}
inline std::string* Document::mutable_namespace_() {
  std::string* _s = _internal_mutable_namespace_();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.Document.namespace)
  return _s;
}
inline const std::string& Document::_internal_namespace_() const {
  return _impl_.namespace__.Get();
}
inline void Document::_internal_set_namespace_(const std::string& value) {
  
  _impl_.namespace__.Set(value, GetArenaForAllocation());
}
inline std::string* Document::_internal_mutable_namespace_() {
  
  return _impl_.namespace__.Mutable(GetArenaForAllocation());
}
inline std::string* Document::release_namespace_() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.Document.namespace)
  return _impl_.namespace__.Release();
}
inline void Document::set_allocated_namespace_(std::string* namespace_) {
  if (namespace_ != nullptr) {
    
  } else {
    
  }
  _impl_.namespace__.SetAllocated(namespace_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.namespace__.IsDefault()) {
    _impl_.namespace__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.Document.namespace)
}

// int32 version = 5;
inline void Document::clear_version() {
  _impl_.version_ = 0;
}
inline int32_t Document::_internal_version() const {
  return _impl_.version_;
}
inline int32_t Document::version() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.Document.version)
  return _internal_version();
}
inline void Document::_internal_set_version(int32_t value) {
  
  _impl_.version_ = value;
}
inline void Document::set_version(int32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:unhinged.document_store.Document.version)
}

// string body_json = 6;
inline void Document::clear_body_json() {
  _impl_.body_json_.ClearToEmpty();
}
inline const std::string& Document::body_json() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.Document.body_json)
  return _internal_body_json();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Document::set_body_json(ArgT0&& arg0, ArgT... args) {
 
 _impl_.body_json_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.document_store.Document.body_json)
}
inline std::string* Document::mutable_body_json() {
  std::string* _s = _internal_mutable_body_json();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.Document.body_json)
  return _s;
}
inline const std::string& Document::_internal_body_json() const {
  return _impl_.body_json_.Get();
}
inline void Document::_internal_set_body_json(const std::string& value) {
  
  _impl_.body_json_.Set(value, GetArenaForAllocation());
}
inline std::string* Document::_internal_mutable_body_json() {
  
  return _impl_.body_json_.Mutable(GetArenaForAllocation());
}
inline std::string* Document::release_body_json() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.Document.body_json)
  return _impl_.body_json_.Release();
}
inline void Document::set_allocated_body_json(std::string* body_json) {
  if (body_json != nullptr) {
    
  } else {
    
  }
  _impl_.body_json_.SetAllocated(body_json, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.body_json_.IsDefault()) {
    _impl_.body_json_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.Document.body_json)
}

// .google.protobuf.Struct metadata = 7;
inline bool Document::_internal_has_metadata() const {
  return this != internal_default_instance() && _impl_.metadata_ != nullptr;
}
inline bool Document::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& Document::_internal_metadata() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& Document::metadata() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.Document.metadata)
  return _internal_metadata();
}
inline void Document::unsafe_arena_set_allocated_metadata(
    ::PROTOBUF_NAMESPACE_ID::Struct* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.document_store.Document.metadata)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Document::release_metadata() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Document::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.Document.metadata)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Document::_internal_mutable_metadata() {
  
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Document::mutable_metadata() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.Document.metadata)
  return _msg;
}
inline void Document::set_allocated_metadata(::PROTOBUF_NAMESPACE_ID::Struct* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.Document.metadata)
}

// repeated string tags = 8;
inline int Document::_internal_tags_size() const {
  return _impl_.tags_.size();
}
inline int Document::tags_size() const {
  return _internal_tags_size();
}
inline void Document::clear_tags() {
  _impl_.tags_.Clear();
}
inline std::string* Document::add_tags() {
  std::string* _s = _internal_add_tags();
  // @@protoc_insertion_point(field_add_mutable:unhinged.document_store.Document.tags)
  return _s;
}
inline const std::string& Document::_internal_tags(int index) const {
  return _impl_.tags_.Get(index);
}
inline const std::string& Document::tags(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.Document.tags)
  return _internal_tags(index);
}
inline std::string* Document::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.Document.tags)
  return _impl_.tags_.Mutable(index);
}
inline void Document::set_tags(int index, const std::string& value) {
  _impl_.tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.document_store.Document.tags)
}
inline void Document::set_tags(int index, std::string&& value) {
  _impl_.tags_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.document_store.Document.tags)
}
inline void Document::set_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.document_store.Document.tags)
}
inline void Document::set_tags(int index, const char* value, size_t size) {
  _impl_.tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.document_store.Document.tags)
}
inline std::string* Document::_internal_add_tags() {
  return _impl_.tags_.Add();
}
inline void Document::add_tags(const std::string& value) {
  _impl_.tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.document_store.Document.tags)
}
inline void Document::add_tags(std::string&& value) {
  _impl_.tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.document_store.Document.tags)
}
inline void Document::add_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.document_store.Document.tags)
}
inline void Document::add_tags(const char* value, size_t size) {
  _impl_.tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.document_store.Document.tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Document::tags() const {
  // @@protoc_insertion_point(field_list:unhinged.document_store.Document.tags)
  return _impl_.tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Document::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.document_store.Document.tags)
  return &_impl_.tags_;
}

// .google.protobuf.Timestamp created_at = 9;
inline bool Document::_internal_has_created_at() const {
  return this != internal_default_instance() && _impl_.created_at_ != nullptr;
}
inline bool Document::has_created_at() const {
  return _internal_has_created_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Document::_internal_created_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Document::created_at() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.Document.created_at)
  return _internal_created_at();
}
inline void Document::unsafe_arena_set_allocated_created_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.document_store.Document.created_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Document::release_created_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Document::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.Document.created_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Document::_internal_mutable_created_at() {
  
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.created_at_ = p;
  }
  return _impl_.created_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Document::mutable_created_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.Document.created_at)
  return _msg;
}
inline void Document::set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at));
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.Document.created_at)
}

// string created_by = 10;
inline void Document::clear_created_by() {
  _impl_.created_by_.ClearToEmpty();
}
inline const std::string& Document::created_by() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.Document.created_by)
  return _internal_created_by();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Document::set_created_by(ArgT0&& arg0, ArgT... args) {
 
 _impl_.created_by_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.document_store.Document.created_by)
}
inline std::string* Document::mutable_created_by() {
  std::string* _s = _internal_mutable_created_by();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.Document.created_by)
  return _s;
}
inline const std::string& Document::_internal_created_by() const {
  return _impl_.created_by_.Get();
}
inline void Document::_internal_set_created_by(const std::string& value) {
  
  _impl_.created_by_.Set(value, GetArenaForAllocation());
}
inline std::string* Document::_internal_mutable_created_by() {
  
  return _impl_.created_by_.Mutable(GetArenaForAllocation());
}
inline std::string* Document::release_created_by() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.Document.created_by)
  return _impl_.created_by_.Release();
}
inline void Document::set_allocated_created_by(std::string* created_by) {
  if (created_by != nullptr) {
    
  } else {
    
  }
  _impl_.created_by_.SetAllocated(created_by, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.created_by_.IsDefault()) {
    _impl_.created_by_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.Document.created_by)
}

// string created_by_type = 11;
inline void Document::clear_created_by_type() {
  _impl_.created_by_type_.ClearToEmpty();
}
inline const std::string& Document::created_by_type() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.Document.created_by_type)
  return _internal_created_by_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Document::set_created_by_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.created_by_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.document_store.Document.created_by_type)
}
inline std::string* Document::mutable_created_by_type() {
  std::string* _s = _internal_mutable_created_by_type();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.Document.created_by_type)
  return _s;
}
inline const std::string& Document::_internal_created_by_type() const {
  return _impl_.created_by_type_.Get();
}
inline void Document::_internal_set_created_by_type(const std::string& value) {
  
  _impl_.created_by_type_.Set(value, GetArenaForAllocation());
}
inline std::string* Document::_internal_mutable_created_by_type() {
  
  return _impl_.created_by_type_.Mutable(GetArenaForAllocation());
}
inline std::string* Document::release_created_by_type() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.Document.created_by_type)
  return _impl_.created_by_type_.Release();
}
inline void Document::set_allocated_created_by_type(std::string* created_by_type) {
  if (created_by_type != nullptr) {
    
  } else {
    
  }
  _impl_.created_by_type_.SetAllocated(created_by_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.created_by_type_.IsDefault()) {
    _impl_.created_by_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.Document.created_by_type)
}

// string session_id = 12;
inline void Document::clear_session_id() {
  _impl_.session_id_.ClearToEmpty();
}
inline const std::string& Document::session_id() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.Document.session_id)
  return _internal_session_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Document::set_session_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.session_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.document_store.Document.session_id)
}
inline std::string* Document::mutable_session_id() {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.Document.session_id)
  return _s;
}
inline const std::string& Document::_internal_session_id() const {
  return _impl_.session_id_.Get();
}
inline void Document::_internal_set_session_id(const std::string& value) {
  
  _impl_.session_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Document::_internal_mutable_session_id() {
  
  return _impl_.session_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Document::release_session_id() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.Document.session_id)
  return _impl_.session_id_.Release();
}
inline void Document::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  _impl_.session_id_.SetAllocated(session_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.session_id_.IsDefault()) {
    _impl_.session_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.Document.session_id)
}

// -------------------------------------------------------------------

// DocumentStub

// string document_uuid = 1;
inline void DocumentStub::clear_document_uuid() {
  _impl_.document_uuid_.ClearToEmpty();
}
inline const std::string& DocumentStub::document_uuid() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.DocumentStub.document_uuid)
  return _internal_document_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DocumentStub::set_document_uuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.document_uuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.document_store.DocumentStub.document_uuid)
}
inline std::string* DocumentStub::mutable_document_uuid() {
  std::string* _s = _internal_mutable_document_uuid();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.DocumentStub.document_uuid)
  return _s;
}
inline const std::string& DocumentStub::_internal_document_uuid() const {
  return _impl_.document_uuid_.Get();
}
inline void DocumentStub::_internal_set_document_uuid(const std::string& value) {
  
  _impl_.document_uuid_.Set(value, GetArenaForAllocation());
}
inline std::string* DocumentStub::_internal_mutable_document_uuid() {
  
  return _impl_.document_uuid_.Mutable(GetArenaForAllocation());
}
inline std::string* DocumentStub::release_document_uuid() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.DocumentStub.document_uuid)
  return _impl_.document_uuid_.Release();
}
inline void DocumentStub::set_allocated_document_uuid(std::string* document_uuid) {
  if (document_uuid != nullptr) {
    
  } else {
    
  }
  _impl_.document_uuid_.SetAllocated(document_uuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.document_uuid_.IsDefault()) {
    _impl_.document_uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.DocumentStub.document_uuid)
}

// string type = 2;
inline void DocumentStub::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& DocumentStub::type() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.DocumentStub.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DocumentStub::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.document_store.DocumentStub.type)
}
inline std::string* DocumentStub::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.DocumentStub.type)
  return _s;
}
inline const std::string& DocumentStub::_internal_type() const {
  return _impl_.type_.Get();
}
inline void DocumentStub::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* DocumentStub::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* DocumentStub::release_type() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.DocumentStub.type)
  return _impl_.type_.Release();
}
inline void DocumentStub::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.DocumentStub.type)
}

// string name = 3;
inline void DocumentStub::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& DocumentStub::name() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.DocumentStub.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DocumentStub::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.document_store.DocumentStub.name)
}
inline std::string* DocumentStub::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.DocumentStub.name)
  return _s;
}
inline const std::string& DocumentStub::_internal_name() const {
  return _impl_.name_.Get();
}
inline void DocumentStub::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* DocumentStub::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* DocumentStub::release_name() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.DocumentStub.name)
  return _impl_.name_.Release();
}
inline void DocumentStub::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.DocumentStub.name)
}

// string namespace = 4;
inline void DocumentStub::clear_namespace_() {
  _impl_.namespace__.ClearToEmpty();
}
inline const std::string& DocumentStub::namespace_() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.DocumentStub.namespace)
  return _internal_namespace_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DocumentStub::set_namespace_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.namespace__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.document_store.DocumentStub.namespace)
}
inline std::string* DocumentStub::mutable_namespace_() {
  std::string* _s = _internal_mutable_namespace_();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.DocumentStub.namespace)
  return _s;
}
inline const std::string& DocumentStub::_internal_namespace_() const {
  return _impl_.namespace__.Get();
}
inline void DocumentStub::_internal_set_namespace_(const std::string& value) {
  
  _impl_.namespace__.Set(value, GetArenaForAllocation());
}
inline std::string* DocumentStub::_internal_mutable_namespace_() {
  
  return _impl_.namespace__.Mutable(GetArenaForAllocation());
}
inline std::string* DocumentStub::release_namespace_() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.DocumentStub.namespace)
  return _impl_.namespace__.Release();
}
inline void DocumentStub::set_allocated_namespace_(std::string* namespace_) {
  if (namespace_ != nullptr) {
    
  } else {
    
  }
  _impl_.namespace__.SetAllocated(namespace_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.namespace__.IsDefault()) {
    _impl_.namespace__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.DocumentStub.namespace)
}

// int32 version = 5;
inline void DocumentStub::clear_version() {
  _impl_.version_ = 0;
}
inline int32_t DocumentStub::_internal_version() const {
  return _impl_.version_;
}
inline int32_t DocumentStub::version() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.DocumentStub.version)
  return _internal_version();
}
inline void DocumentStub::_internal_set_version(int32_t value) {
  
  _impl_.version_ = value;
}
inline void DocumentStub::set_version(int32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:unhinged.document_store.DocumentStub.version)
}

// .google.protobuf.Struct metadata = 6;
inline bool DocumentStub::_internal_has_metadata() const {
  return this != internal_default_instance() && _impl_.metadata_ != nullptr;
}
inline bool DocumentStub::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& DocumentStub::_internal_metadata() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& DocumentStub::metadata() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.DocumentStub.metadata)
  return _internal_metadata();
}
inline void DocumentStub::unsafe_arena_set_allocated_metadata(
    ::PROTOBUF_NAMESPACE_ID::Struct* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.document_store.DocumentStub.metadata)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* DocumentStub::release_metadata() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* DocumentStub::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.DocumentStub.metadata)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* DocumentStub::_internal_mutable_metadata() {
  
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* DocumentStub::mutable_metadata() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.DocumentStub.metadata)
  return _msg;
}
inline void DocumentStub::set_allocated_metadata(::PROTOBUF_NAMESPACE_ID::Struct* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.DocumentStub.metadata)
}

// repeated string tags = 7;
inline int DocumentStub::_internal_tags_size() const {
  return _impl_.tags_.size();
}
inline int DocumentStub::tags_size() const {
  return _internal_tags_size();
}
inline void DocumentStub::clear_tags() {
  _impl_.tags_.Clear();
}
inline std::string* DocumentStub::add_tags() {
  std::string* _s = _internal_add_tags();
  // @@protoc_insertion_point(field_add_mutable:unhinged.document_store.DocumentStub.tags)
  return _s;
}
inline const std::string& DocumentStub::_internal_tags(int index) const {
  return _impl_.tags_.Get(index);
}
inline const std::string& DocumentStub::tags(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.DocumentStub.tags)
  return _internal_tags(index);
}
inline std::string* DocumentStub::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.DocumentStub.tags)
  return _impl_.tags_.Mutable(index);
}
inline void DocumentStub::set_tags(int index, const std::string& value) {
  _impl_.tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.document_store.DocumentStub.tags)
}
inline void DocumentStub::set_tags(int index, std::string&& value) {
  _impl_.tags_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.document_store.DocumentStub.tags)
}
inline void DocumentStub::set_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.document_store.DocumentStub.tags)
}
inline void DocumentStub::set_tags(int index, const char* value, size_t size) {
  _impl_.tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.document_store.DocumentStub.tags)
}
inline std::string* DocumentStub::_internal_add_tags() {
  return _impl_.tags_.Add();
}
inline void DocumentStub::add_tags(const std::string& value) {
  _impl_.tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.document_store.DocumentStub.tags)
}
inline void DocumentStub::add_tags(std::string&& value) {
  _impl_.tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.document_store.DocumentStub.tags)
}
inline void DocumentStub::add_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.document_store.DocumentStub.tags)
}
inline void DocumentStub::add_tags(const char* value, size_t size) {
  _impl_.tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.document_store.DocumentStub.tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DocumentStub::tags() const {
  // @@protoc_insertion_point(field_list:unhinged.document_store.DocumentStub.tags)
  return _impl_.tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DocumentStub::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.document_store.DocumentStub.tags)
  return &_impl_.tags_;
}

// .google.protobuf.Timestamp created_at = 8;
inline bool DocumentStub::_internal_has_created_at() const {
  return this != internal_default_instance() && _impl_.created_at_ != nullptr;
}
inline bool DocumentStub::has_created_at() const {
  return _internal_has_created_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& DocumentStub::_internal_created_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& DocumentStub::created_at() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.DocumentStub.created_at)
  return _internal_created_at();
}
inline void DocumentStub::unsafe_arena_set_allocated_created_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.document_store.DocumentStub.created_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DocumentStub::release_created_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DocumentStub::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.DocumentStub.created_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DocumentStub::_internal_mutable_created_at() {
  
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.created_at_ = p;
  }
  return _impl_.created_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DocumentStub::mutable_created_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.DocumentStub.created_at)
  return _msg;
}
inline void DocumentStub::set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at));
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.DocumentStub.created_at)
}

// string created_by = 9;
inline void DocumentStub::clear_created_by() {
  _impl_.created_by_.ClearToEmpty();
}
inline const std::string& DocumentStub::created_by() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.DocumentStub.created_by)
  return _internal_created_by();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DocumentStub::set_created_by(ArgT0&& arg0, ArgT... args) {
 
 _impl_.created_by_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.document_store.DocumentStub.created_by)
}
inline std::string* DocumentStub::mutable_created_by() {
  std::string* _s = _internal_mutable_created_by();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.DocumentStub.created_by)
  return _s;
}
inline const std::string& DocumentStub::_internal_created_by() const {
  return _impl_.created_by_.Get();
}
inline void DocumentStub::_internal_set_created_by(const std::string& value) {
  
  _impl_.created_by_.Set(value, GetArenaForAllocation());
}
inline std::string* DocumentStub::_internal_mutable_created_by() {
  
  return _impl_.created_by_.Mutable(GetArenaForAllocation());
}
inline std::string* DocumentStub::release_created_by() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.DocumentStub.created_by)
  return _impl_.created_by_.Release();
}
inline void DocumentStub::set_allocated_created_by(std::string* created_by) {
  if (created_by != nullptr) {
    
  } else {
    
  }
  _impl_.created_by_.SetAllocated(created_by, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.created_by_.IsDefault()) {
    _impl_.created_by_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.DocumentStub.created_by)
}

// string created_by_type = 10;
inline void DocumentStub::clear_created_by_type() {
  _impl_.created_by_type_.ClearToEmpty();
}
inline const std::string& DocumentStub::created_by_type() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.DocumentStub.created_by_type)
  return _internal_created_by_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DocumentStub::set_created_by_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.created_by_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.document_store.DocumentStub.created_by_type)
}
inline std::string* DocumentStub::mutable_created_by_type() {
  std::string* _s = _internal_mutable_created_by_type();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.DocumentStub.created_by_type)
  return _s;
}
inline const std::string& DocumentStub::_internal_created_by_type() const {
  return _impl_.created_by_type_.Get();
}
inline void DocumentStub::_internal_set_created_by_type(const std::string& value) {
  
  _impl_.created_by_type_.Set(value, GetArenaForAllocation());
}
inline std::string* DocumentStub::_internal_mutable_created_by_type() {
  
  return _impl_.created_by_type_.Mutable(GetArenaForAllocation());
}
inline std::string* DocumentStub::release_created_by_type() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.DocumentStub.created_by_type)
  return _impl_.created_by_type_.Release();
}
inline void DocumentStub::set_allocated_created_by_type(std::string* created_by_type) {
  if (created_by_type != nullptr) {
    
  } else {
    
  }
  _impl_.created_by_type_.SetAllocated(created_by_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.created_by_type_.IsDefault()) {
    _impl_.created_by_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.DocumentStub.created_by_type)
}

// string session_id = 11;
inline void DocumentStub::clear_session_id() {
  _impl_.session_id_.ClearToEmpty();
}
inline const std::string& DocumentStub::session_id() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.DocumentStub.session_id)
  return _internal_session_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DocumentStub::set_session_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.session_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.document_store.DocumentStub.session_id)
}
inline std::string* DocumentStub::mutable_session_id() {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.DocumentStub.session_id)
  return _s;
}
inline const std::string& DocumentStub::_internal_session_id() const {
  return _impl_.session_id_.Get();
}
inline void DocumentStub::_internal_set_session_id(const std::string& value) {
  
  _impl_.session_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DocumentStub::_internal_mutable_session_id() {
  
  return _impl_.session_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DocumentStub::release_session_id() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.DocumentStub.session_id)
  return _impl_.session_id_.Release();
}
inline void DocumentStub::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  _impl_.session_id_.SetAllocated(session_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.session_id_.IsDefault()) {
    _impl_.session_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.DocumentStub.session_id)
}

// -------------------------------------------------------------------

// ActiveTag

// string document_uuid = 1;
inline void ActiveTag::clear_document_uuid() {
  _impl_.document_uuid_.ClearToEmpty();
}
inline const std::string& ActiveTag::document_uuid() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.ActiveTag.document_uuid)
  return _internal_document_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActiveTag::set_document_uuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.document_uuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.document_store.ActiveTag.document_uuid)
}
inline std::string* ActiveTag::mutable_document_uuid() {
  std::string* _s = _internal_mutable_document_uuid();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.ActiveTag.document_uuid)
  return _s;
}
inline const std::string& ActiveTag::_internal_document_uuid() const {
  return _impl_.document_uuid_.Get();
}
inline void ActiveTag::_internal_set_document_uuid(const std::string& value) {
  
  _impl_.document_uuid_.Set(value, GetArenaForAllocation());
}
inline std::string* ActiveTag::_internal_mutable_document_uuid() {
  
  return _impl_.document_uuid_.Mutable(GetArenaForAllocation());
}
inline std::string* ActiveTag::release_document_uuid() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.ActiveTag.document_uuid)
  return _impl_.document_uuid_.Release();
}
inline void ActiveTag::set_allocated_document_uuid(std::string* document_uuid) {
  if (document_uuid != nullptr) {
    
  } else {
    
  }
  _impl_.document_uuid_.SetAllocated(document_uuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.document_uuid_.IsDefault()) {
    _impl_.document_uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.ActiveTag.document_uuid)
}

// int32 document_version = 2;
inline void ActiveTag::clear_document_version() {
  _impl_.document_version_ = 0;
}
inline int32_t ActiveTag::_internal_document_version() const {
  return _impl_.document_version_;
}
inline int32_t ActiveTag::document_version() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.ActiveTag.document_version)
  return _internal_document_version();
}
inline void ActiveTag::_internal_set_document_version(int32_t value) {
  
  _impl_.document_version_ = value;
}
inline void ActiveTag::set_document_version(int32_t value) {
  _internal_set_document_version(value);
  // @@protoc_insertion_point(field_set:unhinged.document_store.ActiveTag.document_version)
}

// string tag = 3;
inline void ActiveTag::clear_tag() {
  _impl_.tag_.ClearToEmpty();
}
inline const std::string& ActiveTag::tag() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.ActiveTag.tag)
  return _internal_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActiveTag::set_tag(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.document_store.ActiveTag.tag)
}
inline std::string* ActiveTag::mutable_tag() {
  std::string* _s = _internal_mutable_tag();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.ActiveTag.tag)
  return _s;
}
inline const std::string& ActiveTag::_internal_tag() const {
  return _impl_.tag_.Get();
}
inline void ActiveTag::_internal_set_tag(const std::string& value) {
  
  _impl_.tag_.Set(value, GetArenaForAllocation());
}
inline std::string* ActiveTag::_internal_mutable_tag() {
  
  return _impl_.tag_.Mutable(GetArenaForAllocation());
}
inline std::string* ActiveTag::release_tag() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.ActiveTag.tag)
  return _impl_.tag_.Release();
}
inline void ActiveTag::set_allocated_tag(std::string* tag) {
  if (tag != nullptr) {
    
  } else {
    
  }
  _impl_.tag_.SetAllocated(tag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tag_.IsDefault()) {
    _impl_.tag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.ActiveTag.tag)
}

// .google.protobuf.Timestamp updated_at = 4;
inline bool ActiveTag::_internal_has_updated_at() const {
  return this != internal_default_instance() && _impl_.updated_at_ != nullptr;
}
inline bool ActiveTag::has_updated_at() const {
  return _internal_has_updated_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ActiveTag::_internal_updated_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.updated_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ActiveTag::updated_at() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.ActiveTag.updated_at)
  return _internal_updated_at();
}
inline void ActiveTag::unsafe_arena_set_allocated_updated_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.updated_at_);
  }
  _impl_.updated_at_ = updated_at;
  if (updated_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.document_store.ActiveTag.updated_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ActiveTag::release_updated_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.updated_at_;
  _impl_.updated_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ActiveTag::unsafe_arena_release_updated_at() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.ActiveTag.updated_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.updated_at_;
  _impl_.updated_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ActiveTag::_internal_mutable_updated_at() {
  
  if (_impl_.updated_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.updated_at_ = p;
  }
  return _impl_.updated_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ActiveTag::mutable_updated_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_updated_at();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.ActiveTag.updated_at)
  return _msg;
}
inline void ActiveTag::set_allocated_updated_at(::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.updated_at_);
  }
  if (updated_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(updated_at));
    if (message_arena != submessage_arena) {
      updated_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, updated_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.updated_at_ = updated_at;
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.ActiveTag.updated_at)
}

// string updated_by = 5;
inline void ActiveTag::clear_updated_by() {
  _impl_.updated_by_.ClearToEmpty();
}
inline const std::string& ActiveTag::updated_by() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.ActiveTag.updated_by)
  return _internal_updated_by();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActiveTag::set_updated_by(ArgT0&& arg0, ArgT... args) {
 
 _impl_.updated_by_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.document_store.ActiveTag.updated_by)
}
inline std::string* ActiveTag::mutable_updated_by() {
  std::string* _s = _internal_mutable_updated_by();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.ActiveTag.updated_by)
  return _s;
}
inline const std::string& ActiveTag::_internal_updated_by() const {
  return _impl_.updated_by_.Get();
}
inline void ActiveTag::_internal_set_updated_by(const std::string& value) {
  
  _impl_.updated_by_.Set(value, GetArenaForAllocation());
}
inline std::string* ActiveTag::_internal_mutable_updated_by() {
  
  return _impl_.updated_by_.Mutable(GetArenaForAllocation());
}
inline std::string* ActiveTag::release_updated_by() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.ActiveTag.updated_by)
  return _impl_.updated_by_.Release();
}
inline void ActiveTag::set_allocated_updated_by(std::string* updated_by) {
  if (updated_by != nullptr) {
    
  } else {
    
  }
  _impl_.updated_by_.SetAllocated(updated_by, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.updated_by_.IsDefault()) {
    _impl_.updated_by_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.ActiveTag.updated_by)
}

// string updated_by_type = 6;
inline void ActiveTag::clear_updated_by_type() {
  _impl_.updated_by_type_.ClearToEmpty();
}
inline const std::string& ActiveTag::updated_by_type() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.ActiveTag.updated_by_type)
  return _internal_updated_by_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActiveTag::set_updated_by_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.updated_by_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.document_store.ActiveTag.updated_by_type)
}
inline std::string* ActiveTag::mutable_updated_by_type() {
  std::string* _s = _internal_mutable_updated_by_type();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.ActiveTag.updated_by_type)
  return _s;
}
inline const std::string& ActiveTag::_internal_updated_by_type() const {
  return _impl_.updated_by_type_.Get();
}
inline void ActiveTag::_internal_set_updated_by_type(const std::string& value) {
  
  _impl_.updated_by_type_.Set(value, GetArenaForAllocation());
}
inline std::string* ActiveTag::_internal_mutable_updated_by_type() {
  
  return _impl_.updated_by_type_.Mutable(GetArenaForAllocation());
}
inline std::string* ActiveTag::release_updated_by_type() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.ActiveTag.updated_by_type)
  return _impl_.updated_by_type_.Release();
}
inline void ActiveTag::set_allocated_updated_by_type(std::string* updated_by_type) {
  if (updated_by_type != nullptr) {
    
  } else {
    
  }
  _impl_.updated_by_type_.SetAllocated(updated_by_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.updated_by_type_.IsDefault()) {
    _impl_.updated_by_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.ActiveTag.updated_by_type)
}

// string session_id = 7;
inline void ActiveTag::clear_session_id() {
  _impl_.session_id_.ClearToEmpty();
}
inline const std::string& ActiveTag::session_id() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.ActiveTag.session_id)
  return _internal_session_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActiveTag::set_session_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.session_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.document_store.ActiveTag.session_id)
}
inline std::string* ActiveTag::mutable_session_id() {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.ActiveTag.session_id)
  return _s;
}
inline const std::string& ActiveTag::_internal_session_id() const {
  return _impl_.session_id_.Get();
}
inline void ActiveTag::_internal_set_session_id(const std::string& value) {
  
  _impl_.session_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ActiveTag::_internal_mutable_session_id() {
  
  return _impl_.session_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ActiveTag::release_session_id() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.ActiveTag.session_id)
  return _impl_.session_id_.Release();
}
inline void ActiveTag::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  _impl_.session_id_.SetAllocated(session_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.session_id_.IsDefault()) {
    _impl_.session_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.ActiveTag.session_id)
}

// -------------------------------------------------------------------

// TagEvent

// string tag_event_uuid = 1;
inline void TagEvent::clear_tag_event_uuid() {
  _impl_.tag_event_uuid_.ClearToEmpty();
}
inline const std::string& TagEvent::tag_event_uuid() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.TagEvent.tag_event_uuid)
  return _internal_tag_event_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TagEvent::set_tag_event_uuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tag_event_uuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.document_store.TagEvent.tag_event_uuid)
}
inline std::string* TagEvent::mutable_tag_event_uuid() {
  std::string* _s = _internal_mutable_tag_event_uuid();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.TagEvent.tag_event_uuid)
  return _s;
}
inline const std::string& TagEvent::_internal_tag_event_uuid() const {
  return _impl_.tag_event_uuid_.Get();
}
inline void TagEvent::_internal_set_tag_event_uuid(const std::string& value) {
  
  _impl_.tag_event_uuid_.Set(value, GetArenaForAllocation());
}
inline std::string* TagEvent::_internal_mutable_tag_event_uuid() {
  
  return _impl_.tag_event_uuid_.Mutable(GetArenaForAllocation());
}
inline std::string* TagEvent::release_tag_event_uuid() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.TagEvent.tag_event_uuid)
  return _impl_.tag_event_uuid_.Release();
}
inline void TagEvent::set_allocated_tag_event_uuid(std::string* tag_event_uuid) {
  if (tag_event_uuid != nullptr) {
    
  } else {
    
  }
  _impl_.tag_event_uuid_.SetAllocated(tag_event_uuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tag_event_uuid_.IsDefault()) {
    _impl_.tag_event_uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.TagEvent.tag_event_uuid)
}

// string document_uuid = 2;
inline void TagEvent::clear_document_uuid() {
  _impl_.document_uuid_.ClearToEmpty();
}
inline const std::string& TagEvent::document_uuid() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.TagEvent.document_uuid)
  return _internal_document_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TagEvent::set_document_uuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.document_uuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.document_store.TagEvent.document_uuid)
}
inline std::string* TagEvent::mutable_document_uuid() {
  std::string* _s = _internal_mutable_document_uuid();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.TagEvent.document_uuid)
  return _s;
}
inline const std::string& TagEvent::_internal_document_uuid() const {
  return _impl_.document_uuid_.Get();
}
inline void TagEvent::_internal_set_document_uuid(const std::string& value) {
  
  _impl_.document_uuid_.Set(value, GetArenaForAllocation());
}
inline std::string* TagEvent::_internal_mutable_document_uuid() {
  
  return _impl_.document_uuid_.Mutable(GetArenaForAllocation());
}
inline std::string* TagEvent::release_document_uuid() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.TagEvent.document_uuid)
  return _impl_.document_uuid_.Release();
}
inline void TagEvent::set_allocated_document_uuid(std::string* document_uuid) {
  if (document_uuid != nullptr) {
    
  } else {
    
  }
  _impl_.document_uuid_.SetAllocated(document_uuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.document_uuid_.IsDefault()) {
    _impl_.document_uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.TagEvent.document_uuid)
}

// int32 document_version = 3;
inline void TagEvent::clear_document_version() {
  _impl_.document_version_ = 0;
}
inline int32_t TagEvent::_internal_document_version() const {
  return _impl_.document_version_;
}
inline int32_t TagEvent::document_version() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.TagEvent.document_version)
  return _internal_document_version();
}
inline void TagEvent::_internal_set_document_version(int32_t value) {
  
  _impl_.document_version_ = value;
}
inline void TagEvent::set_document_version(int32_t value) {
  _internal_set_document_version(value);
  // @@protoc_insertion_point(field_set:unhinged.document_store.TagEvent.document_version)
}

// string tag = 4;
inline void TagEvent::clear_tag() {
  _impl_.tag_.ClearToEmpty();
}
inline const std::string& TagEvent::tag() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.TagEvent.tag)
  return _internal_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TagEvent::set_tag(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.document_store.TagEvent.tag)
}
inline std::string* TagEvent::mutable_tag() {
  std::string* _s = _internal_mutable_tag();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.TagEvent.tag)
  return _s;
}
inline const std::string& TagEvent::_internal_tag() const {
  return _impl_.tag_.Get();
}
inline void TagEvent::_internal_set_tag(const std::string& value) {
  
  _impl_.tag_.Set(value, GetArenaForAllocation());
}
inline std::string* TagEvent::_internal_mutable_tag() {
  
  return _impl_.tag_.Mutable(GetArenaForAllocation());
}
inline std::string* TagEvent::release_tag() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.TagEvent.tag)
  return _impl_.tag_.Release();
}
inline void TagEvent::set_allocated_tag(std::string* tag) {
  if (tag != nullptr) {
    
  } else {
    
  }
  _impl_.tag_.SetAllocated(tag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tag_.IsDefault()) {
    _impl_.tag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.TagEvent.tag)
}

// string operation = 5;
inline void TagEvent::clear_operation() {
  _impl_.operation_.ClearToEmpty();
}
inline const std::string& TagEvent::operation() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.TagEvent.operation)
  return _internal_operation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TagEvent::set_operation(ArgT0&& arg0, ArgT... args) {
 
 _impl_.operation_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.document_store.TagEvent.operation)
}
inline std::string* TagEvent::mutable_operation() {
  std::string* _s = _internal_mutable_operation();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.TagEvent.operation)
  return _s;
}
inline const std::string& TagEvent::_internal_operation() const {
  return _impl_.operation_.Get();
}
inline void TagEvent::_internal_set_operation(const std::string& value) {
  
  _impl_.operation_.Set(value, GetArenaForAllocation());
}
inline std::string* TagEvent::_internal_mutable_operation() {
  
  return _impl_.operation_.Mutable(GetArenaForAllocation());
}
inline std::string* TagEvent::release_operation() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.TagEvent.operation)
  return _impl_.operation_.Release();
}
inline void TagEvent::set_allocated_operation(std::string* operation) {
  if (operation != nullptr) {
    
  } else {
    
  }
  _impl_.operation_.SetAllocated(operation, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.operation_.IsDefault()) {
    _impl_.operation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.TagEvent.operation)
}

// .google.protobuf.Timestamp created_at = 6;
inline bool TagEvent::_internal_has_created_at() const {
  return this != internal_default_instance() && _impl_.created_at_ != nullptr;
}
inline bool TagEvent::has_created_at() const {
  return _internal_has_created_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& TagEvent::_internal_created_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& TagEvent::created_at() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.TagEvent.created_at)
  return _internal_created_at();
}
inline void TagEvent::unsafe_arena_set_allocated_created_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.document_store.TagEvent.created_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TagEvent::release_created_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TagEvent::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.TagEvent.created_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TagEvent::_internal_mutable_created_at() {
  
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.created_at_ = p;
  }
  return _impl_.created_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TagEvent::mutable_created_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.TagEvent.created_at)
  return _msg;
}
inline void TagEvent::set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at));
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.TagEvent.created_at)
}

// string created_by = 7;
inline void TagEvent::clear_created_by() {
  _impl_.created_by_.ClearToEmpty();
}
inline const std::string& TagEvent::created_by() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.TagEvent.created_by)
  return _internal_created_by();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TagEvent::set_created_by(ArgT0&& arg0, ArgT... args) {
 
 _impl_.created_by_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.document_store.TagEvent.created_by)
}
inline std::string* TagEvent::mutable_created_by() {
  std::string* _s = _internal_mutable_created_by();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.TagEvent.created_by)
  return _s;
}
inline const std::string& TagEvent::_internal_created_by() const {
  return _impl_.created_by_.Get();
}
inline void TagEvent::_internal_set_created_by(const std::string& value) {
  
  _impl_.created_by_.Set(value, GetArenaForAllocation());
}
inline std::string* TagEvent::_internal_mutable_created_by() {
  
  return _impl_.created_by_.Mutable(GetArenaForAllocation());
}
inline std::string* TagEvent::release_created_by() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.TagEvent.created_by)
  return _impl_.created_by_.Release();
}
inline void TagEvent::set_allocated_created_by(std::string* created_by) {
  if (created_by != nullptr) {
    
  } else {
    
  }
  _impl_.created_by_.SetAllocated(created_by, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.created_by_.IsDefault()) {
    _impl_.created_by_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.TagEvent.created_by)
}

// string created_by_type = 8;
inline void TagEvent::clear_created_by_type() {
  _impl_.created_by_type_.ClearToEmpty();
}
inline const std::string& TagEvent::created_by_type() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.TagEvent.created_by_type)
  return _internal_created_by_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TagEvent::set_created_by_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.created_by_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.document_store.TagEvent.created_by_type)
}
inline std::string* TagEvent::mutable_created_by_type() {
  std::string* _s = _internal_mutable_created_by_type();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.TagEvent.created_by_type)
  return _s;
}
inline const std::string& TagEvent::_internal_created_by_type() const {
  return _impl_.created_by_type_.Get();
}
inline void TagEvent::_internal_set_created_by_type(const std::string& value) {
  
  _impl_.created_by_type_.Set(value, GetArenaForAllocation());
}
inline std::string* TagEvent::_internal_mutable_created_by_type() {
  
  return _impl_.created_by_type_.Mutable(GetArenaForAllocation());
}
inline std::string* TagEvent::release_created_by_type() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.TagEvent.created_by_type)
  return _impl_.created_by_type_.Release();
}
inline void TagEvent::set_allocated_created_by_type(std::string* created_by_type) {
  if (created_by_type != nullptr) {
    
  } else {
    
  }
  _impl_.created_by_type_.SetAllocated(created_by_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.created_by_type_.IsDefault()) {
    _impl_.created_by_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.TagEvent.created_by_type)
}

// string session_id = 9;
inline void TagEvent::clear_session_id() {
  _impl_.session_id_.ClearToEmpty();
}
inline const std::string& TagEvent::session_id() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.TagEvent.session_id)
  return _internal_session_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TagEvent::set_session_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.session_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.document_store.TagEvent.session_id)
}
inline std::string* TagEvent::mutable_session_id() {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.TagEvent.session_id)
  return _s;
}
inline const std::string& TagEvent::_internal_session_id() const {
  return _impl_.session_id_.Get();
}
inline void TagEvent::_internal_set_session_id(const std::string& value) {
  
  _impl_.session_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TagEvent::_internal_mutable_session_id() {
  
  return _impl_.session_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TagEvent::release_session_id() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.TagEvent.session_id)
  return _impl_.session_id_.Release();
}
inline void TagEvent::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  _impl_.session_id_.SetAllocated(session_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.session_id_.IsDefault()) {
    _impl_.session_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.TagEvent.session_id)
}

// -------------------------------------------------------------------

// PutDocumentRequest

// .unhinged.document_store.Document document = 1;
inline bool PutDocumentRequest::_internal_has_document() const {
  return this != internal_default_instance() && _impl_.document_ != nullptr;
}
inline bool PutDocumentRequest::has_document() const {
  return _internal_has_document();
}
inline void PutDocumentRequest::clear_document() {
  if (GetArenaForAllocation() == nullptr && _impl_.document_ != nullptr) {
    delete _impl_.document_;
  }
  _impl_.document_ = nullptr;
}
inline const ::unhinged::document_store::Document& PutDocumentRequest::_internal_document() const {
  const ::unhinged::document_store::Document* p = _impl_.document_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::document_store::Document&>(
      ::unhinged::document_store::_Document_default_instance_);
}
inline const ::unhinged::document_store::Document& PutDocumentRequest::document() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.PutDocumentRequest.document)
  return _internal_document();
}
inline void PutDocumentRequest::unsafe_arena_set_allocated_document(
    ::unhinged::document_store::Document* document) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.document_);
  }
  _impl_.document_ = document;
  if (document) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.document_store.PutDocumentRequest.document)
}
inline ::unhinged::document_store::Document* PutDocumentRequest::release_document() {
  
  ::unhinged::document_store::Document* temp = _impl_.document_;
  _impl_.document_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::document_store::Document* PutDocumentRequest::unsafe_arena_release_document() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.PutDocumentRequest.document)
  
  ::unhinged::document_store::Document* temp = _impl_.document_;
  _impl_.document_ = nullptr;
  return temp;
}
inline ::unhinged::document_store::Document* PutDocumentRequest::_internal_mutable_document() {
  
  if (_impl_.document_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::document_store::Document>(GetArenaForAllocation());
    _impl_.document_ = p;
  }
  return _impl_.document_;
}
inline ::unhinged::document_store::Document* PutDocumentRequest::mutable_document() {
  ::unhinged::document_store::Document* _msg = _internal_mutable_document();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.PutDocumentRequest.document)
  return _msg;
}
inline void PutDocumentRequest::set_allocated_document(::unhinged::document_store::Document* document) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.document_;
  }
  if (document) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(document);
    if (message_arena != submessage_arena) {
      document = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, document, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.document_ = document;
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.PutDocumentRequest.document)
}

// -------------------------------------------------------------------

// PutDocumentResponse

// bool success = 1;
inline void PutDocumentResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool PutDocumentResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool PutDocumentResponse::success() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.PutDocumentResponse.success)
  return _internal_success();
}
inline void PutDocumentResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void PutDocumentResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:unhinged.document_store.PutDocumentResponse.success)
}

// string message = 2;
inline void PutDocumentResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& PutDocumentResponse::message() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.PutDocumentResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PutDocumentResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.document_store.PutDocumentResponse.message)
}
inline std::string* PutDocumentResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.PutDocumentResponse.message)
  return _s;
}
inline const std::string& PutDocumentResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void PutDocumentResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* PutDocumentResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* PutDocumentResponse::release_message() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.PutDocumentResponse.message)
  return _impl_.message_.Release();
}
inline void PutDocumentResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.PutDocumentResponse.message)
}

// string document_uuid = 3;
inline void PutDocumentResponse::clear_document_uuid() {
  _impl_.document_uuid_.ClearToEmpty();
}
inline const std::string& PutDocumentResponse::document_uuid() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.PutDocumentResponse.document_uuid)
  return _internal_document_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PutDocumentResponse::set_document_uuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.document_uuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.document_store.PutDocumentResponse.document_uuid)
}
inline std::string* PutDocumentResponse::mutable_document_uuid() {
  std::string* _s = _internal_mutable_document_uuid();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.PutDocumentResponse.document_uuid)
  return _s;
}
inline const std::string& PutDocumentResponse::_internal_document_uuid() const {
  return _impl_.document_uuid_.Get();
}
inline void PutDocumentResponse::_internal_set_document_uuid(const std::string& value) {
  
  _impl_.document_uuid_.Set(value, GetArenaForAllocation());
}
inline std::string* PutDocumentResponse::_internal_mutable_document_uuid() {
  
  return _impl_.document_uuid_.Mutable(GetArenaForAllocation());
}
inline std::string* PutDocumentResponse::release_document_uuid() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.PutDocumentResponse.document_uuid)
  return _impl_.document_uuid_.Release();
}
inline void PutDocumentResponse::set_allocated_document_uuid(std::string* document_uuid) {
  if (document_uuid != nullptr) {
    
  } else {
    
  }
  _impl_.document_uuid_.SetAllocated(document_uuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.document_uuid_.IsDefault()) {
    _impl_.document_uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.PutDocumentResponse.document_uuid)
}

// int32 version = 4;
inline void PutDocumentResponse::clear_version() {
  _impl_.version_ = 0;
}
inline int32_t PutDocumentResponse::_internal_version() const {
  return _impl_.version_;
}
inline int32_t PutDocumentResponse::version() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.PutDocumentResponse.version)
  return _internal_version();
}
inline void PutDocumentResponse::_internal_set_version(int32_t value) {
  
  _impl_.version_ = value;
}
inline void PutDocumentResponse::set_version(int32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:unhinged.document_store.PutDocumentResponse.version)
}

// -------------------------------------------------------------------

// PutDocumentsRequest

// repeated .unhinged.document_store.Document documents = 1;
inline int PutDocumentsRequest::_internal_documents_size() const {
  return _impl_.documents_.size();
}
inline int PutDocumentsRequest::documents_size() const {
  return _internal_documents_size();
}
inline void PutDocumentsRequest::clear_documents() {
  _impl_.documents_.Clear();
}
inline ::unhinged::document_store::Document* PutDocumentsRequest::mutable_documents(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.PutDocumentsRequest.documents)
  return _impl_.documents_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::document_store::Document >*
PutDocumentsRequest::mutable_documents() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.document_store.PutDocumentsRequest.documents)
  return &_impl_.documents_;
}
inline const ::unhinged::document_store::Document& PutDocumentsRequest::_internal_documents(int index) const {
  return _impl_.documents_.Get(index);
}
inline const ::unhinged::document_store::Document& PutDocumentsRequest::documents(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.PutDocumentsRequest.documents)
  return _internal_documents(index);
}
inline ::unhinged::document_store::Document* PutDocumentsRequest::_internal_add_documents() {
  return _impl_.documents_.Add();
}
inline ::unhinged::document_store::Document* PutDocumentsRequest::add_documents() {
  ::unhinged::document_store::Document* _add = _internal_add_documents();
  // @@protoc_insertion_point(field_add:unhinged.document_store.PutDocumentsRequest.documents)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::document_store::Document >&
PutDocumentsRequest::documents() const {
  // @@protoc_insertion_point(field_list:unhinged.document_store.PutDocumentsRequest.documents)
  return _impl_.documents_;
}

// -------------------------------------------------------------------

// PutDocumentReceipt

// string document_uuid = 1;
inline void PutDocumentReceipt::clear_document_uuid() {
  _impl_.document_uuid_.ClearToEmpty();
}
inline const std::string& PutDocumentReceipt::document_uuid() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.PutDocumentReceipt.document_uuid)
  return _internal_document_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PutDocumentReceipt::set_document_uuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.document_uuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.document_store.PutDocumentReceipt.document_uuid)
}
inline std::string* PutDocumentReceipt::mutable_document_uuid() {
  std::string* _s = _internal_mutable_document_uuid();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.PutDocumentReceipt.document_uuid)
  return _s;
}
inline const std::string& PutDocumentReceipt::_internal_document_uuid() const {
  return _impl_.document_uuid_.Get();
}
inline void PutDocumentReceipt::_internal_set_document_uuid(const std::string& value) {
  
  _impl_.document_uuid_.Set(value, GetArenaForAllocation());
}
inline std::string* PutDocumentReceipt::_internal_mutable_document_uuid() {
  
  return _impl_.document_uuid_.Mutable(GetArenaForAllocation());
}
inline std::string* PutDocumentReceipt::release_document_uuid() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.PutDocumentReceipt.document_uuid)
  return _impl_.document_uuid_.Release();
}
inline void PutDocumentReceipt::set_allocated_document_uuid(std::string* document_uuid) {
  if (document_uuid != nullptr) {
    
  } else {
    
  }
  _impl_.document_uuid_.SetAllocated(document_uuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.document_uuid_.IsDefault()) {
    _impl_.document_uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.PutDocumentReceipt.document_uuid)
}

// int32 version = 2;
inline void PutDocumentReceipt::clear_version() {
  _impl_.version_ = 0;
}
inline int32_t PutDocumentReceipt::_internal_version() const {
  return _impl_.version_;
}
inline int32_t PutDocumentReceipt::version() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.PutDocumentReceipt.version)
  return _internal_version();
}
inline void PutDocumentReceipt::_internal_set_version(int32_t value) {
  
  _impl_.version_ = value;
}
inline void PutDocumentReceipt::set_version(int32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:unhinged.document_store.PutDocumentReceipt.version)
}

// bool success = 3;
inline void PutDocumentReceipt::clear_success() {
  _impl_.success_ = false;
}
inline bool PutDocumentReceipt::_internal_success() const {
  return _impl_.success_;
}
inline bool PutDocumentReceipt::success() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.PutDocumentReceipt.success)
  return _internal_success();
}
inline void PutDocumentReceipt::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void PutDocumentReceipt::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:unhinged.document_store.PutDocumentReceipt.success)
}

// string error_message = 4;
inline void PutDocumentReceipt::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& PutDocumentReceipt::error_message() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.PutDocumentReceipt.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PutDocumentReceipt::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.document_store.PutDocumentReceipt.error_message)
}
inline std::string* PutDocumentReceipt::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.PutDocumentReceipt.error_message)
  return _s;
}
inline const std::string& PutDocumentReceipt::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void PutDocumentReceipt::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* PutDocumentReceipt::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* PutDocumentReceipt::release_error_message() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.PutDocumentReceipt.error_message)
  return _impl_.error_message_.Release();
}
inline void PutDocumentReceipt::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.PutDocumentReceipt.error_message)
}

// -------------------------------------------------------------------

// PutDocumentsResponse

// bool success = 1;
inline void PutDocumentsResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool PutDocumentsResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool PutDocumentsResponse::success() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.PutDocumentsResponse.success)
  return _internal_success();
}
inline void PutDocumentsResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void PutDocumentsResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:unhinged.document_store.PutDocumentsResponse.success)
}

// string message = 2;
inline void PutDocumentsResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& PutDocumentsResponse::message() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.PutDocumentsResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PutDocumentsResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.document_store.PutDocumentsResponse.message)
}
inline std::string* PutDocumentsResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.PutDocumentsResponse.message)
  return _s;
}
inline const std::string& PutDocumentsResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void PutDocumentsResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* PutDocumentsResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* PutDocumentsResponse::release_message() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.PutDocumentsResponse.message)
  return _impl_.message_.Release();
}
inline void PutDocumentsResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.PutDocumentsResponse.message)
}

// repeated .unhinged.document_store.PutDocumentReceipt receipts = 3;
inline int PutDocumentsResponse::_internal_receipts_size() const {
  return _impl_.receipts_.size();
}
inline int PutDocumentsResponse::receipts_size() const {
  return _internal_receipts_size();
}
inline void PutDocumentsResponse::clear_receipts() {
  _impl_.receipts_.Clear();
}
inline ::unhinged::document_store::PutDocumentReceipt* PutDocumentsResponse::mutable_receipts(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.PutDocumentsResponse.receipts)
  return _impl_.receipts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::document_store::PutDocumentReceipt >*
PutDocumentsResponse::mutable_receipts() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.document_store.PutDocumentsResponse.receipts)
  return &_impl_.receipts_;
}
inline const ::unhinged::document_store::PutDocumentReceipt& PutDocumentsResponse::_internal_receipts(int index) const {
  return _impl_.receipts_.Get(index);
}
inline const ::unhinged::document_store::PutDocumentReceipt& PutDocumentsResponse::receipts(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.PutDocumentsResponse.receipts)
  return _internal_receipts(index);
}
inline ::unhinged::document_store::PutDocumentReceipt* PutDocumentsResponse::_internal_add_receipts() {
  return _impl_.receipts_.Add();
}
inline ::unhinged::document_store::PutDocumentReceipt* PutDocumentsResponse::add_receipts() {
  ::unhinged::document_store::PutDocumentReceipt* _add = _internal_add_receipts();
  // @@protoc_insertion_point(field_add:unhinged.document_store.PutDocumentsResponse.receipts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::document_store::PutDocumentReceipt >&
PutDocumentsResponse::receipts() const {
  // @@protoc_insertion_point(field_list:unhinged.document_store.PutDocumentsResponse.receipts)
  return _impl_.receipts_;
}

// -------------------------------------------------------------------

// GetDocumentRequest

// string document_uuid = 1;
inline void GetDocumentRequest::clear_document_uuid() {
  _impl_.document_uuid_.ClearToEmpty();
}
inline const std::string& GetDocumentRequest::document_uuid() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.GetDocumentRequest.document_uuid)
  return _internal_document_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetDocumentRequest::set_document_uuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.document_uuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.document_store.GetDocumentRequest.document_uuid)
}
inline std::string* GetDocumentRequest::mutable_document_uuid() {
  std::string* _s = _internal_mutable_document_uuid();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.GetDocumentRequest.document_uuid)
  return _s;
}
inline const std::string& GetDocumentRequest::_internal_document_uuid() const {
  return _impl_.document_uuid_.Get();
}
inline void GetDocumentRequest::_internal_set_document_uuid(const std::string& value) {
  
  _impl_.document_uuid_.Set(value, GetArenaForAllocation());
}
inline std::string* GetDocumentRequest::_internal_mutable_document_uuid() {
  
  return _impl_.document_uuid_.Mutable(GetArenaForAllocation());
}
inline std::string* GetDocumentRequest::release_document_uuid() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.GetDocumentRequest.document_uuid)
  return _impl_.document_uuid_.Release();
}
inline void GetDocumentRequest::set_allocated_document_uuid(std::string* document_uuid) {
  if (document_uuid != nullptr) {
    
  } else {
    
  }
  _impl_.document_uuid_.SetAllocated(document_uuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.document_uuid_.IsDefault()) {
    _impl_.document_uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.GetDocumentRequest.document_uuid)
}

// optional int32 version = 2;
inline bool GetDocumentRequest::_internal_has_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GetDocumentRequest::has_version() const {
  return _internal_has_version();
}
inline void GetDocumentRequest::clear_version() {
  _impl_.version_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t GetDocumentRequest::_internal_version() const {
  return _impl_.version_;
}
inline int32_t GetDocumentRequest::version() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.GetDocumentRequest.version)
  return _internal_version();
}
inline void GetDocumentRequest::_internal_set_version(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.version_ = value;
}
inline void GetDocumentRequest::set_version(int32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:unhinged.document_store.GetDocumentRequest.version)
}

// optional string tag = 3;
inline bool GetDocumentRequest::_internal_has_tag() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetDocumentRequest::has_tag() const {
  return _internal_has_tag();
}
inline void GetDocumentRequest::clear_tag() {
  _impl_.tag_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetDocumentRequest::tag() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.GetDocumentRequest.tag)
  return _internal_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetDocumentRequest::set_tag(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.tag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.document_store.GetDocumentRequest.tag)
}
inline std::string* GetDocumentRequest::mutable_tag() {
  std::string* _s = _internal_mutable_tag();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.GetDocumentRequest.tag)
  return _s;
}
inline const std::string& GetDocumentRequest::_internal_tag() const {
  return _impl_.tag_.Get();
}
inline void GetDocumentRequest::_internal_set_tag(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.tag_.Set(value, GetArenaForAllocation());
}
inline std::string* GetDocumentRequest::_internal_mutable_tag() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.tag_.Mutable(GetArenaForAllocation());
}
inline std::string* GetDocumentRequest::release_tag() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.GetDocumentRequest.tag)
  if (!_internal_has_tag()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.tag_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tag_.IsDefault()) {
    _impl_.tag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetDocumentRequest::set_allocated_tag(std::string* tag) {
  if (tag != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.tag_.SetAllocated(tag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tag_.IsDefault()) {
    _impl_.tag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.GetDocumentRequest.tag)
}

// bool include_body = 4;
inline void GetDocumentRequest::clear_include_body() {
  _impl_.include_body_ = false;
}
inline bool GetDocumentRequest::_internal_include_body() const {
  return _impl_.include_body_;
}
inline bool GetDocumentRequest::include_body() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.GetDocumentRequest.include_body)
  return _internal_include_body();
}
inline void GetDocumentRequest::_internal_set_include_body(bool value) {
  
  _impl_.include_body_ = value;
}
inline void GetDocumentRequest::set_include_body(bool value) {
  _internal_set_include_body(value);
  // @@protoc_insertion_point(field_set:unhinged.document_store.GetDocumentRequest.include_body)
}

// -------------------------------------------------------------------

// GetDocumentResponse

// bool success = 1;
inline void GetDocumentResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool GetDocumentResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool GetDocumentResponse::success() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.GetDocumentResponse.success)
  return _internal_success();
}
inline void GetDocumentResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void GetDocumentResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:unhinged.document_store.GetDocumentResponse.success)
}

// string message = 2;
inline void GetDocumentResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& GetDocumentResponse::message() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.GetDocumentResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetDocumentResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.document_store.GetDocumentResponse.message)
}
inline std::string* GetDocumentResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.GetDocumentResponse.message)
  return _s;
}
inline const std::string& GetDocumentResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void GetDocumentResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* GetDocumentResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* GetDocumentResponse::release_message() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.GetDocumentResponse.message)
  return _impl_.message_.Release();
}
inline void GetDocumentResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.GetDocumentResponse.message)
}

// .unhinged.document_store.Document document = 3;
inline bool GetDocumentResponse::_internal_has_document() const {
  return this != internal_default_instance() && _impl_.document_ != nullptr;
}
inline bool GetDocumentResponse::has_document() const {
  return _internal_has_document();
}
inline void GetDocumentResponse::clear_document() {
  if (GetArenaForAllocation() == nullptr && _impl_.document_ != nullptr) {
    delete _impl_.document_;
  }
  _impl_.document_ = nullptr;
}
inline const ::unhinged::document_store::Document& GetDocumentResponse::_internal_document() const {
  const ::unhinged::document_store::Document* p = _impl_.document_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::document_store::Document&>(
      ::unhinged::document_store::_Document_default_instance_);
}
inline const ::unhinged::document_store::Document& GetDocumentResponse::document() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.GetDocumentResponse.document)
  return _internal_document();
}
inline void GetDocumentResponse::unsafe_arena_set_allocated_document(
    ::unhinged::document_store::Document* document) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.document_);
  }
  _impl_.document_ = document;
  if (document) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.document_store.GetDocumentResponse.document)
}
inline ::unhinged::document_store::Document* GetDocumentResponse::release_document() {
  
  ::unhinged::document_store::Document* temp = _impl_.document_;
  _impl_.document_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::document_store::Document* GetDocumentResponse::unsafe_arena_release_document() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.GetDocumentResponse.document)
  
  ::unhinged::document_store::Document* temp = _impl_.document_;
  _impl_.document_ = nullptr;
  return temp;
}
inline ::unhinged::document_store::Document* GetDocumentResponse::_internal_mutable_document() {
  
  if (_impl_.document_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::document_store::Document>(GetArenaForAllocation());
    _impl_.document_ = p;
  }
  return _impl_.document_;
}
inline ::unhinged::document_store::Document* GetDocumentResponse::mutable_document() {
  ::unhinged::document_store::Document* _msg = _internal_mutable_document();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.GetDocumentResponse.document)
  return _msg;
}
inline void GetDocumentResponse::set_allocated_document(::unhinged::document_store::Document* document) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.document_;
  }
  if (document) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(document);
    if (message_arena != submessage_arena) {
      document = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, document, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.document_ = document;
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.GetDocumentResponse.document)
}

// -------------------------------------------------------------------

// ListDocumentsRequest

// optional string namespace = 1;
inline bool ListDocumentsRequest::_internal_has_namespace_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ListDocumentsRequest::has_namespace_() const {
  return _internal_has_namespace_();
}
inline void ListDocumentsRequest::clear_namespace_() {
  _impl_.namespace__.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ListDocumentsRequest::namespace_() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.ListDocumentsRequest.namespace)
  return _internal_namespace_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListDocumentsRequest::set_namespace_(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.namespace__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.document_store.ListDocumentsRequest.namespace)
}
inline std::string* ListDocumentsRequest::mutable_namespace_() {
  std::string* _s = _internal_mutable_namespace_();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.ListDocumentsRequest.namespace)
  return _s;
}
inline const std::string& ListDocumentsRequest::_internal_namespace_() const {
  return _impl_.namespace__.Get();
}
inline void ListDocumentsRequest::_internal_set_namespace_(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.namespace__.Set(value, GetArenaForAllocation());
}
inline std::string* ListDocumentsRequest::_internal_mutable_namespace_() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.namespace__.Mutable(GetArenaForAllocation());
}
inline std::string* ListDocumentsRequest::release_namespace_() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.ListDocumentsRequest.namespace)
  if (!_internal_has_namespace_()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.namespace__.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.namespace__.IsDefault()) {
    _impl_.namespace__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ListDocumentsRequest::set_allocated_namespace_(std::string* namespace_) {
  if (namespace_ != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.namespace__.SetAllocated(namespace_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.namespace__.IsDefault()) {
    _impl_.namespace__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.ListDocumentsRequest.namespace)
}

// optional string type = 2;
inline bool ListDocumentsRequest::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ListDocumentsRequest::has_type() const {
  return _internal_has_type();
}
inline void ListDocumentsRequest::clear_type() {
  _impl_.type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ListDocumentsRequest::type() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.ListDocumentsRequest.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListDocumentsRequest::set_type(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.document_store.ListDocumentsRequest.type)
}
inline std::string* ListDocumentsRequest::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.ListDocumentsRequest.type)
  return _s;
}
inline const std::string& ListDocumentsRequest::_internal_type() const {
  return _impl_.type_.Get();
}
inline void ListDocumentsRequest::_internal_set_type(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* ListDocumentsRequest::_internal_mutable_type() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* ListDocumentsRequest::release_type() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.ListDocumentsRequest.type)
  if (!_internal_has_type()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.type_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ListDocumentsRequest::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.ListDocumentsRequest.type)
}

// optional string tag = 3;
inline bool ListDocumentsRequest::_internal_has_tag() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ListDocumentsRequest::has_tag() const {
  return _internal_has_tag();
}
inline void ListDocumentsRequest::clear_tag() {
  _impl_.tag_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ListDocumentsRequest::tag() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.ListDocumentsRequest.tag)
  return _internal_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListDocumentsRequest::set_tag(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.tag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.document_store.ListDocumentsRequest.tag)
}
inline std::string* ListDocumentsRequest::mutable_tag() {
  std::string* _s = _internal_mutable_tag();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.ListDocumentsRequest.tag)
  return _s;
}
inline const std::string& ListDocumentsRequest::_internal_tag() const {
  return _impl_.tag_.Get();
}
inline void ListDocumentsRequest::_internal_set_tag(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.tag_.Set(value, GetArenaForAllocation());
}
inline std::string* ListDocumentsRequest::_internal_mutable_tag() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.tag_.Mutable(GetArenaForAllocation());
}
inline std::string* ListDocumentsRequest::release_tag() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.ListDocumentsRequest.tag)
  if (!_internal_has_tag()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.tag_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tag_.IsDefault()) {
    _impl_.tag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ListDocumentsRequest::set_allocated_tag(std::string* tag) {
  if (tag != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.tag_.SetAllocated(tag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tag_.IsDefault()) {
    _impl_.tag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.ListDocumentsRequest.tag)
}

// optional string session_id = 4;
inline bool ListDocumentsRequest::_internal_has_session_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ListDocumentsRequest::has_session_id() const {
  return _internal_has_session_id();
}
inline void ListDocumentsRequest::clear_session_id() {
  _impl_.session_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ListDocumentsRequest::session_id() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.ListDocumentsRequest.session_id)
  return _internal_session_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListDocumentsRequest::set_session_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.session_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.document_store.ListDocumentsRequest.session_id)
}
inline std::string* ListDocumentsRequest::mutable_session_id() {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.ListDocumentsRequest.session_id)
  return _s;
}
inline const std::string& ListDocumentsRequest::_internal_session_id() const {
  return _impl_.session_id_.Get();
}
inline void ListDocumentsRequest::_internal_set_session_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.session_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ListDocumentsRequest::_internal_mutable_session_id() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.session_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ListDocumentsRequest::release_session_id() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.ListDocumentsRequest.session_id)
  if (!_internal_has_session_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.session_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.session_id_.IsDefault()) {
    _impl_.session_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ListDocumentsRequest::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.session_id_.SetAllocated(session_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.session_id_.IsDefault()) {
    _impl_.session_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.ListDocumentsRequest.session_id)
}

// optional .google.protobuf.Timestamp pagination_token = 5;
inline bool ListDocumentsRequest::_internal_has_pagination_token() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pagination_token_ != nullptr);
  return value;
}
inline bool ListDocumentsRequest::has_pagination_token() const {
  return _internal_has_pagination_token();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ListDocumentsRequest::_internal_pagination_token() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.pagination_token_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ListDocumentsRequest::pagination_token() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.ListDocumentsRequest.pagination_token)
  return _internal_pagination_token();
}
inline void ListDocumentsRequest::unsafe_arena_set_allocated_pagination_token(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* pagination_token) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pagination_token_);
  }
  _impl_.pagination_token_ = pagination_token;
  if (pagination_token) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.document_store.ListDocumentsRequest.pagination_token)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ListDocumentsRequest::release_pagination_token() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.pagination_token_;
  _impl_.pagination_token_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ListDocumentsRequest::unsafe_arena_release_pagination_token() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.ListDocumentsRequest.pagination_token)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.pagination_token_;
  _impl_.pagination_token_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ListDocumentsRequest::_internal_mutable_pagination_token() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.pagination_token_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.pagination_token_ = p;
  }
  return _impl_.pagination_token_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ListDocumentsRequest::mutable_pagination_token() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_pagination_token();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.ListDocumentsRequest.pagination_token)
  return _msg;
}
inline void ListDocumentsRequest::set_allocated_pagination_token(::PROTOBUF_NAMESPACE_ID::Timestamp* pagination_token) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pagination_token_);
  }
  if (pagination_token) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pagination_token));
    if (message_arena != submessage_arena) {
      pagination_token = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pagination_token, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.pagination_token_ = pagination_token;
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.ListDocumentsRequest.pagination_token)
}

// int32 page_size = 6;
inline void ListDocumentsRequest::clear_page_size() {
  _impl_.page_size_ = 0;
}
inline int32_t ListDocumentsRequest::_internal_page_size() const {
  return _impl_.page_size_;
}
inline int32_t ListDocumentsRequest::page_size() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.ListDocumentsRequest.page_size)
  return _internal_page_size();
}
inline void ListDocumentsRequest::_internal_set_page_size(int32_t value) {
  
  _impl_.page_size_ = value;
}
inline void ListDocumentsRequest::set_page_size(int32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:unhinged.document_store.ListDocumentsRequest.page_size)
}

// bool include_body = 7;
inline void ListDocumentsRequest::clear_include_body() {
  _impl_.include_body_ = false;
}
inline bool ListDocumentsRequest::_internal_include_body() const {
  return _impl_.include_body_;
}
inline bool ListDocumentsRequest::include_body() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.ListDocumentsRequest.include_body)
  return _internal_include_body();
}
inline void ListDocumentsRequest::_internal_set_include_body(bool value) {
  
  _impl_.include_body_ = value;
}
inline void ListDocumentsRequest::set_include_body(bool value) {
  _internal_set_include_body(value);
  // @@protoc_insertion_point(field_set:unhinged.document_store.ListDocumentsRequest.include_body)
}

// bool latest_versions_only = 8;
inline void ListDocumentsRequest::clear_latest_versions_only() {
  _impl_.latest_versions_only_ = false;
}
inline bool ListDocumentsRequest::_internal_latest_versions_only() const {
  return _impl_.latest_versions_only_;
}
inline bool ListDocumentsRequest::latest_versions_only() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.ListDocumentsRequest.latest_versions_only)
  return _internal_latest_versions_only();
}
inline void ListDocumentsRequest::_internal_set_latest_versions_only(bool value) {
  
  _impl_.latest_versions_only_ = value;
}
inline void ListDocumentsRequest::set_latest_versions_only(bool value) {
  _internal_set_latest_versions_only(value);
  // @@protoc_insertion_point(field_set:unhinged.document_store.ListDocumentsRequest.latest_versions_only)
}

// -------------------------------------------------------------------

// ListDocumentsResponse

// bool success = 1;
inline void ListDocumentsResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool ListDocumentsResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool ListDocumentsResponse::success() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.ListDocumentsResponse.success)
  return _internal_success();
}
inline void ListDocumentsResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void ListDocumentsResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:unhinged.document_store.ListDocumentsResponse.success)
}

// string message = 2;
inline void ListDocumentsResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& ListDocumentsResponse::message() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.ListDocumentsResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListDocumentsResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.document_store.ListDocumentsResponse.message)
}
inline std::string* ListDocumentsResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.ListDocumentsResponse.message)
  return _s;
}
inline const std::string& ListDocumentsResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void ListDocumentsResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* ListDocumentsResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* ListDocumentsResponse::release_message() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.ListDocumentsResponse.message)
  return _impl_.message_.Release();
}
inline void ListDocumentsResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.ListDocumentsResponse.message)
}

// repeated .unhinged.document_store.Document documents = 3;
inline int ListDocumentsResponse::_internal_documents_size() const {
  return _impl_.documents_.size();
}
inline int ListDocumentsResponse::documents_size() const {
  return _internal_documents_size();
}
inline void ListDocumentsResponse::clear_documents() {
  _impl_.documents_.Clear();
}
inline ::unhinged::document_store::Document* ListDocumentsResponse::mutable_documents(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.ListDocumentsResponse.documents)
  return _impl_.documents_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::document_store::Document >*
ListDocumentsResponse::mutable_documents() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.document_store.ListDocumentsResponse.documents)
  return &_impl_.documents_;
}
inline const ::unhinged::document_store::Document& ListDocumentsResponse::_internal_documents(int index) const {
  return _impl_.documents_.Get(index);
}
inline const ::unhinged::document_store::Document& ListDocumentsResponse::documents(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.ListDocumentsResponse.documents)
  return _internal_documents(index);
}
inline ::unhinged::document_store::Document* ListDocumentsResponse::_internal_add_documents() {
  return _impl_.documents_.Add();
}
inline ::unhinged::document_store::Document* ListDocumentsResponse::add_documents() {
  ::unhinged::document_store::Document* _add = _internal_add_documents();
  // @@protoc_insertion_point(field_add:unhinged.document_store.ListDocumentsResponse.documents)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::document_store::Document >&
ListDocumentsResponse::documents() const {
  // @@protoc_insertion_point(field_list:unhinged.document_store.ListDocumentsResponse.documents)
  return _impl_.documents_;
}

// .google.protobuf.Timestamp next_pagination_token = 4;
inline bool ListDocumentsResponse::_internal_has_next_pagination_token() const {
  return this != internal_default_instance() && _impl_.next_pagination_token_ != nullptr;
}
inline bool ListDocumentsResponse::has_next_pagination_token() const {
  return _internal_has_next_pagination_token();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ListDocumentsResponse::_internal_next_pagination_token() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.next_pagination_token_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ListDocumentsResponse::next_pagination_token() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.ListDocumentsResponse.next_pagination_token)
  return _internal_next_pagination_token();
}
inline void ListDocumentsResponse::unsafe_arena_set_allocated_next_pagination_token(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* next_pagination_token) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.next_pagination_token_);
  }
  _impl_.next_pagination_token_ = next_pagination_token;
  if (next_pagination_token) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.document_store.ListDocumentsResponse.next_pagination_token)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ListDocumentsResponse::release_next_pagination_token() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.next_pagination_token_;
  _impl_.next_pagination_token_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ListDocumentsResponse::unsafe_arena_release_next_pagination_token() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.ListDocumentsResponse.next_pagination_token)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.next_pagination_token_;
  _impl_.next_pagination_token_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ListDocumentsResponse::_internal_mutable_next_pagination_token() {
  
  if (_impl_.next_pagination_token_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.next_pagination_token_ = p;
  }
  return _impl_.next_pagination_token_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ListDocumentsResponse::mutable_next_pagination_token() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_next_pagination_token();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.ListDocumentsResponse.next_pagination_token)
  return _msg;
}
inline void ListDocumentsResponse::set_allocated_next_pagination_token(::PROTOBUF_NAMESPACE_ID::Timestamp* next_pagination_token) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.next_pagination_token_);
  }
  if (next_pagination_token) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(next_pagination_token));
    if (message_arena != submessage_arena) {
      next_pagination_token = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, next_pagination_token, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.next_pagination_token_ = next_pagination_token;
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.ListDocumentsResponse.next_pagination_token)
}

// int32 total_count = 5;
inline void ListDocumentsResponse::clear_total_count() {
  _impl_.total_count_ = 0;
}
inline int32_t ListDocumentsResponse::_internal_total_count() const {
  return _impl_.total_count_;
}
inline int32_t ListDocumentsResponse::total_count() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.ListDocumentsResponse.total_count)
  return _internal_total_count();
}
inline void ListDocumentsResponse::_internal_set_total_count(int32_t value) {
  
  _impl_.total_count_ = value;
}
inline void ListDocumentsResponse::set_total_count(int32_t value) {
  _internal_set_total_count(value);
  // @@protoc_insertion_point(field_set:unhinged.document_store.ListDocumentsResponse.total_count)
}

// -------------------------------------------------------------------

// ListDocumentVersionsRequest

// string document_uuid = 1;
inline void ListDocumentVersionsRequest::clear_document_uuid() {
  _impl_.document_uuid_.ClearToEmpty();
}
inline const std::string& ListDocumentVersionsRequest::document_uuid() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.ListDocumentVersionsRequest.document_uuid)
  return _internal_document_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListDocumentVersionsRequest::set_document_uuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.document_uuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.document_store.ListDocumentVersionsRequest.document_uuid)
}
inline std::string* ListDocumentVersionsRequest::mutable_document_uuid() {
  std::string* _s = _internal_mutable_document_uuid();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.ListDocumentVersionsRequest.document_uuid)
  return _s;
}
inline const std::string& ListDocumentVersionsRequest::_internal_document_uuid() const {
  return _impl_.document_uuid_.Get();
}
inline void ListDocumentVersionsRequest::_internal_set_document_uuid(const std::string& value) {
  
  _impl_.document_uuid_.Set(value, GetArenaForAllocation());
}
inline std::string* ListDocumentVersionsRequest::_internal_mutable_document_uuid() {
  
  return _impl_.document_uuid_.Mutable(GetArenaForAllocation());
}
inline std::string* ListDocumentVersionsRequest::release_document_uuid() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.ListDocumentVersionsRequest.document_uuid)
  return _impl_.document_uuid_.Release();
}
inline void ListDocumentVersionsRequest::set_allocated_document_uuid(std::string* document_uuid) {
  if (document_uuid != nullptr) {
    
  } else {
    
  }
  _impl_.document_uuid_.SetAllocated(document_uuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.document_uuid_.IsDefault()) {
    _impl_.document_uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.ListDocumentVersionsRequest.document_uuid)
}

// optional .google.protobuf.Timestamp pagination_token = 2;
inline bool ListDocumentVersionsRequest::_internal_has_pagination_token() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pagination_token_ != nullptr);
  return value;
}
inline bool ListDocumentVersionsRequest::has_pagination_token() const {
  return _internal_has_pagination_token();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ListDocumentVersionsRequest::_internal_pagination_token() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.pagination_token_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ListDocumentVersionsRequest::pagination_token() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.ListDocumentVersionsRequest.pagination_token)
  return _internal_pagination_token();
}
inline void ListDocumentVersionsRequest::unsafe_arena_set_allocated_pagination_token(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* pagination_token) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pagination_token_);
  }
  _impl_.pagination_token_ = pagination_token;
  if (pagination_token) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.document_store.ListDocumentVersionsRequest.pagination_token)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ListDocumentVersionsRequest::release_pagination_token() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.pagination_token_;
  _impl_.pagination_token_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ListDocumentVersionsRequest::unsafe_arena_release_pagination_token() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.ListDocumentVersionsRequest.pagination_token)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.pagination_token_;
  _impl_.pagination_token_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ListDocumentVersionsRequest::_internal_mutable_pagination_token() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.pagination_token_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.pagination_token_ = p;
  }
  return _impl_.pagination_token_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ListDocumentVersionsRequest::mutable_pagination_token() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_pagination_token();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.ListDocumentVersionsRequest.pagination_token)
  return _msg;
}
inline void ListDocumentVersionsRequest::set_allocated_pagination_token(::PROTOBUF_NAMESPACE_ID::Timestamp* pagination_token) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pagination_token_);
  }
  if (pagination_token) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pagination_token));
    if (message_arena != submessage_arena) {
      pagination_token = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pagination_token, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.pagination_token_ = pagination_token;
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.ListDocumentVersionsRequest.pagination_token)
}

// int32 page_size = 3;
inline void ListDocumentVersionsRequest::clear_page_size() {
  _impl_.page_size_ = 0;
}
inline int32_t ListDocumentVersionsRequest::_internal_page_size() const {
  return _impl_.page_size_;
}
inline int32_t ListDocumentVersionsRequest::page_size() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.ListDocumentVersionsRequest.page_size)
  return _internal_page_size();
}
inline void ListDocumentVersionsRequest::_internal_set_page_size(int32_t value) {
  
  _impl_.page_size_ = value;
}
inline void ListDocumentVersionsRequest::set_page_size(int32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:unhinged.document_store.ListDocumentVersionsRequest.page_size)
}

// bool include_body = 4;
inline void ListDocumentVersionsRequest::clear_include_body() {
  _impl_.include_body_ = false;
}
inline bool ListDocumentVersionsRequest::_internal_include_body() const {
  return _impl_.include_body_;
}
inline bool ListDocumentVersionsRequest::include_body() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.ListDocumentVersionsRequest.include_body)
  return _internal_include_body();
}
inline void ListDocumentVersionsRequest::_internal_set_include_body(bool value) {
  
  _impl_.include_body_ = value;
}
inline void ListDocumentVersionsRequest::set_include_body(bool value) {
  _internal_set_include_body(value);
  // @@protoc_insertion_point(field_set:unhinged.document_store.ListDocumentVersionsRequest.include_body)
}

// -------------------------------------------------------------------

// ListDocumentVersionsResponse

// bool success = 1;
inline void ListDocumentVersionsResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool ListDocumentVersionsResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool ListDocumentVersionsResponse::success() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.ListDocumentVersionsResponse.success)
  return _internal_success();
}
inline void ListDocumentVersionsResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void ListDocumentVersionsResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:unhinged.document_store.ListDocumentVersionsResponse.success)
}

// string message = 2;
inline void ListDocumentVersionsResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& ListDocumentVersionsResponse::message() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.ListDocumentVersionsResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListDocumentVersionsResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.document_store.ListDocumentVersionsResponse.message)
}
inline std::string* ListDocumentVersionsResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.ListDocumentVersionsResponse.message)
  return _s;
}
inline const std::string& ListDocumentVersionsResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void ListDocumentVersionsResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* ListDocumentVersionsResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* ListDocumentVersionsResponse::release_message() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.ListDocumentVersionsResponse.message)
  return _impl_.message_.Release();
}
inline void ListDocumentVersionsResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.ListDocumentVersionsResponse.message)
}

// repeated .unhinged.document_store.Document documents = 3;
inline int ListDocumentVersionsResponse::_internal_documents_size() const {
  return _impl_.documents_.size();
}
inline int ListDocumentVersionsResponse::documents_size() const {
  return _internal_documents_size();
}
inline void ListDocumentVersionsResponse::clear_documents() {
  _impl_.documents_.Clear();
}
inline ::unhinged::document_store::Document* ListDocumentVersionsResponse::mutable_documents(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.ListDocumentVersionsResponse.documents)
  return _impl_.documents_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::document_store::Document >*
ListDocumentVersionsResponse::mutable_documents() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.document_store.ListDocumentVersionsResponse.documents)
  return &_impl_.documents_;
}
inline const ::unhinged::document_store::Document& ListDocumentVersionsResponse::_internal_documents(int index) const {
  return _impl_.documents_.Get(index);
}
inline const ::unhinged::document_store::Document& ListDocumentVersionsResponse::documents(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.ListDocumentVersionsResponse.documents)
  return _internal_documents(index);
}
inline ::unhinged::document_store::Document* ListDocumentVersionsResponse::_internal_add_documents() {
  return _impl_.documents_.Add();
}
inline ::unhinged::document_store::Document* ListDocumentVersionsResponse::add_documents() {
  ::unhinged::document_store::Document* _add = _internal_add_documents();
  // @@protoc_insertion_point(field_add:unhinged.document_store.ListDocumentVersionsResponse.documents)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::document_store::Document >&
ListDocumentVersionsResponse::documents() const {
  // @@protoc_insertion_point(field_list:unhinged.document_store.ListDocumentVersionsResponse.documents)
  return _impl_.documents_;
}

// .google.protobuf.Timestamp next_pagination_token = 4;
inline bool ListDocumentVersionsResponse::_internal_has_next_pagination_token() const {
  return this != internal_default_instance() && _impl_.next_pagination_token_ != nullptr;
}
inline bool ListDocumentVersionsResponse::has_next_pagination_token() const {
  return _internal_has_next_pagination_token();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ListDocumentVersionsResponse::_internal_next_pagination_token() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.next_pagination_token_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ListDocumentVersionsResponse::next_pagination_token() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.ListDocumentVersionsResponse.next_pagination_token)
  return _internal_next_pagination_token();
}
inline void ListDocumentVersionsResponse::unsafe_arena_set_allocated_next_pagination_token(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* next_pagination_token) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.next_pagination_token_);
  }
  _impl_.next_pagination_token_ = next_pagination_token;
  if (next_pagination_token) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.document_store.ListDocumentVersionsResponse.next_pagination_token)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ListDocumentVersionsResponse::release_next_pagination_token() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.next_pagination_token_;
  _impl_.next_pagination_token_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ListDocumentVersionsResponse::unsafe_arena_release_next_pagination_token() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.ListDocumentVersionsResponse.next_pagination_token)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.next_pagination_token_;
  _impl_.next_pagination_token_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ListDocumentVersionsResponse::_internal_mutable_next_pagination_token() {
  
  if (_impl_.next_pagination_token_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.next_pagination_token_ = p;
  }
  return _impl_.next_pagination_token_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ListDocumentVersionsResponse::mutable_next_pagination_token() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_next_pagination_token();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.ListDocumentVersionsResponse.next_pagination_token)
  return _msg;
}
inline void ListDocumentVersionsResponse::set_allocated_next_pagination_token(::PROTOBUF_NAMESPACE_ID::Timestamp* next_pagination_token) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.next_pagination_token_);
  }
  if (next_pagination_token) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(next_pagination_token));
    if (message_arena != submessage_arena) {
      next_pagination_token = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, next_pagination_token, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.next_pagination_token_ = next_pagination_token;
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.ListDocumentVersionsResponse.next_pagination_token)
}

// int32 total_count = 5;
inline void ListDocumentVersionsResponse::clear_total_count() {
  _impl_.total_count_ = 0;
}
inline int32_t ListDocumentVersionsResponse::_internal_total_count() const {
  return _impl_.total_count_;
}
inline int32_t ListDocumentVersionsResponse::total_count() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.ListDocumentVersionsResponse.total_count)
  return _internal_total_count();
}
inline void ListDocumentVersionsResponse::_internal_set_total_count(int32_t value) {
  
  _impl_.total_count_ = value;
}
inline void ListDocumentVersionsResponse::set_total_count(int32_t value) {
  _internal_set_total_count(value);
  // @@protoc_insertion_point(field_set:unhinged.document_store.ListDocumentVersionsResponse.total_count)
}

// -------------------------------------------------------------------

// TagDocumentRequest

// string document_uuid = 1;
inline void TagDocumentRequest::clear_document_uuid() {
  _impl_.document_uuid_.ClearToEmpty();
}
inline const std::string& TagDocumentRequest::document_uuid() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.TagDocumentRequest.document_uuid)
  return _internal_document_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TagDocumentRequest::set_document_uuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.document_uuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.document_store.TagDocumentRequest.document_uuid)
}
inline std::string* TagDocumentRequest::mutable_document_uuid() {
  std::string* _s = _internal_mutable_document_uuid();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.TagDocumentRequest.document_uuid)
  return _s;
}
inline const std::string& TagDocumentRequest::_internal_document_uuid() const {
  return _impl_.document_uuid_.Get();
}
inline void TagDocumentRequest::_internal_set_document_uuid(const std::string& value) {
  
  _impl_.document_uuid_.Set(value, GetArenaForAllocation());
}
inline std::string* TagDocumentRequest::_internal_mutable_document_uuid() {
  
  return _impl_.document_uuid_.Mutable(GetArenaForAllocation());
}
inline std::string* TagDocumentRequest::release_document_uuid() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.TagDocumentRequest.document_uuid)
  return _impl_.document_uuid_.Release();
}
inline void TagDocumentRequest::set_allocated_document_uuid(std::string* document_uuid) {
  if (document_uuid != nullptr) {
    
  } else {
    
  }
  _impl_.document_uuid_.SetAllocated(document_uuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.document_uuid_.IsDefault()) {
    _impl_.document_uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.TagDocumentRequest.document_uuid)
}

// int32 version = 2;
inline void TagDocumentRequest::clear_version() {
  _impl_.version_ = 0;
}
inline int32_t TagDocumentRequest::_internal_version() const {
  return _impl_.version_;
}
inline int32_t TagDocumentRequest::version() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.TagDocumentRequest.version)
  return _internal_version();
}
inline void TagDocumentRequest::_internal_set_version(int32_t value) {
  
  _impl_.version_ = value;
}
inline void TagDocumentRequest::set_version(int32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:unhinged.document_store.TagDocumentRequest.version)
}

// string tag = 3;
inline void TagDocumentRequest::clear_tag() {
  _impl_.tag_.ClearToEmpty();
}
inline const std::string& TagDocumentRequest::tag() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.TagDocumentRequest.tag)
  return _internal_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TagDocumentRequest::set_tag(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.document_store.TagDocumentRequest.tag)
}
inline std::string* TagDocumentRequest::mutable_tag() {
  std::string* _s = _internal_mutable_tag();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.TagDocumentRequest.tag)
  return _s;
}
inline const std::string& TagDocumentRequest::_internal_tag() const {
  return _impl_.tag_.Get();
}
inline void TagDocumentRequest::_internal_set_tag(const std::string& value) {
  
  _impl_.tag_.Set(value, GetArenaForAllocation());
}
inline std::string* TagDocumentRequest::_internal_mutable_tag() {
  
  return _impl_.tag_.Mutable(GetArenaForAllocation());
}
inline std::string* TagDocumentRequest::release_tag() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.TagDocumentRequest.tag)
  return _impl_.tag_.Release();
}
inline void TagDocumentRequest::set_allocated_tag(std::string* tag) {
  if (tag != nullptr) {
    
  } else {
    
  }
  _impl_.tag_.SetAllocated(tag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tag_.IsDefault()) {
    _impl_.tag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.TagDocumentRequest.tag)
}

// string tagged_by = 4;
inline void TagDocumentRequest::clear_tagged_by() {
  _impl_.tagged_by_.ClearToEmpty();
}
inline const std::string& TagDocumentRequest::tagged_by() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.TagDocumentRequest.tagged_by)
  return _internal_tagged_by();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TagDocumentRequest::set_tagged_by(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tagged_by_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.document_store.TagDocumentRequest.tagged_by)
}
inline std::string* TagDocumentRequest::mutable_tagged_by() {
  std::string* _s = _internal_mutable_tagged_by();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.TagDocumentRequest.tagged_by)
  return _s;
}
inline const std::string& TagDocumentRequest::_internal_tagged_by() const {
  return _impl_.tagged_by_.Get();
}
inline void TagDocumentRequest::_internal_set_tagged_by(const std::string& value) {
  
  _impl_.tagged_by_.Set(value, GetArenaForAllocation());
}
inline std::string* TagDocumentRequest::_internal_mutable_tagged_by() {
  
  return _impl_.tagged_by_.Mutable(GetArenaForAllocation());
}
inline std::string* TagDocumentRequest::release_tagged_by() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.TagDocumentRequest.tagged_by)
  return _impl_.tagged_by_.Release();
}
inline void TagDocumentRequest::set_allocated_tagged_by(std::string* tagged_by) {
  if (tagged_by != nullptr) {
    
  } else {
    
  }
  _impl_.tagged_by_.SetAllocated(tagged_by, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tagged_by_.IsDefault()) {
    _impl_.tagged_by_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.TagDocumentRequest.tagged_by)
}

// string tagged_by_type = 5;
inline void TagDocumentRequest::clear_tagged_by_type() {
  _impl_.tagged_by_type_.ClearToEmpty();
}
inline const std::string& TagDocumentRequest::tagged_by_type() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.TagDocumentRequest.tagged_by_type)
  return _internal_tagged_by_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TagDocumentRequest::set_tagged_by_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tagged_by_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.document_store.TagDocumentRequest.tagged_by_type)
}
inline std::string* TagDocumentRequest::mutable_tagged_by_type() {
  std::string* _s = _internal_mutable_tagged_by_type();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.TagDocumentRequest.tagged_by_type)
  return _s;
}
inline const std::string& TagDocumentRequest::_internal_tagged_by_type() const {
  return _impl_.tagged_by_type_.Get();
}
inline void TagDocumentRequest::_internal_set_tagged_by_type(const std::string& value) {
  
  _impl_.tagged_by_type_.Set(value, GetArenaForAllocation());
}
inline std::string* TagDocumentRequest::_internal_mutable_tagged_by_type() {
  
  return _impl_.tagged_by_type_.Mutable(GetArenaForAllocation());
}
inline std::string* TagDocumentRequest::release_tagged_by_type() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.TagDocumentRequest.tagged_by_type)
  return _impl_.tagged_by_type_.Release();
}
inline void TagDocumentRequest::set_allocated_tagged_by_type(std::string* tagged_by_type) {
  if (tagged_by_type != nullptr) {
    
  } else {
    
  }
  _impl_.tagged_by_type_.SetAllocated(tagged_by_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tagged_by_type_.IsDefault()) {
    _impl_.tagged_by_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.TagDocumentRequest.tagged_by_type)
}

// string session_id = 6;
inline void TagDocumentRequest::clear_session_id() {
  _impl_.session_id_.ClearToEmpty();
}
inline const std::string& TagDocumentRequest::session_id() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.TagDocumentRequest.session_id)
  return _internal_session_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TagDocumentRequest::set_session_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.session_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.document_store.TagDocumentRequest.session_id)
}
inline std::string* TagDocumentRequest::mutable_session_id() {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.TagDocumentRequest.session_id)
  return _s;
}
inline const std::string& TagDocumentRequest::_internal_session_id() const {
  return _impl_.session_id_.Get();
}
inline void TagDocumentRequest::_internal_set_session_id(const std::string& value) {
  
  _impl_.session_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TagDocumentRequest::_internal_mutable_session_id() {
  
  return _impl_.session_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TagDocumentRequest::release_session_id() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.TagDocumentRequest.session_id)
  return _impl_.session_id_.Release();
}
inline void TagDocumentRequest::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  _impl_.session_id_.SetAllocated(session_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.session_id_.IsDefault()) {
    _impl_.session_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.TagDocumentRequest.session_id)
}

// -------------------------------------------------------------------

// TagDocumentResponse

// bool success = 1;
inline void TagDocumentResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool TagDocumentResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool TagDocumentResponse::success() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.TagDocumentResponse.success)
  return _internal_success();
}
inline void TagDocumentResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void TagDocumentResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:unhinged.document_store.TagDocumentResponse.success)
}

// string message = 2;
inline void TagDocumentResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& TagDocumentResponse::message() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.TagDocumentResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TagDocumentResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.document_store.TagDocumentResponse.message)
}
inline std::string* TagDocumentResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.TagDocumentResponse.message)
  return _s;
}
inline const std::string& TagDocumentResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void TagDocumentResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* TagDocumentResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* TagDocumentResponse::release_message() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.TagDocumentResponse.message)
  return _impl_.message_.Release();
}
inline void TagDocumentResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.TagDocumentResponse.message)
}

// -------------------------------------------------------------------

// ListActiveTagsRequest

// string document_uuid = 1;
inline void ListActiveTagsRequest::clear_document_uuid() {
  _impl_.document_uuid_.ClearToEmpty();
}
inline const std::string& ListActiveTagsRequest::document_uuid() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.ListActiveTagsRequest.document_uuid)
  return _internal_document_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListActiveTagsRequest::set_document_uuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.document_uuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.document_store.ListActiveTagsRequest.document_uuid)
}
inline std::string* ListActiveTagsRequest::mutable_document_uuid() {
  std::string* _s = _internal_mutable_document_uuid();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.ListActiveTagsRequest.document_uuid)
  return _s;
}
inline const std::string& ListActiveTagsRequest::_internal_document_uuid() const {
  return _impl_.document_uuid_.Get();
}
inline void ListActiveTagsRequest::_internal_set_document_uuid(const std::string& value) {
  
  _impl_.document_uuid_.Set(value, GetArenaForAllocation());
}
inline std::string* ListActiveTagsRequest::_internal_mutable_document_uuid() {
  
  return _impl_.document_uuid_.Mutable(GetArenaForAllocation());
}
inline std::string* ListActiveTagsRequest::release_document_uuid() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.ListActiveTagsRequest.document_uuid)
  return _impl_.document_uuid_.Release();
}
inline void ListActiveTagsRequest::set_allocated_document_uuid(std::string* document_uuid) {
  if (document_uuid != nullptr) {
    
  } else {
    
  }
  _impl_.document_uuid_.SetAllocated(document_uuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.document_uuid_.IsDefault()) {
    _impl_.document_uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.ListActiveTagsRequest.document_uuid)
}

// optional int32 document_version = 2;
inline bool ListActiveTagsRequest::_internal_has_document_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ListActiveTagsRequest::has_document_version() const {
  return _internal_has_document_version();
}
inline void ListActiveTagsRequest::clear_document_version() {
  _impl_.document_version_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t ListActiveTagsRequest::_internal_document_version() const {
  return _impl_.document_version_;
}
inline int32_t ListActiveTagsRequest::document_version() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.ListActiveTagsRequest.document_version)
  return _internal_document_version();
}
inline void ListActiveTagsRequest::_internal_set_document_version(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.document_version_ = value;
}
inline void ListActiveTagsRequest::set_document_version(int32_t value) {
  _internal_set_document_version(value);
  // @@protoc_insertion_point(field_set:unhinged.document_store.ListActiveTagsRequest.document_version)
}

// optional .google.protobuf.Timestamp pagination_token = 3;
inline bool ListActiveTagsRequest::_internal_has_pagination_token() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pagination_token_ != nullptr);
  return value;
}
inline bool ListActiveTagsRequest::has_pagination_token() const {
  return _internal_has_pagination_token();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ListActiveTagsRequest::_internal_pagination_token() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.pagination_token_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ListActiveTagsRequest::pagination_token() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.ListActiveTagsRequest.pagination_token)
  return _internal_pagination_token();
}
inline void ListActiveTagsRequest::unsafe_arena_set_allocated_pagination_token(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* pagination_token) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pagination_token_);
  }
  _impl_.pagination_token_ = pagination_token;
  if (pagination_token) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.document_store.ListActiveTagsRequest.pagination_token)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ListActiveTagsRequest::release_pagination_token() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.pagination_token_;
  _impl_.pagination_token_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ListActiveTagsRequest::unsafe_arena_release_pagination_token() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.ListActiveTagsRequest.pagination_token)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.pagination_token_;
  _impl_.pagination_token_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ListActiveTagsRequest::_internal_mutable_pagination_token() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.pagination_token_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.pagination_token_ = p;
  }
  return _impl_.pagination_token_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ListActiveTagsRequest::mutable_pagination_token() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_pagination_token();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.ListActiveTagsRequest.pagination_token)
  return _msg;
}
inline void ListActiveTagsRequest::set_allocated_pagination_token(::PROTOBUF_NAMESPACE_ID::Timestamp* pagination_token) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pagination_token_);
  }
  if (pagination_token) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pagination_token));
    if (message_arena != submessage_arena) {
      pagination_token = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pagination_token, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.pagination_token_ = pagination_token;
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.ListActiveTagsRequest.pagination_token)
}

// int32 page_size = 4;
inline void ListActiveTagsRequest::clear_page_size() {
  _impl_.page_size_ = 0;
}
inline int32_t ListActiveTagsRequest::_internal_page_size() const {
  return _impl_.page_size_;
}
inline int32_t ListActiveTagsRequest::page_size() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.ListActiveTagsRequest.page_size)
  return _internal_page_size();
}
inline void ListActiveTagsRequest::_internal_set_page_size(int32_t value) {
  
  _impl_.page_size_ = value;
}
inline void ListActiveTagsRequest::set_page_size(int32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:unhinged.document_store.ListActiveTagsRequest.page_size)
}

// -------------------------------------------------------------------

// ListActiveTagsResponse

// bool success = 1;
inline void ListActiveTagsResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool ListActiveTagsResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool ListActiveTagsResponse::success() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.ListActiveTagsResponse.success)
  return _internal_success();
}
inline void ListActiveTagsResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void ListActiveTagsResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:unhinged.document_store.ListActiveTagsResponse.success)
}

// string message = 2;
inline void ListActiveTagsResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& ListActiveTagsResponse::message() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.ListActiveTagsResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListActiveTagsResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.document_store.ListActiveTagsResponse.message)
}
inline std::string* ListActiveTagsResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.ListActiveTagsResponse.message)
  return _s;
}
inline const std::string& ListActiveTagsResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void ListActiveTagsResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* ListActiveTagsResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* ListActiveTagsResponse::release_message() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.ListActiveTagsResponse.message)
  return _impl_.message_.Release();
}
inline void ListActiveTagsResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.ListActiveTagsResponse.message)
}

// repeated .unhinged.document_store.ActiveTag tags = 3;
inline int ListActiveTagsResponse::_internal_tags_size() const {
  return _impl_.tags_.size();
}
inline int ListActiveTagsResponse::tags_size() const {
  return _internal_tags_size();
}
inline void ListActiveTagsResponse::clear_tags() {
  _impl_.tags_.Clear();
}
inline ::unhinged::document_store::ActiveTag* ListActiveTagsResponse::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.ListActiveTagsResponse.tags)
  return _impl_.tags_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::document_store::ActiveTag >*
ListActiveTagsResponse::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.document_store.ListActiveTagsResponse.tags)
  return &_impl_.tags_;
}
inline const ::unhinged::document_store::ActiveTag& ListActiveTagsResponse::_internal_tags(int index) const {
  return _impl_.tags_.Get(index);
}
inline const ::unhinged::document_store::ActiveTag& ListActiveTagsResponse::tags(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.ListActiveTagsResponse.tags)
  return _internal_tags(index);
}
inline ::unhinged::document_store::ActiveTag* ListActiveTagsResponse::_internal_add_tags() {
  return _impl_.tags_.Add();
}
inline ::unhinged::document_store::ActiveTag* ListActiveTagsResponse::add_tags() {
  ::unhinged::document_store::ActiveTag* _add = _internal_add_tags();
  // @@protoc_insertion_point(field_add:unhinged.document_store.ListActiveTagsResponse.tags)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::document_store::ActiveTag >&
ListActiveTagsResponse::tags() const {
  // @@protoc_insertion_point(field_list:unhinged.document_store.ListActiveTagsResponse.tags)
  return _impl_.tags_;
}

// .google.protobuf.Timestamp next_pagination_token = 4;
inline bool ListActiveTagsResponse::_internal_has_next_pagination_token() const {
  return this != internal_default_instance() && _impl_.next_pagination_token_ != nullptr;
}
inline bool ListActiveTagsResponse::has_next_pagination_token() const {
  return _internal_has_next_pagination_token();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ListActiveTagsResponse::_internal_next_pagination_token() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.next_pagination_token_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ListActiveTagsResponse::next_pagination_token() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.ListActiveTagsResponse.next_pagination_token)
  return _internal_next_pagination_token();
}
inline void ListActiveTagsResponse::unsafe_arena_set_allocated_next_pagination_token(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* next_pagination_token) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.next_pagination_token_);
  }
  _impl_.next_pagination_token_ = next_pagination_token;
  if (next_pagination_token) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.document_store.ListActiveTagsResponse.next_pagination_token)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ListActiveTagsResponse::release_next_pagination_token() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.next_pagination_token_;
  _impl_.next_pagination_token_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ListActiveTagsResponse::unsafe_arena_release_next_pagination_token() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.ListActiveTagsResponse.next_pagination_token)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.next_pagination_token_;
  _impl_.next_pagination_token_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ListActiveTagsResponse::_internal_mutable_next_pagination_token() {
  
  if (_impl_.next_pagination_token_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.next_pagination_token_ = p;
  }
  return _impl_.next_pagination_token_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ListActiveTagsResponse::mutable_next_pagination_token() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_next_pagination_token();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.ListActiveTagsResponse.next_pagination_token)
  return _msg;
}
inline void ListActiveTagsResponse::set_allocated_next_pagination_token(::PROTOBUF_NAMESPACE_ID::Timestamp* next_pagination_token) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.next_pagination_token_);
  }
  if (next_pagination_token) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(next_pagination_token));
    if (message_arena != submessage_arena) {
      next_pagination_token = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, next_pagination_token, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.next_pagination_token_ = next_pagination_token;
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.ListActiveTagsResponse.next_pagination_token)
}

// int32 total_count = 5;
inline void ListActiveTagsResponse::clear_total_count() {
  _impl_.total_count_ = 0;
}
inline int32_t ListActiveTagsResponse::_internal_total_count() const {
  return _impl_.total_count_;
}
inline int32_t ListActiveTagsResponse::total_count() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.ListActiveTagsResponse.total_count)
  return _internal_total_count();
}
inline void ListActiveTagsResponse::_internal_set_total_count(int32_t value) {
  
  _impl_.total_count_ = value;
}
inline void ListActiveTagsResponse::set_total_count(int32_t value) {
  _internal_set_total_count(value);
  // @@protoc_insertion_point(field_set:unhinged.document_store.ListActiveTagsResponse.total_count)
}

// -------------------------------------------------------------------

// ListTagEventsRequest

// string document_uuid = 1;
inline void ListTagEventsRequest::clear_document_uuid() {
  _impl_.document_uuid_.ClearToEmpty();
}
inline const std::string& ListTagEventsRequest::document_uuid() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.ListTagEventsRequest.document_uuid)
  return _internal_document_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListTagEventsRequest::set_document_uuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.document_uuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.document_store.ListTagEventsRequest.document_uuid)
}
inline std::string* ListTagEventsRequest::mutable_document_uuid() {
  std::string* _s = _internal_mutable_document_uuid();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.ListTagEventsRequest.document_uuid)
  return _s;
}
inline const std::string& ListTagEventsRequest::_internal_document_uuid() const {
  return _impl_.document_uuid_.Get();
}
inline void ListTagEventsRequest::_internal_set_document_uuid(const std::string& value) {
  
  _impl_.document_uuid_.Set(value, GetArenaForAllocation());
}
inline std::string* ListTagEventsRequest::_internal_mutable_document_uuid() {
  
  return _impl_.document_uuid_.Mutable(GetArenaForAllocation());
}
inline std::string* ListTagEventsRequest::release_document_uuid() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.ListTagEventsRequest.document_uuid)
  return _impl_.document_uuid_.Release();
}
inline void ListTagEventsRequest::set_allocated_document_uuid(std::string* document_uuid) {
  if (document_uuid != nullptr) {
    
  } else {
    
  }
  _impl_.document_uuid_.SetAllocated(document_uuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.document_uuid_.IsDefault()) {
    _impl_.document_uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.ListTagEventsRequest.document_uuid)
}

// string tag = 2;
inline void ListTagEventsRequest::clear_tag() {
  _impl_.tag_.ClearToEmpty();
}
inline const std::string& ListTagEventsRequest::tag() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.ListTagEventsRequest.tag)
  return _internal_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListTagEventsRequest::set_tag(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.document_store.ListTagEventsRequest.tag)
}
inline std::string* ListTagEventsRequest::mutable_tag() {
  std::string* _s = _internal_mutable_tag();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.ListTagEventsRequest.tag)
  return _s;
}
inline const std::string& ListTagEventsRequest::_internal_tag() const {
  return _impl_.tag_.Get();
}
inline void ListTagEventsRequest::_internal_set_tag(const std::string& value) {
  
  _impl_.tag_.Set(value, GetArenaForAllocation());
}
inline std::string* ListTagEventsRequest::_internal_mutable_tag() {
  
  return _impl_.tag_.Mutable(GetArenaForAllocation());
}
inline std::string* ListTagEventsRequest::release_tag() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.ListTagEventsRequest.tag)
  return _impl_.tag_.Release();
}
inline void ListTagEventsRequest::set_allocated_tag(std::string* tag) {
  if (tag != nullptr) {
    
  } else {
    
  }
  _impl_.tag_.SetAllocated(tag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tag_.IsDefault()) {
    _impl_.tag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.ListTagEventsRequest.tag)
}

// optional .google.protobuf.Timestamp pagination_token = 3;
inline bool ListTagEventsRequest::_internal_has_pagination_token() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pagination_token_ != nullptr);
  return value;
}
inline bool ListTagEventsRequest::has_pagination_token() const {
  return _internal_has_pagination_token();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ListTagEventsRequest::_internal_pagination_token() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.pagination_token_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ListTagEventsRequest::pagination_token() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.ListTagEventsRequest.pagination_token)
  return _internal_pagination_token();
}
inline void ListTagEventsRequest::unsafe_arena_set_allocated_pagination_token(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* pagination_token) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pagination_token_);
  }
  _impl_.pagination_token_ = pagination_token;
  if (pagination_token) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.document_store.ListTagEventsRequest.pagination_token)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ListTagEventsRequest::release_pagination_token() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.pagination_token_;
  _impl_.pagination_token_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ListTagEventsRequest::unsafe_arena_release_pagination_token() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.ListTagEventsRequest.pagination_token)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.pagination_token_;
  _impl_.pagination_token_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ListTagEventsRequest::_internal_mutable_pagination_token() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.pagination_token_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.pagination_token_ = p;
  }
  return _impl_.pagination_token_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ListTagEventsRequest::mutable_pagination_token() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_pagination_token();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.ListTagEventsRequest.pagination_token)
  return _msg;
}
inline void ListTagEventsRequest::set_allocated_pagination_token(::PROTOBUF_NAMESPACE_ID::Timestamp* pagination_token) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pagination_token_);
  }
  if (pagination_token) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pagination_token));
    if (message_arena != submessage_arena) {
      pagination_token = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pagination_token, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.pagination_token_ = pagination_token;
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.ListTagEventsRequest.pagination_token)
}

// int32 page_size = 4;
inline void ListTagEventsRequest::clear_page_size() {
  _impl_.page_size_ = 0;
}
inline int32_t ListTagEventsRequest::_internal_page_size() const {
  return _impl_.page_size_;
}
inline int32_t ListTagEventsRequest::page_size() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.ListTagEventsRequest.page_size)
  return _internal_page_size();
}
inline void ListTagEventsRequest::_internal_set_page_size(int32_t value) {
  
  _impl_.page_size_ = value;
}
inline void ListTagEventsRequest::set_page_size(int32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:unhinged.document_store.ListTagEventsRequest.page_size)
}

// -------------------------------------------------------------------

// ListTagEventsResponse

// bool success = 1;
inline void ListTagEventsResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool ListTagEventsResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool ListTagEventsResponse::success() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.ListTagEventsResponse.success)
  return _internal_success();
}
inline void ListTagEventsResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void ListTagEventsResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:unhinged.document_store.ListTagEventsResponse.success)
}

// string message = 2;
inline void ListTagEventsResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& ListTagEventsResponse::message() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.ListTagEventsResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListTagEventsResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.document_store.ListTagEventsResponse.message)
}
inline std::string* ListTagEventsResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.ListTagEventsResponse.message)
  return _s;
}
inline const std::string& ListTagEventsResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void ListTagEventsResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* ListTagEventsResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* ListTagEventsResponse::release_message() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.ListTagEventsResponse.message)
  return _impl_.message_.Release();
}
inline void ListTagEventsResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.ListTagEventsResponse.message)
}

// repeated .unhinged.document_store.TagEvent events = 3;
inline int ListTagEventsResponse::_internal_events_size() const {
  return _impl_.events_.size();
}
inline int ListTagEventsResponse::events_size() const {
  return _internal_events_size();
}
inline void ListTagEventsResponse::clear_events() {
  _impl_.events_.Clear();
}
inline ::unhinged::document_store::TagEvent* ListTagEventsResponse::mutable_events(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.ListTagEventsResponse.events)
  return _impl_.events_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::document_store::TagEvent >*
ListTagEventsResponse::mutable_events() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.document_store.ListTagEventsResponse.events)
  return &_impl_.events_;
}
inline const ::unhinged::document_store::TagEvent& ListTagEventsResponse::_internal_events(int index) const {
  return _impl_.events_.Get(index);
}
inline const ::unhinged::document_store::TagEvent& ListTagEventsResponse::events(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.ListTagEventsResponse.events)
  return _internal_events(index);
}
inline ::unhinged::document_store::TagEvent* ListTagEventsResponse::_internal_add_events() {
  return _impl_.events_.Add();
}
inline ::unhinged::document_store::TagEvent* ListTagEventsResponse::add_events() {
  ::unhinged::document_store::TagEvent* _add = _internal_add_events();
  // @@protoc_insertion_point(field_add:unhinged.document_store.ListTagEventsResponse.events)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::document_store::TagEvent >&
ListTagEventsResponse::events() const {
  // @@protoc_insertion_point(field_list:unhinged.document_store.ListTagEventsResponse.events)
  return _impl_.events_;
}

// .google.protobuf.Timestamp next_pagination_token = 4;
inline bool ListTagEventsResponse::_internal_has_next_pagination_token() const {
  return this != internal_default_instance() && _impl_.next_pagination_token_ != nullptr;
}
inline bool ListTagEventsResponse::has_next_pagination_token() const {
  return _internal_has_next_pagination_token();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ListTagEventsResponse::_internal_next_pagination_token() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.next_pagination_token_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ListTagEventsResponse::next_pagination_token() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.ListTagEventsResponse.next_pagination_token)
  return _internal_next_pagination_token();
}
inline void ListTagEventsResponse::unsafe_arena_set_allocated_next_pagination_token(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* next_pagination_token) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.next_pagination_token_);
  }
  _impl_.next_pagination_token_ = next_pagination_token;
  if (next_pagination_token) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.document_store.ListTagEventsResponse.next_pagination_token)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ListTagEventsResponse::release_next_pagination_token() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.next_pagination_token_;
  _impl_.next_pagination_token_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ListTagEventsResponse::unsafe_arena_release_next_pagination_token() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.ListTagEventsResponse.next_pagination_token)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.next_pagination_token_;
  _impl_.next_pagination_token_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ListTagEventsResponse::_internal_mutable_next_pagination_token() {
  
  if (_impl_.next_pagination_token_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.next_pagination_token_ = p;
  }
  return _impl_.next_pagination_token_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ListTagEventsResponse::mutable_next_pagination_token() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_next_pagination_token();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.ListTagEventsResponse.next_pagination_token)
  return _msg;
}
inline void ListTagEventsResponse::set_allocated_next_pagination_token(::PROTOBUF_NAMESPACE_ID::Timestamp* next_pagination_token) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.next_pagination_token_);
  }
  if (next_pagination_token) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(next_pagination_token));
    if (message_arena != submessage_arena) {
      next_pagination_token = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, next_pagination_token, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.next_pagination_token_ = next_pagination_token;
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.ListTagEventsResponse.next_pagination_token)
}

// int32 total_count = 5;
inline void ListTagEventsResponse::clear_total_count() {
  _impl_.total_count_ = 0;
}
inline int32_t ListTagEventsResponse::_internal_total_count() const {
  return _impl_.total_count_;
}
inline int32_t ListTagEventsResponse::total_count() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.ListTagEventsResponse.total_count)
  return _internal_total_count();
}
inline void ListTagEventsResponse::_internal_set_total_count(int32_t value) {
  
  _impl_.total_count_ = value;
}
inline void ListTagEventsResponse::set_total_count(int32_t value) {
  _internal_set_total_count(value);
  // @@protoc_insertion_point(field_set:unhinged.document_store.ListTagEventsResponse.total_count)
}

// -------------------------------------------------------------------

// GetSessionContextRequest

// string session_id = 1;
inline void GetSessionContextRequest::clear_session_id() {
  _impl_.session_id_.ClearToEmpty();
}
inline const std::string& GetSessionContextRequest::session_id() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.GetSessionContextRequest.session_id)
  return _internal_session_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetSessionContextRequest::set_session_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.session_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.document_store.GetSessionContextRequest.session_id)
}
inline std::string* GetSessionContextRequest::mutable_session_id() {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.GetSessionContextRequest.session_id)
  return _s;
}
inline const std::string& GetSessionContextRequest::_internal_session_id() const {
  return _impl_.session_id_.Get();
}
inline void GetSessionContextRequest::_internal_set_session_id(const std::string& value) {
  
  _impl_.session_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetSessionContextRequest::_internal_mutable_session_id() {
  
  return _impl_.session_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetSessionContextRequest::release_session_id() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.GetSessionContextRequest.session_id)
  return _impl_.session_id_.Release();
}
inline void GetSessionContextRequest::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  _impl_.session_id_.SetAllocated(session_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.session_id_.IsDefault()) {
    _impl_.session_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.GetSessionContextRequest.session_id)
}

// repeated string document_types = 2;
inline int GetSessionContextRequest::_internal_document_types_size() const {
  return _impl_.document_types_.size();
}
inline int GetSessionContextRequest::document_types_size() const {
  return _internal_document_types_size();
}
inline void GetSessionContextRequest::clear_document_types() {
  _impl_.document_types_.Clear();
}
inline std::string* GetSessionContextRequest::add_document_types() {
  std::string* _s = _internal_add_document_types();
  // @@protoc_insertion_point(field_add_mutable:unhinged.document_store.GetSessionContextRequest.document_types)
  return _s;
}
inline const std::string& GetSessionContextRequest::_internal_document_types(int index) const {
  return _impl_.document_types_.Get(index);
}
inline const std::string& GetSessionContextRequest::document_types(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.GetSessionContextRequest.document_types)
  return _internal_document_types(index);
}
inline std::string* GetSessionContextRequest::mutable_document_types(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.GetSessionContextRequest.document_types)
  return _impl_.document_types_.Mutable(index);
}
inline void GetSessionContextRequest::set_document_types(int index, const std::string& value) {
  _impl_.document_types_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.document_store.GetSessionContextRequest.document_types)
}
inline void GetSessionContextRequest::set_document_types(int index, std::string&& value) {
  _impl_.document_types_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.document_store.GetSessionContextRequest.document_types)
}
inline void GetSessionContextRequest::set_document_types(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.document_types_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.document_store.GetSessionContextRequest.document_types)
}
inline void GetSessionContextRequest::set_document_types(int index, const char* value, size_t size) {
  _impl_.document_types_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.document_store.GetSessionContextRequest.document_types)
}
inline std::string* GetSessionContextRequest::_internal_add_document_types() {
  return _impl_.document_types_.Add();
}
inline void GetSessionContextRequest::add_document_types(const std::string& value) {
  _impl_.document_types_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.document_store.GetSessionContextRequest.document_types)
}
inline void GetSessionContextRequest::add_document_types(std::string&& value) {
  _impl_.document_types_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.document_store.GetSessionContextRequest.document_types)
}
inline void GetSessionContextRequest::add_document_types(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.document_types_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.document_store.GetSessionContextRequest.document_types)
}
inline void GetSessionContextRequest::add_document_types(const char* value, size_t size) {
  _impl_.document_types_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.document_store.GetSessionContextRequest.document_types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetSessionContextRequest::document_types() const {
  // @@protoc_insertion_point(field_list:unhinged.document_store.GetSessionContextRequest.document_types)
  return _impl_.document_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetSessionContextRequest::mutable_document_types() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.document_store.GetSessionContextRequest.document_types)
  return &_impl_.document_types_;
}

// optional .google.protobuf.Timestamp since = 3;
inline bool GetSessionContextRequest::_internal_has_since() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.since_ != nullptr);
  return value;
}
inline bool GetSessionContextRequest::has_since() const {
  return _internal_has_since();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& GetSessionContextRequest::_internal_since() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.since_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& GetSessionContextRequest::since() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.GetSessionContextRequest.since)
  return _internal_since();
}
inline void GetSessionContextRequest::unsafe_arena_set_allocated_since(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* since) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.since_);
  }
  _impl_.since_ = since;
  if (since) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.document_store.GetSessionContextRequest.since)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetSessionContextRequest::release_since() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.since_;
  _impl_.since_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetSessionContextRequest::unsafe_arena_release_since() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.GetSessionContextRequest.since)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.since_;
  _impl_.since_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetSessionContextRequest::_internal_mutable_since() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.since_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.since_ = p;
  }
  return _impl_.since_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* GetSessionContextRequest::mutable_since() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_since();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.GetSessionContextRequest.since)
  return _msg;
}
inline void GetSessionContextRequest::set_allocated_since(::PROTOBUF_NAMESPACE_ID::Timestamp* since) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.since_);
  }
  if (since) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(since));
    if (message_arena != submessage_arena) {
      since = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, since, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.since_ = since;
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.GetSessionContextRequest.since)
}

// int32 limit = 4;
inline void GetSessionContextRequest::clear_limit() {
  _impl_.limit_ = 0;
}
inline int32_t GetSessionContextRequest::_internal_limit() const {
  return _impl_.limit_;
}
inline int32_t GetSessionContextRequest::limit() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.GetSessionContextRequest.limit)
  return _internal_limit();
}
inline void GetSessionContextRequest::_internal_set_limit(int32_t value) {
  
  _impl_.limit_ = value;
}
inline void GetSessionContextRequest::set_limit(int32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:unhinged.document_store.GetSessionContextRequest.limit)
}

// bool include_body = 5;
inline void GetSessionContextRequest::clear_include_body() {
  _impl_.include_body_ = false;
}
inline bool GetSessionContextRequest::_internal_include_body() const {
  return _impl_.include_body_;
}
inline bool GetSessionContextRequest::include_body() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.GetSessionContextRequest.include_body)
  return _internal_include_body();
}
inline void GetSessionContextRequest::_internal_set_include_body(bool value) {
  
  _impl_.include_body_ = value;
}
inline void GetSessionContextRequest::set_include_body(bool value) {
  _internal_set_include_body(value);
  // @@protoc_insertion_point(field_set:unhinged.document_store.GetSessionContextRequest.include_body)
}

// -------------------------------------------------------------------

// GetSessionContextResponse

// bool success = 1;
inline void GetSessionContextResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool GetSessionContextResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool GetSessionContextResponse::success() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.GetSessionContextResponse.success)
  return _internal_success();
}
inline void GetSessionContextResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void GetSessionContextResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:unhinged.document_store.GetSessionContextResponse.success)
}

// string message = 2;
inline void GetSessionContextResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& GetSessionContextResponse::message() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.GetSessionContextResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetSessionContextResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.document_store.GetSessionContextResponse.message)
}
inline std::string* GetSessionContextResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.GetSessionContextResponse.message)
  return _s;
}
inline const std::string& GetSessionContextResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void GetSessionContextResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* GetSessionContextResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* GetSessionContextResponse::release_message() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.GetSessionContextResponse.message)
  return _impl_.message_.Release();
}
inline void GetSessionContextResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.GetSessionContextResponse.message)
}

// repeated .unhinged.document_store.Document documents = 3;
inline int GetSessionContextResponse::_internal_documents_size() const {
  return _impl_.documents_.size();
}
inline int GetSessionContextResponse::documents_size() const {
  return _internal_documents_size();
}
inline void GetSessionContextResponse::clear_documents() {
  _impl_.documents_.Clear();
}
inline ::unhinged::document_store::Document* GetSessionContextResponse::mutable_documents(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.GetSessionContextResponse.documents)
  return _impl_.documents_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::document_store::Document >*
GetSessionContextResponse::mutable_documents() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.document_store.GetSessionContextResponse.documents)
  return &_impl_.documents_;
}
inline const ::unhinged::document_store::Document& GetSessionContextResponse::_internal_documents(int index) const {
  return _impl_.documents_.Get(index);
}
inline const ::unhinged::document_store::Document& GetSessionContextResponse::documents(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.GetSessionContextResponse.documents)
  return _internal_documents(index);
}
inline ::unhinged::document_store::Document* GetSessionContextResponse::_internal_add_documents() {
  return _impl_.documents_.Add();
}
inline ::unhinged::document_store::Document* GetSessionContextResponse::add_documents() {
  ::unhinged::document_store::Document* _add = _internal_add_documents();
  // @@protoc_insertion_point(field_add:unhinged.document_store.GetSessionContextResponse.documents)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::document_store::Document >&
GetSessionContextResponse::documents() const {
  // @@protoc_insertion_point(field_list:unhinged.document_store.GetSessionContextResponse.documents)
  return _impl_.documents_;
}

// int32 total_count = 4;
inline void GetSessionContextResponse::clear_total_count() {
  _impl_.total_count_ = 0;
}
inline int32_t GetSessionContextResponse::_internal_total_count() const {
  return _impl_.total_count_;
}
inline int32_t GetSessionContextResponse::total_count() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.GetSessionContextResponse.total_count)
  return _internal_total_count();
}
inline void GetSessionContextResponse::_internal_set_total_count(int32_t value) {
  
  _impl_.total_count_ = value;
}
inline void GetSessionContextResponse::set_total_count(int32_t value) {
  _internal_set_total_count(value);
  // @@protoc_insertion_point(field_set:unhinged.document_store.GetSessionContextResponse.total_count)
}

// -------------------------------------------------------------------

// DeleteDocumentRequest

// string document_uuid = 1;
inline void DeleteDocumentRequest::clear_document_uuid() {
  _impl_.document_uuid_.ClearToEmpty();
}
inline const std::string& DeleteDocumentRequest::document_uuid() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.DeleteDocumentRequest.document_uuid)
  return _internal_document_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteDocumentRequest::set_document_uuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.document_uuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.document_store.DeleteDocumentRequest.document_uuid)
}
inline std::string* DeleteDocumentRequest::mutable_document_uuid() {
  std::string* _s = _internal_mutable_document_uuid();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.DeleteDocumentRequest.document_uuid)
  return _s;
}
inline const std::string& DeleteDocumentRequest::_internal_document_uuid() const {
  return _impl_.document_uuid_.Get();
}
inline void DeleteDocumentRequest::_internal_set_document_uuid(const std::string& value) {
  
  _impl_.document_uuid_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteDocumentRequest::_internal_mutable_document_uuid() {
  
  return _impl_.document_uuid_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteDocumentRequest::release_document_uuid() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.DeleteDocumentRequest.document_uuid)
  return _impl_.document_uuid_.Release();
}
inline void DeleteDocumentRequest::set_allocated_document_uuid(std::string* document_uuid) {
  if (document_uuid != nullptr) {
    
  } else {
    
  }
  _impl_.document_uuid_.SetAllocated(document_uuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.document_uuid_.IsDefault()) {
    _impl_.document_uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.DeleteDocumentRequest.document_uuid)
}

// optional int32 version = 2;
inline bool DeleteDocumentRequest::_internal_has_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeleteDocumentRequest::has_version() const {
  return _internal_has_version();
}
inline void DeleteDocumentRequest::clear_version() {
  _impl_.version_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t DeleteDocumentRequest::_internal_version() const {
  return _impl_.version_;
}
inline int32_t DeleteDocumentRequest::version() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.DeleteDocumentRequest.version)
  return _internal_version();
}
inline void DeleteDocumentRequest::_internal_set_version(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.version_ = value;
}
inline void DeleteDocumentRequest::set_version(int32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:unhinged.document_store.DeleteDocumentRequest.version)
}

// string deleted_by = 3;
inline void DeleteDocumentRequest::clear_deleted_by() {
  _impl_.deleted_by_.ClearToEmpty();
}
inline const std::string& DeleteDocumentRequest::deleted_by() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.DeleteDocumentRequest.deleted_by)
  return _internal_deleted_by();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteDocumentRequest::set_deleted_by(ArgT0&& arg0, ArgT... args) {
 
 _impl_.deleted_by_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.document_store.DeleteDocumentRequest.deleted_by)
}
inline std::string* DeleteDocumentRequest::mutable_deleted_by() {
  std::string* _s = _internal_mutable_deleted_by();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.DeleteDocumentRequest.deleted_by)
  return _s;
}
inline const std::string& DeleteDocumentRequest::_internal_deleted_by() const {
  return _impl_.deleted_by_.Get();
}
inline void DeleteDocumentRequest::_internal_set_deleted_by(const std::string& value) {
  
  _impl_.deleted_by_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteDocumentRequest::_internal_mutable_deleted_by() {
  
  return _impl_.deleted_by_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteDocumentRequest::release_deleted_by() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.DeleteDocumentRequest.deleted_by)
  return _impl_.deleted_by_.Release();
}
inline void DeleteDocumentRequest::set_allocated_deleted_by(std::string* deleted_by) {
  if (deleted_by != nullptr) {
    
  } else {
    
  }
  _impl_.deleted_by_.SetAllocated(deleted_by, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.deleted_by_.IsDefault()) {
    _impl_.deleted_by_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.DeleteDocumentRequest.deleted_by)
}

// string deleted_by_type = 4;
inline void DeleteDocumentRequest::clear_deleted_by_type() {
  _impl_.deleted_by_type_.ClearToEmpty();
}
inline const std::string& DeleteDocumentRequest::deleted_by_type() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.DeleteDocumentRequest.deleted_by_type)
  return _internal_deleted_by_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteDocumentRequest::set_deleted_by_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.deleted_by_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.document_store.DeleteDocumentRequest.deleted_by_type)
}
inline std::string* DeleteDocumentRequest::mutable_deleted_by_type() {
  std::string* _s = _internal_mutable_deleted_by_type();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.DeleteDocumentRequest.deleted_by_type)
  return _s;
}
inline const std::string& DeleteDocumentRequest::_internal_deleted_by_type() const {
  return _impl_.deleted_by_type_.Get();
}
inline void DeleteDocumentRequest::_internal_set_deleted_by_type(const std::string& value) {
  
  _impl_.deleted_by_type_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteDocumentRequest::_internal_mutable_deleted_by_type() {
  
  return _impl_.deleted_by_type_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteDocumentRequest::release_deleted_by_type() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.DeleteDocumentRequest.deleted_by_type)
  return _impl_.deleted_by_type_.Release();
}
inline void DeleteDocumentRequest::set_allocated_deleted_by_type(std::string* deleted_by_type) {
  if (deleted_by_type != nullptr) {
    
  } else {
    
  }
  _impl_.deleted_by_type_.SetAllocated(deleted_by_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.deleted_by_type_.IsDefault()) {
    _impl_.deleted_by_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.DeleteDocumentRequest.deleted_by_type)
}

// string session_id = 5;
inline void DeleteDocumentRequest::clear_session_id() {
  _impl_.session_id_.ClearToEmpty();
}
inline const std::string& DeleteDocumentRequest::session_id() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.DeleteDocumentRequest.session_id)
  return _internal_session_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteDocumentRequest::set_session_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.session_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.document_store.DeleteDocumentRequest.session_id)
}
inline std::string* DeleteDocumentRequest::mutable_session_id() {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.DeleteDocumentRequest.session_id)
  return _s;
}
inline const std::string& DeleteDocumentRequest::_internal_session_id() const {
  return _impl_.session_id_.Get();
}
inline void DeleteDocumentRequest::_internal_set_session_id(const std::string& value) {
  
  _impl_.session_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteDocumentRequest::_internal_mutable_session_id() {
  
  return _impl_.session_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteDocumentRequest::release_session_id() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.DeleteDocumentRequest.session_id)
  return _impl_.session_id_.Release();
}
inline void DeleteDocumentRequest::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  _impl_.session_id_.SetAllocated(session_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.session_id_.IsDefault()) {
    _impl_.session_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.DeleteDocumentRequest.session_id)
}

// -------------------------------------------------------------------

// DeleteDocumentResponse

// bool success = 1;
inline void DeleteDocumentResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool DeleteDocumentResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool DeleteDocumentResponse::success() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.DeleteDocumentResponse.success)
  return _internal_success();
}
inline void DeleteDocumentResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void DeleteDocumentResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:unhinged.document_store.DeleteDocumentResponse.success)
}

// string message = 2;
inline void DeleteDocumentResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& DeleteDocumentResponse::message() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.DeleteDocumentResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteDocumentResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.document_store.DeleteDocumentResponse.message)
}
inline std::string* DeleteDocumentResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.DeleteDocumentResponse.message)
  return _s;
}
inline const std::string& DeleteDocumentResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void DeleteDocumentResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteDocumentResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteDocumentResponse::release_message() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.DeleteDocumentResponse.message)
  return _impl_.message_.Release();
}
inline void DeleteDocumentResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.DeleteDocumentResponse.message)
}

// int32 versions_deleted = 3;
inline void DeleteDocumentResponse::clear_versions_deleted() {
  _impl_.versions_deleted_ = 0;
}
inline int32_t DeleteDocumentResponse::_internal_versions_deleted() const {
  return _impl_.versions_deleted_;
}
inline int32_t DeleteDocumentResponse::versions_deleted() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.DeleteDocumentResponse.versions_deleted)
  return _internal_versions_deleted();
}
inline void DeleteDocumentResponse::_internal_set_versions_deleted(int32_t value) {
  
  _impl_.versions_deleted_ = value;
}
inline void DeleteDocumentResponse::set_versions_deleted(int32_t value) {
  _internal_set_versions_deleted(value);
  // @@protoc_insertion_point(field_set:unhinged.document_store.DeleteDocumentResponse.versions_deleted)
}

// -------------------------------------------------------------------

// HealthCheckRequest

// -------------------------------------------------------------------

// HealthCheckResponse

// bool healthy = 1;
inline void HealthCheckResponse::clear_healthy() {
  _impl_.healthy_ = false;
}
inline bool HealthCheckResponse::_internal_healthy() const {
  return _impl_.healthy_;
}
inline bool HealthCheckResponse::healthy() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.HealthCheckResponse.healthy)
  return _internal_healthy();
}
inline void HealthCheckResponse::_internal_set_healthy(bool value) {
  
  _impl_.healthy_ = value;
}
inline void HealthCheckResponse::set_healthy(bool value) {
  _internal_set_healthy(value);
  // @@protoc_insertion_point(field_set:unhinged.document_store.HealthCheckResponse.healthy)
}

// string status = 2;
inline void HealthCheckResponse::clear_status() {
  _impl_.status_.ClearToEmpty();
}
inline const std::string& HealthCheckResponse::status() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.HealthCheckResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HealthCheckResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 _impl_.status_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.document_store.HealthCheckResponse.status)
}
inline std::string* HealthCheckResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.HealthCheckResponse.status)
  return _s;
}
inline const std::string& HealthCheckResponse::_internal_status() const {
  return _impl_.status_.Get();
}
inline void HealthCheckResponse::_internal_set_status(const std::string& value) {
  
  _impl_.status_.Set(value, GetArenaForAllocation());
}
inline std::string* HealthCheckResponse::_internal_mutable_status() {
  
  return _impl_.status_.Mutable(GetArenaForAllocation());
}
inline std::string* HealthCheckResponse::release_status() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.HealthCheckResponse.status)
  return _impl_.status_.Release();
}
inline void HealthCheckResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  _impl_.status_.SetAllocated(status, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.HealthCheckResponse.status)
}

// .google.protobuf.Timestamp timestamp = 3;
inline bool HealthCheckResponse::_internal_has_timestamp() const {
  return this != internal_default_instance() && _impl_.timestamp_ != nullptr;
}
inline bool HealthCheckResponse::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& HealthCheckResponse::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& HealthCheckResponse::timestamp() const {
  // @@protoc_insertion_point(field_get:unhinged.document_store.HealthCheckResponse.timestamp)
  return _internal_timestamp();
}
inline void HealthCheckResponse::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.document_store.HealthCheckResponse.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* HealthCheckResponse::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* HealthCheckResponse::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:unhinged.document_store.HealthCheckResponse.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* HealthCheckResponse::_internal_mutable_timestamp() {
  
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* HealthCheckResponse::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:unhinged.document_store.HealthCheckResponse.timestamp)
  return _msg;
}
inline void HealthCheckResponse::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:unhinged.document_store.HealthCheckResponse.timestamp)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace document_store
}  // namespace unhinged

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_document_5fstore_2eproto
