// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: vision_service.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_vision_5fservice_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_vision_5fservice_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_vision_5fservice_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_vision_5fservice_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_vision_5fservice_2eproto;
namespace multimodal {
class ElementBounds;
struct ElementBoundsDefaultTypeInternal;
extern ElementBoundsDefaultTypeInternal _ElementBounds_default_instance_;
class Empty;
struct EmptyDefaultTypeInternal;
extern EmptyDefaultTypeInternal _Empty_default_instance_;
class HealthResponse;
struct HealthResponseDefaultTypeInternal;
extern HealthResponseDefaultTypeInternal _HealthResponse_default_instance_;
class HealthResponse_DetailsEntry_DoNotUse;
struct HealthResponse_DetailsEntry_DoNotUseDefaultTypeInternal;
extern HealthResponse_DetailsEntry_DoNotUseDefaultTypeInternal _HealthResponse_DetailsEntry_DoNotUse_default_instance_;
class ModelInfo;
struct ModelInfoDefaultTypeInternal;
extern ModelInfoDefaultTypeInternal _ModelInfo_default_instance_;
class ModelMetricsRequest;
struct ModelMetricsRequestDefaultTypeInternal;
extern ModelMetricsRequestDefaultTypeInternal _ModelMetricsRequest_default_instance_;
class ModelMetricsResponse;
struct ModelMetricsResponseDefaultTypeInternal;
extern ModelMetricsResponseDefaultTypeInternal _ModelMetricsResponse_default_instance_;
class ModelMetricsResponse_AdditionalMetricsEntry_DoNotUse;
struct ModelMetricsResponse_AdditionalMetricsEntry_DoNotUseDefaultTypeInternal;
extern ModelMetricsResponse_AdditionalMetricsEntry_DoNotUseDefaultTypeInternal _ModelMetricsResponse_AdditionalMetricsEntry_DoNotUse_default_instance_;
class ModelsResponse;
struct ModelsResponseDefaultTypeInternal;
extern ModelsResponseDefaultTypeInternal _ModelsResponse_default_instance_;
class UIElement;
struct UIElementDefaultTypeInternal;
extern UIElementDefaultTypeInternal _UIElement_default_instance_;
class UIElement_PropertiesEntry_DoNotUse;
struct UIElement_PropertiesEntry_DoNotUseDefaultTypeInternal;
extern UIElement_PropertiesEntry_DoNotUseDefaultTypeInternal _UIElement_PropertiesEntry_DoNotUse_default_instance_;
class VisionInferenceRequest;
struct VisionInferenceRequestDefaultTypeInternal;
extern VisionInferenceRequestDefaultTypeInternal _VisionInferenceRequest_default_instance_;
class VisionInferenceRequest_ParametersEntry_DoNotUse;
struct VisionInferenceRequest_ParametersEntry_DoNotUseDefaultTypeInternal;
extern VisionInferenceRequest_ParametersEntry_DoNotUseDefaultTypeInternal _VisionInferenceRequest_ParametersEntry_DoNotUse_default_instance_;
class VisionInferenceResponse;
struct VisionInferenceResponseDefaultTypeInternal;
extern VisionInferenceResponseDefaultTypeInternal _VisionInferenceResponse_default_instance_;
class VisionInferenceResponse_MetadataEntry_DoNotUse;
struct VisionInferenceResponse_MetadataEntry_DoNotUseDefaultTypeInternal;
extern VisionInferenceResponse_MetadataEntry_DoNotUseDefaultTypeInternal _VisionInferenceResponse_MetadataEntry_DoNotUse_default_instance_;
}  // namespace multimodal
PROTOBUF_NAMESPACE_OPEN
template<> ::multimodal::ElementBounds* Arena::CreateMaybeMessage<::multimodal::ElementBounds>(Arena*);
template<> ::multimodal::Empty* Arena::CreateMaybeMessage<::multimodal::Empty>(Arena*);
template<> ::multimodal::HealthResponse* Arena::CreateMaybeMessage<::multimodal::HealthResponse>(Arena*);
template<> ::multimodal::HealthResponse_DetailsEntry_DoNotUse* Arena::CreateMaybeMessage<::multimodal::HealthResponse_DetailsEntry_DoNotUse>(Arena*);
template<> ::multimodal::ModelInfo* Arena::CreateMaybeMessage<::multimodal::ModelInfo>(Arena*);
template<> ::multimodal::ModelMetricsRequest* Arena::CreateMaybeMessage<::multimodal::ModelMetricsRequest>(Arena*);
template<> ::multimodal::ModelMetricsResponse* Arena::CreateMaybeMessage<::multimodal::ModelMetricsResponse>(Arena*);
template<> ::multimodal::ModelMetricsResponse_AdditionalMetricsEntry_DoNotUse* Arena::CreateMaybeMessage<::multimodal::ModelMetricsResponse_AdditionalMetricsEntry_DoNotUse>(Arena*);
template<> ::multimodal::ModelsResponse* Arena::CreateMaybeMessage<::multimodal::ModelsResponse>(Arena*);
template<> ::multimodal::UIElement* Arena::CreateMaybeMessage<::multimodal::UIElement>(Arena*);
template<> ::multimodal::UIElement_PropertiesEntry_DoNotUse* Arena::CreateMaybeMessage<::multimodal::UIElement_PropertiesEntry_DoNotUse>(Arena*);
template<> ::multimodal::VisionInferenceRequest* Arena::CreateMaybeMessage<::multimodal::VisionInferenceRequest>(Arena*);
template<> ::multimodal::VisionInferenceRequest_ParametersEntry_DoNotUse* Arena::CreateMaybeMessage<::multimodal::VisionInferenceRequest_ParametersEntry_DoNotUse>(Arena*);
template<> ::multimodal::VisionInferenceResponse* Arena::CreateMaybeMessage<::multimodal::VisionInferenceResponse>(Arena*);
template<> ::multimodal::VisionInferenceResponse_MetadataEntry_DoNotUse* Arena::CreateMaybeMessage<::multimodal::VisionInferenceResponse_MetadataEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace multimodal {

// ===================================================================

class VisionInferenceRequest_ParametersEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<VisionInferenceRequest_ParametersEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<VisionInferenceRequest_ParametersEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  VisionInferenceRequest_ParametersEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR VisionInferenceRequest_ParametersEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit VisionInferenceRequest_ParametersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const VisionInferenceRequest_ParametersEntry_DoNotUse& other);
  static const VisionInferenceRequest_ParametersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const VisionInferenceRequest_ParametersEntry_DoNotUse*>(&_VisionInferenceRequest_ParametersEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "multimodal.VisionInferenceRequest.ParametersEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "multimodal.VisionInferenceRequest.ParametersEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_vision_5fservice_2eproto;
};

// -------------------------------------------------------------------

class VisionInferenceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:multimodal.VisionInferenceRequest) */ {
 public:
  inline VisionInferenceRequest() : VisionInferenceRequest(nullptr) {}
  ~VisionInferenceRequest() override;
  explicit PROTOBUF_CONSTEXPR VisionInferenceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VisionInferenceRequest(const VisionInferenceRequest& from);
  VisionInferenceRequest(VisionInferenceRequest&& from) noexcept
    : VisionInferenceRequest() {
    *this = ::std::move(from);
  }

  inline VisionInferenceRequest& operator=(const VisionInferenceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline VisionInferenceRequest& operator=(VisionInferenceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VisionInferenceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const VisionInferenceRequest* internal_default_instance() {
    return reinterpret_cast<const VisionInferenceRequest*>(
               &_VisionInferenceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(VisionInferenceRequest& a, VisionInferenceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(VisionInferenceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VisionInferenceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VisionInferenceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VisionInferenceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VisionInferenceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VisionInferenceRequest& from) {
    VisionInferenceRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VisionInferenceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "multimodal.VisionInferenceRequest";
  }
  protected:
  explicit VisionInferenceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kParametersFieldNumber = 7,
    kImageDataFieldNumber = 1,
    kModelFieldNumber = 2,
    kPromptFieldNumber = 3,
    kAnalysisTypeFieldNumber = 4,
    kMaxTokensFieldNumber = 5,
    kTemperatureFieldNumber = 6,
  };
  // map<string, string> parameters = 7;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_parameters();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_parameters();

  // bytes image_data = 1;
  void clear_image_data();
  const std::string& image_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_image_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_image_data();
  PROTOBUF_NODISCARD std::string* release_image_data();
  void set_allocated_image_data(std::string* image_data);
  private:
  const std::string& _internal_image_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_image_data(const std::string& value);
  std::string* _internal_mutable_image_data();
  public:

  // string model = 2;
  void clear_model();
  const std::string& model() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model();
  PROTOBUF_NODISCARD std::string* release_model();
  void set_allocated_model(std::string* model);
  private:
  const std::string& _internal_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model(const std::string& value);
  std::string* _internal_mutable_model();
  public:

  // string prompt = 3;
  void clear_prompt();
  const std::string& prompt() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_prompt(ArgT0&& arg0, ArgT... args);
  std::string* mutable_prompt();
  PROTOBUF_NODISCARD std::string* release_prompt();
  void set_allocated_prompt(std::string* prompt);
  private:
  const std::string& _internal_prompt() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_prompt(const std::string& value);
  std::string* _internal_mutable_prompt();
  public:

  // string analysis_type = 4;
  void clear_analysis_type();
  const std::string& analysis_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_analysis_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_analysis_type();
  PROTOBUF_NODISCARD std::string* release_analysis_type();
  void set_allocated_analysis_type(std::string* analysis_type);
  private:
  const std::string& _internal_analysis_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_analysis_type(const std::string& value);
  std::string* _internal_mutable_analysis_type();
  public:

  // int32 max_tokens = 5;
  void clear_max_tokens();
  int32_t max_tokens() const;
  void set_max_tokens(int32_t value);
  private:
  int32_t _internal_max_tokens() const;
  void _internal_set_max_tokens(int32_t value);
  public:

  // float temperature = 6;
  void clear_temperature();
  float temperature() const;
  void set_temperature(float value);
  private:
  float _internal_temperature() const;
  void _internal_set_temperature(float value);
  public:

  // @@protoc_insertion_point(class_scope:multimodal.VisionInferenceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        VisionInferenceRequest_ParametersEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> parameters_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr image_data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr prompt_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr analysis_type_;
    int32_t max_tokens_;
    float temperature_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vision_5fservice_2eproto;
};
// -------------------------------------------------------------------

class VisionInferenceResponse_MetadataEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<VisionInferenceResponse_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<VisionInferenceResponse_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  VisionInferenceResponse_MetadataEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR VisionInferenceResponse_MetadataEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit VisionInferenceResponse_MetadataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const VisionInferenceResponse_MetadataEntry_DoNotUse& other);
  static const VisionInferenceResponse_MetadataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const VisionInferenceResponse_MetadataEntry_DoNotUse*>(&_VisionInferenceResponse_MetadataEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "multimodal.VisionInferenceResponse.MetadataEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "multimodal.VisionInferenceResponse.MetadataEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_vision_5fservice_2eproto;
};

// -------------------------------------------------------------------

class VisionInferenceResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:multimodal.VisionInferenceResponse) */ {
 public:
  inline VisionInferenceResponse() : VisionInferenceResponse(nullptr) {}
  ~VisionInferenceResponse() override;
  explicit PROTOBUF_CONSTEXPR VisionInferenceResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VisionInferenceResponse(const VisionInferenceResponse& from);
  VisionInferenceResponse(VisionInferenceResponse&& from) noexcept
    : VisionInferenceResponse() {
    *this = ::std::move(from);
  }

  inline VisionInferenceResponse& operator=(const VisionInferenceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline VisionInferenceResponse& operator=(VisionInferenceResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VisionInferenceResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const VisionInferenceResponse* internal_default_instance() {
    return reinterpret_cast<const VisionInferenceResponse*>(
               &_VisionInferenceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(VisionInferenceResponse& a, VisionInferenceResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(VisionInferenceResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VisionInferenceResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VisionInferenceResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VisionInferenceResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VisionInferenceResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VisionInferenceResponse& from) {
    VisionInferenceResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VisionInferenceResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "multimodal.VisionInferenceResponse";
  }
  protected:
  explicit VisionInferenceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 5,
    kUiElementsFieldNumber = 7,
    kTagsFieldNumber = 8,
    kDescriptionFieldNumber = 1,
    kModelUsedFieldNumber = 3,
    kExtractedTextFieldNumber = 6,
    kErrorFieldNumber = 9,
    kConfidenceFieldNumber = 2,
    kProcessingTimeFieldNumber = 4,
    kSuccessFieldNumber = 10,
  };
  // map<string, string> metadata = 5;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;
  public:
  void clear_metadata();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_metadata();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_metadata();

  // repeated .multimodal.UIElement ui_elements = 7;
  int ui_elements_size() const;
  private:
  int _internal_ui_elements_size() const;
  public:
  void clear_ui_elements();
  ::multimodal::UIElement* mutable_ui_elements(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::multimodal::UIElement >*
      mutable_ui_elements();
  private:
  const ::multimodal::UIElement& _internal_ui_elements(int index) const;
  ::multimodal::UIElement* _internal_add_ui_elements();
  public:
  const ::multimodal::UIElement& ui_elements(int index) const;
  ::multimodal::UIElement* add_ui_elements();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::multimodal::UIElement >&
      ui_elements() const;

  // repeated string tags = 8;
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  const std::string& tags(int index) const;
  std::string* mutable_tags(int index);
  void set_tags(int index, const std::string& value);
  void set_tags(int index, std::string&& value);
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, size_t size);
  std::string* add_tags();
  void add_tags(const std::string& value);
  void add_tags(std::string&& value);
  void add_tags(const char* value);
  void add_tags(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tags();
  private:
  const std::string& _internal_tags(int index) const;
  std::string* _internal_add_tags();
  public:

  // string description = 1;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string model_used = 3;
  void clear_model_used();
  const std::string& model_used() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_used(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_used();
  PROTOBUF_NODISCARD std::string* release_model_used();
  void set_allocated_model_used(std::string* model_used);
  private:
  const std::string& _internal_model_used() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_used(const std::string& value);
  std::string* _internal_mutable_model_used();
  public:

  // string extracted_text = 6;
  void clear_extracted_text();
  const std::string& extracted_text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_extracted_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_extracted_text();
  PROTOBUF_NODISCARD std::string* release_extracted_text();
  void set_allocated_extracted_text(std::string* extracted_text);
  private:
  const std::string& _internal_extracted_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_extracted_text(const std::string& value);
  std::string* _internal_mutable_extracted_text();
  public:

  // string error = 9;
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // double confidence = 2;
  void clear_confidence();
  double confidence() const;
  void set_confidence(double value);
  private:
  double _internal_confidence() const;
  void _internal_set_confidence(double value);
  public:

  // double processing_time = 4;
  void clear_processing_time();
  double processing_time() const;
  void set_processing_time(double value);
  private:
  double _internal_processing_time() const;
  void _internal_set_processing_time(double value);
  public:

  // bool success = 10;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:multimodal.VisionInferenceResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        VisionInferenceResponse_MetadataEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> metadata_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::multimodal::UIElement > ui_elements_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tags_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_used_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr extracted_text_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    double confidence_;
    double processing_time_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vision_5fservice_2eproto;
};
// -------------------------------------------------------------------

class UIElement_PropertiesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<UIElement_PropertiesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<UIElement_PropertiesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  UIElement_PropertiesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR UIElement_PropertiesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit UIElement_PropertiesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const UIElement_PropertiesEntry_DoNotUse& other);
  static const UIElement_PropertiesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const UIElement_PropertiesEntry_DoNotUse*>(&_UIElement_PropertiesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "multimodal.UIElement.PropertiesEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "multimodal.UIElement.PropertiesEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_vision_5fservice_2eproto;
};

// -------------------------------------------------------------------

class UIElement final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:multimodal.UIElement) */ {
 public:
  inline UIElement() : UIElement(nullptr) {}
  ~UIElement() override;
  explicit PROTOBUF_CONSTEXPR UIElement(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UIElement(const UIElement& from);
  UIElement(UIElement&& from) noexcept
    : UIElement() {
    *this = ::std::move(from);
  }

  inline UIElement& operator=(const UIElement& from) {
    CopyFrom(from);
    return *this;
  }
  inline UIElement& operator=(UIElement&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UIElement& default_instance() {
    return *internal_default_instance();
  }
  static inline const UIElement* internal_default_instance() {
    return reinterpret_cast<const UIElement*>(
               &_UIElement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(UIElement& a, UIElement& b) {
    a.Swap(&b);
  }
  inline void Swap(UIElement* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UIElement* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UIElement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UIElement>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UIElement& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UIElement& from) {
    UIElement::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UIElement* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "multimodal.UIElement";
  }
  protected:
  explicit UIElement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kPropertiesFieldNumber = 4,
    kTypeFieldNumber = 1,
    kBoundsFieldNumber = 3,
    kConfidenceFieldNumber = 2,
  };
  // map<string, string> properties = 4;
  int properties_size() const;
  private:
  int _internal_properties_size() const;
  public:
  void clear_properties();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_properties() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_properties();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      properties() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_properties();

  // string type = 1;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // .multimodal.ElementBounds bounds = 3;
  bool has_bounds() const;
  private:
  bool _internal_has_bounds() const;
  public:
  void clear_bounds();
  const ::multimodal::ElementBounds& bounds() const;
  PROTOBUF_NODISCARD ::multimodal::ElementBounds* release_bounds();
  ::multimodal::ElementBounds* mutable_bounds();
  void set_allocated_bounds(::multimodal::ElementBounds* bounds);
  private:
  const ::multimodal::ElementBounds& _internal_bounds() const;
  ::multimodal::ElementBounds* _internal_mutable_bounds();
  public:
  void unsafe_arena_set_allocated_bounds(
      ::multimodal::ElementBounds* bounds);
  ::multimodal::ElementBounds* unsafe_arena_release_bounds();

  // double confidence = 2;
  void clear_confidence();
  double confidence() const;
  void set_confidence(double value);
  private:
  double _internal_confidence() const;
  void _internal_set_confidence(double value);
  public:

  // @@protoc_insertion_point(class_scope:multimodal.UIElement)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        UIElement_PropertiesEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> properties_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::multimodal::ElementBounds* bounds_;
    double confidence_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vision_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ElementBounds final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:multimodal.ElementBounds) */ {
 public:
  inline ElementBounds() : ElementBounds(nullptr) {}
  ~ElementBounds() override;
  explicit PROTOBUF_CONSTEXPR ElementBounds(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ElementBounds(const ElementBounds& from);
  ElementBounds(ElementBounds&& from) noexcept
    : ElementBounds() {
    *this = ::std::move(from);
  }

  inline ElementBounds& operator=(const ElementBounds& from) {
    CopyFrom(from);
    return *this;
  }
  inline ElementBounds& operator=(ElementBounds&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ElementBounds& default_instance() {
    return *internal_default_instance();
  }
  static inline const ElementBounds* internal_default_instance() {
    return reinterpret_cast<const ElementBounds*>(
               &_ElementBounds_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ElementBounds& a, ElementBounds& b) {
    a.Swap(&b);
  }
  inline void Swap(ElementBounds* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ElementBounds* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ElementBounds* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ElementBounds>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ElementBounds& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ElementBounds& from) {
    ElementBounds::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ElementBounds* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "multimodal.ElementBounds";
  }
  protected:
  explicit ElementBounds(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kWidthFieldNumber = 3,
    kHeightFieldNumber = 4,
  };
  // int32 x = 1;
  void clear_x();
  int32_t x() const;
  void set_x(int32_t value);
  private:
  int32_t _internal_x() const;
  void _internal_set_x(int32_t value);
  public:

  // int32 y = 2;
  void clear_y();
  int32_t y() const;
  void set_y(int32_t value);
  private:
  int32_t _internal_y() const;
  void _internal_set_y(int32_t value);
  public:

  // int32 width = 3;
  void clear_width();
  int32_t width() const;
  void set_width(int32_t value);
  private:
  int32_t _internal_width() const;
  void _internal_set_width(int32_t value);
  public:

  // int32 height = 4;
  void clear_height();
  int32_t height() const;
  void set_height(int32_t value);
  private:
  int32_t _internal_height() const;
  void _internal_set_height(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:multimodal.ElementBounds)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t x_;
    int32_t y_;
    int32_t width_;
    int32_t height_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vision_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ModelsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:multimodal.ModelsResponse) */ {
 public:
  inline ModelsResponse() : ModelsResponse(nullptr) {}
  ~ModelsResponse() override;
  explicit PROTOBUF_CONSTEXPR ModelsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelsResponse(const ModelsResponse& from);
  ModelsResponse(ModelsResponse&& from) noexcept
    : ModelsResponse() {
    *this = ::std::move(from);
  }

  inline ModelsResponse& operator=(const ModelsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelsResponse& operator=(ModelsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelsResponse* internal_default_instance() {
    return reinterpret_cast<const ModelsResponse*>(
               &_ModelsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ModelsResponse& a, ModelsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelsResponse& from) {
    ModelsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "multimodal.ModelsResponse";
  }
  protected:
  explicit ModelsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelsFieldNumber = 1,
  };
  // repeated .multimodal.ModelInfo models = 1;
  int models_size() const;
  private:
  int _internal_models_size() const;
  public:
  void clear_models();
  ::multimodal::ModelInfo* mutable_models(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::multimodal::ModelInfo >*
      mutable_models();
  private:
  const ::multimodal::ModelInfo& _internal_models(int index) const;
  ::multimodal::ModelInfo* _internal_add_models();
  public:
  const ::multimodal::ModelInfo& models(int index) const;
  ::multimodal::ModelInfo* add_models();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::multimodal::ModelInfo >&
      models() const;

  // @@protoc_insertion_point(class_scope:multimodal.ModelsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::multimodal::ModelInfo > models_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vision_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ModelInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:multimodal.ModelInfo) */ {
 public:
  inline ModelInfo() : ModelInfo(nullptr) {}
  ~ModelInfo() override;
  explicit PROTOBUF_CONSTEXPR ModelInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelInfo(const ModelInfo& from);
  ModelInfo(ModelInfo&& from) noexcept
    : ModelInfo() {
    *this = ::std::move(from);
  }

  inline ModelInfo& operator=(const ModelInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelInfo& operator=(ModelInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelInfo* internal_default_instance() {
    return reinterpret_cast<const ModelInfo*>(
               &_ModelInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ModelInfo& a, ModelInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelInfo& from) {
    ModelInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "multimodal.ModelInfo";
  }
  protected:
  explicit ModelInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSupportedTypesFieldNumber = 6,
    kNameFieldNumber = 1,
    kDisplayNameFieldNumber = 2,
    kDescriptionFieldNumber = 3,
    kMemoryUsageMbFieldNumber = 5,
    kAvailableFieldNumber = 4,
  };
  // repeated string supported_types = 6;
  int supported_types_size() const;
  private:
  int _internal_supported_types_size() const;
  public:
  void clear_supported_types();
  const std::string& supported_types(int index) const;
  std::string* mutable_supported_types(int index);
  void set_supported_types(int index, const std::string& value);
  void set_supported_types(int index, std::string&& value);
  void set_supported_types(int index, const char* value);
  void set_supported_types(int index, const char* value, size_t size);
  std::string* add_supported_types();
  void add_supported_types(const std::string& value);
  void add_supported_types(std::string&& value);
  void add_supported_types(const char* value);
  void add_supported_types(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& supported_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_supported_types();
  private:
  const std::string& _internal_supported_types(int index) const;
  std::string* _internal_add_supported_types();
  public:

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string display_name = 2;
  void clear_display_name();
  const std::string& display_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_display_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_display_name();
  PROTOBUF_NODISCARD std::string* release_display_name();
  void set_allocated_display_name(std::string* display_name);
  private:
  const std::string& _internal_display_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_display_name(const std::string& value);
  std::string* _internal_mutable_display_name();
  public:

  // string description = 3;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // int64 memory_usage_mb = 5;
  void clear_memory_usage_mb();
  int64_t memory_usage_mb() const;
  void set_memory_usage_mb(int64_t value);
  private:
  int64_t _internal_memory_usage_mb() const;
  void _internal_set_memory_usage_mb(int64_t value);
  public:

  // bool available = 4;
  void clear_available();
  bool available() const;
  void set_available(bool value);
  private:
  bool _internal_available() const;
  void _internal_set_available(bool value);
  public:

  // @@protoc_insertion_point(class_scope:multimodal.ModelInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> supported_types_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr display_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    int64_t memory_usage_mb_;
    bool available_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vision_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ModelMetricsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:multimodal.ModelMetricsRequest) */ {
 public:
  inline ModelMetricsRequest() : ModelMetricsRequest(nullptr) {}
  ~ModelMetricsRequest() override;
  explicit PROTOBUF_CONSTEXPR ModelMetricsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelMetricsRequest(const ModelMetricsRequest& from);
  ModelMetricsRequest(ModelMetricsRequest&& from) noexcept
    : ModelMetricsRequest() {
    *this = ::std::move(from);
  }

  inline ModelMetricsRequest& operator=(const ModelMetricsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelMetricsRequest& operator=(ModelMetricsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelMetricsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelMetricsRequest* internal_default_instance() {
    return reinterpret_cast<const ModelMetricsRequest*>(
               &_ModelMetricsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ModelMetricsRequest& a, ModelMetricsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelMetricsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelMetricsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelMetricsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelMetricsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelMetricsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelMetricsRequest& from) {
    ModelMetricsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelMetricsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "multimodal.ModelMetricsRequest";
  }
  protected:
  explicit ModelMetricsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelFieldNumber = 1,
  };
  // string model = 1;
  void clear_model();
  const std::string& model() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model();
  PROTOBUF_NODISCARD std::string* release_model();
  void set_allocated_model(std::string* model);
  private:
  const std::string& _internal_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model(const std::string& value);
  std::string* _internal_mutable_model();
  public:

  // @@protoc_insertion_point(class_scope:multimodal.ModelMetricsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vision_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ModelMetricsResponse_AdditionalMetricsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelMetricsResponse_AdditionalMetricsEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelMetricsResponse_AdditionalMetricsEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> SuperType;
  ModelMetricsResponse_AdditionalMetricsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ModelMetricsResponse_AdditionalMetricsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ModelMetricsResponse_AdditionalMetricsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ModelMetricsResponse_AdditionalMetricsEntry_DoNotUse& other);
  static const ModelMetricsResponse_AdditionalMetricsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ModelMetricsResponse_AdditionalMetricsEntry_DoNotUse*>(&_ModelMetricsResponse_AdditionalMetricsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "multimodal.ModelMetricsResponse.AdditionalMetricsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_vision_5fservice_2eproto;
};

// -------------------------------------------------------------------

class ModelMetricsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:multimodal.ModelMetricsResponse) */ {
 public:
  inline ModelMetricsResponse() : ModelMetricsResponse(nullptr) {}
  ~ModelMetricsResponse() override;
  explicit PROTOBUF_CONSTEXPR ModelMetricsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelMetricsResponse(const ModelMetricsResponse& from);
  ModelMetricsResponse(ModelMetricsResponse&& from) noexcept
    : ModelMetricsResponse() {
    *this = ::std::move(from);
  }

  inline ModelMetricsResponse& operator=(const ModelMetricsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelMetricsResponse& operator=(ModelMetricsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelMetricsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelMetricsResponse* internal_default_instance() {
    return reinterpret_cast<const ModelMetricsResponse*>(
               &_ModelMetricsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ModelMetricsResponse& a, ModelMetricsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelMetricsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelMetricsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelMetricsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelMetricsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelMetricsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelMetricsResponse& from) {
    ModelMetricsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelMetricsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "multimodal.ModelMetricsResponse";
  }
  protected:
  explicit ModelMetricsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kAdditionalMetricsFieldNumber = 7,
    kModelFieldNumber = 1,
    kTotalInferencesFieldNumber = 2,
    kAverageProcessingTimeFieldNumber = 3,
    kAverageConfidenceFieldNumber = 4,
    kMemoryUsageMbFieldNumber = 5,
    kGpuUtilizationFieldNumber = 6,
  };
  // map<string, double> additional_metrics = 7;
  int additional_metrics_size() const;
  private:
  int _internal_additional_metrics_size() const;
  public:
  void clear_additional_metrics();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      _internal_additional_metrics() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      _internal_mutable_additional_metrics();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      additional_metrics() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      mutable_additional_metrics();

  // string model = 1;
  void clear_model();
  const std::string& model() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model();
  PROTOBUF_NODISCARD std::string* release_model();
  void set_allocated_model(std::string* model);
  private:
  const std::string& _internal_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model(const std::string& value);
  std::string* _internal_mutable_model();
  public:

  // int64 total_inferences = 2;
  void clear_total_inferences();
  int64_t total_inferences() const;
  void set_total_inferences(int64_t value);
  private:
  int64_t _internal_total_inferences() const;
  void _internal_set_total_inferences(int64_t value);
  public:

  // double average_processing_time = 3;
  void clear_average_processing_time();
  double average_processing_time() const;
  void set_average_processing_time(double value);
  private:
  double _internal_average_processing_time() const;
  void _internal_set_average_processing_time(double value);
  public:

  // double average_confidence = 4;
  void clear_average_confidence();
  double average_confidence() const;
  void set_average_confidence(double value);
  private:
  double _internal_average_confidence() const;
  void _internal_set_average_confidence(double value);
  public:

  // int64 memory_usage_mb = 5;
  void clear_memory_usage_mb();
  int64_t memory_usage_mb() const;
  void set_memory_usage_mb(int64_t value);
  private:
  int64_t _internal_memory_usage_mb() const;
  void _internal_set_memory_usage_mb(int64_t value);
  public:

  // double gpu_utilization = 6;
  void clear_gpu_utilization();
  double gpu_utilization() const;
  void set_gpu_utilization(double value);
  private:
  double _internal_gpu_utilization() const;
  void _internal_set_gpu_utilization(double value);
  public:

  // @@protoc_insertion_point(class_scope:multimodal.ModelMetricsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ModelMetricsResponse_AdditionalMetricsEntry_DoNotUse,
        std::string, double,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> additional_metrics_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_;
    int64_t total_inferences_;
    double average_processing_time_;
    double average_confidence_;
    int64_t memory_usage_mb_;
    double gpu_utilization_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vision_5fservice_2eproto;
};
// -------------------------------------------------------------------

class Empty final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:multimodal.Empty) */ {
 public:
  inline Empty() : Empty(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Empty(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Empty(const Empty& from);
  Empty(Empty&& from) noexcept
    : Empty() {
    *this = ::std::move(from);
  }

  inline Empty& operator=(const Empty& from) {
    CopyFrom(from);
    return *this;
  }
  inline Empty& operator=(Empty&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Empty& default_instance() {
    return *internal_default_instance();
  }
  static inline const Empty* internal_default_instance() {
    return reinterpret_cast<const Empty*>(
               &_Empty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Empty& a, Empty& b) {
    a.Swap(&b);
  }
  inline void Swap(Empty* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Empty* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Empty* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Empty>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Empty& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Empty& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "multimodal.Empty";
  }
  protected:
  explicit Empty(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:multimodal.Empty)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_vision_5fservice_2eproto;
};
// -------------------------------------------------------------------

class HealthResponse_DetailsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<HealthResponse_DetailsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<HealthResponse_DetailsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  HealthResponse_DetailsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR HealthResponse_DetailsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit HealthResponse_DetailsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const HealthResponse_DetailsEntry_DoNotUse& other);
  static const HealthResponse_DetailsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const HealthResponse_DetailsEntry_DoNotUse*>(&_HealthResponse_DetailsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "multimodal.HealthResponse.DetailsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "multimodal.HealthResponse.DetailsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_vision_5fservice_2eproto;
};

// -------------------------------------------------------------------

class HealthResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:multimodal.HealthResponse) */ {
 public:
  inline HealthResponse() : HealthResponse(nullptr) {}
  ~HealthResponse() override;
  explicit PROTOBUF_CONSTEXPR HealthResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HealthResponse(const HealthResponse& from);
  HealthResponse(HealthResponse&& from) noexcept
    : HealthResponse() {
    *this = ::std::move(from);
  }

  inline HealthResponse& operator=(const HealthResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline HealthResponse& operator=(HealthResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HealthResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const HealthResponse* internal_default_instance() {
    return reinterpret_cast<const HealthResponse*>(
               &_HealthResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(HealthResponse& a, HealthResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(HealthResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HealthResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HealthResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HealthResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HealthResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HealthResponse& from) {
    HealthResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HealthResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "multimodal.HealthResponse";
  }
  protected:
  explicit HealthResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kDetailsFieldNumber = 3,
    kStatusFieldNumber = 2,
    kVersionFieldNumber = 5,
    kUptimeSecondsFieldNumber = 4,
    kHealthyFieldNumber = 1,
  };
  // map<string, string> details = 3;
  int details_size() const;
  private:
  int _internal_details_size() const;
  public:
  void clear_details();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_details() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_details();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      details() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_details();

  // string status = 2;
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // string version = 5;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // int64 uptime_seconds = 4;
  void clear_uptime_seconds();
  int64_t uptime_seconds() const;
  void set_uptime_seconds(int64_t value);
  private:
  int64_t _internal_uptime_seconds() const;
  void _internal_set_uptime_seconds(int64_t value);
  public:

  // bool healthy = 1;
  void clear_healthy();
  bool healthy() const;
  void set_healthy(bool value);
  private:
  bool _internal_healthy() const;
  void _internal_set_healthy(bool value);
  public:

  // @@protoc_insertion_point(class_scope:multimodal.HealthResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        HealthResponse_DetailsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> details_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    int64_t uptime_seconds_;
    bool healthy_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vision_5fservice_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// VisionInferenceRequest

// bytes image_data = 1;
inline void VisionInferenceRequest::clear_image_data() {
  _impl_.image_data_.ClearToEmpty();
}
inline const std::string& VisionInferenceRequest::image_data() const {
  // @@protoc_insertion_point(field_get:multimodal.VisionInferenceRequest.image_data)
  return _internal_image_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VisionInferenceRequest::set_image_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.image_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:multimodal.VisionInferenceRequest.image_data)
}
inline std::string* VisionInferenceRequest::mutable_image_data() {
  std::string* _s = _internal_mutable_image_data();
  // @@protoc_insertion_point(field_mutable:multimodal.VisionInferenceRequest.image_data)
  return _s;
}
inline const std::string& VisionInferenceRequest::_internal_image_data() const {
  return _impl_.image_data_.Get();
}
inline void VisionInferenceRequest::_internal_set_image_data(const std::string& value) {
  
  _impl_.image_data_.Set(value, GetArenaForAllocation());
}
inline std::string* VisionInferenceRequest::_internal_mutable_image_data() {
  
  return _impl_.image_data_.Mutable(GetArenaForAllocation());
}
inline std::string* VisionInferenceRequest::release_image_data() {
  // @@protoc_insertion_point(field_release:multimodal.VisionInferenceRequest.image_data)
  return _impl_.image_data_.Release();
}
inline void VisionInferenceRequest::set_allocated_image_data(std::string* image_data) {
  if (image_data != nullptr) {
    
  } else {
    
  }
  _impl_.image_data_.SetAllocated(image_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.image_data_.IsDefault()) {
    _impl_.image_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:multimodal.VisionInferenceRequest.image_data)
}

// string model = 2;
inline void VisionInferenceRequest::clear_model() {
  _impl_.model_.ClearToEmpty();
}
inline const std::string& VisionInferenceRequest::model() const {
  // @@protoc_insertion_point(field_get:multimodal.VisionInferenceRequest.model)
  return _internal_model();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VisionInferenceRequest::set_model(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:multimodal.VisionInferenceRequest.model)
}
inline std::string* VisionInferenceRequest::mutable_model() {
  std::string* _s = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:multimodal.VisionInferenceRequest.model)
  return _s;
}
inline const std::string& VisionInferenceRequest::_internal_model() const {
  return _impl_.model_.Get();
}
inline void VisionInferenceRequest::_internal_set_model(const std::string& value) {
  
  _impl_.model_.Set(value, GetArenaForAllocation());
}
inline std::string* VisionInferenceRequest::_internal_mutable_model() {
  
  return _impl_.model_.Mutable(GetArenaForAllocation());
}
inline std::string* VisionInferenceRequest::release_model() {
  // @@protoc_insertion_point(field_release:multimodal.VisionInferenceRequest.model)
  return _impl_.model_.Release();
}
inline void VisionInferenceRequest::set_allocated_model(std::string* model) {
  if (model != nullptr) {
    
  } else {
    
  }
  _impl_.model_.SetAllocated(model, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_.IsDefault()) {
    _impl_.model_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:multimodal.VisionInferenceRequest.model)
}

// string prompt = 3;
inline void VisionInferenceRequest::clear_prompt() {
  _impl_.prompt_.ClearToEmpty();
}
inline const std::string& VisionInferenceRequest::prompt() const {
  // @@protoc_insertion_point(field_get:multimodal.VisionInferenceRequest.prompt)
  return _internal_prompt();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VisionInferenceRequest::set_prompt(ArgT0&& arg0, ArgT... args) {
 
 _impl_.prompt_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:multimodal.VisionInferenceRequest.prompt)
}
inline std::string* VisionInferenceRequest::mutable_prompt() {
  std::string* _s = _internal_mutable_prompt();
  // @@protoc_insertion_point(field_mutable:multimodal.VisionInferenceRequest.prompt)
  return _s;
}
inline const std::string& VisionInferenceRequest::_internal_prompt() const {
  return _impl_.prompt_.Get();
}
inline void VisionInferenceRequest::_internal_set_prompt(const std::string& value) {
  
  _impl_.prompt_.Set(value, GetArenaForAllocation());
}
inline std::string* VisionInferenceRequest::_internal_mutable_prompt() {
  
  return _impl_.prompt_.Mutable(GetArenaForAllocation());
}
inline std::string* VisionInferenceRequest::release_prompt() {
  // @@protoc_insertion_point(field_release:multimodal.VisionInferenceRequest.prompt)
  return _impl_.prompt_.Release();
}
inline void VisionInferenceRequest::set_allocated_prompt(std::string* prompt) {
  if (prompt != nullptr) {
    
  } else {
    
  }
  _impl_.prompt_.SetAllocated(prompt, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.prompt_.IsDefault()) {
    _impl_.prompt_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:multimodal.VisionInferenceRequest.prompt)
}

// string analysis_type = 4;
inline void VisionInferenceRequest::clear_analysis_type() {
  _impl_.analysis_type_.ClearToEmpty();
}
inline const std::string& VisionInferenceRequest::analysis_type() const {
  // @@protoc_insertion_point(field_get:multimodal.VisionInferenceRequest.analysis_type)
  return _internal_analysis_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VisionInferenceRequest::set_analysis_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.analysis_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:multimodal.VisionInferenceRequest.analysis_type)
}
inline std::string* VisionInferenceRequest::mutable_analysis_type() {
  std::string* _s = _internal_mutable_analysis_type();
  // @@protoc_insertion_point(field_mutable:multimodal.VisionInferenceRequest.analysis_type)
  return _s;
}
inline const std::string& VisionInferenceRequest::_internal_analysis_type() const {
  return _impl_.analysis_type_.Get();
}
inline void VisionInferenceRequest::_internal_set_analysis_type(const std::string& value) {
  
  _impl_.analysis_type_.Set(value, GetArenaForAllocation());
}
inline std::string* VisionInferenceRequest::_internal_mutable_analysis_type() {
  
  return _impl_.analysis_type_.Mutable(GetArenaForAllocation());
}
inline std::string* VisionInferenceRequest::release_analysis_type() {
  // @@protoc_insertion_point(field_release:multimodal.VisionInferenceRequest.analysis_type)
  return _impl_.analysis_type_.Release();
}
inline void VisionInferenceRequest::set_allocated_analysis_type(std::string* analysis_type) {
  if (analysis_type != nullptr) {
    
  } else {
    
  }
  _impl_.analysis_type_.SetAllocated(analysis_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.analysis_type_.IsDefault()) {
    _impl_.analysis_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:multimodal.VisionInferenceRequest.analysis_type)
}

// int32 max_tokens = 5;
inline void VisionInferenceRequest::clear_max_tokens() {
  _impl_.max_tokens_ = 0;
}
inline int32_t VisionInferenceRequest::_internal_max_tokens() const {
  return _impl_.max_tokens_;
}
inline int32_t VisionInferenceRequest::max_tokens() const {
  // @@protoc_insertion_point(field_get:multimodal.VisionInferenceRequest.max_tokens)
  return _internal_max_tokens();
}
inline void VisionInferenceRequest::_internal_set_max_tokens(int32_t value) {
  
  _impl_.max_tokens_ = value;
}
inline void VisionInferenceRequest::set_max_tokens(int32_t value) {
  _internal_set_max_tokens(value);
  // @@protoc_insertion_point(field_set:multimodal.VisionInferenceRequest.max_tokens)
}

// float temperature = 6;
inline void VisionInferenceRequest::clear_temperature() {
  _impl_.temperature_ = 0;
}
inline float VisionInferenceRequest::_internal_temperature() const {
  return _impl_.temperature_;
}
inline float VisionInferenceRequest::temperature() const {
  // @@protoc_insertion_point(field_get:multimodal.VisionInferenceRequest.temperature)
  return _internal_temperature();
}
inline void VisionInferenceRequest::_internal_set_temperature(float value) {
  
  _impl_.temperature_ = value;
}
inline void VisionInferenceRequest::set_temperature(float value) {
  _internal_set_temperature(value);
  // @@protoc_insertion_point(field_set:multimodal.VisionInferenceRequest.temperature)
}

// map<string, string> parameters = 7;
inline int VisionInferenceRequest::_internal_parameters_size() const {
  return _impl_.parameters_.size();
}
inline int VisionInferenceRequest::parameters_size() const {
  return _internal_parameters_size();
}
inline void VisionInferenceRequest::clear_parameters() {
  _impl_.parameters_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
VisionInferenceRequest::_internal_parameters() const {
  return _impl_.parameters_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
VisionInferenceRequest::parameters() const {
  // @@protoc_insertion_point(field_map:multimodal.VisionInferenceRequest.parameters)
  return _internal_parameters();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
VisionInferenceRequest::_internal_mutable_parameters() {
  return _impl_.parameters_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
VisionInferenceRequest::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_map:multimodal.VisionInferenceRequest.parameters)
  return _internal_mutable_parameters();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// VisionInferenceResponse

// string description = 1;
inline void VisionInferenceResponse::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& VisionInferenceResponse::description() const {
  // @@protoc_insertion_point(field_get:multimodal.VisionInferenceResponse.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VisionInferenceResponse::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:multimodal.VisionInferenceResponse.description)
}
inline std::string* VisionInferenceResponse::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:multimodal.VisionInferenceResponse.description)
  return _s;
}
inline const std::string& VisionInferenceResponse::_internal_description() const {
  return _impl_.description_.Get();
}
inline void VisionInferenceResponse::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* VisionInferenceResponse::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* VisionInferenceResponse::release_description() {
  // @@protoc_insertion_point(field_release:multimodal.VisionInferenceResponse.description)
  return _impl_.description_.Release();
}
inline void VisionInferenceResponse::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:multimodal.VisionInferenceResponse.description)
}

// double confidence = 2;
inline void VisionInferenceResponse::clear_confidence() {
  _impl_.confidence_ = 0;
}
inline double VisionInferenceResponse::_internal_confidence() const {
  return _impl_.confidence_;
}
inline double VisionInferenceResponse::confidence() const {
  // @@protoc_insertion_point(field_get:multimodal.VisionInferenceResponse.confidence)
  return _internal_confidence();
}
inline void VisionInferenceResponse::_internal_set_confidence(double value) {
  
  _impl_.confidence_ = value;
}
inline void VisionInferenceResponse::set_confidence(double value) {
  _internal_set_confidence(value);
  // @@protoc_insertion_point(field_set:multimodal.VisionInferenceResponse.confidence)
}

// string model_used = 3;
inline void VisionInferenceResponse::clear_model_used() {
  _impl_.model_used_.ClearToEmpty();
}
inline const std::string& VisionInferenceResponse::model_used() const {
  // @@protoc_insertion_point(field_get:multimodal.VisionInferenceResponse.model_used)
  return _internal_model_used();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VisionInferenceResponse::set_model_used(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_used_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:multimodal.VisionInferenceResponse.model_used)
}
inline std::string* VisionInferenceResponse::mutable_model_used() {
  std::string* _s = _internal_mutable_model_used();
  // @@protoc_insertion_point(field_mutable:multimodal.VisionInferenceResponse.model_used)
  return _s;
}
inline const std::string& VisionInferenceResponse::_internal_model_used() const {
  return _impl_.model_used_.Get();
}
inline void VisionInferenceResponse::_internal_set_model_used(const std::string& value) {
  
  _impl_.model_used_.Set(value, GetArenaForAllocation());
}
inline std::string* VisionInferenceResponse::_internal_mutable_model_used() {
  
  return _impl_.model_used_.Mutable(GetArenaForAllocation());
}
inline std::string* VisionInferenceResponse::release_model_used() {
  // @@protoc_insertion_point(field_release:multimodal.VisionInferenceResponse.model_used)
  return _impl_.model_used_.Release();
}
inline void VisionInferenceResponse::set_allocated_model_used(std::string* model_used) {
  if (model_used != nullptr) {
    
  } else {
    
  }
  _impl_.model_used_.SetAllocated(model_used, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_used_.IsDefault()) {
    _impl_.model_used_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:multimodal.VisionInferenceResponse.model_used)
}

// double processing_time = 4;
inline void VisionInferenceResponse::clear_processing_time() {
  _impl_.processing_time_ = 0;
}
inline double VisionInferenceResponse::_internal_processing_time() const {
  return _impl_.processing_time_;
}
inline double VisionInferenceResponse::processing_time() const {
  // @@protoc_insertion_point(field_get:multimodal.VisionInferenceResponse.processing_time)
  return _internal_processing_time();
}
inline void VisionInferenceResponse::_internal_set_processing_time(double value) {
  
  _impl_.processing_time_ = value;
}
inline void VisionInferenceResponse::set_processing_time(double value) {
  _internal_set_processing_time(value);
  // @@protoc_insertion_point(field_set:multimodal.VisionInferenceResponse.processing_time)
}

// map<string, string> metadata = 5;
inline int VisionInferenceResponse::_internal_metadata_size() const {
  return _impl_.metadata_.size();
}
inline int VisionInferenceResponse::metadata_size() const {
  return _internal_metadata_size();
}
inline void VisionInferenceResponse::clear_metadata() {
  _impl_.metadata_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
VisionInferenceResponse::_internal_metadata() const {
  return _impl_.metadata_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
VisionInferenceResponse::metadata() const {
  // @@protoc_insertion_point(field_map:multimodal.VisionInferenceResponse.metadata)
  return _internal_metadata();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
VisionInferenceResponse::_internal_mutable_metadata() {
  return _impl_.metadata_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
VisionInferenceResponse::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_map:multimodal.VisionInferenceResponse.metadata)
  return _internal_mutable_metadata();
}

// string extracted_text = 6;
inline void VisionInferenceResponse::clear_extracted_text() {
  _impl_.extracted_text_.ClearToEmpty();
}
inline const std::string& VisionInferenceResponse::extracted_text() const {
  // @@protoc_insertion_point(field_get:multimodal.VisionInferenceResponse.extracted_text)
  return _internal_extracted_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VisionInferenceResponse::set_extracted_text(ArgT0&& arg0, ArgT... args) {
 
 _impl_.extracted_text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:multimodal.VisionInferenceResponse.extracted_text)
}
inline std::string* VisionInferenceResponse::mutable_extracted_text() {
  std::string* _s = _internal_mutable_extracted_text();
  // @@protoc_insertion_point(field_mutable:multimodal.VisionInferenceResponse.extracted_text)
  return _s;
}
inline const std::string& VisionInferenceResponse::_internal_extracted_text() const {
  return _impl_.extracted_text_.Get();
}
inline void VisionInferenceResponse::_internal_set_extracted_text(const std::string& value) {
  
  _impl_.extracted_text_.Set(value, GetArenaForAllocation());
}
inline std::string* VisionInferenceResponse::_internal_mutable_extracted_text() {
  
  return _impl_.extracted_text_.Mutable(GetArenaForAllocation());
}
inline std::string* VisionInferenceResponse::release_extracted_text() {
  // @@protoc_insertion_point(field_release:multimodal.VisionInferenceResponse.extracted_text)
  return _impl_.extracted_text_.Release();
}
inline void VisionInferenceResponse::set_allocated_extracted_text(std::string* extracted_text) {
  if (extracted_text != nullptr) {
    
  } else {
    
  }
  _impl_.extracted_text_.SetAllocated(extracted_text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.extracted_text_.IsDefault()) {
    _impl_.extracted_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:multimodal.VisionInferenceResponse.extracted_text)
}

// repeated .multimodal.UIElement ui_elements = 7;
inline int VisionInferenceResponse::_internal_ui_elements_size() const {
  return _impl_.ui_elements_.size();
}
inline int VisionInferenceResponse::ui_elements_size() const {
  return _internal_ui_elements_size();
}
inline void VisionInferenceResponse::clear_ui_elements() {
  _impl_.ui_elements_.Clear();
}
inline ::multimodal::UIElement* VisionInferenceResponse::mutable_ui_elements(int index) {
  // @@protoc_insertion_point(field_mutable:multimodal.VisionInferenceResponse.ui_elements)
  return _impl_.ui_elements_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::multimodal::UIElement >*
VisionInferenceResponse::mutable_ui_elements() {
  // @@protoc_insertion_point(field_mutable_list:multimodal.VisionInferenceResponse.ui_elements)
  return &_impl_.ui_elements_;
}
inline const ::multimodal::UIElement& VisionInferenceResponse::_internal_ui_elements(int index) const {
  return _impl_.ui_elements_.Get(index);
}
inline const ::multimodal::UIElement& VisionInferenceResponse::ui_elements(int index) const {
  // @@protoc_insertion_point(field_get:multimodal.VisionInferenceResponse.ui_elements)
  return _internal_ui_elements(index);
}
inline ::multimodal::UIElement* VisionInferenceResponse::_internal_add_ui_elements() {
  return _impl_.ui_elements_.Add();
}
inline ::multimodal::UIElement* VisionInferenceResponse::add_ui_elements() {
  ::multimodal::UIElement* _add = _internal_add_ui_elements();
  // @@protoc_insertion_point(field_add:multimodal.VisionInferenceResponse.ui_elements)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::multimodal::UIElement >&
VisionInferenceResponse::ui_elements() const {
  // @@protoc_insertion_point(field_list:multimodal.VisionInferenceResponse.ui_elements)
  return _impl_.ui_elements_;
}

// repeated string tags = 8;
inline int VisionInferenceResponse::_internal_tags_size() const {
  return _impl_.tags_.size();
}
inline int VisionInferenceResponse::tags_size() const {
  return _internal_tags_size();
}
inline void VisionInferenceResponse::clear_tags() {
  _impl_.tags_.Clear();
}
inline std::string* VisionInferenceResponse::add_tags() {
  std::string* _s = _internal_add_tags();
  // @@protoc_insertion_point(field_add_mutable:multimodal.VisionInferenceResponse.tags)
  return _s;
}
inline const std::string& VisionInferenceResponse::_internal_tags(int index) const {
  return _impl_.tags_.Get(index);
}
inline const std::string& VisionInferenceResponse::tags(int index) const {
  // @@protoc_insertion_point(field_get:multimodal.VisionInferenceResponse.tags)
  return _internal_tags(index);
}
inline std::string* VisionInferenceResponse::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:multimodal.VisionInferenceResponse.tags)
  return _impl_.tags_.Mutable(index);
}
inline void VisionInferenceResponse::set_tags(int index, const std::string& value) {
  _impl_.tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:multimodal.VisionInferenceResponse.tags)
}
inline void VisionInferenceResponse::set_tags(int index, std::string&& value) {
  _impl_.tags_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:multimodal.VisionInferenceResponse.tags)
}
inline void VisionInferenceResponse::set_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:multimodal.VisionInferenceResponse.tags)
}
inline void VisionInferenceResponse::set_tags(int index, const char* value, size_t size) {
  _impl_.tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:multimodal.VisionInferenceResponse.tags)
}
inline std::string* VisionInferenceResponse::_internal_add_tags() {
  return _impl_.tags_.Add();
}
inline void VisionInferenceResponse::add_tags(const std::string& value) {
  _impl_.tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:multimodal.VisionInferenceResponse.tags)
}
inline void VisionInferenceResponse::add_tags(std::string&& value) {
  _impl_.tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:multimodal.VisionInferenceResponse.tags)
}
inline void VisionInferenceResponse::add_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:multimodal.VisionInferenceResponse.tags)
}
inline void VisionInferenceResponse::add_tags(const char* value, size_t size) {
  _impl_.tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:multimodal.VisionInferenceResponse.tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
VisionInferenceResponse::tags() const {
  // @@protoc_insertion_point(field_list:multimodal.VisionInferenceResponse.tags)
  return _impl_.tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
VisionInferenceResponse::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:multimodal.VisionInferenceResponse.tags)
  return &_impl_.tags_;
}

// string error = 9;
inline void VisionInferenceResponse::clear_error() {
  _impl_.error_.ClearToEmpty();
}
inline const std::string& VisionInferenceResponse::error() const {
  // @@protoc_insertion_point(field_get:multimodal.VisionInferenceResponse.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VisionInferenceResponse::set_error(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:multimodal.VisionInferenceResponse.error)
}
inline std::string* VisionInferenceResponse::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:multimodal.VisionInferenceResponse.error)
  return _s;
}
inline const std::string& VisionInferenceResponse::_internal_error() const {
  return _impl_.error_.Get();
}
inline void VisionInferenceResponse::_internal_set_error(const std::string& value) {
  
  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* VisionInferenceResponse::_internal_mutable_error() {
  
  return _impl_.error_.Mutable(GetArenaForAllocation());
}
inline std::string* VisionInferenceResponse::release_error() {
  // @@protoc_insertion_point(field_release:multimodal.VisionInferenceResponse.error)
  return _impl_.error_.Release();
}
inline void VisionInferenceResponse::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  _impl_.error_.SetAllocated(error, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:multimodal.VisionInferenceResponse.error)
}

// bool success = 10;
inline void VisionInferenceResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool VisionInferenceResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool VisionInferenceResponse::success() const {
  // @@protoc_insertion_point(field_get:multimodal.VisionInferenceResponse.success)
  return _internal_success();
}
inline void VisionInferenceResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void VisionInferenceResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:multimodal.VisionInferenceResponse.success)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// UIElement

// string type = 1;
inline void UIElement::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& UIElement::type() const {
  // @@protoc_insertion_point(field_get:multimodal.UIElement.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UIElement::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:multimodal.UIElement.type)
}
inline std::string* UIElement::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:multimodal.UIElement.type)
  return _s;
}
inline const std::string& UIElement::_internal_type() const {
  return _impl_.type_.Get();
}
inline void UIElement::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* UIElement::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* UIElement::release_type() {
  // @@protoc_insertion_point(field_release:multimodal.UIElement.type)
  return _impl_.type_.Release();
}
inline void UIElement::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:multimodal.UIElement.type)
}

// double confidence = 2;
inline void UIElement::clear_confidence() {
  _impl_.confidence_ = 0;
}
inline double UIElement::_internal_confidence() const {
  return _impl_.confidence_;
}
inline double UIElement::confidence() const {
  // @@protoc_insertion_point(field_get:multimodal.UIElement.confidence)
  return _internal_confidence();
}
inline void UIElement::_internal_set_confidence(double value) {
  
  _impl_.confidence_ = value;
}
inline void UIElement::set_confidence(double value) {
  _internal_set_confidence(value);
  // @@protoc_insertion_point(field_set:multimodal.UIElement.confidence)
}

// .multimodal.ElementBounds bounds = 3;
inline bool UIElement::_internal_has_bounds() const {
  return this != internal_default_instance() && _impl_.bounds_ != nullptr;
}
inline bool UIElement::has_bounds() const {
  return _internal_has_bounds();
}
inline void UIElement::clear_bounds() {
  if (GetArenaForAllocation() == nullptr && _impl_.bounds_ != nullptr) {
    delete _impl_.bounds_;
  }
  _impl_.bounds_ = nullptr;
}
inline const ::multimodal::ElementBounds& UIElement::_internal_bounds() const {
  const ::multimodal::ElementBounds* p = _impl_.bounds_;
  return p != nullptr ? *p : reinterpret_cast<const ::multimodal::ElementBounds&>(
      ::multimodal::_ElementBounds_default_instance_);
}
inline const ::multimodal::ElementBounds& UIElement::bounds() const {
  // @@protoc_insertion_point(field_get:multimodal.UIElement.bounds)
  return _internal_bounds();
}
inline void UIElement::unsafe_arena_set_allocated_bounds(
    ::multimodal::ElementBounds* bounds) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bounds_);
  }
  _impl_.bounds_ = bounds;
  if (bounds) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:multimodal.UIElement.bounds)
}
inline ::multimodal::ElementBounds* UIElement::release_bounds() {
  
  ::multimodal::ElementBounds* temp = _impl_.bounds_;
  _impl_.bounds_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::multimodal::ElementBounds* UIElement::unsafe_arena_release_bounds() {
  // @@protoc_insertion_point(field_release:multimodal.UIElement.bounds)
  
  ::multimodal::ElementBounds* temp = _impl_.bounds_;
  _impl_.bounds_ = nullptr;
  return temp;
}
inline ::multimodal::ElementBounds* UIElement::_internal_mutable_bounds() {
  
  if (_impl_.bounds_ == nullptr) {
    auto* p = CreateMaybeMessage<::multimodal::ElementBounds>(GetArenaForAllocation());
    _impl_.bounds_ = p;
  }
  return _impl_.bounds_;
}
inline ::multimodal::ElementBounds* UIElement::mutable_bounds() {
  ::multimodal::ElementBounds* _msg = _internal_mutable_bounds();
  // @@protoc_insertion_point(field_mutable:multimodal.UIElement.bounds)
  return _msg;
}
inline void UIElement::set_allocated_bounds(::multimodal::ElementBounds* bounds) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.bounds_;
  }
  if (bounds) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(bounds);
    if (message_arena != submessage_arena) {
      bounds = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bounds, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.bounds_ = bounds;
  // @@protoc_insertion_point(field_set_allocated:multimodal.UIElement.bounds)
}

// map<string, string> properties = 4;
inline int UIElement::_internal_properties_size() const {
  return _impl_.properties_.size();
}
inline int UIElement::properties_size() const {
  return _internal_properties_size();
}
inline void UIElement::clear_properties() {
  _impl_.properties_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
UIElement::_internal_properties() const {
  return _impl_.properties_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
UIElement::properties() const {
  // @@protoc_insertion_point(field_map:multimodal.UIElement.properties)
  return _internal_properties();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
UIElement::_internal_mutable_properties() {
  return _impl_.properties_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
UIElement::mutable_properties() {
  // @@protoc_insertion_point(field_mutable_map:multimodal.UIElement.properties)
  return _internal_mutable_properties();
}

// -------------------------------------------------------------------

// ElementBounds

// int32 x = 1;
inline void ElementBounds::clear_x() {
  _impl_.x_ = 0;
}
inline int32_t ElementBounds::_internal_x() const {
  return _impl_.x_;
}
inline int32_t ElementBounds::x() const {
  // @@protoc_insertion_point(field_get:multimodal.ElementBounds.x)
  return _internal_x();
}
inline void ElementBounds::_internal_set_x(int32_t value) {
  
  _impl_.x_ = value;
}
inline void ElementBounds::set_x(int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:multimodal.ElementBounds.x)
}

// int32 y = 2;
inline void ElementBounds::clear_y() {
  _impl_.y_ = 0;
}
inline int32_t ElementBounds::_internal_y() const {
  return _impl_.y_;
}
inline int32_t ElementBounds::y() const {
  // @@protoc_insertion_point(field_get:multimodal.ElementBounds.y)
  return _internal_y();
}
inline void ElementBounds::_internal_set_y(int32_t value) {
  
  _impl_.y_ = value;
}
inline void ElementBounds::set_y(int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:multimodal.ElementBounds.y)
}

// int32 width = 3;
inline void ElementBounds::clear_width() {
  _impl_.width_ = 0;
}
inline int32_t ElementBounds::_internal_width() const {
  return _impl_.width_;
}
inline int32_t ElementBounds::width() const {
  // @@protoc_insertion_point(field_get:multimodal.ElementBounds.width)
  return _internal_width();
}
inline void ElementBounds::_internal_set_width(int32_t value) {
  
  _impl_.width_ = value;
}
inline void ElementBounds::set_width(int32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:multimodal.ElementBounds.width)
}

// int32 height = 4;
inline void ElementBounds::clear_height() {
  _impl_.height_ = 0;
}
inline int32_t ElementBounds::_internal_height() const {
  return _impl_.height_;
}
inline int32_t ElementBounds::height() const {
  // @@protoc_insertion_point(field_get:multimodal.ElementBounds.height)
  return _internal_height();
}
inline void ElementBounds::_internal_set_height(int32_t value) {
  
  _impl_.height_ = value;
}
inline void ElementBounds::set_height(int32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:multimodal.ElementBounds.height)
}

// -------------------------------------------------------------------

// ModelsResponse

// repeated .multimodal.ModelInfo models = 1;
inline int ModelsResponse::_internal_models_size() const {
  return _impl_.models_.size();
}
inline int ModelsResponse::models_size() const {
  return _internal_models_size();
}
inline void ModelsResponse::clear_models() {
  _impl_.models_.Clear();
}
inline ::multimodal::ModelInfo* ModelsResponse::mutable_models(int index) {
  // @@protoc_insertion_point(field_mutable:multimodal.ModelsResponse.models)
  return _impl_.models_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::multimodal::ModelInfo >*
ModelsResponse::mutable_models() {
  // @@protoc_insertion_point(field_mutable_list:multimodal.ModelsResponse.models)
  return &_impl_.models_;
}
inline const ::multimodal::ModelInfo& ModelsResponse::_internal_models(int index) const {
  return _impl_.models_.Get(index);
}
inline const ::multimodal::ModelInfo& ModelsResponse::models(int index) const {
  // @@protoc_insertion_point(field_get:multimodal.ModelsResponse.models)
  return _internal_models(index);
}
inline ::multimodal::ModelInfo* ModelsResponse::_internal_add_models() {
  return _impl_.models_.Add();
}
inline ::multimodal::ModelInfo* ModelsResponse::add_models() {
  ::multimodal::ModelInfo* _add = _internal_add_models();
  // @@protoc_insertion_point(field_add:multimodal.ModelsResponse.models)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::multimodal::ModelInfo >&
ModelsResponse::models() const {
  // @@protoc_insertion_point(field_list:multimodal.ModelsResponse.models)
  return _impl_.models_;
}

// -------------------------------------------------------------------

// ModelInfo

// string name = 1;
inline void ModelInfo::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ModelInfo::name() const {
  // @@protoc_insertion_point(field_get:multimodal.ModelInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelInfo::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:multimodal.ModelInfo.name)
}
inline std::string* ModelInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:multimodal.ModelInfo.name)
  return _s;
}
inline const std::string& ModelInfo::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ModelInfo::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelInfo::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelInfo::release_name() {
  // @@protoc_insertion_point(field_release:multimodal.ModelInfo.name)
  return _impl_.name_.Release();
}
inline void ModelInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:multimodal.ModelInfo.name)
}

// string display_name = 2;
inline void ModelInfo::clear_display_name() {
  _impl_.display_name_.ClearToEmpty();
}
inline const std::string& ModelInfo::display_name() const {
  // @@protoc_insertion_point(field_get:multimodal.ModelInfo.display_name)
  return _internal_display_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelInfo::set_display_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.display_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:multimodal.ModelInfo.display_name)
}
inline std::string* ModelInfo::mutable_display_name() {
  std::string* _s = _internal_mutable_display_name();
  // @@protoc_insertion_point(field_mutable:multimodal.ModelInfo.display_name)
  return _s;
}
inline const std::string& ModelInfo::_internal_display_name() const {
  return _impl_.display_name_.Get();
}
inline void ModelInfo::_internal_set_display_name(const std::string& value) {
  
  _impl_.display_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelInfo::_internal_mutable_display_name() {
  
  return _impl_.display_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelInfo::release_display_name() {
  // @@protoc_insertion_point(field_release:multimodal.ModelInfo.display_name)
  return _impl_.display_name_.Release();
}
inline void ModelInfo::set_allocated_display_name(std::string* display_name) {
  if (display_name != nullptr) {
    
  } else {
    
  }
  _impl_.display_name_.SetAllocated(display_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.display_name_.IsDefault()) {
    _impl_.display_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:multimodal.ModelInfo.display_name)
}

// string description = 3;
inline void ModelInfo::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& ModelInfo::description() const {
  // @@protoc_insertion_point(field_get:multimodal.ModelInfo.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelInfo::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:multimodal.ModelInfo.description)
}
inline std::string* ModelInfo::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:multimodal.ModelInfo.description)
  return _s;
}
inline const std::string& ModelInfo::_internal_description() const {
  return _impl_.description_.Get();
}
inline void ModelInfo::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelInfo::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelInfo::release_description() {
  // @@protoc_insertion_point(field_release:multimodal.ModelInfo.description)
  return _impl_.description_.Release();
}
inline void ModelInfo::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:multimodal.ModelInfo.description)
}

// bool available = 4;
inline void ModelInfo::clear_available() {
  _impl_.available_ = false;
}
inline bool ModelInfo::_internal_available() const {
  return _impl_.available_;
}
inline bool ModelInfo::available() const {
  // @@protoc_insertion_point(field_get:multimodal.ModelInfo.available)
  return _internal_available();
}
inline void ModelInfo::_internal_set_available(bool value) {
  
  _impl_.available_ = value;
}
inline void ModelInfo::set_available(bool value) {
  _internal_set_available(value);
  // @@protoc_insertion_point(field_set:multimodal.ModelInfo.available)
}

// int64 memory_usage_mb = 5;
inline void ModelInfo::clear_memory_usage_mb() {
  _impl_.memory_usage_mb_ = int64_t{0};
}
inline int64_t ModelInfo::_internal_memory_usage_mb() const {
  return _impl_.memory_usage_mb_;
}
inline int64_t ModelInfo::memory_usage_mb() const {
  // @@protoc_insertion_point(field_get:multimodal.ModelInfo.memory_usage_mb)
  return _internal_memory_usage_mb();
}
inline void ModelInfo::_internal_set_memory_usage_mb(int64_t value) {
  
  _impl_.memory_usage_mb_ = value;
}
inline void ModelInfo::set_memory_usage_mb(int64_t value) {
  _internal_set_memory_usage_mb(value);
  // @@protoc_insertion_point(field_set:multimodal.ModelInfo.memory_usage_mb)
}

// repeated string supported_types = 6;
inline int ModelInfo::_internal_supported_types_size() const {
  return _impl_.supported_types_.size();
}
inline int ModelInfo::supported_types_size() const {
  return _internal_supported_types_size();
}
inline void ModelInfo::clear_supported_types() {
  _impl_.supported_types_.Clear();
}
inline std::string* ModelInfo::add_supported_types() {
  std::string* _s = _internal_add_supported_types();
  // @@protoc_insertion_point(field_add_mutable:multimodal.ModelInfo.supported_types)
  return _s;
}
inline const std::string& ModelInfo::_internal_supported_types(int index) const {
  return _impl_.supported_types_.Get(index);
}
inline const std::string& ModelInfo::supported_types(int index) const {
  // @@protoc_insertion_point(field_get:multimodal.ModelInfo.supported_types)
  return _internal_supported_types(index);
}
inline std::string* ModelInfo::mutable_supported_types(int index) {
  // @@protoc_insertion_point(field_mutable:multimodal.ModelInfo.supported_types)
  return _impl_.supported_types_.Mutable(index);
}
inline void ModelInfo::set_supported_types(int index, const std::string& value) {
  _impl_.supported_types_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:multimodal.ModelInfo.supported_types)
}
inline void ModelInfo::set_supported_types(int index, std::string&& value) {
  _impl_.supported_types_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:multimodal.ModelInfo.supported_types)
}
inline void ModelInfo::set_supported_types(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.supported_types_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:multimodal.ModelInfo.supported_types)
}
inline void ModelInfo::set_supported_types(int index, const char* value, size_t size) {
  _impl_.supported_types_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:multimodal.ModelInfo.supported_types)
}
inline std::string* ModelInfo::_internal_add_supported_types() {
  return _impl_.supported_types_.Add();
}
inline void ModelInfo::add_supported_types(const std::string& value) {
  _impl_.supported_types_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:multimodal.ModelInfo.supported_types)
}
inline void ModelInfo::add_supported_types(std::string&& value) {
  _impl_.supported_types_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:multimodal.ModelInfo.supported_types)
}
inline void ModelInfo::add_supported_types(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.supported_types_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:multimodal.ModelInfo.supported_types)
}
inline void ModelInfo::add_supported_types(const char* value, size_t size) {
  _impl_.supported_types_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:multimodal.ModelInfo.supported_types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ModelInfo::supported_types() const {
  // @@protoc_insertion_point(field_list:multimodal.ModelInfo.supported_types)
  return _impl_.supported_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ModelInfo::mutable_supported_types() {
  // @@protoc_insertion_point(field_mutable_list:multimodal.ModelInfo.supported_types)
  return &_impl_.supported_types_;
}

// -------------------------------------------------------------------

// ModelMetricsRequest

// string model = 1;
inline void ModelMetricsRequest::clear_model() {
  _impl_.model_.ClearToEmpty();
}
inline const std::string& ModelMetricsRequest::model() const {
  // @@protoc_insertion_point(field_get:multimodal.ModelMetricsRequest.model)
  return _internal_model();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelMetricsRequest::set_model(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:multimodal.ModelMetricsRequest.model)
}
inline std::string* ModelMetricsRequest::mutable_model() {
  std::string* _s = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:multimodal.ModelMetricsRequest.model)
  return _s;
}
inline const std::string& ModelMetricsRequest::_internal_model() const {
  return _impl_.model_.Get();
}
inline void ModelMetricsRequest::_internal_set_model(const std::string& value) {
  
  _impl_.model_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelMetricsRequest::_internal_mutable_model() {
  
  return _impl_.model_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelMetricsRequest::release_model() {
  // @@protoc_insertion_point(field_release:multimodal.ModelMetricsRequest.model)
  return _impl_.model_.Release();
}
inline void ModelMetricsRequest::set_allocated_model(std::string* model) {
  if (model != nullptr) {
    
  } else {
    
  }
  _impl_.model_.SetAllocated(model, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_.IsDefault()) {
    _impl_.model_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:multimodal.ModelMetricsRequest.model)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ModelMetricsResponse

// string model = 1;
inline void ModelMetricsResponse::clear_model() {
  _impl_.model_.ClearToEmpty();
}
inline const std::string& ModelMetricsResponse::model() const {
  // @@protoc_insertion_point(field_get:multimodal.ModelMetricsResponse.model)
  return _internal_model();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelMetricsResponse::set_model(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:multimodal.ModelMetricsResponse.model)
}
inline std::string* ModelMetricsResponse::mutable_model() {
  std::string* _s = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:multimodal.ModelMetricsResponse.model)
  return _s;
}
inline const std::string& ModelMetricsResponse::_internal_model() const {
  return _impl_.model_.Get();
}
inline void ModelMetricsResponse::_internal_set_model(const std::string& value) {
  
  _impl_.model_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelMetricsResponse::_internal_mutable_model() {
  
  return _impl_.model_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelMetricsResponse::release_model() {
  // @@protoc_insertion_point(field_release:multimodal.ModelMetricsResponse.model)
  return _impl_.model_.Release();
}
inline void ModelMetricsResponse::set_allocated_model(std::string* model) {
  if (model != nullptr) {
    
  } else {
    
  }
  _impl_.model_.SetAllocated(model, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_.IsDefault()) {
    _impl_.model_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:multimodal.ModelMetricsResponse.model)
}

// int64 total_inferences = 2;
inline void ModelMetricsResponse::clear_total_inferences() {
  _impl_.total_inferences_ = int64_t{0};
}
inline int64_t ModelMetricsResponse::_internal_total_inferences() const {
  return _impl_.total_inferences_;
}
inline int64_t ModelMetricsResponse::total_inferences() const {
  // @@protoc_insertion_point(field_get:multimodal.ModelMetricsResponse.total_inferences)
  return _internal_total_inferences();
}
inline void ModelMetricsResponse::_internal_set_total_inferences(int64_t value) {
  
  _impl_.total_inferences_ = value;
}
inline void ModelMetricsResponse::set_total_inferences(int64_t value) {
  _internal_set_total_inferences(value);
  // @@protoc_insertion_point(field_set:multimodal.ModelMetricsResponse.total_inferences)
}

// double average_processing_time = 3;
inline void ModelMetricsResponse::clear_average_processing_time() {
  _impl_.average_processing_time_ = 0;
}
inline double ModelMetricsResponse::_internal_average_processing_time() const {
  return _impl_.average_processing_time_;
}
inline double ModelMetricsResponse::average_processing_time() const {
  // @@protoc_insertion_point(field_get:multimodal.ModelMetricsResponse.average_processing_time)
  return _internal_average_processing_time();
}
inline void ModelMetricsResponse::_internal_set_average_processing_time(double value) {
  
  _impl_.average_processing_time_ = value;
}
inline void ModelMetricsResponse::set_average_processing_time(double value) {
  _internal_set_average_processing_time(value);
  // @@protoc_insertion_point(field_set:multimodal.ModelMetricsResponse.average_processing_time)
}

// double average_confidence = 4;
inline void ModelMetricsResponse::clear_average_confidence() {
  _impl_.average_confidence_ = 0;
}
inline double ModelMetricsResponse::_internal_average_confidence() const {
  return _impl_.average_confidence_;
}
inline double ModelMetricsResponse::average_confidence() const {
  // @@protoc_insertion_point(field_get:multimodal.ModelMetricsResponse.average_confidence)
  return _internal_average_confidence();
}
inline void ModelMetricsResponse::_internal_set_average_confidence(double value) {
  
  _impl_.average_confidence_ = value;
}
inline void ModelMetricsResponse::set_average_confidence(double value) {
  _internal_set_average_confidence(value);
  // @@protoc_insertion_point(field_set:multimodal.ModelMetricsResponse.average_confidence)
}

// int64 memory_usage_mb = 5;
inline void ModelMetricsResponse::clear_memory_usage_mb() {
  _impl_.memory_usage_mb_ = int64_t{0};
}
inline int64_t ModelMetricsResponse::_internal_memory_usage_mb() const {
  return _impl_.memory_usage_mb_;
}
inline int64_t ModelMetricsResponse::memory_usage_mb() const {
  // @@protoc_insertion_point(field_get:multimodal.ModelMetricsResponse.memory_usage_mb)
  return _internal_memory_usage_mb();
}
inline void ModelMetricsResponse::_internal_set_memory_usage_mb(int64_t value) {
  
  _impl_.memory_usage_mb_ = value;
}
inline void ModelMetricsResponse::set_memory_usage_mb(int64_t value) {
  _internal_set_memory_usage_mb(value);
  // @@protoc_insertion_point(field_set:multimodal.ModelMetricsResponse.memory_usage_mb)
}

// double gpu_utilization = 6;
inline void ModelMetricsResponse::clear_gpu_utilization() {
  _impl_.gpu_utilization_ = 0;
}
inline double ModelMetricsResponse::_internal_gpu_utilization() const {
  return _impl_.gpu_utilization_;
}
inline double ModelMetricsResponse::gpu_utilization() const {
  // @@protoc_insertion_point(field_get:multimodal.ModelMetricsResponse.gpu_utilization)
  return _internal_gpu_utilization();
}
inline void ModelMetricsResponse::_internal_set_gpu_utilization(double value) {
  
  _impl_.gpu_utilization_ = value;
}
inline void ModelMetricsResponse::set_gpu_utilization(double value) {
  _internal_set_gpu_utilization(value);
  // @@protoc_insertion_point(field_set:multimodal.ModelMetricsResponse.gpu_utilization)
}

// map<string, double> additional_metrics = 7;
inline int ModelMetricsResponse::_internal_additional_metrics_size() const {
  return _impl_.additional_metrics_.size();
}
inline int ModelMetricsResponse::additional_metrics_size() const {
  return _internal_additional_metrics_size();
}
inline void ModelMetricsResponse::clear_additional_metrics() {
  _impl_.additional_metrics_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
ModelMetricsResponse::_internal_additional_metrics() const {
  return _impl_.additional_metrics_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
ModelMetricsResponse::additional_metrics() const {
  // @@protoc_insertion_point(field_map:multimodal.ModelMetricsResponse.additional_metrics)
  return _internal_additional_metrics();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
ModelMetricsResponse::_internal_mutable_additional_metrics() {
  return _impl_.additional_metrics_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
ModelMetricsResponse::mutable_additional_metrics() {
  // @@protoc_insertion_point(field_mutable_map:multimodal.ModelMetricsResponse.additional_metrics)
  return _internal_mutable_additional_metrics();
}

// -------------------------------------------------------------------

// Empty

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// HealthResponse

// bool healthy = 1;
inline void HealthResponse::clear_healthy() {
  _impl_.healthy_ = false;
}
inline bool HealthResponse::_internal_healthy() const {
  return _impl_.healthy_;
}
inline bool HealthResponse::healthy() const {
  // @@protoc_insertion_point(field_get:multimodal.HealthResponse.healthy)
  return _internal_healthy();
}
inline void HealthResponse::_internal_set_healthy(bool value) {
  
  _impl_.healthy_ = value;
}
inline void HealthResponse::set_healthy(bool value) {
  _internal_set_healthy(value);
  // @@protoc_insertion_point(field_set:multimodal.HealthResponse.healthy)
}

// string status = 2;
inline void HealthResponse::clear_status() {
  _impl_.status_.ClearToEmpty();
}
inline const std::string& HealthResponse::status() const {
  // @@protoc_insertion_point(field_get:multimodal.HealthResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HealthResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 _impl_.status_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:multimodal.HealthResponse.status)
}
inline std::string* HealthResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:multimodal.HealthResponse.status)
  return _s;
}
inline const std::string& HealthResponse::_internal_status() const {
  return _impl_.status_.Get();
}
inline void HealthResponse::_internal_set_status(const std::string& value) {
  
  _impl_.status_.Set(value, GetArenaForAllocation());
}
inline std::string* HealthResponse::_internal_mutable_status() {
  
  return _impl_.status_.Mutable(GetArenaForAllocation());
}
inline std::string* HealthResponse::release_status() {
  // @@protoc_insertion_point(field_release:multimodal.HealthResponse.status)
  return _impl_.status_.Release();
}
inline void HealthResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  _impl_.status_.SetAllocated(status, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:multimodal.HealthResponse.status)
}

// map<string, string> details = 3;
inline int HealthResponse::_internal_details_size() const {
  return _impl_.details_.size();
}
inline int HealthResponse::details_size() const {
  return _internal_details_size();
}
inline void HealthResponse::clear_details() {
  _impl_.details_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
HealthResponse::_internal_details() const {
  return _impl_.details_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
HealthResponse::details() const {
  // @@protoc_insertion_point(field_map:multimodal.HealthResponse.details)
  return _internal_details();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
HealthResponse::_internal_mutable_details() {
  return _impl_.details_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
HealthResponse::mutable_details() {
  // @@protoc_insertion_point(field_mutable_map:multimodal.HealthResponse.details)
  return _internal_mutable_details();
}

// int64 uptime_seconds = 4;
inline void HealthResponse::clear_uptime_seconds() {
  _impl_.uptime_seconds_ = int64_t{0};
}
inline int64_t HealthResponse::_internal_uptime_seconds() const {
  return _impl_.uptime_seconds_;
}
inline int64_t HealthResponse::uptime_seconds() const {
  // @@protoc_insertion_point(field_get:multimodal.HealthResponse.uptime_seconds)
  return _internal_uptime_seconds();
}
inline void HealthResponse::_internal_set_uptime_seconds(int64_t value) {
  
  _impl_.uptime_seconds_ = value;
}
inline void HealthResponse::set_uptime_seconds(int64_t value) {
  _internal_set_uptime_seconds(value);
  // @@protoc_insertion_point(field_set:multimodal.HealthResponse.uptime_seconds)
}

// string version = 5;
inline void HealthResponse::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& HealthResponse::version() const {
  // @@protoc_insertion_point(field_get:multimodal.HealthResponse.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HealthResponse::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:multimodal.HealthResponse.version)
}
inline std::string* HealthResponse::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:multimodal.HealthResponse.version)
  return _s;
}
inline const std::string& HealthResponse::_internal_version() const {
  return _impl_.version_.Get();
}
inline void HealthResponse::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* HealthResponse::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* HealthResponse::release_version() {
  // @@protoc_insertion_point(field_release:multimodal.HealthResponse.version)
  return _impl_.version_.Release();
}
inline void HealthResponse::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:multimodal.HealthResponse.version)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace multimodal

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_vision_5fservice_2eproto
