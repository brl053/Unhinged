// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: audio.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_audio_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_audio_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_audio_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_audio_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_audio_2eproto;
namespace unhinged {
namespace audio {
namespace v1 {
class AnalyzeAudioRequest;
struct AnalyzeAudioRequestDefaultTypeInternal;
extern AnalyzeAudioRequestDefaultTypeInternal _AnalyzeAudioRequest_default_instance_;
class AnalyzeAudioResponse;
struct AnalyzeAudioResponseDefaultTypeInternal;
extern AnalyzeAudioResponseDefaultTypeInternal _AnalyzeAudioResponse_default_instance_;
class AudioAnalysis;
struct AudioAnalysisDefaultTypeInternal;
extern AudioAnalysisDefaultTypeInternal _AudioAnalysis_default_instance_;
class AudioEffect;
struct AudioEffectDefaultTypeInternal;
extern AudioEffectDefaultTypeInternal _AudioEffect_default_instance_;
class AudioEffect_ParametersEntry_DoNotUse;
struct AudioEffect_ParametersEntry_DoNotUseDefaultTypeInternal;
extern AudioEffect_ParametersEntry_DoNotUseDefaultTypeInternal _AudioEffect_ParametersEntry_DoNotUse_default_instance_;
class AudioMetadata;
struct AudioMetadataDefaultTypeInternal;
extern AudioMetadataDefaultTypeInternal _AudioMetadata_default_instance_;
class AudioOptions;
struct AudioOptionsDefaultTypeInternal;
extern AudioOptionsDefaultTypeInternal _AudioOptions_default_instance_;
class AudioQualityMetrics;
struct AudioQualityMetricsDefaultTypeInternal;
extern AudioQualityMetricsDefaultTypeInternal _AudioQualityMetrics_default_instance_;
class ConvertAudioRequest;
struct ConvertAudioRequestDefaultTypeInternal;
extern ConvertAudioRequestDefaultTypeInternal _ConvertAudioRequest_default_instance_;
class ConvertAudioResponse;
struct ConvertAudioResponseDefaultTypeInternal;
extern ConvertAudioResponseDefaultTypeInternal _ConvertAudioResponse_default_instance_;
class CreateCustomVoiceRequest;
struct CreateCustomVoiceRequestDefaultTypeInternal;
extern CreateCustomVoiceRequestDefaultTypeInternal _CreateCustomVoiceRequest_default_instance_;
class CreateCustomVoiceResponse;
struct CreateCustomVoiceResponseDefaultTypeInternal;
extern CreateCustomVoiceResponseDefaultTypeInternal _CreateCustomVoiceResponse_default_instance_;
class EmotionSegment;
struct EmotionSegmentDefaultTypeInternal;
extern EmotionSegmentDefaultTypeInternal _EmotionSegment_default_instance_;
class GetVoiceRequest;
struct GetVoiceRequestDefaultTypeInternal;
extern GetVoiceRequestDefaultTypeInternal _GetVoiceRequest_default_instance_;
class GetVoiceResponse;
struct GetVoiceResponseDefaultTypeInternal;
extern GetVoiceResponseDefaultTypeInternal _GetVoiceResponse_default_instance_;
class LanguageDetection;
struct LanguageDetectionDefaultTypeInternal;
extern LanguageDetectionDefaultTypeInternal _LanguageDetection_default_instance_;
class ListVoicesRequest;
struct ListVoicesRequestDefaultTypeInternal;
extern ListVoicesRequestDefaultTypeInternal _ListVoicesRequest_default_instance_;
class ListVoicesResponse;
struct ListVoicesResponseDefaultTypeInternal;
extern ListVoicesResponseDefaultTypeInternal _ListVoicesResponse_default_instance_;
class ProcessAudioRequest;
struct ProcessAudioRequestDefaultTypeInternal;
extern ProcessAudioRequestDefaultTypeInternal _ProcessAudioRequest_default_instance_;
class ProcessAudioResponse;
struct ProcessAudioResponseDefaultTypeInternal;
extern ProcessAudioResponseDefaultTypeInternal _ProcessAudioResponse_default_instance_;
class STTChunkPayload;
struct STTChunkPayloadDefaultTypeInternal;
extern STTChunkPayloadDefaultTypeInternal _STTChunkPayload_default_instance_;
class STTMetadata;
struct STTMetadataDefaultTypeInternal;
extern STTMetadataDefaultTypeInternal _STTMetadata_default_instance_;
class STTResponse;
struct STTResponseDefaultTypeInternal;
extern STTResponseDefaultTypeInternal _STTResponse_default_instance_;
class SpeakerSegment;
struct SpeakerSegmentDefaultTypeInternal;
extern SpeakerSegmentDefaultTypeInternal _SpeakerSegment_default_instance_;
class SpeechSegment;
struct SpeechSegmentDefaultTypeInternal;
extern SpeechSegmentDefaultTypeInternal _SpeechSegment_default_instance_;
class TTSChunkPayload;
struct TTSChunkPayloadDefaultTypeInternal;
extern TTSChunkPayloadDefaultTypeInternal _TTSChunkPayload_default_instance_;
class TTSRequest;
struct TTSRequestDefaultTypeInternal;
extern TTSRequestDefaultTypeInternal _TTSRequest_default_instance_;
class TranscriptSegment;
struct TranscriptSegmentDefaultTypeInternal;
extern TranscriptSegmentDefaultTypeInternal _TranscriptSegment_default_instance_;
class Voice;
struct VoiceDefaultTypeInternal;
extern VoiceDefaultTypeInternal _Voice_default_instance_;
class WordTiming;
struct WordTimingDefaultTypeInternal;
extern WordTimingDefaultTypeInternal _WordTiming_default_instance_;
}  // namespace v1
}  // namespace audio
}  // namespace unhinged
PROTOBUF_NAMESPACE_OPEN
template<> ::unhinged::audio::v1::AnalyzeAudioRequest* Arena::CreateMaybeMessage<::unhinged::audio::v1::AnalyzeAudioRequest>(Arena*);
template<> ::unhinged::audio::v1::AnalyzeAudioResponse* Arena::CreateMaybeMessage<::unhinged::audio::v1::AnalyzeAudioResponse>(Arena*);
template<> ::unhinged::audio::v1::AudioAnalysis* Arena::CreateMaybeMessage<::unhinged::audio::v1::AudioAnalysis>(Arena*);
template<> ::unhinged::audio::v1::AudioEffect* Arena::CreateMaybeMessage<::unhinged::audio::v1::AudioEffect>(Arena*);
template<> ::unhinged::audio::v1::AudioEffect_ParametersEntry_DoNotUse* Arena::CreateMaybeMessage<::unhinged::audio::v1::AudioEffect_ParametersEntry_DoNotUse>(Arena*);
template<> ::unhinged::audio::v1::AudioMetadata* Arena::CreateMaybeMessage<::unhinged::audio::v1::AudioMetadata>(Arena*);
template<> ::unhinged::audio::v1::AudioOptions* Arena::CreateMaybeMessage<::unhinged::audio::v1::AudioOptions>(Arena*);
template<> ::unhinged::audio::v1::AudioQualityMetrics* Arena::CreateMaybeMessage<::unhinged::audio::v1::AudioQualityMetrics>(Arena*);
template<> ::unhinged::audio::v1::ConvertAudioRequest* Arena::CreateMaybeMessage<::unhinged::audio::v1::ConvertAudioRequest>(Arena*);
template<> ::unhinged::audio::v1::ConvertAudioResponse* Arena::CreateMaybeMessage<::unhinged::audio::v1::ConvertAudioResponse>(Arena*);
template<> ::unhinged::audio::v1::CreateCustomVoiceRequest* Arena::CreateMaybeMessage<::unhinged::audio::v1::CreateCustomVoiceRequest>(Arena*);
template<> ::unhinged::audio::v1::CreateCustomVoiceResponse* Arena::CreateMaybeMessage<::unhinged::audio::v1::CreateCustomVoiceResponse>(Arena*);
template<> ::unhinged::audio::v1::EmotionSegment* Arena::CreateMaybeMessage<::unhinged::audio::v1::EmotionSegment>(Arena*);
template<> ::unhinged::audio::v1::GetVoiceRequest* Arena::CreateMaybeMessage<::unhinged::audio::v1::GetVoiceRequest>(Arena*);
template<> ::unhinged::audio::v1::GetVoiceResponse* Arena::CreateMaybeMessage<::unhinged::audio::v1::GetVoiceResponse>(Arena*);
template<> ::unhinged::audio::v1::LanguageDetection* Arena::CreateMaybeMessage<::unhinged::audio::v1::LanguageDetection>(Arena*);
template<> ::unhinged::audio::v1::ListVoicesRequest* Arena::CreateMaybeMessage<::unhinged::audio::v1::ListVoicesRequest>(Arena*);
template<> ::unhinged::audio::v1::ListVoicesResponse* Arena::CreateMaybeMessage<::unhinged::audio::v1::ListVoicesResponse>(Arena*);
template<> ::unhinged::audio::v1::ProcessAudioRequest* Arena::CreateMaybeMessage<::unhinged::audio::v1::ProcessAudioRequest>(Arena*);
template<> ::unhinged::audio::v1::ProcessAudioResponse* Arena::CreateMaybeMessage<::unhinged::audio::v1::ProcessAudioResponse>(Arena*);
template<> ::unhinged::audio::v1::STTChunkPayload* Arena::CreateMaybeMessage<::unhinged::audio::v1::STTChunkPayload>(Arena*);
template<> ::unhinged::audio::v1::STTMetadata* Arena::CreateMaybeMessage<::unhinged::audio::v1::STTMetadata>(Arena*);
template<> ::unhinged::audio::v1::STTResponse* Arena::CreateMaybeMessage<::unhinged::audio::v1::STTResponse>(Arena*);
template<> ::unhinged::audio::v1::SpeakerSegment* Arena::CreateMaybeMessage<::unhinged::audio::v1::SpeakerSegment>(Arena*);
template<> ::unhinged::audio::v1::SpeechSegment* Arena::CreateMaybeMessage<::unhinged::audio::v1::SpeechSegment>(Arena*);
template<> ::unhinged::audio::v1::TTSChunkPayload* Arena::CreateMaybeMessage<::unhinged::audio::v1::TTSChunkPayload>(Arena*);
template<> ::unhinged::audio::v1::TTSRequest* Arena::CreateMaybeMessage<::unhinged::audio::v1::TTSRequest>(Arena*);
template<> ::unhinged::audio::v1::TranscriptSegment* Arena::CreateMaybeMessage<::unhinged::audio::v1::TranscriptSegment>(Arena*);
template<> ::unhinged::audio::v1::Voice* Arena::CreateMaybeMessage<::unhinged::audio::v1::Voice>(Arena*);
template<> ::unhinged::audio::v1::WordTiming* Arena::CreateMaybeMessage<::unhinged::audio::v1::WordTiming>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace unhinged {
namespace audio {
namespace v1 {

enum AudioQuality : int {
  AUDIO_QUALITY_UNSPECIFIED = 0,
  AUDIO_QUALITY_LOW = 1,
  AUDIO_QUALITY_STANDARD = 2,
  AUDIO_QUALITY_HIGH = 3,
  AUDIO_QUALITY_PREMIUM = 4,
  AudioQuality_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AudioQuality_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AudioQuality_IsValid(int value);
constexpr AudioQuality AudioQuality_MIN = AUDIO_QUALITY_UNSPECIFIED;
constexpr AudioQuality AudioQuality_MAX = AUDIO_QUALITY_PREMIUM;
constexpr int AudioQuality_ARRAYSIZE = AudioQuality_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AudioQuality_descriptor();
template<typename T>
inline const std::string& AudioQuality_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AudioQuality>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AudioQuality_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AudioQuality_descriptor(), enum_t_value);
}
inline bool AudioQuality_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AudioQuality* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AudioQuality>(
    AudioQuality_descriptor(), name, value);
}
enum AudioFormat : int {
  AUDIO_FORMAT_UNSPECIFIED = 0,
  AUDIO_FORMAT_WAV = 1,
  AUDIO_FORMAT_MP3 = 2,
  AUDIO_FORMAT_OGG = 3,
  AUDIO_FORMAT_FLAC = 4,
  AUDIO_FORMAT_PCM = 5,
  AUDIO_FORMAT_OPUS = 6,
  AUDIO_FORMAT_AAC = 7,
  AudioFormat_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AudioFormat_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AudioFormat_IsValid(int value);
constexpr AudioFormat AudioFormat_MIN = AUDIO_FORMAT_UNSPECIFIED;
constexpr AudioFormat AudioFormat_MAX = AUDIO_FORMAT_AAC;
constexpr int AudioFormat_ARRAYSIZE = AudioFormat_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AudioFormat_descriptor();
template<typename T>
inline const std::string& AudioFormat_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AudioFormat>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AudioFormat_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AudioFormat_descriptor(), enum_t_value);
}
inline bool AudioFormat_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AudioFormat* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AudioFormat>(
    AudioFormat_descriptor(), name, value);
}
enum AudioEffectType : int {
  AUDIO_EFFECT_TYPE_UNSPECIFIED = 0,
  AUDIO_EFFECT_TYPE_REVERB = 1,
  AUDIO_EFFECT_TYPE_ECHO = 2,
  AUDIO_EFFECT_TYPE_CHORUS = 3,
  AUDIO_EFFECT_TYPE_DISTORTION = 4,
  AUDIO_EFFECT_TYPE_NORMALIZE = 5,
  AUDIO_EFFECT_TYPE_COMPRESSOR = 6,
  AudioEffectType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AudioEffectType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AudioEffectType_IsValid(int value);
constexpr AudioEffectType AudioEffectType_MIN = AUDIO_EFFECT_TYPE_UNSPECIFIED;
constexpr AudioEffectType AudioEffectType_MAX = AUDIO_EFFECT_TYPE_COMPRESSOR;
constexpr int AudioEffectType_ARRAYSIZE = AudioEffectType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AudioEffectType_descriptor();
template<typename T>
inline const std::string& AudioEffectType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AudioEffectType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AudioEffectType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AudioEffectType_descriptor(), enum_t_value);
}
inline bool AudioEffectType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AudioEffectType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AudioEffectType>(
    AudioEffectType_descriptor(), name, value);
}
enum VoiceGender : int {
  VOICE_GENDER_UNSPECIFIED = 0,
  VOICE_GENDER_MALE = 1,
  VOICE_GENDER_FEMALE = 2,
  VOICE_GENDER_NEUTRAL = 3,
  VOICE_GENDER_CHILD = 4,
  VoiceGender_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  VoiceGender_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool VoiceGender_IsValid(int value);
constexpr VoiceGender VoiceGender_MIN = VOICE_GENDER_UNSPECIFIED;
constexpr VoiceGender VoiceGender_MAX = VOICE_GENDER_CHILD;
constexpr int VoiceGender_ARRAYSIZE = VoiceGender_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VoiceGender_descriptor();
template<typename T>
inline const std::string& VoiceGender_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VoiceGender>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VoiceGender_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    VoiceGender_descriptor(), enum_t_value);
}
inline bool VoiceGender_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, VoiceGender* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VoiceGender>(
    VoiceGender_descriptor(), name, value);
}
enum VoiceAge : int {
  VOICE_AGE_UNSPECIFIED = 0,
  VOICE_AGE_CHILD = 1,
  VOICE_AGE_YOUNG_ADULT = 2,
  VOICE_AGE_ADULT = 3,
  VOICE_AGE_SENIOR = 4,
  VoiceAge_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  VoiceAge_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool VoiceAge_IsValid(int value);
constexpr VoiceAge VoiceAge_MIN = VOICE_AGE_UNSPECIFIED;
constexpr VoiceAge VoiceAge_MAX = VOICE_AGE_SENIOR;
constexpr int VoiceAge_ARRAYSIZE = VoiceAge_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VoiceAge_descriptor();
template<typename T>
inline const std::string& VoiceAge_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VoiceAge>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VoiceAge_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    VoiceAge_descriptor(), enum_t_value);
}
inline bool VoiceAge_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, VoiceAge* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VoiceAge>(
    VoiceAge_descriptor(), name, value);
}
enum VoiceStyle : int {
  VOICE_STYLE_UNSPECIFIED = 0,
  VOICE_STYLE_CONVERSATIONAL = 1,
  VOICE_STYLE_PROFESSIONAL = 2,
  VOICE_STYLE_FRIENDLY = 3,
  VOICE_STYLE_AUTHORITATIVE = 4,
  VOICE_STYLE_CALM = 5,
  VOICE_STYLE_ENERGETIC = 6,
  VOICE_STYLE_DRAMATIC = 7,
  VoiceStyle_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  VoiceStyle_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool VoiceStyle_IsValid(int value);
constexpr VoiceStyle VoiceStyle_MIN = VOICE_STYLE_UNSPECIFIED;
constexpr VoiceStyle VoiceStyle_MAX = VOICE_STYLE_DRAMATIC;
constexpr int VoiceStyle_ARRAYSIZE = VoiceStyle_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VoiceStyle_descriptor();
template<typename T>
inline const std::string& VoiceStyle_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VoiceStyle>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VoiceStyle_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    VoiceStyle_descriptor(), enum_t_value);
}
inline bool VoiceStyle_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, VoiceStyle* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VoiceStyle>(
    VoiceStyle_descriptor(), name, value);
}
enum ProcessingType : int {
  PROCESSING_TYPE_UNSPECIFIED = 0,
  PROCESSING_TYPE_TRANSCRIBE = 1,
  PROCESSING_TYPE_TRANSLATE = 2,
  PROCESSING_TYPE_ENHANCE = 3,
  PROCESSING_TYPE_CONVERT = 4,
  ProcessingType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ProcessingType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ProcessingType_IsValid(int value);
constexpr ProcessingType ProcessingType_MIN = PROCESSING_TYPE_UNSPECIFIED;
constexpr ProcessingType ProcessingType_MAX = PROCESSING_TYPE_CONVERT;
constexpr int ProcessingType_ARRAYSIZE = ProcessingType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ProcessingType_descriptor();
template<typename T>
inline const std::string& ProcessingType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ProcessingType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ProcessingType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ProcessingType_descriptor(), enum_t_value);
}
inline bool ProcessingType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ProcessingType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ProcessingType>(
    ProcessingType_descriptor(), name, value);
}
enum AnalysisType : int {
  ANALYSIS_TYPE_UNSPECIFIED = 0,
  ANALYSIS_TYPE_SPEECH_DETECTION = 1,
  ANALYSIS_TYPE_LANGUAGE_DETECTION = 2,
  ANALYSIS_TYPE_SPEAKER_IDENTIFICATION = 3,
  ANALYSIS_TYPE_EMOTION_DETECTION = 4,
  ANALYSIS_TYPE_QUALITY_ASSESSMENT = 5,
  AnalysisType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AnalysisType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AnalysisType_IsValid(int value);
constexpr AnalysisType AnalysisType_MIN = ANALYSIS_TYPE_UNSPECIFIED;
constexpr AnalysisType AnalysisType_MAX = ANALYSIS_TYPE_QUALITY_ASSESSMENT;
constexpr int AnalysisType_ARRAYSIZE = AnalysisType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AnalysisType_descriptor();
template<typename T>
inline const std::string& AnalysisType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AnalysisType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AnalysisType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AnalysisType_descriptor(), enum_t_value);
}
inline bool AnalysisType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AnalysisType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AnalysisType>(
    AnalysisType_descriptor(), name, value);
}
// ===================================================================

class TTSRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.audio.v1.TTSRequest) */ {
 public:
  inline TTSRequest() : TTSRequest(nullptr) {}
  ~TTSRequest() override;
  explicit PROTOBUF_CONSTEXPR TTSRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TTSRequest(const TTSRequest& from);
  TTSRequest(TTSRequest&& from) noexcept
    : TTSRequest() {
    *this = ::std::move(from);
  }

  inline TTSRequest& operator=(const TTSRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TTSRequest& operator=(TTSRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TTSRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TTSRequest* internal_default_instance() {
    return reinterpret_cast<const TTSRequest*>(
               &_TTSRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(TTSRequest& a, TTSRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TTSRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TTSRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TTSRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TTSRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TTSRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TTSRequest& from) {
    TTSRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TTSRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.audio.v1.TTSRequest";
  }
  protected:
  explicit TTSRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEffectsFieldNumber = 8,
    kTextFieldNumber = 1,
    kVoiceIdFieldNumber = 2,
    kOptionsFieldNumber = 3,
    kOutputFormatFieldNumber = 4,
    kSampleRateFieldNumber = 5,
    kChannelsFieldNumber = 6,
    kEnableSsmlFieldNumber = 7,
  };
  // repeated .unhinged.audio.v1.AudioEffect effects = 8;
  int effects_size() const;
  private:
  int _internal_effects_size() const;
  public:
  void clear_effects();
  ::unhinged::audio::v1::AudioEffect* mutable_effects(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::audio::v1::AudioEffect >*
      mutable_effects();
  private:
  const ::unhinged::audio::v1::AudioEffect& _internal_effects(int index) const;
  ::unhinged::audio::v1::AudioEffect* _internal_add_effects();
  public:
  const ::unhinged::audio::v1::AudioEffect& effects(int index) const;
  ::unhinged::audio::v1::AudioEffect* add_effects();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::audio::v1::AudioEffect >&
      effects() const;

  // string text = 1;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // string voice_id = 2;
  void clear_voice_id();
  const std::string& voice_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_voice_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_voice_id();
  PROTOBUF_NODISCARD std::string* release_voice_id();
  void set_allocated_voice_id(std::string* voice_id);
  private:
  const std::string& _internal_voice_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_voice_id(const std::string& value);
  std::string* _internal_mutable_voice_id();
  public:

  // .unhinged.audio.v1.AudioOptions options = 3;
  bool has_options() const;
  private:
  bool _internal_has_options() const;
  public:
  void clear_options();
  const ::unhinged::audio::v1::AudioOptions& options() const;
  PROTOBUF_NODISCARD ::unhinged::audio::v1::AudioOptions* release_options();
  ::unhinged::audio::v1::AudioOptions* mutable_options();
  void set_allocated_options(::unhinged::audio::v1::AudioOptions* options);
  private:
  const ::unhinged::audio::v1::AudioOptions& _internal_options() const;
  ::unhinged::audio::v1::AudioOptions* _internal_mutable_options();
  public:
  void unsafe_arena_set_allocated_options(
      ::unhinged::audio::v1::AudioOptions* options);
  ::unhinged::audio::v1::AudioOptions* unsafe_arena_release_options();

  // .unhinged.audio.v1.AudioFormat output_format = 4;
  void clear_output_format();
  ::unhinged::audio::v1::AudioFormat output_format() const;
  void set_output_format(::unhinged::audio::v1::AudioFormat value);
  private:
  ::unhinged::audio::v1::AudioFormat _internal_output_format() const;
  void _internal_set_output_format(::unhinged::audio::v1::AudioFormat value);
  public:

  // int32 sample_rate = 5;
  void clear_sample_rate();
  int32_t sample_rate() const;
  void set_sample_rate(int32_t value);
  private:
  int32_t _internal_sample_rate() const;
  void _internal_set_sample_rate(int32_t value);
  public:

  // int32 channels = 6;
  void clear_channels();
  int32_t channels() const;
  void set_channels(int32_t value);
  private:
  int32_t _internal_channels() const;
  void _internal_set_channels(int32_t value);
  public:

  // bool enable_ssml = 7;
  void clear_enable_ssml();
  bool enable_ssml() const;
  void set_enable_ssml(bool value);
  private:
  bool _internal_enable_ssml() const;
  void _internal_set_enable_ssml(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.audio.v1.TTSRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::audio::v1::AudioEffect > effects_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr voice_id_;
    ::unhinged::audio::v1::AudioOptions* options_;
    int output_format_;
    int32_t sample_rate_;
    int32_t channels_;
    bool enable_ssml_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_2eproto;
};
// -------------------------------------------------------------------

class STTResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.audio.v1.STTResponse) */ {
 public:
  inline STTResponse() : STTResponse(nullptr) {}
  ~STTResponse() override;
  explicit PROTOBUF_CONSTEXPR STTResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  STTResponse(const STTResponse& from);
  STTResponse(STTResponse&& from) noexcept
    : STTResponse() {
    *this = ::std::move(from);
  }

  inline STTResponse& operator=(const STTResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline STTResponse& operator=(STTResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const STTResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const STTResponse* internal_default_instance() {
    return reinterpret_cast<const STTResponse*>(
               &_STTResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(STTResponse& a, STTResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(STTResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(STTResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  STTResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<STTResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const STTResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const STTResponse& from) {
    STTResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(STTResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.audio.v1.STTResponse";
  }
  protected:
  explicit STTResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSegmentsFieldNumber = 4,
    kTranscriptFieldNumber = 2,
    kResponseFieldNumber = 1,
    kUsageFieldNumber = 5,
    kMetadataFieldNumber = 6,
    kConfidenceFieldNumber = 3,
  };
  // repeated .unhinged.audio.v1.TranscriptSegment segments = 4;
  int segments_size() const;
  private:
  int _internal_segments_size() const;
  public:
  void clear_segments();
  ::unhinged::audio::v1::TranscriptSegment* mutable_segments(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::audio::v1::TranscriptSegment >*
      mutable_segments();
  private:
  const ::unhinged::audio::v1::TranscriptSegment& _internal_segments(int index) const;
  ::unhinged::audio::v1::TranscriptSegment* _internal_add_segments();
  public:
  const ::unhinged::audio::v1::TranscriptSegment& segments(int index) const;
  ::unhinged::audio::v1::TranscriptSegment* add_segments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::audio::v1::TranscriptSegment >&
      segments() const;

  // string transcript = 2;
  void clear_transcript();
  const std::string& transcript() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_transcript(ArgT0&& arg0, ArgT... args);
  std::string* mutable_transcript();
  PROTOBUF_NODISCARD std::string* release_transcript();
  void set_allocated_transcript(std::string* transcript);
  private:
  const std::string& _internal_transcript() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transcript(const std::string& value);
  std::string* _internal_mutable_transcript();
  public:

  // .unhinged.common.v1.StandardResponse response = 1;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::unhinged::common::v1::StandardResponse& response() const;
  PROTOBUF_NODISCARD ::unhinged::common::v1::StandardResponse* release_response();
  ::unhinged::common::v1::StandardResponse* mutable_response();
  void set_allocated_response(::unhinged::common::v1::StandardResponse* response);
  private:
  const ::unhinged::common::v1::StandardResponse& _internal_response() const;
  ::unhinged::common::v1::StandardResponse* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::unhinged::common::v1::StandardResponse* response);
  ::unhinged::common::v1::StandardResponse* unsafe_arena_release_response();

  // .unhinged.common.v1.AudioUsage usage = 5;
  bool has_usage() const;
  private:
  bool _internal_has_usage() const;
  public:
  void clear_usage();
  const ::unhinged::common::v1::AudioUsage& usage() const;
  PROTOBUF_NODISCARD ::unhinged::common::v1::AudioUsage* release_usage();
  ::unhinged::common::v1::AudioUsage* mutable_usage();
  void set_allocated_usage(::unhinged::common::v1::AudioUsage* usage);
  private:
  const ::unhinged::common::v1::AudioUsage& _internal_usage() const;
  ::unhinged::common::v1::AudioUsage* _internal_mutable_usage();
  public:
  void unsafe_arena_set_allocated_usage(
      ::unhinged::common::v1::AudioUsage* usage);
  ::unhinged::common::v1::AudioUsage* unsafe_arena_release_usage();

  // .unhinged.audio.v1.STTMetadata metadata = 6;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::unhinged::audio::v1::STTMetadata& metadata() const;
  PROTOBUF_NODISCARD ::unhinged::audio::v1::STTMetadata* release_metadata();
  ::unhinged::audio::v1::STTMetadata* mutable_metadata();
  void set_allocated_metadata(::unhinged::audio::v1::STTMetadata* metadata);
  private:
  const ::unhinged::audio::v1::STTMetadata& _internal_metadata() const;
  ::unhinged::audio::v1::STTMetadata* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::unhinged::audio::v1::STTMetadata* metadata);
  ::unhinged::audio::v1::STTMetadata* unsafe_arena_release_metadata();

  // float confidence = 3;
  void clear_confidence();
  float confidence() const;
  void set_confidence(float value);
  private:
  float _internal_confidence() const;
  void _internal_set_confidence(float value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.audio.v1.STTResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::audio::v1::TranscriptSegment > segments_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transcript_;
    ::unhinged::common::v1::StandardResponse* response_;
    ::unhinged::common::v1::AudioUsage* usage_;
    ::unhinged::audio::v1::STTMetadata* metadata_;
    float confidence_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_2eproto;
};
// -------------------------------------------------------------------

class AudioOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.audio.v1.AudioOptions) */ {
 public:
  inline AudioOptions() : AudioOptions(nullptr) {}
  ~AudioOptions() override;
  explicit PROTOBUF_CONSTEXPR AudioOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AudioOptions(const AudioOptions& from);
  AudioOptions(AudioOptions&& from) noexcept
    : AudioOptions() {
    *this = ::std::move(from);
  }

  inline AudioOptions& operator=(const AudioOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioOptions& operator=(AudioOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AudioOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const AudioOptions* internal_default_instance() {
    return reinterpret_cast<const AudioOptions*>(
               &_AudioOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(AudioOptions& a, AudioOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AudioOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AudioOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AudioOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AudioOptions& from) {
    AudioOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AudioOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.audio.v1.AudioOptions";
  }
  protected:
  explicit AudioOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpeedFieldNumber = 1,
    kPitchFieldNumber = 2,
    kVolumeFieldNumber = 3,
    kQualityFieldNumber = 4,
    kEnableNoiseReductionFieldNumber = 5,
    kEnableEchoCancellationFieldNumber = 6,
  };
  // float speed = 1;
  void clear_speed();
  float speed() const;
  void set_speed(float value);
  private:
  float _internal_speed() const;
  void _internal_set_speed(float value);
  public:

  // float pitch = 2;
  void clear_pitch();
  float pitch() const;
  void set_pitch(float value);
  private:
  float _internal_pitch() const;
  void _internal_set_pitch(float value);
  public:

  // float volume = 3;
  void clear_volume();
  float volume() const;
  void set_volume(float value);
  private:
  float _internal_volume() const;
  void _internal_set_volume(float value);
  public:

  // .unhinged.audio.v1.AudioQuality quality = 4;
  void clear_quality();
  ::unhinged::audio::v1::AudioQuality quality() const;
  void set_quality(::unhinged::audio::v1::AudioQuality value);
  private:
  ::unhinged::audio::v1::AudioQuality _internal_quality() const;
  void _internal_set_quality(::unhinged::audio::v1::AudioQuality value);
  public:

  // bool enable_noise_reduction = 5;
  void clear_enable_noise_reduction();
  bool enable_noise_reduction() const;
  void set_enable_noise_reduction(bool value);
  private:
  bool _internal_enable_noise_reduction() const;
  void _internal_set_enable_noise_reduction(bool value);
  public:

  // bool enable_echo_cancellation = 6;
  void clear_enable_echo_cancellation();
  bool enable_echo_cancellation() const;
  void set_enable_echo_cancellation(bool value);
  private:
  bool _internal_enable_echo_cancellation() const;
  void _internal_set_enable_echo_cancellation(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.audio.v1.AudioOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float speed_;
    float pitch_;
    float volume_;
    int quality_;
    bool enable_noise_reduction_;
    bool enable_echo_cancellation_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_2eproto;
};
// -------------------------------------------------------------------

class AudioEffect_ParametersEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AudioEffect_ParametersEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AudioEffect_ParametersEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  AudioEffect_ParametersEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR AudioEffect_ParametersEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit AudioEffect_ParametersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const AudioEffect_ParametersEntry_DoNotUse& other);
  static const AudioEffect_ParametersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const AudioEffect_ParametersEntry_DoNotUse*>(&_AudioEffect_ParametersEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "unhinged.audio.v1.AudioEffect.ParametersEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "unhinged.audio.v1.AudioEffect.ParametersEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_audio_2eproto;
};

// -------------------------------------------------------------------

class AudioEffect final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.audio.v1.AudioEffect) */ {
 public:
  inline AudioEffect() : AudioEffect(nullptr) {}
  ~AudioEffect() override;
  explicit PROTOBUF_CONSTEXPR AudioEffect(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AudioEffect(const AudioEffect& from);
  AudioEffect(AudioEffect&& from) noexcept
    : AudioEffect() {
    *this = ::std::move(from);
  }

  inline AudioEffect& operator=(const AudioEffect& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioEffect& operator=(AudioEffect&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AudioEffect& default_instance() {
    return *internal_default_instance();
  }
  static inline const AudioEffect* internal_default_instance() {
    return reinterpret_cast<const AudioEffect*>(
               &_AudioEffect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(AudioEffect& a, AudioEffect& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioEffect* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioEffect* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AudioEffect* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AudioEffect>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AudioEffect& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AudioEffect& from) {
    AudioEffect::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AudioEffect* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.audio.v1.AudioEffect";
  }
  protected:
  explicit AudioEffect(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kParametersFieldNumber = 3,
    kTypeFieldNumber = 1,
    kIntensityFieldNumber = 2,
  };
  // map<string, string> parameters = 3;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_parameters();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_parameters();

  // .unhinged.audio.v1.AudioEffectType type = 1;
  void clear_type();
  ::unhinged::audio::v1::AudioEffectType type() const;
  void set_type(::unhinged::audio::v1::AudioEffectType value);
  private:
  ::unhinged::audio::v1::AudioEffectType _internal_type() const;
  void _internal_set_type(::unhinged::audio::v1::AudioEffectType value);
  public:

  // float intensity = 2;
  void clear_intensity();
  float intensity() const;
  void set_intensity(float value);
  private:
  float _internal_intensity() const;
  void _internal_set_intensity(float value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.audio.v1.AudioEffect)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        AudioEffect_ParametersEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> parameters_;
    int type_;
    float intensity_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_2eproto;
};
// -------------------------------------------------------------------

class TranscriptSegment final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.audio.v1.TranscriptSegment) */ {
 public:
  inline TranscriptSegment() : TranscriptSegment(nullptr) {}
  ~TranscriptSegment() override;
  explicit PROTOBUF_CONSTEXPR TranscriptSegment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TranscriptSegment(const TranscriptSegment& from);
  TranscriptSegment(TranscriptSegment&& from) noexcept
    : TranscriptSegment() {
    *this = ::std::move(from);
  }

  inline TranscriptSegment& operator=(const TranscriptSegment& from) {
    CopyFrom(from);
    return *this;
  }
  inline TranscriptSegment& operator=(TranscriptSegment&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TranscriptSegment& default_instance() {
    return *internal_default_instance();
  }
  static inline const TranscriptSegment* internal_default_instance() {
    return reinterpret_cast<const TranscriptSegment*>(
               &_TranscriptSegment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(TranscriptSegment& a, TranscriptSegment& b) {
    a.Swap(&b);
  }
  inline void Swap(TranscriptSegment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TranscriptSegment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TranscriptSegment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TranscriptSegment>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TranscriptSegment& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TranscriptSegment& from) {
    TranscriptSegment::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TranscriptSegment* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.audio.v1.TranscriptSegment";
  }
  protected:
  explicit TranscriptSegment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWordsFieldNumber = 5,
    kTextFieldNumber = 1,
    kSpeakerIdFieldNumber = 6,
    kStartTimeFieldNumber = 2,
    kEndTimeFieldNumber = 3,
    kConfidenceFieldNumber = 4,
  };
  // repeated .unhinged.audio.v1.WordTiming words = 5;
  int words_size() const;
  private:
  int _internal_words_size() const;
  public:
  void clear_words();
  ::unhinged::audio::v1::WordTiming* mutable_words(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::audio::v1::WordTiming >*
      mutable_words();
  private:
  const ::unhinged::audio::v1::WordTiming& _internal_words(int index) const;
  ::unhinged::audio::v1::WordTiming* _internal_add_words();
  public:
  const ::unhinged::audio::v1::WordTiming& words(int index) const;
  ::unhinged::audio::v1::WordTiming* add_words();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::audio::v1::WordTiming >&
      words() const;

  // string text = 1;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // string speaker_id = 6;
  void clear_speaker_id();
  const std::string& speaker_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_speaker_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_speaker_id();
  PROTOBUF_NODISCARD std::string* release_speaker_id();
  void set_allocated_speaker_id(std::string* speaker_id);
  private:
  const std::string& _internal_speaker_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_speaker_id(const std::string& value);
  std::string* _internal_mutable_speaker_id();
  public:

  // float start_time = 2;
  void clear_start_time();
  float start_time() const;
  void set_start_time(float value);
  private:
  float _internal_start_time() const;
  void _internal_set_start_time(float value);
  public:

  // float end_time = 3;
  void clear_end_time();
  float end_time() const;
  void set_end_time(float value);
  private:
  float _internal_end_time() const;
  void _internal_set_end_time(float value);
  public:

  // float confidence = 4;
  void clear_confidence();
  float confidence() const;
  void set_confidence(float value);
  private:
  float _internal_confidence() const;
  void _internal_set_confidence(float value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.audio.v1.TranscriptSegment)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::audio::v1::WordTiming > words_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr speaker_id_;
    float start_time_;
    float end_time_;
    float confidence_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_2eproto;
};
// -------------------------------------------------------------------

class WordTiming final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.audio.v1.WordTiming) */ {
 public:
  inline WordTiming() : WordTiming(nullptr) {}
  ~WordTiming() override;
  explicit PROTOBUF_CONSTEXPR WordTiming(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WordTiming(const WordTiming& from);
  WordTiming(WordTiming&& from) noexcept
    : WordTiming() {
    *this = ::std::move(from);
  }

  inline WordTiming& operator=(const WordTiming& from) {
    CopyFrom(from);
    return *this;
  }
  inline WordTiming& operator=(WordTiming&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WordTiming& default_instance() {
    return *internal_default_instance();
  }
  static inline const WordTiming* internal_default_instance() {
    return reinterpret_cast<const WordTiming*>(
               &_WordTiming_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(WordTiming& a, WordTiming& b) {
    a.Swap(&b);
  }
  inline void Swap(WordTiming* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WordTiming* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WordTiming* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WordTiming>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WordTiming& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WordTiming& from) {
    WordTiming::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WordTiming* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.audio.v1.WordTiming";
  }
  protected:
  explicit WordTiming(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWordFieldNumber = 1,
    kStartTimeFieldNumber = 2,
    kEndTimeFieldNumber = 3,
    kConfidenceFieldNumber = 4,
  };
  // string word = 1;
  void clear_word();
  const std::string& word() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_word(ArgT0&& arg0, ArgT... args);
  std::string* mutable_word();
  PROTOBUF_NODISCARD std::string* release_word();
  void set_allocated_word(std::string* word);
  private:
  const std::string& _internal_word() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_word(const std::string& value);
  std::string* _internal_mutable_word();
  public:

  // float start_time = 2;
  void clear_start_time();
  float start_time() const;
  void set_start_time(float value);
  private:
  float _internal_start_time() const;
  void _internal_set_start_time(float value);
  public:

  // float end_time = 3;
  void clear_end_time();
  float end_time() const;
  void set_end_time(float value);
  private:
  float _internal_end_time() const;
  void _internal_set_end_time(float value);
  public:

  // float confidence = 4;
  void clear_confidence();
  float confidence() const;
  void set_confidence(float value);
  private:
  float _internal_confidence() const;
  void _internal_set_confidence(float value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.audio.v1.WordTiming)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr word_;
    float start_time_;
    float end_time_;
    float confidence_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_2eproto;
};
// -------------------------------------------------------------------

class STTMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.audio.v1.STTMetadata) */ {
 public:
  inline STTMetadata() : STTMetadata(nullptr) {}
  ~STTMetadata() override;
  explicit PROTOBUF_CONSTEXPR STTMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  STTMetadata(const STTMetadata& from);
  STTMetadata(STTMetadata&& from) noexcept
    : STTMetadata() {
    *this = ::std::move(from);
  }

  inline STTMetadata& operator=(const STTMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline STTMetadata& operator=(STTMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const STTMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const STTMetadata* internal_default_instance() {
    return reinterpret_cast<const STTMetadata*>(
               &_STTMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(STTMetadata& a, STTMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(STTMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(STTMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  STTMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<STTMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const STTMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const STTMetadata& from) {
    STTMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(STTMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.audio.v1.STTMetadata";
  }
  protected:
  explicit STTMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDetectedLanguagesFieldNumber = 6,
    kModelFieldNumber = 1,
    kLanguageFieldNumber = 2,
    kProcessingTimeMsFieldNumber = 3,
    kSignalToNoiseRatioFieldNumber = 4,
    kSpeechRateWpmFieldNumber = 5,
    kHasBackgroundNoiseFieldNumber = 7,
    kHasMultipleSpeakersFieldNumber = 8,
    kDetectedQualityFieldNumber = 9,
  };
  // repeated string detected_languages = 6;
  int detected_languages_size() const;
  private:
  int _internal_detected_languages_size() const;
  public:
  void clear_detected_languages();
  const std::string& detected_languages(int index) const;
  std::string* mutable_detected_languages(int index);
  void set_detected_languages(int index, const std::string& value);
  void set_detected_languages(int index, std::string&& value);
  void set_detected_languages(int index, const char* value);
  void set_detected_languages(int index, const char* value, size_t size);
  std::string* add_detected_languages();
  void add_detected_languages(const std::string& value);
  void add_detected_languages(std::string&& value);
  void add_detected_languages(const char* value);
  void add_detected_languages(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& detected_languages() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_detected_languages();
  private:
  const std::string& _internal_detected_languages(int index) const;
  std::string* _internal_add_detected_languages();
  public:

  // string model = 1;
  void clear_model();
  const std::string& model() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model();
  PROTOBUF_NODISCARD std::string* release_model();
  void set_allocated_model(std::string* model);
  private:
  const std::string& _internal_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model(const std::string& value);
  std::string* _internal_mutable_model();
  public:

  // string language = 2;
  void clear_language();
  const std::string& language() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_language(ArgT0&& arg0, ArgT... args);
  std::string* mutable_language();
  PROTOBUF_NODISCARD std::string* release_language();
  void set_allocated_language(std::string* language);
  private:
  const std::string& _internal_language() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language(const std::string& value);
  std::string* _internal_mutable_language();
  public:

  // float processing_time_ms = 3;
  void clear_processing_time_ms();
  float processing_time_ms() const;
  void set_processing_time_ms(float value);
  private:
  float _internal_processing_time_ms() const;
  void _internal_set_processing_time_ms(float value);
  public:

  // float signal_to_noise_ratio = 4;
  void clear_signal_to_noise_ratio();
  float signal_to_noise_ratio() const;
  void set_signal_to_noise_ratio(float value);
  private:
  float _internal_signal_to_noise_ratio() const;
  void _internal_set_signal_to_noise_ratio(float value);
  public:

  // float speech_rate_wpm = 5;
  void clear_speech_rate_wpm();
  float speech_rate_wpm() const;
  void set_speech_rate_wpm(float value);
  private:
  float _internal_speech_rate_wpm() const;
  void _internal_set_speech_rate_wpm(float value);
  public:

  // bool has_background_noise = 7;
  void clear_has_background_noise();
  bool has_background_noise() const;
  void set_has_background_noise(bool value);
  private:
  bool _internal_has_background_noise() const;
  void _internal_set_has_background_noise(bool value);
  public:

  // bool has_multiple_speakers = 8;
  void clear_has_multiple_speakers();
  bool has_multiple_speakers() const;
  void set_has_multiple_speakers(bool value);
  private:
  bool _internal_has_multiple_speakers() const;
  void _internal_set_has_multiple_speakers(bool value);
  public:

  // .unhinged.audio.v1.AudioQuality detected_quality = 9;
  void clear_detected_quality();
  ::unhinged::audio::v1::AudioQuality detected_quality() const;
  void set_detected_quality(::unhinged::audio::v1::AudioQuality value);
  private:
  ::unhinged::audio::v1::AudioQuality _internal_detected_quality() const;
  void _internal_set_detected_quality(::unhinged::audio::v1::AudioQuality value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.audio.v1.STTMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> detected_languages_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_;
    float processing_time_ms_;
    float signal_to_noise_ratio_;
    float speech_rate_wpm_;
    bool has_background_noise_;
    bool has_multiple_speakers_;
    int detected_quality_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_2eproto;
};
// -------------------------------------------------------------------

class Voice final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.audio.v1.Voice) */ {
 public:
  inline Voice() : Voice(nullptr) {}
  ~Voice() override;
  explicit PROTOBUF_CONSTEXPR Voice(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Voice(const Voice& from);
  Voice(Voice&& from) noexcept
    : Voice() {
    *this = ::std::move(from);
  }

  inline Voice& operator=(const Voice& from) {
    CopyFrom(from);
    return *this;
  }
  inline Voice& operator=(Voice&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Voice& default_instance() {
    return *internal_default_instance();
  }
  static inline const Voice* internal_default_instance() {
    return reinterpret_cast<const Voice*>(
               &_Voice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Voice& a, Voice& b) {
    a.Swap(&b);
  }
  inline void Swap(Voice* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Voice* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Voice* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Voice>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Voice& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Voice& from) {
    Voice::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Voice* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.audio.v1.Voice";
  }
  protected:
  explicit Voice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSupportedFormatsFieldNumber = 10,
    kSupportedSampleRatesFieldNumber = 11,
    kNameFieldNumber = 2,
    kDisplayNameFieldNumber = 3,
    kDescriptionFieldNumber = 4,
    kLanguageFieldNumber = 5,
    kLanguageCodeFieldNumber = 6,
    kPreviewUrlFieldNumber = 15,
    kPreviewTextFieldNumber = 16,
    kMetadataFieldNumber = 1,
    kGenderFieldNumber = 7,
    kAgeFieldNumber = 8,
    kStyleFieldNumber = 9,
    kIsAvailableFieldNumber = 12,
    kIsPremiumFieldNumber = 13,
    kCostPerCharacterFieldNumber = 14,
  };
  // repeated .unhinged.audio.v1.AudioFormat supported_formats = 10;
  int supported_formats_size() const;
  private:
  int _internal_supported_formats_size() const;
  public:
  void clear_supported_formats();
  private:
  ::unhinged::audio::v1::AudioFormat _internal_supported_formats(int index) const;
  void _internal_add_supported_formats(::unhinged::audio::v1::AudioFormat value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_supported_formats();
  public:
  ::unhinged::audio::v1::AudioFormat supported_formats(int index) const;
  void set_supported_formats(int index, ::unhinged::audio::v1::AudioFormat value);
  void add_supported_formats(::unhinged::audio::v1::AudioFormat value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& supported_formats() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_supported_formats();

  // repeated int32 supported_sample_rates = 11;
  int supported_sample_rates_size() const;
  private:
  int _internal_supported_sample_rates_size() const;
  public:
  void clear_supported_sample_rates();
  private:
  int32_t _internal_supported_sample_rates(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_supported_sample_rates() const;
  void _internal_add_supported_sample_rates(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_supported_sample_rates();
  public:
  int32_t supported_sample_rates(int index) const;
  void set_supported_sample_rates(int index, int32_t value);
  void add_supported_sample_rates(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      supported_sample_rates() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_supported_sample_rates();

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string display_name = 3;
  void clear_display_name();
  const std::string& display_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_display_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_display_name();
  PROTOBUF_NODISCARD std::string* release_display_name();
  void set_allocated_display_name(std::string* display_name);
  private:
  const std::string& _internal_display_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_display_name(const std::string& value);
  std::string* _internal_mutable_display_name();
  public:

  // string description = 4;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string language = 5;
  void clear_language();
  const std::string& language() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_language(ArgT0&& arg0, ArgT... args);
  std::string* mutable_language();
  PROTOBUF_NODISCARD std::string* release_language();
  void set_allocated_language(std::string* language);
  private:
  const std::string& _internal_language() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language(const std::string& value);
  std::string* _internal_mutable_language();
  public:

  // string language_code = 6;
  void clear_language_code();
  const std::string& language_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_language_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_language_code();
  PROTOBUF_NODISCARD std::string* release_language_code();
  void set_allocated_language_code(std::string* language_code);
  private:
  const std::string& _internal_language_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language_code(const std::string& value);
  std::string* _internal_mutable_language_code();
  public:

  // string preview_url = 15;
  void clear_preview_url();
  const std::string& preview_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_preview_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_preview_url();
  PROTOBUF_NODISCARD std::string* release_preview_url();
  void set_allocated_preview_url(std::string* preview_url);
  private:
  const std::string& _internal_preview_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_preview_url(const std::string& value);
  std::string* _internal_mutable_preview_url();
  public:

  // string preview_text = 16;
  void clear_preview_text();
  const std::string& preview_text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_preview_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_preview_text();
  PROTOBUF_NODISCARD std::string* release_preview_text();
  void set_allocated_preview_text(std::string* preview_text);
  private:
  const std::string& _internal_preview_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_preview_text(const std::string& value);
  std::string* _internal_mutable_preview_text();
  public:

  // .unhinged.common.v1.ResourceMetadata metadata = 1;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::unhinged::common::v1::ResourceMetadata& metadata() const;
  PROTOBUF_NODISCARD ::unhinged::common::v1::ResourceMetadata* release_metadata();
  ::unhinged::common::v1::ResourceMetadata* mutable_metadata();
  void set_allocated_metadata(::unhinged::common::v1::ResourceMetadata* metadata);
  private:
  const ::unhinged::common::v1::ResourceMetadata& _internal_metadata() const;
  ::unhinged::common::v1::ResourceMetadata* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::unhinged::common::v1::ResourceMetadata* metadata);
  ::unhinged::common::v1::ResourceMetadata* unsafe_arena_release_metadata();

  // .unhinged.audio.v1.VoiceGender gender = 7;
  void clear_gender();
  ::unhinged::audio::v1::VoiceGender gender() const;
  void set_gender(::unhinged::audio::v1::VoiceGender value);
  private:
  ::unhinged::audio::v1::VoiceGender _internal_gender() const;
  void _internal_set_gender(::unhinged::audio::v1::VoiceGender value);
  public:

  // .unhinged.audio.v1.VoiceAge age = 8;
  void clear_age();
  ::unhinged::audio::v1::VoiceAge age() const;
  void set_age(::unhinged::audio::v1::VoiceAge value);
  private:
  ::unhinged::audio::v1::VoiceAge _internal_age() const;
  void _internal_set_age(::unhinged::audio::v1::VoiceAge value);
  public:

  // .unhinged.audio.v1.VoiceStyle style = 9;
  void clear_style();
  ::unhinged::audio::v1::VoiceStyle style() const;
  void set_style(::unhinged::audio::v1::VoiceStyle value);
  private:
  ::unhinged::audio::v1::VoiceStyle _internal_style() const;
  void _internal_set_style(::unhinged::audio::v1::VoiceStyle value);
  public:

  // bool is_available = 12;
  void clear_is_available();
  bool is_available() const;
  void set_is_available(bool value);
  private:
  bool _internal_is_available() const;
  void _internal_set_is_available(bool value);
  public:

  // bool is_premium = 13;
  void clear_is_premium();
  bool is_premium() const;
  void set_is_premium(bool value);
  private:
  bool _internal_is_premium() const;
  void _internal_set_is_premium(bool value);
  public:

  // float cost_per_character = 14;
  void clear_cost_per_character();
  float cost_per_character() const;
  void set_cost_per_character(float value);
  private:
  float _internal_cost_per_character() const;
  void _internal_set_cost_per_character(float value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.audio.v1.Voice)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> supported_formats_;
    mutable std::atomic<int> _supported_formats_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > supported_sample_rates_;
    mutable std::atomic<int> _supported_sample_rates_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr display_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_code_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr preview_url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr preview_text_;
    ::unhinged::common::v1::ResourceMetadata* metadata_;
    int gender_;
    int age_;
    int style_;
    bool is_available_;
    bool is_premium_;
    float cost_per_character_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_2eproto;
};
// -------------------------------------------------------------------

class TTSChunkPayload final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.audio.v1.TTSChunkPayload) */ {
 public:
  inline TTSChunkPayload() : TTSChunkPayload(nullptr) {}
  ~TTSChunkPayload() override;
  explicit PROTOBUF_CONSTEXPR TTSChunkPayload(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TTSChunkPayload(const TTSChunkPayload& from);
  TTSChunkPayload(TTSChunkPayload&& from) noexcept
    : TTSChunkPayload() {
    *this = ::std::move(from);
  }

  inline TTSChunkPayload& operator=(const TTSChunkPayload& from) {
    CopyFrom(from);
    return *this;
  }
  inline TTSChunkPayload& operator=(TTSChunkPayload&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TTSChunkPayload& default_instance() {
    return *internal_default_instance();
  }
  static inline const TTSChunkPayload* internal_default_instance() {
    return reinterpret_cast<const TTSChunkPayload*>(
               &_TTSChunkPayload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(TTSChunkPayload& a, TTSChunkPayload& b) {
    a.Swap(&b);
  }
  inline void Swap(TTSChunkPayload* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TTSChunkPayload* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TTSChunkPayload* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TTSChunkPayload>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TTSChunkPayload& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TTSChunkPayload& from) {
    TTSChunkPayload::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TTSChunkPayload* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.audio.v1.TTSChunkPayload";
  }
  protected:
  explicit TTSChunkPayload(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTtsIdFieldNumber = 1,
    kAudioMetadataFieldNumber = 2,
    kChunkIndexFieldNumber = 3,
    kProgressPercentFieldNumber = 4,
  };
  // string tts_id = 1;
  void clear_tts_id();
  const std::string& tts_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tts_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tts_id();
  PROTOBUF_NODISCARD std::string* release_tts_id();
  void set_allocated_tts_id(std::string* tts_id);
  private:
  const std::string& _internal_tts_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tts_id(const std::string& value);
  std::string* _internal_mutable_tts_id();
  public:

  // .unhinged.audio.v1.AudioMetadata audio_metadata = 2;
  bool has_audio_metadata() const;
  private:
  bool _internal_has_audio_metadata() const;
  public:
  void clear_audio_metadata();
  const ::unhinged::audio::v1::AudioMetadata& audio_metadata() const;
  PROTOBUF_NODISCARD ::unhinged::audio::v1::AudioMetadata* release_audio_metadata();
  ::unhinged::audio::v1::AudioMetadata* mutable_audio_metadata();
  void set_allocated_audio_metadata(::unhinged::audio::v1::AudioMetadata* audio_metadata);
  private:
  const ::unhinged::audio::v1::AudioMetadata& _internal_audio_metadata() const;
  ::unhinged::audio::v1::AudioMetadata* _internal_mutable_audio_metadata();
  public:
  void unsafe_arena_set_allocated_audio_metadata(
      ::unhinged::audio::v1::AudioMetadata* audio_metadata);
  ::unhinged::audio::v1::AudioMetadata* unsafe_arena_release_audio_metadata();

  // int32 chunk_index = 3;
  void clear_chunk_index();
  int32_t chunk_index() const;
  void set_chunk_index(int32_t value);
  private:
  int32_t _internal_chunk_index() const;
  void _internal_set_chunk_index(int32_t value);
  public:

  // float progress_percent = 4;
  void clear_progress_percent();
  float progress_percent() const;
  void set_progress_percent(float value);
  private:
  float _internal_progress_percent() const;
  void _internal_set_progress_percent(float value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.audio.v1.TTSChunkPayload)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tts_id_;
    ::unhinged::audio::v1::AudioMetadata* audio_metadata_;
    int32_t chunk_index_;
    float progress_percent_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_2eproto;
};
// -------------------------------------------------------------------

class STTChunkPayload final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.audio.v1.STTChunkPayload) */ {
 public:
  inline STTChunkPayload() : STTChunkPayload(nullptr) {}
  ~STTChunkPayload() override;
  explicit PROTOBUF_CONSTEXPR STTChunkPayload(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  STTChunkPayload(const STTChunkPayload& from);
  STTChunkPayload(STTChunkPayload&& from) noexcept
    : STTChunkPayload() {
    *this = ::std::move(from);
  }

  inline STTChunkPayload& operator=(const STTChunkPayload& from) {
    CopyFrom(from);
    return *this;
  }
  inline STTChunkPayload& operator=(STTChunkPayload&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const STTChunkPayload& default_instance() {
    return *internal_default_instance();
  }
  static inline const STTChunkPayload* internal_default_instance() {
    return reinterpret_cast<const STTChunkPayload*>(
               &_STTChunkPayload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(STTChunkPayload& a, STTChunkPayload& b) {
    a.Swap(&b);
  }
  inline void Swap(STTChunkPayload* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(STTChunkPayload* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  STTChunkPayload* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<STTChunkPayload>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const STTChunkPayload& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const STTChunkPayload& from) {
    STTChunkPayload::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(STTChunkPayload* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.audio.v1.STTChunkPayload";
  }
  protected:
  explicit STTChunkPayload(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSttIdFieldNumber = 1,
    kAudioMetadataFieldNumber = 2,
    kIsFinalChunkFieldNumber = 3,
  };
  // string stt_id = 1;
  void clear_stt_id();
  const std::string& stt_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stt_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stt_id();
  PROTOBUF_NODISCARD std::string* release_stt_id();
  void set_allocated_stt_id(std::string* stt_id);
  private:
  const std::string& _internal_stt_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stt_id(const std::string& value);
  std::string* _internal_mutable_stt_id();
  public:

  // .unhinged.audio.v1.AudioMetadata audio_metadata = 2;
  bool has_audio_metadata() const;
  private:
  bool _internal_has_audio_metadata() const;
  public:
  void clear_audio_metadata();
  const ::unhinged::audio::v1::AudioMetadata& audio_metadata() const;
  PROTOBUF_NODISCARD ::unhinged::audio::v1::AudioMetadata* release_audio_metadata();
  ::unhinged::audio::v1::AudioMetadata* mutable_audio_metadata();
  void set_allocated_audio_metadata(::unhinged::audio::v1::AudioMetadata* audio_metadata);
  private:
  const ::unhinged::audio::v1::AudioMetadata& _internal_audio_metadata() const;
  ::unhinged::audio::v1::AudioMetadata* _internal_mutable_audio_metadata();
  public:
  void unsafe_arena_set_allocated_audio_metadata(
      ::unhinged::audio::v1::AudioMetadata* audio_metadata);
  ::unhinged::audio::v1::AudioMetadata* unsafe_arena_release_audio_metadata();

  // bool is_final_chunk = 3;
  void clear_is_final_chunk();
  bool is_final_chunk() const;
  void set_is_final_chunk(bool value);
  private:
  bool _internal_is_final_chunk() const;
  void _internal_set_is_final_chunk(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.audio.v1.STTChunkPayload)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stt_id_;
    ::unhinged::audio::v1::AudioMetadata* audio_metadata_;
    bool is_final_chunk_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_2eproto;
};
// -------------------------------------------------------------------

class AudioMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.audio.v1.AudioMetadata) */ {
 public:
  inline AudioMetadata() : AudioMetadata(nullptr) {}
  ~AudioMetadata() override;
  explicit PROTOBUF_CONSTEXPR AudioMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AudioMetadata(const AudioMetadata& from);
  AudioMetadata(AudioMetadata&& from) noexcept
    : AudioMetadata() {
    *this = ::std::move(from);
  }

  inline AudioMetadata& operator=(const AudioMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioMetadata& operator=(AudioMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AudioMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const AudioMetadata* internal_default_instance() {
    return reinterpret_cast<const AudioMetadata*>(
               &_AudioMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(AudioMetadata& a, AudioMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AudioMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AudioMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AudioMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AudioMetadata& from) {
    AudioMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AudioMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.audio.v1.AudioMetadata";
  }
  protected:
  explicit AudioMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFormatFieldNumber = 1,
    kSampleRateFieldNumber = 2,
    kChannelsFieldNumber = 3,
    kBitDepthFieldNumber = 4,
    kTotalBytesFieldNumber = 6,
    kDurationSecondsFieldNumber = 5,
  };
  // .unhinged.audio.v1.AudioFormat format = 1;
  void clear_format();
  ::unhinged::audio::v1::AudioFormat format() const;
  void set_format(::unhinged::audio::v1::AudioFormat value);
  private:
  ::unhinged::audio::v1::AudioFormat _internal_format() const;
  void _internal_set_format(::unhinged::audio::v1::AudioFormat value);
  public:

  // int32 sample_rate = 2;
  void clear_sample_rate();
  int32_t sample_rate() const;
  void set_sample_rate(int32_t value);
  private:
  int32_t _internal_sample_rate() const;
  void _internal_set_sample_rate(int32_t value);
  public:

  // int32 channels = 3;
  void clear_channels();
  int32_t channels() const;
  void set_channels(int32_t value);
  private:
  int32_t _internal_channels() const;
  void _internal_set_channels(int32_t value);
  public:

  // int32 bit_depth = 4;
  void clear_bit_depth();
  int32_t bit_depth() const;
  void set_bit_depth(int32_t value);
  private:
  int32_t _internal_bit_depth() const;
  void _internal_set_bit_depth(int32_t value);
  public:

  // int64 total_bytes = 6;
  void clear_total_bytes();
  int64_t total_bytes() const;
  void set_total_bytes(int64_t value);
  private:
  int64_t _internal_total_bytes() const;
  void _internal_set_total_bytes(int64_t value);
  public:

  // float duration_seconds = 5;
  void clear_duration_seconds();
  float duration_seconds() const;
  void set_duration_seconds(float value);
  private:
  float _internal_duration_seconds() const;
  void _internal_set_duration_seconds(float value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.audio.v1.AudioMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int format_;
    int32_t sample_rate_;
    int32_t channels_;
    int32_t bit_depth_;
    int64_t total_bytes_;
    float duration_seconds_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_2eproto;
};
// -------------------------------------------------------------------

class ProcessAudioRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.audio.v1.ProcessAudioRequest) */ {
 public:
  inline ProcessAudioRequest() : ProcessAudioRequest(nullptr) {}
  ~ProcessAudioRequest() override;
  explicit PROTOBUF_CONSTEXPR ProcessAudioRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProcessAudioRequest(const ProcessAudioRequest& from);
  ProcessAudioRequest(ProcessAudioRequest&& from) noexcept
    : ProcessAudioRequest() {
    *this = ::std::move(from);
  }

  inline ProcessAudioRequest& operator=(const ProcessAudioRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcessAudioRequest& operator=(ProcessAudioRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProcessAudioRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProcessAudioRequest* internal_default_instance() {
    return reinterpret_cast<const ProcessAudioRequest*>(
               &_ProcessAudioRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ProcessAudioRequest& a, ProcessAudioRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcessAudioRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcessAudioRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProcessAudioRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProcessAudioRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProcessAudioRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProcessAudioRequest& from) {
    ProcessAudioRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcessAudioRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.audio.v1.ProcessAudioRequest";
  }
  protected:
  explicit ProcessAudioRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAudioFileFieldNumber = 1,
    kOptionsFieldNumber = 3,
    kProcessingTypeFieldNumber = 2,
  };
  // .unhinged.common.v1.Attachment audio_file = 1;
  bool has_audio_file() const;
  private:
  bool _internal_has_audio_file() const;
  public:
  void clear_audio_file();
  const ::unhinged::common::v1::Attachment& audio_file() const;
  PROTOBUF_NODISCARD ::unhinged::common::v1::Attachment* release_audio_file();
  ::unhinged::common::v1::Attachment* mutable_audio_file();
  void set_allocated_audio_file(::unhinged::common::v1::Attachment* audio_file);
  private:
  const ::unhinged::common::v1::Attachment& _internal_audio_file() const;
  ::unhinged::common::v1::Attachment* _internal_mutable_audio_file();
  public:
  void unsafe_arena_set_allocated_audio_file(
      ::unhinged::common::v1::Attachment* audio_file);
  ::unhinged::common::v1::Attachment* unsafe_arena_release_audio_file();

  // .unhinged.audio.v1.AudioOptions options = 3;
  bool has_options() const;
  private:
  bool _internal_has_options() const;
  public:
  void clear_options();
  const ::unhinged::audio::v1::AudioOptions& options() const;
  PROTOBUF_NODISCARD ::unhinged::audio::v1::AudioOptions* release_options();
  ::unhinged::audio::v1::AudioOptions* mutable_options();
  void set_allocated_options(::unhinged::audio::v1::AudioOptions* options);
  private:
  const ::unhinged::audio::v1::AudioOptions& _internal_options() const;
  ::unhinged::audio::v1::AudioOptions* _internal_mutable_options();
  public:
  void unsafe_arena_set_allocated_options(
      ::unhinged::audio::v1::AudioOptions* options);
  ::unhinged::audio::v1::AudioOptions* unsafe_arena_release_options();

  // .unhinged.audio.v1.ProcessingType processing_type = 2;
  void clear_processing_type();
  ::unhinged::audio::v1::ProcessingType processing_type() const;
  void set_processing_type(::unhinged::audio::v1::ProcessingType value);
  private:
  ::unhinged::audio::v1::ProcessingType _internal_processing_type() const;
  void _internal_set_processing_type(::unhinged::audio::v1::ProcessingType value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.audio.v1.ProcessAudioRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::unhinged::common::v1::Attachment* audio_file_;
    ::unhinged::audio::v1::AudioOptions* options_;
    int processing_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_2eproto;
};
// -------------------------------------------------------------------

class ProcessAudioResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.audio.v1.ProcessAudioResponse) */ {
 public:
  inline ProcessAudioResponse() : ProcessAudioResponse(nullptr) {}
  ~ProcessAudioResponse() override;
  explicit PROTOBUF_CONSTEXPR ProcessAudioResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProcessAudioResponse(const ProcessAudioResponse& from);
  ProcessAudioResponse(ProcessAudioResponse&& from) noexcept
    : ProcessAudioResponse() {
    *this = ::std::move(from);
  }

  inline ProcessAudioResponse& operator=(const ProcessAudioResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcessAudioResponse& operator=(ProcessAudioResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProcessAudioResponse& default_instance() {
    return *internal_default_instance();
  }
  enum ResultCase {
    kTranscript = 2,
    kTranslation = 3,
    kEnhancedAudio = 4,
    kConvertedAudio = 5,
    RESULT_NOT_SET = 0,
  };

  static inline const ProcessAudioResponse* internal_default_instance() {
    return reinterpret_cast<const ProcessAudioResponse*>(
               &_ProcessAudioResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ProcessAudioResponse& a, ProcessAudioResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcessAudioResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcessAudioResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProcessAudioResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProcessAudioResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProcessAudioResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProcessAudioResponse& from) {
    ProcessAudioResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcessAudioResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.audio.v1.ProcessAudioResponse";
  }
  protected:
  explicit ProcessAudioResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 1,
    kUsageFieldNumber = 6,
    kTranscriptFieldNumber = 2,
    kTranslationFieldNumber = 3,
    kEnhancedAudioFieldNumber = 4,
    kConvertedAudioFieldNumber = 5,
  };
  // .unhinged.common.v1.StandardResponse response = 1;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::unhinged::common::v1::StandardResponse& response() const;
  PROTOBUF_NODISCARD ::unhinged::common::v1::StandardResponse* release_response();
  ::unhinged::common::v1::StandardResponse* mutable_response();
  void set_allocated_response(::unhinged::common::v1::StandardResponse* response);
  private:
  const ::unhinged::common::v1::StandardResponse& _internal_response() const;
  ::unhinged::common::v1::StandardResponse* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::unhinged::common::v1::StandardResponse* response);
  ::unhinged::common::v1::StandardResponse* unsafe_arena_release_response();

  // .unhinged.common.v1.AudioUsage usage = 6;
  bool has_usage() const;
  private:
  bool _internal_has_usage() const;
  public:
  void clear_usage();
  const ::unhinged::common::v1::AudioUsage& usage() const;
  PROTOBUF_NODISCARD ::unhinged::common::v1::AudioUsage* release_usage();
  ::unhinged::common::v1::AudioUsage* mutable_usage();
  void set_allocated_usage(::unhinged::common::v1::AudioUsage* usage);
  private:
  const ::unhinged::common::v1::AudioUsage& _internal_usage() const;
  ::unhinged::common::v1::AudioUsage* _internal_mutable_usage();
  public:
  void unsafe_arena_set_allocated_usage(
      ::unhinged::common::v1::AudioUsage* usage);
  ::unhinged::common::v1::AudioUsage* unsafe_arena_release_usage();

  // string transcript = 2;
  bool has_transcript() const;
  private:
  bool _internal_has_transcript() const;
  public:
  void clear_transcript();
  const std::string& transcript() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_transcript(ArgT0&& arg0, ArgT... args);
  std::string* mutable_transcript();
  PROTOBUF_NODISCARD std::string* release_transcript();
  void set_allocated_transcript(std::string* transcript);
  private:
  const std::string& _internal_transcript() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transcript(const std::string& value);
  std::string* _internal_mutable_transcript();
  public:

  // string translation = 3;
  bool has_translation() const;
  private:
  bool _internal_has_translation() const;
  public:
  void clear_translation();
  const std::string& translation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_translation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_translation();
  PROTOBUF_NODISCARD std::string* release_translation();
  void set_allocated_translation(std::string* translation);
  private:
  const std::string& _internal_translation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_translation(const std::string& value);
  std::string* _internal_mutable_translation();
  public:

  // .unhinged.common.v1.Attachment enhanced_audio = 4;
  bool has_enhanced_audio() const;
  private:
  bool _internal_has_enhanced_audio() const;
  public:
  void clear_enhanced_audio();
  const ::unhinged::common::v1::Attachment& enhanced_audio() const;
  PROTOBUF_NODISCARD ::unhinged::common::v1::Attachment* release_enhanced_audio();
  ::unhinged::common::v1::Attachment* mutable_enhanced_audio();
  void set_allocated_enhanced_audio(::unhinged::common::v1::Attachment* enhanced_audio);
  private:
  const ::unhinged::common::v1::Attachment& _internal_enhanced_audio() const;
  ::unhinged::common::v1::Attachment* _internal_mutable_enhanced_audio();
  public:
  void unsafe_arena_set_allocated_enhanced_audio(
      ::unhinged::common::v1::Attachment* enhanced_audio);
  ::unhinged::common::v1::Attachment* unsafe_arena_release_enhanced_audio();

  // .unhinged.common.v1.Attachment converted_audio = 5;
  bool has_converted_audio() const;
  private:
  bool _internal_has_converted_audio() const;
  public:
  void clear_converted_audio();
  const ::unhinged::common::v1::Attachment& converted_audio() const;
  PROTOBUF_NODISCARD ::unhinged::common::v1::Attachment* release_converted_audio();
  ::unhinged::common::v1::Attachment* mutable_converted_audio();
  void set_allocated_converted_audio(::unhinged::common::v1::Attachment* converted_audio);
  private:
  const ::unhinged::common::v1::Attachment& _internal_converted_audio() const;
  ::unhinged::common::v1::Attachment* _internal_mutable_converted_audio();
  public:
  void unsafe_arena_set_allocated_converted_audio(
      ::unhinged::common::v1::Attachment* converted_audio);
  ::unhinged::common::v1::Attachment* unsafe_arena_release_converted_audio();

  void clear_result();
  ResultCase result_case() const;
  // @@protoc_insertion_point(class_scope:unhinged.audio.v1.ProcessAudioResponse)
 private:
  class _Internal;
  void set_has_transcript();
  void set_has_translation();
  void set_has_enhanced_audio();
  void set_has_converted_audio();

  inline bool has_result() const;
  inline void clear_has_result();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::unhinged::common::v1::StandardResponse* response_;
    ::unhinged::common::v1::AudioUsage* usage_;
    union ResultUnion {
      constexpr ResultUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transcript_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr translation_;
      ::unhinged::common::v1::Attachment* enhanced_audio_;
      ::unhinged::common::v1::Attachment* converted_audio_;
    } result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_2eproto;
};
// -------------------------------------------------------------------

class ListVoicesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.audio.v1.ListVoicesRequest) */ {
 public:
  inline ListVoicesRequest() : ListVoicesRequest(nullptr) {}
  ~ListVoicesRequest() override;
  explicit PROTOBUF_CONSTEXPR ListVoicesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListVoicesRequest(const ListVoicesRequest& from);
  ListVoicesRequest(ListVoicesRequest&& from) noexcept
    : ListVoicesRequest() {
    *this = ::std::move(from);
  }

  inline ListVoicesRequest& operator=(const ListVoicesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListVoicesRequest& operator=(ListVoicesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListVoicesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListVoicesRequest* internal_default_instance() {
    return reinterpret_cast<const ListVoicesRequest*>(
               &_ListVoicesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ListVoicesRequest& a, ListVoicesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListVoicesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListVoicesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListVoicesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListVoicesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListVoicesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListVoicesRequest& from) {
    ListVoicesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListVoicesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.audio.v1.ListVoicesRequest";
  }
  protected:
  explicit ListVoicesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFiltersFieldNumber = 6,
    kLanguageFieldNumber = 1,
    kPaginationFieldNumber = 5,
    kGenderFieldNumber = 2,
    kStyleFieldNumber = 3,
    kPremiumOnlyFieldNumber = 4,
  };
  // repeated .unhinged.common.v1.Filter filters = 6;
  int filters_size() const;
  private:
  int _internal_filters_size() const;
  public:
  void clear_filters();
  ::unhinged::common::v1::Filter* mutable_filters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::common::v1::Filter >*
      mutable_filters();
  private:
  const ::unhinged::common::v1::Filter& _internal_filters(int index) const;
  ::unhinged::common::v1::Filter* _internal_add_filters();
  public:
  const ::unhinged::common::v1::Filter& filters(int index) const;
  ::unhinged::common::v1::Filter* add_filters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::common::v1::Filter >&
      filters() const;

  // string language = 1;
  void clear_language();
  const std::string& language() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_language(ArgT0&& arg0, ArgT... args);
  std::string* mutable_language();
  PROTOBUF_NODISCARD std::string* release_language();
  void set_allocated_language(std::string* language);
  private:
  const std::string& _internal_language() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language(const std::string& value);
  std::string* _internal_mutable_language();
  public:

  // .unhinged.common.v1.PaginationRequest pagination = 5;
  bool has_pagination() const;
  private:
  bool _internal_has_pagination() const;
  public:
  void clear_pagination();
  const ::unhinged::common::v1::PaginationRequest& pagination() const;
  PROTOBUF_NODISCARD ::unhinged::common::v1::PaginationRequest* release_pagination();
  ::unhinged::common::v1::PaginationRequest* mutable_pagination();
  void set_allocated_pagination(::unhinged::common::v1::PaginationRequest* pagination);
  private:
  const ::unhinged::common::v1::PaginationRequest& _internal_pagination() const;
  ::unhinged::common::v1::PaginationRequest* _internal_mutable_pagination();
  public:
  void unsafe_arena_set_allocated_pagination(
      ::unhinged::common::v1::PaginationRequest* pagination);
  ::unhinged::common::v1::PaginationRequest* unsafe_arena_release_pagination();

  // .unhinged.audio.v1.VoiceGender gender = 2;
  void clear_gender();
  ::unhinged::audio::v1::VoiceGender gender() const;
  void set_gender(::unhinged::audio::v1::VoiceGender value);
  private:
  ::unhinged::audio::v1::VoiceGender _internal_gender() const;
  void _internal_set_gender(::unhinged::audio::v1::VoiceGender value);
  public:

  // .unhinged.audio.v1.VoiceStyle style = 3;
  void clear_style();
  ::unhinged::audio::v1::VoiceStyle style() const;
  void set_style(::unhinged::audio::v1::VoiceStyle value);
  private:
  ::unhinged::audio::v1::VoiceStyle _internal_style() const;
  void _internal_set_style(::unhinged::audio::v1::VoiceStyle value);
  public:

  // bool premium_only = 4;
  void clear_premium_only();
  bool premium_only() const;
  void set_premium_only(bool value);
  private:
  bool _internal_premium_only() const;
  void _internal_set_premium_only(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.audio.v1.ListVoicesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::common::v1::Filter > filters_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_;
    ::unhinged::common::v1::PaginationRequest* pagination_;
    int gender_;
    int style_;
    bool premium_only_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_2eproto;
};
// -------------------------------------------------------------------

class ListVoicesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.audio.v1.ListVoicesResponse) */ {
 public:
  inline ListVoicesResponse() : ListVoicesResponse(nullptr) {}
  ~ListVoicesResponse() override;
  explicit PROTOBUF_CONSTEXPR ListVoicesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListVoicesResponse(const ListVoicesResponse& from);
  ListVoicesResponse(ListVoicesResponse&& from) noexcept
    : ListVoicesResponse() {
    *this = ::std::move(from);
  }

  inline ListVoicesResponse& operator=(const ListVoicesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListVoicesResponse& operator=(ListVoicesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListVoicesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListVoicesResponse* internal_default_instance() {
    return reinterpret_cast<const ListVoicesResponse*>(
               &_ListVoicesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ListVoicesResponse& a, ListVoicesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListVoicesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListVoicesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListVoicesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListVoicesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListVoicesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListVoicesResponse& from) {
    ListVoicesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListVoicesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.audio.v1.ListVoicesResponse";
  }
  protected:
  explicit ListVoicesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVoicesFieldNumber = 2,
    kResponseFieldNumber = 1,
    kPaginationFieldNumber = 3,
  };
  // repeated .unhinged.audio.v1.Voice voices = 2;
  int voices_size() const;
  private:
  int _internal_voices_size() const;
  public:
  void clear_voices();
  ::unhinged::audio::v1::Voice* mutable_voices(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::audio::v1::Voice >*
      mutable_voices();
  private:
  const ::unhinged::audio::v1::Voice& _internal_voices(int index) const;
  ::unhinged::audio::v1::Voice* _internal_add_voices();
  public:
  const ::unhinged::audio::v1::Voice& voices(int index) const;
  ::unhinged::audio::v1::Voice* add_voices();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::audio::v1::Voice >&
      voices() const;

  // .unhinged.common.v1.StandardResponse response = 1;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::unhinged::common::v1::StandardResponse& response() const;
  PROTOBUF_NODISCARD ::unhinged::common::v1::StandardResponse* release_response();
  ::unhinged::common::v1::StandardResponse* mutable_response();
  void set_allocated_response(::unhinged::common::v1::StandardResponse* response);
  private:
  const ::unhinged::common::v1::StandardResponse& _internal_response() const;
  ::unhinged::common::v1::StandardResponse* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::unhinged::common::v1::StandardResponse* response);
  ::unhinged::common::v1::StandardResponse* unsafe_arena_release_response();

  // .unhinged.common.v1.PaginationResponse pagination = 3;
  bool has_pagination() const;
  private:
  bool _internal_has_pagination() const;
  public:
  void clear_pagination();
  const ::unhinged::common::v1::PaginationResponse& pagination() const;
  PROTOBUF_NODISCARD ::unhinged::common::v1::PaginationResponse* release_pagination();
  ::unhinged::common::v1::PaginationResponse* mutable_pagination();
  void set_allocated_pagination(::unhinged::common::v1::PaginationResponse* pagination);
  private:
  const ::unhinged::common::v1::PaginationResponse& _internal_pagination() const;
  ::unhinged::common::v1::PaginationResponse* _internal_mutable_pagination();
  public:
  void unsafe_arena_set_allocated_pagination(
      ::unhinged::common::v1::PaginationResponse* pagination);
  ::unhinged::common::v1::PaginationResponse* unsafe_arena_release_pagination();

  // @@protoc_insertion_point(class_scope:unhinged.audio.v1.ListVoicesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::audio::v1::Voice > voices_;
    ::unhinged::common::v1::StandardResponse* response_;
    ::unhinged::common::v1::PaginationResponse* pagination_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_2eproto;
};
// -------------------------------------------------------------------

class GetVoiceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.audio.v1.GetVoiceRequest) */ {
 public:
  inline GetVoiceRequest() : GetVoiceRequest(nullptr) {}
  ~GetVoiceRequest() override;
  explicit PROTOBUF_CONSTEXPR GetVoiceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetVoiceRequest(const GetVoiceRequest& from);
  GetVoiceRequest(GetVoiceRequest&& from) noexcept
    : GetVoiceRequest() {
    *this = ::std::move(from);
  }

  inline GetVoiceRequest& operator=(const GetVoiceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetVoiceRequest& operator=(GetVoiceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetVoiceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetVoiceRequest* internal_default_instance() {
    return reinterpret_cast<const GetVoiceRequest*>(
               &_GetVoiceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(GetVoiceRequest& a, GetVoiceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetVoiceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetVoiceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetVoiceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetVoiceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetVoiceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetVoiceRequest& from) {
    GetVoiceRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetVoiceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.audio.v1.GetVoiceRequest";
  }
  protected:
  explicit GetVoiceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVoiceIdFieldNumber = 1,
    kIncludePreviewFieldNumber = 2,
  };
  // string voice_id = 1;
  void clear_voice_id();
  const std::string& voice_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_voice_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_voice_id();
  PROTOBUF_NODISCARD std::string* release_voice_id();
  void set_allocated_voice_id(std::string* voice_id);
  private:
  const std::string& _internal_voice_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_voice_id(const std::string& value);
  std::string* _internal_mutable_voice_id();
  public:

  // bool include_preview = 2;
  void clear_include_preview();
  bool include_preview() const;
  void set_include_preview(bool value);
  private:
  bool _internal_include_preview() const;
  void _internal_set_include_preview(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.audio.v1.GetVoiceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr voice_id_;
    bool include_preview_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_2eproto;
};
// -------------------------------------------------------------------

class GetVoiceResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.audio.v1.GetVoiceResponse) */ {
 public:
  inline GetVoiceResponse() : GetVoiceResponse(nullptr) {}
  ~GetVoiceResponse() override;
  explicit PROTOBUF_CONSTEXPR GetVoiceResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetVoiceResponse(const GetVoiceResponse& from);
  GetVoiceResponse(GetVoiceResponse&& from) noexcept
    : GetVoiceResponse() {
    *this = ::std::move(from);
  }

  inline GetVoiceResponse& operator=(const GetVoiceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetVoiceResponse& operator=(GetVoiceResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetVoiceResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetVoiceResponse* internal_default_instance() {
    return reinterpret_cast<const GetVoiceResponse*>(
               &_GetVoiceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(GetVoiceResponse& a, GetVoiceResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetVoiceResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetVoiceResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetVoiceResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetVoiceResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetVoiceResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetVoiceResponse& from) {
    GetVoiceResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetVoiceResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.audio.v1.GetVoiceResponse";
  }
  protected:
  explicit GetVoiceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 1,
    kVoiceFieldNumber = 2,
  };
  // .unhinged.common.v1.StandardResponse response = 1;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::unhinged::common::v1::StandardResponse& response() const;
  PROTOBUF_NODISCARD ::unhinged::common::v1::StandardResponse* release_response();
  ::unhinged::common::v1::StandardResponse* mutable_response();
  void set_allocated_response(::unhinged::common::v1::StandardResponse* response);
  private:
  const ::unhinged::common::v1::StandardResponse& _internal_response() const;
  ::unhinged::common::v1::StandardResponse* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::unhinged::common::v1::StandardResponse* response);
  ::unhinged::common::v1::StandardResponse* unsafe_arena_release_response();

  // .unhinged.audio.v1.Voice voice = 2;
  bool has_voice() const;
  private:
  bool _internal_has_voice() const;
  public:
  void clear_voice();
  const ::unhinged::audio::v1::Voice& voice() const;
  PROTOBUF_NODISCARD ::unhinged::audio::v1::Voice* release_voice();
  ::unhinged::audio::v1::Voice* mutable_voice();
  void set_allocated_voice(::unhinged::audio::v1::Voice* voice);
  private:
  const ::unhinged::audio::v1::Voice& _internal_voice() const;
  ::unhinged::audio::v1::Voice* _internal_mutable_voice();
  public:
  void unsafe_arena_set_allocated_voice(
      ::unhinged::audio::v1::Voice* voice);
  ::unhinged::audio::v1::Voice* unsafe_arena_release_voice();

  // @@protoc_insertion_point(class_scope:unhinged.audio.v1.GetVoiceResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::unhinged::common::v1::StandardResponse* response_;
    ::unhinged::audio::v1::Voice* voice_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_2eproto;
};
// -------------------------------------------------------------------

class CreateCustomVoiceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.audio.v1.CreateCustomVoiceRequest) */ {
 public:
  inline CreateCustomVoiceRequest() : CreateCustomVoiceRequest(nullptr) {}
  ~CreateCustomVoiceRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateCustomVoiceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateCustomVoiceRequest(const CreateCustomVoiceRequest& from);
  CreateCustomVoiceRequest(CreateCustomVoiceRequest&& from) noexcept
    : CreateCustomVoiceRequest() {
    *this = ::std::move(from);
  }

  inline CreateCustomVoiceRequest& operator=(const CreateCustomVoiceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateCustomVoiceRequest& operator=(CreateCustomVoiceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateCustomVoiceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateCustomVoiceRequest* internal_default_instance() {
    return reinterpret_cast<const CreateCustomVoiceRequest*>(
               &_CreateCustomVoiceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(CreateCustomVoiceRequest& a, CreateCustomVoiceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateCustomVoiceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateCustomVoiceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateCustomVoiceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateCustomVoiceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateCustomVoiceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateCustomVoiceRequest& from) {
    CreateCustomVoiceRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateCustomVoiceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.audio.v1.CreateCustomVoiceRequest";
  }
  protected:
  explicit CreateCustomVoiceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrainingSamplesFieldNumber = 3,
    kNameFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kTargetGenderFieldNumber = 4,
    kTargetStyleFieldNumber = 5,
  };
  // repeated .unhinged.common.v1.Attachment training_samples = 3;
  int training_samples_size() const;
  private:
  int _internal_training_samples_size() const;
  public:
  void clear_training_samples();
  ::unhinged::common::v1::Attachment* mutable_training_samples(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::common::v1::Attachment >*
      mutable_training_samples();
  private:
  const ::unhinged::common::v1::Attachment& _internal_training_samples(int index) const;
  ::unhinged::common::v1::Attachment* _internal_add_training_samples();
  public:
  const ::unhinged::common::v1::Attachment& training_samples(int index) const;
  ::unhinged::common::v1::Attachment* add_training_samples();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::common::v1::Attachment >&
      training_samples() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string description = 2;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // .unhinged.audio.v1.VoiceGender target_gender = 4;
  void clear_target_gender();
  ::unhinged::audio::v1::VoiceGender target_gender() const;
  void set_target_gender(::unhinged::audio::v1::VoiceGender value);
  private:
  ::unhinged::audio::v1::VoiceGender _internal_target_gender() const;
  void _internal_set_target_gender(::unhinged::audio::v1::VoiceGender value);
  public:

  // .unhinged.audio.v1.VoiceStyle target_style = 5;
  void clear_target_style();
  ::unhinged::audio::v1::VoiceStyle target_style() const;
  void set_target_style(::unhinged::audio::v1::VoiceStyle value);
  private:
  ::unhinged::audio::v1::VoiceStyle _internal_target_style() const;
  void _internal_set_target_style(::unhinged::audio::v1::VoiceStyle value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.audio.v1.CreateCustomVoiceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::common::v1::Attachment > training_samples_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    int target_gender_;
    int target_style_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_2eproto;
};
// -------------------------------------------------------------------

class CreateCustomVoiceResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.audio.v1.CreateCustomVoiceResponse) */ {
 public:
  inline CreateCustomVoiceResponse() : CreateCustomVoiceResponse(nullptr) {}
  ~CreateCustomVoiceResponse() override;
  explicit PROTOBUF_CONSTEXPR CreateCustomVoiceResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateCustomVoiceResponse(const CreateCustomVoiceResponse& from);
  CreateCustomVoiceResponse(CreateCustomVoiceResponse&& from) noexcept
    : CreateCustomVoiceResponse() {
    *this = ::std::move(from);
  }

  inline CreateCustomVoiceResponse& operator=(const CreateCustomVoiceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateCustomVoiceResponse& operator=(CreateCustomVoiceResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateCustomVoiceResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateCustomVoiceResponse* internal_default_instance() {
    return reinterpret_cast<const CreateCustomVoiceResponse*>(
               &_CreateCustomVoiceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(CreateCustomVoiceResponse& a, CreateCustomVoiceResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateCustomVoiceResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateCustomVoiceResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateCustomVoiceResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateCustomVoiceResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateCustomVoiceResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateCustomVoiceResponse& from) {
    CreateCustomVoiceResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateCustomVoiceResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.audio.v1.CreateCustomVoiceResponse";
  }
  protected:
  explicit CreateCustomVoiceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrainingJobIdFieldNumber = 3,
    kResponseFieldNumber = 1,
    kVoiceFieldNumber = 2,
  };
  // string training_job_id = 3;
  void clear_training_job_id();
  const std::string& training_job_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_training_job_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_training_job_id();
  PROTOBUF_NODISCARD std::string* release_training_job_id();
  void set_allocated_training_job_id(std::string* training_job_id);
  private:
  const std::string& _internal_training_job_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_training_job_id(const std::string& value);
  std::string* _internal_mutable_training_job_id();
  public:

  // .unhinged.common.v1.StandardResponse response = 1;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::unhinged::common::v1::StandardResponse& response() const;
  PROTOBUF_NODISCARD ::unhinged::common::v1::StandardResponse* release_response();
  ::unhinged::common::v1::StandardResponse* mutable_response();
  void set_allocated_response(::unhinged::common::v1::StandardResponse* response);
  private:
  const ::unhinged::common::v1::StandardResponse& _internal_response() const;
  ::unhinged::common::v1::StandardResponse* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::unhinged::common::v1::StandardResponse* response);
  ::unhinged::common::v1::StandardResponse* unsafe_arena_release_response();

  // .unhinged.audio.v1.Voice voice = 2;
  bool has_voice() const;
  private:
  bool _internal_has_voice() const;
  public:
  void clear_voice();
  const ::unhinged::audio::v1::Voice& voice() const;
  PROTOBUF_NODISCARD ::unhinged::audio::v1::Voice* release_voice();
  ::unhinged::audio::v1::Voice* mutable_voice();
  void set_allocated_voice(::unhinged::audio::v1::Voice* voice);
  private:
  const ::unhinged::audio::v1::Voice& _internal_voice() const;
  ::unhinged::audio::v1::Voice* _internal_mutable_voice();
  public:
  void unsafe_arena_set_allocated_voice(
      ::unhinged::audio::v1::Voice* voice);
  ::unhinged::audio::v1::Voice* unsafe_arena_release_voice();

  // @@protoc_insertion_point(class_scope:unhinged.audio.v1.CreateCustomVoiceResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr training_job_id_;
    ::unhinged::common::v1::StandardResponse* response_;
    ::unhinged::audio::v1::Voice* voice_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_2eproto;
};
// -------------------------------------------------------------------

class ConvertAudioRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.audio.v1.ConvertAudioRequest) */ {
 public:
  inline ConvertAudioRequest() : ConvertAudioRequest(nullptr) {}
  ~ConvertAudioRequest() override;
  explicit PROTOBUF_CONSTEXPR ConvertAudioRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConvertAudioRequest(const ConvertAudioRequest& from);
  ConvertAudioRequest(ConvertAudioRequest&& from) noexcept
    : ConvertAudioRequest() {
    *this = ::std::move(from);
  }

  inline ConvertAudioRequest& operator=(const ConvertAudioRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConvertAudioRequest& operator=(ConvertAudioRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConvertAudioRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConvertAudioRequest* internal_default_instance() {
    return reinterpret_cast<const ConvertAudioRequest*>(
               &_ConvertAudioRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(ConvertAudioRequest& a, ConvertAudioRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ConvertAudioRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConvertAudioRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConvertAudioRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConvertAudioRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConvertAudioRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConvertAudioRequest& from) {
    ConvertAudioRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConvertAudioRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.audio.v1.ConvertAudioRequest";
  }
  protected:
  explicit ConvertAudioRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInputAudioFieldNumber = 1,
    kOptionsFieldNumber = 4,
    kTargetFormatFieldNumber = 2,
    kTargetSampleRateFieldNumber = 3,
  };
  // .unhinged.common.v1.Attachment input_audio = 1;
  bool has_input_audio() const;
  private:
  bool _internal_has_input_audio() const;
  public:
  void clear_input_audio();
  const ::unhinged::common::v1::Attachment& input_audio() const;
  PROTOBUF_NODISCARD ::unhinged::common::v1::Attachment* release_input_audio();
  ::unhinged::common::v1::Attachment* mutable_input_audio();
  void set_allocated_input_audio(::unhinged::common::v1::Attachment* input_audio);
  private:
  const ::unhinged::common::v1::Attachment& _internal_input_audio() const;
  ::unhinged::common::v1::Attachment* _internal_mutable_input_audio();
  public:
  void unsafe_arena_set_allocated_input_audio(
      ::unhinged::common::v1::Attachment* input_audio);
  ::unhinged::common::v1::Attachment* unsafe_arena_release_input_audio();

  // .unhinged.audio.v1.AudioOptions options = 4;
  bool has_options() const;
  private:
  bool _internal_has_options() const;
  public:
  void clear_options();
  const ::unhinged::audio::v1::AudioOptions& options() const;
  PROTOBUF_NODISCARD ::unhinged::audio::v1::AudioOptions* release_options();
  ::unhinged::audio::v1::AudioOptions* mutable_options();
  void set_allocated_options(::unhinged::audio::v1::AudioOptions* options);
  private:
  const ::unhinged::audio::v1::AudioOptions& _internal_options() const;
  ::unhinged::audio::v1::AudioOptions* _internal_mutable_options();
  public:
  void unsafe_arena_set_allocated_options(
      ::unhinged::audio::v1::AudioOptions* options);
  ::unhinged::audio::v1::AudioOptions* unsafe_arena_release_options();

  // .unhinged.audio.v1.AudioFormat target_format = 2;
  void clear_target_format();
  ::unhinged::audio::v1::AudioFormat target_format() const;
  void set_target_format(::unhinged::audio::v1::AudioFormat value);
  private:
  ::unhinged::audio::v1::AudioFormat _internal_target_format() const;
  void _internal_set_target_format(::unhinged::audio::v1::AudioFormat value);
  public:

  // int32 target_sample_rate = 3;
  void clear_target_sample_rate();
  int32_t target_sample_rate() const;
  void set_target_sample_rate(int32_t value);
  private:
  int32_t _internal_target_sample_rate() const;
  void _internal_set_target_sample_rate(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.audio.v1.ConvertAudioRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::unhinged::common::v1::Attachment* input_audio_;
    ::unhinged::audio::v1::AudioOptions* options_;
    int target_format_;
    int32_t target_sample_rate_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_2eproto;
};
// -------------------------------------------------------------------

class ConvertAudioResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.audio.v1.ConvertAudioResponse) */ {
 public:
  inline ConvertAudioResponse() : ConvertAudioResponse(nullptr) {}
  ~ConvertAudioResponse() override;
  explicit PROTOBUF_CONSTEXPR ConvertAudioResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConvertAudioResponse(const ConvertAudioResponse& from);
  ConvertAudioResponse(ConvertAudioResponse&& from) noexcept
    : ConvertAudioResponse() {
    *this = ::std::move(from);
  }

  inline ConvertAudioResponse& operator=(const ConvertAudioResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConvertAudioResponse& operator=(ConvertAudioResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConvertAudioResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConvertAudioResponse* internal_default_instance() {
    return reinterpret_cast<const ConvertAudioResponse*>(
               &_ConvertAudioResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(ConvertAudioResponse& a, ConvertAudioResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ConvertAudioResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConvertAudioResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConvertAudioResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConvertAudioResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConvertAudioResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConvertAudioResponse& from) {
    ConvertAudioResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConvertAudioResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.audio.v1.ConvertAudioResponse";
  }
  protected:
  explicit ConvertAudioResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 1,
    kConvertedAudioFieldNumber = 2,
    kUsageFieldNumber = 3,
  };
  // .unhinged.common.v1.StandardResponse response = 1;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::unhinged::common::v1::StandardResponse& response() const;
  PROTOBUF_NODISCARD ::unhinged::common::v1::StandardResponse* release_response();
  ::unhinged::common::v1::StandardResponse* mutable_response();
  void set_allocated_response(::unhinged::common::v1::StandardResponse* response);
  private:
  const ::unhinged::common::v1::StandardResponse& _internal_response() const;
  ::unhinged::common::v1::StandardResponse* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::unhinged::common::v1::StandardResponse* response);
  ::unhinged::common::v1::StandardResponse* unsafe_arena_release_response();

  // .unhinged.common.v1.Attachment converted_audio = 2;
  bool has_converted_audio() const;
  private:
  bool _internal_has_converted_audio() const;
  public:
  void clear_converted_audio();
  const ::unhinged::common::v1::Attachment& converted_audio() const;
  PROTOBUF_NODISCARD ::unhinged::common::v1::Attachment* release_converted_audio();
  ::unhinged::common::v1::Attachment* mutable_converted_audio();
  void set_allocated_converted_audio(::unhinged::common::v1::Attachment* converted_audio);
  private:
  const ::unhinged::common::v1::Attachment& _internal_converted_audio() const;
  ::unhinged::common::v1::Attachment* _internal_mutable_converted_audio();
  public:
  void unsafe_arena_set_allocated_converted_audio(
      ::unhinged::common::v1::Attachment* converted_audio);
  ::unhinged::common::v1::Attachment* unsafe_arena_release_converted_audio();

  // .unhinged.common.v1.AudioUsage usage = 3;
  bool has_usage() const;
  private:
  bool _internal_has_usage() const;
  public:
  void clear_usage();
  const ::unhinged::common::v1::AudioUsage& usage() const;
  PROTOBUF_NODISCARD ::unhinged::common::v1::AudioUsage* release_usage();
  ::unhinged::common::v1::AudioUsage* mutable_usage();
  void set_allocated_usage(::unhinged::common::v1::AudioUsage* usage);
  private:
  const ::unhinged::common::v1::AudioUsage& _internal_usage() const;
  ::unhinged::common::v1::AudioUsage* _internal_mutable_usage();
  public:
  void unsafe_arena_set_allocated_usage(
      ::unhinged::common::v1::AudioUsage* usage);
  ::unhinged::common::v1::AudioUsage* unsafe_arena_release_usage();

  // @@protoc_insertion_point(class_scope:unhinged.audio.v1.ConvertAudioResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::unhinged::common::v1::StandardResponse* response_;
    ::unhinged::common::v1::Attachment* converted_audio_;
    ::unhinged::common::v1::AudioUsage* usage_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_2eproto;
};
// -------------------------------------------------------------------

class AnalyzeAudioRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.audio.v1.AnalyzeAudioRequest) */ {
 public:
  inline AnalyzeAudioRequest() : AnalyzeAudioRequest(nullptr) {}
  ~AnalyzeAudioRequest() override;
  explicit PROTOBUF_CONSTEXPR AnalyzeAudioRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AnalyzeAudioRequest(const AnalyzeAudioRequest& from);
  AnalyzeAudioRequest(AnalyzeAudioRequest&& from) noexcept
    : AnalyzeAudioRequest() {
    *this = ::std::move(from);
  }

  inline AnalyzeAudioRequest& operator=(const AnalyzeAudioRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnalyzeAudioRequest& operator=(AnalyzeAudioRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnalyzeAudioRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AnalyzeAudioRequest* internal_default_instance() {
    return reinterpret_cast<const AnalyzeAudioRequest*>(
               &_AnalyzeAudioRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(AnalyzeAudioRequest& a, AnalyzeAudioRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AnalyzeAudioRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnalyzeAudioRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnalyzeAudioRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AnalyzeAudioRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AnalyzeAudioRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AnalyzeAudioRequest& from) {
    AnalyzeAudioRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnalyzeAudioRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.audio.v1.AnalyzeAudioRequest";
  }
  protected:
  explicit AnalyzeAudioRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAnalysisTypesFieldNumber = 2,
    kAudioFileFieldNumber = 1,
  };
  // repeated .unhinged.audio.v1.AnalysisType analysis_types = 2;
  int analysis_types_size() const;
  private:
  int _internal_analysis_types_size() const;
  public:
  void clear_analysis_types();
  private:
  ::unhinged::audio::v1::AnalysisType _internal_analysis_types(int index) const;
  void _internal_add_analysis_types(::unhinged::audio::v1::AnalysisType value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_analysis_types();
  public:
  ::unhinged::audio::v1::AnalysisType analysis_types(int index) const;
  void set_analysis_types(int index, ::unhinged::audio::v1::AnalysisType value);
  void add_analysis_types(::unhinged::audio::v1::AnalysisType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& analysis_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_analysis_types();

  // .unhinged.common.v1.Attachment audio_file = 1;
  bool has_audio_file() const;
  private:
  bool _internal_has_audio_file() const;
  public:
  void clear_audio_file();
  const ::unhinged::common::v1::Attachment& audio_file() const;
  PROTOBUF_NODISCARD ::unhinged::common::v1::Attachment* release_audio_file();
  ::unhinged::common::v1::Attachment* mutable_audio_file();
  void set_allocated_audio_file(::unhinged::common::v1::Attachment* audio_file);
  private:
  const ::unhinged::common::v1::Attachment& _internal_audio_file() const;
  ::unhinged::common::v1::Attachment* _internal_mutable_audio_file();
  public:
  void unsafe_arena_set_allocated_audio_file(
      ::unhinged::common::v1::Attachment* audio_file);
  ::unhinged::common::v1::Attachment* unsafe_arena_release_audio_file();

  // @@protoc_insertion_point(class_scope:unhinged.audio.v1.AnalyzeAudioRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> analysis_types_;
    mutable std::atomic<int> _analysis_types_cached_byte_size_;
    ::unhinged::common::v1::Attachment* audio_file_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_2eproto;
};
// -------------------------------------------------------------------

class AnalyzeAudioResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.audio.v1.AnalyzeAudioResponse) */ {
 public:
  inline AnalyzeAudioResponse() : AnalyzeAudioResponse(nullptr) {}
  ~AnalyzeAudioResponse() override;
  explicit PROTOBUF_CONSTEXPR AnalyzeAudioResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AnalyzeAudioResponse(const AnalyzeAudioResponse& from);
  AnalyzeAudioResponse(AnalyzeAudioResponse&& from) noexcept
    : AnalyzeAudioResponse() {
    *this = ::std::move(from);
  }

  inline AnalyzeAudioResponse& operator=(const AnalyzeAudioResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnalyzeAudioResponse& operator=(AnalyzeAudioResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnalyzeAudioResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AnalyzeAudioResponse* internal_default_instance() {
    return reinterpret_cast<const AnalyzeAudioResponse*>(
               &_AnalyzeAudioResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(AnalyzeAudioResponse& a, AnalyzeAudioResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AnalyzeAudioResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnalyzeAudioResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnalyzeAudioResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AnalyzeAudioResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AnalyzeAudioResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AnalyzeAudioResponse& from) {
    AnalyzeAudioResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnalyzeAudioResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.audio.v1.AnalyzeAudioResponse";
  }
  protected:
  explicit AnalyzeAudioResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 1,
    kAnalysisFieldNumber = 2,
    kUsageFieldNumber = 3,
  };
  // .unhinged.common.v1.StandardResponse response = 1;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::unhinged::common::v1::StandardResponse& response() const;
  PROTOBUF_NODISCARD ::unhinged::common::v1::StandardResponse* release_response();
  ::unhinged::common::v1::StandardResponse* mutable_response();
  void set_allocated_response(::unhinged::common::v1::StandardResponse* response);
  private:
  const ::unhinged::common::v1::StandardResponse& _internal_response() const;
  ::unhinged::common::v1::StandardResponse* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::unhinged::common::v1::StandardResponse* response);
  ::unhinged::common::v1::StandardResponse* unsafe_arena_release_response();

  // .unhinged.audio.v1.AudioAnalysis analysis = 2;
  bool has_analysis() const;
  private:
  bool _internal_has_analysis() const;
  public:
  void clear_analysis();
  const ::unhinged::audio::v1::AudioAnalysis& analysis() const;
  PROTOBUF_NODISCARD ::unhinged::audio::v1::AudioAnalysis* release_analysis();
  ::unhinged::audio::v1::AudioAnalysis* mutable_analysis();
  void set_allocated_analysis(::unhinged::audio::v1::AudioAnalysis* analysis);
  private:
  const ::unhinged::audio::v1::AudioAnalysis& _internal_analysis() const;
  ::unhinged::audio::v1::AudioAnalysis* _internal_mutable_analysis();
  public:
  void unsafe_arena_set_allocated_analysis(
      ::unhinged::audio::v1::AudioAnalysis* analysis);
  ::unhinged::audio::v1::AudioAnalysis* unsafe_arena_release_analysis();

  // .unhinged.common.v1.AudioUsage usage = 3;
  bool has_usage() const;
  private:
  bool _internal_has_usage() const;
  public:
  void clear_usage();
  const ::unhinged::common::v1::AudioUsage& usage() const;
  PROTOBUF_NODISCARD ::unhinged::common::v1::AudioUsage* release_usage();
  ::unhinged::common::v1::AudioUsage* mutable_usage();
  void set_allocated_usage(::unhinged::common::v1::AudioUsage* usage);
  private:
  const ::unhinged::common::v1::AudioUsage& _internal_usage() const;
  ::unhinged::common::v1::AudioUsage* _internal_mutable_usage();
  public:
  void unsafe_arena_set_allocated_usage(
      ::unhinged::common::v1::AudioUsage* usage);
  ::unhinged::common::v1::AudioUsage* unsafe_arena_release_usage();

  // @@protoc_insertion_point(class_scope:unhinged.audio.v1.AnalyzeAudioResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::unhinged::common::v1::StandardResponse* response_;
    ::unhinged::audio::v1::AudioAnalysis* analysis_;
    ::unhinged::common::v1::AudioUsage* usage_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_2eproto;
};
// -------------------------------------------------------------------

class AudioAnalysis final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.audio.v1.AudioAnalysis) */ {
 public:
  inline AudioAnalysis() : AudioAnalysis(nullptr) {}
  ~AudioAnalysis() override;
  explicit PROTOBUF_CONSTEXPR AudioAnalysis(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AudioAnalysis(const AudioAnalysis& from);
  AudioAnalysis(AudioAnalysis&& from) noexcept
    : AudioAnalysis() {
    *this = ::std::move(from);
  }

  inline AudioAnalysis& operator=(const AudioAnalysis& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioAnalysis& operator=(AudioAnalysis&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AudioAnalysis& default_instance() {
    return *internal_default_instance();
  }
  static inline const AudioAnalysis* internal_default_instance() {
    return reinterpret_cast<const AudioAnalysis*>(
               &_AudioAnalysis_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(AudioAnalysis& a, AudioAnalysis& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioAnalysis* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioAnalysis* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AudioAnalysis* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AudioAnalysis>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AudioAnalysis& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AudioAnalysis& from) {
    AudioAnalysis::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AudioAnalysis* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.audio.v1.AudioAnalysis";
  }
  protected:
  explicit AudioAnalysis(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpeechSegmentsFieldNumber = 3,
    kDetectedLanguagesFieldNumber = 4,
    kSpeakerSegmentsFieldNumber = 6,
    kEmotionSegmentsFieldNumber = 7,
    kQualityMetricsFieldNumber = 8,
    kContainsSpeechFieldNumber = 1,
    kSpeechPercentageFieldNumber = 2,
    kSpeakerCountFieldNumber = 5,
  };
  // repeated .unhinged.audio.v1.SpeechSegment speech_segments = 3;
  int speech_segments_size() const;
  private:
  int _internal_speech_segments_size() const;
  public:
  void clear_speech_segments();
  ::unhinged::audio::v1::SpeechSegment* mutable_speech_segments(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::audio::v1::SpeechSegment >*
      mutable_speech_segments();
  private:
  const ::unhinged::audio::v1::SpeechSegment& _internal_speech_segments(int index) const;
  ::unhinged::audio::v1::SpeechSegment* _internal_add_speech_segments();
  public:
  const ::unhinged::audio::v1::SpeechSegment& speech_segments(int index) const;
  ::unhinged::audio::v1::SpeechSegment* add_speech_segments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::audio::v1::SpeechSegment >&
      speech_segments() const;

  // repeated .unhinged.audio.v1.LanguageDetection detected_languages = 4;
  int detected_languages_size() const;
  private:
  int _internal_detected_languages_size() const;
  public:
  void clear_detected_languages();
  ::unhinged::audio::v1::LanguageDetection* mutable_detected_languages(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::audio::v1::LanguageDetection >*
      mutable_detected_languages();
  private:
  const ::unhinged::audio::v1::LanguageDetection& _internal_detected_languages(int index) const;
  ::unhinged::audio::v1::LanguageDetection* _internal_add_detected_languages();
  public:
  const ::unhinged::audio::v1::LanguageDetection& detected_languages(int index) const;
  ::unhinged::audio::v1::LanguageDetection* add_detected_languages();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::audio::v1::LanguageDetection >&
      detected_languages() const;

  // repeated .unhinged.audio.v1.SpeakerSegment speaker_segments = 6;
  int speaker_segments_size() const;
  private:
  int _internal_speaker_segments_size() const;
  public:
  void clear_speaker_segments();
  ::unhinged::audio::v1::SpeakerSegment* mutable_speaker_segments(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::audio::v1::SpeakerSegment >*
      mutable_speaker_segments();
  private:
  const ::unhinged::audio::v1::SpeakerSegment& _internal_speaker_segments(int index) const;
  ::unhinged::audio::v1::SpeakerSegment* _internal_add_speaker_segments();
  public:
  const ::unhinged::audio::v1::SpeakerSegment& speaker_segments(int index) const;
  ::unhinged::audio::v1::SpeakerSegment* add_speaker_segments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::audio::v1::SpeakerSegment >&
      speaker_segments() const;

  // repeated .unhinged.audio.v1.EmotionSegment emotion_segments = 7;
  int emotion_segments_size() const;
  private:
  int _internal_emotion_segments_size() const;
  public:
  void clear_emotion_segments();
  ::unhinged::audio::v1::EmotionSegment* mutable_emotion_segments(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::audio::v1::EmotionSegment >*
      mutable_emotion_segments();
  private:
  const ::unhinged::audio::v1::EmotionSegment& _internal_emotion_segments(int index) const;
  ::unhinged::audio::v1::EmotionSegment* _internal_add_emotion_segments();
  public:
  const ::unhinged::audio::v1::EmotionSegment& emotion_segments(int index) const;
  ::unhinged::audio::v1::EmotionSegment* add_emotion_segments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::audio::v1::EmotionSegment >&
      emotion_segments() const;

  // .unhinged.audio.v1.AudioQualityMetrics quality_metrics = 8;
  bool has_quality_metrics() const;
  private:
  bool _internal_has_quality_metrics() const;
  public:
  void clear_quality_metrics();
  const ::unhinged::audio::v1::AudioQualityMetrics& quality_metrics() const;
  PROTOBUF_NODISCARD ::unhinged::audio::v1::AudioQualityMetrics* release_quality_metrics();
  ::unhinged::audio::v1::AudioQualityMetrics* mutable_quality_metrics();
  void set_allocated_quality_metrics(::unhinged::audio::v1::AudioQualityMetrics* quality_metrics);
  private:
  const ::unhinged::audio::v1::AudioQualityMetrics& _internal_quality_metrics() const;
  ::unhinged::audio::v1::AudioQualityMetrics* _internal_mutable_quality_metrics();
  public:
  void unsafe_arena_set_allocated_quality_metrics(
      ::unhinged::audio::v1::AudioQualityMetrics* quality_metrics);
  ::unhinged::audio::v1::AudioQualityMetrics* unsafe_arena_release_quality_metrics();

  // bool contains_speech = 1;
  void clear_contains_speech();
  bool contains_speech() const;
  void set_contains_speech(bool value);
  private:
  bool _internal_contains_speech() const;
  void _internal_set_contains_speech(bool value);
  public:

  // float speech_percentage = 2;
  void clear_speech_percentage();
  float speech_percentage() const;
  void set_speech_percentage(float value);
  private:
  float _internal_speech_percentage() const;
  void _internal_set_speech_percentage(float value);
  public:

  // int32 speaker_count = 5;
  void clear_speaker_count();
  int32_t speaker_count() const;
  void set_speaker_count(int32_t value);
  private:
  int32_t _internal_speaker_count() const;
  void _internal_set_speaker_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.audio.v1.AudioAnalysis)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::audio::v1::SpeechSegment > speech_segments_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::audio::v1::LanguageDetection > detected_languages_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::audio::v1::SpeakerSegment > speaker_segments_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::audio::v1::EmotionSegment > emotion_segments_;
    ::unhinged::audio::v1::AudioQualityMetrics* quality_metrics_;
    bool contains_speech_;
    float speech_percentage_;
    int32_t speaker_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_2eproto;
};
// -------------------------------------------------------------------

class SpeechSegment final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.audio.v1.SpeechSegment) */ {
 public:
  inline SpeechSegment() : SpeechSegment(nullptr) {}
  ~SpeechSegment() override;
  explicit PROTOBUF_CONSTEXPR SpeechSegment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpeechSegment(const SpeechSegment& from);
  SpeechSegment(SpeechSegment&& from) noexcept
    : SpeechSegment() {
    *this = ::std::move(from);
  }

  inline SpeechSegment& operator=(const SpeechSegment& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpeechSegment& operator=(SpeechSegment&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpeechSegment& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpeechSegment* internal_default_instance() {
    return reinterpret_cast<const SpeechSegment*>(
               &_SpeechSegment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(SpeechSegment& a, SpeechSegment& b) {
    a.Swap(&b);
  }
  inline void Swap(SpeechSegment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpeechSegment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpeechSegment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SpeechSegment>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SpeechSegment& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SpeechSegment& from) {
    SpeechSegment::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpeechSegment* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.audio.v1.SpeechSegment";
  }
  protected:
  explicit SpeechSegment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartTimeFieldNumber = 1,
    kEndTimeFieldNumber = 2,
    kConfidenceFieldNumber = 3,
  };
  // float start_time = 1;
  void clear_start_time();
  float start_time() const;
  void set_start_time(float value);
  private:
  float _internal_start_time() const;
  void _internal_set_start_time(float value);
  public:

  // float end_time = 2;
  void clear_end_time();
  float end_time() const;
  void set_end_time(float value);
  private:
  float _internal_end_time() const;
  void _internal_set_end_time(float value);
  public:

  // float confidence = 3;
  void clear_confidence();
  float confidence() const;
  void set_confidence(float value);
  private:
  float _internal_confidence() const;
  void _internal_set_confidence(float value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.audio.v1.SpeechSegment)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float start_time_;
    float end_time_;
    float confidence_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_2eproto;
};
// -------------------------------------------------------------------

class LanguageDetection final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.audio.v1.LanguageDetection) */ {
 public:
  inline LanguageDetection() : LanguageDetection(nullptr) {}
  ~LanguageDetection() override;
  explicit PROTOBUF_CONSTEXPR LanguageDetection(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LanguageDetection(const LanguageDetection& from);
  LanguageDetection(LanguageDetection&& from) noexcept
    : LanguageDetection() {
    *this = ::std::move(from);
  }

  inline LanguageDetection& operator=(const LanguageDetection& from) {
    CopyFrom(from);
    return *this;
  }
  inline LanguageDetection& operator=(LanguageDetection&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LanguageDetection& default_instance() {
    return *internal_default_instance();
  }
  static inline const LanguageDetection* internal_default_instance() {
    return reinterpret_cast<const LanguageDetection*>(
               &_LanguageDetection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(LanguageDetection& a, LanguageDetection& b) {
    a.Swap(&b);
  }
  inline void Swap(LanguageDetection* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LanguageDetection* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LanguageDetection* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LanguageDetection>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LanguageDetection& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LanguageDetection& from) {
    LanguageDetection::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LanguageDetection* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.audio.v1.LanguageDetection";
  }
  protected:
  explicit LanguageDetection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLanguageFieldNumber = 1,
    kLanguageCodeFieldNumber = 2,
    kConfidenceFieldNumber = 3,
  };
  // string language = 1;
  void clear_language();
  const std::string& language() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_language(ArgT0&& arg0, ArgT... args);
  std::string* mutable_language();
  PROTOBUF_NODISCARD std::string* release_language();
  void set_allocated_language(std::string* language);
  private:
  const std::string& _internal_language() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language(const std::string& value);
  std::string* _internal_mutable_language();
  public:

  // string language_code = 2;
  void clear_language_code();
  const std::string& language_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_language_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_language_code();
  PROTOBUF_NODISCARD std::string* release_language_code();
  void set_allocated_language_code(std::string* language_code);
  private:
  const std::string& _internal_language_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language_code(const std::string& value);
  std::string* _internal_mutable_language_code();
  public:

  // float confidence = 3;
  void clear_confidence();
  float confidence() const;
  void set_confidence(float value);
  private:
  float _internal_confidence() const;
  void _internal_set_confidence(float value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.audio.v1.LanguageDetection)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_code_;
    float confidence_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_2eproto;
};
// -------------------------------------------------------------------

class SpeakerSegment final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.audio.v1.SpeakerSegment) */ {
 public:
  inline SpeakerSegment() : SpeakerSegment(nullptr) {}
  ~SpeakerSegment() override;
  explicit PROTOBUF_CONSTEXPR SpeakerSegment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpeakerSegment(const SpeakerSegment& from);
  SpeakerSegment(SpeakerSegment&& from) noexcept
    : SpeakerSegment() {
    *this = ::std::move(from);
  }

  inline SpeakerSegment& operator=(const SpeakerSegment& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpeakerSegment& operator=(SpeakerSegment&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpeakerSegment& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpeakerSegment* internal_default_instance() {
    return reinterpret_cast<const SpeakerSegment*>(
               &_SpeakerSegment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(SpeakerSegment& a, SpeakerSegment& b) {
    a.Swap(&b);
  }
  inline void Swap(SpeakerSegment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpeakerSegment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpeakerSegment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SpeakerSegment>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SpeakerSegment& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SpeakerSegment& from) {
    SpeakerSegment::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpeakerSegment* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.audio.v1.SpeakerSegment";
  }
  protected:
  explicit SpeakerSegment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpeakerIdFieldNumber = 1,
    kStartTimeFieldNumber = 2,
    kEndTimeFieldNumber = 3,
    kConfidenceFieldNumber = 4,
  };
  // string speaker_id = 1;
  void clear_speaker_id();
  const std::string& speaker_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_speaker_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_speaker_id();
  PROTOBUF_NODISCARD std::string* release_speaker_id();
  void set_allocated_speaker_id(std::string* speaker_id);
  private:
  const std::string& _internal_speaker_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_speaker_id(const std::string& value);
  std::string* _internal_mutable_speaker_id();
  public:

  // float start_time = 2;
  void clear_start_time();
  float start_time() const;
  void set_start_time(float value);
  private:
  float _internal_start_time() const;
  void _internal_set_start_time(float value);
  public:

  // float end_time = 3;
  void clear_end_time();
  float end_time() const;
  void set_end_time(float value);
  private:
  float _internal_end_time() const;
  void _internal_set_end_time(float value);
  public:

  // float confidence = 4;
  void clear_confidence();
  float confidence() const;
  void set_confidence(float value);
  private:
  float _internal_confidence() const;
  void _internal_set_confidence(float value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.audio.v1.SpeakerSegment)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr speaker_id_;
    float start_time_;
    float end_time_;
    float confidence_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_2eproto;
};
// -------------------------------------------------------------------

class EmotionSegment final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.audio.v1.EmotionSegment) */ {
 public:
  inline EmotionSegment() : EmotionSegment(nullptr) {}
  ~EmotionSegment() override;
  explicit PROTOBUF_CONSTEXPR EmotionSegment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EmotionSegment(const EmotionSegment& from);
  EmotionSegment(EmotionSegment&& from) noexcept
    : EmotionSegment() {
    *this = ::std::move(from);
  }

  inline EmotionSegment& operator=(const EmotionSegment& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmotionSegment& operator=(EmotionSegment&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EmotionSegment& default_instance() {
    return *internal_default_instance();
  }
  static inline const EmotionSegment* internal_default_instance() {
    return reinterpret_cast<const EmotionSegment*>(
               &_EmotionSegment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(EmotionSegment& a, EmotionSegment& b) {
    a.Swap(&b);
  }
  inline void Swap(EmotionSegment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EmotionSegment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EmotionSegment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EmotionSegment>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EmotionSegment& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EmotionSegment& from) {
    EmotionSegment::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EmotionSegment* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.audio.v1.EmotionSegment";
  }
  protected:
  explicit EmotionSegment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEmotionFieldNumber = 1,
    kStartTimeFieldNumber = 2,
    kEndTimeFieldNumber = 3,
    kConfidenceFieldNumber = 4,
    kIntensityFieldNumber = 5,
  };
  // string emotion = 1;
  void clear_emotion();
  const std::string& emotion() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_emotion(ArgT0&& arg0, ArgT... args);
  std::string* mutable_emotion();
  PROTOBUF_NODISCARD std::string* release_emotion();
  void set_allocated_emotion(std::string* emotion);
  private:
  const std::string& _internal_emotion() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_emotion(const std::string& value);
  std::string* _internal_mutable_emotion();
  public:

  // float start_time = 2;
  void clear_start_time();
  float start_time() const;
  void set_start_time(float value);
  private:
  float _internal_start_time() const;
  void _internal_set_start_time(float value);
  public:

  // float end_time = 3;
  void clear_end_time();
  float end_time() const;
  void set_end_time(float value);
  private:
  float _internal_end_time() const;
  void _internal_set_end_time(float value);
  public:

  // float confidence = 4;
  void clear_confidence();
  float confidence() const;
  void set_confidence(float value);
  private:
  float _internal_confidence() const;
  void _internal_set_confidence(float value);
  public:

  // float intensity = 5;
  void clear_intensity();
  float intensity() const;
  void set_intensity(float value);
  private:
  float _internal_intensity() const;
  void _internal_set_intensity(float value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.audio.v1.EmotionSegment)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr emotion_;
    float start_time_;
    float end_time_;
    float confidence_;
    float intensity_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_2eproto;
};
// -------------------------------------------------------------------

class AudioQualityMetrics final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.audio.v1.AudioQualityMetrics) */ {
 public:
  inline AudioQualityMetrics() : AudioQualityMetrics(nullptr) {}
  ~AudioQualityMetrics() override;
  explicit PROTOBUF_CONSTEXPR AudioQualityMetrics(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AudioQualityMetrics(const AudioQualityMetrics& from);
  AudioQualityMetrics(AudioQualityMetrics&& from) noexcept
    : AudioQualityMetrics() {
    *this = ::std::move(from);
  }

  inline AudioQualityMetrics& operator=(const AudioQualityMetrics& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioQualityMetrics& operator=(AudioQualityMetrics&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AudioQualityMetrics& default_instance() {
    return *internal_default_instance();
  }
  static inline const AudioQualityMetrics* internal_default_instance() {
    return reinterpret_cast<const AudioQualityMetrics*>(
               &_AudioQualityMetrics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(AudioQualityMetrics& a, AudioQualityMetrics& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioQualityMetrics* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioQualityMetrics* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AudioQualityMetrics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AudioQualityMetrics>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AudioQualityMetrics& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AudioQualityMetrics& from) {
    AudioQualityMetrics::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AudioQualityMetrics* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.audio.v1.AudioQualityMetrics";
  }
  protected:
  explicit AudioQualityMetrics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignalToNoiseRatioFieldNumber = 1,
    kDynamicRangeFieldNumber = 2,
    kHasClippingFieldNumber = 3,
    kHasBackgroundNoiseFieldNumber = 4,
    kOverallQualityScoreFieldNumber = 5,
  };
  // float signal_to_noise_ratio = 1;
  void clear_signal_to_noise_ratio();
  float signal_to_noise_ratio() const;
  void set_signal_to_noise_ratio(float value);
  private:
  float _internal_signal_to_noise_ratio() const;
  void _internal_set_signal_to_noise_ratio(float value);
  public:

  // float dynamic_range = 2;
  void clear_dynamic_range();
  float dynamic_range() const;
  void set_dynamic_range(float value);
  private:
  float _internal_dynamic_range() const;
  void _internal_set_dynamic_range(float value);
  public:

  // bool has_clipping = 3;
  void clear_has_clipping();
  bool has_clipping() const;
  void set_has_clipping(bool value);
  private:
  bool _internal_has_clipping() const;
  void _internal_set_has_clipping(bool value);
  public:

  // bool has_background_noise = 4;
  void clear_has_background_noise();
  bool has_background_noise() const;
  void set_has_background_noise(bool value);
  private:
  bool _internal_has_background_noise() const;
  void _internal_set_has_background_noise(bool value);
  public:

  // float overall_quality_score = 5;
  void clear_overall_quality_score();
  float overall_quality_score() const;
  void set_overall_quality_score(float value);
  private:
  float _internal_overall_quality_score() const;
  void _internal_set_overall_quality_score(float value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.audio.v1.AudioQualityMetrics)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float signal_to_noise_ratio_;
    float dynamic_range_;
    bool has_clipping_;
    bool has_background_noise_;
    float overall_quality_score_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TTSRequest

// string text = 1;
inline void TTSRequest::clear_text() {
  _impl_.text_.ClearToEmpty();
}
inline const std::string& TTSRequest::text() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.TTSRequest.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TTSRequest::set_text(ArgT0&& arg0, ArgT... args) {
 
 _impl_.text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.TTSRequest.text)
}
inline std::string* TTSRequest::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.TTSRequest.text)
  return _s;
}
inline const std::string& TTSRequest::_internal_text() const {
  return _impl_.text_.Get();
}
inline void TTSRequest::_internal_set_text(const std::string& value) {
  
  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* TTSRequest::_internal_mutable_text() {
  
  return _impl_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* TTSRequest::release_text() {
  // @@protoc_insertion_point(field_release:unhinged.audio.v1.TTSRequest.text)
  return _impl_.text_.Release();
}
inline void TTSRequest::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  _impl_.text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.audio.v1.TTSRequest.text)
}

// string voice_id = 2;
inline void TTSRequest::clear_voice_id() {
  _impl_.voice_id_.ClearToEmpty();
}
inline const std::string& TTSRequest::voice_id() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.TTSRequest.voice_id)
  return _internal_voice_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TTSRequest::set_voice_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.voice_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.TTSRequest.voice_id)
}
inline std::string* TTSRequest::mutable_voice_id() {
  std::string* _s = _internal_mutable_voice_id();
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.TTSRequest.voice_id)
  return _s;
}
inline const std::string& TTSRequest::_internal_voice_id() const {
  return _impl_.voice_id_.Get();
}
inline void TTSRequest::_internal_set_voice_id(const std::string& value) {
  
  _impl_.voice_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TTSRequest::_internal_mutable_voice_id() {
  
  return _impl_.voice_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TTSRequest::release_voice_id() {
  // @@protoc_insertion_point(field_release:unhinged.audio.v1.TTSRequest.voice_id)
  return _impl_.voice_id_.Release();
}
inline void TTSRequest::set_allocated_voice_id(std::string* voice_id) {
  if (voice_id != nullptr) {
    
  } else {
    
  }
  _impl_.voice_id_.SetAllocated(voice_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.voice_id_.IsDefault()) {
    _impl_.voice_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.audio.v1.TTSRequest.voice_id)
}

// .unhinged.audio.v1.AudioOptions options = 3;
inline bool TTSRequest::_internal_has_options() const {
  return this != internal_default_instance() && _impl_.options_ != nullptr;
}
inline bool TTSRequest::has_options() const {
  return _internal_has_options();
}
inline void TTSRequest::clear_options() {
  if (GetArenaForAllocation() == nullptr && _impl_.options_ != nullptr) {
    delete _impl_.options_;
  }
  _impl_.options_ = nullptr;
}
inline const ::unhinged::audio::v1::AudioOptions& TTSRequest::_internal_options() const {
  const ::unhinged::audio::v1::AudioOptions* p = _impl_.options_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::audio::v1::AudioOptions&>(
      ::unhinged::audio::v1::_AudioOptions_default_instance_);
}
inline const ::unhinged::audio::v1::AudioOptions& TTSRequest::options() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.TTSRequest.options)
  return _internal_options();
}
inline void TTSRequest::unsafe_arena_set_allocated_options(
    ::unhinged::audio::v1::AudioOptions* options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.options_);
  }
  _impl_.options_ = options;
  if (options) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.audio.v1.TTSRequest.options)
}
inline ::unhinged::audio::v1::AudioOptions* TTSRequest::release_options() {
  
  ::unhinged::audio::v1::AudioOptions* temp = _impl_.options_;
  _impl_.options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::audio::v1::AudioOptions* TTSRequest::unsafe_arena_release_options() {
  // @@protoc_insertion_point(field_release:unhinged.audio.v1.TTSRequest.options)
  
  ::unhinged::audio::v1::AudioOptions* temp = _impl_.options_;
  _impl_.options_ = nullptr;
  return temp;
}
inline ::unhinged::audio::v1::AudioOptions* TTSRequest::_internal_mutable_options() {
  
  if (_impl_.options_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::audio::v1::AudioOptions>(GetArenaForAllocation());
    _impl_.options_ = p;
  }
  return _impl_.options_;
}
inline ::unhinged::audio::v1::AudioOptions* TTSRequest::mutable_options() {
  ::unhinged::audio::v1::AudioOptions* _msg = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.TTSRequest.options)
  return _msg;
}
inline void TTSRequest::set_allocated_options(::unhinged::audio::v1::AudioOptions* options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.options_;
  }
  if (options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(options);
    if (message_arena != submessage_arena) {
      options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.options_ = options;
  // @@protoc_insertion_point(field_set_allocated:unhinged.audio.v1.TTSRequest.options)
}

// .unhinged.audio.v1.AudioFormat output_format = 4;
inline void TTSRequest::clear_output_format() {
  _impl_.output_format_ = 0;
}
inline ::unhinged::audio::v1::AudioFormat TTSRequest::_internal_output_format() const {
  return static_cast< ::unhinged::audio::v1::AudioFormat >(_impl_.output_format_);
}
inline ::unhinged::audio::v1::AudioFormat TTSRequest::output_format() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.TTSRequest.output_format)
  return _internal_output_format();
}
inline void TTSRequest::_internal_set_output_format(::unhinged::audio::v1::AudioFormat value) {
  
  _impl_.output_format_ = value;
}
inline void TTSRequest::set_output_format(::unhinged::audio::v1::AudioFormat value) {
  _internal_set_output_format(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.TTSRequest.output_format)
}

// int32 sample_rate = 5;
inline void TTSRequest::clear_sample_rate() {
  _impl_.sample_rate_ = 0;
}
inline int32_t TTSRequest::_internal_sample_rate() const {
  return _impl_.sample_rate_;
}
inline int32_t TTSRequest::sample_rate() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.TTSRequest.sample_rate)
  return _internal_sample_rate();
}
inline void TTSRequest::_internal_set_sample_rate(int32_t value) {
  
  _impl_.sample_rate_ = value;
}
inline void TTSRequest::set_sample_rate(int32_t value) {
  _internal_set_sample_rate(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.TTSRequest.sample_rate)
}

// int32 channels = 6;
inline void TTSRequest::clear_channels() {
  _impl_.channels_ = 0;
}
inline int32_t TTSRequest::_internal_channels() const {
  return _impl_.channels_;
}
inline int32_t TTSRequest::channels() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.TTSRequest.channels)
  return _internal_channels();
}
inline void TTSRequest::_internal_set_channels(int32_t value) {
  
  _impl_.channels_ = value;
}
inline void TTSRequest::set_channels(int32_t value) {
  _internal_set_channels(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.TTSRequest.channels)
}

// bool enable_ssml = 7;
inline void TTSRequest::clear_enable_ssml() {
  _impl_.enable_ssml_ = false;
}
inline bool TTSRequest::_internal_enable_ssml() const {
  return _impl_.enable_ssml_;
}
inline bool TTSRequest::enable_ssml() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.TTSRequest.enable_ssml)
  return _internal_enable_ssml();
}
inline void TTSRequest::_internal_set_enable_ssml(bool value) {
  
  _impl_.enable_ssml_ = value;
}
inline void TTSRequest::set_enable_ssml(bool value) {
  _internal_set_enable_ssml(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.TTSRequest.enable_ssml)
}

// repeated .unhinged.audio.v1.AudioEffect effects = 8;
inline int TTSRequest::_internal_effects_size() const {
  return _impl_.effects_.size();
}
inline int TTSRequest::effects_size() const {
  return _internal_effects_size();
}
inline void TTSRequest::clear_effects() {
  _impl_.effects_.Clear();
}
inline ::unhinged::audio::v1::AudioEffect* TTSRequest::mutable_effects(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.TTSRequest.effects)
  return _impl_.effects_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::audio::v1::AudioEffect >*
TTSRequest::mutable_effects() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.audio.v1.TTSRequest.effects)
  return &_impl_.effects_;
}
inline const ::unhinged::audio::v1::AudioEffect& TTSRequest::_internal_effects(int index) const {
  return _impl_.effects_.Get(index);
}
inline const ::unhinged::audio::v1::AudioEffect& TTSRequest::effects(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.TTSRequest.effects)
  return _internal_effects(index);
}
inline ::unhinged::audio::v1::AudioEffect* TTSRequest::_internal_add_effects() {
  return _impl_.effects_.Add();
}
inline ::unhinged::audio::v1::AudioEffect* TTSRequest::add_effects() {
  ::unhinged::audio::v1::AudioEffect* _add = _internal_add_effects();
  // @@protoc_insertion_point(field_add:unhinged.audio.v1.TTSRequest.effects)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::audio::v1::AudioEffect >&
TTSRequest::effects() const {
  // @@protoc_insertion_point(field_list:unhinged.audio.v1.TTSRequest.effects)
  return _impl_.effects_;
}

// -------------------------------------------------------------------

// STTResponse

// .unhinged.common.v1.StandardResponse response = 1;
inline bool STTResponse::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool STTResponse::has_response() const {
  return _internal_has_response();
}
inline const ::unhinged::common::v1::StandardResponse& STTResponse::_internal_response() const {
  const ::unhinged::common::v1::StandardResponse* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::common::v1::StandardResponse&>(
      ::unhinged::common::v1::_StandardResponse_default_instance_);
}
inline const ::unhinged::common::v1::StandardResponse& STTResponse::response() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.STTResponse.response)
  return _internal_response();
}
inline void STTResponse::unsafe_arena_set_allocated_response(
    ::unhinged::common::v1::StandardResponse* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.audio.v1.STTResponse.response)
}
inline ::unhinged::common::v1::StandardResponse* STTResponse::release_response() {
  
  ::unhinged::common::v1::StandardResponse* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::common::v1::StandardResponse* STTResponse::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:unhinged.audio.v1.STTResponse.response)
  
  ::unhinged::common::v1::StandardResponse* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::unhinged::common::v1::StandardResponse* STTResponse::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::common::v1::StandardResponse>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::unhinged::common::v1::StandardResponse* STTResponse::mutable_response() {
  ::unhinged::common::v1::StandardResponse* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.STTResponse.response)
  return _msg;
}
inline void STTResponse::set_allocated_response(::unhinged::common::v1::StandardResponse* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:unhinged.audio.v1.STTResponse.response)
}

// string transcript = 2;
inline void STTResponse::clear_transcript() {
  _impl_.transcript_.ClearToEmpty();
}
inline const std::string& STTResponse::transcript() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.STTResponse.transcript)
  return _internal_transcript();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void STTResponse::set_transcript(ArgT0&& arg0, ArgT... args) {
 
 _impl_.transcript_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.STTResponse.transcript)
}
inline std::string* STTResponse::mutable_transcript() {
  std::string* _s = _internal_mutable_transcript();
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.STTResponse.transcript)
  return _s;
}
inline const std::string& STTResponse::_internal_transcript() const {
  return _impl_.transcript_.Get();
}
inline void STTResponse::_internal_set_transcript(const std::string& value) {
  
  _impl_.transcript_.Set(value, GetArenaForAllocation());
}
inline std::string* STTResponse::_internal_mutable_transcript() {
  
  return _impl_.transcript_.Mutable(GetArenaForAllocation());
}
inline std::string* STTResponse::release_transcript() {
  // @@protoc_insertion_point(field_release:unhinged.audio.v1.STTResponse.transcript)
  return _impl_.transcript_.Release();
}
inline void STTResponse::set_allocated_transcript(std::string* transcript) {
  if (transcript != nullptr) {
    
  } else {
    
  }
  _impl_.transcript_.SetAllocated(transcript, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.transcript_.IsDefault()) {
    _impl_.transcript_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.audio.v1.STTResponse.transcript)
}

// float confidence = 3;
inline void STTResponse::clear_confidence() {
  _impl_.confidence_ = 0;
}
inline float STTResponse::_internal_confidence() const {
  return _impl_.confidence_;
}
inline float STTResponse::confidence() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.STTResponse.confidence)
  return _internal_confidence();
}
inline void STTResponse::_internal_set_confidence(float value) {
  
  _impl_.confidence_ = value;
}
inline void STTResponse::set_confidence(float value) {
  _internal_set_confidence(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.STTResponse.confidence)
}

// repeated .unhinged.audio.v1.TranscriptSegment segments = 4;
inline int STTResponse::_internal_segments_size() const {
  return _impl_.segments_.size();
}
inline int STTResponse::segments_size() const {
  return _internal_segments_size();
}
inline void STTResponse::clear_segments() {
  _impl_.segments_.Clear();
}
inline ::unhinged::audio::v1::TranscriptSegment* STTResponse::mutable_segments(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.STTResponse.segments)
  return _impl_.segments_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::audio::v1::TranscriptSegment >*
STTResponse::mutable_segments() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.audio.v1.STTResponse.segments)
  return &_impl_.segments_;
}
inline const ::unhinged::audio::v1::TranscriptSegment& STTResponse::_internal_segments(int index) const {
  return _impl_.segments_.Get(index);
}
inline const ::unhinged::audio::v1::TranscriptSegment& STTResponse::segments(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.STTResponse.segments)
  return _internal_segments(index);
}
inline ::unhinged::audio::v1::TranscriptSegment* STTResponse::_internal_add_segments() {
  return _impl_.segments_.Add();
}
inline ::unhinged::audio::v1::TranscriptSegment* STTResponse::add_segments() {
  ::unhinged::audio::v1::TranscriptSegment* _add = _internal_add_segments();
  // @@protoc_insertion_point(field_add:unhinged.audio.v1.STTResponse.segments)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::audio::v1::TranscriptSegment >&
STTResponse::segments() const {
  // @@protoc_insertion_point(field_list:unhinged.audio.v1.STTResponse.segments)
  return _impl_.segments_;
}

// .unhinged.common.v1.AudioUsage usage = 5;
inline bool STTResponse::_internal_has_usage() const {
  return this != internal_default_instance() && _impl_.usage_ != nullptr;
}
inline bool STTResponse::has_usage() const {
  return _internal_has_usage();
}
inline const ::unhinged::common::v1::AudioUsage& STTResponse::_internal_usage() const {
  const ::unhinged::common::v1::AudioUsage* p = _impl_.usage_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::common::v1::AudioUsage&>(
      ::unhinged::common::v1::_AudioUsage_default_instance_);
}
inline const ::unhinged::common::v1::AudioUsage& STTResponse::usage() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.STTResponse.usage)
  return _internal_usage();
}
inline void STTResponse::unsafe_arena_set_allocated_usage(
    ::unhinged::common::v1::AudioUsage* usage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.usage_);
  }
  _impl_.usage_ = usage;
  if (usage) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.audio.v1.STTResponse.usage)
}
inline ::unhinged::common::v1::AudioUsage* STTResponse::release_usage() {
  
  ::unhinged::common::v1::AudioUsage* temp = _impl_.usage_;
  _impl_.usage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::common::v1::AudioUsage* STTResponse::unsafe_arena_release_usage() {
  // @@protoc_insertion_point(field_release:unhinged.audio.v1.STTResponse.usage)
  
  ::unhinged::common::v1::AudioUsage* temp = _impl_.usage_;
  _impl_.usage_ = nullptr;
  return temp;
}
inline ::unhinged::common::v1::AudioUsage* STTResponse::_internal_mutable_usage() {
  
  if (_impl_.usage_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::common::v1::AudioUsage>(GetArenaForAllocation());
    _impl_.usage_ = p;
  }
  return _impl_.usage_;
}
inline ::unhinged::common::v1::AudioUsage* STTResponse::mutable_usage() {
  ::unhinged::common::v1::AudioUsage* _msg = _internal_mutable_usage();
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.STTResponse.usage)
  return _msg;
}
inline void STTResponse::set_allocated_usage(::unhinged::common::v1::AudioUsage* usage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.usage_);
  }
  if (usage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(usage));
    if (message_arena != submessage_arena) {
      usage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, usage, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.usage_ = usage;
  // @@protoc_insertion_point(field_set_allocated:unhinged.audio.v1.STTResponse.usage)
}

// .unhinged.audio.v1.STTMetadata metadata = 6;
inline bool STTResponse::_internal_has_metadata() const {
  return this != internal_default_instance() && _impl_.metadata_ != nullptr;
}
inline bool STTResponse::has_metadata() const {
  return _internal_has_metadata();
}
inline void STTResponse::clear_metadata() {
  if (GetArenaForAllocation() == nullptr && _impl_.metadata_ != nullptr) {
    delete _impl_.metadata_;
  }
  _impl_.metadata_ = nullptr;
}
inline const ::unhinged::audio::v1::STTMetadata& STTResponse::_internal_metadata() const {
  const ::unhinged::audio::v1::STTMetadata* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::audio::v1::STTMetadata&>(
      ::unhinged::audio::v1::_STTMetadata_default_instance_);
}
inline const ::unhinged::audio::v1::STTMetadata& STTResponse::metadata() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.STTResponse.metadata)
  return _internal_metadata();
}
inline void STTResponse::unsafe_arena_set_allocated_metadata(
    ::unhinged::audio::v1::STTMetadata* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.audio.v1.STTResponse.metadata)
}
inline ::unhinged::audio::v1::STTMetadata* STTResponse::release_metadata() {
  
  ::unhinged::audio::v1::STTMetadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::audio::v1::STTMetadata* STTResponse::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:unhinged.audio.v1.STTResponse.metadata)
  
  ::unhinged::audio::v1::STTMetadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::unhinged::audio::v1::STTMetadata* STTResponse::_internal_mutable_metadata() {
  
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::audio::v1::STTMetadata>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::unhinged::audio::v1::STTMetadata* STTResponse::mutable_metadata() {
  ::unhinged::audio::v1::STTMetadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.STTResponse.metadata)
  return _msg;
}
inline void STTResponse::set_allocated_metadata(::unhinged::audio::v1::STTMetadata* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.metadata_;
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(metadata);
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:unhinged.audio.v1.STTResponse.metadata)
}

// -------------------------------------------------------------------

// AudioOptions

// float speed = 1;
inline void AudioOptions::clear_speed() {
  _impl_.speed_ = 0;
}
inline float AudioOptions::_internal_speed() const {
  return _impl_.speed_;
}
inline float AudioOptions::speed() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.AudioOptions.speed)
  return _internal_speed();
}
inline void AudioOptions::_internal_set_speed(float value) {
  
  _impl_.speed_ = value;
}
inline void AudioOptions::set_speed(float value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.AudioOptions.speed)
}

// float pitch = 2;
inline void AudioOptions::clear_pitch() {
  _impl_.pitch_ = 0;
}
inline float AudioOptions::_internal_pitch() const {
  return _impl_.pitch_;
}
inline float AudioOptions::pitch() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.AudioOptions.pitch)
  return _internal_pitch();
}
inline void AudioOptions::_internal_set_pitch(float value) {
  
  _impl_.pitch_ = value;
}
inline void AudioOptions::set_pitch(float value) {
  _internal_set_pitch(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.AudioOptions.pitch)
}

// float volume = 3;
inline void AudioOptions::clear_volume() {
  _impl_.volume_ = 0;
}
inline float AudioOptions::_internal_volume() const {
  return _impl_.volume_;
}
inline float AudioOptions::volume() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.AudioOptions.volume)
  return _internal_volume();
}
inline void AudioOptions::_internal_set_volume(float value) {
  
  _impl_.volume_ = value;
}
inline void AudioOptions::set_volume(float value) {
  _internal_set_volume(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.AudioOptions.volume)
}

// .unhinged.audio.v1.AudioQuality quality = 4;
inline void AudioOptions::clear_quality() {
  _impl_.quality_ = 0;
}
inline ::unhinged::audio::v1::AudioQuality AudioOptions::_internal_quality() const {
  return static_cast< ::unhinged::audio::v1::AudioQuality >(_impl_.quality_);
}
inline ::unhinged::audio::v1::AudioQuality AudioOptions::quality() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.AudioOptions.quality)
  return _internal_quality();
}
inline void AudioOptions::_internal_set_quality(::unhinged::audio::v1::AudioQuality value) {
  
  _impl_.quality_ = value;
}
inline void AudioOptions::set_quality(::unhinged::audio::v1::AudioQuality value) {
  _internal_set_quality(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.AudioOptions.quality)
}

// bool enable_noise_reduction = 5;
inline void AudioOptions::clear_enable_noise_reduction() {
  _impl_.enable_noise_reduction_ = false;
}
inline bool AudioOptions::_internal_enable_noise_reduction() const {
  return _impl_.enable_noise_reduction_;
}
inline bool AudioOptions::enable_noise_reduction() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.AudioOptions.enable_noise_reduction)
  return _internal_enable_noise_reduction();
}
inline void AudioOptions::_internal_set_enable_noise_reduction(bool value) {
  
  _impl_.enable_noise_reduction_ = value;
}
inline void AudioOptions::set_enable_noise_reduction(bool value) {
  _internal_set_enable_noise_reduction(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.AudioOptions.enable_noise_reduction)
}

// bool enable_echo_cancellation = 6;
inline void AudioOptions::clear_enable_echo_cancellation() {
  _impl_.enable_echo_cancellation_ = false;
}
inline bool AudioOptions::_internal_enable_echo_cancellation() const {
  return _impl_.enable_echo_cancellation_;
}
inline bool AudioOptions::enable_echo_cancellation() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.AudioOptions.enable_echo_cancellation)
  return _internal_enable_echo_cancellation();
}
inline void AudioOptions::_internal_set_enable_echo_cancellation(bool value) {
  
  _impl_.enable_echo_cancellation_ = value;
}
inline void AudioOptions::set_enable_echo_cancellation(bool value) {
  _internal_set_enable_echo_cancellation(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.AudioOptions.enable_echo_cancellation)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// AudioEffect

// .unhinged.audio.v1.AudioEffectType type = 1;
inline void AudioEffect::clear_type() {
  _impl_.type_ = 0;
}
inline ::unhinged::audio::v1::AudioEffectType AudioEffect::_internal_type() const {
  return static_cast< ::unhinged::audio::v1::AudioEffectType >(_impl_.type_);
}
inline ::unhinged::audio::v1::AudioEffectType AudioEffect::type() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.AudioEffect.type)
  return _internal_type();
}
inline void AudioEffect::_internal_set_type(::unhinged::audio::v1::AudioEffectType value) {
  
  _impl_.type_ = value;
}
inline void AudioEffect::set_type(::unhinged::audio::v1::AudioEffectType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.AudioEffect.type)
}

// float intensity = 2;
inline void AudioEffect::clear_intensity() {
  _impl_.intensity_ = 0;
}
inline float AudioEffect::_internal_intensity() const {
  return _impl_.intensity_;
}
inline float AudioEffect::intensity() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.AudioEffect.intensity)
  return _internal_intensity();
}
inline void AudioEffect::_internal_set_intensity(float value) {
  
  _impl_.intensity_ = value;
}
inline void AudioEffect::set_intensity(float value) {
  _internal_set_intensity(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.AudioEffect.intensity)
}

// map<string, string> parameters = 3;
inline int AudioEffect::_internal_parameters_size() const {
  return _impl_.parameters_.size();
}
inline int AudioEffect::parameters_size() const {
  return _internal_parameters_size();
}
inline void AudioEffect::clear_parameters() {
  _impl_.parameters_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
AudioEffect::_internal_parameters() const {
  return _impl_.parameters_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
AudioEffect::parameters() const {
  // @@protoc_insertion_point(field_map:unhinged.audio.v1.AudioEffect.parameters)
  return _internal_parameters();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
AudioEffect::_internal_mutable_parameters() {
  return _impl_.parameters_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
AudioEffect::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_map:unhinged.audio.v1.AudioEffect.parameters)
  return _internal_mutable_parameters();
}

// -------------------------------------------------------------------

// TranscriptSegment

// string text = 1;
inline void TranscriptSegment::clear_text() {
  _impl_.text_.ClearToEmpty();
}
inline const std::string& TranscriptSegment::text() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.TranscriptSegment.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TranscriptSegment::set_text(ArgT0&& arg0, ArgT... args) {
 
 _impl_.text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.TranscriptSegment.text)
}
inline std::string* TranscriptSegment::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.TranscriptSegment.text)
  return _s;
}
inline const std::string& TranscriptSegment::_internal_text() const {
  return _impl_.text_.Get();
}
inline void TranscriptSegment::_internal_set_text(const std::string& value) {
  
  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* TranscriptSegment::_internal_mutable_text() {
  
  return _impl_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* TranscriptSegment::release_text() {
  // @@protoc_insertion_point(field_release:unhinged.audio.v1.TranscriptSegment.text)
  return _impl_.text_.Release();
}
inline void TranscriptSegment::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  _impl_.text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.audio.v1.TranscriptSegment.text)
}

// float start_time = 2;
inline void TranscriptSegment::clear_start_time() {
  _impl_.start_time_ = 0;
}
inline float TranscriptSegment::_internal_start_time() const {
  return _impl_.start_time_;
}
inline float TranscriptSegment::start_time() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.TranscriptSegment.start_time)
  return _internal_start_time();
}
inline void TranscriptSegment::_internal_set_start_time(float value) {
  
  _impl_.start_time_ = value;
}
inline void TranscriptSegment::set_start_time(float value) {
  _internal_set_start_time(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.TranscriptSegment.start_time)
}

// float end_time = 3;
inline void TranscriptSegment::clear_end_time() {
  _impl_.end_time_ = 0;
}
inline float TranscriptSegment::_internal_end_time() const {
  return _impl_.end_time_;
}
inline float TranscriptSegment::end_time() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.TranscriptSegment.end_time)
  return _internal_end_time();
}
inline void TranscriptSegment::_internal_set_end_time(float value) {
  
  _impl_.end_time_ = value;
}
inline void TranscriptSegment::set_end_time(float value) {
  _internal_set_end_time(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.TranscriptSegment.end_time)
}

// float confidence = 4;
inline void TranscriptSegment::clear_confidence() {
  _impl_.confidence_ = 0;
}
inline float TranscriptSegment::_internal_confidence() const {
  return _impl_.confidence_;
}
inline float TranscriptSegment::confidence() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.TranscriptSegment.confidence)
  return _internal_confidence();
}
inline void TranscriptSegment::_internal_set_confidence(float value) {
  
  _impl_.confidence_ = value;
}
inline void TranscriptSegment::set_confidence(float value) {
  _internal_set_confidence(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.TranscriptSegment.confidence)
}

// repeated .unhinged.audio.v1.WordTiming words = 5;
inline int TranscriptSegment::_internal_words_size() const {
  return _impl_.words_.size();
}
inline int TranscriptSegment::words_size() const {
  return _internal_words_size();
}
inline void TranscriptSegment::clear_words() {
  _impl_.words_.Clear();
}
inline ::unhinged::audio::v1::WordTiming* TranscriptSegment::mutable_words(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.TranscriptSegment.words)
  return _impl_.words_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::audio::v1::WordTiming >*
TranscriptSegment::mutable_words() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.audio.v1.TranscriptSegment.words)
  return &_impl_.words_;
}
inline const ::unhinged::audio::v1::WordTiming& TranscriptSegment::_internal_words(int index) const {
  return _impl_.words_.Get(index);
}
inline const ::unhinged::audio::v1::WordTiming& TranscriptSegment::words(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.TranscriptSegment.words)
  return _internal_words(index);
}
inline ::unhinged::audio::v1::WordTiming* TranscriptSegment::_internal_add_words() {
  return _impl_.words_.Add();
}
inline ::unhinged::audio::v1::WordTiming* TranscriptSegment::add_words() {
  ::unhinged::audio::v1::WordTiming* _add = _internal_add_words();
  // @@protoc_insertion_point(field_add:unhinged.audio.v1.TranscriptSegment.words)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::audio::v1::WordTiming >&
TranscriptSegment::words() const {
  // @@protoc_insertion_point(field_list:unhinged.audio.v1.TranscriptSegment.words)
  return _impl_.words_;
}

// string speaker_id = 6;
inline void TranscriptSegment::clear_speaker_id() {
  _impl_.speaker_id_.ClearToEmpty();
}
inline const std::string& TranscriptSegment::speaker_id() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.TranscriptSegment.speaker_id)
  return _internal_speaker_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TranscriptSegment::set_speaker_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.speaker_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.TranscriptSegment.speaker_id)
}
inline std::string* TranscriptSegment::mutable_speaker_id() {
  std::string* _s = _internal_mutable_speaker_id();
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.TranscriptSegment.speaker_id)
  return _s;
}
inline const std::string& TranscriptSegment::_internal_speaker_id() const {
  return _impl_.speaker_id_.Get();
}
inline void TranscriptSegment::_internal_set_speaker_id(const std::string& value) {
  
  _impl_.speaker_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TranscriptSegment::_internal_mutable_speaker_id() {
  
  return _impl_.speaker_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TranscriptSegment::release_speaker_id() {
  // @@protoc_insertion_point(field_release:unhinged.audio.v1.TranscriptSegment.speaker_id)
  return _impl_.speaker_id_.Release();
}
inline void TranscriptSegment::set_allocated_speaker_id(std::string* speaker_id) {
  if (speaker_id != nullptr) {
    
  } else {
    
  }
  _impl_.speaker_id_.SetAllocated(speaker_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.speaker_id_.IsDefault()) {
    _impl_.speaker_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.audio.v1.TranscriptSegment.speaker_id)
}

// -------------------------------------------------------------------

// WordTiming

// string word = 1;
inline void WordTiming::clear_word() {
  _impl_.word_.ClearToEmpty();
}
inline const std::string& WordTiming::word() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.WordTiming.word)
  return _internal_word();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WordTiming::set_word(ArgT0&& arg0, ArgT... args) {
 
 _impl_.word_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.WordTiming.word)
}
inline std::string* WordTiming::mutable_word() {
  std::string* _s = _internal_mutable_word();
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.WordTiming.word)
  return _s;
}
inline const std::string& WordTiming::_internal_word() const {
  return _impl_.word_.Get();
}
inline void WordTiming::_internal_set_word(const std::string& value) {
  
  _impl_.word_.Set(value, GetArenaForAllocation());
}
inline std::string* WordTiming::_internal_mutable_word() {
  
  return _impl_.word_.Mutable(GetArenaForAllocation());
}
inline std::string* WordTiming::release_word() {
  // @@protoc_insertion_point(field_release:unhinged.audio.v1.WordTiming.word)
  return _impl_.word_.Release();
}
inline void WordTiming::set_allocated_word(std::string* word) {
  if (word != nullptr) {
    
  } else {
    
  }
  _impl_.word_.SetAllocated(word, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.word_.IsDefault()) {
    _impl_.word_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.audio.v1.WordTiming.word)
}

// float start_time = 2;
inline void WordTiming::clear_start_time() {
  _impl_.start_time_ = 0;
}
inline float WordTiming::_internal_start_time() const {
  return _impl_.start_time_;
}
inline float WordTiming::start_time() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.WordTiming.start_time)
  return _internal_start_time();
}
inline void WordTiming::_internal_set_start_time(float value) {
  
  _impl_.start_time_ = value;
}
inline void WordTiming::set_start_time(float value) {
  _internal_set_start_time(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.WordTiming.start_time)
}

// float end_time = 3;
inline void WordTiming::clear_end_time() {
  _impl_.end_time_ = 0;
}
inline float WordTiming::_internal_end_time() const {
  return _impl_.end_time_;
}
inline float WordTiming::end_time() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.WordTiming.end_time)
  return _internal_end_time();
}
inline void WordTiming::_internal_set_end_time(float value) {
  
  _impl_.end_time_ = value;
}
inline void WordTiming::set_end_time(float value) {
  _internal_set_end_time(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.WordTiming.end_time)
}

// float confidence = 4;
inline void WordTiming::clear_confidence() {
  _impl_.confidence_ = 0;
}
inline float WordTiming::_internal_confidence() const {
  return _impl_.confidence_;
}
inline float WordTiming::confidence() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.WordTiming.confidence)
  return _internal_confidence();
}
inline void WordTiming::_internal_set_confidence(float value) {
  
  _impl_.confidence_ = value;
}
inline void WordTiming::set_confidence(float value) {
  _internal_set_confidence(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.WordTiming.confidence)
}

// -------------------------------------------------------------------

// STTMetadata

// string model = 1;
inline void STTMetadata::clear_model() {
  _impl_.model_.ClearToEmpty();
}
inline const std::string& STTMetadata::model() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.STTMetadata.model)
  return _internal_model();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void STTMetadata::set_model(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.STTMetadata.model)
}
inline std::string* STTMetadata::mutable_model() {
  std::string* _s = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.STTMetadata.model)
  return _s;
}
inline const std::string& STTMetadata::_internal_model() const {
  return _impl_.model_.Get();
}
inline void STTMetadata::_internal_set_model(const std::string& value) {
  
  _impl_.model_.Set(value, GetArenaForAllocation());
}
inline std::string* STTMetadata::_internal_mutable_model() {
  
  return _impl_.model_.Mutable(GetArenaForAllocation());
}
inline std::string* STTMetadata::release_model() {
  // @@protoc_insertion_point(field_release:unhinged.audio.v1.STTMetadata.model)
  return _impl_.model_.Release();
}
inline void STTMetadata::set_allocated_model(std::string* model) {
  if (model != nullptr) {
    
  } else {
    
  }
  _impl_.model_.SetAllocated(model, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_.IsDefault()) {
    _impl_.model_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.audio.v1.STTMetadata.model)
}

// string language = 2;
inline void STTMetadata::clear_language() {
  _impl_.language_.ClearToEmpty();
}
inline const std::string& STTMetadata::language() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.STTMetadata.language)
  return _internal_language();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void STTMetadata::set_language(ArgT0&& arg0, ArgT... args) {
 
 _impl_.language_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.STTMetadata.language)
}
inline std::string* STTMetadata::mutable_language() {
  std::string* _s = _internal_mutable_language();
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.STTMetadata.language)
  return _s;
}
inline const std::string& STTMetadata::_internal_language() const {
  return _impl_.language_.Get();
}
inline void STTMetadata::_internal_set_language(const std::string& value) {
  
  _impl_.language_.Set(value, GetArenaForAllocation());
}
inline std::string* STTMetadata::_internal_mutable_language() {
  
  return _impl_.language_.Mutable(GetArenaForAllocation());
}
inline std::string* STTMetadata::release_language() {
  // @@protoc_insertion_point(field_release:unhinged.audio.v1.STTMetadata.language)
  return _impl_.language_.Release();
}
inline void STTMetadata::set_allocated_language(std::string* language) {
  if (language != nullptr) {
    
  } else {
    
  }
  _impl_.language_.SetAllocated(language, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.language_.IsDefault()) {
    _impl_.language_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.audio.v1.STTMetadata.language)
}

// float processing_time_ms = 3;
inline void STTMetadata::clear_processing_time_ms() {
  _impl_.processing_time_ms_ = 0;
}
inline float STTMetadata::_internal_processing_time_ms() const {
  return _impl_.processing_time_ms_;
}
inline float STTMetadata::processing_time_ms() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.STTMetadata.processing_time_ms)
  return _internal_processing_time_ms();
}
inline void STTMetadata::_internal_set_processing_time_ms(float value) {
  
  _impl_.processing_time_ms_ = value;
}
inline void STTMetadata::set_processing_time_ms(float value) {
  _internal_set_processing_time_ms(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.STTMetadata.processing_time_ms)
}

// float signal_to_noise_ratio = 4;
inline void STTMetadata::clear_signal_to_noise_ratio() {
  _impl_.signal_to_noise_ratio_ = 0;
}
inline float STTMetadata::_internal_signal_to_noise_ratio() const {
  return _impl_.signal_to_noise_ratio_;
}
inline float STTMetadata::signal_to_noise_ratio() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.STTMetadata.signal_to_noise_ratio)
  return _internal_signal_to_noise_ratio();
}
inline void STTMetadata::_internal_set_signal_to_noise_ratio(float value) {
  
  _impl_.signal_to_noise_ratio_ = value;
}
inline void STTMetadata::set_signal_to_noise_ratio(float value) {
  _internal_set_signal_to_noise_ratio(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.STTMetadata.signal_to_noise_ratio)
}

// float speech_rate_wpm = 5;
inline void STTMetadata::clear_speech_rate_wpm() {
  _impl_.speech_rate_wpm_ = 0;
}
inline float STTMetadata::_internal_speech_rate_wpm() const {
  return _impl_.speech_rate_wpm_;
}
inline float STTMetadata::speech_rate_wpm() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.STTMetadata.speech_rate_wpm)
  return _internal_speech_rate_wpm();
}
inline void STTMetadata::_internal_set_speech_rate_wpm(float value) {
  
  _impl_.speech_rate_wpm_ = value;
}
inline void STTMetadata::set_speech_rate_wpm(float value) {
  _internal_set_speech_rate_wpm(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.STTMetadata.speech_rate_wpm)
}

// repeated string detected_languages = 6;
inline int STTMetadata::_internal_detected_languages_size() const {
  return _impl_.detected_languages_.size();
}
inline int STTMetadata::detected_languages_size() const {
  return _internal_detected_languages_size();
}
inline void STTMetadata::clear_detected_languages() {
  _impl_.detected_languages_.Clear();
}
inline std::string* STTMetadata::add_detected_languages() {
  std::string* _s = _internal_add_detected_languages();
  // @@protoc_insertion_point(field_add_mutable:unhinged.audio.v1.STTMetadata.detected_languages)
  return _s;
}
inline const std::string& STTMetadata::_internal_detected_languages(int index) const {
  return _impl_.detected_languages_.Get(index);
}
inline const std::string& STTMetadata::detected_languages(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.STTMetadata.detected_languages)
  return _internal_detected_languages(index);
}
inline std::string* STTMetadata::mutable_detected_languages(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.STTMetadata.detected_languages)
  return _impl_.detected_languages_.Mutable(index);
}
inline void STTMetadata::set_detected_languages(int index, const std::string& value) {
  _impl_.detected_languages_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.STTMetadata.detected_languages)
}
inline void STTMetadata::set_detected_languages(int index, std::string&& value) {
  _impl_.detected_languages_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.STTMetadata.detected_languages)
}
inline void STTMetadata::set_detected_languages(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.detected_languages_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.audio.v1.STTMetadata.detected_languages)
}
inline void STTMetadata::set_detected_languages(int index, const char* value, size_t size) {
  _impl_.detected_languages_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.audio.v1.STTMetadata.detected_languages)
}
inline std::string* STTMetadata::_internal_add_detected_languages() {
  return _impl_.detected_languages_.Add();
}
inline void STTMetadata::add_detected_languages(const std::string& value) {
  _impl_.detected_languages_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.audio.v1.STTMetadata.detected_languages)
}
inline void STTMetadata::add_detected_languages(std::string&& value) {
  _impl_.detected_languages_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.audio.v1.STTMetadata.detected_languages)
}
inline void STTMetadata::add_detected_languages(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.detected_languages_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.audio.v1.STTMetadata.detected_languages)
}
inline void STTMetadata::add_detected_languages(const char* value, size_t size) {
  _impl_.detected_languages_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.audio.v1.STTMetadata.detected_languages)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
STTMetadata::detected_languages() const {
  // @@protoc_insertion_point(field_list:unhinged.audio.v1.STTMetadata.detected_languages)
  return _impl_.detected_languages_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
STTMetadata::mutable_detected_languages() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.audio.v1.STTMetadata.detected_languages)
  return &_impl_.detected_languages_;
}

// bool has_background_noise = 7;
inline void STTMetadata::clear_has_background_noise() {
  _impl_.has_background_noise_ = false;
}
inline bool STTMetadata::_internal_has_background_noise() const {
  return _impl_.has_background_noise_;
}
inline bool STTMetadata::has_background_noise() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.STTMetadata.has_background_noise)
  return _internal_has_background_noise();
}
inline void STTMetadata::_internal_set_has_background_noise(bool value) {
  
  _impl_.has_background_noise_ = value;
}
inline void STTMetadata::set_has_background_noise(bool value) {
  _internal_set_has_background_noise(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.STTMetadata.has_background_noise)
}

// bool has_multiple_speakers = 8;
inline void STTMetadata::clear_has_multiple_speakers() {
  _impl_.has_multiple_speakers_ = false;
}
inline bool STTMetadata::_internal_has_multiple_speakers() const {
  return _impl_.has_multiple_speakers_;
}
inline bool STTMetadata::has_multiple_speakers() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.STTMetadata.has_multiple_speakers)
  return _internal_has_multiple_speakers();
}
inline void STTMetadata::_internal_set_has_multiple_speakers(bool value) {
  
  _impl_.has_multiple_speakers_ = value;
}
inline void STTMetadata::set_has_multiple_speakers(bool value) {
  _internal_set_has_multiple_speakers(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.STTMetadata.has_multiple_speakers)
}

// .unhinged.audio.v1.AudioQuality detected_quality = 9;
inline void STTMetadata::clear_detected_quality() {
  _impl_.detected_quality_ = 0;
}
inline ::unhinged::audio::v1::AudioQuality STTMetadata::_internal_detected_quality() const {
  return static_cast< ::unhinged::audio::v1::AudioQuality >(_impl_.detected_quality_);
}
inline ::unhinged::audio::v1::AudioQuality STTMetadata::detected_quality() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.STTMetadata.detected_quality)
  return _internal_detected_quality();
}
inline void STTMetadata::_internal_set_detected_quality(::unhinged::audio::v1::AudioQuality value) {
  
  _impl_.detected_quality_ = value;
}
inline void STTMetadata::set_detected_quality(::unhinged::audio::v1::AudioQuality value) {
  _internal_set_detected_quality(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.STTMetadata.detected_quality)
}

// -------------------------------------------------------------------

// Voice

// .unhinged.common.v1.ResourceMetadata metadata = 1;
inline bool Voice::_internal_has_metadata() const {
  return this != internal_default_instance() && _impl_.metadata_ != nullptr;
}
inline bool Voice::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::unhinged::common::v1::ResourceMetadata& Voice::_internal_metadata() const {
  const ::unhinged::common::v1::ResourceMetadata* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::common::v1::ResourceMetadata&>(
      ::unhinged::common::v1::_ResourceMetadata_default_instance_);
}
inline const ::unhinged::common::v1::ResourceMetadata& Voice::metadata() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.Voice.metadata)
  return _internal_metadata();
}
inline void Voice::unsafe_arena_set_allocated_metadata(
    ::unhinged::common::v1::ResourceMetadata* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.audio.v1.Voice.metadata)
}
inline ::unhinged::common::v1::ResourceMetadata* Voice::release_metadata() {
  
  ::unhinged::common::v1::ResourceMetadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::common::v1::ResourceMetadata* Voice::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:unhinged.audio.v1.Voice.metadata)
  
  ::unhinged::common::v1::ResourceMetadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::unhinged::common::v1::ResourceMetadata* Voice::_internal_mutable_metadata() {
  
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::common::v1::ResourceMetadata>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::unhinged::common::v1::ResourceMetadata* Voice::mutable_metadata() {
  ::unhinged::common::v1::ResourceMetadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.Voice.metadata)
  return _msg;
}
inline void Voice::set_allocated_metadata(::unhinged::common::v1::ResourceMetadata* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:unhinged.audio.v1.Voice.metadata)
}

// string name = 2;
inline void Voice::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Voice::name() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.Voice.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Voice::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.Voice.name)
}
inline std::string* Voice::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.Voice.name)
  return _s;
}
inline const std::string& Voice::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Voice::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Voice::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Voice::release_name() {
  // @@protoc_insertion_point(field_release:unhinged.audio.v1.Voice.name)
  return _impl_.name_.Release();
}
inline void Voice::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.audio.v1.Voice.name)
}

// string display_name = 3;
inline void Voice::clear_display_name() {
  _impl_.display_name_.ClearToEmpty();
}
inline const std::string& Voice::display_name() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.Voice.display_name)
  return _internal_display_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Voice::set_display_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.display_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.Voice.display_name)
}
inline std::string* Voice::mutable_display_name() {
  std::string* _s = _internal_mutable_display_name();
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.Voice.display_name)
  return _s;
}
inline const std::string& Voice::_internal_display_name() const {
  return _impl_.display_name_.Get();
}
inline void Voice::_internal_set_display_name(const std::string& value) {
  
  _impl_.display_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Voice::_internal_mutable_display_name() {
  
  return _impl_.display_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Voice::release_display_name() {
  // @@protoc_insertion_point(field_release:unhinged.audio.v1.Voice.display_name)
  return _impl_.display_name_.Release();
}
inline void Voice::set_allocated_display_name(std::string* display_name) {
  if (display_name != nullptr) {
    
  } else {
    
  }
  _impl_.display_name_.SetAllocated(display_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.display_name_.IsDefault()) {
    _impl_.display_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.audio.v1.Voice.display_name)
}

// string description = 4;
inline void Voice::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Voice::description() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.Voice.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Voice::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.Voice.description)
}
inline std::string* Voice::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.Voice.description)
  return _s;
}
inline const std::string& Voice::_internal_description() const {
  return _impl_.description_.Get();
}
inline void Voice::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* Voice::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* Voice::release_description() {
  // @@protoc_insertion_point(field_release:unhinged.audio.v1.Voice.description)
  return _impl_.description_.Release();
}
inline void Voice::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.audio.v1.Voice.description)
}

// string language = 5;
inline void Voice::clear_language() {
  _impl_.language_.ClearToEmpty();
}
inline const std::string& Voice::language() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.Voice.language)
  return _internal_language();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Voice::set_language(ArgT0&& arg0, ArgT... args) {
 
 _impl_.language_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.Voice.language)
}
inline std::string* Voice::mutable_language() {
  std::string* _s = _internal_mutable_language();
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.Voice.language)
  return _s;
}
inline const std::string& Voice::_internal_language() const {
  return _impl_.language_.Get();
}
inline void Voice::_internal_set_language(const std::string& value) {
  
  _impl_.language_.Set(value, GetArenaForAllocation());
}
inline std::string* Voice::_internal_mutable_language() {
  
  return _impl_.language_.Mutable(GetArenaForAllocation());
}
inline std::string* Voice::release_language() {
  // @@protoc_insertion_point(field_release:unhinged.audio.v1.Voice.language)
  return _impl_.language_.Release();
}
inline void Voice::set_allocated_language(std::string* language) {
  if (language != nullptr) {
    
  } else {
    
  }
  _impl_.language_.SetAllocated(language, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.language_.IsDefault()) {
    _impl_.language_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.audio.v1.Voice.language)
}

// string language_code = 6;
inline void Voice::clear_language_code() {
  _impl_.language_code_.ClearToEmpty();
}
inline const std::string& Voice::language_code() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.Voice.language_code)
  return _internal_language_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Voice::set_language_code(ArgT0&& arg0, ArgT... args) {
 
 _impl_.language_code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.Voice.language_code)
}
inline std::string* Voice::mutable_language_code() {
  std::string* _s = _internal_mutable_language_code();
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.Voice.language_code)
  return _s;
}
inline const std::string& Voice::_internal_language_code() const {
  return _impl_.language_code_.Get();
}
inline void Voice::_internal_set_language_code(const std::string& value) {
  
  _impl_.language_code_.Set(value, GetArenaForAllocation());
}
inline std::string* Voice::_internal_mutable_language_code() {
  
  return _impl_.language_code_.Mutable(GetArenaForAllocation());
}
inline std::string* Voice::release_language_code() {
  // @@protoc_insertion_point(field_release:unhinged.audio.v1.Voice.language_code)
  return _impl_.language_code_.Release();
}
inline void Voice::set_allocated_language_code(std::string* language_code) {
  if (language_code != nullptr) {
    
  } else {
    
  }
  _impl_.language_code_.SetAllocated(language_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.language_code_.IsDefault()) {
    _impl_.language_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.audio.v1.Voice.language_code)
}

// .unhinged.audio.v1.VoiceGender gender = 7;
inline void Voice::clear_gender() {
  _impl_.gender_ = 0;
}
inline ::unhinged::audio::v1::VoiceGender Voice::_internal_gender() const {
  return static_cast< ::unhinged::audio::v1::VoiceGender >(_impl_.gender_);
}
inline ::unhinged::audio::v1::VoiceGender Voice::gender() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.Voice.gender)
  return _internal_gender();
}
inline void Voice::_internal_set_gender(::unhinged::audio::v1::VoiceGender value) {
  
  _impl_.gender_ = value;
}
inline void Voice::set_gender(::unhinged::audio::v1::VoiceGender value) {
  _internal_set_gender(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.Voice.gender)
}

// .unhinged.audio.v1.VoiceAge age = 8;
inline void Voice::clear_age() {
  _impl_.age_ = 0;
}
inline ::unhinged::audio::v1::VoiceAge Voice::_internal_age() const {
  return static_cast< ::unhinged::audio::v1::VoiceAge >(_impl_.age_);
}
inline ::unhinged::audio::v1::VoiceAge Voice::age() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.Voice.age)
  return _internal_age();
}
inline void Voice::_internal_set_age(::unhinged::audio::v1::VoiceAge value) {
  
  _impl_.age_ = value;
}
inline void Voice::set_age(::unhinged::audio::v1::VoiceAge value) {
  _internal_set_age(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.Voice.age)
}

// .unhinged.audio.v1.VoiceStyle style = 9;
inline void Voice::clear_style() {
  _impl_.style_ = 0;
}
inline ::unhinged::audio::v1::VoiceStyle Voice::_internal_style() const {
  return static_cast< ::unhinged::audio::v1::VoiceStyle >(_impl_.style_);
}
inline ::unhinged::audio::v1::VoiceStyle Voice::style() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.Voice.style)
  return _internal_style();
}
inline void Voice::_internal_set_style(::unhinged::audio::v1::VoiceStyle value) {
  
  _impl_.style_ = value;
}
inline void Voice::set_style(::unhinged::audio::v1::VoiceStyle value) {
  _internal_set_style(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.Voice.style)
}

// repeated .unhinged.audio.v1.AudioFormat supported_formats = 10;
inline int Voice::_internal_supported_formats_size() const {
  return _impl_.supported_formats_.size();
}
inline int Voice::supported_formats_size() const {
  return _internal_supported_formats_size();
}
inline void Voice::clear_supported_formats() {
  _impl_.supported_formats_.Clear();
}
inline ::unhinged::audio::v1::AudioFormat Voice::_internal_supported_formats(int index) const {
  return static_cast< ::unhinged::audio::v1::AudioFormat >(_impl_.supported_formats_.Get(index));
}
inline ::unhinged::audio::v1::AudioFormat Voice::supported_formats(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.Voice.supported_formats)
  return _internal_supported_formats(index);
}
inline void Voice::set_supported_formats(int index, ::unhinged::audio::v1::AudioFormat value) {
  _impl_.supported_formats_.Set(index, value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.Voice.supported_formats)
}
inline void Voice::_internal_add_supported_formats(::unhinged::audio::v1::AudioFormat value) {
  _impl_.supported_formats_.Add(value);
}
inline void Voice::add_supported_formats(::unhinged::audio::v1::AudioFormat value) {
  _internal_add_supported_formats(value);
  // @@protoc_insertion_point(field_add:unhinged.audio.v1.Voice.supported_formats)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
Voice::supported_formats() const {
  // @@protoc_insertion_point(field_list:unhinged.audio.v1.Voice.supported_formats)
  return _impl_.supported_formats_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
Voice::_internal_mutable_supported_formats() {
  return &_impl_.supported_formats_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
Voice::mutable_supported_formats() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.audio.v1.Voice.supported_formats)
  return _internal_mutable_supported_formats();
}

// repeated int32 supported_sample_rates = 11;
inline int Voice::_internal_supported_sample_rates_size() const {
  return _impl_.supported_sample_rates_.size();
}
inline int Voice::supported_sample_rates_size() const {
  return _internal_supported_sample_rates_size();
}
inline void Voice::clear_supported_sample_rates() {
  _impl_.supported_sample_rates_.Clear();
}
inline int32_t Voice::_internal_supported_sample_rates(int index) const {
  return _impl_.supported_sample_rates_.Get(index);
}
inline int32_t Voice::supported_sample_rates(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.Voice.supported_sample_rates)
  return _internal_supported_sample_rates(index);
}
inline void Voice::set_supported_sample_rates(int index, int32_t value) {
  _impl_.supported_sample_rates_.Set(index, value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.Voice.supported_sample_rates)
}
inline void Voice::_internal_add_supported_sample_rates(int32_t value) {
  _impl_.supported_sample_rates_.Add(value);
}
inline void Voice::add_supported_sample_rates(int32_t value) {
  _internal_add_supported_sample_rates(value);
  // @@protoc_insertion_point(field_add:unhinged.audio.v1.Voice.supported_sample_rates)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Voice::_internal_supported_sample_rates() const {
  return _impl_.supported_sample_rates_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Voice::supported_sample_rates() const {
  // @@protoc_insertion_point(field_list:unhinged.audio.v1.Voice.supported_sample_rates)
  return _internal_supported_sample_rates();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Voice::_internal_mutable_supported_sample_rates() {
  return &_impl_.supported_sample_rates_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Voice::mutable_supported_sample_rates() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.audio.v1.Voice.supported_sample_rates)
  return _internal_mutable_supported_sample_rates();
}

// bool is_available = 12;
inline void Voice::clear_is_available() {
  _impl_.is_available_ = false;
}
inline bool Voice::_internal_is_available() const {
  return _impl_.is_available_;
}
inline bool Voice::is_available() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.Voice.is_available)
  return _internal_is_available();
}
inline void Voice::_internal_set_is_available(bool value) {
  
  _impl_.is_available_ = value;
}
inline void Voice::set_is_available(bool value) {
  _internal_set_is_available(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.Voice.is_available)
}

// bool is_premium = 13;
inline void Voice::clear_is_premium() {
  _impl_.is_premium_ = false;
}
inline bool Voice::_internal_is_premium() const {
  return _impl_.is_premium_;
}
inline bool Voice::is_premium() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.Voice.is_premium)
  return _internal_is_premium();
}
inline void Voice::_internal_set_is_premium(bool value) {
  
  _impl_.is_premium_ = value;
}
inline void Voice::set_is_premium(bool value) {
  _internal_set_is_premium(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.Voice.is_premium)
}

// float cost_per_character = 14;
inline void Voice::clear_cost_per_character() {
  _impl_.cost_per_character_ = 0;
}
inline float Voice::_internal_cost_per_character() const {
  return _impl_.cost_per_character_;
}
inline float Voice::cost_per_character() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.Voice.cost_per_character)
  return _internal_cost_per_character();
}
inline void Voice::_internal_set_cost_per_character(float value) {
  
  _impl_.cost_per_character_ = value;
}
inline void Voice::set_cost_per_character(float value) {
  _internal_set_cost_per_character(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.Voice.cost_per_character)
}

// string preview_url = 15;
inline void Voice::clear_preview_url() {
  _impl_.preview_url_.ClearToEmpty();
}
inline const std::string& Voice::preview_url() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.Voice.preview_url)
  return _internal_preview_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Voice::set_preview_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.preview_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.Voice.preview_url)
}
inline std::string* Voice::mutable_preview_url() {
  std::string* _s = _internal_mutable_preview_url();
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.Voice.preview_url)
  return _s;
}
inline const std::string& Voice::_internal_preview_url() const {
  return _impl_.preview_url_.Get();
}
inline void Voice::_internal_set_preview_url(const std::string& value) {
  
  _impl_.preview_url_.Set(value, GetArenaForAllocation());
}
inline std::string* Voice::_internal_mutable_preview_url() {
  
  return _impl_.preview_url_.Mutable(GetArenaForAllocation());
}
inline std::string* Voice::release_preview_url() {
  // @@protoc_insertion_point(field_release:unhinged.audio.v1.Voice.preview_url)
  return _impl_.preview_url_.Release();
}
inline void Voice::set_allocated_preview_url(std::string* preview_url) {
  if (preview_url != nullptr) {
    
  } else {
    
  }
  _impl_.preview_url_.SetAllocated(preview_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.preview_url_.IsDefault()) {
    _impl_.preview_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.audio.v1.Voice.preview_url)
}

// string preview_text = 16;
inline void Voice::clear_preview_text() {
  _impl_.preview_text_.ClearToEmpty();
}
inline const std::string& Voice::preview_text() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.Voice.preview_text)
  return _internal_preview_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Voice::set_preview_text(ArgT0&& arg0, ArgT... args) {
 
 _impl_.preview_text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.Voice.preview_text)
}
inline std::string* Voice::mutable_preview_text() {
  std::string* _s = _internal_mutable_preview_text();
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.Voice.preview_text)
  return _s;
}
inline const std::string& Voice::_internal_preview_text() const {
  return _impl_.preview_text_.Get();
}
inline void Voice::_internal_set_preview_text(const std::string& value) {
  
  _impl_.preview_text_.Set(value, GetArenaForAllocation());
}
inline std::string* Voice::_internal_mutable_preview_text() {
  
  return _impl_.preview_text_.Mutable(GetArenaForAllocation());
}
inline std::string* Voice::release_preview_text() {
  // @@protoc_insertion_point(field_release:unhinged.audio.v1.Voice.preview_text)
  return _impl_.preview_text_.Release();
}
inline void Voice::set_allocated_preview_text(std::string* preview_text) {
  if (preview_text != nullptr) {
    
  } else {
    
  }
  _impl_.preview_text_.SetAllocated(preview_text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.preview_text_.IsDefault()) {
    _impl_.preview_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.audio.v1.Voice.preview_text)
}

// -------------------------------------------------------------------

// TTSChunkPayload

// string tts_id = 1;
inline void TTSChunkPayload::clear_tts_id() {
  _impl_.tts_id_.ClearToEmpty();
}
inline const std::string& TTSChunkPayload::tts_id() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.TTSChunkPayload.tts_id)
  return _internal_tts_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TTSChunkPayload::set_tts_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tts_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.TTSChunkPayload.tts_id)
}
inline std::string* TTSChunkPayload::mutable_tts_id() {
  std::string* _s = _internal_mutable_tts_id();
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.TTSChunkPayload.tts_id)
  return _s;
}
inline const std::string& TTSChunkPayload::_internal_tts_id() const {
  return _impl_.tts_id_.Get();
}
inline void TTSChunkPayload::_internal_set_tts_id(const std::string& value) {
  
  _impl_.tts_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TTSChunkPayload::_internal_mutable_tts_id() {
  
  return _impl_.tts_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TTSChunkPayload::release_tts_id() {
  // @@protoc_insertion_point(field_release:unhinged.audio.v1.TTSChunkPayload.tts_id)
  return _impl_.tts_id_.Release();
}
inline void TTSChunkPayload::set_allocated_tts_id(std::string* tts_id) {
  if (tts_id != nullptr) {
    
  } else {
    
  }
  _impl_.tts_id_.SetAllocated(tts_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tts_id_.IsDefault()) {
    _impl_.tts_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.audio.v1.TTSChunkPayload.tts_id)
}

// .unhinged.audio.v1.AudioMetadata audio_metadata = 2;
inline bool TTSChunkPayload::_internal_has_audio_metadata() const {
  return this != internal_default_instance() && _impl_.audio_metadata_ != nullptr;
}
inline bool TTSChunkPayload::has_audio_metadata() const {
  return _internal_has_audio_metadata();
}
inline void TTSChunkPayload::clear_audio_metadata() {
  if (GetArenaForAllocation() == nullptr && _impl_.audio_metadata_ != nullptr) {
    delete _impl_.audio_metadata_;
  }
  _impl_.audio_metadata_ = nullptr;
}
inline const ::unhinged::audio::v1::AudioMetadata& TTSChunkPayload::_internal_audio_metadata() const {
  const ::unhinged::audio::v1::AudioMetadata* p = _impl_.audio_metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::audio::v1::AudioMetadata&>(
      ::unhinged::audio::v1::_AudioMetadata_default_instance_);
}
inline const ::unhinged::audio::v1::AudioMetadata& TTSChunkPayload::audio_metadata() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.TTSChunkPayload.audio_metadata)
  return _internal_audio_metadata();
}
inline void TTSChunkPayload::unsafe_arena_set_allocated_audio_metadata(
    ::unhinged::audio::v1::AudioMetadata* audio_metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.audio_metadata_);
  }
  _impl_.audio_metadata_ = audio_metadata;
  if (audio_metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.audio.v1.TTSChunkPayload.audio_metadata)
}
inline ::unhinged::audio::v1::AudioMetadata* TTSChunkPayload::release_audio_metadata() {
  
  ::unhinged::audio::v1::AudioMetadata* temp = _impl_.audio_metadata_;
  _impl_.audio_metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::audio::v1::AudioMetadata* TTSChunkPayload::unsafe_arena_release_audio_metadata() {
  // @@protoc_insertion_point(field_release:unhinged.audio.v1.TTSChunkPayload.audio_metadata)
  
  ::unhinged::audio::v1::AudioMetadata* temp = _impl_.audio_metadata_;
  _impl_.audio_metadata_ = nullptr;
  return temp;
}
inline ::unhinged::audio::v1::AudioMetadata* TTSChunkPayload::_internal_mutable_audio_metadata() {
  
  if (_impl_.audio_metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::audio::v1::AudioMetadata>(GetArenaForAllocation());
    _impl_.audio_metadata_ = p;
  }
  return _impl_.audio_metadata_;
}
inline ::unhinged::audio::v1::AudioMetadata* TTSChunkPayload::mutable_audio_metadata() {
  ::unhinged::audio::v1::AudioMetadata* _msg = _internal_mutable_audio_metadata();
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.TTSChunkPayload.audio_metadata)
  return _msg;
}
inline void TTSChunkPayload::set_allocated_audio_metadata(::unhinged::audio::v1::AudioMetadata* audio_metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.audio_metadata_;
  }
  if (audio_metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(audio_metadata);
    if (message_arena != submessage_arena) {
      audio_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, audio_metadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.audio_metadata_ = audio_metadata;
  // @@protoc_insertion_point(field_set_allocated:unhinged.audio.v1.TTSChunkPayload.audio_metadata)
}

// int32 chunk_index = 3;
inline void TTSChunkPayload::clear_chunk_index() {
  _impl_.chunk_index_ = 0;
}
inline int32_t TTSChunkPayload::_internal_chunk_index() const {
  return _impl_.chunk_index_;
}
inline int32_t TTSChunkPayload::chunk_index() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.TTSChunkPayload.chunk_index)
  return _internal_chunk_index();
}
inline void TTSChunkPayload::_internal_set_chunk_index(int32_t value) {
  
  _impl_.chunk_index_ = value;
}
inline void TTSChunkPayload::set_chunk_index(int32_t value) {
  _internal_set_chunk_index(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.TTSChunkPayload.chunk_index)
}

// float progress_percent = 4;
inline void TTSChunkPayload::clear_progress_percent() {
  _impl_.progress_percent_ = 0;
}
inline float TTSChunkPayload::_internal_progress_percent() const {
  return _impl_.progress_percent_;
}
inline float TTSChunkPayload::progress_percent() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.TTSChunkPayload.progress_percent)
  return _internal_progress_percent();
}
inline void TTSChunkPayload::_internal_set_progress_percent(float value) {
  
  _impl_.progress_percent_ = value;
}
inline void TTSChunkPayload::set_progress_percent(float value) {
  _internal_set_progress_percent(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.TTSChunkPayload.progress_percent)
}

// -------------------------------------------------------------------

// STTChunkPayload

// string stt_id = 1;
inline void STTChunkPayload::clear_stt_id() {
  _impl_.stt_id_.ClearToEmpty();
}
inline const std::string& STTChunkPayload::stt_id() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.STTChunkPayload.stt_id)
  return _internal_stt_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void STTChunkPayload::set_stt_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.stt_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.STTChunkPayload.stt_id)
}
inline std::string* STTChunkPayload::mutable_stt_id() {
  std::string* _s = _internal_mutable_stt_id();
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.STTChunkPayload.stt_id)
  return _s;
}
inline const std::string& STTChunkPayload::_internal_stt_id() const {
  return _impl_.stt_id_.Get();
}
inline void STTChunkPayload::_internal_set_stt_id(const std::string& value) {
  
  _impl_.stt_id_.Set(value, GetArenaForAllocation());
}
inline std::string* STTChunkPayload::_internal_mutable_stt_id() {
  
  return _impl_.stt_id_.Mutable(GetArenaForAllocation());
}
inline std::string* STTChunkPayload::release_stt_id() {
  // @@protoc_insertion_point(field_release:unhinged.audio.v1.STTChunkPayload.stt_id)
  return _impl_.stt_id_.Release();
}
inline void STTChunkPayload::set_allocated_stt_id(std::string* stt_id) {
  if (stt_id != nullptr) {
    
  } else {
    
  }
  _impl_.stt_id_.SetAllocated(stt_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stt_id_.IsDefault()) {
    _impl_.stt_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.audio.v1.STTChunkPayload.stt_id)
}

// .unhinged.audio.v1.AudioMetadata audio_metadata = 2;
inline bool STTChunkPayload::_internal_has_audio_metadata() const {
  return this != internal_default_instance() && _impl_.audio_metadata_ != nullptr;
}
inline bool STTChunkPayload::has_audio_metadata() const {
  return _internal_has_audio_metadata();
}
inline void STTChunkPayload::clear_audio_metadata() {
  if (GetArenaForAllocation() == nullptr && _impl_.audio_metadata_ != nullptr) {
    delete _impl_.audio_metadata_;
  }
  _impl_.audio_metadata_ = nullptr;
}
inline const ::unhinged::audio::v1::AudioMetadata& STTChunkPayload::_internal_audio_metadata() const {
  const ::unhinged::audio::v1::AudioMetadata* p = _impl_.audio_metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::audio::v1::AudioMetadata&>(
      ::unhinged::audio::v1::_AudioMetadata_default_instance_);
}
inline const ::unhinged::audio::v1::AudioMetadata& STTChunkPayload::audio_metadata() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.STTChunkPayload.audio_metadata)
  return _internal_audio_metadata();
}
inline void STTChunkPayload::unsafe_arena_set_allocated_audio_metadata(
    ::unhinged::audio::v1::AudioMetadata* audio_metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.audio_metadata_);
  }
  _impl_.audio_metadata_ = audio_metadata;
  if (audio_metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.audio.v1.STTChunkPayload.audio_metadata)
}
inline ::unhinged::audio::v1::AudioMetadata* STTChunkPayload::release_audio_metadata() {
  
  ::unhinged::audio::v1::AudioMetadata* temp = _impl_.audio_metadata_;
  _impl_.audio_metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::audio::v1::AudioMetadata* STTChunkPayload::unsafe_arena_release_audio_metadata() {
  // @@protoc_insertion_point(field_release:unhinged.audio.v1.STTChunkPayload.audio_metadata)
  
  ::unhinged::audio::v1::AudioMetadata* temp = _impl_.audio_metadata_;
  _impl_.audio_metadata_ = nullptr;
  return temp;
}
inline ::unhinged::audio::v1::AudioMetadata* STTChunkPayload::_internal_mutable_audio_metadata() {
  
  if (_impl_.audio_metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::audio::v1::AudioMetadata>(GetArenaForAllocation());
    _impl_.audio_metadata_ = p;
  }
  return _impl_.audio_metadata_;
}
inline ::unhinged::audio::v1::AudioMetadata* STTChunkPayload::mutable_audio_metadata() {
  ::unhinged::audio::v1::AudioMetadata* _msg = _internal_mutable_audio_metadata();
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.STTChunkPayload.audio_metadata)
  return _msg;
}
inline void STTChunkPayload::set_allocated_audio_metadata(::unhinged::audio::v1::AudioMetadata* audio_metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.audio_metadata_;
  }
  if (audio_metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(audio_metadata);
    if (message_arena != submessage_arena) {
      audio_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, audio_metadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.audio_metadata_ = audio_metadata;
  // @@protoc_insertion_point(field_set_allocated:unhinged.audio.v1.STTChunkPayload.audio_metadata)
}

// bool is_final_chunk = 3;
inline void STTChunkPayload::clear_is_final_chunk() {
  _impl_.is_final_chunk_ = false;
}
inline bool STTChunkPayload::_internal_is_final_chunk() const {
  return _impl_.is_final_chunk_;
}
inline bool STTChunkPayload::is_final_chunk() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.STTChunkPayload.is_final_chunk)
  return _internal_is_final_chunk();
}
inline void STTChunkPayload::_internal_set_is_final_chunk(bool value) {
  
  _impl_.is_final_chunk_ = value;
}
inline void STTChunkPayload::set_is_final_chunk(bool value) {
  _internal_set_is_final_chunk(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.STTChunkPayload.is_final_chunk)
}

// -------------------------------------------------------------------

// AudioMetadata

// .unhinged.audio.v1.AudioFormat format = 1;
inline void AudioMetadata::clear_format() {
  _impl_.format_ = 0;
}
inline ::unhinged::audio::v1::AudioFormat AudioMetadata::_internal_format() const {
  return static_cast< ::unhinged::audio::v1::AudioFormat >(_impl_.format_);
}
inline ::unhinged::audio::v1::AudioFormat AudioMetadata::format() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.AudioMetadata.format)
  return _internal_format();
}
inline void AudioMetadata::_internal_set_format(::unhinged::audio::v1::AudioFormat value) {
  
  _impl_.format_ = value;
}
inline void AudioMetadata::set_format(::unhinged::audio::v1::AudioFormat value) {
  _internal_set_format(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.AudioMetadata.format)
}

// int32 sample_rate = 2;
inline void AudioMetadata::clear_sample_rate() {
  _impl_.sample_rate_ = 0;
}
inline int32_t AudioMetadata::_internal_sample_rate() const {
  return _impl_.sample_rate_;
}
inline int32_t AudioMetadata::sample_rate() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.AudioMetadata.sample_rate)
  return _internal_sample_rate();
}
inline void AudioMetadata::_internal_set_sample_rate(int32_t value) {
  
  _impl_.sample_rate_ = value;
}
inline void AudioMetadata::set_sample_rate(int32_t value) {
  _internal_set_sample_rate(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.AudioMetadata.sample_rate)
}

// int32 channels = 3;
inline void AudioMetadata::clear_channels() {
  _impl_.channels_ = 0;
}
inline int32_t AudioMetadata::_internal_channels() const {
  return _impl_.channels_;
}
inline int32_t AudioMetadata::channels() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.AudioMetadata.channels)
  return _internal_channels();
}
inline void AudioMetadata::_internal_set_channels(int32_t value) {
  
  _impl_.channels_ = value;
}
inline void AudioMetadata::set_channels(int32_t value) {
  _internal_set_channels(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.AudioMetadata.channels)
}

// int32 bit_depth = 4;
inline void AudioMetadata::clear_bit_depth() {
  _impl_.bit_depth_ = 0;
}
inline int32_t AudioMetadata::_internal_bit_depth() const {
  return _impl_.bit_depth_;
}
inline int32_t AudioMetadata::bit_depth() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.AudioMetadata.bit_depth)
  return _internal_bit_depth();
}
inline void AudioMetadata::_internal_set_bit_depth(int32_t value) {
  
  _impl_.bit_depth_ = value;
}
inline void AudioMetadata::set_bit_depth(int32_t value) {
  _internal_set_bit_depth(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.AudioMetadata.bit_depth)
}

// float duration_seconds = 5;
inline void AudioMetadata::clear_duration_seconds() {
  _impl_.duration_seconds_ = 0;
}
inline float AudioMetadata::_internal_duration_seconds() const {
  return _impl_.duration_seconds_;
}
inline float AudioMetadata::duration_seconds() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.AudioMetadata.duration_seconds)
  return _internal_duration_seconds();
}
inline void AudioMetadata::_internal_set_duration_seconds(float value) {
  
  _impl_.duration_seconds_ = value;
}
inline void AudioMetadata::set_duration_seconds(float value) {
  _internal_set_duration_seconds(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.AudioMetadata.duration_seconds)
}

// int64 total_bytes = 6;
inline void AudioMetadata::clear_total_bytes() {
  _impl_.total_bytes_ = int64_t{0};
}
inline int64_t AudioMetadata::_internal_total_bytes() const {
  return _impl_.total_bytes_;
}
inline int64_t AudioMetadata::total_bytes() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.AudioMetadata.total_bytes)
  return _internal_total_bytes();
}
inline void AudioMetadata::_internal_set_total_bytes(int64_t value) {
  
  _impl_.total_bytes_ = value;
}
inline void AudioMetadata::set_total_bytes(int64_t value) {
  _internal_set_total_bytes(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.AudioMetadata.total_bytes)
}

// -------------------------------------------------------------------

// ProcessAudioRequest

// .unhinged.common.v1.Attachment audio_file = 1;
inline bool ProcessAudioRequest::_internal_has_audio_file() const {
  return this != internal_default_instance() && _impl_.audio_file_ != nullptr;
}
inline bool ProcessAudioRequest::has_audio_file() const {
  return _internal_has_audio_file();
}
inline const ::unhinged::common::v1::Attachment& ProcessAudioRequest::_internal_audio_file() const {
  const ::unhinged::common::v1::Attachment* p = _impl_.audio_file_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::common::v1::Attachment&>(
      ::unhinged::common::v1::_Attachment_default_instance_);
}
inline const ::unhinged::common::v1::Attachment& ProcessAudioRequest::audio_file() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.ProcessAudioRequest.audio_file)
  return _internal_audio_file();
}
inline void ProcessAudioRequest::unsafe_arena_set_allocated_audio_file(
    ::unhinged::common::v1::Attachment* audio_file) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.audio_file_);
  }
  _impl_.audio_file_ = audio_file;
  if (audio_file) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.audio.v1.ProcessAudioRequest.audio_file)
}
inline ::unhinged::common::v1::Attachment* ProcessAudioRequest::release_audio_file() {
  
  ::unhinged::common::v1::Attachment* temp = _impl_.audio_file_;
  _impl_.audio_file_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::common::v1::Attachment* ProcessAudioRequest::unsafe_arena_release_audio_file() {
  // @@protoc_insertion_point(field_release:unhinged.audio.v1.ProcessAudioRequest.audio_file)
  
  ::unhinged::common::v1::Attachment* temp = _impl_.audio_file_;
  _impl_.audio_file_ = nullptr;
  return temp;
}
inline ::unhinged::common::v1::Attachment* ProcessAudioRequest::_internal_mutable_audio_file() {
  
  if (_impl_.audio_file_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::common::v1::Attachment>(GetArenaForAllocation());
    _impl_.audio_file_ = p;
  }
  return _impl_.audio_file_;
}
inline ::unhinged::common::v1::Attachment* ProcessAudioRequest::mutable_audio_file() {
  ::unhinged::common::v1::Attachment* _msg = _internal_mutable_audio_file();
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.ProcessAudioRequest.audio_file)
  return _msg;
}
inline void ProcessAudioRequest::set_allocated_audio_file(::unhinged::common::v1::Attachment* audio_file) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.audio_file_);
  }
  if (audio_file) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(audio_file));
    if (message_arena != submessage_arena) {
      audio_file = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, audio_file, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.audio_file_ = audio_file;
  // @@protoc_insertion_point(field_set_allocated:unhinged.audio.v1.ProcessAudioRequest.audio_file)
}

// .unhinged.audio.v1.ProcessingType processing_type = 2;
inline void ProcessAudioRequest::clear_processing_type() {
  _impl_.processing_type_ = 0;
}
inline ::unhinged::audio::v1::ProcessingType ProcessAudioRequest::_internal_processing_type() const {
  return static_cast< ::unhinged::audio::v1::ProcessingType >(_impl_.processing_type_);
}
inline ::unhinged::audio::v1::ProcessingType ProcessAudioRequest::processing_type() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.ProcessAudioRequest.processing_type)
  return _internal_processing_type();
}
inline void ProcessAudioRequest::_internal_set_processing_type(::unhinged::audio::v1::ProcessingType value) {
  
  _impl_.processing_type_ = value;
}
inline void ProcessAudioRequest::set_processing_type(::unhinged::audio::v1::ProcessingType value) {
  _internal_set_processing_type(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.ProcessAudioRequest.processing_type)
}

// .unhinged.audio.v1.AudioOptions options = 3;
inline bool ProcessAudioRequest::_internal_has_options() const {
  return this != internal_default_instance() && _impl_.options_ != nullptr;
}
inline bool ProcessAudioRequest::has_options() const {
  return _internal_has_options();
}
inline void ProcessAudioRequest::clear_options() {
  if (GetArenaForAllocation() == nullptr && _impl_.options_ != nullptr) {
    delete _impl_.options_;
  }
  _impl_.options_ = nullptr;
}
inline const ::unhinged::audio::v1::AudioOptions& ProcessAudioRequest::_internal_options() const {
  const ::unhinged::audio::v1::AudioOptions* p = _impl_.options_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::audio::v1::AudioOptions&>(
      ::unhinged::audio::v1::_AudioOptions_default_instance_);
}
inline const ::unhinged::audio::v1::AudioOptions& ProcessAudioRequest::options() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.ProcessAudioRequest.options)
  return _internal_options();
}
inline void ProcessAudioRequest::unsafe_arena_set_allocated_options(
    ::unhinged::audio::v1::AudioOptions* options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.options_);
  }
  _impl_.options_ = options;
  if (options) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.audio.v1.ProcessAudioRequest.options)
}
inline ::unhinged::audio::v1::AudioOptions* ProcessAudioRequest::release_options() {
  
  ::unhinged::audio::v1::AudioOptions* temp = _impl_.options_;
  _impl_.options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::audio::v1::AudioOptions* ProcessAudioRequest::unsafe_arena_release_options() {
  // @@protoc_insertion_point(field_release:unhinged.audio.v1.ProcessAudioRequest.options)
  
  ::unhinged::audio::v1::AudioOptions* temp = _impl_.options_;
  _impl_.options_ = nullptr;
  return temp;
}
inline ::unhinged::audio::v1::AudioOptions* ProcessAudioRequest::_internal_mutable_options() {
  
  if (_impl_.options_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::audio::v1::AudioOptions>(GetArenaForAllocation());
    _impl_.options_ = p;
  }
  return _impl_.options_;
}
inline ::unhinged::audio::v1::AudioOptions* ProcessAudioRequest::mutable_options() {
  ::unhinged::audio::v1::AudioOptions* _msg = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.ProcessAudioRequest.options)
  return _msg;
}
inline void ProcessAudioRequest::set_allocated_options(::unhinged::audio::v1::AudioOptions* options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.options_;
  }
  if (options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(options);
    if (message_arena != submessage_arena) {
      options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.options_ = options;
  // @@protoc_insertion_point(field_set_allocated:unhinged.audio.v1.ProcessAudioRequest.options)
}

// -------------------------------------------------------------------

// ProcessAudioResponse

// .unhinged.common.v1.StandardResponse response = 1;
inline bool ProcessAudioResponse::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool ProcessAudioResponse::has_response() const {
  return _internal_has_response();
}
inline const ::unhinged::common::v1::StandardResponse& ProcessAudioResponse::_internal_response() const {
  const ::unhinged::common::v1::StandardResponse* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::common::v1::StandardResponse&>(
      ::unhinged::common::v1::_StandardResponse_default_instance_);
}
inline const ::unhinged::common::v1::StandardResponse& ProcessAudioResponse::response() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.ProcessAudioResponse.response)
  return _internal_response();
}
inline void ProcessAudioResponse::unsafe_arena_set_allocated_response(
    ::unhinged::common::v1::StandardResponse* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.audio.v1.ProcessAudioResponse.response)
}
inline ::unhinged::common::v1::StandardResponse* ProcessAudioResponse::release_response() {
  
  ::unhinged::common::v1::StandardResponse* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::common::v1::StandardResponse* ProcessAudioResponse::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:unhinged.audio.v1.ProcessAudioResponse.response)
  
  ::unhinged::common::v1::StandardResponse* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::unhinged::common::v1::StandardResponse* ProcessAudioResponse::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::common::v1::StandardResponse>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::unhinged::common::v1::StandardResponse* ProcessAudioResponse::mutable_response() {
  ::unhinged::common::v1::StandardResponse* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.ProcessAudioResponse.response)
  return _msg;
}
inline void ProcessAudioResponse::set_allocated_response(::unhinged::common::v1::StandardResponse* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:unhinged.audio.v1.ProcessAudioResponse.response)
}

// string transcript = 2;
inline bool ProcessAudioResponse::_internal_has_transcript() const {
  return result_case() == kTranscript;
}
inline bool ProcessAudioResponse::has_transcript() const {
  return _internal_has_transcript();
}
inline void ProcessAudioResponse::set_has_transcript() {
  _impl_._oneof_case_[0] = kTranscript;
}
inline void ProcessAudioResponse::clear_transcript() {
  if (_internal_has_transcript()) {
    _impl_.result_.transcript_.Destroy();
    clear_has_result();
  }
}
inline const std::string& ProcessAudioResponse::transcript() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.ProcessAudioResponse.transcript)
  return _internal_transcript();
}
template <typename ArgT0, typename... ArgT>
inline void ProcessAudioResponse::set_transcript(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_transcript()) {
    clear_result();
    set_has_transcript();
    _impl_.result_.transcript_.InitDefault();
  }
  _impl_.result_.transcript_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.ProcessAudioResponse.transcript)
}
inline std::string* ProcessAudioResponse::mutable_transcript() {
  std::string* _s = _internal_mutable_transcript();
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.ProcessAudioResponse.transcript)
  return _s;
}
inline const std::string& ProcessAudioResponse::_internal_transcript() const {
  if (_internal_has_transcript()) {
    return _impl_.result_.transcript_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void ProcessAudioResponse::_internal_set_transcript(const std::string& value) {
  if (!_internal_has_transcript()) {
    clear_result();
    set_has_transcript();
    _impl_.result_.transcript_.InitDefault();
  }
  _impl_.result_.transcript_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessAudioResponse::_internal_mutable_transcript() {
  if (!_internal_has_transcript()) {
    clear_result();
    set_has_transcript();
    _impl_.result_.transcript_.InitDefault();
  }
  return _impl_.result_.transcript_.Mutable(      GetArenaForAllocation());
}
inline std::string* ProcessAudioResponse::release_transcript() {
  // @@protoc_insertion_point(field_release:unhinged.audio.v1.ProcessAudioResponse.transcript)
  if (_internal_has_transcript()) {
    clear_has_result();
    return _impl_.result_.transcript_.Release();
  } else {
    return nullptr;
  }
}
inline void ProcessAudioResponse::set_allocated_transcript(std::string* transcript) {
  if (has_result()) {
    clear_result();
  }
  if (transcript != nullptr) {
    set_has_transcript();
    _impl_.result_.transcript_.InitAllocated(transcript, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:unhinged.audio.v1.ProcessAudioResponse.transcript)
}

// string translation = 3;
inline bool ProcessAudioResponse::_internal_has_translation() const {
  return result_case() == kTranslation;
}
inline bool ProcessAudioResponse::has_translation() const {
  return _internal_has_translation();
}
inline void ProcessAudioResponse::set_has_translation() {
  _impl_._oneof_case_[0] = kTranslation;
}
inline void ProcessAudioResponse::clear_translation() {
  if (_internal_has_translation()) {
    _impl_.result_.translation_.Destroy();
    clear_has_result();
  }
}
inline const std::string& ProcessAudioResponse::translation() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.ProcessAudioResponse.translation)
  return _internal_translation();
}
template <typename ArgT0, typename... ArgT>
inline void ProcessAudioResponse::set_translation(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_translation()) {
    clear_result();
    set_has_translation();
    _impl_.result_.translation_.InitDefault();
  }
  _impl_.result_.translation_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.ProcessAudioResponse.translation)
}
inline std::string* ProcessAudioResponse::mutable_translation() {
  std::string* _s = _internal_mutable_translation();
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.ProcessAudioResponse.translation)
  return _s;
}
inline const std::string& ProcessAudioResponse::_internal_translation() const {
  if (_internal_has_translation()) {
    return _impl_.result_.translation_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void ProcessAudioResponse::_internal_set_translation(const std::string& value) {
  if (!_internal_has_translation()) {
    clear_result();
    set_has_translation();
    _impl_.result_.translation_.InitDefault();
  }
  _impl_.result_.translation_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessAudioResponse::_internal_mutable_translation() {
  if (!_internal_has_translation()) {
    clear_result();
    set_has_translation();
    _impl_.result_.translation_.InitDefault();
  }
  return _impl_.result_.translation_.Mutable(      GetArenaForAllocation());
}
inline std::string* ProcessAudioResponse::release_translation() {
  // @@protoc_insertion_point(field_release:unhinged.audio.v1.ProcessAudioResponse.translation)
  if (_internal_has_translation()) {
    clear_has_result();
    return _impl_.result_.translation_.Release();
  } else {
    return nullptr;
  }
}
inline void ProcessAudioResponse::set_allocated_translation(std::string* translation) {
  if (has_result()) {
    clear_result();
  }
  if (translation != nullptr) {
    set_has_translation();
    _impl_.result_.translation_.InitAllocated(translation, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:unhinged.audio.v1.ProcessAudioResponse.translation)
}

// .unhinged.common.v1.Attachment enhanced_audio = 4;
inline bool ProcessAudioResponse::_internal_has_enhanced_audio() const {
  return result_case() == kEnhancedAudio;
}
inline bool ProcessAudioResponse::has_enhanced_audio() const {
  return _internal_has_enhanced_audio();
}
inline void ProcessAudioResponse::set_has_enhanced_audio() {
  _impl_._oneof_case_[0] = kEnhancedAudio;
}
inline ::unhinged::common::v1::Attachment* ProcessAudioResponse::release_enhanced_audio() {
  // @@protoc_insertion_point(field_release:unhinged.audio.v1.ProcessAudioResponse.enhanced_audio)
  if (_internal_has_enhanced_audio()) {
    clear_has_result();
    ::unhinged::common::v1::Attachment* temp = _impl_.result_.enhanced_audio_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.result_.enhanced_audio_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::common::v1::Attachment& ProcessAudioResponse::_internal_enhanced_audio() const {
  return _internal_has_enhanced_audio()
      ? *_impl_.result_.enhanced_audio_
      : reinterpret_cast< ::unhinged::common::v1::Attachment&>(::unhinged::common::v1::_Attachment_default_instance_);
}
inline const ::unhinged::common::v1::Attachment& ProcessAudioResponse::enhanced_audio() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.ProcessAudioResponse.enhanced_audio)
  return _internal_enhanced_audio();
}
inline ::unhinged::common::v1::Attachment* ProcessAudioResponse::unsafe_arena_release_enhanced_audio() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.audio.v1.ProcessAudioResponse.enhanced_audio)
  if (_internal_has_enhanced_audio()) {
    clear_has_result();
    ::unhinged::common::v1::Attachment* temp = _impl_.result_.enhanced_audio_;
    _impl_.result_.enhanced_audio_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProcessAudioResponse::unsafe_arena_set_allocated_enhanced_audio(::unhinged::common::v1::Attachment* enhanced_audio) {
  clear_result();
  if (enhanced_audio) {
    set_has_enhanced_audio();
    _impl_.result_.enhanced_audio_ = enhanced_audio;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.audio.v1.ProcessAudioResponse.enhanced_audio)
}
inline ::unhinged::common::v1::Attachment* ProcessAudioResponse::_internal_mutable_enhanced_audio() {
  if (!_internal_has_enhanced_audio()) {
    clear_result();
    set_has_enhanced_audio();
    _impl_.result_.enhanced_audio_ = CreateMaybeMessage< ::unhinged::common::v1::Attachment >(GetArenaForAllocation());
  }
  return _impl_.result_.enhanced_audio_;
}
inline ::unhinged::common::v1::Attachment* ProcessAudioResponse::mutable_enhanced_audio() {
  ::unhinged::common::v1::Attachment* _msg = _internal_mutable_enhanced_audio();
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.ProcessAudioResponse.enhanced_audio)
  return _msg;
}

// .unhinged.common.v1.Attachment converted_audio = 5;
inline bool ProcessAudioResponse::_internal_has_converted_audio() const {
  return result_case() == kConvertedAudio;
}
inline bool ProcessAudioResponse::has_converted_audio() const {
  return _internal_has_converted_audio();
}
inline void ProcessAudioResponse::set_has_converted_audio() {
  _impl_._oneof_case_[0] = kConvertedAudio;
}
inline ::unhinged::common::v1::Attachment* ProcessAudioResponse::release_converted_audio() {
  // @@protoc_insertion_point(field_release:unhinged.audio.v1.ProcessAudioResponse.converted_audio)
  if (_internal_has_converted_audio()) {
    clear_has_result();
    ::unhinged::common::v1::Attachment* temp = _impl_.result_.converted_audio_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.result_.converted_audio_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::common::v1::Attachment& ProcessAudioResponse::_internal_converted_audio() const {
  return _internal_has_converted_audio()
      ? *_impl_.result_.converted_audio_
      : reinterpret_cast< ::unhinged::common::v1::Attachment&>(::unhinged::common::v1::_Attachment_default_instance_);
}
inline const ::unhinged::common::v1::Attachment& ProcessAudioResponse::converted_audio() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.ProcessAudioResponse.converted_audio)
  return _internal_converted_audio();
}
inline ::unhinged::common::v1::Attachment* ProcessAudioResponse::unsafe_arena_release_converted_audio() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.audio.v1.ProcessAudioResponse.converted_audio)
  if (_internal_has_converted_audio()) {
    clear_has_result();
    ::unhinged::common::v1::Attachment* temp = _impl_.result_.converted_audio_;
    _impl_.result_.converted_audio_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProcessAudioResponse::unsafe_arena_set_allocated_converted_audio(::unhinged::common::v1::Attachment* converted_audio) {
  clear_result();
  if (converted_audio) {
    set_has_converted_audio();
    _impl_.result_.converted_audio_ = converted_audio;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.audio.v1.ProcessAudioResponse.converted_audio)
}
inline ::unhinged::common::v1::Attachment* ProcessAudioResponse::_internal_mutable_converted_audio() {
  if (!_internal_has_converted_audio()) {
    clear_result();
    set_has_converted_audio();
    _impl_.result_.converted_audio_ = CreateMaybeMessage< ::unhinged::common::v1::Attachment >(GetArenaForAllocation());
  }
  return _impl_.result_.converted_audio_;
}
inline ::unhinged::common::v1::Attachment* ProcessAudioResponse::mutable_converted_audio() {
  ::unhinged::common::v1::Attachment* _msg = _internal_mutable_converted_audio();
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.ProcessAudioResponse.converted_audio)
  return _msg;
}

// .unhinged.common.v1.AudioUsage usage = 6;
inline bool ProcessAudioResponse::_internal_has_usage() const {
  return this != internal_default_instance() && _impl_.usage_ != nullptr;
}
inline bool ProcessAudioResponse::has_usage() const {
  return _internal_has_usage();
}
inline const ::unhinged::common::v1::AudioUsage& ProcessAudioResponse::_internal_usage() const {
  const ::unhinged::common::v1::AudioUsage* p = _impl_.usage_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::common::v1::AudioUsage&>(
      ::unhinged::common::v1::_AudioUsage_default_instance_);
}
inline const ::unhinged::common::v1::AudioUsage& ProcessAudioResponse::usage() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.ProcessAudioResponse.usage)
  return _internal_usage();
}
inline void ProcessAudioResponse::unsafe_arena_set_allocated_usage(
    ::unhinged::common::v1::AudioUsage* usage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.usage_);
  }
  _impl_.usage_ = usage;
  if (usage) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.audio.v1.ProcessAudioResponse.usage)
}
inline ::unhinged::common::v1::AudioUsage* ProcessAudioResponse::release_usage() {
  
  ::unhinged::common::v1::AudioUsage* temp = _impl_.usage_;
  _impl_.usage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::common::v1::AudioUsage* ProcessAudioResponse::unsafe_arena_release_usage() {
  // @@protoc_insertion_point(field_release:unhinged.audio.v1.ProcessAudioResponse.usage)
  
  ::unhinged::common::v1::AudioUsage* temp = _impl_.usage_;
  _impl_.usage_ = nullptr;
  return temp;
}
inline ::unhinged::common::v1::AudioUsage* ProcessAudioResponse::_internal_mutable_usage() {
  
  if (_impl_.usage_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::common::v1::AudioUsage>(GetArenaForAllocation());
    _impl_.usage_ = p;
  }
  return _impl_.usage_;
}
inline ::unhinged::common::v1::AudioUsage* ProcessAudioResponse::mutable_usage() {
  ::unhinged::common::v1::AudioUsage* _msg = _internal_mutable_usage();
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.ProcessAudioResponse.usage)
  return _msg;
}
inline void ProcessAudioResponse::set_allocated_usage(::unhinged::common::v1::AudioUsage* usage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.usage_);
  }
  if (usage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(usage));
    if (message_arena != submessage_arena) {
      usage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, usage, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.usage_ = usage;
  // @@protoc_insertion_point(field_set_allocated:unhinged.audio.v1.ProcessAudioResponse.usage)
}

inline bool ProcessAudioResponse::has_result() const {
  return result_case() != RESULT_NOT_SET;
}
inline void ProcessAudioResponse::clear_has_result() {
  _impl_._oneof_case_[0] = RESULT_NOT_SET;
}
inline ProcessAudioResponse::ResultCase ProcessAudioResponse::result_case() const {
  return ProcessAudioResponse::ResultCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ListVoicesRequest

// string language = 1;
inline void ListVoicesRequest::clear_language() {
  _impl_.language_.ClearToEmpty();
}
inline const std::string& ListVoicesRequest::language() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.ListVoicesRequest.language)
  return _internal_language();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListVoicesRequest::set_language(ArgT0&& arg0, ArgT... args) {
 
 _impl_.language_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.ListVoicesRequest.language)
}
inline std::string* ListVoicesRequest::mutable_language() {
  std::string* _s = _internal_mutable_language();
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.ListVoicesRequest.language)
  return _s;
}
inline const std::string& ListVoicesRequest::_internal_language() const {
  return _impl_.language_.Get();
}
inline void ListVoicesRequest::_internal_set_language(const std::string& value) {
  
  _impl_.language_.Set(value, GetArenaForAllocation());
}
inline std::string* ListVoicesRequest::_internal_mutable_language() {
  
  return _impl_.language_.Mutable(GetArenaForAllocation());
}
inline std::string* ListVoicesRequest::release_language() {
  // @@protoc_insertion_point(field_release:unhinged.audio.v1.ListVoicesRequest.language)
  return _impl_.language_.Release();
}
inline void ListVoicesRequest::set_allocated_language(std::string* language) {
  if (language != nullptr) {
    
  } else {
    
  }
  _impl_.language_.SetAllocated(language, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.language_.IsDefault()) {
    _impl_.language_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.audio.v1.ListVoicesRequest.language)
}

// .unhinged.audio.v1.VoiceGender gender = 2;
inline void ListVoicesRequest::clear_gender() {
  _impl_.gender_ = 0;
}
inline ::unhinged::audio::v1::VoiceGender ListVoicesRequest::_internal_gender() const {
  return static_cast< ::unhinged::audio::v1::VoiceGender >(_impl_.gender_);
}
inline ::unhinged::audio::v1::VoiceGender ListVoicesRequest::gender() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.ListVoicesRequest.gender)
  return _internal_gender();
}
inline void ListVoicesRequest::_internal_set_gender(::unhinged::audio::v1::VoiceGender value) {
  
  _impl_.gender_ = value;
}
inline void ListVoicesRequest::set_gender(::unhinged::audio::v1::VoiceGender value) {
  _internal_set_gender(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.ListVoicesRequest.gender)
}

// .unhinged.audio.v1.VoiceStyle style = 3;
inline void ListVoicesRequest::clear_style() {
  _impl_.style_ = 0;
}
inline ::unhinged::audio::v1::VoiceStyle ListVoicesRequest::_internal_style() const {
  return static_cast< ::unhinged::audio::v1::VoiceStyle >(_impl_.style_);
}
inline ::unhinged::audio::v1::VoiceStyle ListVoicesRequest::style() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.ListVoicesRequest.style)
  return _internal_style();
}
inline void ListVoicesRequest::_internal_set_style(::unhinged::audio::v1::VoiceStyle value) {
  
  _impl_.style_ = value;
}
inline void ListVoicesRequest::set_style(::unhinged::audio::v1::VoiceStyle value) {
  _internal_set_style(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.ListVoicesRequest.style)
}

// bool premium_only = 4;
inline void ListVoicesRequest::clear_premium_only() {
  _impl_.premium_only_ = false;
}
inline bool ListVoicesRequest::_internal_premium_only() const {
  return _impl_.premium_only_;
}
inline bool ListVoicesRequest::premium_only() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.ListVoicesRequest.premium_only)
  return _internal_premium_only();
}
inline void ListVoicesRequest::_internal_set_premium_only(bool value) {
  
  _impl_.premium_only_ = value;
}
inline void ListVoicesRequest::set_premium_only(bool value) {
  _internal_set_premium_only(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.ListVoicesRequest.premium_only)
}

// .unhinged.common.v1.PaginationRequest pagination = 5;
inline bool ListVoicesRequest::_internal_has_pagination() const {
  return this != internal_default_instance() && _impl_.pagination_ != nullptr;
}
inline bool ListVoicesRequest::has_pagination() const {
  return _internal_has_pagination();
}
inline const ::unhinged::common::v1::PaginationRequest& ListVoicesRequest::_internal_pagination() const {
  const ::unhinged::common::v1::PaginationRequest* p = _impl_.pagination_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::common::v1::PaginationRequest&>(
      ::unhinged::common::v1::_PaginationRequest_default_instance_);
}
inline const ::unhinged::common::v1::PaginationRequest& ListVoicesRequest::pagination() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.ListVoicesRequest.pagination)
  return _internal_pagination();
}
inline void ListVoicesRequest::unsafe_arena_set_allocated_pagination(
    ::unhinged::common::v1::PaginationRequest* pagination) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pagination_);
  }
  _impl_.pagination_ = pagination;
  if (pagination) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.audio.v1.ListVoicesRequest.pagination)
}
inline ::unhinged::common::v1::PaginationRequest* ListVoicesRequest::release_pagination() {
  
  ::unhinged::common::v1::PaginationRequest* temp = _impl_.pagination_;
  _impl_.pagination_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::common::v1::PaginationRequest* ListVoicesRequest::unsafe_arena_release_pagination() {
  // @@protoc_insertion_point(field_release:unhinged.audio.v1.ListVoicesRequest.pagination)
  
  ::unhinged::common::v1::PaginationRequest* temp = _impl_.pagination_;
  _impl_.pagination_ = nullptr;
  return temp;
}
inline ::unhinged::common::v1::PaginationRequest* ListVoicesRequest::_internal_mutable_pagination() {
  
  if (_impl_.pagination_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::common::v1::PaginationRequest>(GetArenaForAllocation());
    _impl_.pagination_ = p;
  }
  return _impl_.pagination_;
}
inline ::unhinged::common::v1::PaginationRequest* ListVoicesRequest::mutable_pagination() {
  ::unhinged::common::v1::PaginationRequest* _msg = _internal_mutable_pagination();
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.ListVoicesRequest.pagination)
  return _msg;
}
inline void ListVoicesRequest::set_allocated_pagination(::unhinged::common::v1::PaginationRequest* pagination) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pagination_);
  }
  if (pagination) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pagination));
    if (message_arena != submessage_arena) {
      pagination = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pagination, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pagination_ = pagination;
  // @@protoc_insertion_point(field_set_allocated:unhinged.audio.v1.ListVoicesRequest.pagination)
}

// repeated .unhinged.common.v1.Filter filters = 6;
inline int ListVoicesRequest::_internal_filters_size() const {
  return _impl_.filters_.size();
}
inline int ListVoicesRequest::filters_size() const {
  return _internal_filters_size();
}
inline ::unhinged::common::v1::Filter* ListVoicesRequest::mutable_filters(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.ListVoicesRequest.filters)
  return _impl_.filters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::common::v1::Filter >*
ListVoicesRequest::mutable_filters() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.audio.v1.ListVoicesRequest.filters)
  return &_impl_.filters_;
}
inline const ::unhinged::common::v1::Filter& ListVoicesRequest::_internal_filters(int index) const {
  return _impl_.filters_.Get(index);
}
inline const ::unhinged::common::v1::Filter& ListVoicesRequest::filters(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.ListVoicesRequest.filters)
  return _internal_filters(index);
}
inline ::unhinged::common::v1::Filter* ListVoicesRequest::_internal_add_filters() {
  return _impl_.filters_.Add();
}
inline ::unhinged::common::v1::Filter* ListVoicesRequest::add_filters() {
  ::unhinged::common::v1::Filter* _add = _internal_add_filters();
  // @@protoc_insertion_point(field_add:unhinged.audio.v1.ListVoicesRequest.filters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::common::v1::Filter >&
ListVoicesRequest::filters() const {
  // @@protoc_insertion_point(field_list:unhinged.audio.v1.ListVoicesRequest.filters)
  return _impl_.filters_;
}

// -------------------------------------------------------------------

// ListVoicesResponse

// .unhinged.common.v1.StandardResponse response = 1;
inline bool ListVoicesResponse::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool ListVoicesResponse::has_response() const {
  return _internal_has_response();
}
inline const ::unhinged::common::v1::StandardResponse& ListVoicesResponse::_internal_response() const {
  const ::unhinged::common::v1::StandardResponse* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::common::v1::StandardResponse&>(
      ::unhinged::common::v1::_StandardResponse_default_instance_);
}
inline const ::unhinged::common::v1::StandardResponse& ListVoicesResponse::response() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.ListVoicesResponse.response)
  return _internal_response();
}
inline void ListVoicesResponse::unsafe_arena_set_allocated_response(
    ::unhinged::common::v1::StandardResponse* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.audio.v1.ListVoicesResponse.response)
}
inline ::unhinged::common::v1::StandardResponse* ListVoicesResponse::release_response() {
  
  ::unhinged::common::v1::StandardResponse* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::common::v1::StandardResponse* ListVoicesResponse::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:unhinged.audio.v1.ListVoicesResponse.response)
  
  ::unhinged::common::v1::StandardResponse* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::unhinged::common::v1::StandardResponse* ListVoicesResponse::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::common::v1::StandardResponse>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::unhinged::common::v1::StandardResponse* ListVoicesResponse::mutable_response() {
  ::unhinged::common::v1::StandardResponse* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.ListVoicesResponse.response)
  return _msg;
}
inline void ListVoicesResponse::set_allocated_response(::unhinged::common::v1::StandardResponse* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:unhinged.audio.v1.ListVoicesResponse.response)
}

// repeated .unhinged.audio.v1.Voice voices = 2;
inline int ListVoicesResponse::_internal_voices_size() const {
  return _impl_.voices_.size();
}
inline int ListVoicesResponse::voices_size() const {
  return _internal_voices_size();
}
inline void ListVoicesResponse::clear_voices() {
  _impl_.voices_.Clear();
}
inline ::unhinged::audio::v1::Voice* ListVoicesResponse::mutable_voices(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.ListVoicesResponse.voices)
  return _impl_.voices_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::audio::v1::Voice >*
ListVoicesResponse::mutable_voices() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.audio.v1.ListVoicesResponse.voices)
  return &_impl_.voices_;
}
inline const ::unhinged::audio::v1::Voice& ListVoicesResponse::_internal_voices(int index) const {
  return _impl_.voices_.Get(index);
}
inline const ::unhinged::audio::v1::Voice& ListVoicesResponse::voices(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.ListVoicesResponse.voices)
  return _internal_voices(index);
}
inline ::unhinged::audio::v1::Voice* ListVoicesResponse::_internal_add_voices() {
  return _impl_.voices_.Add();
}
inline ::unhinged::audio::v1::Voice* ListVoicesResponse::add_voices() {
  ::unhinged::audio::v1::Voice* _add = _internal_add_voices();
  // @@protoc_insertion_point(field_add:unhinged.audio.v1.ListVoicesResponse.voices)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::audio::v1::Voice >&
ListVoicesResponse::voices() const {
  // @@protoc_insertion_point(field_list:unhinged.audio.v1.ListVoicesResponse.voices)
  return _impl_.voices_;
}

// .unhinged.common.v1.PaginationResponse pagination = 3;
inline bool ListVoicesResponse::_internal_has_pagination() const {
  return this != internal_default_instance() && _impl_.pagination_ != nullptr;
}
inline bool ListVoicesResponse::has_pagination() const {
  return _internal_has_pagination();
}
inline const ::unhinged::common::v1::PaginationResponse& ListVoicesResponse::_internal_pagination() const {
  const ::unhinged::common::v1::PaginationResponse* p = _impl_.pagination_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::common::v1::PaginationResponse&>(
      ::unhinged::common::v1::_PaginationResponse_default_instance_);
}
inline const ::unhinged::common::v1::PaginationResponse& ListVoicesResponse::pagination() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.ListVoicesResponse.pagination)
  return _internal_pagination();
}
inline void ListVoicesResponse::unsafe_arena_set_allocated_pagination(
    ::unhinged::common::v1::PaginationResponse* pagination) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pagination_);
  }
  _impl_.pagination_ = pagination;
  if (pagination) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.audio.v1.ListVoicesResponse.pagination)
}
inline ::unhinged::common::v1::PaginationResponse* ListVoicesResponse::release_pagination() {
  
  ::unhinged::common::v1::PaginationResponse* temp = _impl_.pagination_;
  _impl_.pagination_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::common::v1::PaginationResponse* ListVoicesResponse::unsafe_arena_release_pagination() {
  // @@protoc_insertion_point(field_release:unhinged.audio.v1.ListVoicesResponse.pagination)
  
  ::unhinged::common::v1::PaginationResponse* temp = _impl_.pagination_;
  _impl_.pagination_ = nullptr;
  return temp;
}
inline ::unhinged::common::v1::PaginationResponse* ListVoicesResponse::_internal_mutable_pagination() {
  
  if (_impl_.pagination_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::common::v1::PaginationResponse>(GetArenaForAllocation());
    _impl_.pagination_ = p;
  }
  return _impl_.pagination_;
}
inline ::unhinged::common::v1::PaginationResponse* ListVoicesResponse::mutable_pagination() {
  ::unhinged::common::v1::PaginationResponse* _msg = _internal_mutable_pagination();
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.ListVoicesResponse.pagination)
  return _msg;
}
inline void ListVoicesResponse::set_allocated_pagination(::unhinged::common::v1::PaginationResponse* pagination) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pagination_);
  }
  if (pagination) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pagination));
    if (message_arena != submessage_arena) {
      pagination = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pagination, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pagination_ = pagination;
  // @@protoc_insertion_point(field_set_allocated:unhinged.audio.v1.ListVoicesResponse.pagination)
}

// -------------------------------------------------------------------

// GetVoiceRequest

// string voice_id = 1;
inline void GetVoiceRequest::clear_voice_id() {
  _impl_.voice_id_.ClearToEmpty();
}
inline const std::string& GetVoiceRequest::voice_id() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.GetVoiceRequest.voice_id)
  return _internal_voice_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetVoiceRequest::set_voice_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.voice_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.GetVoiceRequest.voice_id)
}
inline std::string* GetVoiceRequest::mutable_voice_id() {
  std::string* _s = _internal_mutable_voice_id();
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.GetVoiceRequest.voice_id)
  return _s;
}
inline const std::string& GetVoiceRequest::_internal_voice_id() const {
  return _impl_.voice_id_.Get();
}
inline void GetVoiceRequest::_internal_set_voice_id(const std::string& value) {
  
  _impl_.voice_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetVoiceRequest::_internal_mutable_voice_id() {
  
  return _impl_.voice_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetVoiceRequest::release_voice_id() {
  // @@protoc_insertion_point(field_release:unhinged.audio.v1.GetVoiceRequest.voice_id)
  return _impl_.voice_id_.Release();
}
inline void GetVoiceRequest::set_allocated_voice_id(std::string* voice_id) {
  if (voice_id != nullptr) {
    
  } else {
    
  }
  _impl_.voice_id_.SetAllocated(voice_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.voice_id_.IsDefault()) {
    _impl_.voice_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.audio.v1.GetVoiceRequest.voice_id)
}

// bool include_preview = 2;
inline void GetVoiceRequest::clear_include_preview() {
  _impl_.include_preview_ = false;
}
inline bool GetVoiceRequest::_internal_include_preview() const {
  return _impl_.include_preview_;
}
inline bool GetVoiceRequest::include_preview() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.GetVoiceRequest.include_preview)
  return _internal_include_preview();
}
inline void GetVoiceRequest::_internal_set_include_preview(bool value) {
  
  _impl_.include_preview_ = value;
}
inline void GetVoiceRequest::set_include_preview(bool value) {
  _internal_set_include_preview(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.GetVoiceRequest.include_preview)
}

// -------------------------------------------------------------------

// GetVoiceResponse

// .unhinged.common.v1.StandardResponse response = 1;
inline bool GetVoiceResponse::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool GetVoiceResponse::has_response() const {
  return _internal_has_response();
}
inline const ::unhinged::common::v1::StandardResponse& GetVoiceResponse::_internal_response() const {
  const ::unhinged::common::v1::StandardResponse* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::common::v1::StandardResponse&>(
      ::unhinged::common::v1::_StandardResponse_default_instance_);
}
inline const ::unhinged::common::v1::StandardResponse& GetVoiceResponse::response() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.GetVoiceResponse.response)
  return _internal_response();
}
inline void GetVoiceResponse::unsafe_arena_set_allocated_response(
    ::unhinged::common::v1::StandardResponse* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.audio.v1.GetVoiceResponse.response)
}
inline ::unhinged::common::v1::StandardResponse* GetVoiceResponse::release_response() {
  
  ::unhinged::common::v1::StandardResponse* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::common::v1::StandardResponse* GetVoiceResponse::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:unhinged.audio.v1.GetVoiceResponse.response)
  
  ::unhinged::common::v1::StandardResponse* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::unhinged::common::v1::StandardResponse* GetVoiceResponse::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::common::v1::StandardResponse>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::unhinged::common::v1::StandardResponse* GetVoiceResponse::mutable_response() {
  ::unhinged::common::v1::StandardResponse* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.GetVoiceResponse.response)
  return _msg;
}
inline void GetVoiceResponse::set_allocated_response(::unhinged::common::v1::StandardResponse* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:unhinged.audio.v1.GetVoiceResponse.response)
}

// .unhinged.audio.v1.Voice voice = 2;
inline bool GetVoiceResponse::_internal_has_voice() const {
  return this != internal_default_instance() && _impl_.voice_ != nullptr;
}
inline bool GetVoiceResponse::has_voice() const {
  return _internal_has_voice();
}
inline void GetVoiceResponse::clear_voice() {
  if (GetArenaForAllocation() == nullptr && _impl_.voice_ != nullptr) {
    delete _impl_.voice_;
  }
  _impl_.voice_ = nullptr;
}
inline const ::unhinged::audio::v1::Voice& GetVoiceResponse::_internal_voice() const {
  const ::unhinged::audio::v1::Voice* p = _impl_.voice_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::audio::v1::Voice&>(
      ::unhinged::audio::v1::_Voice_default_instance_);
}
inline const ::unhinged::audio::v1::Voice& GetVoiceResponse::voice() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.GetVoiceResponse.voice)
  return _internal_voice();
}
inline void GetVoiceResponse::unsafe_arena_set_allocated_voice(
    ::unhinged::audio::v1::Voice* voice) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.voice_);
  }
  _impl_.voice_ = voice;
  if (voice) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.audio.v1.GetVoiceResponse.voice)
}
inline ::unhinged::audio::v1::Voice* GetVoiceResponse::release_voice() {
  
  ::unhinged::audio::v1::Voice* temp = _impl_.voice_;
  _impl_.voice_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::audio::v1::Voice* GetVoiceResponse::unsafe_arena_release_voice() {
  // @@protoc_insertion_point(field_release:unhinged.audio.v1.GetVoiceResponse.voice)
  
  ::unhinged::audio::v1::Voice* temp = _impl_.voice_;
  _impl_.voice_ = nullptr;
  return temp;
}
inline ::unhinged::audio::v1::Voice* GetVoiceResponse::_internal_mutable_voice() {
  
  if (_impl_.voice_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::audio::v1::Voice>(GetArenaForAllocation());
    _impl_.voice_ = p;
  }
  return _impl_.voice_;
}
inline ::unhinged::audio::v1::Voice* GetVoiceResponse::mutable_voice() {
  ::unhinged::audio::v1::Voice* _msg = _internal_mutable_voice();
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.GetVoiceResponse.voice)
  return _msg;
}
inline void GetVoiceResponse::set_allocated_voice(::unhinged::audio::v1::Voice* voice) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.voice_;
  }
  if (voice) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(voice);
    if (message_arena != submessage_arena) {
      voice = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, voice, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.voice_ = voice;
  // @@protoc_insertion_point(field_set_allocated:unhinged.audio.v1.GetVoiceResponse.voice)
}

// -------------------------------------------------------------------

// CreateCustomVoiceRequest

// string name = 1;
inline void CreateCustomVoiceRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CreateCustomVoiceRequest::name() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.CreateCustomVoiceRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateCustomVoiceRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.CreateCustomVoiceRequest.name)
}
inline std::string* CreateCustomVoiceRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.CreateCustomVoiceRequest.name)
  return _s;
}
inline const std::string& CreateCustomVoiceRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CreateCustomVoiceRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateCustomVoiceRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateCustomVoiceRequest::release_name() {
  // @@protoc_insertion_point(field_release:unhinged.audio.v1.CreateCustomVoiceRequest.name)
  return _impl_.name_.Release();
}
inline void CreateCustomVoiceRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.audio.v1.CreateCustomVoiceRequest.name)
}

// string description = 2;
inline void CreateCustomVoiceRequest::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& CreateCustomVoiceRequest::description() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.CreateCustomVoiceRequest.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateCustomVoiceRequest::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.CreateCustomVoiceRequest.description)
}
inline std::string* CreateCustomVoiceRequest::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.CreateCustomVoiceRequest.description)
  return _s;
}
inline const std::string& CreateCustomVoiceRequest::_internal_description() const {
  return _impl_.description_.Get();
}
inline void CreateCustomVoiceRequest::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateCustomVoiceRequest::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateCustomVoiceRequest::release_description() {
  // @@protoc_insertion_point(field_release:unhinged.audio.v1.CreateCustomVoiceRequest.description)
  return _impl_.description_.Release();
}
inline void CreateCustomVoiceRequest::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.audio.v1.CreateCustomVoiceRequest.description)
}

// repeated .unhinged.common.v1.Attachment training_samples = 3;
inline int CreateCustomVoiceRequest::_internal_training_samples_size() const {
  return _impl_.training_samples_.size();
}
inline int CreateCustomVoiceRequest::training_samples_size() const {
  return _internal_training_samples_size();
}
inline ::unhinged::common::v1::Attachment* CreateCustomVoiceRequest::mutable_training_samples(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.CreateCustomVoiceRequest.training_samples)
  return _impl_.training_samples_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::common::v1::Attachment >*
CreateCustomVoiceRequest::mutable_training_samples() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.audio.v1.CreateCustomVoiceRequest.training_samples)
  return &_impl_.training_samples_;
}
inline const ::unhinged::common::v1::Attachment& CreateCustomVoiceRequest::_internal_training_samples(int index) const {
  return _impl_.training_samples_.Get(index);
}
inline const ::unhinged::common::v1::Attachment& CreateCustomVoiceRequest::training_samples(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.CreateCustomVoiceRequest.training_samples)
  return _internal_training_samples(index);
}
inline ::unhinged::common::v1::Attachment* CreateCustomVoiceRequest::_internal_add_training_samples() {
  return _impl_.training_samples_.Add();
}
inline ::unhinged::common::v1::Attachment* CreateCustomVoiceRequest::add_training_samples() {
  ::unhinged::common::v1::Attachment* _add = _internal_add_training_samples();
  // @@protoc_insertion_point(field_add:unhinged.audio.v1.CreateCustomVoiceRequest.training_samples)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::common::v1::Attachment >&
CreateCustomVoiceRequest::training_samples() const {
  // @@protoc_insertion_point(field_list:unhinged.audio.v1.CreateCustomVoiceRequest.training_samples)
  return _impl_.training_samples_;
}

// .unhinged.audio.v1.VoiceGender target_gender = 4;
inline void CreateCustomVoiceRequest::clear_target_gender() {
  _impl_.target_gender_ = 0;
}
inline ::unhinged::audio::v1::VoiceGender CreateCustomVoiceRequest::_internal_target_gender() const {
  return static_cast< ::unhinged::audio::v1::VoiceGender >(_impl_.target_gender_);
}
inline ::unhinged::audio::v1::VoiceGender CreateCustomVoiceRequest::target_gender() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.CreateCustomVoiceRequest.target_gender)
  return _internal_target_gender();
}
inline void CreateCustomVoiceRequest::_internal_set_target_gender(::unhinged::audio::v1::VoiceGender value) {
  
  _impl_.target_gender_ = value;
}
inline void CreateCustomVoiceRequest::set_target_gender(::unhinged::audio::v1::VoiceGender value) {
  _internal_set_target_gender(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.CreateCustomVoiceRequest.target_gender)
}

// .unhinged.audio.v1.VoiceStyle target_style = 5;
inline void CreateCustomVoiceRequest::clear_target_style() {
  _impl_.target_style_ = 0;
}
inline ::unhinged::audio::v1::VoiceStyle CreateCustomVoiceRequest::_internal_target_style() const {
  return static_cast< ::unhinged::audio::v1::VoiceStyle >(_impl_.target_style_);
}
inline ::unhinged::audio::v1::VoiceStyle CreateCustomVoiceRequest::target_style() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.CreateCustomVoiceRequest.target_style)
  return _internal_target_style();
}
inline void CreateCustomVoiceRequest::_internal_set_target_style(::unhinged::audio::v1::VoiceStyle value) {
  
  _impl_.target_style_ = value;
}
inline void CreateCustomVoiceRequest::set_target_style(::unhinged::audio::v1::VoiceStyle value) {
  _internal_set_target_style(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.CreateCustomVoiceRequest.target_style)
}

// -------------------------------------------------------------------

// CreateCustomVoiceResponse

// .unhinged.common.v1.StandardResponse response = 1;
inline bool CreateCustomVoiceResponse::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool CreateCustomVoiceResponse::has_response() const {
  return _internal_has_response();
}
inline const ::unhinged::common::v1::StandardResponse& CreateCustomVoiceResponse::_internal_response() const {
  const ::unhinged::common::v1::StandardResponse* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::common::v1::StandardResponse&>(
      ::unhinged::common::v1::_StandardResponse_default_instance_);
}
inline const ::unhinged::common::v1::StandardResponse& CreateCustomVoiceResponse::response() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.CreateCustomVoiceResponse.response)
  return _internal_response();
}
inline void CreateCustomVoiceResponse::unsafe_arena_set_allocated_response(
    ::unhinged::common::v1::StandardResponse* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.audio.v1.CreateCustomVoiceResponse.response)
}
inline ::unhinged::common::v1::StandardResponse* CreateCustomVoiceResponse::release_response() {
  
  ::unhinged::common::v1::StandardResponse* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::common::v1::StandardResponse* CreateCustomVoiceResponse::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:unhinged.audio.v1.CreateCustomVoiceResponse.response)
  
  ::unhinged::common::v1::StandardResponse* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::unhinged::common::v1::StandardResponse* CreateCustomVoiceResponse::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::common::v1::StandardResponse>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::unhinged::common::v1::StandardResponse* CreateCustomVoiceResponse::mutable_response() {
  ::unhinged::common::v1::StandardResponse* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.CreateCustomVoiceResponse.response)
  return _msg;
}
inline void CreateCustomVoiceResponse::set_allocated_response(::unhinged::common::v1::StandardResponse* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:unhinged.audio.v1.CreateCustomVoiceResponse.response)
}

// .unhinged.audio.v1.Voice voice = 2;
inline bool CreateCustomVoiceResponse::_internal_has_voice() const {
  return this != internal_default_instance() && _impl_.voice_ != nullptr;
}
inline bool CreateCustomVoiceResponse::has_voice() const {
  return _internal_has_voice();
}
inline void CreateCustomVoiceResponse::clear_voice() {
  if (GetArenaForAllocation() == nullptr && _impl_.voice_ != nullptr) {
    delete _impl_.voice_;
  }
  _impl_.voice_ = nullptr;
}
inline const ::unhinged::audio::v1::Voice& CreateCustomVoiceResponse::_internal_voice() const {
  const ::unhinged::audio::v1::Voice* p = _impl_.voice_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::audio::v1::Voice&>(
      ::unhinged::audio::v1::_Voice_default_instance_);
}
inline const ::unhinged::audio::v1::Voice& CreateCustomVoiceResponse::voice() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.CreateCustomVoiceResponse.voice)
  return _internal_voice();
}
inline void CreateCustomVoiceResponse::unsafe_arena_set_allocated_voice(
    ::unhinged::audio::v1::Voice* voice) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.voice_);
  }
  _impl_.voice_ = voice;
  if (voice) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.audio.v1.CreateCustomVoiceResponse.voice)
}
inline ::unhinged::audio::v1::Voice* CreateCustomVoiceResponse::release_voice() {
  
  ::unhinged::audio::v1::Voice* temp = _impl_.voice_;
  _impl_.voice_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::audio::v1::Voice* CreateCustomVoiceResponse::unsafe_arena_release_voice() {
  // @@protoc_insertion_point(field_release:unhinged.audio.v1.CreateCustomVoiceResponse.voice)
  
  ::unhinged::audio::v1::Voice* temp = _impl_.voice_;
  _impl_.voice_ = nullptr;
  return temp;
}
inline ::unhinged::audio::v1::Voice* CreateCustomVoiceResponse::_internal_mutable_voice() {
  
  if (_impl_.voice_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::audio::v1::Voice>(GetArenaForAllocation());
    _impl_.voice_ = p;
  }
  return _impl_.voice_;
}
inline ::unhinged::audio::v1::Voice* CreateCustomVoiceResponse::mutable_voice() {
  ::unhinged::audio::v1::Voice* _msg = _internal_mutable_voice();
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.CreateCustomVoiceResponse.voice)
  return _msg;
}
inline void CreateCustomVoiceResponse::set_allocated_voice(::unhinged::audio::v1::Voice* voice) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.voice_;
  }
  if (voice) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(voice);
    if (message_arena != submessage_arena) {
      voice = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, voice, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.voice_ = voice;
  // @@protoc_insertion_point(field_set_allocated:unhinged.audio.v1.CreateCustomVoiceResponse.voice)
}

// string training_job_id = 3;
inline void CreateCustomVoiceResponse::clear_training_job_id() {
  _impl_.training_job_id_.ClearToEmpty();
}
inline const std::string& CreateCustomVoiceResponse::training_job_id() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.CreateCustomVoiceResponse.training_job_id)
  return _internal_training_job_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateCustomVoiceResponse::set_training_job_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.training_job_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.CreateCustomVoiceResponse.training_job_id)
}
inline std::string* CreateCustomVoiceResponse::mutable_training_job_id() {
  std::string* _s = _internal_mutable_training_job_id();
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.CreateCustomVoiceResponse.training_job_id)
  return _s;
}
inline const std::string& CreateCustomVoiceResponse::_internal_training_job_id() const {
  return _impl_.training_job_id_.Get();
}
inline void CreateCustomVoiceResponse::_internal_set_training_job_id(const std::string& value) {
  
  _impl_.training_job_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateCustomVoiceResponse::_internal_mutable_training_job_id() {
  
  return _impl_.training_job_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateCustomVoiceResponse::release_training_job_id() {
  // @@protoc_insertion_point(field_release:unhinged.audio.v1.CreateCustomVoiceResponse.training_job_id)
  return _impl_.training_job_id_.Release();
}
inline void CreateCustomVoiceResponse::set_allocated_training_job_id(std::string* training_job_id) {
  if (training_job_id != nullptr) {
    
  } else {
    
  }
  _impl_.training_job_id_.SetAllocated(training_job_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.training_job_id_.IsDefault()) {
    _impl_.training_job_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.audio.v1.CreateCustomVoiceResponse.training_job_id)
}

// -------------------------------------------------------------------

// ConvertAudioRequest

// .unhinged.common.v1.Attachment input_audio = 1;
inline bool ConvertAudioRequest::_internal_has_input_audio() const {
  return this != internal_default_instance() && _impl_.input_audio_ != nullptr;
}
inline bool ConvertAudioRequest::has_input_audio() const {
  return _internal_has_input_audio();
}
inline const ::unhinged::common::v1::Attachment& ConvertAudioRequest::_internal_input_audio() const {
  const ::unhinged::common::v1::Attachment* p = _impl_.input_audio_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::common::v1::Attachment&>(
      ::unhinged::common::v1::_Attachment_default_instance_);
}
inline const ::unhinged::common::v1::Attachment& ConvertAudioRequest::input_audio() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.ConvertAudioRequest.input_audio)
  return _internal_input_audio();
}
inline void ConvertAudioRequest::unsafe_arena_set_allocated_input_audio(
    ::unhinged::common::v1::Attachment* input_audio) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.input_audio_);
  }
  _impl_.input_audio_ = input_audio;
  if (input_audio) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.audio.v1.ConvertAudioRequest.input_audio)
}
inline ::unhinged::common::v1::Attachment* ConvertAudioRequest::release_input_audio() {
  
  ::unhinged::common::v1::Attachment* temp = _impl_.input_audio_;
  _impl_.input_audio_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::common::v1::Attachment* ConvertAudioRequest::unsafe_arena_release_input_audio() {
  // @@protoc_insertion_point(field_release:unhinged.audio.v1.ConvertAudioRequest.input_audio)
  
  ::unhinged::common::v1::Attachment* temp = _impl_.input_audio_;
  _impl_.input_audio_ = nullptr;
  return temp;
}
inline ::unhinged::common::v1::Attachment* ConvertAudioRequest::_internal_mutable_input_audio() {
  
  if (_impl_.input_audio_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::common::v1::Attachment>(GetArenaForAllocation());
    _impl_.input_audio_ = p;
  }
  return _impl_.input_audio_;
}
inline ::unhinged::common::v1::Attachment* ConvertAudioRequest::mutable_input_audio() {
  ::unhinged::common::v1::Attachment* _msg = _internal_mutable_input_audio();
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.ConvertAudioRequest.input_audio)
  return _msg;
}
inline void ConvertAudioRequest::set_allocated_input_audio(::unhinged::common::v1::Attachment* input_audio) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.input_audio_);
  }
  if (input_audio) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(input_audio));
    if (message_arena != submessage_arena) {
      input_audio = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, input_audio, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.input_audio_ = input_audio;
  // @@protoc_insertion_point(field_set_allocated:unhinged.audio.v1.ConvertAudioRequest.input_audio)
}

// .unhinged.audio.v1.AudioFormat target_format = 2;
inline void ConvertAudioRequest::clear_target_format() {
  _impl_.target_format_ = 0;
}
inline ::unhinged::audio::v1::AudioFormat ConvertAudioRequest::_internal_target_format() const {
  return static_cast< ::unhinged::audio::v1::AudioFormat >(_impl_.target_format_);
}
inline ::unhinged::audio::v1::AudioFormat ConvertAudioRequest::target_format() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.ConvertAudioRequest.target_format)
  return _internal_target_format();
}
inline void ConvertAudioRequest::_internal_set_target_format(::unhinged::audio::v1::AudioFormat value) {
  
  _impl_.target_format_ = value;
}
inline void ConvertAudioRequest::set_target_format(::unhinged::audio::v1::AudioFormat value) {
  _internal_set_target_format(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.ConvertAudioRequest.target_format)
}

// int32 target_sample_rate = 3;
inline void ConvertAudioRequest::clear_target_sample_rate() {
  _impl_.target_sample_rate_ = 0;
}
inline int32_t ConvertAudioRequest::_internal_target_sample_rate() const {
  return _impl_.target_sample_rate_;
}
inline int32_t ConvertAudioRequest::target_sample_rate() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.ConvertAudioRequest.target_sample_rate)
  return _internal_target_sample_rate();
}
inline void ConvertAudioRequest::_internal_set_target_sample_rate(int32_t value) {
  
  _impl_.target_sample_rate_ = value;
}
inline void ConvertAudioRequest::set_target_sample_rate(int32_t value) {
  _internal_set_target_sample_rate(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.ConvertAudioRequest.target_sample_rate)
}

// .unhinged.audio.v1.AudioOptions options = 4;
inline bool ConvertAudioRequest::_internal_has_options() const {
  return this != internal_default_instance() && _impl_.options_ != nullptr;
}
inline bool ConvertAudioRequest::has_options() const {
  return _internal_has_options();
}
inline void ConvertAudioRequest::clear_options() {
  if (GetArenaForAllocation() == nullptr && _impl_.options_ != nullptr) {
    delete _impl_.options_;
  }
  _impl_.options_ = nullptr;
}
inline const ::unhinged::audio::v1::AudioOptions& ConvertAudioRequest::_internal_options() const {
  const ::unhinged::audio::v1::AudioOptions* p = _impl_.options_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::audio::v1::AudioOptions&>(
      ::unhinged::audio::v1::_AudioOptions_default_instance_);
}
inline const ::unhinged::audio::v1::AudioOptions& ConvertAudioRequest::options() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.ConvertAudioRequest.options)
  return _internal_options();
}
inline void ConvertAudioRequest::unsafe_arena_set_allocated_options(
    ::unhinged::audio::v1::AudioOptions* options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.options_);
  }
  _impl_.options_ = options;
  if (options) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.audio.v1.ConvertAudioRequest.options)
}
inline ::unhinged::audio::v1::AudioOptions* ConvertAudioRequest::release_options() {
  
  ::unhinged::audio::v1::AudioOptions* temp = _impl_.options_;
  _impl_.options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::audio::v1::AudioOptions* ConvertAudioRequest::unsafe_arena_release_options() {
  // @@protoc_insertion_point(field_release:unhinged.audio.v1.ConvertAudioRequest.options)
  
  ::unhinged::audio::v1::AudioOptions* temp = _impl_.options_;
  _impl_.options_ = nullptr;
  return temp;
}
inline ::unhinged::audio::v1::AudioOptions* ConvertAudioRequest::_internal_mutable_options() {
  
  if (_impl_.options_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::audio::v1::AudioOptions>(GetArenaForAllocation());
    _impl_.options_ = p;
  }
  return _impl_.options_;
}
inline ::unhinged::audio::v1::AudioOptions* ConvertAudioRequest::mutable_options() {
  ::unhinged::audio::v1::AudioOptions* _msg = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.ConvertAudioRequest.options)
  return _msg;
}
inline void ConvertAudioRequest::set_allocated_options(::unhinged::audio::v1::AudioOptions* options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.options_;
  }
  if (options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(options);
    if (message_arena != submessage_arena) {
      options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.options_ = options;
  // @@protoc_insertion_point(field_set_allocated:unhinged.audio.v1.ConvertAudioRequest.options)
}

// -------------------------------------------------------------------

// ConvertAudioResponse

// .unhinged.common.v1.StandardResponse response = 1;
inline bool ConvertAudioResponse::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool ConvertAudioResponse::has_response() const {
  return _internal_has_response();
}
inline const ::unhinged::common::v1::StandardResponse& ConvertAudioResponse::_internal_response() const {
  const ::unhinged::common::v1::StandardResponse* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::common::v1::StandardResponse&>(
      ::unhinged::common::v1::_StandardResponse_default_instance_);
}
inline const ::unhinged::common::v1::StandardResponse& ConvertAudioResponse::response() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.ConvertAudioResponse.response)
  return _internal_response();
}
inline void ConvertAudioResponse::unsafe_arena_set_allocated_response(
    ::unhinged::common::v1::StandardResponse* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.audio.v1.ConvertAudioResponse.response)
}
inline ::unhinged::common::v1::StandardResponse* ConvertAudioResponse::release_response() {
  
  ::unhinged::common::v1::StandardResponse* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::common::v1::StandardResponse* ConvertAudioResponse::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:unhinged.audio.v1.ConvertAudioResponse.response)
  
  ::unhinged::common::v1::StandardResponse* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::unhinged::common::v1::StandardResponse* ConvertAudioResponse::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::common::v1::StandardResponse>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::unhinged::common::v1::StandardResponse* ConvertAudioResponse::mutable_response() {
  ::unhinged::common::v1::StandardResponse* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.ConvertAudioResponse.response)
  return _msg;
}
inline void ConvertAudioResponse::set_allocated_response(::unhinged::common::v1::StandardResponse* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:unhinged.audio.v1.ConvertAudioResponse.response)
}

// .unhinged.common.v1.Attachment converted_audio = 2;
inline bool ConvertAudioResponse::_internal_has_converted_audio() const {
  return this != internal_default_instance() && _impl_.converted_audio_ != nullptr;
}
inline bool ConvertAudioResponse::has_converted_audio() const {
  return _internal_has_converted_audio();
}
inline const ::unhinged::common::v1::Attachment& ConvertAudioResponse::_internal_converted_audio() const {
  const ::unhinged::common::v1::Attachment* p = _impl_.converted_audio_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::common::v1::Attachment&>(
      ::unhinged::common::v1::_Attachment_default_instance_);
}
inline const ::unhinged::common::v1::Attachment& ConvertAudioResponse::converted_audio() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.ConvertAudioResponse.converted_audio)
  return _internal_converted_audio();
}
inline void ConvertAudioResponse::unsafe_arena_set_allocated_converted_audio(
    ::unhinged::common::v1::Attachment* converted_audio) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.converted_audio_);
  }
  _impl_.converted_audio_ = converted_audio;
  if (converted_audio) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.audio.v1.ConvertAudioResponse.converted_audio)
}
inline ::unhinged::common::v1::Attachment* ConvertAudioResponse::release_converted_audio() {
  
  ::unhinged::common::v1::Attachment* temp = _impl_.converted_audio_;
  _impl_.converted_audio_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::common::v1::Attachment* ConvertAudioResponse::unsafe_arena_release_converted_audio() {
  // @@protoc_insertion_point(field_release:unhinged.audio.v1.ConvertAudioResponse.converted_audio)
  
  ::unhinged::common::v1::Attachment* temp = _impl_.converted_audio_;
  _impl_.converted_audio_ = nullptr;
  return temp;
}
inline ::unhinged::common::v1::Attachment* ConvertAudioResponse::_internal_mutable_converted_audio() {
  
  if (_impl_.converted_audio_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::common::v1::Attachment>(GetArenaForAllocation());
    _impl_.converted_audio_ = p;
  }
  return _impl_.converted_audio_;
}
inline ::unhinged::common::v1::Attachment* ConvertAudioResponse::mutable_converted_audio() {
  ::unhinged::common::v1::Attachment* _msg = _internal_mutable_converted_audio();
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.ConvertAudioResponse.converted_audio)
  return _msg;
}
inline void ConvertAudioResponse::set_allocated_converted_audio(::unhinged::common::v1::Attachment* converted_audio) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.converted_audio_);
  }
  if (converted_audio) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(converted_audio));
    if (message_arena != submessage_arena) {
      converted_audio = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, converted_audio, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.converted_audio_ = converted_audio;
  // @@protoc_insertion_point(field_set_allocated:unhinged.audio.v1.ConvertAudioResponse.converted_audio)
}

// .unhinged.common.v1.AudioUsage usage = 3;
inline bool ConvertAudioResponse::_internal_has_usage() const {
  return this != internal_default_instance() && _impl_.usage_ != nullptr;
}
inline bool ConvertAudioResponse::has_usage() const {
  return _internal_has_usage();
}
inline const ::unhinged::common::v1::AudioUsage& ConvertAudioResponse::_internal_usage() const {
  const ::unhinged::common::v1::AudioUsage* p = _impl_.usage_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::common::v1::AudioUsage&>(
      ::unhinged::common::v1::_AudioUsage_default_instance_);
}
inline const ::unhinged::common::v1::AudioUsage& ConvertAudioResponse::usage() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.ConvertAudioResponse.usage)
  return _internal_usage();
}
inline void ConvertAudioResponse::unsafe_arena_set_allocated_usage(
    ::unhinged::common::v1::AudioUsage* usage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.usage_);
  }
  _impl_.usage_ = usage;
  if (usage) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.audio.v1.ConvertAudioResponse.usage)
}
inline ::unhinged::common::v1::AudioUsage* ConvertAudioResponse::release_usage() {
  
  ::unhinged::common::v1::AudioUsage* temp = _impl_.usage_;
  _impl_.usage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::common::v1::AudioUsage* ConvertAudioResponse::unsafe_arena_release_usage() {
  // @@protoc_insertion_point(field_release:unhinged.audio.v1.ConvertAudioResponse.usage)
  
  ::unhinged::common::v1::AudioUsage* temp = _impl_.usage_;
  _impl_.usage_ = nullptr;
  return temp;
}
inline ::unhinged::common::v1::AudioUsage* ConvertAudioResponse::_internal_mutable_usage() {
  
  if (_impl_.usage_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::common::v1::AudioUsage>(GetArenaForAllocation());
    _impl_.usage_ = p;
  }
  return _impl_.usage_;
}
inline ::unhinged::common::v1::AudioUsage* ConvertAudioResponse::mutable_usage() {
  ::unhinged::common::v1::AudioUsage* _msg = _internal_mutable_usage();
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.ConvertAudioResponse.usage)
  return _msg;
}
inline void ConvertAudioResponse::set_allocated_usage(::unhinged::common::v1::AudioUsage* usage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.usage_);
  }
  if (usage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(usage));
    if (message_arena != submessage_arena) {
      usage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, usage, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.usage_ = usage;
  // @@protoc_insertion_point(field_set_allocated:unhinged.audio.v1.ConvertAudioResponse.usage)
}

// -------------------------------------------------------------------

// AnalyzeAudioRequest

// .unhinged.common.v1.Attachment audio_file = 1;
inline bool AnalyzeAudioRequest::_internal_has_audio_file() const {
  return this != internal_default_instance() && _impl_.audio_file_ != nullptr;
}
inline bool AnalyzeAudioRequest::has_audio_file() const {
  return _internal_has_audio_file();
}
inline const ::unhinged::common::v1::Attachment& AnalyzeAudioRequest::_internal_audio_file() const {
  const ::unhinged::common::v1::Attachment* p = _impl_.audio_file_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::common::v1::Attachment&>(
      ::unhinged::common::v1::_Attachment_default_instance_);
}
inline const ::unhinged::common::v1::Attachment& AnalyzeAudioRequest::audio_file() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.AnalyzeAudioRequest.audio_file)
  return _internal_audio_file();
}
inline void AnalyzeAudioRequest::unsafe_arena_set_allocated_audio_file(
    ::unhinged::common::v1::Attachment* audio_file) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.audio_file_);
  }
  _impl_.audio_file_ = audio_file;
  if (audio_file) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.audio.v1.AnalyzeAudioRequest.audio_file)
}
inline ::unhinged::common::v1::Attachment* AnalyzeAudioRequest::release_audio_file() {
  
  ::unhinged::common::v1::Attachment* temp = _impl_.audio_file_;
  _impl_.audio_file_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::common::v1::Attachment* AnalyzeAudioRequest::unsafe_arena_release_audio_file() {
  // @@protoc_insertion_point(field_release:unhinged.audio.v1.AnalyzeAudioRequest.audio_file)
  
  ::unhinged::common::v1::Attachment* temp = _impl_.audio_file_;
  _impl_.audio_file_ = nullptr;
  return temp;
}
inline ::unhinged::common::v1::Attachment* AnalyzeAudioRequest::_internal_mutable_audio_file() {
  
  if (_impl_.audio_file_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::common::v1::Attachment>(GetArenaForAllocation());
    _impl_.audio_file_ = p;
  }
  return _impl_.audio_file_;
}
inline ::unhinged::common::v1::Attachment* AnalyzeAudioRequest::mutable_audio_file() {
  ::unhinged::common::v1::Attachment* _msg = _internal_mutable_audio_file();
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.AnalyzeAudioRequest.audio_file)
  return _msg;
}
inline void AnalyzeAudioRequest::set_allocated_audio_file(::unhinged::common::v1::Attachment* audio_file) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.audio_file_);
  }
  if (audio_file) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(audio_file));
    if (message_arena != submessage_arena) {
      audio_file = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, audio_file, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.audio_file_ = audio_file;
  // @@protoc_insertion_point(field_set_allocated:unhinged.audio.v1.AnalyzeAudioRequest.audio_file)
}

// repeated .unhinged.audio.v1.AnalysisType analysis_types = 2;
inline int AnalyzeAudioRequest::_internal_analysis_types_size() const {
  return _impl_.analysis_types_.size();
}
inline int AnalyzeAudioRequest::analysis_types_size() const {
  return _internal_analysis_types_size();
}
inline void AnalyzeAudioRequest::clear_analysis_types() {
  _impl_.analysis_types_.Clear();
}
inline ::unhinged::audio::v1::AnalysisType AnalyzeAudioRequest::_internal_analysis_types(int index) const {
  return static_cast< ::unhinged::audio::v1::AnalysisType >(_impl_.analysis_types_.Get(index));
}
inline ::unhinged::audio::v1::AnalysisType AnalyzeAudioRequest::analysis_types(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.AnalyzeAudioRequest.analysis_types)
  return _internal_analysis_types(index);
}
inline void AnalyzeAudioRequest::set_analysis_types(int index, ::unhinged::audio::v1::AnalysisType value) {
  _impl_.analysis_types_.Set(index, value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.AnalyzeAudioRequest.analysis_types)
}
inline void AnalyzeAudioRequest::_internal_add_analysis_types(::unhinged::audio::v1::AnalysisType value) {
  _impl_.analysis_types_.Add(value);
}
inline void AnalyzeAudioRequest::add_analysis_types(::unhinged::audio::v1::AnalysisType value) {
  _internal_add_analysis_types(value);
  // @@protoc_insertion_point(field_add:unhinged.audio.v1.AnalyzeAudioRequest.analysis_types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
AnalyzeAudioRequest::analysis_types() const {
  // @@protoc_insertion_point(field_list:unhinged.audio.v1.AnalyzeAudioRequest.analysis_types)
  return _impl_.analysis_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
AnalyzeAudioRequest::_internal_mutable_analysis_types() {
  return &_impl_.analysis_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
AnalyzeAudioRequest::mutable_analysis_types() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.audio.v1.AnalyzeAudioRequest.analysis_types)
  return _internal_mutable_analysis_types();
}

// -------------------------------------------------------------------

// AnalyzeAudioResponse

// .unhinged.common.v1.StandardResponse response = 1;
inline bool AnalyzeAudioResponse::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool AnalyzeAudioResponse::has_response() const {
  return _internal_has_response();
}
inline const ::unhinged::common::v1::StandardResponse& AnalyzeAudioResponse::_internal_response() const {
  const ::unhinged::common::v1::StandardResponse* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::common::v1::StandardResponse&>(
      ::unhinged::common::v1::_StandardResponse_default_instance_);
}
inline const ::unhinged::common::v1::StandardResponse& AnalyzeAudioResponse::response() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.AnalyzeAudioResponse.response)
  return _internal_response();
}
inline void AnalyzeAudioResponse::unsafe_arena_set_allocated_response(
    ::unhinged::common::v1::StandardResponse* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.audio.v1.AnalyzeAudioResponse.response)
}
inline ::unhinged::common::v1::StandardResponse* AnalyzeAudioResponse::release_response() {
  
  ::unhinged::common::v1::StandardResponse* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::common::v1::StandardResponse* AnalyzeAudioResponse::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:unhinged.audio.v1.AnalyzeAudioResponse.response)
  
  ::unhinged::common::v1::StandardResponse* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::unhinged::common::v1::StandardResponse* AnalyzeAudioResponse::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::common::v1::StandardResponse>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::unhinged::common::v1::StandardResponse* AnalyzeAudioResponse::mutable_response() {
  ::unhinged::common::v1::StandardResponse* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.AnalyzeAudioResponse.response)
  return _msg;
}
inline void AnalyzeAudioResponse::set_allocated_response(::unhinged::common::v1::StandardResponse* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:unhinged.audio.v1.AnalyzeAudioResponse.response)
}

// .unhinged.audio.v1.AudioAnalysis analysis = 2;
inline bool AnalyzeAudioResponse::_internal_has_analysis() const {
  return this != internal_default_instance() && _impl_.analysis_ != nullptr;
}
inline bool AnalyzeAudioResponse::has_analysis() const {
  return _internal_has_analysis();
}
inline void AnalyzeAudioResponse::clear_analysis() {
  if (GetArenaForAllocation() == nullptr && _impl_.analysis_ != nullptr) {
    delete _impl_.analysis_;
  }
  _impl_.analysis_ = nullptr;
}
inline const ::unhinged::audio::v1::AudioAnalysis& AnalyzeAudioResponse::_internal_analysis() const {
  const ::unhinged::audio::v1::AudioAnalysis* p = _impl_.analysis_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::audio::v1::AudioAnalysis&>(
      ::unhinged::audio::v1::_AudioAnalysis_default_instance_);
}
inline const ::unhinged::audio::v1::AudioAnalysis& AnalyzeAudioResponse::analysis() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.AnalyzeAudioResponse.analysis)
  return _internal_analysis();
}
inline void AnalyzeAudioResponse::unsafe_arena_set_allocated_analysis(
    ::unhinged::audio::v1::AudioAnalysis* analysis) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.analysis_);
  }
  _impl_.analysis_ = analysis;
  if (analysis) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.audio.v1.AnalyzeAudioResponse.analysis)
}
inline ::unhinged::audio::v1::AudioAnalysis* AnalyzeAudioResponse::release_analysis() {
  
  ::unhinged::audio::v1::AudioAnalysis* temp = _impl_.analysis_;
  _impl_.analysis_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::audio::v1::AudioAnalysis* AnalyzeAudioResponse::unsafe_arena_release_analysis() {
  // @@protoc_insertion_point(field_release:unhinged.audio.v1.AnalyzeAudioResponse.analysis)
  
  ::unhinged::audio::v1::AudioAnalysis* temp = _impl_.analysis_;
  _impl_.analysis_ = nullptr;
  return temp;
}
inline ::unhinged::audio::v1::AudioAnalysis* AnalyzeAudioResponse::_internal_mutable_analysis() {
  
  if (_impl_.analysis_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::audio::v1::AudioAnalysis>(GetArenaForAllocation());
    _impl_.analysis_ = p;
  }
  return _impl_.analysis_;
}
inline ::unhinged::audio::v1::AudioAnalysis* AnalyzeAudioResponse::mutable_analysis() {
  ::unhinged::audio::v1::AudioAnalysis* _msg = _internal_mutable_analysis();
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.AnalyzeAudioResponse.analysis)
  return _msg;
}
inline void AnalyzeAudioResponse::set_allocated_analysis(::unhinged::audio::v1::AudioAnalysis* analysis) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.analysis_;
  }
  if (analysis) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(analysis);
    if (message_arena != submessage_arena) {
      analysis = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, analysis, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.analysis_ = analysis;
  // @@protoc_insertion_point(field_set_allocated:unhinged.audio.v1.AnalyzeAudioResponse.analysis)
}

// .unhinged.common.v1.AudioUsage usage = 3;
inline bool AnalyzeAudioResponse::_internal_has_usage() const {
  return this != internal_default_instance() && _impl_.usage_ != nullptr;
}
inline bool AnalyzeAudioResponse::has_usage() const {
  return _internal_has_usage();
}
inline const ::unhinged::common::v1::AudioUsage& AnalyzeAudioResponse::_internal_usage() const {
  const ::unhinged::common::v1::AudioUsage* p = _impl_.usage_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::common::v1::AudioUsage&>(
      ::unhinged::common::v1::_AudioUsage_default_instance_);
}
inline const ::unhinged::common::v1::AudioUsage& AnalyzeAudioResponse::usage() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.AnalyzeAudioResponse.usage)
  return _internal_usage();
}
inline void AnalyzeAudioResponse::unsafe_arena_set_allocated_usage(
    ::unhinged::common::v1::AudioUsage* usage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.usage_);
  }
  _impl_.usage_ = usage;
  if (usage) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.audio.v1.AnalyzeAudioResponse.usage)
}
inline ::unhinged::common::v1::AudioUsage* AnalyzeAudioResponse::release_usage() {
  
  ::unhinged::common::v1::AudioUsage* temp = _impl_.usage_;
  _impl_.usage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::common::v1::AudioUsage* AnalyzeAudioResponse::unsafe_arena_release_usage() {
  // @@protoc_insertion_point(field_release:unhinged.audio.v1.AnalyzeAudioResponse.usage)
  
  ::unhinged::common::v1::AudioUsage* temp = _impl_.usage_;
  _impl_.usage_ = nullptr;
  return temp;
}
inline ::unhinged::common::v1::AudioUsage* AnalyzeAudioResponse::_internal_mutable_usage() {
  
  if (_impl_.usage_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::common::v1::AudioUsage>(GetArenaForAllocation());
    _impl_.usage_ = p;
  }
  return _impl_.usage_;
}
inline ::unhinged::common::v1::AudioUsage* AnalyzeAudioResponse::mutable_usage() {
  ::unhinged::common::v1::AudioUsage* _msg = _internal_mutable_usage();
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.AnalyzeAudioResponse.usage)
  return _msg;
}
inline void AnalyzeAudioResponse::set_allocated_usage(::unhinged::common::v1::AudioUsage* usage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.usage_);
  }
  if (usage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(usage));
    if (message_arena != submessage_arena) {
      usage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, usage, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.usage_ = usage;
  // @@protoc_insertion_point(field_set_allocated:unhinged.audio.v1.AnalyzeAudioResponse.usage)
}

// -------------------------------------------------------------------

// AudioAnalysis

// bool contains_speech = 1;
inline void AudioAnalysis::clear_contains_speech() {
  _impl_.contains_speech_ = false;
}
inline bool AudioAnalysis::_internal_contains_speech() const {
  return _impl_.contains_speech_;
}
inline bool AudioAnalysis::contains_speech() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.AudioAnalysis.contains_speech)
  return _internal_contains_speech();
}
inline void AudioAnalysis::_internal_set_contains_speech(bool value) {
  
  _impl_.contains_speech_ = value;
}
inline void AudioAnalysis::set_contains_speech(bool value) {
  _internal_set_contains_speech(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.AudioAnalysis.contains_speech)
}

// float speech_percentage = 2;
inline void AudioAnalysis::clear_speech_percentage() {
  _impl_.speech_percentage_ = 0;
}
inline float AudioAnalysis::_internal_speech_percentage() const {
  return _impl_.speech_percentage_;
}
inline float AudioAnalysis::speech_percentage() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.AudioAnalysis.speech_percentage)
  return _internal_speech_percentage();
}
inline void AudioAnalysis::_internal_set_speech_percentage(float value) {
  
  _impl_.speech_percentage_ = value;
}
inline void AudioAnalysis::set_speech_percentage(float value) {
  _internal_set_speech_percentage(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.AudioAnalysis.speech_percentage)
}

// repeated .unhinged.audio.v1.SpeechSegment speech_segments = 3;
inline int AudioAnalysis::_internal_speech_segments_size() const {
  return _impl_.speech_segments_.size();
}
inline int AudioAnalysis::speech_segments_size() const {
  return _internal_speech_segments_size();
}
inline void AudioAnalysis::clear_speech_segments() {
  _impl_.speech_segments_.Clear();
}
inline ::unhinged::audio::v1::SpeechSegment* AudioAnalysis::mutable_speech_segments(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.AudioAnalysis.speech_segments)
  return _impl_.speech_segments_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::audio::v1::SpeechSegment >*
AudioAnalysis::mutable_speech_segments() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.audio.v1.AudioAnalysis.speech_segments)
  return &_impl_.speech_segments_;
}
inline const ::unhinged::audio::v1::SpeechSegment& AudioAnalysis::_internal_speech_segments(int index) const {
  return _impl_.speech_segments_.Get(index);
}
inline const ::unhinged::audio::v1::SpeechSegment& AudioAnalysis::speech_segments(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.AudioAnalysis.speech_segments)
  return _internal_speech_segments(index);
}
inline ::unhinged::audio::v1::SpeechSegment* AudioAnalysis::_internal_add_speech_segments() {
  return _impl_.speech_segments_.Add();
}
inline ::unhinged::audio::v1::SpeechSegment* AudioAnalysis::add_speech_segments() {
  ::unhinged::audio::v1::SpeechSegment* _add = _internal_add_speech_segments();
  // @@protoc_insertion_point(field_add:unhinged.audio.v1.AudioAnalysis.speech_segments)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::audio::v1::SpeechSegment >&
AudioAnalysis::speech_segments() const {
  // @@protoc_insertion_point(field_list:unhinged.audio.v1.AudioAnalysis.speech_segments)
  return _impl_.speech_segments_;
}

// repeated .unhinged.audio.v1.LanguageDetection detected_languages = 4;
inline int AudioAnalysis::_internal_detected_languages_size() const {
  return _impl_.detected_languages_.size();
}
inline int AudioAnalysis::detected_languages_size() const {
  return _internal_detected_languages_size();
}
inline void AudioAnalysis::clear_detected_languages() {
  _impl_.detected_languages_.Clear();
}
inline ::unhinged::audio::v1::LanguageDetection* AudioAnalysis::mutable_detected_languages(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.AudioAnalysis.detected_languages)
  return _impl_.detected_languages_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::audio::v1::LanguageDetection >*
AudioAnalysis::mutable_detected_languages() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.audio.v1.AudioAnalysis.detected_languages)
  return &_impl_.detected_languages_;
}
inline const ::unhinged::audio::v1::LanguageDetection& AudioAnalysis::_internal_detected_languages(int index) const {
  return _impl_.detected_languages_.Get(index);
}
inline const ::unhinged::audio::v1::LanguageDetection& AudioAnalysis::detected_languages(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.AudioAnalysis.detected_languages)
  return _internal_detected_languages(index);
}
inline ::unhinged::audio::v1::LanguageDetection* AudioAnalysis::_internal_add_detected_languages() {
  return _impl_.detected_languages_.Add();
}
inline ::unhinged::audio::v1::LanguageDetection* AudioAnalysis::add_detected_languages() {
  ::unhinged::audio::v1::LanguageDetection* _add = _internal_add_detected_languages();
  // @@protoc_insertion_point(field_add:unhinged.audio.v1.AudioAnalysis.detected_languages)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::audio::v1::LanguageDetection >&
AudioAnalysis::detected_languages() const {
  // @@protoc_insertion_point(field_list:unhinged.audio.v1.AudioAnalysis.detected_languages)
  return _impl_.detected_languages_;
}

// int32 speaker_count = 5;
inline void AudioAnalysis::clear_speaker_count() {
  _impl_.speaker_count_ = 0;
}
inline int32_t AudioAnalysis::_internal_speaker_count() const {
  return _impl_.speaker_count_;
}
inline int32_t AudioAnalysis::speaker_count() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.AudioAnalysis.speaker_count)
  return _internal_speaker_count();
}
inline void AudioAnalysis::_internal_set_speaker_count(int32_t value) {
  
  _impl_.speaker_count_ = value;
}
inline void AudioAnalysis::set_speaker_count(int32_t value) {
  _internal_set_speaker_count(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.AudioAnalysis.speaker_count)
}

// repeated .unhinged.audio.v1.SpeakerSegment speaker_segments = 6;
inline int AudioAnalysis::_internal_speaker_segments_size() const {
  return _impl_.speaker_segments_.size();
}
inline int AudioAnalysis::speaker_segments_size() const {
  return _internal_speaker_segments_size();
}
inline void AudioAnalysis::clear_speaker_segments() {
  _impl_.speaker_segments_.Clear();
}
inline ::unhinged::audio::v1::SpeakerSegment* AudioAnalysis::mutable_speaker_segments(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.AudioAnalysis.speaker_segments)
  return _impl_.speaker_segments_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::audio::v1::SpeakerSegment >*
AudioAnalysis::mutable_speaker_segments() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.audio.v1.AudioAnalysis.speaker_segments)
  return &_impl_.speaker_segments_;
}
inline const ::unhinged::audio::v1::SpeakerSegment& AudioAnalysis::_internal_speaker_segments(int index) const {
  return _impl_.speaker_segments_.Get(index);
}
inline const ::unhinged::audio::v1::SpeakerSegment& AudioAnalysis::speaker_segments(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.AudioAnalysis.speaker_segments)
  return _internal_speaker_segments(index);
}
inline ::unhinged::audio::v1::SpeakerSegment* AudioAnalysis::_internal_add_speaker_segments() {
  return _impl_.speaker_segments_.Add();
}
inline ::unhinged::audio::v1::SpeakerSegment* AudioAnalysis::add_speaker_segments() {
  ::unhinged::audio::v1::SpeakerSegment* _add = _internal_add_speaker_segments();
  // @@protoc_insertion_point(field_add:unhinged.audio.v1.AudioAnalysis.speaker_segments)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::audio::v1::SpeakerSegment >&
AudioAnalysis::speaker_segments() const {
  // @@protoc_insertion_point(field_list:unhinged.audio.v1.AudioAnalysis.speaker_segments)
  return _impl_.speaker_segments_;
}

// repeated .unhinged.audio.v1.EmotionSegment emotion_segments = 7;
inline int AudioAnalysis::_internal_emotion_segments_size() const {
  return _impl_.emotion_segments_.size();
}
inline int AudioAnalysis::emotion_segments_size() const {
  return _internal_emotion_segments_size();
}
inline void AudioAnalysis::clear_emotion_segments() {
  _impl_.emotion_segments_.Clear();
}
inline ::unhinged::audio::v1::EmotionSegment* AudioAnalysis::mutable_emotion_segments(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.AudioAnalysis.emotion_segments)
  return _impl_.emotion_segments_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::audio::v1::EmotionSegment >*
AudioAnalysis::mutable_emotion_segments() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.audio.v1.AudioAnalysis.emotion_segments)
  return &_impl_.emotion_segments_;
}
inline const ::unhinged::audio::v1::EmotionSegment& AudioAnalysis::_internal_emotion_segments(int index) const {
  return _impl_.emotion_segments_.Get(index);
}
inline const ::unhinged::audio::v1::EmotionSegment& AudioAnalysis::emotion_segments(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.AudioAnalysis.emotion_segments)
  return _internal_emotion_segments(index);
}
inline ::unhinged::audio::v1::EmotionSegment* AudioAnalysis::_internal_add_emotion_segments() {
  return _impl_.emotion_segments_.Add();
}
inline ::unhinged::audio::v1::EmotionSegment* AudioAnalysis::add_emotion_segments() {
  ::unhinged::audio::v1::EmotionSegment* _add = _internal_add_emotion_segments();
  // @@protoc_insertion_point(field_add:unhinged.audio.v1.AudioAnalysis.emotion_segments)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::audio::v1::EmotionSegment >&
AudioAnalysis::emotion_segments() const {
  // @@protoc_insertion_point(field_list:unhinged.audio.v1.AudioAnalysis.emotion_segments)
  return _impl_.emotion_segments_;
}

// .unhinged.audio.v1.AudioQualityMetrics quality_metrics = 8;
inline bool AudioAnalysis::_internal_has_quality_metrics() const {
  return this != internal_default_instance() && _impl_.quality_metrics_ != nullptr;
}
inline bool AudioAnalysis::has_quality_metrics() const {
  return _internal_has_quality_metrics();
}
inline void AudioAnalysis::clear_quality_metrics() {
  if (GetArenaForAllocation() == nullptr && _impl_.quality_metrics_ != nullptr) {
    delete _impl_.quality_metrics_;
  }
  _impl_.quality_metrics_ = nullptr;
}
inline const ::unhinged::audio::v1::AudioQualityMetrics& AudioAnalysis::_internal_quality_metrics() const {
  const ::unhinged::audio::v1::AudioQualityMetrics* p = _impl_.quality_metrics_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::audio::v1::AudioQualityMetrics&>(
      ::unhinged::audio::v1::_AudioQualityMetrics_default_instance_);
}
inline const ::unhinged::audio::v1::AudioQualityMetrics& AudioAnalysis::quality_metrics() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.AudioAnalysis.quality_metrics)
  return _internal_quality_metrics();
}
inline void AudioAnalysis::unsafe_arena_set_allocated_quality_metrics(
    ::unhinged::audio::v1::AudioQualityMetrics* quality_metrics) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.quality_metrics_);
  }
  _impl_.quality_metrics_ = quality_metrics;
  if (quality_metrics) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.audio.v1.AudioAnalysis.quality_metrics)
}
inline ::unhinged::audio::v1::AudioQualityMetrics* AudioAnalysis::release_quality_metrics() {
  
  ::unhinged::audio::v1::AudioQualityMetrics* temp = _impl_.quality_metrics_;
  _impl_.quality_metrics_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::audio::v1::AudioQualityMetrics* AudioAnalysis::unsafe_arena_release_quality_metrics() {
  // @@protoc_insertion_point(field_release:unhinged.audio.v1.AudioAnalysis.quality_metrics)
  
  ::unhinged::audio::v1::AudioQualityMetrics* temp = _impl_.quality_metrics_;
  _impl_.quality_metrics_ = nullptr;
  return temp;
}
inline ::unhinged::audio::v1::AudioQualityMetrics* AudioAnalysis::_internal_mutable_quality_metrics() {
  
  if (_impl_.quality_metrics_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::audio::v1::AudioQualityMetrics>(GetArenaForAllocation());
    _impl_.quality_metrics_ = p;
  }
  return _impl_.quality_metrics_;
}
inline ::unhinged::audio::v1::AudioQualityMetrics* AudioAnalysis::mutable_quality_metrics() {
  ::unhinged::audio::v1::AudioQualityMetrics* _msg = _internal_mutable_quality_metrics();
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.AudioAnalysis.quality_metrics)
  return _msg;
}
inline void AudioAnalysis::set_allocated_quality_metrics(::unhinged::audio::v1::AudioQualityMetrics* quality_metrics) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.quality_metrics_;
  }
  if (quality_metrics) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(quality_metrics);
    if (message_arena != submessage_arena) {
      quality_metrics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, quality_metrics, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.quality_metrics_ = quality_metrics;
  // @@protoc_insertion_point(field_set_allocated:unhinged.audio.v1.AudioAnalysis.quality_metrics)
}

// -------------------------------------------------------------------

// SpeechSegment

// float start_time = 1;
inline void SpeechSegment::clear_start_time() {
  _impl_.start_time_ = 0;
}
inline float SpeechSegment::_internal_start_time() const {
  return _impl_.start_time_;
}
inline float SpeechSegment::start_time() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.SpeechSegment.start_time)
  return _internal_start_time();
}
inline void SpeechSegment::_internal_set_start_time(float value) {
  
  _impl_.start_time_ = value;
}
inline void SpeechSegment::set_start_time(float value) {
  _internal_set_start_time(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.SpeechSegment.start_time)
}

// float end_time = 2;
inline void SpeechSegment::clear_end_time() {
  _impl_.end_time_ = 0;
}
inline float SpeechSegment::_internal_end_time() const {
  return _impl_.end_time_;
}
inline float SpeechSegment::end_time() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.SpeechSegment.end_time)
  return _internal_end_time();
}
inline void SpeechSegment::_internal_set_end_time(float value) {
  
  _impl_.end_time_ = value;
}
inline void SpeechSegment::set_end_time(float value) {
  _internal_set_end_time(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.SpeechSegment.end_time)
}

// float confidence = 3;
inline void SpeechSegment::clear_confidence() {
  _impl_.confidence_ = 0;
}
inline float SpeechSegment::_internal_confidence() const {
  return _impl_.confidence_;
}
inline float SpeechSegment::confidence() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.SpeechSegment.confidence)
  return _internal_confidence();
}
inline void SpeechSegment::_internal_set_confidence(float value) {
  
  _impl_.confidence_ = value;
}
inline void SpeechSegment::set_confidence(float value) {
  _internal_set_confidence(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.SpeechSegment.confidence)
}

// -------------------------------------------------------------------

// LanguageDetection

// string language = 1;
inline void LanguageDetection::clear_language() {
  _impl_.language_.ClearToEmpty();
}
inline const std::string& LanguageDetection::language() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.LanguageDetection.language)
  return _internal_language();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LanguageDetection::set_language(ArgT0&& arg0, ArgT... args) {
 
 _impl_.language_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.LanguageDetection.language)
}
inline std::string* LanguageDetection::mutable_language() {
  std::string* _s = _internal_mutable_language();
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.LanguageDetection.language)
  return _s;
}
inline const std::string& LanguageDetection::_internal_language() const {
  return _impl_.language_.Get();
}
inline void LanguageDetection::_internal_set_language(const std::string& value) {
  
  _impl_.language_.Set(value, GetArenaForAllocation());
}
inline std::string* LanguageDetection::_internal_mutable_language() {
  
  return _impl_.language_.Mutable(GetArenaForAllocation());
}
inline std::string* LanguageDetection::release_language() {
  // @@protoc_insertion_point(field_release:unhinged.audio.v1.LanguageDetection.language)
  return _impl_.language_.Release();
}
inline void LanguageDetection::set_allocated_language(std::string* language) {
  if (language != nullptr) {
    
  } else {
    
  }
  _impl_.language_.SetAllocated(language, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.language_.IsDefault()) {
    _impl_.language_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.audio.v1.LanguageDetection.language)
}

// string language_code = 2;
inline void LanguageDetection::clear_language_code() {
  _impl_.language_code_.ClearToEmpty();
}
inline const std::string& LanguageDetection::language_code() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.LanguageDetection.language_code)
  return _internal_language_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LanguageDetection::set_language_code(ArgT0&& arg0, ArgT... args) {
 
 _impl_.language_code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.LanguageDetection.language_code)
}
inline std::string* LanguageDetection::mutable_language_code() {
  std::string* _s = _internal_mutable_language_code();
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.LanguageDetection.language_code)
  return _s;
}
inline const std::string& LanguageDetection::_internal_language_code() const {
  return _impl_.language_code_.Get();
}
inline void LanguageDetection::_internal_set_language_code(const std::string& value) {
  
  _impl_.language_code_.Set(value, GetArenaForAllocation());
}
inline std::string* LanguageDetection::_internal_mutable_language_code() {
  
  return _impl_.language_code_.Mutable(GetArenaForAllocation());
}
inline std::string* LanguageDetection::release_language_code() {
  // @@protoc_insertion_point(field_release:unhinged.audio.v1.LanguageDetection.language_code)
  return _impl_.language_code_.Release();
}
inline void LanguageDetection::set_allocated_language_code(std::string* language_code) {
  if (language_code != nullptr) {
    
  } else {
    
  }
  _impl_.language_code_.SetAllocated(language_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.language_code_.IsDefault()) {
    _impl_.language_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.audio.v1.LanguageDetection.language_code)
}

// float confidence = 3;
inline void LanguageDetection::clear_confidence() {
  _impl_.confidence_ = 0;
}
inline float LanguageDetection::_internal_confidence() const {
  return _impl_.confidence_;
}
inline float LanguageDetection::confidence() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.LanguageDetection.confidence)
  return _internal_confidence();
}
inline void LanguageDetection::_internal_set_confidence(float value) {
  
  _impl_.confidence_ = value;
}
inline void LanguageDetection::set_confidence(float value) {
  _internal_set_confidence(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.LanguageDetection.confidence)
}

// -------------------------------------------------------------------

// SpeakerSegment

// string speaker_id = 1;
inline void SpeakerSegment::clear_speaker_id() {
  _impl_.speaker_id_.ClearToEmpty();
}
inline const std::string& SpeakerSegment::speaker_id() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.SpeakerSegment.speaker_id)
  return _internal_speaker_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SpeakerSegment::set_speaker_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.speaker_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.SpeakerSegment.speaker_id)
}
inline std::string* SpeakerSegment::mutable_speaker_id() {
  std::string* _s = _internal_mutable_speaker_id();
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.SpeakerSegment.speaker_id)
  return _s;
}
inline const std::string& SpeakerSegment::_internal_speaker_id() const {
  return _impl_.speaker_id_.Get();
}
inline void SpeakerSegment::_internal_set_speaker_id(const std::string& value) {
  
  _impl_.speaker_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SpeakerSegment::_internal_mutable_speaker_id() {
  
  return _impl_.speaker_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SpeakerSegment::release_speaker_id() {
  // @@protoc_insertion_point(field_release:unhinged.audio.v1.SpeakerSegment.speaker_id)
  return _impl_.speaker_id_.Release();
}
inline void SpeakerSegment::set_allocated_speaker_id(std::string* speaker_id) {
  if (speaker_id != nullptr) {
    
  } else {
    
  }
  _impl_.speaker_id_.SetAllocated(speaker_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.speaker_id_.IsDefault()) {
    _impl_.speaker_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.audio.v1.SpeakerSegment.speaker_id)
}

// float start_time = 2;
inline void SpeakerSegment::clear_start_time() {
  _impl_.start_time_ = 0;
}
inline float SpeakerSegment::_internal_start_time() const {
  return _impl_.start_time_;
}
inline float SpeakerSegment::start_time() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.SpeakerSegment.start_time)
  return _internal_start_time();
}
inline void SpeakerSegment::_internal_set_start_time(float value) {
  
  _impl_.start_time_ = value;
}
inline void SpeakerSegment::set_start_time(float value) {
  _internal_set_start_time(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.SpeakerSegment.start_time)
}

// float end_time = 3;
inline void SpeakerSegment::clear_end_time() {
  _impl_.end_time_ = 0;
}
inline float SpeakerSegment::_internal_end_time() const {
  return _impl_.end_time_;
}
inline float SpeakerSegment::end_time() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.SpeakerSegment.end_time)
  return _internal_end_time();
}
inline void SpeakerSegment::_internal_set_end_time(float value) {
  
  _impl_.end_time_ = value;
}
inline void SpeakerSegment::set_end_time(float value) {
  _internal_set_end_time(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.SpeakerSegment.end_time)
}

// float confidence = 4;
inline void SpeakerSegment::clear_confidence() {
  _impl_.confidence_ = 0;
}
inline float SpeakerSegment::_internal_confidence() const {
  return _impl_.confidence_;
}
inline float SpeakerSegment::confidence() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.SpeakerSegment.confidence)
  return _internal_confidence();
}
inline void SpeakerSegment::_internal_set_confidence(float value) {
  
  _impl_.confidence_ = value;
}
inline void SpeakerSegment::set_confidence(float value) {
  _internal_set_confidence(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.SpeakerSegment.confidence)
}

// -------------------------------------------------------------------

// EmotionSegment

// string emotion = 1;
inline void EmotionSegment::clear_emotion() {
  _impl_.emotion_.ClearToEmpty();
}
inline const std::string& EmotionSegment::emotion() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.EmotionSegment.emotion)
  return _internal_emotion();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EmotionSegment::set_emotion(ArgT0&& arg0, ArgT... args) {
 
 _impl_.emotion_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.EmotionSegment.emotion)
}
inline std::string* EmotionSegment::mutable_emotion() {
  std::string* _s = _internal_mutable_emotion();
  // @@protoc_insertion_point(field_mutable:unhinged.audio.v1.EmotionSegment.emotion)
  return _s;
}
inline const std::string& EmotionSegment::_internal_emotion() const {
  return _impl_.emotion_.Get();
}
inline void EmotionSegment::_internal_set_emotion(const std::string& value) {
  
  _impl_.emotion_.Set(value, GetArenaForAllocation());
}
inline std::string* EmotionSegment::_internal_mutable_emotion() {
  
  return _impl_.emotion_.Mutable(GetArenaForAllocation());
}
inline std::string* EmotionSegment::release_emotion() {
  // @@protoc_insertion_point(field_release:unhinged.audio.v1.EmotionSegment.emotion)
  return _impl_.emotion_.Release();
}
inline void EmotionSegment::set_allocated_emotion(std::string* emotion) {
  if (emotion != nullptr) {
    
  } else {
    
  }
  _impl_.emotion_.SetAllocated(emotion, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.emotion_.IsDefault()) {
    _impl_.emotion_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.audio.v1.EmotionSegment.emotion)
}

// float start_time = 2;
inline void EmotionSegment::clear_start_time() {
  _impl_.start_time_ = 0;
}
inline float EmotionSegment::_internal_start_time() const {
  return _impl_.start_time_;
}
inline float EmotionSegment::start_time() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.EmotionSegment.start_time)
  return _internal_start_time();
}
inline void EmotionSegment::_internal_set_start_time(float value) {
  
  _impl_.start_time_ = value;
}
inline void EmotionSegment::set_start_time(float value) {
  _internal_set_start_time(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.EmotionSegment.start_time)
}

// float end_time = 3;
inline void EmotionSegment::clear_end_time() {
  _impl_.end_time_ = 0;
}
inline float EmotionSegment::_internal_end_time() const {
  return _impl_.end_time_;
}
inline float EmotionSegment::end_time() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.EmotionSegment.end_time)
  return _internal_end_time();
}
inline void EmotionSegment::_internal_set_end_time(float value) {
  
  _impl_.end_time_ = value;
}
inline void EmotionSegment::set_end_time(float value) {
  _internal_set_end_time(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.EmotionSegment.end_time)
}

// float confidence = 4;
inline void EmotionSegment::clear_confidence() {
  _impl_.confidence_ = 0;
}
inline float EmotionSegment::_internal_confidence() const {
  return _impl_.confidence_;
}
inline float EmotionSegment::confidence() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.EmotionSegment.confidence)
  return _internal_confidence();
}
inline void EmotionSegment::_internal_set_confidence(float value) {
  
  _impl_.confidence_ = value;
}
inline void EmotionSegment::set_confidence(float value) {
  _internal_set_confidence(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.EmotionSegment.confidence)
}

// float intensity = 5;
inline void EmotionSegment::clear_intensity() {
  _impl_.intensity_ = 0;
}
inline float EmotionSegment::_internal_intensity() const {
  return _impl_.intensity_;
}
inline float EmotionSegment::intensity() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.EmotionSegment.intensity)
  return _internal_intensity();
}
inline void EmotionSegment::_internal_set_intensity(float value) {
  
  _impl_.intensity_ = value;
}
inline void EmotionSegment::set_intensity(float value) {
  _internal_set_intensity(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.EmotionSegment.intensity)
}

// -------------------------------------------------------------------

// AudioQualityMetrics

// float signal_to_noise_ratio = 1;
inline void AudioQualityMetrics::clear_signal_to_noise_ratio() {
  _impl_.signal_to_noise_ratio_ = 0;
}
inline float AudioQualityMetrics::_internal_signal_to_noise_ratio() const {
  return _impl_.signal_to_noise_ratio_;
}
inline float AudioQualityMetrics::signal_to_noise_ratio() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.AudioQualityMetrics.signal_to_noise_ratio)
  return _internal_signal_to_noise_ratio();
}
inline void AudioQualityMetrics::_internal_set_signal_to_noise_ratio(float value) {
  
  _impl_.signal_to_noise_ratio_ = value;
}
inline void AudioQualityMetrics::set_signal_to_noise_ratio(float value) {
  _internal_set_signal_to_noise_ratio(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.AudioQualityMetrics.signal_to_noise_ratio)
}

// float dynamic_range = 2;
inline void AudioQualityMetrics::clear_dynamic_range() {
  _impl_.dynamic_range_ = 0;
}
inline float AudioQualityMetrics::_internal_dynamic_range() const {
  return _impl_.dynamic_range_;
}
inline float AudioQualityMetrics::dynamic_range() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.AudioQualityMetrics.dynamic_range)
  return _internal_dynamic_range();
}
inline void AudioQualityMetrics::_internal_set_dynamic_range(float value) {
  
  _impl_.dynamic_range_ = value;
}
inline void AudioQualityMetrics::set_dynamic_range(float value) {
  _internal_set_dynamic_range(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.AudioQualityMetrics.dynamic_range)
}

// bool has_clipping = 3;
inline void AudioQualityMetrics::clear_has_clipping() {
  _impl_.has_clipping_ = false;
}
inline bool AudioQualityMetrics::_internal_has_clipping() const {
  return _impl_.has_clipping_;
}
inline bool AudioQualityMetrics::has_clipping() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.AudioQualityMetrics.has_clipping)
  return _internal_has_clipping();
}
inline void AudioQualityMetrics::_internal_set_has_clipping(bool value) {
  
  _impl_.has_clipping_ = value;
}
inline void AudioQualityMetrics::set_has_clipping(bool value) {
  _internal_set_has_clipping(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.AudioQualityMetrics.has_clipping)
}

// bool has_background_noise = 4;
inline void AudioQualityMetrics::clear_has_background_noise() {
  _impl_.has_background_noise_ = false;
}
inline bool AudioQualityMetrics::_internal_has_background_noise() const {
  return _impl_.has_background_noise_;
}
inline bool AudioQualityMetrics::has_background_noise() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.AudioQualityMetrics.has_background_noise)
  return _internal_has_background_noise();
}
inline void AudioQualityMetrics::_internal_set_has_background_noise(bool value) {
  
  _impl_.has_background_noise_ = value;
}
inline void AudioQualityMetrics::set_has_background_noise(bool value) {
  _internal_set_has_background_noise(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.AudioQualityMetrics.has_background_noise)
}

// float overall_quality_score = 5;
inline void AudioQualityMetrics::clear_overall_quality_score() {
  _impl_.overall_quality_score_ = 0;
}
inline float AudioQualityMetrics::_internal_overall_quality_score() const {
  return _impl_.overall_quality_score_;
}
inline float AudioQualityMetrics::overall_quality_score() const {
  // @@protoc_insertion_point(field_get:unhinged.audio.v1.AudioQualityMetrics.overall_quality_score)
  return _internal_overall_quality_score();
}
inline void AudioQualityMetrics::_internal_set_overall_quality_score(float value) {
  
  _impl_.overall_quality_score_ = value;
}
inline void AudioQualityMetrics::set_overall_quality_score(float value) {
  _internal_set_overall_quality_score(value);
  // @@protoc_insertion_point(field_set:unhinged.audio.v1.AudioQualityMetrics.overall_quality_score)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace audio
}  // namespace unhinged

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::unhinged::audio::v1::AudioQuality> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::unhinged::audio::v1::AudioQuality>() {
  return ::unhinged::audio::v1::AudioQuality_descriptor();
}
template <> struct is_proto_enum< ::unhinged::audio::v1::AudioFormat> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::unhinged::audio::v1::AudioFormat>() {
  return ::unhinged::audio::v1::AudioFormat_descriptor();
}
template <> struct is_proto_enum< ::unhinged::audio::v1::AudioEffectType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::unhinged::audio::v1::AudioEffectType>() {
  return ::unhinged::audio::v1::AudioEffectType_descriptor();
}
template <> struct is_proto_enum< ::unhinged::audio::v1::VoiceGender> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::unhinged::audio::v1::VoiceGender>() {
  return ::unhinged::audio::v1::VoiceGender_descriptor();
}
template <> struct is_proto_enum< ::unhinged::audio::v1::VoiceAge> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::unhinged::audio::v1::VoiceAge>() {
  return ::unhinged::audio::v1::VoiceAge_descriptor();
}
template <> struct is_proto_enum< ::unhinged::audio::v1::VoiceStyle> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::unhinged::audio::v1::VoiceStyle>() {
  return ::unhinged::audio::v1::VoiceStyle_descriptor();
}
template <> struct is_proto_enum< ::unhinged::audio::v1::ProcessingType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::unhinged::audio::v1::ProcessingType>() {
  return ::unhinged::audio::v1::ProcessingType_descriptor();
}
template <> struct is_proto_enum< ::unhinged::audio::v1::AnalysisType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::unhinged::audio::v1::AnalysisType>() {
  return ::unhinged::audio::v1::AnalysisType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_audio_2eproto
