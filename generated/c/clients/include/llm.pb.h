// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: llm.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_llm_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_llm_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
#include "chat.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_llm_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_llm_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_llm_2eproto;
namespace unhinged {
namespace llm {
namespace v1 {
class ChatMessageList;
struct ChatMessageListDefaultTypeInternal;
extern ChatMessageListDefaultTypeInternal _ChatMessageList_default_instance_;
class CompletionChoice;
struct CompletionChoiceDefaultTypeInternal;
extern CompletionChoiceDefaultTypeInternal _CompletionChoice_default_instance_;
class CompletionChunkPayload;
struct CompletionChunkPayloadDefaultTypeInternal;
extern CompletionChunkPayloadDefaultTypeInternal _CompletionChunkPayload_default_instance_;
class CompletionMetadata;
struct CompletionMetadataDefaultTypeInternal;
extern CompletionMetadataDefaultTypeInternal _CompletionMetadata_default_instance_;
class CompletionOptions;
struct CompletionOptionsDefaultTypeInternal;
extern CompletionOptionsDefaultTypeInternal _CompletionOptions_default_instance_;
class CompletionRequest;
struct CompletionRequestDefaultTypeInternal;
extern CompletionRequestDefaultTypeInternal _CompletionRequest_default_instance_;
class CompletionResponse;
struct CompletionResponseDefaultTypeInternal;
extern CompletionResponseDefaultTypeInternal _CompletionResponse_default_instance_;
class ContextOptions;
struct ContextOptionsDefaultTypeInternal;
extern ContextOptionsDefaultTypeInternal _ContextOptions_default_instance_;
class DocumentTokens;
struct DocumentTokensDefaultTypeInternal;
extern DocumentTokensDefaultTypeInternal _DocumentTokens_default_instance_;
class GetModelRequest;
struct GetModelRequestDefaultTypeInternal;
extern GetModelRequestDefaultTypeInternal _GetModelRequest_default_instance_;
class GetModelResponse;
struct GetModelResponseDefaultTypeInternal;
extern GetModelResponseDefaultTypeInternal _GetModelResponse_default_instance_;
class ListModelsRequest;
struct ListModelsRequestDefaultTypeInternal;
extern ListModelsRequestDefaultTypeInternal _ListModelsRequest_default_instance_;
class ListModelsResponse;
struct ListModelsResponseDefaultTypeInternal;
extern ListModelsResponseDefaultTypeInternal _ListModelsResponse_default_instance_;
class Model;
struct ModelDefaultTypeInternal;
extern ModelDefaultTypeInternal _Model_default_instance_;
class ModelCapabilities;
struct ModelCapabilitiesDefaultTypeInternal;
extern ModelCapabilitiesDefaultTypeInternal _ModelCapabilities_default_instance_;
class ModelLimits;
struct ModelLimitsDefaultTypeInternal;
extern ModelLimitsDefaultTypeInternal _ModelLimits_default_instance_;
class ModelPricing;
struct ModelPricingDefaultTypeInternal;
extern ModelPricingDefaultTypeInternal _ModelPricing_default_instance_;
class TokenBreakdown;
struct TokenBreakdownDefaultTypeInternal;
extern TokenBreakdownDefaultTypeInternal _TokenBreakdown_default_instance_;
class TokenCountRequest;
struct TokenCountRequestDefaultTypeInternal;
extern TokenCountRequestDefaultTypeInternal _TokenCountRequest_default_instance_;
class TokenCountResponse;
struct TokenCountResponseDefaultTypeInternal;
extern TokenCountResponseDefaultTypeInternal _TokenCountResponse_default_instance_;
class TokenEstimationRequest;
struct TokenEstimationRequestDefaultTypeInternal;
extern TokenEstimationRequestDefaultTypeInternal _TokenEstimationRequest_default_instance_;
class TokenEstimationResponse;
struct TokenEstimationResponseDefaultTypeInternal;
extern TokenEstimationResponseDefaultTypeInternal _TokenEstimationResponse_default_instance_;
class TokenInfo;
struct TokenInfoDefaultTypeInternal;
extern TokenInfoDefaultTypeInternal _TokenInfo_default_instance_;
class ToolDefinition;
struct ToolDefinitionDefaultTypeInternal;
extern ToolDefinitionDefaultTypeInternal _ToolDefinition_default_instance_;
}  // namespace v1
}  // namespace llm
}  // namespace unhinged
PROTOBUF_NAMESPACE_OPEN
template<> ::unhinged::llm::v1::ChatMessageList* Arena::CreateMaybeMessage<::unhinged::llm::v1::ChatMessageList>(Arena*);
template<> ::unhinged::llm::v1::CompletionChoice* Arena::CreateMaybeMessage<::unhinged::llm::v1::CompletionChoice>(Arena*);
template<> ::unhinged::llm::v1::CompletionChunkPayload* Arena::CreateMaybeMessage<::unhinged::llm::v1::CompletionChunkPayload>(Arena*);
template<> ::unhinged::llm::v1::CompletionMetadata* Arena::CreateMaybeMessage<::unhinged::llm::v1::CompletionMetadata>(Arena*);
template<> ::unhinged::llm::v1::CompletionOptions* Arena::CreateMaybeMessage<::unhinged::llm::v1::CompletionOptions>(Arena*);
template<> ::unhinged::llm::v1::CompletionRequest* Arena::CreateMaybeMessage<::unhinged::llm::v1::CompletionRequest>(Arena*);
template<> ::unhinged::llm::v1::CompletionResponse* Arena::CreateMaybeMessage<::unhinged::llm::v1::CompletionResponse>(Arena*);
template<> ::unhinged::llm::v1::ContextOptions* Arena::CreateMaybeMessage<::unhinged::llm::v1::ContextOptions>(Arena*);
template<> ::unhinged::llm::v1::DocumentTokens* Arena::CreateMaybeMessage<::unhinged::llm::v1::DocumentTokens>(Arena*);
template<> ::unhinged::llm::v1::GetModelRequest* Arena::CreateMaybeMessage<::unhinged::llm::v1::GetModelRequest>(Arena*);
template<> ::unhinged::llm::v1::GetModelResponse* Arena::CreateMaybeMessage<::unhinged::llm::v1::GetModelResponse>(Arena*);
template<> ::unhinged::llm::v1::ListModelsRequest* Arena::CreateMaybeMessage<::unhinged::llm::v1::ListModelsRequest>(Arena*);
template<> ::unhinged::llm::v1::ListModelsResponse* Arena::CreateMaybeMessage<::unhinged::llm::v1::ListModelsResponse>(Arena*);
template<> ::unhinged::llm::v1::Model* Arena::CreateMaybeMessage<::unhinged::llm::v1::Model>(Arena*);
template<> ::unhinged::llm::v1::ModelCapabilities* Arena::CreateMaybeMessage<::unhinged::llm::v1::ModelCapabilities>(Arena*);
template<> ::unhinged::llm::v1::ModelLimits* Arena::CreateMaybeMessage<::unhinged::llm::v1::ModelLimits>(Arena*);
template<> ::unhinged::llm::v1::ModelPricing* Arena::CreateMaybeMessage<::unhinged::llm::v1::ModelPricing>(Arena*);
template<> ::unhinged::llm::v1::TokenBreakdown* Arena::CreateMaybeMessage<::unhinged::llm::v1::TokenBreakdown>(Arena*);
template<> ::unhinged::llm::v1::TokenCountRequest* Arena::CreateMaybeMessage<::unhinged::llm::v1::TokenCountRequest>(Arena*);
template<> ::unhinged::llm::v1::TokenCountResponse* Arena::CreateMaybeMessage<::unhinged::llm::v1::TokenCountResponse>(Arena*);
template<> ::unhinged::llm::v1::TokenEstimationRequest* Arena::CreateMaybeMessage<::unhinged::llm::v1::TokenEstimationRequest>(Arena*);
template<> ::unhinged::llm::v1::TokenEstimationResponse* Arena::CreateMaybeMessage<::unhinged::llm::v1::TokenEstimationResponse>(Arena*);
template<> ::unhinged::llm::v1::TokenInfo* Arena::CreateMaybeMessage<::unhinged::llm::v1::TokenInfo>(Arena*);
template<> ::unhinged::llm::v1::ToolDefinition* Arena::CreateMaybeMessage<::unhinged::llm::v1::ToolDefinition>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace unhinged {
namespace llm {
namespace v1 {

enum CompletionChunkType : int {
  COMPLETION_CHUNK_TYPE_UNSPECIFIED = 0,
  COMPLETION_CHUNK_TYPE_CONTENT = 1,
  COMPLETION_CHUNK_TYPE_TOOL_CALL = 2,
  COMPLETION_CHUNK_TYPE_TOOL_RESULT = 3,
  COMPLETION_CHUNK_TYPE_THINKING = 4,
  COMPLETION_CHUNK_TYPE_METADATA = 5,
  CompletionChunkType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CompletionChunkType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CompletionChunkType_IsValid(int value);
constexpr CompletionChunkType CompletionChunkType_MIN = COMPLETION_CHUNK_TYPE_UNSPECIFIED;
constexpr CompletionChunkType CompletionChunkType_MAX = COMPLETION_CHUNK_TYPE_METADATA;
constexpr int CompletionChunkType_ARRAYSIZE = CompletionChunkType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CompletionChunkType_descriptor();
template<typename T>
inline const std::string& CompletionChunkType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CompletionChunkType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CompletionChunkType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CompletionChunkType_descriptor(), enum_t_value);
}
inline bool CompletionChunkType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CompletionChunkType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CompletionChunkType>(
    CompletionChunkType_descriptor(), name, value);
}
// ===================================================================

class CompletionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.llm.v1.CompletionRequest) */ {
 public:
  inline CompletionRequest() : CompletionRequest(nullptr) {}
  ~CompletionRequest() override;
  explicit PROTOBUF_CONSTEXPR CompletionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CompletionRequest(const CompletionRequest& from);
  CompletionRequest(CompletionRequest&& from) noexcept
    : CompletionRequest() {
    *this = ::std::move(from);
  }

  inline CompletionRequest& operator=(const CompletionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompletionRequest& operator=(CompletionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompletionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompletionRequest* internal_default_instance() {
    return reinterpret_cast<const CompletionRequest*>(
               &_CompletionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CompletionRequest& a, CompletionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CompletionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompletionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompletionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CompletionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CompletionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CompletionRequest& from) {
    CompletionRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompletionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.llm.v1.CompletionRequest";
  }
  protected:
  explicit CompletionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessagesFieldNumber = 2,
    kModelFieldNumber = 1,
    kSessionIdFieldNumber = 4,
    kOptionsFieldNumber = 3,
    kContextOptionsFieldNumber = 6,
    kIncludeContextFieldNumber = 5,
  };
  // repeated .unhinged.chat.v1.ChatMessage messages = 2;
  int messages_size() const;
  private:
  int _internal_messages_size() const;
  public:
  void clear_messages();
  ::unhinged::chat::v1::ChatMessage* mutable_messages(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::chat::v1::ChatMessage >*
      mutable_messages();
  private:
  const ::unhinged::chat::v1::ChatMessage& _internal_messages(int index) const;
  ::unhinged::chat::v1::ChatMessage* _internal_add_messages();
  public:
  const ::unhinged::chat::v1::ChatMessage& messages(int index) const;
  ::unhinged::chat::v1::ChatMessage* add_messages();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::chat::v1::ChatMessage >&
      messages() const;

  // string model = 1;
  void clear_model();
  const std::string& model() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model();
  PROTOBUF_NODISCARD std::string* release_model();
  void set_allocated_model(std::string* model);
  private:
  const std::string& _internal_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model(const std::string& value);
  std::string* _internal_mutable_model();
  public:

  // string session_id = 4;
  void clear_session_id();
  const std::string& session_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // .unhinged.llm.v1.CompletionOptions options = 3;
  bool has_options() const;
  private:
  bool _internal_has_options() const;
  public:
  void clear_options();
  const ::unhinged::llm::v1::CompletionOptions& options() const;
  PROTOBUF_NODISCARD ::unhinged::llm::v1::CompletionOptions* release_options();
  ::unhinged::llm::v1::CompletionOptions* mutable_options();
  void set_allocated_options(::unhinged::llm::v1::CompletionOptions* options);
  private:
  const ::unhinged::llm::v1::CompletionOptions& _internal_options() const;
  ::unhinged::llm::v1::CompletionOptions* _internal_mutable_options();
  public:
  void unsafe_arena_set_allocated_options(
      ::unhinged::llm::v1::CompletionOptions* options);
  ::unhinged::llm::v1::CompletionOptions* unsafe_arena_release_options();

  // .unhinged.llm.v1.ContextOptions context_options = 6;
  bool has_context_options() const;
  private:
  bool _internal_has_context_options() const;
  public:
  void clear_context_options();
  const ::unhinged::llm::v1::ContextOptions& context_options() const;
  PROTOBUF_NODISCARD ::unhinged::llm::v1::ContextOptions* release_context_options();
  ::unhinged::llm::v1::ContextOptions* mutable_context_options();
  void set_allocated_context_options(::unhinged::llm::v1::ContextOptions* context_options);
  private:
  const ::unhinged::llm::v1::ContextOptions& _internal_context_options() const;
  ::unhinged::llm::v1::ContextOptions* _internal_mutable_context_options();
  public:
  void unsafe_arena_set_allocated_context_options(
      ::unhinged::llm::v1::ContextOptions* context_options);
  ::unhinged::llm::v1::ContextOptions* unsafe_arena_release_context_options();

  // bool include_context = 5;
  void clear_include_context();
  bool include_context() const;
  void set_include_context(bool value);
  private:
  bool _internal_include_context() const;
  void _internal_set_include_context(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.llm.v1.CompletionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::chat::v1::ChatMessage > messages_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
    ::unhinged::llm::v1::CompletionOptions* options_;
    ::unhinged::llm::v1::ContextOptions* context_options_;
    bool include_context_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_llm_2eproto;
};
// -------------------------------------------------------------------

class CompletionOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.llm.v1.CompletionOptions) */ {
 public:
  inline CompletionOptions() : CompletionOptions(nullptr) {}
  ~CompletionOptions() override;
  explicit PROTOBUF_CONSTEXPR CompletionOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CompletionOptions(const CompletionOptions& from);
  CompletionOptions(CompletionOptions&& from) noexcept
    : CompletionOptions() {
    *this = ::std::move(from);
  }

  inline CompletionOptions& operator=(const CompletionOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompletionOptions& operator=(CompletionOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompletionOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompletionOptions* internal_default_instance() {
    return reinterpret_cast<const CompletionOptions*>(
               &_CompletionOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CompletionOptions& a, CompletionOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(CompletionOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompletionOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompletionOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CompletionOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CompletionOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CompletionOptions& from) {
    CompletionOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompletionOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.llm.v1.CompletionOptions";
  }
  protected:
  explicit CompletionOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStopSequencesFieldNumber = 6,
    kToolsFieldNumber = 11,
    kToolChoiceFieldNumber = 12,
    kMaxTokensFieldNumber = 1,
    kTemperatureFieldNumber = 2,
    kTopPFieldNumber = 3,
    kFrequencyPenaltyFieldNumber = 4,
    kPresencePenaltyFieldNumber = 5,
    kStreamFieldNumber = 7,
    kIncludeUsageFieldNumber = 8,
    kEnableToolsFieldNumber = 10,
    kNFieldNumber = 9,
  };
  // repeated string stop_sequences = 6;
  int stop_sequences_size() const;
  private:
  int _internal_stop_sequences_size() const;
  public:
  void clear_stop_sequences();
  const std::string& stop_sequences(int index) const;
  std::string* mutable_stop_sequences(int index);
  void set_stop_sequences(int index, const std::string& value);
  void set_stop_sequences(int index, std::string&& value);
  void set_stop_sequences(int index, const char* value);
  void set_stop_sequences(int index, const char* value, size_t size);
  std::string* add_stop_sequences();
  void add_stop_sequences(const std::string& value);
  void add_stop_sequences(std::string&& value);
  void add_stop_sequences(const char* value);
  void add_stop_sequences(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& stop_sequences() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_stop_sequences();
  private:
  const std::string& _internal_stop_sequences(int index) const;
  std::string* _internal_add_stop_sequences();
  public:

  // repeated .unhinged.llm.v1.ToolDefinition tools = 11;
  int tools_size() const;
  private:
  int _internal_tools_size() const;
  public:
  void clear_tools();
  ::unhinged::llm::v1::ToolDefinition* mutable_tools(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::llm::v1::ToolDefinition >*
      mutable_tools();
  private:
  const ::unhinged::llm::v1::ToolDefinition& _internal_tools(int index) const;
  ::unhinged::llm::v1::ToolDefinition* _internal_add_tools();
  public:
  const ::unhinged::llm::v1::ToolDefinition& tools(int index) const;
  ::unhinged::llm::v1::ToolDefinition* add_tools();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::llm::v1::ToolDefinition >&
      tools() const;

  // string tool_choice = 12;
  void clear_tool_choice();
  const std::string& tool_choice() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tool_choice(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tool_choice();
  PROTOBUF_NODISCARD std::string* release_tool_choice();
  void set_allocated_tool_choice(std::string* tool_choice);
  private:
  const std::string& _internal_tool_choice() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tool_choice(const std::string& value);
  std::string* _internal_mutable_tool_choice();
  public:

  // int32 max_tokens = 1;
  void clear_max_tokens();
  int32_t max_tokens() const;
  void set_max_tokens(int32_t value);
  private:
  int32_t _internal_max_tokens() const;
  void _internal_set_max_tokens(int32_t value);
  public:

  // float temperature = 2;
  void clear_temperature();
  float temperature() const;
  void set_temperature(float value);
  private:
  float _internal_temperature() const;
  void _internal_set_temperature(float value);
  public:

  // float top_p = 3;
  void clear_top_p();
  float top_p() const;
  void set_top_p(float value);
  private:
  float _internal_top_p() const;
  void _internal_set_top_p(float value);
  public:

  // float frequency_penalty = 4;
  void clear_frequency_penalty();
  float frequency_penalty() const;
  void set_frequency_penalty(float value);
  private:
  float _internal_frequency_penalty() const;
  void _internal_set_frequency_penalty(float value);
  public:

  // float presence_penalty = 5;
  void clear_presence_penalty();
  float presence_penalty() const;
  void set_presence_penalty(float value);
  private:
  float _internal_presence_penalty() const;
  void _internal_set_presence_penalty(float value);
  public:

  // bool stream = 7;
  void clear_stream();
  bool stream() const;
  void set_stream(bool value);
  private:
  bool _internal_stream() const;
  void _internal_set_stream(bool value);
  public:

  // bool include_usage = 8;
  void clear_include_usage();
  bool include_usage() const;
  void set_include_usage(bool value);
  private:
  bool _internal_include_usage() const;
  void _internal_set_include_usage(bool value);
  public:

  // bool enable_tools = 10;
  void clear_enable_tools();
  bool enable_tools() const;
  void set_enable_tools(bool value);
  private:
  bool _internal_enable_tools() const;
  void _internal_set_enable_tools(bool value);
  public:

  // int32 n = 9;
  void clear_n();
  int32_t n() const;
  void set_n(int32_t value);
  private:
  int32_t _internal_n() const;
  void _internal_set_n(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.llm.v1.CompletionOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> stop_sequences_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::llm::v1::ToolDefinition > tools_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tool_choice_;
    int32_t max_tokens_;
    float temperature_;
    float top_p_;
    float frequency_penalty_;
    float presence_penalty_;
    bool stream_;
    bool include_usage_;
    bool enable_tools_;
    int32_t n_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_llm_2eproto;
};
// -------------------------------------------------------------------

class ContextOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.llm.v1.ContextOptions) */ {
 public:
  inline ContextOptions() : ContextOptions(nullptr) {}
  ~ContextOptions() override;
  explicit PROTOBUF_CONSTEXPR ContextOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContextOptions(const ContextOptions& from);
  ContextOptions(ContextOptions&& from) noexcept
    : ContextOptions() {
    *this = ::std::move(from);
  }

  inline ContextOptions& operator=(const ContextOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContextOptions& operator=(ContextOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContextOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContextOptions* internal_default_instance() {
    return reinterpret_cast<const ContextOptions*>(
               &_ContextOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ContextOptions& a, ContextOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(ContextOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContextOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContextOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContextOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ContextOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ContextOptions& from) {
    ContextOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContextOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.llm.v1.ContextOptions";
  }
  protected:
  explicit ContextOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDocumentTypesFieldNumber = 3,
    kMaxContextTokensFieldNumber = 1,
    kRelevanceThresholdFieldNumber = 2,
    kIncludeMetadataFieldNumber = 4,
  };
  // repeated string document_types = 3;
  int document_types_size() const;
  private:
  int _internal_document_types_size() const;
  public:
  void clear_document_types();
  const std::string& document_types(int index) const;
  std::string* mutable_document_types(int index);
  void set_document_types(int index, const std::string& value);
  void set_document_types(int index, std::string&& value);
  void set_document_types(int index, const char* value);
  void set_document_types(int index, const char* value, size_t size);
  std::string* add_document_types();
  void add_document_types(const std::string& value);
  void add_document_types(std::string&& value);
  void add_document_types(const char* value);
  void add_document_types(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& document_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_document_types();
  private:
  const std::string& _internal_document_types(int index) const;
  std::string* _internal_add_document_types();
  public:

  // int32 max_context_tokens = 1;
  void clear_max_context_tokens();
  int32_t max_context_tokens() const;
  void set_max_context_tokens(int32_t value);
  private:
  int32_t _internal_max_context_tokens() const;
  void _internal_set_max_context_tokens(int32_t value);
  public:

  // float relevance_threshold = 2;
  void clear_relevance_threshold();
  float relevance_threshold() const;
  void set_relevance_threshold(float value);
  private:
  float _internal_relevance_threshold() const;
  void _internal_set_relevance_threshold(float value);
  public:

  // bool include_metadata = 4;
  void clear_include_metadata();
  bool include_metadata() const;
  void set_include_metadata(bool value);
  private:
  bool _internal_include_metadata() const;
  void _internal_set_include_metadata(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.llm.v1.ContextOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> document_types_;
    int32_t max_context_tokens_;
    float relevance_threshold_;
    bool include_metadata_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_llm_2eproto;
};
// -------------------------------------------------------------------

class ToolDefinition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.llm.v1.ToolDefinition) */ {
 public:
  inline ToolDefinition() : ToolDefinition(nullptr) {}
  ~ToolDefinition() override;
  explicit PROTOBUF_CONSTEXPR ToolDefinition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ToolDefinition(const ToolDefinition& from);
  ToolDefinition(ToolDefinition&& from) noexcept
    : ToolDefinition() {
    *this = ::std::move(from);
  }

  inline ToolDefinition& operator=(const ToolDefinition& from) {
    CopyFrom(from);
    return *this;
  }
  inline ToolDefinition& operator=(ToolDefinition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ToolDefinition& default_instance() {
    return *internal_default_instance();
  }
  static inline const ToolDefinition* internal_default_instance() {
    return reinterpret_cast<const ToolDefinition*>(
               &_ToolDefinition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ToolDefinition& a, ToolDefinition& b) {
    a.Swap(&b);
  }
  inline void Swap(ToolDefinition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ToolDefinition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ToolDefinition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ToolDefinition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ToolDefinition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ToolDefinition& from) {
    ToolDefinition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ToolDefinition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.llm.v1.ToolDefinition";
  }
  protected:
  explicit ToolDefinition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kParametersSchemaFieldNumber = 3,
    kRequiredFieldNumber = 4,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string description = 2;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string parameters_schema = 3;
  void clear_parameters_schema();
  const std::string& parameters_schema() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parameters_schema(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parameters_schema();
  PROTOBUF_NODISCARD std::string* release_parameters_schema();
  void set_allocated_parameters_schema(std::string* parameters_schema);
  private:
  const std::string& _internal_parameters_schema() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parameters_schema(const std::string& value);
  std::string* _internal_mutable_parameters_schema();
  public:

  // bool required = 4;
  void clear_required();
  bool required() const;
  void set_required(bool value);
  private:
  bool _internal_required() const;
  void _internal_set_required(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.llm.v1.ToolDefinition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parameters_schema_;
    bool required_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_llm_2eproto;
};
// -------------------------------------------------------------------

class CompletionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.llm.v1.CompletionResponse) */ {
 public:
  inline CompletionResponse() : CompletionResponse(nullptr) {}
  ~CompletionResponse() override;
  explicit PROTOBUF_CONSTEXPR CompletionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CompletionResponse(const CompletionResponse& from);
  CompletionResponse(CompletionResponse&& from) noexcept
    : CompletionResponse() {
    *this = ::std::move(from);
  }

  inline CompletionResponse& operator=(const CompletionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompletionResponse& operator=(CompletionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompletionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompletionResponse* internal_default_instance() {
    return reinterpret_cast<const CompletionResponse*>(
               &_CompletionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CompletionResponse& a, CompletionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CompletionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompletionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompletionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CompletionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CompletionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CompletionResponse& from) {
    CompletionResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompletionResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.llm.v1.CompletionResponse";
  }
  protected:
  explicit CompletionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChoicesFieldNumber = 3,
    kCompletionIdFieldNumber = 2,
    kResponseFieldNumber = 1,
    kUsageFieldNumber = 4,
    kMetadataFieldNumber = 5,
  };
  // repeated .unhinged.llm.v1.CompletionChoice choices = 3;
  int choices_size() const;
  private:
  int _internal_choices_size() const;
  public:
  void clear_choices();
  ::unhinged::llm::v1::CompletionChoice* mutable_choices(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::llm::v1::CompletionChoice >*
      mutable_choices();
  private:
  const ::unhinged::llm::v1::CompletionChoice& _internal_choices(int index) const;
  ::unhinged::llm::v1::CompletionChoice* _internal_add_choices();
  public:
  const ::unhinged::llm::v1::CompletionChoice& choices(int index) const;
  ::unhinged::llm::v1::CompletionChoice* add_choices();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::llm::v1::CompletionChoice >&
      choices() const;

  // string completion_id = 2;
  void clear_completion_id();
  const std::string& completion_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_completion_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_completion_id();
  PROTOBUF_NODISCARD std::string* release_completion_id();
  void set_allocated_completion_id(std::string* completion_id);
  private:
  const std::string& _internal_completion_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_completion_id(const std::string& value);
  std::string* _internal_mutable_completion_id();
  public:

  // .unhinged.common.v1.StandardResponse response = 1;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::unhinged::common::v1::StandardResponse& response() const;
  PROTOBUF_NODISCARD ::unhinged::common::v1::StandardResponse* release_response();
  ::unhinged::common::v1::StandardResponse* mutable_response();
  void set_allocated_response(::unhinged::common::v1::StandardResponse* response);
  private:
  const ::unhinged::common::v1::StandardResponse& _internal_response() const;
  ::unhinged::common::v1::StandardResponse* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::unhinged::common::v1::StandardResponse* response);
  ::unhinged::common::v1::StandardResponse* unsafe_arena_release_response();

  // .unhinged.common.v1.UsageMetrics usage = 4;
  bool has_usage() const;
  private:
  bool _internal_has_usage() const;
  public:
  void clear_usage();
  const ::unhinged::common::v1::UsageMetrics& usage() const;
  PROTOBUF_NODISCARD ::unhinged::common::v1::UsageMetrics* release_usage();
  ::unhinged::common::v1::UsageMetrics* mutable_usage();
  void set_allocated_usage(::unhinged::common::v1::UsageMetrics* usage);
  private:
  const ::unhinged::common::v1::UsageMetrics& _internal_usage() const;
  ::unhinged::common::v1::UsageMetrics* _internal_mutable_usage();
  public:
  void unsafe_arena_set_allocated_usage(
      ::unhinged::common::v1::UsageMetrics* usage);
  ::unhinged::common::v1::UsageMetrics* unsafe_arena_release_usage();

  // .unhinged.llm.v1.CompletionMetadata metadata = 5;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::unhinged::llm::v1::CompletionMetadata& metadata() const;
  PROTOBUF_NODISCARD ::unhinged::llm::v1::CompletionMetadata* release_metadata();
  ::unhinged::llm::v1::CompletionMetadata* mutable_metadata();
  void set_allocated_metadata(::unhinged::llm::v1::CompletionMetadata* metadata);
  private:
  const ::unhinged::llm::v1::CompletionMetadata& _internal_metadata() const;
  ::unhinged::llm::v1::CompletionMetadata* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::unhinged::llm::v1::CompletionMetadata* metadata);
  ::unhinged::llm::v1::CompletionMetadata* unsafe_arena_release_metadata();

  // @@protoc_insertion_point(class_scope:unhinged.llm.v1.CompletionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::llm::v1::CompletionChoice > choices_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr completion_id_;
    ::unhinged::common::v1::StandardResponse* response_;
    ::unhinged::common::v1::UsageMetrics* usage_;
    ::unhinged::llm::v1::CompletionMetadata* metadata_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_llm_2eproto;
};
// -------------------------------------------------------------------

class CompletionChoice final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.llm.v1.CompletionChoice) */ {
 public:
  inline CompletionChoice() : CompletionChoice(nullptr) {}
  ~CompletionChoice() override;
  explicit PROTOBUF_CONSTEXPR CompletionChoice(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CompletionChoice(const CompletionChoice& from);
  CompletionChoice(CompletionChoice&& from) noexcept
    : CompletionChoice() {
    *this = ::std::move(from);
  }

  inline CompletionChoice& operator=(const CompletionChoice& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompletionChoice& operator=(CompletionChoice&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompletionChoice& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompletionChoice* internal_default_instance() {
    return reinterpret_cast<const CompletionChoice*>(
               &_CompletionChoice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CompletionChoice& a, CompletionChoice& b) {
    a.Swap(&b);
  }
  inline void Swap(CompletionChoice* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompletionChoice* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompletionChoice* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CompletionChoice>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CompletionChoice& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CompletionChoice& from) {
    CompletionChoice::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompletionChoice* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.llm.v1.CompletionChoice";
  }
  protected:
  explicit CompletionChoice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFinishReasonFieldNumber = 3,
    kMessageFieldNumber = 2,
    kIndexFieldNumber = 1,
    kLogprobsFieldNumber = 4,
  };
  // string finish_reason = 3;
  void clear_finish_reason();
  const std::string& finish_reason() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_finish_reason(ArgT0&& arg0, ArgT... args);
  std::string* mutable_finish_reason();
  PROTOBUF_NODISCARD std::string* release_finish_reason();
  void set_allocated_finish_reason(std::string* finish_reason);
  private:
  const std::string& _internal_finish_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_finish_reason(const std::string& value);
  std::string* _internal_mutable_finish_reason();
  public:

  // .unhinged.chat.v1.ChatMessage message = 2;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const ::unhinged::chat::v1::ChatMessage& message() const;
  PROTOBUF_NODISCARD ::unhinged::chat::v1::ChatMessage* release_message();
  ::unhinged::chat::v1::ChatMessage* mutable_message();
  void set_allocated_message(::unhinged::chat::v1::ChatMessage* message);
  private:
  const ::unhinged::chat::v1::ChatMessage& _internal_message() const;
  ::unhinged::chat::v1::ChatMessage* _internal_mutable_message();
  public:
  void unsafe_arena_set_allocated_message(
      ::unhinged::chat::v1::ChatMessage* message);
  ::unhinged::chat::v1::ChatMessage* unsafe_arena_release_message();

  // int32 index = 1;
  void clear_index();
  int32_t index() const;
  void set_index(int32_t value);
  private:
  int32_t _internal_index() const;
  void _internal_set_index(int32_t value);
  public:

  // float logprobs = 4;
  void clear_logprobs();
  float logprobs() const;
  void set_logprobs(float value);
  private:
  float _internal_logprobs() const;
  void _internal_set_logprobs(float value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.llm.v1.CompletionChoice)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr finish_reason_;
    ::unhinged::chat::v1::ChatMessage* message_;
    int32_t index_;
    float logprobs_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_llm_2eproto;
};
// -------------------------------------------------------------------

class CompletionMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.llm.v1.CompletionMetadata) */ {
 public:
  inline CompletionMetadata() : CompletionMetadata(nullptr) {}
  ~CompletionMetadata() override;
  explicit PROTOBUF_CONSTEXPR CompletionMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CompletionMetadata(const CompletionMetadata& from);
  CompletionMetadata(CompletionMetadata&& from) noexcept
    : CompletionMetadata() {
    *this = ::std::move(from);
  }

  inline CompletionMetadata& operator=(const CompletionMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompletionMetadata& operator=(CompletionMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompletionMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompletionMetadata* internal_default_instance() {
    return reinterpret_cast<const CompletionMetadata*>(
               &_CompletionMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CompletionMetadata& a, CompletionMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(CompletionMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompletionMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompletionMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CompletionMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CompletionMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CompletionMetadata& from) {
    CompletionMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompletionMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.llm.v1.CompletionMetadata";
  }
  protected:
  explicit CompletionMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContextDocumentIdsFieldNumber = 5,
    kModelFieldNumber = 1,
    kProviderFieldNumber = 2,
    kProcessingTimeMsFieldNumber = 3,
    kContextDocumentsUsedFieldNumber = 4,
  };
  // repeated string context_document_ids = 5;
  int context_document_ids_size() const;
  private:
  int _internal_context_document_ids_size() const;
  public:
  void clear_context_document_ids();
  const std::string& context_document_ids(int index) const;
  std::string* mutable_context_document_ids(int index);
  void set_context_document_ids(int index, const std::string& value);
  void set_context_document_ids(int index, std::string&& value);
  void set_context_document_ids(int index, const char* value);
  void set_context_document_ids(int index, const char* value, size_t size);
  std::string* add_context_document_ids();
  void add_context_document_ids(const std::string& value);
  void add_context_document_ids(std::string&& value);
  void add_context_document_ids(const char* value);
  void add_context_document_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& context_document_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_context_document_ids();
  private:
  const std::string& _internal_context_document_ids(int index) const;
  std::string* _internal_add_context_document_ids();
  public:

  // string model = 1;
  void clear_model();
  const std::string& model() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model();
  PROTOBUF_NODISCARD std::string* release_model();
  void set_allocated_model(std::string* model);
  private:
  const std::string& _internal_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model(const std::string& value);
  std::string* _internal_mutable_model();
  public:

  // string provider = 2;
  void clear_provider();
  const std::string& provider() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_provider(ArgT0&& arg0, ArgT... args);
  std::string* mutable_provider();
  PROTOBUF_NODISCARD std::string* release_provider();
  void set_allocated_provider(std::string* provider);
  private:
  const std::string& _internal_provider() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_provider(const std::string& value);
  std::string* _internal_mutable_provider();
  public:

  // float processing_time_ms = 3;
  void clear_processing_time_ms();
  float processing_time_ms() const;
  void set_processing_time_ms(float value);
  private:
  float _internal_processing_time_ms() const;
  void _internal_set_processing_time_ms(float value);
  public:

  // int32 context_documents_used = 4;
  void clear_context_documents_used();
  int32_t context_documents_used() const;
  void set_context_documents_used(int32_t value);
  private:
  int32_t _internal_context_documents_used() const;
  void _internal_set_context_documents_used(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.llm.v1.CompletionMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> context_document_ids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr provider_;
    float processing_time_ms_;
    int32_t context_documents_used_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_llm_2eproto;
};
// -------------------------------------------------------------------

class Model final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.llm.v1.Model) */ {
 public:
  inline Model() : Model(nullptr) {}
  ~Model() override;
  explicit PROTOBUF_CONSTEXPR Model(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Model(const Model& from);
  Model(Model&& from) noexcept
    : Model() {
    *this = ::std::move(from);
  }

  inline Model& operator=(const Model& from) {
    CopyFrom(from);
    return *this;
  }
  inline Model& operator=(Model&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Model& default_instance() {
    return *internal_default_instance();
  }
  static inline const Model* internal_default_instance() {
    return reinterpret_cast<const Model*>(
               &_Model_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Model& a, Model& b) {
    a.Swap(&b);
  }
  inline void Swap(Model* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Model* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Model* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Model>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Model& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Model& from) {
    Model::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Model* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.llm.v1.Model";
  }
  protected:
  explicit Model(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kProviderFieldNumber = 3,
    kDescriptionFieldNumber = 4,
    kStatusFieldNumber = 9,
    kMetadataFieldNumber = 1,
    kCapabilitiesFieldNumber = 5,
    kPricingFieldNumber = 6,
    kLimitsFieldNumber = 7,
    kIsAvailableFieldNumber = 8,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string provider = 3;
  void clear_provider();
  const std::string& provider() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_provider(ArgT0&& arg0, ArgT... args);
  std::string* mutable_provider();
  PROTOBUF_NODISCARD std::string* release_provider();
  void set_allocated_provider(std::string* provider);
  private:
  const std::string& _internal_provider() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_provider(const std::string& value);
  std::string* _internal_mutable_provider();
  public:

  // string description = 4;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string status = 9;
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // .unhinged.common.v1.ResourceMetadata metadata = 1;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::unhinged::common::v1::ResourceMetadata& metadata() const;
  PROTOBUF_NODISCARD ::unhinged::common::v1::ResourceMetadata* release_metadata();
  ::unhinged::common::v1::ResourceMetadata* mutable_metadata();
  void set_allocated_metadata(::unhinged::common::v1::ResourceMetadata* metadata);
  private:
  const ::unhinged::common::v1::ResourceMetadata& _internal_metadata() const;
  ::unhinged::common::v1::ResourceMetadata* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::unhinged::common::v1::ResourceMetadata* metadata);
  ::unhinged::common::v1::ResourceMetadata* unsafe_arena_release_metadata();

  // .unhinged.llm.v1.ModelCapabilities capabilities = 5;
  bool has_capabilities() const;
  private:
  bool _internal_has_capabilities() const;
  public:
  void clear_capabilities();
  const ::unhinged::llm::v1::ModelCapabilities& capabilities() const;
  PROTOBUF_NODISCARD ::unhinged::llm::v1::ModelCapabilities* release_capabilities();
  ::unhinged::llm::v1::ModelCapabilities* mutable_capabilities();
  void set_allocated_capabilities(::unhinged::llm::v1::ModelCapabilities* capabilities);
  private:
  const ::unhinged::llm::v1::ModelCapabilities& _internal_capabilities() const;
  ::unhinged::llm::v1::ModelCapabilities* _internal_mutable_capabilities();
  public:
  void unsafe_arena_set_allocated_capabilities(
      ::unhinged::llm::v1::ModelCapabilities* capabilities);
  ::unhinged::llm::v1::ModelCapabilities* unsafe_arena_release_capabilities();

  // .unhinged.llm.v1.ModelPricing pricing = 6;
  bool has_pricing() const;
  private:
  bool _internal_has_pricing() const;
  public:
  void clear_pricing();
  const ::unhinged::llm::v1::ModelPricing& pricing() const;
  PROTOBUF_NODISCARD ::unhinged::llm::v1::ModelPricing* release_pricing();
  ::unhinged::llm::v1::ModelPricing* mutable_pricing();
  void set_allocated_pricing(::unhinged::llm::v1::ModelPricing* pricing);
  private:
  const ::unhinged::llm::v1::ModelPricing& _internal_pricing() const;
  ::unhinged::llm::v1::ModelPricing* _internal_mutable_pricing();
  public:
  void unsafe_arena_set_allocated_pricing(
      ::unhinged::llm::v1::ModelPricing* pricing);
  ::unhinged::llm::v1::ModelPricing* unsafe_arena_release_pricing();

  // .unhinged.llm.v1.ModelLimits limits = 7;
  bool has_limits() const;
  private:
  bool _internal_has_limits() const;
  public:
  void clear_limits();
  const ::unhinged::llm::v1::ModelLimits& limits() const;
  PROTOBUF_NODISCARD ::unhinged::llm::v1::ModelLimits* release_limits();
  ::unhinged::llm::v1::ModelLimits* mutable_limits();
  void set_allocated_limits(::unhinged::llm::v1::ModelLimits* limits);
  private:
  const ::unhinged::llm::v1::ModelLimits& _internal_limits() const;
  ::unhinged::llm::v1::ModelLimits* _internal_mutable_limits();
  public:
  void unsafe_arena_set_allocated_limits(
      ::unhinged::llm::v1::ModelLimits* limits);
  ::unhinged::llm::v1::ModelLimits* unsafe_arena_release_limits();

  // bool is_available = 8;
  void clear_is_available();
  bool is_available() const;
  void set_is_available(bool value);
  private:
  bool _internal_is_available() const;
  void _internal_set_is_available(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.llm.v1.Model)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr provider_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
    ::unhinged::common::v1::ResourceMetadata* metadata_;
    ::unhinged::llm::v1::ModelCapabilities* capabilities_;
    ::unhinged::llm::v1::ModelPricing* pricing_;
    ::unhinged::llm::v1::ModelLimits* limits_;
    bool is_available_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_llm_2eproto;
};
// -------------------------------------------------------------------

class ModelCapabilities final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.llm.v1.ModelCapabilities) */ {
 public:
  inline ModelCapabilities() : ModelCapabilities(nullptr) {}
  ~ModelCapabilities() override;
  explicit PROTOBUF_CONSTEXPR ModelCapabilities(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelCapabilities(const ModelCapabilities& from);
  ModelCapabilities(ModelCapabilities&& from) noexcept
    : ModelCapabilities() {
    *this = ::std::move(from);
  }

  inline ModelCapabilities& operator=(const ModelCapabilities& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelCapabilities& operator=(ModelCapabilities&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelCapabilities& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelCapabilities* internal_default_instance() {
    return reinterpret_cast<const ModelCapabilities*>(
               &_ModelCapabilities_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ModelCapabilities& a, ModelCapabilities& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelCapabilities* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelCapabilities* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelCapabilities* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelCapabilities>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelCapabilities& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelCapabilities& from) {
    ModelCapabilities::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelCapabilities* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.llm.v1.ModelCapabilities";
  }
  protected:
  explicit ModelCapabilities(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSupportedLanguagesFieldNumber = 6,
    kInputModalitiesFieldNumber = 7,
    kOutputModalitiesFieldNumber = 8,
    kSupportsStreamingFieldNumber = 1,
    kSupportsVisionFieldNumber = 2,
    kSupportsFunctionCallingFieldNumber = 3,
    kSupportsJsonModeFieldNumber = 4,
    kSupportsSystemMessagesFieldNumber = 5,
  };
  // repeated string supported_languages = 6;
  int supported_languages_size() const;
  private:
  int _internal_supported_languages_size() const;
  public:
  void clear_supported_languages();
  const std::string& supported_languages(int index) const;
  std::string* mutable_supported_languages(int index);
  void set_supported_languages(int index, const std::string& value);
  void set_supported_languages(int index, std::string&& value);
  void set_supported_languages(int index, const char* value);
  void set_supported_languages(int index, const char* value, size_t size);
  std::string* add_supported_languages();
  void add_supported_languages(const std::string& value);
  void add_supported_languages(std::string&& value);
  void add_supported_languages(const char* value);
  void add_supported_languages(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& supported_languages() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_supported_languages();
  private:
  const std::string& _internal_supported_languages(int index) const;
  std::string* _internal_add_supported_languages();
  public:

  // repeated string input_modalities = 7;
  int input_modalities_size() const;
  private:
  int _internal_input_modalities_size() const;
  public:
  void clear_input_modalities();
  const std::string& input_modalities(int index) const;
  std::string* mutable_input_modalities(int index);
  void set_input_modalities(int index, const std::string& value);
  void set_input_modalities(int index, std::string&& value);
  void set_input_modalities(int index, const char* value);
  void set_input_modalities(int index, const char* value, size_t size);
  std::string* add_input_modalities();
  void add_input_modalities(const std::string& value);
  void add_input_modalities(std::string&& value);
  void add_input_modalities(const char* value);
  void add_input_modalities(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& input_modalities() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_input_modalities();
  private:
  const std::string& _internal_input_modalities(int index) const;
  std::string* _internal_add_input_modalities();
  public:

  // repeated string output_modalities = 8;
  int output_modalities_size() const;
  private:
  int _internal_output_modalities_size() const;
  public:
  void clear_output_modalities();
  const std::string& output_modalities(int index) const;
  std::string* mutable_output_modalities(int index);
  void set_output_modalities(int index, const std::string& value);
  void set_output_modalities(int index, std::string&& value);
  void set_output_modalities(int index, const char* value);
  void set_output_modalities(int index, const char* value, size_t size);
  std::string* add_output_modalities();
  void add_output_modalities(const std::string& value);
  void add_output_modalities(std::string&& value);
  void add_output_modalities(const char* value);
  void add_output_modalities(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& output_modalities() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_output_modalities();
  private:
  const std::string& _internal_output_modalities(int index) const;
  std::string* _internal_add_output_modalities();
  public:

  // bool supports_streaming = 1;
  void clear_supports_streaming();
  bool supports_streaming() const;
  void set_supports_streaming(bool value);
  private:
  bool _internal_supports_streaming() const;
  void _internal_set_supports_streaming(bool value);
  public:

  // bool supports_vision = 2;
  void clear_supports_vision();
  bool supports_vision() const;
  void set_supports_vision(bool value);
  private:
  bool _internal_supports_vision() const;
  void _internal_set_supports_vision(bool value);
  public:

  // bool supports_function_calling = 3;
  void clear_supports_function_calling();
  bool supports_function_calling() const;
  void set_supports_function_calling(bool value);
  private:
  bool _internal_supports_function_calling() const;
  void _internal_set_supports_function_calling(bool value);
  public:

  // bool supports_json_mode = 4;
  void clear_supports_json_mode();
  bool supports_json_mode() const;
  void set_supports_json_mode(bool value);
  private:
  bool _internal_supports_json_mode() const;
  void _internal_set_supports_json_mode(bool value);
  public:

  // bool supports_system_messages = 5;
  void clear_supports_system_messages();
  bool supports_system_messages() const;
  void set_supports_system_messages(bool value);
  private:
  bool _internal_supports_system_messages() const;
  void _internal_set_supports_system_messages(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.llm.v1.ModelCapabilities)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> supported_languages_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> input_modalities_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> output_modalities_;
    bool supports_streaming_;
    bool supports_vision_;
    bool supports_function_calling_;
    bool supports_json_mode_;
    bool supports_system_messages_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_llm_2eproto;
};
// -------------------------------------------------------------------

class ModelPricing final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.llm.v1.ModelPricing) */ {
 public:
  inline ModelPricing() : ModelPricing(nullptr) {}
  ~ModelPricing() override;
  explicit PROTOBUF_CONSTEXPR ModelPricing(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelPricing(const ModelPricing& from);
  ModelPricing(ModelPricing&& from) noexcept
    : ModelPricing() {
    *this = ::std::move(from);
  }

  inline ModelPricing& operator=(const ModelPricing& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelPricing& operator=(ModelPricing&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelPricing& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelPricing* internal_default_instance() {
    return reinterpret_cast<const ModelPricing*>(
               &_ModelPricing_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ModelPricing& a, ModelPricing& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelPricing* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelPricing* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelPricing* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelPricing>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelPricing& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelPricing& from) {
    ModelPricing::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelPricing* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.llm.v1.ModelPricing";
  }
  protected:
  explicit ModelPricing(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurrencyFieldNumber = 3,
    kInputCostPer1KTokensFieldNumber = 1,
    kOutputCostPer1KTokensFieldNumber = 2,
    kHasFreeTierFieldNumber = 4,
    kFreeTierLimitFieldNumber = 5,
  };
  // string currency = 3;
  void clear_currency();
  const std::string& currency() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_currency(ArgT0&& arg0, ArgT... args);
  std::string* mutable_currency();
  PROTOBUF_NODISCARD std::string* release_currency();
  void set_allocated_currency(std::string* currency);
  private:
  const std::string& _internal_currency() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_currency(const std::string& value);
  std::string* _internal_mutable_currency();
  public:

  // float input_cost_per_1k_tokens = 1;
  void clear_input_cost_per_1k_tokens();
  float input_cost_per_1k_tokens() const;
  void set_input_cost_per_1k_tokens(float value);
  private:
  float _internal_input_cost_per_1k_tokens() const;
  void _internal_set_input_cost_per_1k_tokens(float value);
  public:

  // float output_cost_per_1k_tokens = 2;
  void clear_output_cost_per_1k_tokens();
  float output_cost_per_1k_tokens() const;
  void set_output_cost_per_1k_tokens(float value);
  private:
  float _internal_output_cost_per_1k_tokens() const;
  void _internal_set_output_cost_per_1k_tokens(float value);
  public:

  // bool has_free_tier = 4;
  void clear_has_free_tier();
  bool has_free_tier() const;
  void set_has_free_tier(bool value);
  private:
  bool _internal_has_free_tier() const;
  void _internal_set_has_free_tier(bool value);
  public:

  // int32 free_tier_limit = 5;
  void clear_free_tier_limit();
  int32_t free_tier_limit() const;
  void set_free_tier_limit(int32_t value);
  private:
  int32_t _internal_free_tier_limit() const;
  void _internal_set_free_tier_limit(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.llm.v1.ModelPricing)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr currency_;
    float input_cost_per_1k_tokens_;
    float output_cost_per_1k_tokens_;
    bool has_free_tier_;
    int32_t free_tier_limit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_llm_2eproto;
};
// -------------------------------------------------------------------

class ModelLimits final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.llm.v1.ModelLimits) */ {
 public:
  inline ModelLimits() : ModelLimits(nullptr) {}
  ~ModelLimits() override;
  explicit PROTOBUF_CONSTEXPR ModelLimits(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelLimits(const ModelLimits& from);
  ModelLimits(ModelLimits&& from) noexcept
    : ModelLimits() {
    *this = ::std::move(from);
  }

  inline ModelLimits& operator=(const ModelLimits& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelLimits& operator=(ModelLimits&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelLimits& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelLimits* internal_default_instance() {
    return reinterpret_cast<const ModelLimits*>(
               &_ModelLimits_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ModelLimits& a, ModelLimits& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelLimits* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelLimits* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelLimits* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelLimits>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelLimits& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelLimits& from) {
    ModelLimits::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelLimits* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.llm.v1.ModelLimits";
  }
  protected:
  explicit ModelLimits(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaxContextTokensFieldNumber = 1,
    kMaxOutputTokensFieldNumber = 2,
    kMaxRequestsPerMinuteFieldNumber = 3,
    kMaxTokensPerMinuteFieldNumber = 4,
  };
  // int32 max_context_tokens = 1;
  void clear_max_context_tokens();
  int32_t max_context_tokens() const;
  void set_max_context_tokens(int32_t value);
  private:
  int32_t _internal_max_context_tokens() const;
  void _internal_set_max_context_tokens(int32_t value);
  public:

  // int32 max_output_tokens = 2;
  void clear_max_output_tokens();
  int32_t max_output_tokens() const;
  void set_max_output_tokens(int32_t value);
  private:
  int32_t _internal_max_output_tokens() const;
  void _internal_set_max_output_tokens(int32_t value);
  public:

  // int32 max_requests_per_minute = 3;
  void clear_max_requests_per_minute();
  int32_t max_requests_per_minute() const;
  void set_max_requests_per_minute(int32_t value);
  private:
  int32_t _internal_max_requests_per_minute() const;
  void _internal_set_max_requests_per_minute(int32_t value);
  public:

  // int32 max_tokens_per_minute = 4;
  void clear_max_tokens_per_minute();
  int32_t max_tokens_per_minute() const;
  void set_max_tokens_per_minute(int32_t value);
  private:
  int32_t _internal_max_tokens_per_minute() const;
  void _internal_set_max_tokens_per_minute(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.llm.v1.ModelLimits)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t max_context_tokens_;
    int32_t max_output_tokens_;
    int32_t max_requests_per_minute_;
    int32_t max_tokens_per_minute_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_llm_2eproto;
};
// -------------------------------------------------------------------

class CompletionChunkPayload final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.llm.v1.CompletionChunkPayload) */ {
 public:
  inline CompletionChunkPayload() : CompletionChunkPayload(nullptr) {}
  ~CompletionChunkPayload() override;
  explicit PROTOBUF_CONSTEXPR CompletionChunkPayload(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CompletionChunkPayload(const CompletionChunkPayload& from);
  CompletionChunkPayload(CompletionChunkPayload&& from) noexcept
    : CompletionChunkPayload() {
    *this = ::std::move(from);
  }

  inline CompletionChunkPayload& operator=(const CompletionChunkPayload& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompletionChunkPayload& operator=(CompletionChunkPayload&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompletionChunkPayload& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompletionChunkPayload* internal_default_instance() {
    return reinterpret_cast<const CompletionChunkPayload*>(
               &_CompletionChunkPayload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(CompletionChunkPayload& a, CompletionChunkPayload& b) {
    a.Swap(&b);
  }
  inline void Swap(CompletionChunkPayload* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompletionChunkPayload* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompletionChunkPayload* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CompletionChunkPayload>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CompletionChunkPayload& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CompletionChunkPayload& from) {
    CompletionChunkPayload::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompletionChunkPayload* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.llm.v1.CompletionChunkPayload";
  }
  protected:
  explicit CompletionChunkPayload(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kToolCallsFieldNumber = 5,
    kCompletionIdFieldNumber = 1,
    kContentFieldNumber = 4,
    kFinishReasonFieldNumber = 6,
    kUsageFieldNumber = 7,
    kChoiceIndexFieldNumber = 2,
    kTypeFieldNumber = 3,
  };
  // repeated .unhinged.chat.v1.ToolCall tool_calls = 5;
  int tool_calls_size() const;
  private:
  int _internal_tool_calls_size() const;
  public:
  void clear_tool_calls();
  ::unhinged::chat::v1::ToolCall* mutable_tool_calls(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::chat::v1::ToolCall >*
      mutable_tool_calls();
  private:
  const ::unhinged::chat::v1::ToolCall& _internal_tool_calls(int index) const;
  ::unhinged::chat::v1::ToolCall* _internal_add_tool_calls();
  public:
  const ::unhinged::chat::v1::ToolCall& tool_calls(int index) const;
  ::unhinged::chat::v1::ToolCall* add_tool_calls();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::chat::v1::ToolCall >&
      tool_calls() const;

  // string completion_id = 1;
  void clear_completion_id();
  const std::string& completion_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_completion_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_completion_id();
  PROTOBUF_NODISCARD std::string* release_completion_id();
  void set_allocated_completion_id(std::string* completion_id);
  private:
  const std::string& _internal_completion_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_completion_id(const std::string& value);
  std::string* _internal_mutable_completion_id();
  public:

  // string content = 4;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // string finish_reason = 6;
  void clear_finish_reason();
  const std::string& finish_reason() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_finish_reason(ArgT0&& arg0, ArgT... args);
  std::string* mutable_finish_reason();
  PROTOBUF_NODISCARD std::string* release_finish_reason();
  void set_allocated_finish_reason(std::string* finish_reason);
  private:
  const std::string& _internal_finish_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_finish_reason(const std::string& value);
  std::string* _internal_mutable_finish_reason();
  public:

  // .unhinged.common.v1.UsageMetrics usage = 7;
  bool has_usage() const;
  private:
  bool _internal_has_usage() const;
  public:
  void clear_usage();
  const ::unhinged::common::v1::UsageMetrics& usage() const;
  PROTOBUF_NODISCARD ::unhinged::common::v1::UsageMetrics* release_usage();
  ::unhinged::common::v1::UsageMetrics* mutable_usage();
  void set_allocated_usage(::unhinged::common::v1::UsageMetrics* usage);
  private:
  const ::unhinged::common::v1::UsageMetrics& _internal_usage() const;
  ::unhinged::common::v1::UsageMetrics* _internal_mutable_usage();
  public:
  void unsafe_arena_set_allocated_usage(
      ::unhinged::common::v1::UsageMetrics* usage);
  ::unhinged::common::v1::UsageMetrics* unsafe_arena_release_usage();

  // int32 choice_index = 2;
  void clear_choice_index();
  int32_t choice_index() const;
  void set_choice_index(int32_t value);
  private:
  int32_t _internal_choice_index() const;
  void _internal_set_choice_index(int32_t value);
  public:

  // .unhinged.llm.v1.CompletionChunkType type = 3;
  void clear_type();
  ::unhinged::llm::v1::CompletionChunkType type() const;
  void set_type(::unhinged::llm::v1::CompletionChunkType value);
  private:
  ::unhinged::llm::v1::CompletionChunkType _internal_type() const;
  void _internal_set_type(::unhinged::llm::v1::CompletionChunkType value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.llm.v1.CompletionChunkPayload)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::chat::v1::ToolCall > tool_calls_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr completion_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr finish_reason_;
    ::unhinged::common::v1::UsageMetrics* usage_;
    int32_t choice_index_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_llm_2eproto;
};
// -------------------------------------------------------------------

class ListModelsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.llm.v1.ListModelsRequest) */ {
 public:
  inline ListModelsRequest() : ListModelsRequest(nullptr) {}
  ~ListModelsRequest() override;
  explicit PROTOBUF_CONSTEXPR ListModelsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListModelsRequest(const ListModelsRequest& from);
  ListModelsRequest(ListModelsRequest&& from) noexcept
    : ListModelsRequest() {
    *this = ::std::move(from);
  }

  inline ListModelsRequest& operator=(const ListModelsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListModelsRequest& operator=(ListModelsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListModelsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListModelsRequest* internal_default_instance() {
    return reinterpret_cast<const ListModelsRequest*>(
               &_ListModelsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ListModelsRequest& a, ListModelsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListModelsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListModelsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListModelsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListModelsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListModelsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListModelsRequest& from) {
    ListModelsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListModelsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.llm.v1.ListModelsRequest";
  }
  protected:
  explicit ListModelsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFiltersFieldNumber = 4,
    kProviderFieldNumber = 1,
    kPaginationFieldNumber = 3,
    kAvailableOnlyFieldNumber = 2,
  };
  // repeated .unhinged.common.v1.Filter filters = 4;
  int filters_size() const;
  private:
  int _internal_filters_size() const;
  public:
  void clear_filters();
  ::unhinged::common::v1::Filter* mutable_filters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::common::v1::Filter >*
      mutable_filters();
  private:
  const ::unhinged::common::v1::Filter& _internal_filters(int index) const;
  ::unhinged::common::v1::Filter* _internal_add_filters();
  public:
  const ::unhinged::common::v1::Filter& filters(int index) const;
  ::unhinged::common::v1::Filter* add_filters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::common::v1::Filter >&
      filters() const;

  // string provider = 1;
  void clear_provider();
  const std::string& provider() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_provider(ArgT0&& arg0, ArgT... args);
  std::string* mutable_provider();
  PROTOBUF_NODISCARD std::string* release_provider();
  void set_allocated_provider(std::string* provider);
  private:
  const std::string& _internal_provider() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_provider(const std::string& value);
  std::string* _internal_mutable_provider();
  public:

  // .unhinged.common.v1.PaginationRequest pagination = 3;
  bool has_pagination() const;
  private:
  bool _internal_has_pagination() const;
  public:
  void clear_pagination();
  const ::unhinged::common::v1::PaginationRequest& pagination() const;
  PROTOBUF_NODISCARD ::unhinged::common::v1::PaginationRequest* release_pagination();
  ::unhinged::common::v1::PaginationRequest* mutable_pagination();
  void set_allocated_pagination(::unhinged::common::v1::PaginationRequest* pagination);
  private:
  const ::unhinged::common::v1::PaginationRequest& _internal_pagination() const;
  ::unhinged::common::v1::PaginationRequest* _internal_mutable_pagination();
  public:
  void unsafe_arena_set_allocated_pagination(
      ::unhinged::common::v1::PaginationRequest* pagination);
  ::unhinged::common::v1::PaginationRequest* unsafe_arena_release_pagination();

  // bool available_only = 2;
  void clear_available_only();
  bool available_only() const;
  void set_available_only(bool value);
  private:
  bool _internal_available_only() const;
  void _internal_set_available_only(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.llm.v1.ListModelsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::common::v1::Filter > filters_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr provider_;
    ::unhinged::common::v1::PaginationRequest* pagination_;
    bool available_only_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_llm_2eproto;
};
// -------------------------------------------------------------------

class ListModelsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.llm.v1.ListModelsResponse) */ {
 public:
  inline ListModelsResponse() : ListModelsResponse(nullptr) {}
  ~ListModelsResponse() override;
  explicit PROTOBUF_CONSTEXPR ListModelsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListModelsResponse(const ListModelsResponse& from);
  ListModelsResponse(ListModelsResponse&& from) noexcept
    : ListModelsResponse() {
    *this = ::std::move(from);
  }

  inline ListModelsResponse& operator=(const ListModelsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListModelsResponse& operator=(ListModelsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListModelsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListModelsResponse* internal_default_instance() {
    return reinterpret_cast<const ListModelsResponse*>(
               &_ListModelsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ListModelsResponse& a, ListModelsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListModelsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListModelsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListModelsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListModelsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListModelsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListModelsResponse& from) {
    ListModelsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListModelsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.llm.v1.ListModelsResponse";
  }
  protected:
  explicit ListModelsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelsFieldNumber = 2,
    kResponseFieldNumber = 1,
    kPaginationFieldNumber = 3,
  };
  // repeated .unhinged.llm.v1.Model models = 2;
  int models_size() const;
  private:
  int _internal_models_size() const;
  public:
  void clear_models();
  ::unhinged::llm::v1::Model* mutable_models(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::llm::v1::Model >*
      mutable_models();
  private:
  const ::unhinged::llm::v1::Model& _internal_models(int index) const;
  ::unhinged::llm::v1::Model* _internal_add_models();
  public:
  const ::unhinged::llm::v1::Model& models(int index) const;
  ::unhinged::llm::v1::Model* add_models();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::llm::v1::Model >&
      models() const;

  // .unhinged.common.v1.StandardResponse response = 1;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::unhinged::common::v1::StandardResponse& response() const;
  PROTOBUF_NODISCARD ::unhinged::common::v1::StandardResponse* release_response();
  ::unhinged::common::v1::StandardResponse* mutable_response();
  void set_allocated_response(::unhinged::common::v1::StandardResponse* response);
  private:
  const ::unhinged::common::v1::StandardResponse& _internal_response() const;
  ::unhinged::common::v1::StandardResponse* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::unhinged::common::v1::StandardResponse* response);
  ::unhinged::common::v1::StandardResponse* unsafe_arena_release_response();

  // .unhinged.common.v1.PaginationResponse pagination = 3;
  bool has_pagination() const;
  private:
  bool _internal_has_pagination() const;
  public:
  void clear_pagination();
  const ::unhinged::common::v1::PaginationResponse& pagination() const;
  PROTOBUF_NODISCARD ::unhinged::common::v1::PaginationResponse* release_pagination();
  ::unhinged::common::v1::PaginationResponse* mutable_pagination();
  void set_allocated_pagination(::unhinged::common::v1::PaginationResponse* pagination);
  private:
  const ::unhinged::common::v1::PaginationResponse& _internal_pagination() const;
  ::unhinged::common::v1::PaginationResponse* _internal_mutable_pagination();
  public:
  void unsafe_arena_set_allocated_pagination(
      ::unhinged::common::v1::PaginationResponse* pagination);
  ::unhinged::common::v1::PaginationResponse* unsafe_arena_release_pagination();

  // @@protoc_insertion_point(class_scope:unhinged.llm.v1.ListModelsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::llm::v1::Model > models_;
    ::unhinged::common::v1::StandardResponse* response_;
    ::unhinged::common::v1::PaginationResponse* pagination_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_llm_2eproto;
};
// -------------------------------------------------------------------

class GetModelRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.llm.v1.GetModelRequest) */ {
 public:
  inline GetModelRequest() : GetModelRequest(nullptr) {}
  ~GetModelRequest() override;
  explicit PROTOBUF_CONSTEXPR GetModelRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetModelRequest(const GetModelRequest& from);
  GetModelRequest(GetModelRequest&& from) noexcept
    : GetModelRequest() {
    *this = ::std::move(from);
  }

  inline GetModelRequest& operator=(const GetModelRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetModelRequest& operator=(GetModelRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetModelRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetModelRequest* internal_default_instance() {
    return reinterpret_cast<const GetModelRequest*>(
               &_GetModelRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(GetModelRequest& a, GetModelRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetModelRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetModelRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetModelRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetModelRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetModelRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetModelRequest& from) {
    GetModelRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetModelRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.llm.v1.GetModelRequest";
  }
  protected:
  explicit GetModelRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelIdFieldNumber = 1,
    kIncludePricingFieldNumber = 2,
    kIncludeCapabilitiesFieldNumber = 3,
  };
  // string model_id = 1;
  void clear_model_id();
  const std::string& model_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_id();
  PROTOBUF_NODISCARD std::string* release_model_id();
  void set_allocated_model_id(std::string* model_id);
  private:
  const std::string& _internal_model_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_id(const std::string& value);
  std::string* _internal_mutable_model_id();
  public:

  // bool include_pricing = 2;
  void clear_include_pricing();
  bool include_pricing() const;
  void set_include_pricing(bool value);
  private:
  bool _internal_include_pricing() const;
  void _internal_set_include_pricing(bool value);
  public:

  // bool include_capabilities = 3;
  void clear_include_capabilities();
  bool include_capabilities() const;
  void set_include_capabilities(bool value);
  private:
  bool _internal_include_capabilities() const;
  void _internal_set_include_capabilities(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.llm.v1.GetModelRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_id_;
    bool include_pricing_;
    bool include_capabilities_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_llm_2eproto;
};
// -------------------------------------------------------------------

class GetModelResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.llm.v1.GetModelResponse) */ {
 public:
  inline GetModelResponse() : GetModelResponse(nullptr) {}
  ~GetModelResponse() override;
  explicit PROTOBUF_CONSTEXPR GetModelResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetModelResponse(const GetModelResponse& from);
  GetModelResponse(GetModelResponse&& from) noexcept
    : GetModelResponse() {
    *this = ::std::move(from);
  }

  inline GetModelResponse& operator=(const GetModelResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetModelResponse& operator=(GetModelResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetModelResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetModelResponse* internal_default_instance() {
    return reinterpret_cast<const GetModelResponse*>(
               &_GetModelResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(GetModelResponse& a, GetModelResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetModelResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetModelResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetModelResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetModelResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetModelResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetModelResponse& from) {
    GetModelResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetModelResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.llm.v1.GetModelResponse";
  }
  protected:
  explicit GetModelResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 1,
    kModelFieldNumber = 2,
  };
  // .unhinged.common.v1.StandardResponse response = 1;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::unhinged::common::v1::StandardResponse& response() const;
  PROTOBUF_NODISCARD ::unhinged::common::v1::StandardResponse* release_response();
  ::unhinged::common::v1::StandardResponse* mutable_response();
  void set_allocated_response(::unhinged::common::v1::StandardResponse* response);
  private:
  const ::unhinged::common::v1::StandardResponse& _internal_response() const;
  ::unhinged::common::v1::StandardResponse* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::unhinged::common::v1::StandardResponse* response);
  ::unhinged::common::v1::StandardResponse* unsafe_arena_release_response();

  // .unhinged.llm.v1.Model model = 2;
  bool has_model() const;
  private:
  bool _internal_has_model() const;
  public:
  void clear_model();
  const ::unhinged::llm::v1::Model& model() const;
  PROTOBUF_NODISCARD ::unhinged::llm::v1::Model* release_model();
  ::unhinged::llm::v1::Model* mutable_model();
  void set_allocated_model(::unhinged::llm::v1::Model* model);
  private:
  const ::unhinged::llm::v1::Model& _internal_model() const;
  ::unhinged::llm::v1::Model* _internal_mutable_model();
  public:
  void unsafe_arena_set_allocated_model(
      ::unhinged::llm::v1::Model* model);
  ::unhinged::llm::v1::Model* unsafe_arena_release_model();

  // @@protoc_insertion_point(class_scope:unhinged.llm.v1.GetModelResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::unhinged::common::v1::StandardResponse* response_;
    ::unhinged::llm::v1::Model* model_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_llm_2eproto;
};
// -------------------------------------------------------------------

class TokenEstimationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.llm.v1.TokenEstimationRequest) */ {
 public:
  inline TokenEstimationRequest() : TokenEstimationRequest(nullptr) {}
  ~TokenEstimationRequest() override;
  explicit PROTOBUF_CONSTEXPR TokenEstimationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TokenEstimationRequest(const TokenEstimationRequest& from);
  TokenEstimationRequest(TokenEstimationRequest&& from) noexcept
    : TokenEstimationRequest() {
    *this = ::std::move(from);
  }

  inline TokenEstimationRequest& operator=(const TokenEstimationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TokenEstimationRequest& operator=(TokenEstimationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TokenEstimationRequest& default_instance() {
    return *internal_default_instance();
  }
  enum InputCase {
    kText = 2,
    kMessages = 3,
    INPUT_NOT_SET = 0,
  };

  static inline const TokenEstimationRequest* internal_default_instance() {
    return reinterpret_cast<const TokenEstimationRequest*>(
               &_TokenEstimationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(TokenEstimationRequest& a, TokenEstimationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TokenEstimationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TokenEstimationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TokenEstimationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TokenEstimationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TokenEstimationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TokenEstimationRequest& from) {
    TokenEstimationRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TokenEstimationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.llm.v1.TokenEstimationRequest";
  }
  protected:
  explicit TokenEstimationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelFieldNumber = 1,
    kSessionIdFieldNumber = 5,
    kIncludeContextFieldNumber = 4,
    kTextFieldNumber = 2,
    kMessagesFieldNumber = 3,
  };
  // string model = 1;
  void clear_model();
  const std::string& model() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model();
  PROTOBUF_NODISCARD std::string* release_model();
  void set_allocated_model(std::string* model);
  private:
  const std::string& _internal_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model(const std::string& value);
  std::string* _internal_mutable_model();
  public:

  // string session_id = 5;
  void clear_session_id();
  const std::string& session_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // bool include_context = 4;
  void clear_include_context();
  bool include_context() const;
  void set_include_context(bool value);
  private:
  bool _internal_include_context() const;
  void _internal_set_include_context(bool value);
  public:

  // string text = 2;
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // .unhinged.llm.v1.ChatMessageList messages = 3;
  bool has_messages() const;
  private:
  bool _internal_has_messages() const;
  public:
  void clear_messages();
  const ::unhinged::llm::v1::ChatMessageList& messages() const;
  PROTOBUF_NODISCARD ::unhinged::llm::v1::ChatMessageList* release_messages();
  ::unhinged::llm::v1::ChatMessageList* mutable_messages();
  void set_allocated_messages(::unhinged::llm::v1::ChatMessageList* messages);
  private:
  const ::unhinged::llm::v1::ChatMessageList& _internal_messages() const;
  ::unhinged::llm::v1::ChatMessageList* _internal_mutable_messages();
  public:
  void unsafe_arena_set_allocated_messages(
      ::unhinged::llm::v1::ChatMessageList* messages);
  ::unhinged::llm::v1::ChatMessageList* unsafe_arena_release_messages();

  void clear_input();
  InputCase input_case() const;
  // @@protoc_insertion_point(class_scope:unhinged.llm.v1.TokenEstimationRequest)
 private:
  class _Internal;
  void set_has_text();
  void set_has_messages();

  inline bool has_input() const;
  inline void clear_has_input();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
    bool include_context_;
    union InputUnion {
      constexpr InputUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
      ::unhinged::llm::v1::ChatMessageList* messages_;
    } input_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_llm_2eproto;
};
// -------------------------------------------------------------------

class ChatMessageList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.llm.v1.ChatMessageList) */ {
 public:
  inline ChatMessageList() : ChatMessageList(nullptr) {}
  ~ChatMessageList() override;
  explicit PROTOBUF_CONSTEXPR ChatMessageList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChatMessageList(const ChatMessageList& from);
  ChatMessageList(ChatMessageList&& from) noexcept
    : ChatMessageList() {
    *this = ::std::move(from);
  }

  inline ChatMessageList& operator=(const ChatMessageList& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatMessageList& operator=(ChatMessageList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChatMessageList& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChatMessageList* internal_default_instance() {
    return reinterpret_cast<const ChatMessageList*>(
               &_ChatMessageList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ChatMessageList& a, ChatMessageList& b) {
    a.Swap(&b);
  }
  inline void Swap(ChatMessageList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChatMessageList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChatMessageList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChatMessageList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChatMessageList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChatMessageList& from) {
    ChatMessageList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChatMessageList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.llm.v1.ChatMessageList";
  }
  protected:
  explicit ChatMessageList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessagesFieldNumber = 1,
  };
  // repeated .unhinged.chat.v1.ChatMessage messages = 1;
  int messages_size() const;
  private:
  int _internal_messages_size() const;
  public:
  void clear_messages();
  ::unhinged::chat::v1::ChatMessage* mutable_messages(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::chat::v1::ChatMessage >*
      mutable_messages();
  private:
  const ::unhinged::chat::v1::ChatMessage& _internal_messages(int index) const;
  ::unhinged::chat::v1::ChatMessage* _internal_add_messages();
  public:
  const ::unhinged::chat::v1::ChatMessage& messages(int index) const;
  ::unhinged::chat::v1::ChatMessage* add_messages();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::chat::v1::ChatMessage >&
      messages() const;

  // @@protoc_insertion_point(class_scope:unhinged.llm.v1.ChatMessageList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::chat::v1::ChatMessage > messages_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_llm_2eproto;
};
// -------------------------------------------------------------------

class TokenEstimationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.llm.v1.TokenEstimationResponse) */ {
 public:
  inline TokenEstimationResponse() : TokenEstimationResponse(nullptr) {}
  ~TokenEstimationResponse() override;
  explicit PROTOBUF_CONSTEXPR TokenEstimationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TokenEstimationResponse(const TokenEstimationResponse& from);
  TokenEstimationResponse(TokenEstimationResponse&& from) noexcept
    : TokenEstimationResponse() {
    *this = ::std::move(from);
  }

  inline TokenEstimationResponse& operator=(const TokenEstimationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TokenEstimationResponse& operator=(TokenEstimationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TokenEstimationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TokenEstimationResponse* internal_default_instance() {
    return reinterpret_cast<const TokenEstimationResponse*>(
               &_TokenEstimationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(TokenEstimationResponse& a, TokenEstimationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TokenEstimationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TokenEstimationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TokenEstimationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TokenEstimationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TokenEstimationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TokenEstimationResponse& from) {
    TokenEstimationResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TokenEstimationResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.llm.v1.TokenEstimationResponse";
  }
  protected:
  explicit TokenEstimationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 1,
    kUsageFieldNumber = 2,
    kBreakdownFieldNumber = 3,
  };
  // .unhinged.common.v1.StandardResponse response = 1;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::unhinged::common::v1::StandardResponse& response() const;
  PROTOBUF_NODISCARD ::unhinged::common::v1::StandardResponse* release_response();
  ::unhinged::common::v1::StandardResponse* mutable_response();
  void set_allocated_response(::unhinged::common::v1::StandardResponse* response);
  private:
  const ::unhinged::common::v1::StandardResponse& _internal_response() const;
  ::unhinged::common::v1::StandardResponse* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::unhinged::common::v1::StandardResponse* response);
  ::unhinged::common::v1::StandardResponse* unsafe_arena_release_response();

  // .unhinged.common.v1.TokenUsage usage = 2;
  bool has_usage() const;
  private:
  bool _internal_has_usage() const;
  public:
  void clear_usage();
  const ::unhinged::common::v1::TokenUsage& usage() const;
  PROTOBUF_NODISCARD ::unhinged::common::v1::TokenUsage* release_usage();
  ::unhinged::common::v1::TokenUsage* mutable_usage();
  void set_allocated_usage(::unhinged::common::v1::TokenUsage* usage);
  private:
  const ::unhinged::common::v1::TokenUsage& _internal_usage() const;
  ::unhinged::common::v1::TokenUsage* _internal_mutable_usage();
  public:
  void unsafe_arena_set_allocated_usage(
      ::unhinged::common::v1::TokenUsage* usage);
  ::unhinged::common::v1::TokenUsage* unsafe_arena_release_usage();

  // .unhinged.llm.v1.TokenBreakdown breakdown = 3;
  bool has_breakdown() const;
  private:
  bool _internal_has_breakdown() const;
  public:
  void clear_breakdown();
  const ::unhinged::llm::v1::TokenBreakdown& breakdown() const;
  PROTOBUF_NODISCARD ::unhinged::llm::v1::TokenBreakdown* release_breakdown();
  ::unhinged::llm::v1::TokenBreakdown* mutable_breakdown();
  void set_allocated_breakdown(::unhinged::llm::v1::TokenBreakdown* breakdown);
  private:
  const ::unhinged::llm::v1::TokenBreakdown& _internal_breakdown() const;
  ::unhinged::llm::v1::TokenBreakdown* _internal_mutable_breakdown();
  public:
  void unsafe_arena_set_allocated_breakdown(
      ::unhinged::llm::v1::TokenBreakdown* breakdown);
  ::unhinged::llm::v1::TokenBreakdown* unsafe_arena_release_breakdown();

  // @@protoc_insertion_point(class_scope:unhinged.llm.v1.TokenEstimationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::unhinged::common::v1::StandardResponse* response_;
    ::unhinged::common::v1::TokenUsage* usage_;
    ::unhinged::llm::v1::TokenBreakdown* breakdown_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_llm_2eproto;
};
// -------------------------------------------------------------------

class TokenBreakdown final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.llm.v1.TokenBreakdown) */ {
 public:
  inline TokenBreakdown() : TokenBreakdown(nullptr) {}
  ~TokenBreakdown() override;
  explicit PROTOBUF_CONSTEXPR TokenBreakdown(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TokenBreakdown(const TokenBreakdown& from);
  TokenBreakdown(TokenBreakdown&& from) noexcept
    : TokenBreakdown() {
    *this = ::std::move(from);
  }

  inline TokenBreakdown& operator=(const TokenBreakdown& from) {
    CopyFrom(from);
    return *this;
  }
  inline TokenBreakdown& operator=(TokenBreakdown&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TokenBreakdown& default_instance() {
    return *internal_default_instance();
  }
  static inline const TokenBreakdown* internal_default_instance() {
    return reinterpret_cast<const TokenBreakdown*>(
               &_TokenBreakdown_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(TokenBreakdown& a, TokenBreakdown& b) {
    a.Swap(&b);
  }
  inline void Swap(TokenBreakdown* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TokenBreakdown* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TokenBreakdown* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TokenBreakdown>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TokenBreakdown& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TokenBreakdown& from) {
    TokenBreakdown::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TokenBreakdown* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.llm.v1.TokenBreakdown";
  }
  protected:
  explicit TokenBreakdown(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContextDocumentsFieldNumber = 6,
    kSystemTokensFieldNumber = 1,
    kUserTokensFieldNumber = 2,
    kAssistantTokensFieldNumber = 3,
    kContextTokensFieldNumber = 4,
    kToolTokensFieldNumber = 5,
  };
  // repeated .unhinged.llm.v1.DocumentTokens context_documents = 6;
  int context_documents_size() const;
  private:
  int _internal_context_documents_size() const;
  public:
  void clear_context_documents();
  ::unhinged::llm::v1::DocumentTokens* mutable_context_documents(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::llm::v1::DocumentTokens >*
      mutable_context_documents();
  private:
  const ::unhinged::llm::v1::DocumentTokens& _internal_context_documents(int index) const;
  ::unhinged::llm::v1::DocumentTokens* _internal_add_context_documents();
  public:
  const ::unhinged::llm::v1::DocumentTokens& context_documents(int index) const;
  ::unhinged::llm::v1::DocumentTokens* add_context_documents();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::llm::v1::DocumentTokens >&
      context_documents() const;

  // int32 system_tokens = 1;
  void clear_system_tokens();
  int32_t system_tokens() const;
  void set_system_tokens(int32_t value);
  private:
  int32_t _internal_system_tokens() const;
  void _internal_set_system_tokens(int32_t value);
  public:

  // int32 user_tokens = 2;
  void clear_user_tokens();
  int32_t user_tokens() const;
  void set_user_tokens(int32_t value);
  private:
  int32_t _internal_user_tokens() const;
  void _internal_set_user_tokens(int32_t value);
  public:

  // int32 assistant_tokens = 3;
  void clear_assistant_tokens();
  int32_t assistant_tokens() const;
  void set_assistant_tokens(int32_t value);
  private:
  int32_t _internal_assistant_tokens() const;
  void _internal_set_assistant_tokens(int32_t value);
  public:

  // int32 context_tokens = 4;
  void clear_context_tokens();
  int32_t context_tokens() const;
  void set_context_tokens(int32_t value);
  private:
  int32_t _internal_context_tokens() const;
  void _internal_set_context_tokens(int32_t value);
  public:

  // int32 tool_tokens = 5;
  void clear_tool_tokens();
  int32_t tool_tokens() const;
  void set_tool_tokens(int32_t value);
  private:
  int32_t _internal_tool_tokens() const;
  void _internal_set_tool_tokens(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.llm.v1.TokenBreakdown)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::llm::v1::DocumentTokens > context_documents_;
    int32_t system_tokens_;
    int32_t user_tokens_;
    int32_t assistant_tokens_;
    int32_t context_tokens_;
    int32_t tool_tokens_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_llm_2eproto;
};
// -------------------------------------------------------------------

class DocumentTokens final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.llm.v1.DocumentTokens) */ {
 public:
  inline DocumentTokens() : DocumentTokens(nullptr) {}
  ~DocumentTokens() override;
  explicit PROTOBUF_CONSTEXPR DocumentTokens(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DocumentTokens(const DocumentTokens& from);
  DocumentTokens(DocumentTokens&& from) noexcept
    : DocumentTokens() {
    *this = ::std::move(from);
  }

  inline DocumentTokens& operator=(const DocumentTokens& from) {
    CopyFrom(from);
    return *this;
  }
  inline DocumentTokens& operator=(DocumentTokens&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DocumentTokens& default_instance() {
    return *internal_default_instance();
  }
  static inline const DocumentTokens* internal_default_instance() {
    return reinterpret_cast<const DocumentTokens*>(
               &_DocumentTokens_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(DocumentTokens& a, DocumentTokens& b) {
    a.Swap(&b);
  }
  inline void Swap(DocumentTokens* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DocumentTokens* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DocumentTokens* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DocumentTokens>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DocumentTokens& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DocumentTokens& from) {
    DocumentTokens::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DocumentTokens* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.llm.v1.DocumentTokens";
  }
  protected:
  explicit DocumentTokens(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDocumentIdFieldNumber = 1,
    kDocumentTypeFieldNumber = 2,
    kTokenCountFieldNumber = 3,
    kRelevanceScoreFieldNumber = 4,
  };
  // string document_id = 1;
  void clear_document_id();
  const std::string& document_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_document_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_document_id();
  PROTOBUF_NODISCARD std::string* release_document_id();
  void set_allocated_document_id(std::string* document_id);
  private:
  const std::string& _internal_document_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_document_id(const std::string& value);
  std::string* _internal_mutable_document_id();
  public:

  // string document_type = 2;
  void clear_document_type();
  const std::string& document_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_document_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_document_type();
  PROTOBUF_NODISCARD std::string* release_document_type();
  void set_allocated_document_type(std::string* document_type);
  private:
  const std::string& _internal_document_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_document_type(const std::string& value);
  std::string* _internal_mutable_document_type();
  public:

  // int32 token_count = 3;
  void clear_token_count();
  int32_t token_count() const;
  void set_token_count(int32_t value);
  private:
  int32_t _internal_token_count() const;
  void _internal_set_token_count(int32_t value);
  public:

  // float relevance_score = 4;
  void clear_relevance_score();
  float relevance_score() const;
  void set_relevance_score(float value);
  private:
  float _internal_relevance_score() const;
  void _internal_set_relevance_score(float value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.llm.v1.DocumentTokens)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr document_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr document_type_;
    int32_t token_count_;
    float relevance_score_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_llm_2eproto;
};
// -------------------------------------------------------------------

class TokenCountRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.llm.v1.TokenCountRequest) */ {
 public:
  inline TokenCountRequest() : TokenCountRequest(nullptr) {}
  ~TokenCountRequest() override;
  explicit PROTOBUF_CONSTEXPR TokenCountRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TokenCountRequest(const TokenCountRequest& from);
  TokenCountRequest(TokenCountRequest&& from) noexcept
    : TokenCountRequest() {
    *this = ::std::move(from);
  }

  inline TokenCountRequest& operator=(const TokenCountRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TokenCountRequest& operator=(TokenCountRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TokenCountRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TokenCountRequest* internal_default_instance() {
    return reinterpret_cast<const TokenCountRequest*>(
               &_TokenCountRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(TokenCountRequest& a, TokenCountRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TokenCountRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TokenCountRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TokenCountRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TokenCountRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TokenCountRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TokenCountRequest& from) {
    TokenCountRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TokenCountRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.llm.v1.TokenCountRequest";
  }
  protected:
  explicit TokenCountRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelFieldNumber = 1,
    kTextFieldNumber = 2,
  };
  // string model = 1;
  void clear_model();
  const std::string& model() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model();
  PROTOBUF_NODISCARD std::string* release_model();
  void set_allocated_model(std::string* model);
  private:
  const std::string& _internal_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model(const std::string& value);
  std::string* _internal_mutable_model();
  public:

  // string text = 2;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // @@protoc_insertion_point(class_scope:unhinged.llm.v1.TokenCountRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_llm_2eproto;
};
// -------------------------------------------------------------------

class TokenCountResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.llm.v1.TokenCountResponse) */ {
 public:
  inline TokenCountResponse() : TokenCountResponse(nullptr) {}
  ~TokenCountResponse() override;
  explicit PROTOBUF_CONSTEXPR TokenCountResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TokenCountResponse(const TokenCountResponse& from);
  TokenCountResponse(TokenCountResponse&& from) noexcept
    : TokenCountResponse() {
    *this = ::std::move(from);
  }

  inline TokenCountResponse& operator=(const TokenCountResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TokenCountResponse& operator=(TokenCountResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TokenCountResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TokenCountResponse* internal_default_instance() {
    return reinterpret_cast<const TokenCountResponse*>(
               &_TokenCountResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(TokenCountResponse& a, TokenCountResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TokenCountResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TokenCountResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TokenCountResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TokenCountResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TokenCountResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TokenCountResponse& from) {
    TokenCountResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TokenCountResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.llm.v1.TokenCountResponse";
  }
  protected:
  explicit TokenCountResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokensFieldNumber = 3,
    kResponseFieldNumber = 1,
    kTokenCountFieldNumber = 2,
  };
  // repeated .unhinged.llm.v1.TokenInfo tokens = 3;
  int tokens_size() const;
  private:
  int _internal_tokens_size() const;
  public:
  void clear_tokens();
  ::unhinged::llm::v1::TokenInfo* mutable_tokens(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::llm::v1::TokenInfo >*
      mutable_tokens();
  private:
  const ::unhinged::llm::v1::TokenInfo& _internal_tokens(int index) const;
  ::unhinged::llm::v1::TokenInfo* _internal_add_tokens();
  public:
  const ::unhinged::llm::v1::TokenInfo& tokens(int index) const;
  ::unhinged::llm::v1::TokenInfo* add_tokens();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::llm::v1::TokenInfo >&
      tokens() const;

  // .unhinged.common.v1.StandardResponse response = 1;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::unhinged::common::v1::StandardResponse& response() const;
  PROTOBUF_NODISCARD ::unhinged::common::v1::StandardResponse* release_response();
  ::unhinged::common::v1::StandardResponse* mutable_response();
  void set_allocated_response(::unhinged::common::v1::StandardResponse* response);
  private:
  const ::unhinged::common::v1::StandardResponse& _internal_response() const;
  ::unhinged::common::v1::StandardResponse* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::unhinged::common::v1::StandardResponse* response);
  ::unhinged::common::v1::StandardResponse* unsafe_arena_release_response();

  // int32 token_count = 2;
  void clear_token_count();
  int32_t token_count() const;
  void set_token_count(int32_t value);
  private:
  int32_t _internal_token_count() const;
  void _internal_set_token_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.llm.v1.TokenCountResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::llm::v1::TokenInfo > tokens_;
    ::unhinged::common::v1::StandardResponse* response_;
    int32_t token_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_llm_2eproto;
};
// -------------------------------------------------------------------

class TokenInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.llm.v1.TokenInfo) */ {
 public:
  inline TokenInfo() : TokenInfo(nullptr) {}
  ~TokenInfo() override;
  explicit PROTOBUF_CONSTEXPR TokenInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TokenInfo(const TokenInfo& from);
  TokenInfo(TokenInfo&& from) noexcept
    : TokenInfo() {
    *this = ::std::move(from);
  }

  inline TokenInfo& operator=(const TokenInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TokenInfo& operator=(TokenInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TokenInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TokenInfo* internal_default_instance() {
    return reinterpret_cast<const TokenInfo*>(
               &_TokenInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(TokenInfo& a, TokenInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TokenInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TokenInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TokenInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TokenInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TokenInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TokenInfo& from) {
    TokenInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TokenInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.llm.v1.TokenInfo";
  }
  protected:
  explicit TokenInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 1,
    kTokenIdFieldNumber = 2,
    kProbabilityFieldNumber = 3,
  };
  // string token = 1;
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // int32 token_id = 2;
  void clear_token_id();
  int32_t token_id() const;
  void set_token_id(int32_t value);
  private:
  int32_t _internal_token_id() const;
  void _internal_set_token_id(int32_t value);
  public:

  // float probability = 3;
  void clear_probability();
  float probability() const;
  void set_probability(float value);
  private:
  float _internal_probability() const;
  void _internal_set_probability(float value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.llm.v1.TokenInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
    int32_t token_id_;
    float probability_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_llm_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CompletionRequest

// string model = 1;
inline void CompletionRequest::clear_model() {
  _impl_.model_.ClearToEmpty();
}
inline const std::string& CompletionRequest::model() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.CompletionRequest.model)
  return _internal_model();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CompletionRequest::set_model(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.CompletionRequest.model)
}
inline std::string* CompletionRequest::mutable_model() {
  std::string* _s = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.CompletionRequest.model)
  return _s;
}
inline const std::string& CompletionRequest::_internal_model() const {
  return _impl_.model_.Get();
}
inline void CompletionRequest::_internal_set_model(const std::string& value) {
  
  _impl_.model_.Set(value, GetArenaForAllocation());
}
inline std::string* CompletionRequest::_internal_mutable_model() {
  
  return _impl_.model_.Mutable(GetArenaForAllocation());
}
inline std::string* CompletionRequest::release_model() {
  // @@protoc_insertion_point(field_release:unhinged.llm.v1.CompletionRequest.model)
  return _impl_.model_.Release();
}
inline void CompletionRequest::set_allocated_model(std::string* model) {
  if (model != nullptr) {
    
  } else {
    
  }
  _impl_.model_.SetAllocated(model, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_.IsDefault()) {
    _impl_.model_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.llm.v1.CompletionRequest.model)
}

// repeated .unhinged.chat.v1.ChatMessage messages = 2;
inline int CompletionRequest::_internal_messages_size() const {
  return _impl_.messages_.size();
}
inline int CompletionRequest::messages_size() const {
  return _internal_messages_size();
}
inline ::unhinged::chat::v1::ChatMessage* CompletionRequest::mutable_messages(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.CompletionRequest.messages)
  return _impl_.messages_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::chat::v1::ChatMessage >*
CompletionRequest::mutable_messages() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.llm.v1.CompletionRequest.messages)
  return &_impl_.messages_;
}
inline const ::unhinged::chat::v1::ChatMessage& CompletionRequest::_internal_messages(int index) const {
  return _impl_.messages_.Get(index);
}
inline const ::unhinged::chat::v1::ChatMessage& CompletionRequest::messages(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.CompletionRequest.messages)
  return _internal_messages(index);
}
inline ::unhinged::chat::v1::ChatMessage* CompletionRequest::_internal_add_messages() {
  return _impl_.messages_.Add();
}
inline ::unhinged::chat::v1::ChatMessage* CompletionRequest::add_messages() {
  ::unhinged::chat::v1::ChatMessage* _add = _internal_add_messages();
  // @@protoc_insertion_point(field_add:unhinged.llm.v1.CompletionRequest.messages)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::chat::v1::ChatMessage >&
CompletionRequest::messages() const {
  // @@protoc_insertion_point(field_list:unhinged.llm.v1.CompletionRequest.messages)
  return _impl_.messages_;
}

// .unhinged.llm.v1.CompletionOptions options = 3;
inline bool CompletionRequest::_internal_has_options() const {
  return this != internal_default_instance() && _impl_.options_ != nullptr;
}
inline bool CompletionRequest::has_options() const {
  return _internal_has_options();
}
inline void CompletionRequest::clear_options() {
  if (GetArenaForAllocation() == nullptr && _impl_.options_ != nullptr) {
    delete _impl_.options_;
  }
  _impl_.options_ = nullptr;
}
inline const ::unhinged::llm::v1::CompletionOptions& CompletionRequest::_internal_options() const {
  const ::unhinged::llm::v1::CompletionOptions* p = _impl_.options_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::llm::v1::CompletionOptions&>(
      ::unhinged::llm::v1::_CompletionOptions_default_instance_);
}
inline const ::unhinged::llm::v1::CompletionOptions& CompletionRequest::options() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.CompletionRequest.options)
  return _internal_options();
}
inline void CompletionRequest::unsafe_arena_set_allocated_options(
    ::unhinged::llm::v1::CompletionOptions* options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.options_);
  }
  _impl_.options_ = options;
  if (options) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.llm.v1.CompletionRequest.options)
}
inline ::unhinged::llm::v1::CompletionOptions* CompletionRequest::release_options() {
  
  ::unhinged::llm::v1::CompletionOptions* temp = _impl_.options_;
  _impl_.options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::llm::v1::CompletionOptions* CompletionRequest::unsafe_arena_release_options() {
  // @@protoc_insertion_point(field_release:unhinged.llm.v1.CompletionRequest.options)
  
  ::unhinged::llm::v1::CompletionOptions* temp = _impl_.options_;
  _impl_.options_ = nullptr;
  return temp;
}
inline ::unhinged::llm::v1::CompletionOptions* CompletionRequest::_internal_mutable_options() {
  
  if (_impl_.options_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::llm::v1::CompletionOptions>(GetArenaForAllocation());
    _impl_.options_ = p;
  }
  return _impl_.options_;
}
inline ::unhinged::llm::v1::CompletionOptions* CompletionRequest::mutable_options() {
  ::unhinged::llm::v1::CompletionOptions* _msg = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.CompletionRequest.options)
  return _msg;
}
inline void CompletionRequest::set_allocated_options(::unhinged::llm::v1::CompletionOptions* options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.options_;
  }
  if (options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(options);
    if (message_arena != submessage_arena) {
      options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.options_ = options;
  // @@protoc_insertion_point(field_set_allocated:unhinged.llm.v1.CompletionRequest.options)
}

// string session_id = 4;
inline void CompletionRequest::clear_session_id() {
  _impl_.session_id_.ClearToEmpty();
}
inline const std::string& CompletionRequest::session_id() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.CompletionRequest.session_id)
  return _internal_session_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CompletionRequest::set_session_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.session_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.CompletionRequest.session_id)
}
inline std::string* CompletionRequest::mutable_session_id() {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.CompletionRequest.session_id)
  return _s;
}
inline const std::string& CompletionRequest::_internal_session_id() const {
  return _impl_.session_id_.Get();
}
inline void CompletionRequest::_internal_set_session_id(const std::string& value) {
  
  _impl_.session_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CompletionRequest::_internal_mutable_session_id() {
  
  return _impl_.session_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CompletionRequest::release_session_id() {
  // @@protoc_insertion_point(field_release:unhinged.llm.v1.CompletionRequest.session_id)
  return _impl_.session_id_.Release();
}
inline void CompletionRequest::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  _impl_.session_id_.SetAllocated(session_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.session_id_.IsDefault()) {
    _impl_.session_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.llm.v1.CompletionRequest.session_id)
}

// bool include_context = 5;
inline void CompletionRequest::clear_include_context() {
  _impl_.include_context_ = false;
}
inline bool CompletionRequest::_internal_include_context() const {
  return _impl_.include_context_;
}
inline bool CompletionRequest::include_context() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.CompletionRequest.include_context)
  return _internal_include_context();
}
inline void CompletionRequest::_internal_set_include_context(bool value) {
  
  _impl_.include_context_ = value;
}
inline void CompletionRequest::set_include_context(bool value) {
  _internal_set_include_context(value);
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.CompletionRequest.include_context)
}

// .unhinged.llm.v1.ContextOptions context_options = 6;
inline bool CompletionRequest::_internal_has_context_options() const {
  return this != internal_default_instance() && _impl_.context_options_ != nullptr;
}
inline bool CompletionRequest::has_context_options() const {
  return _internal_has_context_options();
}
inline void CompletionRequest::clear_context_options() {
  if (GetArenaForAllocation() == nullptr && _impl_.context_options_ != nullptr) {
    delete _impl_.context_options_;
  }
  _impl_.context_options_ = nullptr;
}
inline const ::unhinged::llm::v1::ContextOptions& CompletionRequest::_internal_context_options() const {
  const ::unhinged::llm::v1::ContextOptions* p = _impl_.context_options_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::llm::v1::ContextOptions&>(
      ::unhinged::llm::v1::_ContextOptions_default_instance_);
}
inline const ::unhinged::llm::v1::ContextOptions& CompletionRequest::context_options() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.CompletionRequest.context_options)
  return _internal_context_options();
}
inline void CompletionRequest::unsafe_arena_set_allocated_context_options(
    ::unhinged::llm::v1::ContextOptions* context_options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.context_options_);
  }
  _impl_.context_options_ = context_options;
  if (context_options) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.llm.v1.CompletionRequest.context_options)
}
inline ::unhinged::llm::v1::ContextOptions* CompletionRequest::release_context_options() {
  
  ::unhinged::llm::v1::ContextOptions* temp = _impl_.context_options_;
  _impl_.context_options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::llm::v1::ContextOptions* CompletionRequest::unsafe_arena_release_context_options() {
  // @@protoc_insertion_point(field_release:unhinged.llm.v1.CompletionRequest.context_options)
  
  ::unhinged::llm::v1::ContextOptions* temp = _impl_.context_options_;
  _impl_.context_options_ = nullptr;
  return temp;
}
inline ::unhinged::llm::v1::ContextOptions* CompletionRequest::_internal_mutable_context_options() {
  
  if (_impl_.context_options_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::llm::v1::ContextOptions>(GetArenaForAllocation());
    _impl_.context_options_ = p;
  }
  return _impl_.context_options_;
}
inline ::unhinged::llm::v1::ContextOptions* CompletionRequest::mutable_context_options() {
  ::unhinged::llm::v1::ContextOptions* _msg = _internal_mutable_context_options();
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.CompletionRequest.context_options)
  return _msg;
}
inline void CompletionRequest::set_allocated_context_options(::unhinged::llm::v1::ContextOptions* context_options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.context_options_;
  }
  if (context_options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(context_options);
    if (message_arena != submessage_arena) {
      context_options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, context_options, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.context_options_ = context_options;
  // @@protoc_insertion_point(field_set_allocated:unhinged.llm.v1.CompletionRequest.context_options)
}

// -------------------------------------------------------------------

// CompletionOptions

// int32 max_tokens = 1;
inline void CompletionOptions::clear_max_tokens() {
  _impl_.max_tokens_ = 0;
}
inline int32_t CompletionOptions::_internal_max_tokens() const {
  return _impl_.max_tokens_;
}
inline int32_t CompletionOptions::max_tokens() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.CompletionOptions.max_tokens)
  return _internal_max_tokens();
}
inline void CompletionOptions::_internal_set_max_tokens(int32_t value) {
  
  _impl_.max_tokens_ = value;
}
inline void CompletionOptions::set_max_tokens(int32_t value) {
  _internal_set_max_tokens(value);
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.CompletionOptions.max_tokens)
}

// float temperature = 2;
inline void CompletionOptions::clear_temperature() {
  _impl_.temperature_ = 0;
}
inline float CompletionOptions::_internal_temperature() const {
  return _impl_.temperature_;
}
inline float CompletionOptions::temperature() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.CompletionOptions.temperature)
  return _internal_temperature();
}
inline void CompletionOptions::_internal_set_temperature(float value) {
  
  _impl_.temperature_ = value;
}
inline void CompletionOptions::set_temperature(float value) {
  _internal_set_temperature(value);
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.CompletionOptions.temperature)
}

// float top_p = 3;
inline void CompletionOptions::clear_top_p() {
  _impl_.top_p_ = 0;
}
inline float CompletionOptions::_internal_top_p() const {
  return _impl_.top_p_;
}
inline float CompletionOptions::top_p() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.CompletionOptions.top_p)
  return _internal_top_p();
}
inline void CompletionOptions::_internal_set_top_p(float value) {
  
  _impl_.top_p_ = value;
}
inline void CompletionOptions::set_top_p(float value) {
  _internal_set_top_p(value);
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.CompletionOptions.top_p)
}

// float frequency_penalty = 4;
inline void CompletionOptions::clear_frequency_penalty() {
  _impl_.frequency_penalty_ = 0;
}
inline float CompletionOptions::_internal_frequency_penalty() const {
  return _impl_.frequency_penalty_;
}
inline float CompletionOptions::frequency_penalty() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.CompletionOptions.frequency_penalty)
  return _internal_frequency_penalty();
}
inline void CompletionOptions::_internal_set_frequency_penalty(float value) {
  
  _impl_.frequency_penalty_ = value;
}
inline void CompletionOptions::set_frequency_penalty(float value) {
  _internal_set_frequency_penalty(value);
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.CompletionOptions.frequency_penalty)
}

// float presence_penalty = 5;
inline void CompletionOptions::clear_presence_penalty() {
  _impl_.presence_penalty_ = 0;
}
inline float CompletionOptions::_internal_presence_penalty() const {
  return _impl_.presence_penalty_;
}
inline float CompletionOptions::presence_penalty() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.CompletionOptions.presence_penalty)
  return _internal_presence_penalty();
}
inline void CompletionOptions::_internal_set_presence_penalty(float value) {
  
  _impl_.presence_penalty_ = value;
}
inline void CompletionOptions::set_presence_penalty(float value) {
  _internal_set_presence_penalty(value);
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.CompletionOptions.presence_penalty)
}

// repeated string stop_sequences = 6;
inline int CompletionOptions::_internal_stop_sequences_size() const {
  return _impl_.stop_sequences_.size();
}
inline int CompletionOptions::stop_sequences_size() const {
  return _internal_stop_sequences_size();
}
inline void CompletionOptions::clear_stop_sequences() {
  _impl_.stop_sequences_.Clear();
}
inline std::string* CompletionOptions::add_stop_sequences() {
  std::string* _s = _internal_add_stop_sequences();
  // @@protoc_insertion_point(field_add_mutable:unhinged.llm.v1.CompletionOptions.stop_sequences)
  return _s;
}
inline const std::string& CompletionOptions::_internal_stop_sequences(int index) const {
  return _impl_.stop_sequences_.Get(index);
}
inline const std::string& CompletionOptions::stop_sequences(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.CompletionOptions.stop_sequences)
  return _internal_stop_sequences(index);
}
inline std::string* CompletionOptions::mutable_stop_sequences(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.CompletionOptions.stop_sequences)
  return _impl_.stop_sequences_.Mutable(index);
}
inline void CompletionOptions::set_stop_sequences(int index, const std::string& value) {
  _impl_.stop_sequences_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.CompletionOptions.stop_sequences)
}
inline void CompletionOptions::set_stop_sequences(int index, std::string&& value) {
  _impl_.stop_sequences_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.CompletionOptions.stop_sequences)
}
inline void CompletionOptions::set_stop_sequences(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.stop_sequences_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.llm.v1.CompletionOptions.stop_sequences)
}
inline void CompletionOptions::set_stop_sequences(int index, const char* value, size_t size) {
  _impl_.stop_sequences_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.llm.v1.CompletionOptions.stop_sequences)
}
inline std::string* CompletionOptions::_internal_add_stop_sequences() {
  return _impl_.stop_sequences_.Add();
}
inline void CompletionOptions::add_stop_sequences(const std::string& value) {
  _impl_.stop_sequences_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.llm.v1.CompletionOptions.stop_sequences)
}
inline void CompletionOptions::add_stop_sequences(std::string&& value) {
  _impl_.stop_sequences_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.llm.v1.CompletionOptions.stop_sequences)
}
inline void CompletionOptions::add_stop_sequences(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.stop_sequences_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.llm.v1.CompletionOptions.stop_sequences)
}
inline void CompletionOptions::add_stop_sequences(const char* value, size_t size) {
  _impl_.stop_sequences_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.llm.v1.CompletionOptions.stop_sequences)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CompletionOptions::stop_sequences() const {
  // @@protoc_insertion_point(field_list:unhinged.llm.v1.CompletionOptions.stop_sequences)
  return _impl_.stop_sequences_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CompletionOptions::mutable_stop_sequences() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.llm.v1.CompletionOptions.stop_sequences)
  return &_impl_.stop_sequences_;
}

// bool stream = 7;
inline void CompletionOptions::clear_stream() {
  _impl_.stream_ = false;
}
inline bool CompletionOptions::_internal_stream() const {
  return _impl_.stream_;
}
inline bool CompletionOptions::stream() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.CompletionOptions.stream)
  return _internal_stream();
}
inline void CompletionOptions::_internal_set_stream(bool value) {
  
  _impl_.stream_ = value;
}
inline void CompletionOptions::set_stream(bool value) {
  _internal_set_stream(value);
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.CompletionOptions.stream)
}

// bool include_usage = 8;
inline void CompletionOptions::clear_include_usage() {
  _impl_.include_usage_ = false;
}
inline bool CompletionOptions::_internal_include_usage() const {
  return _impl_.include_usage_;
}
inline bool CompletionOptions::include_usage() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.CompletionOptions.include_usage)
  return _internal_include_usage();
}
inline void CompletionOptions::_internal_set_include_usage(bool value) {
  
  _impl_.include_usage_ = value;
}
inline void CompletionOptions::set_include_usage(bool value) {
  _internal_set_include_usage(value);
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.CompletionOptions.include_usage)
}

// int32 n = 9;
inline void CompletionOptions::clear_n() {
  _impl_.n_ = 0;
}
inline int32_t CompletionOptions::_internal_n() const {
  return _impl_.n_;
}
inline int32_t CompletionOptions::n() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.CompletionOptions.n)
  return _internal_n();
}
inline void CompletionOptions::_internal_set_n(int32_t value) {
  
  _impl_.n_ = value;
}
inline void CompletionOptions::set_n(int32_t value) {
  _internal_set_n(value);
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.CompletionOptions.n)
}

// bool enable_tools = 10;
inline void CompletionOptions::clear_enable_tools() {
  _impl_.enable_tools_ = false;
}
inline bool CompletionOptions::_internal_enable_tools() const {
  return _impl_.enable_tools_;
}
inline bool CompletionOptions::enable_tools() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.CompletionOptions.enable_tools)
  return _internal_enable_tools();
}
inline void CompletionOptions::_internal_set_enable_tools(bool value) {
  
  _impl_.enable_tools_ = value;
}
inline void CompletionOptions::set_enable_tools(bool value) {
  _internal_set_enable_tools(value);
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.CompletionOptions.enable_tools)
}

// repeated .unhinged.llm.v1.ToolDefinition tools = 11;
inline int CompletionOptions::_internal_tools_size() const {
  return _impl_.tools_.size();
}
inline int CompletionOptions::tools_size() const {
  return _internal_tools_size();
}
inline void CompletionOptions::clear_tools() {
  _impl_.tools_.Clear();
}
inline ::unhinged::llm::v1::ToolDefinition* CompletionOptions::mutable_tools(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.CompletionOptions.tools)
  return _impl_.tools_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::llm::v1::ToolDefinition >*
CompletionOptions::mutable_tools() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.llm.v1.CompletionOptions.tools)
  return &_impl_.tools_;
}
inline const ::unhinged::llm::v1::ToolDefinition& CompletionOptions::_internal_tools(int index) const {
  return _impl_.tools_.Get(index);
}
inline const ::unhinged::llm::v1::ToolDefinition& CompletionOptions::tools(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.CompletionOptions.tools)
  return _internal_tools(index);
}
inline ::unhinged::llm::v1::ToolDefinition* CompletionOptions::_internal_add_tools() {
  return _impl_.tools_.Add();
}
inline ::unhinged::llm::v1::ToolDefinition* CompletionOptions::add_tools() {
  ::unhinged::llm::v1::ToolDefinition* _add = _internal_add_tools();
  // @@protoc_insertion_point(field_add:unhinged.llm.v1.CompletionOptions.tools)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::llm::v1::ToolDefinition >&
CompletionOptions::tools() const {
  // @@protoc_insertion_point(field_list:unhinged.llm.v1.CompletionOptions.tools)
  return _impl_.tools_;
}

// string tool_choice = 12;
inline void CompletionOptions::clear_tool_choice() {
  _impl_.tool_choice_.ClearToEmpty();
}
inline const std::string& CompletionOptions::tool_choice() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.CompletionOptions.tool_choice)
  return _internal_tool_choice();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CompletionOptions::set_tool_choice(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tool_choice_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.CompletionOptions.tool_choice)
}
inline std::string* CompletionOptions::mutable_tool_choice() {
  std::string* _s = _internal_mutable_tool_choice();
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.CompletionOptions.tool_choice)
  return _s;
}
inline const std::string& CompletionOptions::_internal_tool_choice() const {
  return _impl_.tool_choice_.Get();
}
inline void CompletionOptions::_internal_set_tool_choice(const std::string& value) {
  
  _impl_.tool_choice_.Set(value, GetArenaForAllocation());
}
inline std::string* CompletionOptions::_internal_mutable_tool_choice() {
  
  return _impl_.tool_choice_.Mutable(GetArenaForAllocation());
}
inline std::string* CompletionOptions::release_tool_choice() {
  // @@protoc_insertion_point(field_release:unhinged.llm.v1.CompletionOptions.tool_choice)
  return _impl_.tool_choice_.Release();
}
inline void CompletionOptions::set_allocated_tool_choice(std::string* tool_choice) {
  if (tool_choice != nullptr) {
    
  } else {
    
  }
  _impl_.tool_choice_.SetAllocated(tool_choice, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tool_choice_.IsDefault()) {
    _impl_.tool_choice_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.llm.v1.CompletionOptions.tool_choice)
}

// -------------------------------------------------------------------

// ContextOptions

// int32 max_context_tokens = 1;
inline void ContextOptions::clear_max_context_tokens() {
  _impl_.max_context_tokens_ = 0;
}
inline int32_t ContextOptions::_internal_max_context_tokens() const {
  return _impl_.max_context_tokens_;
}
inline int32_t ContextOptions::max_context_tokens() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.ContextOptions.max_context_tokens)
  return _internal_max_context_tokens();
}
inline void ContextOptions::_internal_set_max_context_tokens(int32_t value) {
  
  _impl_.max_context_tokens_ = value;
}
inline void ContextOptions::set_max_context_tokens(int32_t value) {
  _internal_set_max_context_tokens(value);
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.ContextOptions.max_context_tokens)
}

// float relevance_threshold = 2;
inline void ContextOptions::clear_relevance_threshold() {
  _impl_.relevance_threshold_ = 0;
}
inline float ContextOptions::_internal_relevance_threshold() const {
  return _impl_.relevance_threshold_;
}
inline float ContextOptions::relevance_threshold() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.ContextOptions.relevance_threshold)
  return _internal_relevance_threshold();
}
inline void ContextOptions::_internal_set_relevance_threshold(float value) {
  
  _impl_.relevance_threshold_ = value;
}
inline void ContextOptions::set_relevance_threshold(float value) {
  _internal_set_relevance_threshold(value);
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.ContextOptions.relevance_threshold)
}

// repeated string document_types = 3;
inline int ContextOptions::_internal_document_types_size() const {
  return _impl_.document_types_.size();
}
inline int ContextOptions::document_types_size() const {
  return _internal_document_types_size();
}
inline void ContextOptions::clear_document_types() {
  _impl_.document_types_.Clear();
}
inline std::string* ContextOptions::add_document_types() {
  std::string* _s = _internal_add_document_types();
  // @@protoc_insertion_point(field_add_mutable:unhinged.llm.v1.ContextOptions.document_types)
  return _s;
}
inline const std::string& ContextOptions::_internal_document_types(int index) const {
  return _impl_.document_types_.Get(index);
}
inline const std::string& ContextOptions::document_types(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.ContextOptions.document_types)
  return _internal_document_types(index);
}
inline std::string* ContextOptions::mutable_document_types(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.ContextOptions.document_types)
  return _impl_.document_types_.Mutable(index);
}
inline void ContextOptions::set_document_types(int index, const std::string& value) {
  _impl_.document_types_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.ContextOptions.document_types)
}
inline void ContextOptions::set_document_types(int index, std::string&& value) {
  _impl_.document_types_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.ContextOptions.document_types)
}
inline void ContextOptions::set_document_types(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.document_types_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.llm.v1.ContextOptions.document_types)
}
inline void ContextOptions::set_document_types(int index, const char* value, size_t size) {
  _impl_.document_types_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.llm.v1.ContextOptions.document_types)
}
inline std::string* ContextOptions::_internal_add_document_types() {
  return _impl_.document_types_.Add();
}
inline void ContextOptions::add_document_types(const std::string& value) {
  _impl_.document_types_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.llm.v1.ContextOptions.document_types)
}
inline void ContextOptions::add_document_types(std::string&& value) {
  _impl_.document_types_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.llm.v1.ContextOptions.document_types)
}
inline void ContextOptions::add_document_types(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.document_types_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.llm.v1.ContextOptions.document_types)
}
inline void ContextOptions::add_document_types(const char* value, size_t size) {
  _impl_.document_types_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.llm.v1.ContextOptions.document_types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ContextOptions::document_types() const {
  // @@protoc_insertion_point(field_list:unhinged.llm.v1.ContextOptions.document_types)
  return _impl_.document_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ContextOptions::mutable_document_types() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.llm.v1.ContextOptions.document_types)
  return &_impl_.document_types_;
}

// bool include_metadata = 4;
inline void ContextOptions::clear_include_metadata() {
  _impl_.include_metadata_ = false;
}
inline bool ContextOptions::_internal_include_metadata() const {
  return _impl_.include_metadata_;
}
inline bool ContextOptions::include_metadata() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.ContextOptions.include_metadata)
  return _internal_include_metadata();
}
inline void ContextOptions::_internal_set_include_metadata(bool value) {
  
  _impl_.include_metadata_ = value;
}
inline void ContextOptions::set_include_metadata(bool value) {
  _internal_set_include_metadata(value);
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.ContextOptions.include_metadata)
}

// -------------------------------------------------------------------

// ToolDefinition

// string name = 1;
inline void ToolDefinition::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ToolDefinition::name() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.ToolDefinition.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ToolDefinition::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.ToolDefinition.name)
}
inline std::string* ToolDefinition::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.ToolDefinition.name)
  return _s;
}
inline const std::string& ToolDefinition::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ToolDefinition::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ToolDefinition::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ToolDefinition::release_name() {
  // @@protoc_insertion_point(field_release:unhinged.llm.v1.ToolDefinition.name)
  return _impl_.name_.Release();
}
inline void ToolDefinition::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.llm.v1.ToolDefinition.name)
}

// string description = 2;
inline void ToolDefinition::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& ToolDefinition::description() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.ToolDefinition.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ToolDefinition::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.ToolDefinition.description)
}
inline std::string* ToolDefinition::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.ToolDefinition.description)
  return _s;
}
inline const std::string& ToolDefinition::_internal_description() const {
  return _impl_.description_.Get();
}
inline void ToolDefinition::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* ToolDefinition::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* ToolDefinition::release_description() {
  // @@protoc_insertion_point(field_release:unhinged.llm.v1.ToolDefinition.description)
  return _impl_.description_.Release();
}
inline void ToolDefinition::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.llm.v1.ToolDefinition.description)
}

// string parameters_schema = 3;
inline void ToolDefinition::clear_parameters_schema() {
  _impl_.parameters_schema_.ClearToEmpty();
}
inline const std::string& ToolDefinition::parameters_schema() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.ToolDefinition.parameters_schema)
  return _internal_parameters_schema();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ToolDefinition::set_parameters_schema(ArgT0&& arg0, ArgT... args) {
 
 _impl_.parameters_schema_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.ToolDefinition.parameters_schema)
}
inline std::string* ToolDefinition::mutable_parameters_schema() {
  std::string* _s = _internal_mutable_parameters_schema();
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.ToolDefinition.parameters_schema)
  return _s;
}
inline const std::string& ToolDefinition::_internal_parameters_schema() const {
  return _impl_.parameters_schema_.Get();
}
inline void ToolDefinition::_internal_set_parameters_schema(const std::string& value) {
  
  _impl_.parameters_schema_.Set(value, GetArenaForAllocation());
}
inline std::string* ToolDefinition::_internal_mutable_parameters_schema() {
  
  return _impl_.parameters_schema_.Mutable(GetArenaForAllocation());
}
inline std::string* ToolDefinition::release_parameters_schema() {
  // @@protoc_insertion_point(field_release:unhinged.llm.v1.ToolDefinition.parameters_schema)
  return _impl_.parameters_schema_.Release();
}
inline void ToolDefinition::set_allocated_parameters_schema(std::string* parameters_schema) {
  if (parameters_schema != nullptr) {
    
  } else {
    
  }
  _impl_.parameters_schema_.SetAllocated(parameters_schema, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parameters_schema_.IsDefault()) {
    _impl_.parameters_schema_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.llm.v1.ToolDefinition.parameters_schema)
}

// bool required = 4;
inline void ToolDefinition::clear_required() {
  _impl_.required_ = false;
}
inline bool ToolDefinition::_internal_required() const {
  return _impl_.required_;
}
inline bool ToolDefinition::required() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.ToolDefinition.required)
  return _internal_required();
}
inline void ToolDefinition::_internal_set_required(bool value) {
  
  _impl_.required_ = value;
}
inline void ToolDefinition::set_required(bool value) {
  _internal_set_required(value);
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.ToolDefinition.required)
}

// -------------------------------------------------------------------

// CompletionResponse

// .unhinged.common.v1.StandardResponse response = 1;
inline bool CompletionResponse::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool CompletionResponse::has_response() const {
  return _internal_has_response();
}
inline const ::unhinged::common::v1::StandardResponse& CompletionResponse::_internal_response() const {
  const ::unhinged::common::v1::StandardResponse* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::common::v1::StandardResponse&>(
      ::unhinged::common::v1::_StandardResponse_default_instance_);
}
inline const ::unhinged::common::v1::StandardResponse& CompletionResponse::response() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.CompletionResponse.response)
  return _internal_response();
}
inline void CompletionResponse::unsafe_arena_set_allocated_response(
    ::unhinged::common::v1::StandardResponse* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.llm.v1.CompletionResponse.response)
}
inline ::unhinged::common::v1::StandardResponse* CompletionResponse::release_response() {
  
  ::unhinged::common::v1::StandardResponse* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::common::v1::StandardResponse* CompletionResponse::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:unhinged.llm.v1.CompletionResponse.response)
  
  ::unhinged::common::v1::StandardResponse* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::unhinged::common::v1::StandardResponse* CompletionResponse::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::common::v1::StandardResponse>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::unhinged::common::v1::StandardResponse* CompletionResponse::mutable_response() {
  ::unhinged::common::v1::StandardResponse* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.CompletionResponse.response)
  return _msg;
}
inline void CompletionResponse::set_allocated_response(::unhinged::common::v1::StandardResponse* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:unhinged.llm.v1.CompletionResponse.response)
}

// string completion_id = 2;
inline void CompletionResponse::clear_completion_id() {
  _impl_.completion_id_.ClearToEmpty();
}
inline const std::string& CompletionResponse::completion_id() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.CompletionResponse.completion_id)
  return _internal_completion_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CompletionResponse::set_completion_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.completion_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.CompletionResponse.completion_id)
}
inline std::string* CompletionResponse::mutable_completion_id() {
  std::string* _s = _internal_mutable_completion_id();
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.CompletionResponse.completion_id)
  return _s;
}
inline const std::string& CompletionResponse::_internal_completion_id() const {
  return _impl_.completion_id_.Get();
}
inline void CompletionResponse::_internal_set_completion_id(const std::string& value) {
  
  _impl_.completion_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CompletionResponse::_internal_mutable_completion_id() {
  
  return _impl_.completion_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CompletionResponse::release_completion_id() {
  // @@protoc_insertion_point(field_release:unhinged.llm.v1.CompletionResponse.completion_id)
  return _impl_.completion_id_.Release();
}
inline void CompletionResponse::set_allocated_completion_id(std::string* completion_id) {
  if (completion_id != nullptr) {
    
  } else {
    
  }
  _impl_.completion_id_.SetAllocated(completion_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.completion_id_.IsDefault()) {
    _impl_.completion_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.llm.v1.CompletionResponse.completion_id)
}

// repeated .unhinged.llm.v1.CompletionChoice choices = 3;
inline int CompletionResponse::_internal_choices_size() const {
  return _impl_.choices_.size();
}
inline int CompletionResponse::choices_size() const {
  return _internal_choices_size();
}
inline void CompletionResponse::clear_choices() {
  _impl_.choices_.Clear();
}
inline ::unhinged::llm::v1::CompletionChoice* CompletionResponse::mutable_choices(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.CompletionResponse.choices)
  return _impl_.choices_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::llm::v1::CompletionChoice >*
CompletionResponse::mutable_choices() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.llm.v1.CompletionResponse.choices)
  return &_impl_.choices_;
}
inline const ::unhinged::llm::v1::CompletionChoice& CompletionResponse::_internal_choices(int index) const {
  return _impl_.choices_.Get(index);
}
inline const ::unhinged::llm::v1::CompletionChoice& CompletionResponse::choices(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.CompletionResponse.choices)
  return _internal_choices(index);
}
inline ::unhinged::llm::v1::CompletionChoice* CompletionResponse::_internal_add_choices() {
  return _impl_.choices_.Add();
}
inline ::unhinged::llm::v1::CompletionChoice* CompletionResponse::add_choices() {
  ::unhinged::llm::v1::CompletionChoice* _add = _internal_add_choices();
  // @@protoc_insertion_point(field_add:unhinged.llm.v1.CompletionResponse.choices)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::llm::v1::CompletionChoice >&
CompletionResponse::choices() const {
  // @@protoc_insertion_point(field_list:unhinged.llm.v1.CompletionResponse.choices)
  return _impl_.choices_;
}

// .unhinged.common.v1.UsageMetrics usage = 4;
inline bool CompletionResponse::_internal_has_usage() const {
  return this != internal_default_instance() && _impl_.usage_ != nullptr;
}
inline bool CompletionResponse::has_usage() const {
  return _internal_has_usage();
}
inline const ::unhinged::common::v1::UsageMetrics& CompletionResponse::_internal_usage() const {
  const ::unhinged::common::v1::UsageMetrics* p = _impl_.usage_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::common::v1::UsageMetrics&>(
      ::unhinged::common::v1::_UsageMetrics_default_instance_);
}
inline const ::unhinged::common::v1::UsageMetrics& CompletionResponse::usage() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.CompletionResponse.usage)
  return _internal_usage();
}
inline void CompletionResponse::unsafe_arena_set_allocated_usage(
    ::unhinged::common::v1::UsageMetrics* usage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.usage_);
  }
  _impl_.usage_ = usage;
  if (usage) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.llm.v1.CompletionResponse.usage)
}
inline ::unhinged::common::v1::UsageMetrics* CompletionResponse::release_usage() {
  
  ::unhinged::common::v1::UsageMetrics* temp = _impl_.usage_;
  _impl_.usage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::common::v1::UsageMetrics* CompletionResponse::unsafe_arena_release_usage() {
  // @@protoc_insertion_point(field_release:unhinged.llm.v1.CompletionResponse.usage)
  
  ::unhinged::common::v1::UsageMetrics* temp = _impl_.usage_;
  _impl_.usage_ = nullptr;
  return temp;
}
inline ::unhinged::common::v1::UsageMetrics* CompletionResponse::_internal_mutable_usage() {
  
  if (_impl_.usage_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::common::v1::UsageMetrics>(GetArenaForAllocation());
    _impl_.usage_ = p;
  }
  return _impl_.usage_;
}
inline ::unhinged::common::v1::UsageMetrics* CompletionResponse::mutable_usage() {
  ::unhinged::common::v1::UsageMetrics* _msg = _internal_mutable_usage();
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.CompletionResponse.usage)
  return _msg;
}
inline void CompletionResponse::set_allocated_usage(::unhinged::common::v1::UsageMetrics* usage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.usage_);
  }
  if (usage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(usage));
    if (message_arena != submessage_arena) {
      usage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, usage, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.usage_ = usage;
  // @@protoc_insertion_point(field_set_allocated:unhinged.llm.v1.CompletionResponse.usage)
}

// .unhinged.llm.v1.CompletionMetadata metadata = 5;
inline bool CompletionResponse::_internal_has_metadata() const {
  return this != internal_default_instance() && _impl_.metadata_ != nullptr;
}
inline bool CompletionResponse::has_metadata() const {
  return _internal_has_metadata();
}
inline void CompletionResponse::clear_metadata() {
  if (GetArenaForAllocation() == nullptr && _impl_.metadata_ != nullptr) {
    delete _impl_.metadata_;
  }
  _impl_.metadata_ = nullptr;
}
inline const ::unhinged::llm::v1::CompletionMetadata& CompletionResponse::_internal_metadata() const {
  const ::unhinged::llm::v1::CompletionMetadata* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::llm::v1::CompletionMetadata&>(
      ::unhinged::llm::v1::_CompletionMetadata_default_instance_);
}
inline const ::unhinged::llm::v1::CompletionMetadata& CompletionResponse::metadata() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.CompletionResponse.metadata)
  return _internal_metadata();
}
inline void CompletionResponse::unsafe_arena_set_allocated_metadata(
    ::unhinged::llm::v1::CompletionMetadata* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.llm.v1.CompletionResponse.metadata)
}
inline ::unhinged::llm::v1::CompletionMetadata* CompletionResponse::release_metadata() {
  
  ::unhinged::llm::v1::CompletionMetadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::llm::v1::CompletionMetadata* CompletionResponse::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:unhinged.llm.v1.CompletionResponse.metadata)
  
  ::unhinged::llm::v1::CompletionMetadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::unhinged::llm::v1::CompletionMetadata* CompletionResponse::_internal_mutable_metadata() {
  
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::llm::v1::CompletionMetadata>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::unhinged::llm::v1::CompletionMetadata* CompletionResponse::mutable_metadata() {
  ::unhinged::llm::v1::CompletionMetadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.CompletionResponse.metadata)
  return _msg;
}
inline void CompletionResponse::set_allocated_metadata(::unhinged::llm::v1::CompletionMetadata* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.metadata_;
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(metadata);
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:unhinged.llm.v1.CompletionResponse.metadata)
}

// -------------------------------------------------------------------

// CompletionChoice

// int32 index = 1;
inline void CompletionChoice::clear_index() {
  _impl_.index_ = 0;
}
inline int32_t CompletionChoice::_internal_index() const {
  return _impl_.index_;
}
inline int32_t CompletionChoice::index() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.CompletionChoice.index)
  return _internal_index();
}
inline void CompletionChoice::_internal_set_index(int32_t value) {
  
  _impl_.index_ = value;
}
inline void CompletionChoice::set_index(int32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.CompletionChoice.index)
}

// .unhinged.chat.v1.ChatMessage message = 2;
inline bool CompletionChoice::_internal_has_message() const {
  return this != internal_default_instance() && _impl_.message_ != nullptr;
}
inline bool CompletionChoice::has_message() const {
  return _internal_has_message();
}
inline const ::unhinged::chat::v1::ChatMessage& CompletionChoice::_internal_message() const {
  const ::unhinged::chat::v1::ChatMessage* p = _impl_.message_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::chat::v1::ChatMessage&>(
      ::unhinged::chat::v1::_ChatMessage_default_instance_);
}
inline const ::unhinged::chat::v1::ChatMessage& CompletionChoice::message() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.CompletionChoice.message)
  return _internal_message();
}
inline void CompletionChoice::unsafe_arena_set_allocated_message(
    ::unhinged::chat::v1::ChatMessage* message) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.message_);
  }
  _impl_.message_ = message;
  if (message) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.llm.v1.CompletionChoice.message)
}
inline ::unhinged::chat::v1::ChatMessage* CompletionChoice::release_message() {
  
  ::unhinged::chat::v1::ChatMessage* temp = _impl_.message_;
  _impl_.message_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::chat::v1::ChatMessage* CompletionChoice::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_release:unhinged.llm.v1.CompletionChoice.message)
  
  ::unhinged::chat::v1::ChatMessage* temp = _impl_.message_;
  _impl_.message_ = nullptr;
  return temp;
}
inline ::unhinged::chat::v1::ChatMessage* CompletionChoice::_internal_mutable_message() {
  
  if (_impl_.message_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::chat::v1::ChatMessage>(GetArenaForAllocation());
    _impl_.message_ = p;
  }
  return _impl_.message_;
}
inline ::unhinged::chat::v1::ChatMessage* CompletionChoice::mutable_message() {
  ::unhinged::chat::v1::ChatMessage* _msg = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.CompletionChoice.message)
  return _msg;
}
inline void CompletionChoice::set_allocated_message(::unhinged::chat::v1::ChatMessage* message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.message_);
  }
  if (message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(message));
    if (message_arena != submessage_arena) {
      message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, message, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.message_ = message;
  // @@protoc_insertion_point(field_set_allocated:unhinged.llm.v1.CompletionChoice.message)
}

// string finish_reason = 3;
inline void CompletionChoice::clear_finish_reason() {
  _impl_.finish_reason_.ClearToEmpty();
}
inline const std::string& CompletionChoice::finish_reason() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.CompletionChoice.finish_reason)
  return _internal_finish_reason();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CompletionChoice::set_finish_reason(ArgT0&& arg0, ArgT... args) {
 
 _impl_.finish_reason_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.CompletionChoice.finish_reason)
}
inline std::string* CompletionChoice::mutable_finish_reason() {
  std::string* _s = _internal_mutable_finish_reason();
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.CompletionChoice.finish_reason)
  return _s;
}
inline const std::string& CompletionChoice::_internal_finish_reason() const {
  return _impl_.finish_reason_.Get();
}
inline void CompletionChoice::_internal_set_finish_reason(const std::string& value) {
  
  _impl_.finish_reason_.Set(value, GetArenaForAllocation());
}
inline std::string* CompletionChoice::_internal_mutable_finish_reason() {
  
  return _impl_.finish_reason_.Mutable(GetArenaForAllocation());
}
inline std::string* CompletionChoice::release_finish_reason() {
  // @@protoc_insertion_point(field_release:unhinged.llm.v1.CompletionChoice.finish_reason)
  return _impl_.finish_reason_.Release();
}
inline void CompletionChoice::set_allocated_finish_reason(std::string* finish_reason) {
  if (finish_reason != nullptr) {
    
  } else {
    
  }
  _impl_.finish_reason_.SetAllocated(finish_reason, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.finish_reason_.IsDefault()) {
    _impl_.finish_reason_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.llm.v1.CompletionChoice.finish_reason)
}

// float logprobs = 4;
inline void CompletionChoice::clear_logprobs() {
  _impl_.logprobs_ = 0;
}
inline float CompletionChoice::_internal_logprobs() const {
  return _impl_.logprobs_;
}
inline float CompletionChoice::logprobs() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.CompletionChoice.logprobs)
  return _internal_logprobs();
}
inline void CompletionChoice::_internal_set_logprobs(float value) {
  
  _impl_.logprobs_ = value;
}
inline void CompletionChoice::set_logprobs(float value) {
  _internal_set_logprobs(value);
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.CompletionChoice.logprobs)
}

// -------------------------------------------------------------------

// CompletionMetadata

// string model = 1;
inline void CompletionMetadata::clear_model() {
  _impl_.model_.ClearToEmpty();
}
inline const std::string& CompletionMetadata::model() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.CompletionMetadata.model)
  return _internal_model();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CompletionMetadata::set_model(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.CompletionMetadata.model)
}
inline std::string* CompletionMetadata::mutable_model() {
  std::string* _s = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.CompletionMetadata.model)
  return _s;
}
inline const std::string& CompletionMetadata::_internal_model() const {
  return _impl_.model_.Get();
}
inline void CompletionMetadata::_internal_set_model(const std::string& value) {
  
  _impl_.model_.Set(value, GetArenaForAllocation());
}
inline std::string* CompletionMetadata::_internal_mutable_model() {
  
  return _impl_.model_.Mutable(GetArenaForAllocation());
}
inline std::string* CompletionMetadata::release_model() {
  // @@protoc_insertion_point(field_release:unhinged.llm.v1.CompletionMetadata.model)
  return _impl_.model_.Release();
}
inline void CompletionMetadata::set_allocated_model(std::string* model) {
  if (model != nullptr) {
    
  } else {
    
  }
  _impl_.model_.SetAllocated(model, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_.IsDefault()) {
    _impl_.model_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.llm.v1.CompletionMetadata.model)
}

// string provider = 2;
inline void CompletionMetadata::clear_provider() {
  _impl_.provider_.ClearToEmpty();
}
inline const std::string& CompletionMetadata::provider() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.CompletionMetadata.provider)
  return _internal_provider();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CompletionMetadata::set_provider(ArgT0&& arg0, ArgT... args) {
 
 _impl_.provider_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.CompletionMetadata.provider)
}
inline std::string* CompletionMetadata::mutable_provider() {
  std::string* _s = _internal_mutable_provider();
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.CompletionMetadata.provider)
  return _s;
}
inline const std::string& CompletionMetadata::_internal_provider() const {
  return _impl_.provider_.Get();
}
inline void CompletionMetadata::_internal_set_provider(const std::string& value) {
  
  _impl_.provider_.Set(value, GetArenaForAllocation());
}
inline std::string* CompletionMetadata::_internal_mutable_provider() {
  
  return _impl_.provider_.Mutable(GetArenaForAllocation());
}
inline std::string* CompletionMetadata::release_provider() {
  // @@protoc_insertion_point(field_release:unhinged.llm.v1.CompletionMetadata.provider)
  return _impl_.provider_.Release();
}
inline void CompletionMetadata::set_allocated_provider(std::string* provider) {
  if (provider != nullptr) {
    
  } else {
    
  }
  _impl_.provider_.SetAllocated(provider, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.provider_.IsDefault()) {
    _impl_.provider_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.llm.v1.CompletionMetadata.provider)
}

// float processing_time_ms = 3;
inline void CompletionMetadata::clear_processing_time_ms() {
  _impl_.processing_time_ms_ = 0;
}
inline float CompletionMetadata::_internal_processing_time_ms() const {
  return _impl_.processing_time_ms_;
}
inline float CompletionMetadata::processing_time_ms() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.CompletionMetadata.processing_time_ms)
  return _internal_processing_time_ms();
}
inline void CompletionMetadata::_internal_set_processing_time_ms(float value) {
  
  _impl_.processing_time_ms_ = value;
}
inline void CompletionMetadata::set_processing_time_ms(float value) {
  _internal_set_processing_time_ms(value);
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.CompletionMetadata.processing_time_ms)
}

// int32 context_documents_used = 4;
inline void CompletionMetadata::clear_context_documents_used() {
  _impl_.context_documents_used_ = 0;
}
inline int32_t CompletionMetadata::_internal_context_documents_used() const {
  return _impl_.context_documents_used_;
}
inline int32_t CompletionMetadata::context_documents_used() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.CompletionMetadata.context_documents_used)
  return _internal_context_documents_used();
}
inline void CompletionMetadata::_internal_set_context_documents_used(int32_t value) {
  
  _impl_.context_documents_used_ = value;
}
inline void CompletionMetadata::set_context_documents_used(int32_t value) {
  _internal_set_context_documents_used(value);
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.CompletionMetadata.context_documents_used)
}

// repeated string context_document_ids = 5;
inline int CompletionMetadata::_internal_context_document_ids_size() const {
  return _impl_.context_document_ids_.size();
}
inline int CompletionMetadata::context_document_ids_size() const {
  return _internal_context_document_ids_size();
}
inline void CompletionMetadata::clear_context_document_ids() {
  _impl_.context_document_ids_.Clear();
}
inline std::string* CompletionMetadata::add_context_document_ids() {
  std::string* _s = _internal_add_context_document_ids();
  // @@protoc_insertion_point(field_add_mutable:unhinged.llm.v1.CompletionMetadata.context_document_ids)
  return _s;
}
inline const std::string& CompletionMetadata::_internal_context_document_ids(int index) const {
  return _impl_.context_document_ids_.Get(index);
}
inline const std::string& CompletionMetadata::context_document_ids(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.CompletionMetadata.context_document_ids)
  return _internal_context_document_ids(index);
}
inline std::string* CompletionMetadata::mutable_context_document_ids(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.CompletionMetadata.context_document_ids)
  return _impl_.context_document_ids_.Mutable(index);
}
inline void CompletionMetadata::set_context_document_ids(int index, const std::string& value) {
  _impl_.context_document_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.CompletionMetadata.context_document_ids)
}
inline void CompletionMetadata::set_context_document_ids(int index, std::string&& value) {
  _impl_.context_document_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.CompletionMetadata.context_document_ids)
}
inline void CompletionMetadata::set_context_document_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.context_document_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.llm.v1.CompletionMetadata.context_document_ids)
}
inline void CompletionMetadata::set_context_document_ids(int index, const char* value, size_t size) {
  _impl_.context_document_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.llm.v1.CompletionMetadata.context_document_ids)
}
inline std::string* CompletionMetadata::_internal_add_context_document_ids() {
  return _impl_.context_document_ids_.Add();
}
inline void CompletionMetadata::add_context_document_ids(const std::string& value) {
  _impl_.context_document_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.llm.v1.CompletionMetadata.context_document_ids)
}
inline void CompletionMetadata::add_context_document_ids(std::string&& value) {
  _impl_.context_document_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.llm.v1.CompletionMetadata.context_document_ids)
}
inline void CompletionMetadata::add_context_document_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.context_document_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.llm.v1.CompletionMetadata.context_document_ids)
}
inline void CompletionMetadata::add_context_document_ids(const char* value, size_t size) {
  _impl_.context_document_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.llm.v1.CompletionMetadata.context_document_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CompletionMetadata::context_document_ids() const {
  // @@protoc_insertion_point(field_list:unhinged.llm.v1.CompletionMetadata.context_document_ids)
  return _impl_.context_document_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CompletionMetadata::mutable_context_document_ids() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.llm.v1.CompletionMetadata.context_document_ids)
  return &_impl_.context_document_ids_;
}

// -------------------------------------------------------------------

// Model

// .unhinged.common.v1.ResourceMetadata metadata = 1;
inline bool Model::_internal_has_metadata() const {
  return this != internal_default_instance() && _impl_.metadata_ != nullptr;
}
inline bool Model::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::unhinged::common::v1::ResourceMetadata& Model::_internal_metadata() const {
  const ::unhinged::common::v1::ResourceMetadata* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::common::v1::ResourceMetadata&>(
      ::unhinged::common::v1::_ResourceMetadata_default_instance_);
}
inline const ::unhinged::common::v1::ResourceMetadata& Model::metadata() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.Model.metadata)
  return _internal_metadata();
}
inline void Model::unsafe_arena_set_allocated_metadata(
    ::unhinged::common::v1::ResourceMetadata* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.llm.v1.Model.metadata)
}
inline ::unhinged::common::v1::ResourceMetadata* Model::release_metadata() {
  
  ::unhinged::common::v1::ResourceMetadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::common::v1::ResourceMetadata* Model::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:unhinged.llm.v1.Model.metadata)
  
  ::unhinged::common::v1::ResourceMetadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::unhinged::common::v1::ResourceMetadata* Model::_internal_mutable_metadata() {
  
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::common::v1::ResourceMetadata>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::unhinged::common::v1::ResourceMetadata* Model::mutable_metadata() {
  ::unhinged::common::v1::ResourceMetadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.Model.metadata)
  return _msg;
}
inline void Model::set_allocated_metadata(::unhinged::common::v1::ResourceMetadata* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:unhinged.llm.v1.Model.metadata)
}

// string name = 2;
inline void Model::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Model::name() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.Model.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Model::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.Model.name)
}
inline std::string* Model::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.Model.name)
  return _s;
}
inline const std::string& Model::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Model::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Model::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Model::release_name() {
  // @@protoc_insertion_point(field_release:unhinged.llm.v1.Model.name)
  return _impl_.name_.Release();
}
inline void Model::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.llm.v1.Model.name)
}

// string provider = 3;
inline void Model::clear_provider() {
  _impl_.provider_.ClearToEmpty();
}
inline const std::string& Model::provider() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.Model.provider)
  return _internal_provider();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Model::set_provider(ArgT0&& arg0, ArgT... args) {
 
 _impl_.provider_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.Model.provider)
}
inline std::string* Model::mutable_provider() {
  std::string* _s = _internal_mutable_provider();
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.Model.provider)
  return _s;
}
inline const std::string& Model::_internal_provider() const {
  return _impl_.provider_.Get();
}
inline void Model::_internal_set_provider(const std::string& value) {
  
  _impl_.provider_.Set(value, GetArenaForAllocation());
}
inline std::string* Model::_internal_mutable_provider() {
  
  return _impl_.provider_.Mutable(GetArenaForAllocation());
}
inline std::string* Model::release_provider() {
  // @@protoc_insertion_point(field_release:unhinged.llm.v1.Model.provider)
  return _impl_.provider_.Release();
}
inline void Model::set_allocated_provider(std::string* provider) {
  if (provider != nullptr) {
    
  } else {
    
  }
  _impl_.provider_.SetAllocated(provider, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.provider_.IsDefault()) {
    _impl_.provider_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.llm.v1.Model.provider)
}

// string description = 4;
inline void Model::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Model::description() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.Model.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Model::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.Model.description)
}
inline std::string* Model::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.Model.description)
  return _s;
}
inline const std::string& Model::_internal_description() const {
  return _impl_.description_.Get();
}
inline void Model::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* Model::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* Model::release_description() {
  // @@protoc_insertion_point(field_release:unhinged.llm.v1.Model.description)
  return _impl_.description_.Release();
}
inline void Model::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.llm.v1.Model.description)
}

// .unhinged.llm.v1.ModelCapabilities capabilities = 5;
inline bool Model::_internal_has_capabilities() const {
  return this != internal_default_instance() && _impl_.capabilities_ != nullptr;
}
inline bool Model::has_capabilities() const {
  return _internal_has_capabilities();
}
inline void Model::clear_capabilities() {
  if (GetArenaForAllocation() == nullptr && _impl_.capabilities_ != nullptr) {
    delete _impl_.capabilities_;
  }
  _impl_.capabilities_ = nullptr;
}
inline const ::unhinged::llm::v1::ModelCapabilities& Model::_internal_capabilities() const {
  const ::unhinged::llm::v1::ModelCapabilities* p = _impl_.capabilities_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::llm::v1::ModelCapabilities&>(
      ::unhinged::llm::v1::_ModelCapabilities_default_instance_);
}
inline const ::unhinged::llm::v1::ModelCapabilities& Model::capabilities() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.Model.capabilities)
  return _internal_capabilities();
}
inline void Model::unsafe_arena_set_allocated_capabilities(
    ::unhinged::llm::v1::ModelCapabilities* capabilities) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.capabilities_);
  }
  _impl_.capabilities_ = capabilities;
  if (capabilities) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.llm.v1.Model.capabilities)
}
inline ::unhinged::llm::v1::ModelCapabilities* Model::release_capabilities() {
  
  ::unhinged::llm::v1::ModelCapabilities* temp = _impl_.capabilities_;
  _impl_.capabilities_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::llm::v1::ModelCapabilities* Model::unsafe_arena_release_capabilities() {
  // @@protoc_insertion_point(field_release:unhinged.llm.v1.Model.capabilities)
  
  ::unhinged::llm::v1::ModelCapabilities* temp = _impl_.capabilities_;
  _impl_.capabilities_ = nullptr;
  return temp;
}
inline ::unhinged::llm::v1::ModelCapabilities* Model::_internal_mutable_capabilities() {
  
  if (_impl_.capabilities_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::llm::v1::ModelCapabilities>(GetArenaForAllocation());
    _impl_.capabilities_ = p;
  }
  return _impl_.capabilities_;
}
inline ::unhinged::llm::v1::ModelCapabilities* Model::mutable_capabilities() {
  ::unhinged::llm::v1::ModelCapabilities* _msg = _internal_mutable_capabilities();
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.Model.capabilities)
  return _msg;
}
inline void Model::set_allocated_capabilities(::unhinged::llm::v1::ModelCapabilities* capabilities) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.capabilities_;
  }
  if (capabilities) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(capabilities);
    if (message_arena != submessage_arena) {
      capabilities = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, capabilities, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.capabilities_ = capabilities;
  // @@protoc_insertion_point(field_set_allocated:unhinged.llm.v1.Model.capabilities)
}

// .unhinged.llm.v1.ModelPricing pricing = 6;
inline bool Model::_internal_has_pricing() const {
  return this != internal_default_instance() && _impl_.pricing_ != nullptr;
}
inline bool Model::has_pricing() const {
  return _internal_has_pricing();
}
inline void Model::clear_pricing() {
  if (GetArenaForAllocation() == nullptr && _impl_.pricing_ != nullptr) {
    delete _impl_.pricing_;
  }
  _impl_.pricing_ = nullptr;
}
inline const ::unhinged::llm::v1::ModelPricing& Model::_internal_pricing() const {
  const ::unhinged::llm::v1::ModelPricing* p = _impl_.pricing_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::llm::v1::ModelPricing&>(
      ::unhinged::llm::v1::_ModelPricing_default_instance_);
}
inline const ::unhinged::llm::v1::ModelPricing& Model::pricing() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.Model.pricing)
  return _internal_pricing();
}
inline void Model::unsafe_arena_set_allocated_pricing(
    ::unhinged::llm::v1::ModelPricing* pricing) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pricing_);
  }
  _impl_.pricing_ = pricing;
  if (pricing) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.llm.v1.Model.pricing)
}
inline ::unhinged::llm::v1::ModelPricing* Model::release_pricing() {
  
  ::unhinged::llm::v1::ModelPricing* temp = _impl_.pricing_;
  _impl_.pricing_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::llm::v1::ModelPricing* Model::unsafe_arena_release_pricing() {
  // @@protoc_insertion_point(field_release:unhinged.llm.v1.Model.pricing)
  
  ::unhinged::llm::v1::ModelPricing* temp = _impl_.pricing_;
  _impl_.pricing_ = nullptr;
  return temp;
}
inline ::unhinged::llm::v1::ModelPricing* Model::_internal_mutable_pricing() {
  
  if (_impl_.pricing_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::llm::v1::ModelPricing>(GetArenaForAllocation());
    _impl_.pricing_ = p;
  }
  return _impl_.pricing_;
}
inline ::unhinged::llm::v1::ModelPricing* Model::mutable_pricing() {
  ::unhinged::llm::v1::ModelPricing* _msg = _internal_mutable_pricing();
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.Model.pricing)
  return _msg;
}
inline void Model::set_allocated_pricing(::unhinged::llm::v1::ModelPricing* pricing) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pricing_;
  }
  if (pricing) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pricing);
    if (message_arena != submessage_arena) {
      pricing = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pricing, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pricing_ = pricing;
  // @@protoc_insertion_point(field_set_allocated:unhinged.llm.v1.Model.pricing)
}

// .unhinged.llm.v1.ModelLimits limits = 7;
inline bool Model::_internal_has_limits() const {
  return this != internal_default_instance() && _impl_.limits_ != nullptr;
}
inline bool Model::has_limits() const {
  return _internal_has_limits();
}
inline void Model::clear_limits() {
  if (GetArenaForAllocation() == nullptr && _impl_.limits_ != nullptr) {
    delete _impl_.limits_;
  }
  _impl_.limits_ = nullptr;
}
inline const ::unhinged::llm::v1::ModelLimits& Model::_internal_limits() const {
  const ::unhinged::llm::v1::ModelLimits* p = _impl_.limits_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::llm::v1::ModelLimits&>(
      ::unhinged::llm::v1::_ModelLimits_default_instance_);
}
inline const ::unhinged::llm::v1::ModelLimits& Model::limits() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.Model.limits)
  return _internal_limits();
}
inline void Model::unsafe_arena_set_allocated_limits(
    ::unhinged::llm::v1::ModelLimits* limits) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.limits_);
  }
  _impl_.limits_ = limits;
  if (limits) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.llm.v1.Model.limits)
}
inline ::unhinged::llm::v1::ModelLimits* Model::release_limits() {
  
  ::unhinged::llm::v1::ModelLimits* temp = _impl_.limits_;
  _impl_.limits_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::llm::v1::ModelLimits* Model::unsafe_arena_release_limits() {
  // @@protoc_insertion_point(field_release:unhinged.llm.v1.Model.limits)
  
  ::unhinged::llm::v1::ModelLimits* temp = _impl_.limits_;
  _impl_.limits_ = nullptr;
  return temp;
}
inline ::unhinged::llm::v1::ModelLimits* Model::_internal_mutable_limits() {
  
  if (_impl_.limits_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::llm::v1::ModelLimits>(GetArenaForAllocation());
    _impl_.limits_ = p;
  }
  return _impl_.limits_;
}
inline ::unhinged::llm::v1::ModelLimits* Model::mutable_limits() {
  ::unhinged::llm::v1::ModelLimits* _msg = _internal_mutable_limits();
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.Model.limits)
  return _msg;
}
inline void Model::set_allocated_limits(::unhinged::llm::v1::ModelLimits* limits) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.limits_;
  }
  if (limits) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(limits);
    if (message_arena != submessage_arena) {
      limits = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, limits, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.limits_ = limits;
  // @@protoc_insertion_point(field_set_allocated:unhinged.llm.v1.Model.limits)
}

// bool is_available = 8;
inline void Model::clear_is_available() {
  _impl_.is_available_ = false;
}
inline bool Model::_internal_is_available() const {
  return _impl_.is_available_;
}
inline bool Model::is_available() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.Model.is_available)
  return _internal_is_available();
}
inline void Model::_internal_set_is_available(bool value) {
  
  _impl_.is_available_ = value;
}
inline void Model::set_is_available(bool value) {
  _internal_set_is_available(value);
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.Model.is_available)
}

// string status = 9;
inline void Model::clear_status() {
  _impl_.status_.ClearToEmpty();
}
inline const std::string& Model::status() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.Model.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Model::set_status(ArgT0&& arg0, ArgT... args) {
 
 _impl_.status_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.Model.status)
}
inline std::string* Model::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.Model.status)
  return _s;
}
inline const std::string& Model::_internal_status() const {
  return _impl_.status_.Get();
}
inline void Model::_internal_set_status(const std::string& value) {
  
  _impl_.status_.Set(value, GetArenaForAllocation());
}
inline std::string* Model::_internal_mutable_status() {
  
  return _impl_.status_.Mutable(GetArenaForAllocation());
}
inline std::string* Model::release_status() {
  // @@protoc_insertion_point(field_release:unhinged.llm.v1.Model.status)
  return _impl_.status_.Release();
}
inline void Model::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  _impl_.status_.SetAllocated(status, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.llm.v1.Model.status)
}

// -------------------------------------------------------------------

// ModelCapabilities

// bool supports_streaming = 1;
inline void ModelCapabilities::clear_supports_streaming() {
  _impl_.supports_streaming_ = false;
}
inline bool ModelCapabilities::_internal_supports_streaming() const {
  return _impl_.supports_streaming_;
}
inline bool ModelCapabilities::supports_streaming() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.ModelCapabilities.supports_streaming)
  return _internal_supports_streaming();
}
inline void ModelCapabilities::_internal_set_supports_streaming(bool value) {
  
  _impl_.supports_streaming_ = value;
}
inline void ModelCapabilities::set_supports_streaming(bool value) {
  _internal_set_supports_streaming(value);
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.ModelCapabilities.supports_streaming)
}

// bool supports_vision = 2;
inline void ModelCapabilities::clear_supports_vision() {
  _impl_.supports_vision_ = false;
}
inline bool ModelCapabilities::_internal_supports_vision() const {
  return _impl_.supports_vision_;
}
inline bool ModelCapabilities::supports_vision() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.ModelCapabilities.supports_vision)
  return _internal_supports_vision();
}
inline void ModelCapabilities::_internal_set_supports_vision(bool value) {
  
  _impl_.supports_vision_ = value;
}
inline void ModelCapabilities::set_supports_vision(bool value) {
  _internal_set_supports_vision(value);
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.ModelCapabilities.supports_vision)
}

// bool supports_function_calling = 3;
inline void ModelCapabilities::clear_supports_function_calling() {
  _impl_.supports_function_calling_ = false;
}
inline bool ModelCapabilities::_internal_supports_function_calling() const {
  return _impl_.supports_function_calling_;
}
inline bool ModelCapabilities::supports_function_calling() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.ModelCapabilities.supports_function_calling)
  return _internal_supports_function_calling();
}
inline void ModelCapabilities::_internal_set_supports_function_calling(bool value) {
  
  _impl_.supports_function_calling_ = value;
}
inline void ModelCapabilities::set_supports_function_calling(bool value) {
  _internal_set_supports_function_calling(value);
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.ModelCapabilities.supports_function_calling)
}

// bool supports_json_mode = 4;
inline void ModelCapabilities::clear_supports_json_mode() {
  _impl_.supports_json_mode_ = false;
}
inline bool ModelCapabilities::_internal_supports_json_mode() const {
  return _impl_.supports_json_mode_;
}
inline bool ModelCapabilities::supports_json_mode() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.ModelCapabilities.supports_json_mode)
  return _internal_supports_json_mode();
}
inline void ModelCapabilities::_internal_set_supports_json_mode(bool value) {
  
  _impl_.supports_json_mode_ = value;
}
inline void ModelCapabilities::set_supports_json_mode(bool value) {
  _internal_set_supports_json_mode(value);
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.ModelCapabilities.supports_json_mode)
}

// bool supports_system_messages = 5;
inline void ModelCapabilities::clear_supports_system_messages() {
  _impl_.supports_system_messages_ = false;
}
inline bool ModelCapabilities::_internal_supports_system_messages() const {
  return _impl_.supports_system_messages_;
}
inline bool ModelCapabilities::supports_system_messages() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.ModelCapabilities.supports_system_messages)
  return _internal_supports_system_messages();
}
inline void ModelCapabilities::_internal_set_supports_system_messages(bool value) {
  
  _impl_.supports_system_messages_ = value;
}
inline void ModelCapabilities::set_supports_system_messages(bool value) {
  _internal_set_supports_system_messages(value);
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.ModelCapabilities.supports_system_messages)
}

// repeated string supported_languages = 6;
inline int ModelCapabilities::_internal_supported_languages_size() const {
  return _impl_.supported_languages_.size();
}
inline int ModelCapabilities::supported_languages_size() const {
  return _internal_supported_languages_size();
}
inline void ModelCapabilities::clear_supported_languages() {
  _impl_.supported_languages_.Clear();
}
inline std::string* ModelCapabilities::add_supported_languages() {
  std::string* _s = _internal_add_supported_languages();
  // @@protoc_insertion_point(field_add_mutable:unhinged.llm.v1.ModelCapabilities.supported_languages)
  return _s;
}
inline const std::string& ModelCapabilities::_internal_supported_languages(int index) const {
  return _impl_.supported_languages_.Get(index);
}
inline const std::string& ModelCapabilities::supported_languages(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.ModelCapabilities.supported_languages)
  return _internal_supported_languages(index);
}
inline std::string* ModelCapabilities::mutable_supported_languages(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.ModelCapabilities.supported_languages)
  return _impl_.supported_languages_.Mutable(index);
}
inline void ModelCapabilities::set_supported_languages(int index, const std::string& value) {
  _impl_.supported_languages_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.ModelCapabilities.supported_languages)
}
inline void ModelCapabilities::set_supported_languages(int index, std::string&& value) {
  _impl_.supported_languages_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.ModelCapabilities.supported_languages)
}
inline void ModelCapabilities::set_supported_languages(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.supported_languages_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.llm.v1.ModelCapabilities.supported_languages)
}
inline void ModelCapabilities::set_supported_languages(int index, const char* value, size_t size) {
  _impl_.supported_languages_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.llm.v1.ModelCapabilities.supported_languages)
}
inline std::string* ModelCapabilities::_internal_add_supported_languages() {
  return _impl_.supported_languages_.Add();
}
inline void ModelCapabilities::add_supported_languages(const std::string& value) {
  _impl_.supported_languages_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.llm.v1.ModelCapabilities.supported_languages)
}
inline void ModelCapabilities::add_supported_languages(std::string&& value) {
  _impl_.supported_languages_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.llm.v1.ModelCapabilities.supported_languages)
}
inline void ModelCapabilities::add_supported_languages(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.supported_languages_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.llm.v1.ModelCapabilities.supported_languages)
}
inline void ModelCapabilities::add_supported_languages(const char* value, size_t size) {
  _impl_.supported_languages_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.llm.v1.ModelCapabilities.supported_languages)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ModelCapabilities::supported_languages() const {
  // @@protoc_insertion_point(field_list:unhinged.llm.v1.ModelCapabilities.supported_languages)
  return _impl_.supported_languages_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ModelCapabilities::mutable_supported_languages() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.llm.v1.ModelCapabilities.supported_languages)
  return &_impl_.supported_languages_;
}

// repeated string input_modalities = 7;
inline int ModelCapabilities::_internal_input_modalities_size() const {
  return _impl_.input_modalities_.size();
}
inline int ModelCapabilities::input_modalities_size() const {
  return _internal_input_modalities_size();
}
inline void ModelCapabilities::clear_input_modalities() {
  _impl_.input_modalities_.Clear();
}
inline std::string* ModelCapabilities::add_input_modalities() {
  std::string* _s = _internal_add_input_modalities();
  // @@protoc_insertion_point(field_add_mutable:unhinged.llm.v1.ModelCapabilities.input_modalities)
  return _s;
}
inline const std::string& ModelCapabilities::_internal_input_modalities(int index) const {
  return _impl_.input_modalities_.Get(index);
}
inline const std::string& ModelCapabilities::input_modalities(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.ModelCapabilities.input_modalities)
  return _internal_input_modalities(index);
}
inline std::string* ModelCapabilities::mutable_input_modalities(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.ModelCapabilities.input_modalities)
  return _impl_.input_modalities_.Mutable(index);
}
inline void ModelCapabilities::set_input_modalities(int index, const std::string& value) {
  _impl_.input_modalities_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.ModelCapabilities.input_modalities)
}
inline void ModelCapabilities::set_input_modalities(int index, std::string&& value) {
  _impl_.input_modalities_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.ModelCapabilities.input_modalities)
}
inline void ModelCapabilities::set_input_modalities(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.input_modalities_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.llm.v1.ModelCapabilities.input_modalities)
}
inline void ModelCapabilities::set_input_modalities(int index, const char* value, size_t size) {
  _impl_.input_modalities_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.llm.v1.ModelCapabilities.input_modalities)
}
inline std::string* ModelCapabilities::_internal_add_input_modalities() {
  return _impl_.input_modalities_.Add();
}
inline void ModelCapabilities::add_input_modalities(const std::string& value) {
  _impl_.input_modalities_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.llm.v1.ModelCapabilities.input_modalities)
}
inline void ModelCapabilities::add_input_modalities(std::string&& value) {
  _impl_.input_modalities_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.llm.v1.ModelCapabilities.input_modalities)
}
inline void ModelCapabilities::add_input_modalities(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.input_modalities_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.llm.v1.ModelCapabilities.input_modalities)
}
inline void ModelCapabilities::add_input_modalities(const char* value, size_t size) {
  _impl_.input_modalities_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.llm.v1.ModelCapabilities.input_modalities)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ModelCapabilities::input_modalities() const {
  // @@protoc_insertion_point(field_list:unhinged.llm.v1.ModelCapabilities.input_modalities)
  return _impl_.input_modalities_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ModelCapabilities::mutable_input_modalities() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.llm.v1.ModelCapabilities.input_modalities)
  return &_impl_.input_modalities_;
}

// repeated string output_modalities = 8;
inline int ModelCapabilities::_internal_output_modalities_size() const {
  return _impl_.output_modalities_.size();
}
inline int ModelCapabilities::output_modalities_size() const {
  return _internal_output_modalities_size();
}
inline void ModelCapabilities::clear_output_modalities() {
  _impl_.output_modalities_.Clear();
}
inline std::string* ModelCapabilities::add_output_modalities() {
  std::string* _s = _internal_add_output_modalities();
  // @@protoc_insertion_point(field_add_mutable:unhinged.llm.v1.ModelCapabilities.output_modalities)
  return _s;
}
inline const std::string& ModelCapabilities::_internal_output_modalities(int index) const {
  return _impl_.output_modalities_.Get(index);
}
inline const std::string& ModelCapabilities::output_modalities(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.ModelCapabilities.output_modalities)
  return _internal_output_modalities(index);
}
inline std::string* ModelCapabilities::mutable_output_modalities(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.ModelCapabilities.output_modalities)
  return _impl_.output_modalities_.Mutable(index);
}
inline void ModelCapabilities::set_output_modalities(int index, const std::string& value) {
  _impl_.output_modalities_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.ModelCapabilities.output_modalities)
}
inline void ModelCapabilities::set_output_modalities(int index, std::string&& value) {
  _impl_.output_modalities_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.ModelCapabilities.output_modalities)
}
inline void ModelCapabilities::set_output_modalities(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.output_modalities_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.llm.v1.ModelCapabilities.output_modalities)
}
inline void ModelCapabilities::set_output_modalities(int index, const char* value, size_t size) {
  _impl_.output_modalities_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.llm.v1.ModelCapabilities.output_modalities)
}
inline std::string* ModelCapabilities::_internal_add_output_modalities() {
  return _impl_.output_modalities_.Add();
}
inline void ModelCapabilities::add_output_modalities(const std::string& value) {
  _impl_.output_modalities_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.llm.v1.ModelCapabilities.output_modalities)
}
inline void ModelCapabilities::add_output_modalities(std::string&& value) {
  _impl_.output_modalities_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.llm.v1.ModelCapabilities.output_modalities)
}
inline void ModelCapabilities::add_output_modalities(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.output_modalities_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.llm.v1.ModelCapabilities.output_modalities)
}
inline void ModelCapabilities::add_output_modalities(const char* value, size_t size) {
  _impl_.output_modalities_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.llm.v1.ModelCapabilities.output_modalities)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ModelCapabilities::output_modalities() const {
  // @@protoc_insertion_point(field_list:unhinged.llm.v1.ModelCapabilities.output_modalities)
  return _impl_.output_modalities_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ModelCapabilities::mutable_output_modalities() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.llm.v1.ModelCapabilities.output_modalities)
  return &_impl_.output_modalities_;
}

// -------------------------------------------------------------------

// ModelPricing

// float input_cost_per_1k_tokens = 1;
inline void ModelPricing::clear_input_cost_per_1k_tokens() {
  _impl_.input_cost_per_1k_tokens_ = 0;
}
inline float ModelPricing::_internal_input_cost_per_1k_tokens() const {
  return _impl_.input_cost_per_1k_tokens_;
}
inline float ModelPricing::input_cost_per_1k_tokens() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.ModelPricing.input_cost_per_1k_tokens)
  return _internal_input_cost_per_1k_tokens();
}
inline void ModelPricing::_internal_set_input_cost_per_1k_tokens(float value) {
  
  _impl_.input_cost_per_1k_tokens_ = value;
}
inline void ModelPricing::set_input_cost_per_1k_tokens(float value) {
  _internal_set_input_cost_per_1k_tokens(value);
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.ModelPricing.input_cost_per_1k_tokens)
}

// float output_cost_per_1k_tokens = 2;
inline void ModelPricing::clear_output_cost_per_1k_tokens() {
  _impl_.output_cost_per_1k_tokens_ = 0;
}
inline float ModelPricing::_internal_output_cost_per_1k_tokens() const {
  return _impl_.output_cost_per_1k_tokens_;
}
inline float ModelPricing::output_cost_per_1k_tokens() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.ModelPricing.output_cost_per_1k_tokens)
  return _internal_output_cost_per_1k_tokens();
}
inline void ModelPricing::_internal_set_output_cost_per_1k_tokens(float value) {
  
  _impl_.output_cost_per_1k_tokens_ = value;
}
inline void ModelPricing::set_output_cost_per_1k_tokens(float value) {
  _internal_set_output_cost_per_1k_tokens(value);
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.ModelPricing.output_cost_per_1k_tokens)
}

// string currency = 3;
inline void ModelPricing::clear_currency() {
  _impl_.currency_.ClearToEmpty();
}
inline const std::string& ModelPricing::currency() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.ModelPricing.currency)
  return _internal_currency();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelPricing::set_currency(ArgT0&& arg0, ArgT... args) {
 
 _impl_.currency_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.ModelPricing.currency)
}
inline std::string* ModelPricing::mutable_currency() {
  std::string* _s = _internal_mutable_currency();
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.ModelPricing.currency)
  return _s;
}
inline const std::string& ModelPricing::_internal_currency() const {
  return _impl_.currency_.Get();
}
inline void ModelPricing::_internal_set_currency(const std::string& value) {
  
  _impl_.currency_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelPricing::_internal_mutable_currency() {
  
  return _impl_.currency_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelPricing::release_currency() {
  // @@protoc_insertion_point(field_release:unhinged.llm.v1.ModelPricing.currency)
  return _impl_.currency_.Release();
}
inline void ModelPricing::set_allocated_currency(std::string* currency) {
  if (currency != nullptr) {
    
  } else {
    
  }
  _impl_.currency_.SetAllocated(currency, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.currency_.IsDefault()) {
    _impl_.currency_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.llm.v1.ModelPricing.currency)
}

// bool has_free_tier = 4;
inline void ModelPricing::clear_has_free_tier() {
  _impl_.has_free_tier_ = false;
}
inline bool ModelPricing::_internal_has_free_tier() const {
  return _impl_.has_free_tier_;
}
inline bool ModelPricing::has_free_tier() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.ModelPricing.has_free_tier)
  return _internal_has_free_tier();
}
inline void ModelPricing::_internal_set_has_free_tier(bool value) {
  
  _impl_.has_free_tier_ = value;
}
inline void ModelPricing::set_has_free_tier(bool value) {
  _internal_set_has_free_tier(value);
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.ModelPricing.has_free_tier)
}

// int32 free_tier_limit = 5;
inline void ModelPricing::clear_free_tier_limit() {
  _impl_.free_tier_limit_ = 0;
}
inline int32_t ModelPricing::_internal_free_tier_limit() const {
  return _impl_.free_tier_limit_;
}
inline int32_t ModelPricing::free_tier_limit() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.ModelPricing.free_tier_limit)
  return _internal_free_tier_limit();
}
inline void ModelPricing::_internal_set_free_tier_limit(int32_t value) {
  
  _impl_.free_tier_limit_ = value;
}
inline void ModelPricing::set_free_tier_limit(int32_t value) {
  _internal_set_free_tier_limit(value);
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.ModelPricing.free_tier_limit)
}

// -------------------------------------------------------------------

// ModelLimits

// int32 max_context_tokens = 1;
inline void ModelLimits::clear_max_context_tokens() {
  _impl_.max_context_tokens_ = 0;
}
inline int32_t ModelLimits::_internal_max_context_tokens() const {
  return _impl_.max_context_tokens_;
}
inline int32_t ModelLimits::max_context_tokens() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.ModelLimits.max_context_tokens)
  return _internal_max_context_tokens();
}
inline void ModelLimits::_internal_set_max_context_tokens(int32_t value) {
  
  _impl_.max_context_tokens_ = value;
}
inline void ModelLimits::set_max_context_tokens(int32_t value) {
  _internal_set_max_context_tokens(value);
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.ModelLimits.max_context_tokens)
}

// int32 max_output_tokens = 2;
inline void ModelLimits::clear_max_output_tokens() {
  _impl_.max_output_tokens_ = 0;
}
inline int32_t ModelLimits::_internal_max_output_tokens() const {
  return _impl_.max_output_tokens_;
}
inline int32_t ModelLimits::max_output_tokens() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.ModelLimits.max_output_tokens)
  return _internal_max_output_tokens();
}
inline void ModelLimits::_internal_set_max_output_tokens(int32_t value) {
  
  _impl_.max_output_tokens_ = value;
}
inline void ModelLimits::set_max_output_tokens(int32_t value) {
  _internal_set_max_output_tokens(value);
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.ModelLimits.max_output_tokens)
}

// int32 max_requests_per_minute = 3;
inline void ModelLimits::clear_max_requests_per_minute() {
  _impl_.max_requests_per_minute_ = 0;
}
inline int32_t ModelLimits::_internal_max_requests_per_minute() const {
  return _impl_.max_requests_per_minute_;
}
inline int32_t ModelLimits::max_requests_per_minute() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.ModelLimits.max_requests_per_minute)
  return _internal_max_requests_per_minute();
}
inline void ModelLimits::_internal_set_max_requests_per_minute(int32_t value) {
  
  _impl_.max_requests_per_minute_ = value;
}
inline void ModelLimits::set_max_requests_per_minute(int32_t value) {
  _internal_set_max_requests_per_minute(value);
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.ModelLimits.max_requests_per_minute)
}

// int32 max_tokens_per_minute = 4;
inline void ModelLimits::clear_max_tokens_per_minute() {
  _impl_.max_tokens_per_minute_ = 0;
}
inline int32_t ModelLimits::_internal_max_tokens_per_minute() const {
  return _impl_.max_tokens_per_minute_;
}
inline int32_t ModelLimits::max_tokens_per_minute() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.ModelLimits.max_tokens_per_minute)
  return _internal_max_tokens_per_minute();
}
inline void ModelLimits::_internal_set_max_tokens_per_minute(int32_t value) {
  
  _impl_.max_tokens_per_minute_ = value;
}
inline void ModelLimits::set_max_tokens_per_minute(int32_t value) {
  _internal_set_max_tokens_per_minute(value);
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.ModelLimits.max_tokens_per_minute)
}

// -------------------------------------------------------------------

// CompletionChunkPayload

// string completion_id = 1;
inline void CompletionChunkPayload::clear_completion_id() {
  _impl_.completion_id_.ClearToEmpty();
}
inline const std::string& CompletionChunkPayload::completion_id() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.CompletionChunkPayload.completion_id)
  return _internal_completion_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CompletionChunkPayload::set_completion_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.completion_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.CompletionChunkPayload.completion_id)
}
inline std::string* CompletionChunkPayload::mutable_completion_id() {
  std::string* _s = _internal_mutable_completion_id();
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.CompletionChunkPayload.completion_id)
  return _s;
}
inline const std::string& CompletionChunkPayload::_internal_completion_id() const {
  return _impl_.completion_id_.Get();
}
inline void CompletionChunkPayload::_internal_set_completion_id(const std::string& value) {
  
  _impl_.completion_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CompletionChunkPayload::_internal_mutable_completion_id() {
  
  return _impl_.completion_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CompletionChunkPayload::release_completion_id() {
  // @@protoc_insertion_point(field_release:unhinged.llm.v1.CompletionChunkPayload.completion_id)
  return _impl_.completion_id_.Release();
}
inline void CompletionChunkPayload::set_allocated_completion_id(std::string* completion_id) {
  if (completion_id != nullptr) {
    
  } else {
    
  }
  _impl_.completion_id_.SetAllocated(completion_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.completion_id_.IsDefault()) {
    _impl_.completion_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.llm.v1.CompletionChunkPayload.completion_id)
}

// int32 choice_index = 2;
inline void CompletionChunkPayload::clear_choice_index() {
  _impl_.choice_index_ = 0;
}
inline int32_t CompletionChunkPayload::_internal_choice_index() const {
  return _impl_.choice_index_;
}
inline int32_t CompletionChunkPayload::choice_index() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.CompletionChunkPayload.choice_index)
  return _internal_choice_index();
}
inline void CompletionChunkPayload::_internal_set_choice_index(int32_t value) {
  
  _impl_.choice_index_ = value;
}
inline void CompletionChunkPayload::set_choice_index(int32_t value) {
  _internal_set_choice_index(value);
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.CompletionChunkPayload.choice_index)
}

// .unhinged.llm.v1.CompletionChunkType type = 3;
inline void CompletionChunkPayload::clear_type() {
  _impl_.type_ = 0;
}
inline ::unhinged::llm::v1::CompletionChunkType CompletionChunkPayload::_internal_type() const {
  return static_cast< ::unhinged::llm::v1::CompletionChunkType >(_impl_.type_);
}
inline ::unhinged::llm::v1::CompletionChunkType CompletionChunkPayload::type() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.CompletionChunkPayload.type)
  return _internal_type();
}
inline void CompletionChunkPayload::_internal_set_type(::unhinged::llm::v1::CompletionChunkType value) {
  
  _impl_.type_ = value;
}
inline void CompletionChunkPayload::set_type(::unhinged::llm::v1::CompletionChunkType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.CompletionChunkPayload.type)
}

// string content = 4;
inline void CompletionChunkPayload::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& CompletionChunkPayload::content() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.CompletionChunkPayload.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CompletionChunkPayload::set_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.CompletionChunkPayload.content)
}
inline std::string* CompletionChunkPayload::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.CompletionChunkPayload.content)
  return _s;
}
inline const std::string& CompletionChunkPayload::_internal_content() const {
  return _impl_.content_.Get();
}
inline void CompletionChunkPayload::_internal_set_content(const std::string& value) {
  
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* CompletionChunkPayload::_internal_mutable_content() {
  
  return _impl_.content_.Mutable(GetArenaForAllocation());
}
inline std::string* CompletionChunkPayload::release_content() {
  // @@protoc_insertion_point(field_release:unhinged.llm.v1.CompletionChunkPayload.content)
  return _impl_.content_.Release();
}
inline void CompletionChunkPayload::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.llm.v1.CompletionChunkPayload.content)
}

// repeated .unhinged.chat.v1.ToolCall tool_calls = 5;
inline int CompletionChunkPayload::_internal_tool_calls_size() const {
  return _impl_.tool_calls_.size();
}
inline int CompletionChunkPayload::tool_calls_size() const {
  return _internal_tool_calls_size();
}
inline ::unhinged::chat::v1::ToolCall* CompletionChunkPayload::mutable_tool_calls(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.CompletionChunkPayload.tool_calls)
  return _impl_.tool_calls_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::chat::v1::ToolCall >*
CompletionChunkPayload::mutable_tool_calls() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.llm.v1.CompletionChunkPayload.tool_calls)
  return &_impl_.tool_calls_;
}
inline const ::unhinged::chat::v1::ToolCall& CompletionChunkPayload::_internal_tool_calls(int index) const {
  return _impl_.tool_calls_.Get(index);
}
inline const ::unhinged::chat::v1::ToolCall& CompletionChunkPayload::tool_calls(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.CompletionChunkPayload.tool_calls)
  return _internal_tool_calls(index);
}
inline ::unhinged::chat::v1::ToolCall* CompletionChunkPayload::_internal_add_tool_calls() {
  return _impl_.tool_calls_.Add();
}
inline ::unhinged::chat::v1::ToolCall* CompletionChunkPayload::add_tool_calls() {
  ::unhinged::chat::v1::ToolCall* _add = _internal_add_tool_calls();
  // @@protoc_insertion_point(field_add:unhinged.llm.v1.CompletionChunkPayload.tool_calls)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::chat::v1::ToolCall >&
CompletionChunkPayload::tool_calls() const {
  // @@protoc_insertion_point(field_list:unhinged.llm.v1.CompletionChunkPayload.tool_calls)
  return _impl_.tool_calls_;
}

// string finish_reason = 6;
inline void CompletionChunkPayload::clear_finish_reason() {
  _impl_.finish_reason_.ClearToEmpty();
}
inline const std::string& CompletionChunkPayload::finish_reason() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.CompletionChunkPayload.finish_reason)
  return _internal_finish_reason();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CompletionChunkPayload::set_finish_reason(ArgT0&& arg0, ArgT... args) {
 
 _impl_.finish_reason_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.CompletionChunkPayload.finish_reason)
}
inline std::string* CompletionChunkPayload::mutable_finish_reason() {
  std::string* _s = _internal_mutable_finish_reason();
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.CompletionChunkPayload.finish_reason)
  return _s;
}
inline const std::string& CompletionChunkPayload::_internal_finish_reason() const {
  return _impl_.finish_reason_.Get();
}
inline void CompletionChunkPayload::_internal_set_finish_reason(const std::string& value) {
  
  _impl_.finish_reason_.Set(value, GetArenaForAllocation());
}
inline std::string* CompletionChunkPayload::_internal_mutable_finish_reason() {
  
  return _impl_.finish_reason_.Mutable(GetArenaForAllocation());
}
inline std::string* CompletionChunkPayload::release_finish_reason() {
  // @@protoc_insertion_point(field_release:unhinged.llm.v1.CompletionChunkPayload.finish_reason)
  return _impl_.finish_reason_.Release();
}
inline void CompletionChunkPayload::set_allocated_finish_reason(std::string* finish_reason) {
  if (finish_reason != nullptr) {
    
  } else {
    
  }
  _impl_.finish_reason_.SetAllocated(finish_reason, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.finish_reason_.IsDefault()) {
    _impl_.finish_reason_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.llm.v1.CompletionChunkPayload.finish_reason)
}

// .unhinged.common.v1.UsageMetrics usage = 7;
inline bool CompletionChunkPayload::_internal_has_usage() const {
  return this != internal_default_instance() && _impl_.usage_ != nullptr;
}
inline bool CompletionChunkPayload::has_usage() const {
  return _internal_has_usage();
}
inline const ::unhinged::common::v1::UsageMetrics& CompletionChunkPayload::_internal_usage() const {
  const ::unhinged::common::v1::UsageMetrics* p = _impl_.usage_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::common::v1::UsageMetrics&>(
      ::unhinged::common::v1::_UsageMetrics_default_instance_);
}
inline const ::unhinged::common::v1::UsageMetrics& CompletionChunkPayload::usage() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.CompletionChunkPayload.usage)
  return _internal_usage();
}
inline void CompletionChunkPayload::unsafe_arena_set_allocated_usage(
    ::unhinged::common::v1::UsageMetrics* usage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.usage_);
  }
  _impl_.usage_ = usage;
  if (usage) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.llm.v1.CompletionChunkPayload.usage)
}
inline ::unhinged::common::v1::UsageMetrics* CompletionChunkPayload::release_usage() {
  
  ::unhinged::common::v1::UsageMetrics* temp = _impl_.usage_;
  _impl_.usage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::common::v1::UsageMetrics* CompletionChunkPayload::unsafe_arena_release_usage() {
  // @@protoc_insertion_point(field_release:unhinged.llm.v1.CompletionChunkPayload.usage)
  
  ::unhinged::common::v1::UsageMetrics* temp = _impl_.usage_;
  _impl_.usage_ = nullptr;
  return temp;
}
inline ::unhinged::common::v1::UsageMetrics* CompletionChunkPayload::_internal_mutable_usage() {
  
  if (_impl_.usage_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::common::v1::UsageMetrics>(GetArenaForAllocation());
    _impl_.usage_ = p;
  }
  return _impl_.usage_;
}
inline ::unhinged::common::v1::UsageMetrics* CompletionChunkPayload::mutable_usage() {
  ::unhinged::common::v1::UsageMetrics* _msg = _internal_mutable_usage();
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.CompletionChunkPayload.usage)
  return _msg;
}
inline void CompletionChunkPayload::set_allocated_usage(::unhinged::common::v1::UsageMetrics* usage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.usage_);
  }
  if (usage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(usage));
    if (message_arena != submessage_arena) {
      usage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, usage, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.usage_ = usage;
  // @@protoc_insertion_point(field_set_allocated:unhinged.llm.v1.CompletionChunkPayload.usage)
}

// -------------------------------------------------------------------

// ListModelsRequest

// string provider = 1;
inline void ListModelsRequest::clear_provider() {
  _impl_.provider_.ClearToEmpty();
}
inline const std::string& ListModelsRequest::provider() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.ListModelsRequest.provider)
  return _internal_provider();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListModelsRequest::set_provider(ArgT0&& arg0, ArgT... args) {
 
 _impl_.provider_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.ListModelsRequest.provider)
}
inline std::string* ListModelsRequest::mutable_provider() {
  std::string* _s = _internal_mutable_provider();
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.ListModelsRequest.provider)
  return _s;
}
inline const std::string& ListModelsRequest::_internal_provider() const {
  return _impl_.provider_.Get();
}
inline void ListModelsRequest::_internal_set_provider(const std::string& value) {
  
  _impl_.provider_.Set(value, GetArenaForAllocation());
}
inline std::string* ListModelsRequest::_internal_mutable_provider() {
  
  return _impl_.provider_.Mutable(GetArenaForAllocation());
}
inline std::string* ListModelsRequest::release_provider() {
  // @@protoc_insertion_point(field_release:unhinged.llm.v1.ListModelsRequest.provider)
  return _impl_.provider_.Release();
}
inline void ListModelsRequest::set_allocated_provider(std::string* provider) {
  if (provider != nullptr) {
    
  } else {
    
  }
  _impl_.provider_.SetAllocated(provider, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.provider_.IsDefault()) {
    _impl_.provider_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.llm.v1.ListModelsRequest.provider)
}

// bool available_only = 2;
inline void ListModelsRequest::clear_available_only() {
  _impl_.available_only_ = false;
}
inline bool ListModelsRequest::_internal_available_only() const {
  return _impl_.available_only_;
}
inline bool ListModelsRequest::available_only() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.ListModelsRequest.available_only)
  return _internal_available_only();
}
inline void ListModelsRequest::_internal_set_available_only(bool value) {
  
  _impl_.available_only_ = value;
}
inline void ListModelsRequest::set_available_only(bool value) {
  _internal_set_available_only(value);
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.ListModelsRequest.available_only)
}

// .unhinged.common.v1.PaginationRequest pagination = 3;
inline bool ListModelsRequest::_internal_has_pagination() const {
  return this != internal_default_instance() && _impl_.pagination_ != nullptr;
}
inline bool ListModelsRequest::has_pagination() const {
  return _internal_has_pagination();
}
inline const ::unhinged::common::v1::PaginationRequest& ListModelsRequest::_internal_pagination() const {
  const ::unhinged::common::v1::PaginationRequest* p = _impl_.pagination_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::common::v1::PaginationRequest&>(
      ::unhinged::common::v1::_PaginationRequest_default_instance_);
}
inline const ::unhinged::common::v1::PaginationRequest& ListModelsRequest::pagination() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.ListModelsRequest.pagination)
  return _internal_pagination();
}
inline void ListModelsRequest::unsafe_arena_set_allocated_pagination(
    ::unhinged::common::v1::PaginationRequest* pagination) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pagination_);
  }
  _impl_.pagination_ = pagination;
  if (pagination) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.llm.v1.ListModelsRequest.pagination)
}
inline ::unhinged::common::v1::PaginationRequest* ListModelsRequest::release_pagination() {
  
  ::unhinged::common::v1::PaginationRequest* temp = _impl_.pagination_;
  _impl_.pagination_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::common::v1::PaginationRequest* ListModelsRequest::unsafe_arena_release_pagination() {
  // @@protoc_insertion_point(field_release:unhinged.llm.v1.ListModelsRequest.pagination)
  
  ::unhinged::common::v1::PaginationRequest* temp = _impl_.pagination_;
  _impl_.pagination_ = nullptr;
  return temp;
}
inline ::unhinged::common::v1::PaginationRequest* ListModelsRequest::_internal_mutable_pagination() {
  
  if (_impl_.pagination_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::common::v1::PaginationRequest>(GetArenaForAllocation());
    _impl_.pagination_ = p;
  }
  return _impl_.pagination_;
}
inline ::unhinged::common::v1::PaginationRequest* ListModelsRequest::mutable_pagination() {
  ::unhinged::common::v1::PaginationRequest* _msg = _internal_mutable_pagination();
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.ListModelsRequest.pagination)
  return _msg;
}
inline void ListModelsRequest::set_allocated_pagination(::unhinged::common::v1::PaginationRequest* pagination) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pagination_);
  }
  if (pagination) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pagination));
    if (message_arena != submessage_arena) {
      pagination = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pagination, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pagination_ = pagination;
  // @@protoc_insertion_point(field_set_allocated:unhinged.llm.v1.ListModelsRequest.pagination)
}

// repeated .unhinged.common.v1.Filter filters = 4;
inline int ListModelsRequest::_internal_filters_size() const {
  return _impl_.filters_.size();
}
inline int ListModelsRequest::filters_size() const {
  return _internal_filters_size();
}
inline ::unhinged::common::v1::Filter* ListModelsRequest::mutable_filters(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.ListModelsRequest.filters)
  return _impl_.filters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::common::v1::Filter >*
ListModelsRequest::mutable_filters() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.llm.v1.ListModelsRequest.filters)
  return &_impl_.filters_;
}
inline const ::unhinged::common::v1::Filter& ListModelsRequest::_internal_filters(int index) const {
  return _impl_.filters_.Get(index);
}
inline const ::unhinged::common::v1::Filter& ListModelsRequest::filters(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.ListModelsRequest.filters)
  return _internal_filters(index);
}
inline ::unhinged::common::v1::Filter* ListModelsRequest::_internal_add_filters() {
  return _impl_.filters_.Add();
}
inline ::unhinged::common::v1::Filter* ListModelsRequest::add_filters() {
  ::unhinged::common::v1::Filter* _add = _internal_add_filters();
  // @@protoc_insertion_point(field_add:unhinged.llm.v1.ListModelsRequest.filters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::common::v1::Filter >&
ListModelsRequest::filters() const {
  // @@protoc_insertion_point(field_list:unhinged.llm.v1.ListModelsRequest.filters)
  return _impl_.filters_;
}

// -------------------------------------------------------------------

// ListModelsResponse

// .unhinged.common.v1.StandardResponse response = 1;
inline bool ListModelsResponse::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool ListModelsResponse::has_response() const {
  return _internal_has_response();
}
inline const ::unhinged::common::v1::StandardResponse& ListModelsResponse::_internal_response() const {
  const ::unhinged::common::v1::StandardResponse* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::common::v1::StandardResponse&>(
      ::unhinged::common::v1::_StandardResponse_default_instance_);
}
inline const ::unhinged::common::v1::StandardResponse& ListModelsResponse::response() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.ListModelsResponse.response)
  return _internal_response();
}
inline void ListModelsResponse::unsafe_arena_set_allocated_response(
    ::unhinged::common::v1::StandardResponse* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.llm.v1.ListModelsResponse.response)
}
inline ::unhinged::common::v1::StandardResponse* ListModelsResponse::release_response() {
  
  ::unhinged::common::v1::StandardResponse* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::common::v1::StandardResponse* ListModelsResponse::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:unhinged.llm.v1.ListModelsResponse.response)
  
  ::unhinged::common::v1::StandardResponse* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::unhinged::common::v1::StandardResponse* ListModelsResponse::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::common::v1::StandardResponse>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::unhinged::common::v1::StandardResponse* ListModelsResponse::mutable_response() {
  ::unhinged::common::v1::StandardResponse* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.ListModelsResponse.response)
  return _msg;
}
inline void ListModelsResponse::set_allocated_response(::unhinged::common::v1::StandardResponse* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:unhinged.llm.v1.ListModelsResponse.response)
}

// repeated .unhinged.llm.v1.Model models = 2;
inline int ListModelsResponse::_internal_models_size() const {
  return _impl_.models_.size();
}
inline int ListModelsResponse::models_size() const {
  return _internal_models_size();
}
inline void ListModelsResponse::clear_models() {
  _impl_.models_.Clear();
}
inline ::unhinged::llm::v1::Model* ListModelsResponse::mutable_models(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.ListModelsResponse.models)
  return _impl_.models_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::llm::v1::Model >*
ListModelsResponse::mutable_models() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.llm.v1.ListModelsResponse.models)
  return &_impl_.models_;
}
inline const ::unhinged::llm::v1::Model& ListModelsResponse::_internal_models(int index) const {
  return _impl_.models_.Get(index);
}
inline const ::unhinged::llm::v1::Model& ListModelsResponse::models(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.ListModelsResponse.models)
  return _internal_models(index);
}
inline ::unhinged::llm::v1::Model* ListModelsResponse::_internal_add_models() {
  return _impl_.models_.Add();
}
inline ::unhinged::llm::v1::Model* ListModelsResponse::add_models() {
  ::unhinged::llm::v1::Model* _add = _internal_add_models();
  // @@protoc_insertion_point(field_add:unhinged.llm.v1.ListModelsResponse.models)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::llm::v1::Model >&
ListModelsResponse::models() const {
  // @@protoc_insertion_point(field_list:unhinged.llm.v1.ListModelsResponse.models)
  return _impl_.models_;
}

// .unhinged.common.v1.PaginationResponse pagination = 3;
inline bool ListModelsResponse::_internal_has_pagination() const {
  return this != internal_default_instance() && _impl_.pagination_ != nullptr;
}
inline bool ListModelsResponse::has_pagination() const {
  return _internal_has_pagination();
}
inline const ::unhinged::common::v1::PaginationResponse& ListModelsResponse::_internal_pagination() const {
  const ::unhinged::common::v1::PaginationResponse* p = _impl_.pagination_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::common::v1::PaginationResponse&>(
      ::unhinged::common::v1::_PaginationResponse_default_instance_);
}
inline const ::unhinged::common::v1::PaginationResponse& ListModelsResponse::pagination() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.ListModelsResponse.pagination)
  return _internal_pagination();
}
inline void ListModelsResponse::unsafe_arena_set_allocated_pagination(
    ::unhinged::common::v1::PaginationResponse* pagination) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pagination_);
  }
  _impl_.pagination_ = pagination;
  if (pagination) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.llm.v1.ListModelsResponse.pagination)
}
inline ::unhinged::common::v1::PaginationResponse* ListModelsResponse::release_pagination() {
  
  ::unhinged::common::v1::PaginationResponse* temp = _impl_.pagination_;
  _impl_.pagination_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::common::v1::PaginationResponse* ListModelsResponse::unsafe_arena_release_pagination() {
  // @@protoc_insertion_point(field_release:unhinged.llm.v1.ListModelsResponse.pagination)
  
  ::unhinged::common::v1::PaginationResponse* temp = _impl_.pagination_;
  _impl_.pagination_ = nullptr;
  return temp;
}
inline ::unhinged::common::v1::PaginationResponse* ListModelsResponse::_internal_mutable_pagination() {
  
  if (_impl_.pagination_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::common::v1::PaginationResponse>(GetArenaForAllocation());
    _impl_.pagination_ = p;
  }
  return _impl_.pagination_;
}
inline ::unhinged::common::v1::PaginationResponse* ListModelsResponse::mutable_pagination() {
  ::unhinged::common::v1::PaginationResponse* _msg = _internal_mutable_pagination();
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.ListModelsResponse.pagination)
  return _msg;
}
inline void ListModelsResponse::set_allocated_pagination(::unhinged::common::v1::PaginationResponse* pagination) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pagination_);
  }
  if (pagination) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pagination));
    if (message_arena != submessage_arena) {
      pagination = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pagination, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pagination_ = pagination;
  // @@protoc_insertion_point(field_set_allocated:unhinged.llm.v1.ListModelsResponse.pagination)
}

// -------------------------------------------------------------------

// GetModelRequest

// string model_id = 1;
inline void GetModelRequest::clear_model_id() {
  _impl_.model_id_.ClearToEmpty();
}
inline const std::string& GetModelRequest::model_id() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.GetModelRequest.model_id)
  return _internal_model_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetModelRequest::set_model_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.GetModelRequest.model_id)
}
inline std::string* GetModelRequest::mutable_model_id() {
  std::string* _s = _internal_mutable_model_id();
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.GetModelRequest.model_id)
  return _s;
}
inline const std::string& GetModelRequest::_internal_model_id() const {
  return _impl_.model_id_.Get();
}
inline void GetModelRequest::_internal_set_model_id(const std::string& value) {
  
  _impl_.model_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetModelRequest::_internal_mutable_model_id() {
  
  return _impl_.model_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetModelRequest::release_model_id() {
  // @@protoc_insertion_point(field_release:unhinged.llm.v1.GetModelRequest.model_id)
  return _impl_.model_id_.Release();
}
inline void GetModelRequest::set_allocated_model_id(std::string* model_id) {
  if (model_id != nullptr) {
    
  } else {
    
  }
  _impl_.model_id_.SetAllocated(model_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_id_.IsDefault()) {
    _impl_.model_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.llm.v1.GetModelRequest.model_id)
}

// bool include_pricing = 2;
inline void GetModelRequest::clear_include_pricing() {
  _impl_.include_pricing_ = false;
}
inline bool GetModelRequest::_internal_include_pricing() const {
  return _impl_.include_pricing_;
}
inline bool GetModelRequest::include_pricing() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.GetModelRequest.include_pricing)
  return _internal_include_pricing();
}
inline void GetModelRequest::_internal_set_include_pricing(bool value) {
  
  _impl_.include_pricing_ = value;
}
inline void GetModelRequest::set_include_pricing(bool value) {
  _internal_set_include_pricing(value);
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.GetModelRequest.include_pricing)
}

// bool include_capabilities = 3;
inline void GetModelRequest::clear_include_capabilities() {
  _impl_.include_capabilities_ = false;
}
inline bool GetModelRequest::_internal_include_capabilities() const {
  return _impl_.include_capabilities_;
}
inline bool GetModelRequest::include_capabilities() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.GetModelRequest.include_capabilities)
  return _internal_include_capabilities();
}
inline void GetModelRequest::_internal_set_include_capabilities(bool value) {
  
  _impl_.include_capabilities_ = value;
}
inline void GetModelRequest::set_include_capabilities(bool value) {
  _internal_set_include_capabilities(value);
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.GetModelRequest.include_capabilities)
}

// -------------------------------------------------------------------

// GetModelResponse

// .unhinged.common.v1.StandardResponse response = 1;
inline bool GetModelResponse::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool GetModelResponse::has_response() const {
  return _internal_has_response();
}
inline const ::unhinged::common::v1::StandardResponse& GetModelResponse::_internal_response() const {
  const ::unhinged::common::v1::StandardResponse* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::common::v1::StandardResponse&>(
      ::unhinged::common::v1::_StandardResponse_default_instance_);
}
inline const ::unhinged::common::v1::StandardResponse& GetModelResponse::response() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.GetModelResponse.response)
  return _internal_response();
}
inline void GetModelResponse::unsafe_arena_set_allocated_response(
    ::unhinged::common::v1::StandardResponse* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.llm.v1.GetModelResponse.response)
}
inline ::unhinged::common::v1::StandardResponse* GetModelResponse::release_response() {
  
  ::unhinged::common::v1::StandardResponse* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::common::v1::StandardResponse* GetModelResponse::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:unhinged.llm.v1.GetModelResponse.response)
  
  ::unhinged::common::v1::StandardResponse* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::unhinged::common::v1::StandardResponse* GetModelResponse::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::common::v1::StandardResponse>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::unhinged::common::v1::StandardResponse* GetModelResponse::mutable_response() {
  ::unhinged::common::v1::StandardResponse* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.GetModelResponse.response)
  return _msg;
}
inline void GetModelResponse::set_allocated_response(::unhinged::common::v1::StandardResponse* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:unhinged.llm.v1.GetModelResponse.response)
}

// .unhinged.llm.v1.Model model = 2;
inline bool GetModelResponse::_internal_has_model() const {
  return this != internal_default_instance() && _impl_.model_ != nullptr;
}
inline bool GetModelResponse::has_model() const {
  return _internal_has_model();
}
inline void GetModelResponse::clear_model() {
  if (GetArenaForAllocation() == nullptr && _impl_.model_ != nullptr) {
    delete _impl_.model_;
  }
  _impl_.model_ = nullptr;
}
inline const ::unhinged::llm::v1::Model& GetModelResponse::_internal_model() const {
  const ::unhinged::llm::v1::Model* p = _impl_.model_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::llm::v1::Model&>(
      ::unhinged::llm::v1::_Model_default_instance_);
}
inline const ::unhinged::llm::v1::Model& GetModelResponse::model() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.GetModelResponse.model)
  return _internal_model();
}
inline void GetModelResponse::unsafe_arena_set_allocated_model(
    ::unhinged::llm::v1::Model* model) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.model_);
  }
  _impl_.model_ = model;
  if (model) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.llm.v1.GetModelResponse.model)
}
inline ::unhinged::llm::v1::Model* GetModelResponse::release_model() {
  
  ::unhinged::llm::v1::Model* temp = _impl_.model_;
  _impl_.model_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::llm::v1::Model* GetModelResponse::unsafe_arena_release_model() {
  // @@protoc_insertion_point(field_release:unhinged.llm.v1.GetModelResponse.model)
  
  ::unhinged::llm::v1::Model* temp = _impl_.model_;
  _impl_.model_ = nullptr;
  return temp;
}
inline ::unhinged::llm::v1::Model* GetModelResponse::_internal_mutable_model() {
  
  if (_impl_.model_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::llm::v1::Model>(GetArenaForAllocation());
    _impl_.model_ = p;
  }
  return _impl_.model_;
}
inline ::unhinged::llm::v1::Model* GetModelResponse::mutable_model() {
  ::unhinged::llm::v1::Model* _msg = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.GetModelResponse.model)
  return _msg;
}
inline void GetModelResponse::set_allocated_model(::unhinged::llm::v1::Model* model) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.model_;
  }
  if (model) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(model);
    if (message_arena != submessage_arena) {
      model = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, model, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.model_ = model;
  // @@protoc_insertion_point(field_set_allocated:unhinged.llm.v1.GetModelResponse.model)
}

// -------------------------------------------------------------------

// TokenEstimationRequest

// string model = 1;
inline void TokenEstimationRequest::clear_model() {
  _impl_.model_.ClearToEmpty();
}
inline const std::string& TokenEstimationRequest::model() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.TokenEstimationRequest.model)
  return _internal_model();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TokenEstimationRequest::set_model(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.TokenEstimationRequest.model)
}
inline std::string* TokenEstimationRequest::mutable_model() {
  std::string* _s = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.TokenEstimationRequest.model)
  return _s;
}
inline const std::string& TokenEstimationRequest::_internal_model() const {
  return _impl_.model_.Get();
}
inline void TokenEstimationRequest::_internal_set_model(const std::string& value) {
  
  _impl_.model_.Set(value, GetArenaForAllocation());
}
inline std::string* TokenEstimationRequest::_internal_mutable_model() {
  
  return _impl_.model_.Mutable(GetArenaForAllocation());
}
inline std::string* TokenEstimationRequest::release_model() {
  // @@protoc_insertion_point(field_release:unhinged.llm.v1.TokenEstimationRequest.model)
  return _impl_.model_.Release();
}
inline void TokenEstimationRequest::set_allocated_model(std::string* model) {
  if (model != nullptr) {
    
  } else {
    
  }
  _impl_.model_.SetAllocated(model, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_.IsDefault()) {
    _impl_.model_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.llm.v1.TokenEstimationRequest.model)
}

// string text = 2;
inline bool TokenEstimationRequest::_internal_has_text() const {
  return input_case() == kText;
}
inline bool TokenEstimationRequest::has_text() const {
  return _internal_has_text();
}
inline void TokenEstimationRequest::set_has_text() {
  _impl_._oneof_case_[0] = kText;
}
inline void TokenEstimationRequest::clear_text() {
  if (_internal_has_text()) {
    _impl_.input_.text_.Destroy();
    clear_has_input();
  }
}
inline const std::string& TokenEstimationRequest::text() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.TokenEstimationRequest.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline void TokenEstimationRequest::set_text(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_text()) {
    clear_input();
    set_has_text();
    _impl_.input_.text_.InitDefault();
  }
  _impl_.input_.text_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.TokenEstimationRequest.text)
}
inline std::string* TokenEstimationRequest::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.TokenEstimationRequest.text)
  return _s;
}
inline const std::string& TokenEstimationRequest::_internal_text() const {
  if (_internal_has_text()) {
    return _impl_.input_.text_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void TokenEstimationRequest::_internal_set_text(const std::string& value) {
  if (!_internal_has_text()) {
    clear_input();
    set_has_text();
    _impl_.input_.text_.InitDefault();
  }
  _impl_.input_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* TokenEstimationRequest::_internal_mutable_text() {
  if (!_internal_has_text()) {
    clear_input();
    set_has_text();
    _impl_.input_.text_.InitDefault();
  }
  return _impl_.input_.text_.Mutable(      GetArenaForAllocation());
}
inline std::string* TokenEstimationRequest::release_text() {
  // @@protoc_insertion_point(field_release:unhinged.llm.v1.TokenEstimationRequest.text)
  if (_internal_has_text()) {
    clear_has_input();
    return _impl_.input_.text_.Release();
  } else {
    return nullptr;
  }
}
inline void TokenEstimationRequest::set_allocated_text(std::string* text) {
  if (has_input()) {
    clear_input();
  }
  if (text != nullptr) {
    set_has_text();
    _impl_.input_.text_.InitAllocated(text, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:unhinged.llm.v1.TokenEstimationRequest.text)
}

// .unhinged.llm.v1.ChatMessageList messages = 3;
inline bool TokenEstimationRequest::_internal_has_messages() const {
  return input_case() == kMessages;
}
inline bool TokenEstimationRequest::has_messages() const {
  return _internal_has_messages();
}
inline void TokenEstimationRequest::set_has_messages() {
  _impl_._oneof_case_[0] = kMessages;
}
inline void TokenEstimationRequest::clear_messages() {
  if (_internal_has_messages()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.input_.messages_;
    }
    clear_has_input();
  }
}
inline ::unhinged::llm::v1::ChatMessageList* TokenEstimationRequest::release_messages() {
  // @@protoc_insertion_point(field_release:unhinged.llm.v1.TokenEstimationRequest.messages)
  if (_internal_has_messages()) {
    clear_has_input();
    ::unhinged::llm::v1::ChatMessageList* temp = _impl_.input_.messages_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.input_.messages_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::llm::v1::ChatMessageList& TokenEstimationRequest::_internal_messages() const {
  return _internal_has_messages()
      ? *_impl_.input_.messages_
      : reinterpret_cast< ::unhinged::llm::v1::ChatMessageList&>(::unhinged::llm::v1::_ChatMessageList_default_instance_);
}
inline const ::unhinged::llm::v1::ChatMessageList& TokenEstimationRequest::messages() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.TokenEstimationRequest.messages)
  return _internal_messages();
}
inline ::unhinged::llm::v1::ChatMessageList* TokenEstimationRequest::unsafe_arena_release_messages() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.llm.v1.TokenEstimationRequest.messages)
  if (_internal_has_messages()) {
    clear_has_input();
    ::unhinged::llm::v1::ChatMessageList* temp = _impl_.input_.messages_;
    _impl_.input_.messages_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TokenEstimationRequest::unsafe_arena_set_allocated_messages(::unhinged::llm::v1::ChatMessageList* messages) {
  clear_input();
  if (messages) {
    set_has_messages();
    _impl_.input_.messages_ = messages;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.llm.v1.TokenEstimationRequest.messages)
}
inline ::unhinged::llm::v1::ChatMessageList* TokenEstimationRequest::_internal_mutable_messages() {
  if (!_internal_has_messages()) {
    clear_input();
    set_has_messages();
    _impl_.input_.messages_ = CreateMaybeMessage< ::unhinged::llm::v1::ChatMessageList >(GetArenaForAllocation());
  }
  return _impl_.input_.messages_;
}
inline ::unhinged::llm::v1::ChatMessageList* TokenEstimationRequest::mutable_messages() {
  ::unhinged::llm::v1::ChatMessageList* _msg = _internal_mutable_messages();
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.TokenEstimationRequest.messages)
  return _msg;
}

// bool include_context = 4;
inline void TokenEstimationRequest::clear_include_context() {
  _impl_.include_context_ = false;
}
inline bool TokenEstimationRequest::_internal_include_context() const {
  return _impl_.include_context_;
}
inline bool TokenEstimationRequest::include_context() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.TokenEstimationRequest.include_context)
  return _internal_include_context();
}
inline void TokenEstimationRequest::_internal_set_include_context(bool value) {
  
  _impl_.include_context_ = value;
}
inline void TokenEstimationRequest::set_include_context(bool value) {
  _internal_set_include_context(value);
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.TokenEstimationRequest.include_context)
}

// string session_id = 5;
inline void TokenEstimationRequest::clear_session_id() {
  _impl_.session_id_.ClearToEmpty();
}
inline const std::string& TokenEstimationRequest::session_id() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.TokenEstimationRequest.session_id)
  return _internal_session_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TokenEstimationRequest::set_session_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.session_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.TokenEstimationRequest.session_id)
}
inline std::string* TokenEstimationRequest::mutable_session_id() {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.TokenEstimationRequest.session_id)
  return _s;
}
inline const std::string& TokenEstimationRequest::_internal_session_id() const {
  return _impl_.session_id_.Get();
}
inline void TokenEstimationRequest::_internal_set_session_id(const std::string& value) {
  
  _impl_.session_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TokenEstimationRequest::_internal_mutable_session_id() {
  
  return _impl_.session_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TokenEstimationRequest::release_session_id() {
  // @@protoc_insertion_point(field_release:unhinged.llm.v1.TokenEstimationRequest.session_id)
  return _impl_.session_id_.Release();
}
inline void TokenEstimationRequest::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  _impl_.session_id_.SetAllocated(session_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.session_id_.IsDefault()) {
    _impl_.session_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.llm.v1.TokenEstimationRequest.session_id)
}

inline bool TokenEstimationRequest::has_input() const {
  return input_case() != INPUT_NOT_SET;
}
inline void TokenEstimationRequest::clear_has_input() {
  _impl_._oneof_case_[0] = INPUT_NOT_SET;
}
inline TokenEstimationRequest::InputCase TokenEstimationRequest::input_case() const {
  return TokenEstimationRequest::InputCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ChatMessageList

// repeated .unhinged.chat.v1.ChatMessage messages = 1;
inline int ChatMessageList::_internal_messages_size() const {
  return _impl_.messages_.size();
}
inline int ChatMessageList::messages_size() const {
  return _internal_messages_size();
}
inline ::unhinged::chat::v1::ChatMessage* ChatMessageList::mutable_messages(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.ChatMessageList.messages)
  return _impl_.messages_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::chat::v1::ChatMessage >*
ChatMessageList::mutable_messages() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.llm.v1.ChatMessageList.messages)
  return &_impl_.messages_;
}
inline const ::unhinged::chat::v1::ChatMessage& ChatMessageList::_internal_messages(int index) const {
  return _impl_.messages_.Get(index);
}
inline const ::unhinged::chat::v1::ChatMessage& ChatMessageList::messages(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.ChatMessageList.messages)
  return _internal_messages(index);
}
inline ::unhinged::chat::v1::ChatMessage* ChatMessageList::_internal_add_messages() {
  return _impl_.messages_.Add();
}
inline ::unhinged::chat::v1::ChatMessage* ChatMessageList::add_messages() {
  ::unhinged::chat::v1::ChatMessage* _add = _internal_add_messages();
  // @@protoc_insertion_point(field_add:unhinged.llm.v1.ChatMessageList.messages)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::chat::v1::ChatMessage >&
ChatMessageList::messages() const {
  // @@protoc_insertion_point(field_list:unhinged.llm.v1.ChatMessageList.messages)
  return _impl_.messages_;
}

// -------------------------------------------------------------------

// TokenEstimationResponse

// .unhinged.common.v1.StandardResponse response = 1;
inline bool TokenEstimationResponse::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool TokenEstimationResponse::has_response() const {
  return _internal_has_response();
}
inline const ::unhinged::common::v1::StandardResponse& TokenEstimationResponse::_internal_response() const {
  const ::unhinged::common::v1::StandardResponse* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::common::v1::StandardResponse&>(
      ::unhinged::common::v1::_StandardResponse_default_instance_);
}
inline const ::unhinged::common::v1::StandardResponse& TokenEstimationResponse::response() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.TokenEstimationResponse.response)
  return _internal_response();
}
inline void TokenEstimationResponse::unsafe_arena_set_allocated_response(
    ::unhinged::common::v1::StandardResponse* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.llm.v1.TokenEstimationResponse.response)
}
inline ::unhinged::common::v1::StandardResponse* TokenEstimationResponse::release_response() {
  
  ::unhinged::common::v1::StandardResponse* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::common::v1::StandardResponse* TokenEstimationResponse::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:unhinged.llm.v1.TokenEstimationResponse.response)
  
  ::unhinged::common::v1::StandardResponse* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::unhinged::common::v1::StandardResponse* TokenEstimationResponse::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::common::v1::StandardResponse>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::unhinged::common::v1::StandardResponse* TokenEstimationResponse::mutable_response() {
  ::unhinged::common::v1::StandardResponse* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.TokenEstimationResponse.response)
  return _msg;
}
inline void TokenEstimationResponse::set_allocated_response(::unhinged::common::v1::StandardResponse* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:unhinged.llm.v1.TokenEstimationResponse.response)
}

// .unhinged.common.v1.TokenUsage usage = 2;
inline bool TokenEstimationResponse::_internal_has_usage() const {
  return this != internal_default_instance() && _impl_.usage_ != nullptr;
}
inline bool TokenEstimationResponse::has_usage() const {
  return _internal_has_usage();
}
inline const ::unhinged::common::v1::TokenUsage& TokenEstimationResponse::_internal_usage() const {
  const ::unhinged::common::v1::TokenUsage* p = _impl_.usage_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::common::v1::TokenUsage&>(
      ::unhinged::common::v1::_TokenUsage_default_instance_);
}
inline const ::unhinged::common::v1::TokenUsage& TokenEstimationResponse::usage() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.TokenEstimationResponse.usage)
  return _internal_usage();
}
inline void TokenEstimationResponse::unsafe_arena_set_allocated_usage(
    ::unhinged::common::v1::TokenUsage* usage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.usage_);
  }
  _impl_.usage_ = usage;
  if (usage) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.llm.v1.TokenEstimationResponse.usage)
}
inline ::unhinged::common::v1::TokenUsage* TokenEstimationResponse::release_usage() {
  
  ::unhinged::common::v1::TokenUsage* temp = _impl_.usage_;
  _impl_.usage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::common::v1::TokenUsage* TokenEstimationResponse::unsafe_arena_release_usage() {
  // @@protoc_insertion_point(field_release:unhinged.llm.v1.TokenEstimationResponse.usage)
  
  ::unhinged::common::v1::TokenUsage* temp = _impl_.usage_;
  _impl_.usage_ = nullptr;
  return temp;
}
inline ::unhinged::common::v1::TokenUsage* TokenEstimationResponse::_internal_mutable_usage() {
  
  if (_impl_.usage_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::common::v1::TokenUsage>(GetArenaForAllocation());
    _impl_.usage_ = p;
  }
  return _impl_.usage_;
}
inline ::unhinged::common::v1::TokenUsage* TokenEstimationResponse::mutable_usage() {
  ::unhinged::common::v1::TokenUsage* _msg = _internal_mutable_usage();
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.TokenEstimationResponse.usage)
  return _msg;
}
inline void TokenEstimationResponse::set_allocated_usage(::unhinged::common::v1::TokenUsage* usage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.usage_);
  }
  if (usage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(usage));
    if (message_arena != submessage_arena) {
      usage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, usage, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.usage_ = usage;
  // @@protoc_insertion_point(field_set_allocated:unhinged.llm.v1.TokenEstimationResponse.usage)
}

// .unhinged.llm.v1.TokenBreakdown breakdown = 3;
inline bool TokenEstimationResponse::_internal_has_breakdown() const {
  return this != internal_default_instance() && _impl_.breakdown_ != nullptr;
}
inline bool TokenEstimationResponse::has_breakdown() const {
  return _internal_has_breakdown();
}
inline void TokenEstimationResponse::clear_breakdown() {
  if (GetArenaForAllocation() == nullptr && _impl_.breakdown_ != nullptr) {
    delete _impl_.breakdown_;
  }
  _impl_.breakdown_ = nullptr;
}
inline const ::unhinged::llm::v1::TokenBreakdown& TokenEstimationResponse::_internal_breakdown() const {
  const ::unhinged::llm::v1::TokenBreakdown* p = _impl_.breakdown_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::llm::v1::TokenBreakdown&>(
      ::unhinged::llm::v1::_TokenBreakdown_default_instance_);
}
inline const ::unhinged::llm::v1::TokenBreakdown& TokenEstimationResponse::breakdown() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.TokenEstimationResponse.breakdown)
  return _internal_breakdown();
}
inline void TokenEstimationResponse::unsafe_arena_set_allocated_breakdown(
    ::unhinged::llm::v1::TokenBreakdown* breakdown) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.breakdown_);
  }
  _impl_.breakdown_ = breakdown;
  if (breakdown) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.llm.v1.TokenEstimationResponse.breakdown)
}
inline ::unhinged::llm::v1::TokenBreakdown* TokenEstimationResponse::release_breakdown() {
  
  ::unhinged::llm::v1::TokenBreakdown* temp = _impl_.breakdown_;
  _impl_.breakdown_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::llm::v1::TokenBreakdown* TokenEstimationResponse::unsafe_arena_release_breakdown() {
  // @@protoc_insertion_point(field_release:unhinged.llm.v1.TokenEstimationResponse.breakdown)
  
  ::unhinged::llm::v1::TokenBreakdown* temp = _impl_.breakdown_;
  _impl_.breakdown_ = nullptr;
  return temp;
}
inline ::unhinged::llm::v1::TokenBreakdown* TokenEstimationResponse::_internal_mutable_breakdown() {
  
  if (_impl_.breakdown_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::llm::v1::TokenBreakdown>(GetArenaForAllocation());
    _impl_.breakdown_ = p;
  }
  return _impl_.breakdown_;
}
inline ::unhinged::llm::v1::TokenBreakdown* TokenEstimationResponse::mutable_breakdown() {
  ::unhinged::llm::v1::TokenBreakdown* _msg = _internal_mutable_breakdown();
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.TokenEstimationResponse.breakdown)
  return _msg;
}
inline void TokenEstimationResponse::set_allocated_breakdown(::unhinged::llm::v1::TokenBreakdown* breakdown) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.breakdown_;
  }
  if (breakdown) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(breakdown);
    if (message_arena != submessage_arena) {
      breakdown = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, breakdown, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.breakdown_ = breakdown;
  // @@protoc_insertion_point(field_set_allocated:unhinged.llm.v1.TokenEstimationResponse.breakdown)
}

// -------------------------------------------------------------------

// TokenBreakdown

// int32 system_tokens = 1;
inline void TokenBreakdown::clear_system_tokens() {
  _impl_.system_tokens_ = 0;
}
inline int32_t TokenBreakdown::_internal_system_tokens() const {
  return _impl_.system_tokens_;
}
inline int32_t TokenBreakdown::system_tokens() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.TokenBreakdown.system_tokens)
  return _internal_system_tokens();
}
inline void TokenBreakdown::_internal_set_system_tokens(int32_t value) {
  
  _impl_.system_tokens_ = value;
}
inline void TokenBreakdown::set_system_tokens(int32_t value) {
  _internal_set_system_tokens(value);
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.TokenBreakdown.system_tokens)
}

// int32 user_tokens = 2;
inline void TokenBreakdown::clear_user_tokens() {
  _impl_.user_tokens_ = 0;
}
inline int32_t TokenBreakdown::_internal_user_tokens() const {
  return _impl_.user_tokens_;
}
inline int32_t TokenBreakdown::user_tokens() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.TokenBreakdown.user_tokens)
  return _internal_user_tokens();
}
inline void TokenBreakdown::_internal_set_user_tokens(int32_t value) {
  
  _impl_.user_tokens_ = value;
}
inline void TokenBreakdown::set_user_tokens(int32_t value) {
  _internal_set_user_tokens(value);
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.TokenBreakdown.user_tokens)
}

// int32 assistant_tokens = 3;
inline void TokenBreakdown::clear_assistant_tokens() {
  _impl_.assistant_tokens_ = 0;
}
inline int32_t TokenBreakdown::_internal_assistant_tokens() const {
  return _impl_.assistant_tokens_;
}
inline int32_t TokenBreakdown::assistant_tokens() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.TokenBreakdown.assistant_tokens)
  return _internal_assistant_tokens();
}
inline void TokenBreakdown::_internal_set_assistant_tokens(int32_t value) {
  
  _impl_.assistant_tokens_ = value;
}
inline void TokenBreakdown::set_assistant_tokens(int32_t value) {
  _internal_set_assistant_tokens(value);
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.TokenBreakdown.assistant_tokens)
}

// int32 context_tokens = 4;
inline void TokenBreakdown::clear_context_tokens() {
  _impl_.context_tokens_ = 0;
}
inline int32_t TokenBreakdown::_internal_context_tokens() const {
  return _impl_.context_tokens_;
}
inline int32_t TokenBreakdown::context_tokens() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.TokenBreakdown.context_tokens)
  return _internal_context_tokens();
}
inline void TokenBreakdown::_internal_set_context_tokens(int32_t value) {
  
  _impl_.context_tokens_ = value;
}
inline void TokenBreakdown::set_context_tokens(int32_t value) {
  _internal_set_context_tokens(value);
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.TokenBreakdown.context_tokens)
}

// int32 tool_tokens = 5;
inline void TokenBreakdown::clear_tool_tokens() {
  _impl_.tool_tokens_ = 0;
}
inline int32_t TokenBreakdown::_internal_tool_tokens() const {
  return _impl_.tool_tokens_;
}
inline int32_t TokenBreakdown::tool_tokens() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.TokenBreakdown.tool_tokens)
  return _internal_tool_tokens();
}
inline void TokenBreakdown::_internal_set_tool_tokens(int32_t value) {
  
  _impl_.tool_tokens_ = value;
}
inline void TokenBreakdown::set_tool_tokens(int32_t value) {
  _internal_set_tool_tokens(value);
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.TokenBreakdown.tool_tokens)
}

// repeated .unhinged.llm.v1.DocumentTokens context_documents = 6;
inline int TokenBreakdown::_internal_context_documents_size() const {
  return _impl_.context_documents_.size();
}
inline int TokenBreakdown::context_documents_size() const {
  return _internal_context_documents_size();
}
inline void TokenBreakdown::clear_context_documents() {
  _impl_.context_documents_.Clear();
}
inline ::unhinged::llm::v1::DocumentTokens* TokenBreakdown::mutable_context_documents(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.TokenBreakdown.context_documents)
  return _impl_.context_documents_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::llm::v1::DocumentTokens >*
TokenBreakdown::mutable_context_documents() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.llm.v1.TokenBreakdown.context_documents)
  return &_impl_.context_documents_;
}
inline const ::unhinged::llm::v1::DocumentTokens& TokenBreakdown::_internal_context_documents(int index) const {
  return _impl_.context_documents_.Get(index);
}
inline const ::unhinged::llm::v1::DocumentTokens& TokenBreakdown::context_documents(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.TokenBreakdown.context_documents)
  return _internal_context_documents(index);
}
inline ::unhinged::llm::v1::DocumentTokens* TokenBreakdown::_internal_add_context_documents() {
  return _impl_.context_documents_.Add();
}
inline ::unhinged::llm::v1::DocumentTokens* TokenBreakdown::add_context_documents() {
  ::unhinged::llm::v1::DocumentTokens* _add = _internal_add_context_documents();
  // @@protoc_insertion_point(field_add:unhinged.llm.v1.TokenBreakdown.context_documents)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::llm::v1::DocumentTokens >&
TokenBreakdown::context_documents() const {
  // @@protoc_insertion_point(field_list:unhinged.llm.v1.TokenBreakdown.context_documents)
  return _impl_.context_documents_;
}

// -------------------------------------------------------------------

// DocumentTokens

// string document_id = 1;
inline void DocumentTokens::clear_document_id() {
  _impl_.document_id_.ClearToEmpty();
}
inline const std::string& DocumentTokens::document_id() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.DocumentTokens.document_id)
  return _internal_document_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DocumentTokens::set_document_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.document_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.DocumentTokens.document_id)
}
inline std::string* DocumentTokens::mutable_document_id() {
  std::string* _s = _internal_mutable_document_id();
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.DocumentTokens.document_id)
  return _s;
}
inline const std::string& DocumentTokens::_internal_document_id() const {
  return _impl_.document_id_.Get();
}
inline void DocumentTokens::_internal_set_document_id(const std::string& value) {
  
  _impl_.document_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DocumentTokens::_internal_mutable_document_id() {
  
  return _impl_.document_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DocumentTokens::release_document_id() {
  // @@protoc_insertion_point(field_release:unhinged.llm.v1.DocumentTokens.document_id)
  return _impl_.document_id_.Release();
}
inline void DocumentTokens::set_allocated_document_id(std::string* document_id) {
  if (document_id != nullptr) {
    
  } else {
    
  }
  _impl_.document_id_.SetAllocated(document_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.document_id_.IsDefault()) {
    _impl_.document_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.llm.v1.DocumentTokens.document_id)
}

// string document_type = 2;
inline void DocumentTokens::clear_document_type() {
  _impl_.document_type_.ClearToEmpty();
}
inline const std::string& DocumentTokens::document_type() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.DocumentTokens.document_type)
  return _internal_document_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DocumentTokens::set_document_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.document_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.DocumentTokens.document_type)
}
inline std::string* DocumentTokens::mutable_document_type() {
  std::string* _s = _internal_mutable_document_type();
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.DocumentTokens.document_type)
  return _s;
}
inline const std::string& DocumentTokens::_internal_document_type() const {
  return _impl_.document_type_.Get();
}
inline void DocumentTokens::_internal_set_document_type(const std::string& value) {
  
  _impl_.document_type_.Set(value, GetArenaForAllocation());
}
inline std::string* DocumentTokens::_internal_mutable_document_type() {
  
  return _impl_.document_type_.Mutable(GetArenaForAllocation());
}
inline std::string* DocumentTokens::release_document_type() {
  // @@protoc_insertion_point(field_release:unhinged.llm.v1.DocumentTokens.document_type)
  return _impl_.document_type_.Release();
}
inline void DocumentTokens::set_allocated_document_type(std::string* document_type) {
  if (document_type != nullptr) {
    
  } else {
    
  }
  _impl_.document_type_.SetAllocated(document_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.document_type_.IsDefault()) {
    _impl_.document_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.llm.v1.DocumentTokens.document_type)
}

// int32 token_count = 3;
inline void DocumentTokens::clear_token_count() {
  _impl_.token_count_ = 0;
}
inline int32_t DocumentTokens::_internal_token_count() const {
  return _impl_.token_count_;
}
inline int32_t DocumentTokens::token_count() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.DocumentTokens.token_count)
  return _internal_token_count();
}
inline void DocumentTokens::_internal_set_token_count(int32_t value) {
  
  _impl_.token_count_ = value;
}
inline void DocumentTokens::set_token_count(int32_t value) {
  _internal_set_token_count(value);
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.DocumentTokens.token_count)
}

// float relevance_score = 4;
inline void DocumentTokens::clear_relevance_score() {
  _impl_.relevance_score_ = 0;
}
inline float DocumentTokens::_internal_relevance_score() const {
  return _impl_.relevance_score_;
}
inline float DocumentTokens::relevance_score() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.DocumentTokens.relevance_score)
  return _internal_relevance_score();
}
inline void DocumentTokens::_internal_set_relevance_score(float value) {
  
  _impl_.relevance_score_ = value;
}
inline void DocumentTokens::set_relevance_score(float value) {
  _internal_set_relevance_score(value);
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.DocumentTokens.relevance_score)
}

// -------------------------------------------------------------------

// TokenCountRequest

// string model = 1;
inline void TokenCountRequest::clear_model() {
  _impl_.model_.ClearToEmpty();
}
inline const std::string& TokenCountRequest::model() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.TokenCountRequest.model)
  return _internal_model();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TokenCountRequest::set_model(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.TokenCountRequest.model)
}
inline std::string* TokenCountRequest::mutable_model() {
  std::string* _s = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.TokenCountRequest.model)
  return _s;
}
inline const std::string& TokenCountRequest::_internal_model() const {
  return _impl_.model_.Get();
}
inline void TokenCountRequest::_internal_set_model(const std::string& value) {
  
  _impl_.model_.Set(value, GetArenaForAllocation());
}
inline std::string* TokenCountRequest::_internal_mutable_model() {
  
  return _impl_.model_.Mutable(GetArenaForAllocation());
}
inline std::string* TokenCountRequest::release_model() {
  // @@protoc_insertion_point(field_release:unhinged.llm.v1.TokenCountRequest.model)
  return _impl_.model_.Release();
}
inline void TokenCountRequest::set_allocated_model(std::string* model) {
  if (model != nullptr) {
    
  } else {
    
  }
  _impl_.model_.SetAllocated(model, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_.IsDefault()) {
    _impl_.model_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.llm.v1.TokenCountRequest.model)
}

// string text = 2;
inline void TokenCountRequest::clear_text() {
  _impl_.text_.ClearToEmpty();
}
inline const std::string& TokenCountRequest::text() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.TokenCountRequest.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TokenCountRequest::set_text(ArgT0&& arg0, ArgT... args) {
 
 _impl_.text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.TokenCountRequest.text)
}
inline std::string* TokenCountRequest::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.TokenCountRequest.text)
  return _s;
}
inline const std::string& TokenCountRequest::_internal_text() const {
  return _impl_.text_.Get();
}
inline void TokenCountRequest::_internal_set_text(const std::string& value) {
  
  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* TokenCountRequest::_internal_mutable_text() {
  
  return _impl_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* TokenCountRequest::release_text() {
  // @@protoc_insertion_point(field_release:unhinged.llm.v1.TokenCountRequest.text)
  return _impl_.text_.Release();
}
inline void TokenCountRequest::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  _impl_.text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.llm.v1.TokenCountRequest.text)
}

// -------------------------------------------------------------------

// TokenCountResponse

// .unhinged.common.v1.StandardResponse response = 1;
inline bool TokenCountResponse::_internal_has_response() const {
  return this != internal_default_instance() && _impl_.response_ != nullptr;
}
inline bool TokenCountResponse::has_response() const {
  return _internal_has_response();
}
inline const ::unhinged::common::v1::StandardResponse& TokenCountResponse::_internal_response() const {
  const ::unhinged::common::v1::StandardResponse* p = _impl_.response_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::common::v1::StandardResponse&>(
      ::unhinged::common::v1::_StandardResponse_default_instance_);
}
inline const ::unhinged::common::v1::StandardResponse& TokenCountResponse::response() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.TokenCountResponse.response)
  return _internal_response();
}
inline void TokenCountResponse::unsafe_arena_set_allocated_response(
    ::unhinged::common::v1::StandardResponse* response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  _impl_.response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.llm.v1.TokenCountResponse.response)
}
inline ::unhinged::common::v1::StandardResponse* TokenCountResponse::release_response() {
  
  ::unhinged::common::v1::StandardResponse* temp = _impl_.response_;
  _impl_.response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::common::v1::StandardResponse* TokenCountResponse::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:unhinged.llm.v1.TokenCountResponse.response)
  
  ::unhinged::common::v1::StandardResponse* temp = _impl_.response_;
  _impl_.response_ = nullptr;
  return temp;
}
inline ::unhinged::common::v1::StandardResponse* TokenCountResponse::_internal_mutable_response() {
  
  if (_impl_.response_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::common::v1::StandardResponse>(GetArenaForAllocation());
    _impl_.response_ = p;
  }
  return _impl_.response_;
}
inline ::unhinged::common::v1::StandardResponse* TokenCountResponse::mutable_response() {
  ::unhinged::common::v1::StandardResponse* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.TokenCountResponse.response)
  return _msg;
}
inline void TokenCountResponse::set_allocated_response(::unhinged::common::v1::StandardResponse* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_);
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response));
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_ = response;
  // @@protoc_insertion_point(field_set_allocated:unhinged.llm.v1.TokenCountResponse.response)
}

// int32 token_count = 2;
inline void TokenCountResponse::clear_token_count() {
  _impl_.token_count_ = 0;
}
inline int32_t TokenCountResponse::_internal_token_count() const {
  return _impl_.token_count_;
}
inline int32_t TokenCountResponse::token_count() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.TokenCountResponse.token_count)
  return _internal_token_count();
}
inline void TokenCountResponse::_internal_set_token_count(int32_t value) {
  
  _impl_.token_count_ = value;
}
inline void TokenCountResponse::set_token_count(int32_t value) {
  _internal_set_token_count(value);
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.TokenCountResponse.token_count)
}

// repeated .unhinged.llm.v1.TokenInfo tokens = 3;
inline int TokenCountResponse::_internal_tokens_size() const {
  return _impl_.tokens_.size();
}
inline int TokenCountResponse::tokens_size() const {
  return _internal_tokens_size();
}
inline void TokenCountResponse::clear_tokens() {
  _impl_.tokens_.Clear();
}
inline ::unhinged::llm::v1::TokenInfo* TokenCountResponse::mutable_tokens(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.TokenCountResponse.tokens)
  return _impl_.tokens_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::llm::v1::TokenInfo >*
TokenCountResponse::mutable_tokens() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.llm.v1.TokenCountResponse.tokens)
  return &_impl_.tokens_;
}
inline const ::unhinged::llm::v1::TokenInfo& TokenCountResponse::_internal_tokens(int index) const {
  return _impl_.tokens_.Get(index);
}
inline const ::unhinged::llm::v1::TokenInfo& TokenCountResponse::tokens(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.TokenCountResponse.tokens)
  return _internal_tokens(index);
}
inline ::unhinged::llm::v1::TokenInfo* TokenCountResponse::_internal_add_tokens() {
  return _impl_.tokens_.Add();
}
inline ::unhinged::llm::v1::TokenInfo* TokenCountResponse::add_tokens() {
  ::unhinged::llm::v1::TokenInfo* _add = _internal_add_tokens();
  // @@protoc_insertion_point(field_add:unhinged.llm.v1.TokenCountResponse.tokens)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::llm::v1::TokenInfo >&
TokenCountResponse::tokens() const {
  // @@protoc_insertion_point(field_list:unhinged.llm.v1.TokenCountResponse.tokens)
  return _impl_.tokens_;
}

// -------------------------------------------------------------------

// TokenInfo

// string token = 1;
inline void TokenInfo::clear_token() {
  _impl_.token_.ClearToEmpty();
}
inline const std::string& TokenInfo::token() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.TokenInfo.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TokenInfo::set_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.TokenInfo.token)
}
inline std::string* TokenInfo::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:unhinged.llm.v1.TokenInfo.token)
  return _s;
}
inline const std::string& TokenInfo::_internal_token() const {
  return _impl_.token_.Get();
}
inline void TokenInfo::_internal_set_token(const std::string& value) {
  
  _impl_.token_.Set(value, GetArenaForAllocation());
}
inline std::string* TokenInfo::_internal_mutable_token() {
  
  return _impl_.token_.Mutable(GetArenaForAllocation());
}
inline std::string* TokenInfo::release_token() {
  // @@protoc_insertion_point(field_release:unhinged.llm.v1.TokenInfo.token)
  return _impl_.token_.Release();
}
inline void TokenInfo::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  _impl_.token_.SetAllocated(token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.llm.v1.TokenInfo.token)
}

// int32 token_id = 2;
inline void TokenInfo::clear_token_id() {
  _impl_.token_id_ = 0;
}
inline int32_t TokenInfo::_internal_token_id() const {
  return _impl_.token_id_;
}
inline int32_t TokenInfo::token_id() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.TokenInfo.token_id)
  return _internal_token_id();
}
inline void TokenInfo::_internal_set_token_id(int32_t value) {
  
  _impl_.token_id_ = value;
}
inline void TokenInfo::set_token_id(int32_t value) {
  _internal_set_token_id(value);
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.TokenInfo.token_id)
}

// float probability = 3;
inline void TokenInfo::clear_probability() {
  _impl_.probability_ = 0;
}
inline float TokenInfo::_internal_probability() const {
  return _impl_.probability_;
}
inline float TokenInfo::probability() const {
  // @@protoc_insertion_point(field_get:unhinged.llm.v1.TokenInfo.probability)
  return _internal_probability();
}
inline void TokenInfo::_internal_set_probability(float value) {
  
  _impl_.probability_ = value;
}
inline void TokenInfo::set_probability(float value) {
  _internal_set_probability(value);
  // @@protoc_insertion_point(field_set:unhinged.llm.v1.TokenInfo.probability)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace llm
}  // namespace unhinged

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::unhinged::llm::v1::CompletionChunkType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::unhinged::llm::v1::CompletionChunkType>() {
  return ::unhinged::llm::v1::CompletionChunkType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_llm_2eproto
