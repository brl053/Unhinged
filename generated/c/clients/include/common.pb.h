// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: common.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_common_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_common_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
#include <google/protobuf/struct.pb.h>
#include <google/protobuf/duration.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_common_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_common_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_common_2eproto;
namespace unhinged {
namespace common {
namespace v1 {
class Attachment;
struct AttachmentDefaultTypeInternal;
extern AttachmentDefaultTypeInternal _Attachment_default_instance_;
class AudioUsage;
struct AudioUsageDefaultTypeInternal;
extern AudioUsageDefaultTypeInternal _AudioUsage_default_instance_;
class AuditInfo;
struct AuditInfoDefaultTypeInternal;
extern AuditInfoDefaultTypeInternal _AuditInfo_default_instance_;
class ComputeUsage;
struct ComputeUsageDefaultTypeInternal;
extern ComputeUsageDefaultTypeInternal _ComputeUsage_default_instance_;
class DataUsage;
struct DataUsageDefaultTypeInternal;
extern DataUsageDefaultTypeInternal _DataUsage_default_instance_;
class Error;
struct ErrorDefaultTypeInternal;
extern ErrorDefaultTypeInternal _Error_default_instance_;
class ErrorField;
struct ErrorFieldDefaultTypeInternal;
extern ErrorFieldDefaultTypeInternal _ErrorField_default_instance_;
class Filter;
struct FilterDefaultTypeInternal;
extern FilterDefaultTypeInternal _Filter_default_instance_;
class HealthCheckRequest;
struct HealthCheckRequestDefaultTypeInternal;
extern HealthCheckRequestDefaultTypeInternal _HealthCheckRequest_default_instance_;
class HealthCheckResponse;
struct HealthCheckResponseDefaultTypeInternal;
extern HealthCheckResponseDefaultTypeInternal _HealthCheckResponse_default_instance_;
class HealthCheckResponse_DetailsEntry_DoNotUse;
struct HealthCheckResponse_DetailsEntry_DoNotUseDefaultTypeInternal;
extern HealthCheckResponse_DetailsEntry_DoNotUseDefaultTypeInternal _HealthCheckResponse_DetailsEntry_DoNotUse_default_instance_;
class PaginationRequest;
struct PaginationRequestDefaultTypeInternal;
extern PaginationRequestDefaultTypeInternal _PaginationRequest_default_instance_;
class PaginationResponse;
struct PaginationResponseDefaultTypeInternal;
extern PaginationResponseDefaultTypeInternal _PaginationResponse_default_instance_;
class ResourceMetadata;
struct ResourceMetadataDefaultTypeInternal;
extern ResourceMetadataDefaultTypeInternal _ResourceMetadata_default_instance_;
class ResourceReference;
struct ResourceReferenceDefaultTypeInternal;
extern ResourceReferenceDefaultTypeInternal _ResourceReference_default_instance_;
class StandardResponse;
struct StandardResponseDefaultTypeInternal;
extern StandardResponseDefaultTypeInternal _StandardResponse_default_instance_;
class StreamChunk;
struct StreamChunkDefaultTypeInternal;
extern StreamChunkDefaultTypeInternal _StreamChunk_default_instance_;
class TokenUsage;
struct TokenUsageDefaultTypeInternal;
extern TokenUsageDefaultTypeInternal _TokenUsage_default_instance_;
class UsageMetrics;
struct UsageMetricsDefaultTypeInternal;
extern UsageMetricsDefaultTypeInternal _UsageMetrics_default_instance_;
}  // namespace v1
}  // namespace common
}  // namespace unhinged
PROTOBUF_NAMESPACE_OPEN
template<> ::unhinged::common::v1::Attachment* Arena::CreateMaybeMessage<::unhinged::common::v1::Attachment>(Arena*);
template<> ::unhinged::common::v1::AudioUsage* Arena::CreateMaybeMessage<::unhinged::common::v1::AudioUsage>(Arena*);
template<> ::unhinged::common::v1::AuditInfo* Arena::CreateMaybeMessage<::unhinged::common::v1::AuditInfo>(Arena*);
template<> ::unhinged::common::v1::ComputeUsage* Arena::CreateMaybeMessage<::unhinged::common::v1::ComputeUsage>(Arena*);
template<> ::unhinged::common::v1::DataUsage* Arena::CreateMaybeMessage<::unhinged::common::v1::DataUsage>(Arena*);
template<> ::unhinged::common::v1::Error* Arena::CreateMaybeMessage<::unhinged::common::v1::Error>(Arena*);
template<> ::unhinged::common::v1::ErrorField* Arena::CreateMaybeMessage<::unhinged::common::v1::ErrorField>(Arena*);
template<> ::unhinged::common::v1::Filter* Arena::CreateMaybeMessage<::unhinged::common::v1::Filter>(Arena*);
template<> ::unhinged::common::v1::HealthCheckRequest* Arena::CreateMaybeMessage<::unhinged::common::v1::HealthCheckRequest>(Arena*);
template<> ::unhinged::common::v1::HealthCheckResponse* Arena::CreateMaybeMessage<::unhinged::common::v1::HealthCheckResponse>(Arena*);
template<> ::unhinged::common::v1::HealthCheckResponse_DetailsEntry_DoNotUse* Arena::CreateMaybeMessage<::unhinged::common::v1::HealthCheckResponse_DetailsEntry_DoNotUse>(Arena*);
template<> ::unhinged::common::v1::PaginationRequest* Arena::CreateMaybeMessage<::unhinged::common::v1::PaginationRequest>(Arena*);
template<> ::unhinged::common::v1::PaginationResponse* Arena::CreateMaybeMessage<::unhinged::common::v1::PaginationResponse>(Arena*);
template<> ::unhinged::common::v1::ResourceMetadata* Arena::CreateMaybeMessage<::unhinged::common::v1::ResourceMetadata>(Arena*);
template<> ::unhinged::common::v1::ResourceReference* Arena::CreateMaybeMessage<::unhinged::common::v1::ResourceReference>(Arena*);
template<> ::unhinged::common::v1::StandardResponse* Arena::CreateMaybeMessage<::unhinged::common::v1::StandardResponse>(Arena*);
template<> ::unhinged::common::v1::StreamChunk* Arena::CreateMaybeMessage<::unhinged::common::v1::StreamChunk>(Arena*);
template<> ::unhinged::common::v1::TokenUsage* Arena::CreateMaybeMessage<::unhinged::common::v1::TokenUsage>(Arena*);
template<> ::unhinged::common::v1::UsageMetrics* Arena::CreateMaybeMessage<::unhinged::common::v1::UsageMetrics>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace unhinged {
namespace common {
namespace v1 {

enum ChunkType : int {
  CHUNK_TYPE_UNSPECIFIED = 0,
  CHUNK_TYPE_DATA = 1,
  CHUNK_TYPE_METADATA = 2,
  CHUNK_TYPE_ERROR = 3,
  CHUNK_TYPE_HEARTBEAT = 4,
  CHUNK_TYPE_PROGRESS = 5,
  ChunkType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ChunkType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ChunkType_IsValid(int value);
constexpr ChunkType ChunkType_MIN = CHUNK_TYPE_UNSPECIFIED;
constexpr ChunkType ChunkType_MAX = CHUNK_TYPE_PROGRESS;
constexpr int ChunkType_ARRAYSIZE = ChunkType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ChunkType_descriptor();
template<typename T>
inline const std::string& ChunkType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ChunkType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ChunkType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ChunkType_descriptor(), enum_t_value);
}
inline bool ChunkType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ChunkType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ChunkType>(
    ChunkType_descriptor(), name, value);
}
enum ChunkStatus : int {
  CHUNK_STATUS_UNSPECIFIED = 0,
  CHUNK_STATUS_PROCESSING = 1,
  CHUNK_STATUS_COMPLETE = 2,
  CHUNK_STATUS_ERROR = 3,
  CHUNK_STATUS_CANCELLED = 4,
  ChunkStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ChunkStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ChunkStatus_IsValid(int value);
constexpr ChunkStatus ChunkStatus_MIN = CHUNK_STATUS_UNSPECIFIED;
constexpr ChunkStatus ChunkStatus_MAX = CHUNK_STATUS_CANCELLED;
constexpr int ChunkStatus_ARRAYSIZE = ChunkStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ChunkStatus_descriptor();
template<typename T>
inline const std::string& ChunkStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ChunkStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ChunkStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ChunkStatus_descriptor(), enum_t_value);
}
inline bool ChunkStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ChunkStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ChunkStatus>(
    ChunkStatus_descriptor(), name, value);
}
enum AttachmentType : int {
  ATTACHMENT_TYPE_UNSPECIFIED = 0,
  ATTACHMENT_TYPE_IMAGE = 1,
  ATTACHMENT_TYPE_DOCUMENT = 2,
  ATTACHMENT_TYPE_AUDIO = 3,
  ATTACHMENT_TYPE_VIDEO = 4,
  ATTACHMENT_TYPE_ARCHIVE = 5,
  ATTACHMENT_TYPE_CODE = 6,
  ATTACHMENT_TYPE_SPREADSHEET = 7,
  ATTACHMENT_TYPE_PRESENTATION = 8,
  AttachmentType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AttachmentType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AttachmentType_IsValid(int value);
constexpr AttachmentType AttachmentType_MIN = ATTACHMENT_TYPE_UNSPECIFIED;
constexpr AttachmentType AttachmentType_MAX = ATTACHMENT_TYPE_PRESENTATION;
constexpr int AttachmentType_ARRAYSIZE = AttachmentType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AttachmentType_descriptor();
template<typename T>
inline const std::string& AttachmentType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AttachmentType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AttachmentType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AttachmentType_descriptor(), enum_t_value);
}
inline bool AttachmentType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AttachmentType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AttachmentType>(
    AttachmentType_descriptor(), name, value);
}
enum ErrorCode : int {
  ERROR_CODE_UNSPECIFIED = 0,
  ERROR_CODE_INVALID_ARGUMENT = 1,
  ERROR_CODE_NOT_FOUND = 2,
  ERROR_CODE_PERMISSION_DENIED = 3,
  ERROR_CODE_UNAUTHENTICATED = 4,
  ERROR_CODE_RESOURCE_EXHAUSTED = 5,
  ERROR_CODE_INTERNAL = 6,
  ERROR_CODE_UNAVAILABLE = 7,
  ERROR_CODE_DEADLINE_EXCEEDED = 8,
  ERROR_CODE_ALREADY_EXISTS = 9,
  ERROR_CODE_CANCELLED = 10,
  ErrorCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ErrorCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ErrorCode_IsValid(int value);
constexpr ErrorCode ErrorCode_MIN = ERROR_CODE_UNSPECIFIED;
constexpr ErrorCode ErrorCode_MAX = ERROR_CODE_CANCELLED;
constexpr int ErrorCode_ARRAYSIZE = ErrorCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ErrorCode_descriptor();
template<typename T>
inline const std::string& ErrorCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ErrorCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ErrorCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ErrorCode_descriptor(), enum_t_value);
}
inline bool ErrorCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ErrorCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ErrorCode>(
    ErrorCode_descriptor(), name, value);
}
enum FilterOperator : int {
  FILTER_OPERATOR_UNSPECIFIED = 0,
  FILTER_OPERATOR_EQUALS = 1,
  FILTER_OPERATOR_NOT_EQUALS = 2,
  FILTER_OPERATOR_GREATER_THAN = 3,
  FILTER_OPERATOR_LESS_THAN = 4,
  FILTER_OPERATOR_CONTAINS = 5,
  FILTER_OPERATOR_IN = 6,
  FILTER_OPERATOR_NOT_IN = 7,
  FILTER_OPERATOR_IS_NULL = 8,
  FILTER_OPERATOR_IS_NOT_NULL = 9,
  FilterOperator_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  FilterOperator_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool FilterOperator_IsValid(int value);
constexpr FilterOperator FilterOperator_MIN = FILTER_OPERATOR_UNSPECIFIED;
constexpr FilterOperator FilterOperator_MAX = FILTER_OPERATOR_IS_NOT_NULL;
constexpr int FilterOperator_ARRAYSIZE = FilterOperator_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FilterOperator_descriptor();
template<typename T>
inline const std::string& FilterOperator_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FilterOperator>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FilterOperator_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FilterOperator_descriptor(), enum_t_value);
}
inline bool FilterOperator_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FilterOperator* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FilterOperator>(
    FilterOperator_descriptor(), name, value);
}
enum HealthStatus : int {
  HEALTH_STATUS_UNSPECIFIED = 0,
  HEALTH_STATUS_HEALTHY = 1,
  HEALTH_STATUS_DEGRADED = 2,
  HEALTH_STATUS_UNHEALTHY = 3,
  HEALTH_STATUS_UNKNOWN = 4,
  HealthStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  HealthStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool HealthStatus_IsValid(int value);
constexpr HealthStatus HealthStatus_MIN = HEALTH_STATUS_UNSPECIFIED;
constexpr HealthStatus HealthStatus_MAX = HEALTH_STATUS_UNKNOWN;
constexpr int HealthStatus_ARRAYSIZE = HealthStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HealthStatus_descriptor();
template<typename T>
inline const std::string& HealthStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HealthStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HealthStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    HealthStatus_descriptor(), enum_t_value);
}
inline bool HealthStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HealthStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<HealthStatus>(
    HealthStatus_descriptor(), name, value);
}
// ===================================================================

class ResourceMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.common.v1.ResourceMetadata) */ {
 public:
  inline ResourceMetadata() : ResourceMetadata(nullptr) {}
  ~ResourceMetadata() override;
  explicit PROTOBUF_CONSTEXPR ResourceMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResourceMetadata(const ResourceMetadata& from);
  ResourceMetadata(ResourceMetadata&& from) noexcept
    : ResourceMetadata() {
    *this = ::std::move(from);
  }

  inline ResourceMetadata& operator=(const ResourceMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResourceMetadata& operator=(ResourceMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResourceMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResourceMetadata* internal_default_instance() {
    return reinterpret_cast<const ResourceMetadata*>(
               &_ResourceMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ResourceMetadata& a, ResourceMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(ResourceMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResourceMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResourceMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResourceMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResourceMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResourceMetadata& from) {
    ResourceMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResourceMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.common.v1.ResourceMetadata";
  }
  protected:
  explicit ResourceMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagsFieldNumber = 9,
    kResourceIdFieldNumber = 1,
    kTeamIdFieldNumber = 2,
    kNamespaceIdFieldNumber = 3,
    kCreatedByFieldNumber = 4,
    kCreatedAtFieldNumber = 5,
    kUpdatedAtFieldNumber = 6,
    kCustomMetadataFieldNumber = 7,
    kVersionFieldNumber = 8,
  };
  // repeated string tags = 9;
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  const std::string& tags(int index) const;
  std::string* mutable_tags(int index);
  void set_tags(int index, const std::string& value);
  void set_tags(int index, std::string&& value);
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, size_t size);
  std::string* add_tags();
  void add_tags(const std::string& value);
  void add_tags(std::string&& value);
  void add_tags(const char* value);
  void add_tags(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tags();
  private:
  const std::string& _internal_tags(int index) const;
  std::string* _internal_add_tags();
  public:

  // string resource_id = 1;
  void clear_resource_id();
  const std::string& resource_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resource_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resource_id();
  PROTOBUF_NODISCARD std::string* release_resource_id();
  void set_allocated_resource_id(std::string* resource_id);
  private:
  const std::string& _internal_resource_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource_id(const std::string& value);
  std::string* _internal_mutable_resource_id();
  public:

  // string team_id = 2;
  void clear_team_id();
  const std::string& team_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_team_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_team_id();
  PROTOBUF_NODISCARD std::string* release_team_id();
  void set_allocated_team_id(std::string* team_id);
  private:
  const std::string& _internal_team_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_team_id(const std::string& value);
  std::string* _internal_mutable_team_id();
  public:

  // string namespace_id = 3;
  void clear_namespace_id();
  const std::string& namespace_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_namespace_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_namespace_id();
  PROTOBUF_NODISCARD std::string* release_namespace_id();
  void set_allocated_namespace_id(std::string* namespace_id);
  private:
  const std::string& _internal_namespace_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_namespace_id(const std::string& value);
  std::string* _internal_mutable_namespace_id();
  public:

  // string created_by = 4;
  void clear_created_by();
  const std::string& created_by() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_created_by(ArgT0&& arg0, ArgT... args);
  std::string* mutable_created_by();
  PROTOBUF_NODISCARD std::string* release_created_by();
  void set_allocated_created_by(std::string* created_by);
  private:
  const std::string& _internal_created_by() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_created_by(const std::string& value);
  std::string* _internal_mutable_created_by();
  public:

  // .google.protobuf.Timestamp created_at = 5;
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_at();
  void set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_at();
  public:
  void unsafe_arena_set_allocated_created_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_at();

  // .google.protobuf.Timestamp updated_at = 6;
  bool has_updated_at() const;
  private:
  bool _internal_has_updated_at() const;
  public:
  void clear_updated_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& updated_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_updated_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_updated_at();
  void set_allocated_updated_at(::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_updated_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_updated_at();
  public:
  void unsafe_arena_set_allocated_updated_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_updated_at();

  // .google.protobuf.Struct custom_metadata = 7;
  bool has_custom_metadata() const;
  private:
  bool _internal_has_custom_metadata() const;
  public:
  void clear_custom_metadata();
  const ::PROTOBUF_NAMESPACE_ID::Struct& custom_metadata() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_custom_metadata();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_custom_metadata();
  void set_allocated_custom_metadata(::PROTOBUF_NAMESPACE_ID::Struct* custom_metadata);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_custom_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_custom_metadata();
  public:
  void unsafe_arena_set_allocated_custom_metadata(
      ::PROTOBUF_NAMESPACE_ID::Struct* custom_metadata);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_custom_metadata();

  // int32 version = 8;
  void clear_version();
  int32_t version() const;
  void set_version(int32_t value);
  private:
  int32_t _internal_version() const;
  void _internal_set_version(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.common.v1.ResourceMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tags_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr team_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr namespace_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr created_by_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at_;
    ::PROTOBUF_NAMESPACE_ID::Struct* custom_metadata_;
    int32_t version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class ResourceReference final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.common.v1.ResourceReference) */ {
 public:
  inline ResourceReference() : ResourceReference(nullptr) {}
  ~ResourceReference() override;
  explicit PROTOBUF_CONSTEXPR ResourceReference(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResourceReference(const ResourceReference& from);
  ResourceReference(ResourceReference&& from) noexcept
    : ResourceReference() {
    *this = ::std::move(from);
  }

  inline ResourceReference& operator=(const ResourceReference& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResourceReference& operator=(ResourceReference&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResourceReference& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResourceReference* internal_default_instance() {
    return reinterpret_cast<const ResourceReference*>(
               &_ResourceReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ResourceReference& a, ResourceReference& b) {
    a.Swap(&b);
  }
  inline void Swap(ResourceReference* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResourceReference* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResourceReference* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResourceReference>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResourceReference& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResourceReference& from) {
    ResourceReference::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResourceReference* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.common.v1.ResourceReference";
  }
  protected:
  explicit ResourceReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResourceTypeFieldNumber = 1,
    kResourceIdFieldNumber = 2,
    kDisplayNameFieldNumber = 3,
    kUrlFieldNumber = 4,
  };
  // string resource_type = 1;
  void clear_resource_type();
  const std::string& resource_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resource_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resource_type();
  PROTOBUF_NODISCARD std::string* release_resource_type();
  void set_allocated_resource_type(std::string* resource_type);
  private:
  const std::string& _internal_resource_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource_type(const std::string& value);
  std::string* _internal_mutable_resource_type();
  public:

  // string resource_id = 2;
  void clear_resource_id();
  const std::string& resource_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resource_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resource_id();
  PROTOBUF_NODISCARD std::string* release_resource_id();
  void set_allocated_resource_id(std::string* resource_id);
  private:
  const std::string& _internal_resource_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource_id(const std::string& value);
  std::string* _internal_mutable_resource_id();
  public:

  // string display_name = 3;
  void clear_display_name();
  const std::string& display_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_display_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_display_name();
  PROTOBUF_NODISCARD std::string* release_display_name();
  void set_allocated_display_name(std::string* display_name);
  private:
  const std::string& _internal_display_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_display_name(const std::string& value);
  std::string* _internal_mutable_display_name();
  public:

  // string url = 4;
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // @@protoc_insertion_point(class_scope:unhinged.common.v1.ResourceReference)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr display_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class PaginationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.common.v1.PaginationRequest) */ {
 public:
  inline PaginationRequest() : PaginationRequest(nullptr) {}
  ~PaginationRequest() override;
  explicit PROTOBUF_CONSTEXPR PaginationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PaginationRequest(const PaginationRequest& from);
  PaginationRequest(PaginationRequest&& from) noexcept
    : PaginationRequest() {
    *this = ::std::move(from);
  }

  inline PaginationRequest& operator=(const PaginationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PaginationRequest& operator=(PaginationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PaginationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PaginationRequest* internal_default_instance() {
    return reinterpret_cast<const PaginationRequest*>(
               &_PaginationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PaginationRequest& a, PaginationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PaginationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PaginationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PaginationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PaginationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PaginationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PaginationRequest& from) {
    PaginationRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PaginationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.common.v1.PaginationRequest";
  }
  protected:
  explicit PaginationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPageTokenFieldNumber = 2,
    kOrderByFieldNumber = 3,
    kPageSizeFieldNumber = 1,
  };
  // string page_token = 2;
  void clear_page_token();
  const std::string& page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_page_token();
  PROTOBUF_NODISCARD std::string* release_page_token();
  void set_allocated_page_token(std::string* page_token);
  private:
  const std::string& _internal_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(const std::string& value);
  std::string* _internal_mutable_page_token();
  public:

  // string order_by = 3;
  void clear_order_by();
  const std::string& order_by() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_order_by(ArgT0&& arg0, ArgT... args);
  std::string* mutable_order_by();
  PROTOBUF_NODISCARD std::string* release_order_by();
  void set_allocated_order_by(std::string* order_by);
  private:
  const std::string& _internal_order_by() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_by(const std::string& value);
  std::string* _internal_mutable_order_by();
  public:

  // int32 page_size = 1;
  void clear_page_size();
  int32_t page_size() const;
  void set_page_size(int32_t value);
  private:
  int32_t _internal_page_size() const;
  void _internal_set_page_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.common.v1.PaginationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr page_token_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_by_;
    int32_t page_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class PaginationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.common.v1.PaginationResponse) */ {
 public:
  inline PaginationResponse() : PaginationResponse(nullptr) {}
  ~PaginationResponse() override;
  explicit PROTOBUF_CONSTEXPR PaginationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PaginationResponse(const PaginationResponse& from);
  PaginationResponse(PaginationResponse&& from) noexcept
    : PaginationResponse() {
    *this = ::std::move(from);
  }

  inline PaginationResponse& operator=(const PaginationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PaginationResponse& operator=(PaginationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PaginationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PaginationResponse* internal_default_instance() {
    return reinterpret_cast<const PaginationResponse*>(
               &_PaginationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PaginationResponse& a, PaginationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PaginationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PaginationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PaginationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PaginationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PaginationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PaginationResponse& from) {
    PaginationResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PaginationResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.common.v1.PaginationResponse";
  }
  protected:
  explicit PaginationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNextPageTokenFieldNumber = 1,
    kTotalCountFieldNumber = 2,
    kHasMoreFieldNumber = 3,
    kPageSizeFieldNumber = 4,
  };
  // string next_page_token = 1;
  void clear_next_page_token();
  const std::string& next_page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_page_token();
  PROTOBUF_NODISCARD std::string* release_next_page_token();
  void set_allocated_next_page_token(std::string* next_page_token);
  private:
  const std::string& _internal_next_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(const std::string& value);
  std::string* _internal_mutable_next_page_token();
  public:

  // int32 total_count = 2;
  void clear_total_count();
  int32_t total_count() const;
  void set_total_count(int32_t value);
  private:
  int32_t _internal_total_count() const;
  void _internal_set_total_count(int32_t value);
  public:

  // bool has_more = 3;
  void clear_has_more();
  bool has_more() const;
  void set_has_more(bool value);
  private:
  bool _internal_has_more() const;
  void _internal_set_has_more(bool value);
  public:

  // int32 page_size = 4;
  void clear_page_size();
  int32_t page_size() const;
  void set_page_size(int32_t value);
  private:
  int32_t _internal_page_size() const;
  void _internal_set_page_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.common.v1.PaginationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_page_token_;
    int32_t total_count_;
    bool has_more_;
    int32_t page_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class StreamChunk final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.common.v1.StreamChunk) */ {
 public:
  inline StreamChunk() : StreamChunk(nullptr) {}
  ~StreamChunk() override;
  explicit PROTOBUF_CONSTEXPR StreamChunk(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamChunk(const StreamChunk& from);
  StreamChunk(StreamChunk&& from) noexcept
    : StreamChunk() {
    *this = ::std::move(from);
  }

  inline StreamChunk& operator=(const StreamChunk& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamChunk& operator=(StreamChunk&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamChunk& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamChunk* internal_default_instance() {
    return reinterpret_cast<const StreamChunk*>(
               &_StreamChunk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(StreamChunk& a, StreamChunk& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamChunk* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamChunk* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamChunk* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamChunk>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamChunk& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamChunk& from) {
    StreamChunk::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamChunk* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.common.v1.StreamChunk";
  }
  protected:
  explicit StreamChunk(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStreamIdFieldNumber = 1,
    kDataFieldNumber = 4,
    kTextFieldNumber = 5,
    kStructuredFieldNumber = 6,
    kMetadataFieldNumber = 7,
    kTimestampFieldNumber = 10,
    kSequenceNumberFieldNumber = 2,
    kTypeFieldNumber = 3,
    kIsFinalFieldNumber = 8,
    kStatusFieldNumber = 9,
  };
  // string stream_id = 1;
  void clear_stream_id();
  const std::string& stream_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stream_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stream_id();
  PROTOBUF_NODISCARD std::string* release_stream_id();
  void set_allocated_stream_id(std::string* stream_id);
  private:
  const std::string& _internal_stream_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stream_id(const std::string& value);
  std::string* _internal_mutable_stream_id();
  public:

  // bytes data = 4;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // string text = 5;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // .google.protobuf.Struct structured = 6;
  bool has_structured() const;
  private:
  bool _internal_has_structured() const;
  public:
  void clear_structured();
  const ::PROTOBUF_NAMESPACE_ID::Struct& structured() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_structured();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_structured();
  void set_allocated_structured(::PROTOBUF_NAMESPACE_ID::Struct* structured);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_structured() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_structured();
  public:
  void unsafe_arena_set_allocated_structured(
      ::PROTOBUF_NAMESPACE_ID::Struct* structured);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_structured();

  // .google.protobuf.Struct metadata = 7;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::PROTOBUF_NAMESPACE_ID::Struct& metadata() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_metadata();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_metadata();
  void set_allocated_metadata(::PROTOBUF_NAMESPACE_ID::Struct* metadata);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::PROTOBUF_NAMESPACE_ID::Struct* metadata);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_metadata();

  // .google.protobuf.Timestamp timestamp = 10;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // int32 sequence_number = 2;
  void clear_sequence_number();
  int32_t sequence_number() const;
  void set_sequence_number(int32_t value);
  private:
  int32_t _internal_sequence_number() const;
  void _internal_set_sequence_number(int32_t value);
  public:

  // .unhinged.common.v1.ChunkType type = 3;
  void clear_type();
  ::unhinged::common::v1::ChunkType type() const;
  void set_type(::unhinged::common::v1::ChunkType value);
  private:
  ::unhinged::common::v1::ChunkType _internal_type() const;
  void _internal_set_type(::unhinged::common::v1::ChunkType value);
  public:

  // bool is_final = 8;
  void clear_is_final();
  bool is_final() const;
  void set_is_final(bool value);
  private:
  bool _internal_is_final() const;
  void _internal_set_is_final(bool value);
  public:

  // .unhinged.common.v1.ChunkStatus status = 9;
  void clear_status();
  ::unhinged::common::v1::ChunkStatus status() const;
  void set_status(::unhinged::common::v1::ChunkStatus value);
  private:
  ::unhinged::common::v1::ChunkStatus _internal_status() const;
  void _internal_set_status(::unhinged::common::v1::ChunkStatus value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.common.v1.StreamChunk)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stream_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    ::PROTOBUF_NAMESPACE_ID::Struct* structured_;
    ::PROTOBUF_NAMESPACE_ID::Struct* metadata_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
    int32_t sequence_number_;
    int type_;
    bool is_final_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class UsageMetrics final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.common.v1.UsageMetrics) */ {
 public:
  inline UsageMetrics() : UsageMetrics(nullptr) {}
  ~UsageMetrics() override;
  explicit PROTOBUF_CONSTEXPR UsageMetrics(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UsageMetrics(const UsageMetrics& from);
  UsageMetrics(UsageMetrics&& from) noexcept
    : UsageMetrics() {
    *this = ::std::move(from);
  }

  inline UsageMetrics& operator=(const UsageMetrics& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsageMetrics& operator=(UsageMetrics&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UsageMetrics& default_instance() {
    return *internal_default_instance();
  }
  enum MetricCase {
    kTokens = 1,
    kAudio = 2,
    kData = 3,
    kCompute = 4,
    METRIC_NOT_SET = 0,
  };

  static inline const UsageMetrics* internal_default_instance() {
    return reinterpret_cast<const UsageMetrics*>(
               &_UsageMetrics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(UsageMetrics& a, UsageMetrics& b) {
    a.Swap(&b);
  }
  inline void Swap(UsageMetrics* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UsageMetrics* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UsageMetrics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UsageMetrics>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UsageMetrics& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UsageMetrics& from) {
    UsageMetrics::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UsageMetrics* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.common.v1.UsageMetrics";
  }
  protected:
  explicit UsageMetrics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProcessingTimeFieldNumber = 5,
    kRecordedAtFieldNumber = 6,
    kCostUsdFieldNumber = 7,
    kTokensFieldNumber = 1,
    kAudioFieldNumber = 2,
    kDataFieldNumber = 3,
    kComputeFieldNumber = 4,
  };
  // .google.protobuf.Duration processing_time = 5;
  bool has_processing_time() const;
  private:
  bool _internal_has_processing_time() const;
  public:
  void clear_processing_time();
  const ::PROTOBUF_NAMESPACE_ID::Duration& processing_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_processing_time();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_processing_time();
  void set_allocated_processing_time(::PROTOBUF_NAMESPACE_ID::Duration* processing_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_processing_time() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_processing_time();
  public:
  void unsafe_arena_set_allocated_processing_time(
      ::PROTOBUF_NAMESPACE_ID::Duration* processing_time);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_processing_time();

  // .google.protobuf.Timestamp recorded_at = 6;
  bool has_recorded_at() const;
  private:
  bool _internal_has_recorded_at() const;
  public:
  void clear_recorded_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& recorded_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_recorded_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_recorded_at();
  void set_allocated_recorded_at(::PROTOBUF_NAMESPACE_ID::Timestamp* recorded_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_recorded_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_recorded_at();
  public:
  void unsafe_arena_set_allocated_recorded_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* recorded_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_recorded_at();

  // float cost_usd = 7;
  void clear_cost_usd();
  float cost_usd() const;
  void set_cost_usd(float value);
  private:
  float _internal_cost_usd() const;
  void _internal_set_cost_usd(float value);
  public:

  // .unhinged.common.v1.TokenUsage tokens = 1;
  bool has_tokens() const;
  private:
  bool _internal_has_tokens() const;
  public:
  void clear_tokens();
  const ::unhinged::common::v1::TokenUsage& tokens() const;
  PROTOBUF_NODISCARD ::unhinged::common::v1::TokenUsage* release_tokens();
  ::unhinged::common::v1::TokenUsage* mutable_tokens();
  void set_allocated_tokens(::unhinged::common::v1::TokenUsage* tokens);
  private:
  const ::unhinged::common::v1::TokenUsage& _internal_tokens() const;
  ::unhinged::common::v1::TokenUsage* _internal_mutable_tokens();
  public:
  void unsafe_arena_set_allocated_tokens(
      ::unhinged::common::v1::TokenUsage* tokens);
  ::unhinged::common::v1::TokenUsage* unsafe_arena_release_tokens();

  // .unhinged.common.v1.AudioUsage audio = 2;
  bool has_audio() const;
  private:
  bool _internal_has_audio() const;
  public:
  void clear_audio();
  const ::unhinged::common::v1::AudioUsage& audio() const;
  PROTOBUF_NODISCARD ::unhinged::common::v1::AudioUsage* release_audio();
  ::unhinged::common::v1::AudioUsage* mutable_audio();
  void set_allocated_audio(::unhinged::common::v1::AudioUsage* audio);
  private:
  const ::unhinged::common::v1::AudioUsage& _internal_audio() const;
  ::unhinged::common::v1::AudioUsage* _internal_mutable_audio();
  public:
  void unsafe_arena_set_allocated_audio(
      ::unhinged::common::v1::AudioUsage* audio);
  ::unhinged::common::v1::AudioUsage* unsafe_arena_release_audio();

  // .unhinged.common.v1.DataUsage data = 3;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::unhinged::common::v1::DataUsage& data() const;
  PROTOBUF_NODISCARD ::unhinged::common::v1::DataUsage* release_data();
  ::unhinged::common::v1::DataUsage* mutable_data();
  void set_allocated_data(::unhinged::common::v1::DataUsage* data);
  private:
  const ::unhinged::common::v1::DataUsage& _internal_data() const;
  ::unhinged::common::v1::DataUsage* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::unhinged::common::v1::DataUsage* data);
  ::unhinged::common::v1::DataUsage* unsafe_arena_release_data();

  // .unhinged.common.v1.ComputeUsage compute = 4;
  bool has_compute() const;
  private:
  bool _internal_has_compute() const;
  public:
  void clear_compute();
  const ::unhinged::common::v1::ComputeUsage& compute() const;
  PROTOBUF_NODISCARD ::unhinged::common::v1::ComputeUsage* release_compute();
  ::unhinged::common::v1::ComputeUsage* mutable_compute();
  void set_allocated_compute(::unhinged::common::v1::ComputeUsage* compute);
  private:
  const ::unhinged::common::v1::ComputeUsage& _internal_compute() const;
  ::unhinged::common::v1::ComputeUsage* _internal_mutable_compute();
  public:
  void unsafe_arena_set_allocated_compute(
      ::unhinged::common::v1::ComputeUsage* compute);
  ::unhinged::common::v1::ComputeUsage* unsafe_arena_release_compute();

  void clear_metric();
  MetricCase metric_case() const;
  // @@protoc_insertion_point(class_scope:unhinged.common.v1.UsageMetrics)
 private:
  class _Internal;
  void set_has_tokens();
  void set_has_audio();
  void set_has_data();
  void set_has_compute();

  inline bool has_metric() const;
  inline void clear_has_metric();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::Duration* processing_time_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* recorded_at_;
    float cost_usd_;
    union MetricUnion {
      constexpr MetricUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::unhinged::common::v1::TokenUsage* tokens_;
      ::unhinged::common::v1::AudioUsage* audio_;
      ::unhinged::common::v1::DataUsage* data_;
      ::unhinged::common::v1::ComputeUsage* compute_;
    } metric_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class TokenUsage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.common.v1.TokenUsage) */ {
 public:
  inline TokenUsage() : TokenUsage(nullptr) {}
  ~TokenUsage() override;
  explicit PROTOBUF_CONSTEXPR TokenUsage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TokenUsage(const TokenUsage& from);
  TokenUsage(TokenUsage&& from) noexcept
    : TokenUsage() {
    *this = ::std::move(from);
  }

  inline TokenUsage& operator=(const TokenUsage& from) {
    CopyFrom(from);
    return *this;
  }
  inline TokenUsage& operator=(TokenUsage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TokenUsage& default_instance() {
    return *internal_default_instance();
  }
  static inline const TokenUsage* internal_default_instance() {
    return reinterpret_cast<const TokenUsage*>(
               &_TokenUsage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(TokenUsage& a, TokenUsage& b) {
    a.Swap(&b);
  }
  inline void Swap(TokenUsage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TokenUsage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TokenUsage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TokenUsage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TokenUsage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TokenUsage& from) {
    TokenUsage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TokenUsage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.common.v1.TokenUsage";
  }
  protected:
  explicit TokenUsage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelFieldNumber = 5,
    kPromptTokensFieldNumber = 1,
    kCompletionTokensFieldNumber = 2,
    kTotalTokensFieldNumber = 3,
    kCachedTokensFieldNumber = 4,
  };
  // string model = 5;
  void clear_model();
  const std::string& model() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model();
  PROTOBUF_NODISCARD std::string* release_model();
  void set_allocated_model(std::string* model);
  private:
  const std::string& _internal_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model(const std::string& value);
  std::string* _internal_mutable_model();
  public:

  // int32 prompt_tokens = 1;
  void clear_prompt_tokens();
  int32_t prompt_tokens() const;
  void set_prompt_tokens(int32_t value);
  private:
  int32_t _internal_prompt_tokens() const;
  void _internal_set_prompt_tokens(int32_t value);
  public:

  // int32 completion_tokens = 2;
  void clear_completion_tokens();
  int32_t completion_tokens() const;
  void set_completion_tokens(int32_t value);
  private:
  int32_t _internal_completion_tokens() const;
  void _internal_set_completion_tokens(int32_t value);
  public:

  // int32 total_tokens = 3;
  void clear_total_tokens();
  int32_t total_tokens() const;
  void set_total_tokens(int32_t value);
  private:
  int32_t _internal_total_tokens() const;
  void _internal_set_total_tokens(int32_t value);
  public:

  // int32 cached_tokens = 4;
  void clear_cached_tokens();
  int32_t cached_tokens() const;
  void set_cached_tokens(int32_t value);
  private:
  int32_t _internal_cached_tokens() const;
  void _internal_set_cached_tokens(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.common.v1.TokenUsage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_;
    int32_t prompt_tokens_;
    int32_t completion_tokens_;
    int32_t total_tokens_;
    int32_t cached_tokens_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class AudioUsage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.common.v1.AudioUsage) */ {
 public:
  inline AudioUsage() : AudioUsage(nullptr) {}
  ~AudioUsage() override;
  explicit PROTOBUF_CONSTEXPR AudioUsage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AudioUsage(const AudioUsage& from);
  AudioUsage(AudioUsage&& from) noexcept
    : AudioUsage() {
    *this = ::std::move(from);
  }

  inline AudioUsage& operator=(const AudioUsage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioUsage& operator=(AudioUsage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AudioUsage& default_instance() {
    return *internal_default_instance();
  }
  static inline const AudioUsage* internal_default_instance() {
    return reinterpret_cast<const AudioUsage*>(
               &_AudioUsage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(AudioUsage& a, AudioUsage& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioUsage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioUsage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AudioUsage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AudioUsage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AudioUsage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AudioUsage& from) {
    AudioUsage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AudioUsage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.common.v1.AudioUsage";
  }
  protected:
  explicit AudioUsage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFormatFieldNumber = 5,
    kDurationFieldNumber = 1,
    kBytesProcessedFieldNumber = 2,
    kSampleRateFieldNumber = 3,
    kChannelsFieldNumber = 4,
  };
  // string format = 5;
  void clear_format();
  const std::string& format() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_format(ArgT0&& arg0, ArgT... args);
  std::string* mutable_format();
  PROTOBUF_NODISCARD std::string* release_format();
  void set_allocated_format(std::string* format);
  private:
  const std::string& _internal_format() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_format(const std::string& value);
  std::string* _internal_mutable_format();
  public:

  // .google.protobuf.Duration duration = 1;
  bool has_duration() const;
  private:
  bool _internal_has_duration() const;
  public:
  void clear_duration();
  const ::PROTOBUF_NAMESPACE_ID::Duration& duration() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_duration();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_duration();
  void set_allocated_duration(::PROTOBUF_NAMESPACE_ID::Duration* duration);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_duration() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_duration();
  public:
  void unsafe_arena_set_allocated_duration(
      ::PROTOBUF_NAMESPACE_ID::Duration* duration);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_duration();

  // int64 bytes_processed = 2;
  void clear_bytes_processed();
  int64_t bytes_processed() const;
  void set_bytes_processed(int64_t value);
  private:
  int64_t _internal_bytes_processed() const;
  void _internal_set_bytes_processed(int64_t value);
  public:

  // int32 sample_rate = 3;
  void clear_sample_rate();
  int32_t sample_rate() const;
  void set_sample_rate(int32_t value);
  private:
  int32_t _internal_sample_rate() const;
  void _internal_set_sample_rate(int32_t value);
  public:

  // int32 channels = 4;
  void clear_channels();
  int32_t channels() const;
  void set_channels(int32_t value);
  private:
  int32_t _internal_channels() const;
  void _internal_set_channels(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.common.v1.AudioUsage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr format_;
    ::PROTOBUF_NAMESPACE_ID::Duration* duration_;
    int64_t bytes_processed_;
    int32_t sample_rate_;
    int32_t channels_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class DataUsage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.common.v1.DataUsage) */ {
 public:
  inline DataUsage() : DataUsage(nullptr) {}
  ~DataUsage() override;
  explicit PROTOBUF_CONSTEXPR DataUsage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataUsage(const DataUsage& from);
  DataUsage(DataUsage&& from) noexcept
    : DataUsage() {
    *this = ::std::move(from);
  }

  inline DataUsage& operator=(const DataUsage& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataUsage& operator=(DataUsage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataUsage& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataUsage* internal_default_instance() {
    return reinterpret_cast<const DataUsage*>(
               &_DataUsage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(DataUsage& a, DataUsage& b) {
    a.Swap(&b);
  }
  inline void Swap(DataUsage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataUsage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataUsage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataUsage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataUsage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DataUsage& from) {
    DataUsage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataUsage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.common.v1.DataUsage";
  }
  protected:
  explicit DataUsage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBytesReadFieldNumber = 1,
    kBytesWrittenFieldNumber = 2,
    kRecordsProcessedFieldNumber = 3,
    kApiCallsFieldNumber = 4,
  };
  // int64 bytes_read = 1;
  void clear_bytes_read();
  int64_t bytes_read() const;
  void set_bytes_read(int64_t value);
  private:
  int64_t _internal_bytes_read() const;
  void _internal_set_bytes_read(int64_t value);
  public:

  // int64 bytes_written = 2;
  void clear_bytes_written();
  int64_t bytes_written() const;
  void set_bytes_written(int64_t value);
  private:
  int64_t _internal_bytes_written() const;
  void _internal_set_bytes_written(int64_t value);
  public:

  // int32 records_processed = 3;
  void clear_records_processed();
  int32_t records_processed() const;
  void set_records_processed(int32_t value);
  private:
  int32_t _internal_records_processed() const;
  void _internal_set_records_processed(int32_t value);
  public:

  // int32 api_calls = 4;
  void clear_api_calls();
  int32_t api_calls() const;
  void set_api_calls(int32_t value);
  private:
  int32_t _internal_api_calls() const;
  void _internal_set_api_calls(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.common.v1.DataUsage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t bytes_read_;
    int64_t bytes_written_;
    int32_t records_processed_;
    int32_t api_calls_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class ComputeUsage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.common.v1.ComputeUsage) */ {
 public:
  inline ComputeUsage() : ComputeUsage(nullptr) {}
  ~ComputeUsage() override;
  explicit PROTOBUF_CONSTEXPR ComputeUsage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ComputeUsage(const ComputeUsage& from);
  ComputeUsage(ComputeUsage&& from) noexcept
    : ComputeUsage() {
    *this = ::std::move(from);
  }

  inline ComputeUsage& operator=(const ComputeUsage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ComputeUsage& operator=(ComputeUsage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ComputeUsage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ComputeUsage* internal_default_instance() {
    return reinterpret_cast<const ComputeUsage*>(
               &_ComputeUsage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ComputeUsage& a, ComputeUsage& b) {
    a.Swap(&b);
  }
  inline void Swap(ComputeUsage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ComputeUsage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ComputeUsage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ComputeUsage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ComputeUsage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ComputeUsage& from) {
    ComputeUsage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ComputeUsage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.common.v1.ComputeUsage";
  }
  protected:
  explicit ComputeUsage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCpuTimeFieldNumber = 1,
    kMemoryBytesFieldNumber = 2,
    kStorageBytesFieldNumber = 3,
    kGpuSecondsFieldNumber = 4,
  };
  // .google.protobuf.Duration cpu_time = 1;
  bool has_cpu_time() const;
  private:
  bool _internal_has_cpu_time() const;
  public:
  void clear_cpu_time();
  const ::PROTOBUF_NAMESPACE_ID::Duration& cpu_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_cpu_time();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_cpu_time();
  void set_allocated_cpu_time(::PROTOBUF_NAMESPACE_ID::Duration* cpu_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_cpu_time() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_cpu_time();
  public:
  void unsafe_arena_set_allocated_cpu_time(
      ::PROTOBUF_NAMESPACE_ID::Duration* cpu_time);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_cpu_time();

  // int64 memory_bytes = 2;
  void clear_memory_bytes();
  int64_t memory_bytes() const;
  void set_memory_bytes(int64_t value);
  private:
  int64_t _internal_memory_bytes() const;
  void _internal_set_memory_bytes(int64_t value);
  public:

  // int64 storage_bytes = 3;
  void clear_storage_bytes();
  int64_t storage_bytes() const;
  void set_storage_bytes(int64_t value);
  private:
  int64_t _internal_storage_bytes() const;
  void _internal_set_storage_bytes(int64_t value);
  public:

  // int32 gpu_seconds = 4;
  void clear_gpu_seconds();
  int32_t gpu_seconds() const;
  void set_gpu_seconds(int32_t value);
  private:
  int32_t _internal_gpu_seconds() const;
  void _internal_set_gpu_seconds(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.common.v1.ComputeUsage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::Duration* cpu_time_;
    int64_t memory_bytes_;
    int64_t storage_bytes_;
    int32_t gpu_seconds_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class Attachment final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.common.v1.Attachment) */ {
 public:
  inline Attachment() : Attachment(nullptr) {}
  ~Attachment() override;
  explicit PROTOBUF_CONSTEXPR Attachment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Attachment(const Attachment& from);
  Attachment(Attachment&& from) noexcept
    : Attachment() {
    *this = ::std::move(from);
  }

  inline Attachment& operator=(const Attachment& from) {
    CopyFrom(from);
    return *this;
  }
  inline Attachment& operator=(Attachment&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Attachment& default_instance() {
    return *internal_default_instance();
  }
  static inline const Attachment* internal_default_instance() {
    return reinterpret_cast<const Attachment*>(
               &_Attachment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Attachment& a, Attachment& b) {
    a.Swap(&b);
  }
  inline void Swap(Attachment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Attachment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Attachment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Attachment>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Attachment& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Attachment& from) {
    Attachment::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Attachment* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.common.v1.Attachment";
  }
  protected:
  explicit Attachment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttachmentIdFieldNumber = 1,
    kUrlFieldNumber = 3,
    kFilenameFieldNumber = 4,
    kMimeTypeFieldNumber = 6,
    kThumbnailUrlFieldNumber = 7,
    kUploadedByFieldNumber = 10,
    kMetadataFieldNumber = 8,
    kUploadedAtFieldNumber = 9,
    kSizeBytesFieldNumber = 5,
    kTypeFieldNumber = 2,
  };
  // string attachment_id = 1;
  void clear_attachment_id();
  const std::string& attachment_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attachment_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attachment_id();
  PROTOBUF_NODISCARD std::string* release_attachment_id();
  void set_allocated_attachment_id(std::string* attachment_id);
  private:
  const std::string& _internal_attachment_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attachment_id(const std::string& value);
  std::string* _internal_mutable_attachment_id();
  public:

  // string url = 3;
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // string filename = 4;
  void clear_filename();
  const std::string& filename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filename();
  PROTOBUF_NODISCARD std::string* release_filename();
  void set_allocated_filename(std::string* filename);
  private:
  const std::string& _internal_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filename(const std::string& value);
  std::string* _internal_mutable_filename();
  public:

  // string mime_type = 6;
  void clear_mime_type();
  const std::string& mime_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mime_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mime_type();
  PROTOBUF_NODISCARD std::string* release_mime_type();
  void set_allocated_mime_type(std::string* mime_type);
  private:
  const std::string& _internal_mime_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mime_type(const std::string& value);
  std::string* _internal_mutable_mime_type();
  public:

  // string thumbnail_url = 7;
  void clear_thumbnail_url();
  const std::string& thumbnail_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_thumbnail_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_thumbnail_url();
  PROTOBUF_NODISCARD std::string* release_thumbnail_url();
  void set_allocated_thumbnail_url(std::string* thumbnail_url);
  private:
  const std::string& _internal_thumbnail_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_thumbnail_url(const std::string& value);
  std::string* _internal_mutable_thumbnail_url();
  public:

  // string uploaded_by = 10;
  void clear_uploaded_by();
  const std::string& uploaded_by() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uploaded_by(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uploaded_by();
  PROTOBUF_NODISCARD std::string* release_uploaded_by();
  void set_allocated_uploaded_by(std::string* uploaded_by);
  private:
  const std::string& _internal_uploaded_by() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uploaded_by(const std::string& value);
  std::string* _internal_mutable_uploaded_by();
  public:

  // .google.protobuf.Struct metadata = 8;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::PROTOBUF_NAMESPACE_ID::Struct& metadata() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_metadata();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_metadata();
  void set_allocated_metadata(::PROTOBUF_NAMESPACE_ID::Struct* metadata);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::PROTOBUF_NAMESPACE_ID::Struct* metadata);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_metadata();

  // .google.protobuf.Timestamp uploaded_at = 9;
  bool has_uploaded_at() const;
  private:
  bool _internal_has_uploaded_at() const;
  public:
  void clear_uploaded_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& uploaded_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_uploaded_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_uploaded_at();
  void set_allocated_uploaded_at(::PROTOBUF_NAMESPACE_ID::Timestamp* uploaded_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_uploaded_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_uploaded_at();
  public:
  void unsafe_arena_set_allocated_uploaded_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* uploaded_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_uploaded_at();

  // int64 size_bytes = 5;
  void clear_size_bytes();
  int64_t size_bytes() const;
  void set_size_bytes(int64_t value);
  private:
  int64_t _internal_size_bytes() const;
  void _internal_set_size_bytes(int64_t value);
  public:

  // .unhinged.common.v1.AttachmentType type = 2;
  void clear_type();
  ::unhinged::common::v1::AttachmentType type() const;
  void set_type(::unhinged::common::v1::AttachmentType value);
  private:
  ::unhinged::common::v1::AttachmentType _internal_type() const;
  void _internal_set_type(::unhinged::common::v1::AttachmentType value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.common.v1.Attachment)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attachment_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mime_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr thumbnail_url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uploaded_by_;
    ::PROTOBUF_NAMESPACE_ID::Struct* metadata_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* uploaded_at_;
    int64_t size_bytes_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class Error final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.common.v1.Error) */ {
 public:
  inline Error() : Error(nullptr) {}
  ~Error() override;
  explicit PROTOBUF_CONSTEXPR Error(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Error(const Error& from);
  Error(Error&& from) noexcept
    : Error() {
    *this = ::std::move(from);
  }

  inline Error& operator=(const Error& from) {
    CopyFrom(from);
    return *this;
  }
  inline Error& operator=(Error&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Error& default_instance() {
    return *internal_default_instance();
  }
  static inline const Error* internal_default_instance() {
    return reinterpret_cast<const Error*>(
               &_Error_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Error& a, Error& b) {
    a.Swap(&b);
  }
  inline void Swap(Error* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Error* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Error* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Error>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Error& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Error& from) {
    Error::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Error* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.common.v1.Error";
  }
  protected:
  explicit Error(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldErrorsFieldNumber = 4,
    kMessageFieldNumber = 2,
    kDetailsFieldNumber = 3,
    kRequestIdFieldNumber = 6,
    kDebugInfoFieldNumber = 5,
    kCodeFieldNumber = 1,
  };
  // repeated .unhinged.common.v1.ErrorField field_errors = 4;
  int field_errors_size() const;
  private:
  int _internal_field_errors_size() const;
  public:
  void clear_field_errors();
  ::unhinged::common::v1::ErrorField* mutable_field_errors(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::common::v1::ErrorField >*
      mutable_field_errors();
  private:
  const ::unhinged::common::v1::ErrorField& _internal_field_errors(int index) const;
  ::unhinged::common::v1::ErrorField* _internal_add_field_errors();
  public:
  const ::unhinged::common::v1::ErrorField& field_errors(int index) const;
  ::unhinged::common::v1::ErrorField* add_field_errors();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::common::v1::ErrorField >&
      field_errors() const;

  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // string details = 3;
  void clear_details();
  const std::string& details() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_details(ArgT0&& arg0, ArgT... args);
  std::string* mutable_details();
  PROTOBUF_NODISCARD std::string* release_details();
  void set_allocated_details(std::string* details);
  private:
  const std::string& _internal_details() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_details(const std::string& value);
  std::string* _internal_mutable_details();
  public:

  // string request_id = 6;
  void clear_request_id();
  const std::string& request_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_request_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_request_id();
  PROTOBUF_NODISCARD std::string* release_request_id();
  void set_allocated_request_id(std::string* request_id);
  private:
  const std::string& _internal_request_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_id(const std::string& value);
  std::string* _internal_mutable_request_id();
  public:

  // .google.protobuf.Struct debug_info = 5;
  bool has_debug_info() const;
  private:
  bool _internal_has_debug_info() const;
  public:
  void clear_debug_info();
  const ::PROTOBUF_NAMESPACE_ID::Struct& debug_info() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_debug_info();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_debug_info();
  void set_allocated_debug_info(::PROTOBUF_NAMESPACE_ID::Struct* debug_info);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_debug_info() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_debug_info();
  public:
  void unsafe_arena_set_allocated_debug_info(
      ::PROTOBUF_NAMESPACE_ID::Struct* debug_info);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_debug_info();

  // .unhinged.common.v1.ErrorCode code = 1;
  void clear_code();
  ::unhinged::common::v1::ErrorCode code() const;
  void set_code(::unhinged::common::v1::ErrorCode value);
  private:
  ::unhinged::common::v1::ErrorCode _internal_code() const;
  void _internal_set_code(::unhinged::common::v1::ErrorCode value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.common.v1.Error)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::common::v1::ErrorField > field_errors_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr details_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_id_;
    ::PROTOBUF_NAMESPACE_ID::Struct* debug_info_;
    int code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class ErrorField final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.common.v1.ErrorField) */ {
 public:
  inline ErrorField() : ErrorField(nullptr) {}
  ~ErrorField() override;
  explicit PROTOBUF_CONSTEXPR ErrorField(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ErrorField(const ErrorField& from);
  ErrorField(ErrorField&& from) noexcept
    : ErrorField() {
    *this = ::std::move(from);
  }

  inline ErrorField& operator=(const ErrorField& from) {
    CopyFrom(from);
    return *this;
  }
  inline ErrorField& operator=(ErrorField&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ErrorField& default_instance() {
    return *internal_default_instance();
  }
  static inline const ErrorField* internal_default_instance() {
    return reinterpret_cast<const ErrorField*>(
               &_ErrorField_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ErrorField& a, ErrorField& b) {
    a.Swap(&b);
  }
  inline void Swap(ErrorField* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ErrorField* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ErrorField* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ErrorField>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ErrorField& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ErrorField& from) {
    ErrorField::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ErrorField* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.common.v1.ErrorField";
  }
  protected:
  explicit ErrorField(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldFieldNumber = 1,
    kMessageFieldNumber = 2,
    kCodeFieldNumber = 3,
  };
  // string field = 1;
  void clear_field();
  const std::string& field() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field();
  PROTOBUF_NODISCARD std::string* release_field();
  void set_allocated_field(std::string* field);
  private:
  const std::string& _internal_field() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field(const std::string& value);
  std::string* _internal_mutable_field();
  public:

  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // string code = 3;
  void clear_code();
  const std::string& code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_code();
  PROTOBUF_NODISCARD std::string* release_code();
  void set_allocated_code(std::string* code);
  private:
  const std::string& _internal_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code(const std::string& value);
  std::string* _internal_mutable_code();
  public:

  // @@protoc_insertion_point(class_scope:unhinged.common.v1.ErrorField)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class Filter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.common.v1.Filter) */ {
 public:
  inline Filter() : Filter(nullptr) {}
  ~Filter() override;
  explicit PROTOBUF_CONSTEXPR Filter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Filter(const Filter& from);
  Filter(Filter&& from) noexcept
    : Filter() {
    *this = ::std::move(from);
  }

  inline Filter& operator=(const Filter& from) {
    CopyFrom(from);
    return *this;
  }
  inline Filter& operator=(Filter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Filter& default_instance() {
    return *internal_default_instance();
  }
  static inline const Filter* internal_default_instance() {
    return reinterpret_cast<const Filter*>(
               &_Filter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Filter& a, Filter& b) {
    a.Swap(&b);
  }
  inline void Swap(Filter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Filter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Filter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Filter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Filter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Filter& from) {
    Filter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Filter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.common.v1.Filter";
  }
  protected:
  explicit Filter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 4,
    kFieldFieldNumber = 1,
    kValueFieldNumber = 3,
    kOperatorFieldNumber = 2,
  };
  // repeated string values = 4;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  const std::string& values(int index) const;
  std::string* mutable_values(int index);
  void set_values(int index, const std::string& value);
  void set_values(int index, std::string&& value);
  void set_values(int index, const char* value);
  void set_values(int index, const char* value, size_t size);
  std::string* add_values();
  void add_values(const std::string& value);
  void add_values(std::string&& value);
  void add_values(const char* value);
  void add_values(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_values();
  private:
  const std::string& _internal_values(int index) const;
  std::string* _internal_add_values();
  public:

  // string field = 1;
  void clear_field();
  const std::string& field() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field();
  PROTOBUF_NODISCARD std::string* release_field();
  void set_allocated_field(std::string* field);
  private:
  const std::string& _internal_field() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field(const std::string& value);
  std::string* _internal_mutable_field();
  public:

  // string value = 3;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // .unhinged.common.v1.FilterOperator operator = 2;
  void clear_operator_();
  ::unhinged::common::v1::FilterOperator operator_() const;
  void set_operator_(::unhinged::common::v1::FilterOperator value);
  private:
  ::unhinged::common::v1::FilterOperator _internal_operator_() const;
  void _internal_set_operator_(::unhinged::common::v1::FilterOperator value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.common.v1.Filter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> values_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    int operator__;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class HealthCheckRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.common.v1.HealthCheckRequest) */ {
 public:
  inline HealthCheckRequest() : HealthCheckRequest(nullptr) {}
  ~HealthCheckRequest() override;
  explicit PROTOBUF_CONSTEXPR HealthCheckRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HealthCheckRequest(const HealthCheckRequest& from);
  HealthCheckRequest(HealthCheckRequest&& from) noexcept
    : HealthCheckRequest() {
    *this = ::std::move(from);
  }

  inline HealthCheckRequest& operator=(const HealthCheckRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HealthCheckRequest& operator=(HealthCheckRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HealthCheckRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HealthCheckRequest* internal_default_instance() {
    return reinterpret_cast<const HealthCheckRequest*>(
               &_HealthCheckRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(HealthCheckRequest& a, HealthCheckRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HealthCheckRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HealthCheckRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HealthCheckRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HealthCheckRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HealthCheckRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HealthCheckRequest& from) {
    HealthCheckRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HealthCheckRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.common.v1.HealthCheckRequest";
  }
  protected:
  explicit HealthCheckRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceFieldNumber = 1,
    kIncludeDependenciesFieldNumber = 2,
  };
  // string service = 1;
  void clear_service();
  const std::string& service() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service();
  PROTOBUF_NODISCARD std::string* release_service();
  void set_allocated_service(std::string* service);
  private:
  const std::string& _internal_service() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service(const std::string& value);
  std::string* _internal_mutable_service();
  public:

  // bool include_dependencies = 2;
  void clear_include_dependencies();
  bool include_dependencies() const;
  void set_include_dependencies(bool value);
  private:
  bool _internal_include_dependencies() const;
  void _internal_set_include_dependencies(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.common.v1.HealthCheckRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_;
    bool include_dependencies_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class HealthCheckResponse_DetailsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<HealthCheckResponse_DetailsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<HealthCheckResponse_DetailsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  HealthCheckResponse_DetailsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR HealthCheckResponse_DetailsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit HealthCheckResponse_DetailsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const HealthCheckResponse_DetailsEntry_DoNotUse& other);
  static const HealthCheckResponse_DetailsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const HealthCheckResponse_DetailsEntry_DoNotUse*>(&_HealthCheckResponse_DetailsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "unhinged.common.v1.HealthCheckResponse.DetailsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "unhinged.common.v1.HealthCheckResponse.DetailsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_common_2eproto;
};

// -------------------------------------------------------------------

class HealthCheckResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.common.v1.HealthCheckResponse) */ {
 public:
  inline HealthCheckResponse() : HealthCheckResponse(nullptr) {}
  ~HealthCheckResponse() override;
  explicit PROTOBUF_CONSTEXPR HealthCheckResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HealthCheckResponse(const HealthCheckResponse& from);
  HealthCheckResponse(HealthCheckResponse&& from) noexcept
    : HealthCheckResponse() {
    *this = ::std::move(from);
  }

  inline HealthCheckResponse& operator=(const HealthCheckResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline HealthCheckResponse& operator=(HealthCheckResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HealthCheckResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const HealthCheckResponse* internal_default_instance() {
    return reinterpret_cast<const HealthCheckResponse*>(
               &_HealthCheckResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(HealthCheckResponse& a, HealthCheckResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(HealthCheckResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HealthCheckResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HealthCheckResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HealthCheckResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HealthCheckResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HealthCheckResponse& from) {
    HealthCheckResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HealthCheckResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.common.v1.HealthCheckResponse";
  }
  protected:
  explicit HealthCheckResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kDetailsFieldNumber = 3,
    kMessageFieldNumber = 2,
    kCheckedAtFieldNumber = 4,
    kResponseTimeFieldNumber = 5,
    kStatusFieldNumber = 1,
  };
  // map<string, string> details = 3;
  int details_size() const;
  private:
  int _internal_details_size() const;
  public:
  void clear_details();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_details() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_details();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      details() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_details();

  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .google.protobuf.Timestamp checked_at = 4;
  bool has_checked_at() const;
  private:
  bool _internal_has_checked_at() const;
  public:
  void clear_checked_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& checked_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_checked_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_checked_at();
  void set_allocated_checked_at(::PROTOBUF_NAMESPACE_ID::Timestamp* checked_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_checked_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_checked_at();
  public:
  void unsafe_arena_set_allocated_checked_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* checked_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_checked_at();

  // .google.protobuf.Duration response_time = 5;
  bool has_response_time() const;
  private:
  bool _internal_has_response_time() const;
  public:
  void clear_response_time();
  const ::PROTOBUF_NAMESPACE_ID::Duration& response_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_response_time();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_response_time();
  void set_allocated_response_time(::PROTOBUF_NAMESPACE_ID::Duration* response_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_response_time() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_response_time();
  public:
  void unsafe_arena_set_allocated_response_time(
      ::PROTOBUF_NAMESPACE_ID::Duration* response_time);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_response_time();

  // .unhinged.common.v1.HealthStatus status = 1;
  void clear_status();
  ::unhinged::common::v1::HealthStatus status() const;
  void set_status(::unhinged::common::v1::HealthStatus value);
  private:
  ::unhinged::common::v1::HealthStatus _internal_status() const;
  void _internal_set_status(::unhinged::common::v1::HealthStatus value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.common.v1.HealthCheckResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        HealthCheckResponse_DetailsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> details_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* checked_at_;
    ::PROTOBUF_NAMESPACE_ID::Duration* response_time_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class StandardResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.common.v1.StandardResponse) */ {
 public:
  inline StandardResponse() : StandardResponse(nullptr) {}
  ~StandardResponse() override;
  explicit PROTOBUF_CONSTEXPR StandardResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StandardResponse(const StandardResponse& from);
  StandardResponse(StandardResponse&& from) noexcept
    : StandardResponse() {
    *this = ::std::move(from);
  }

  inline StandardResponse& operator=(const StandardResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StandardResponse& operator=(StandardResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StandardResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StandardResponse* internal_default_instance() {
    return reinterpret_cast<const StandardResponse*>(
               &_StandardResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(StandardResponse& a, StandardResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StandardResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StandardResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StandardResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StandardResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StandardResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StandardResponse& from) {
    StandardResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StandardResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.common.v1.StandardResponse";
  }
  protected:
  explicit StandardResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kRequestIdFieldNumber = 5,
    kErrorFieldNumber = 3,
    kMetadataFieldNumber = 4,
    kSuccessFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // string request_id = 5;
  void clear_request_id();
  const std::string& request_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_request_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_request_id();
  PROTOBUF_NODISCARD std::string* release_request_id();
  void set_allocated_request_id(std::string* request_id);
  private:
  const std::string& _internal_request_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_id(const std::string& value);
  std::string* _internal_mutable_request_id();
  public:

  // .unhinged.common.v1.Error error = 3;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::unhinged::common::v1::Error& error() const;
  PROTOBUF_NODISCARD ::unhinged::common::v1::Error* release_error();
  ::unhinged::common::v1::Error* mutable_error();
  void set_allocated_error(::unhinged::common::v1::Error* error);
  private:
  const ::unhinged::common::v1::Error& _internal_error() const;
  ::unhinged::common::v1::Error* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::unhinged::common::v1::Error* error);
  ::unhinged::common::v1::Error* unsafe_arena_release_error();

  // .google.protobuf.Struct metadata = 4;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::PROTOBUF_NAMESPACE_ID::Struct& metadata() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_metadata();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_metadata();
  void set_allocated_metadata(::PROTOBUF_NAMESPACE_ID::Struct* metadata);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::PROTOBUF_NAMESPACE_ID::Struct* metadata);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_metadata();

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:unhinged.common.v1.StandardResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_id_;
    ::unhinged::common::v1::Error* error_;
    ::PROTOBUF_NAMESPACE_ID::Struct* metadata_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class AuditInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:unhinged.common.v1.AuditInfo) */ {
 public:
  inline AuditInfo() : AuditInfo(nullptr) {}
  ~AuditInfo() override;
  explicit PROTOBUF_CONSTEXPR AuditInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuditInfo(const AuditInfo& from);
  AuditInfo(AuditInfo&& from) noexcept
    : AuditInfo() {
    *this = ::std::move(from);
  }

  inline AuditInfo& operator=(const AuditInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuditInfo& operator=(AuditInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuditInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuditInfo* internal_default_instance() {
    return reinterpret_cast<const AuditInfo*>(
               &_AuditInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(AuditInfo& a, AuditInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(AuditInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuditInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuditInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuditInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuditInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AuditInfo& from) {
    AuditInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuditInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "unhinged.common.v1.AuditInfo";
  }
  protected:
  explicit AuditInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kSessionIdFieldNumber = 2,
    kIpAddressFieldNumber = 3,
    kUserAgentFieldNumber = 4,
    kActionFieldNumber = 6,
    kTimestampFieldNumber = 5,
    kContextFieldNumber = 7,
  };
  // string user_id = 1;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string session_id = 2;
  void clear_session_id();
  const std::string& session_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // string ip_address = 3;
  void clear_ip_address();
  const std::string& ip_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip_address();
  PROTOBUF_NODISCARD std::string* release_ip_address();
  void set_allocated_ip_address(std::string* ip_address);
  private:
  const std::string& _internal_ip_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip_address(const std::string& value);
  std::string* _internal_mutable_ip_address();
  public:

  // string user_agent = 4;
  void clear_user_agent();
  const std::string& user_agent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_agent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_agent();
  PROTOBUF_NODISCARD std::string* release_user_agent();
  void set_allocated_user_agent(std::string* user_agent);
  private:
  const std::string& _internal_user_agent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_agent(const std::string& value);
  std::string* _internal_mutable_user_agent();
  public:

  // string action = 6;
  void clear_action();
  const std::string& action() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_action(ArgT0&& arg0, ArgT... args);
  std::string* mutable_action();
  PROTOBUF_NODISCARD std::string* release_action();
  void set_allocated_action(std::string* action);
  private:
  const std::string& _internal_action() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_action(const std::string& value);
  std::string* _internal_mutable_action();
  public:

  // .google.protobuf.Timestamp timestamp = 5;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // .google.protobuf.Struct context = 7;
  bool has_context() const;
  private:
  bool _internal_has_context() const;
  public:
  void clear_context();
  const ::PROTOBUF_NAMESPACE_ID::Struct& context() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_context();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_context();
  void set_allocated_context(::PROTOBUF_NAMESPACE_ID::Struct* context);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_context() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_context();
  public:
  void unsafe_arena_set_allocated_context(
      ::PROTOBUF_NAMESPACE_ID::Struct* context);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_context();

  // @@protoc_insertion_point(class_scope:unhinged.common.v1.AuditInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_agent_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr action_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
    ::PROTOBUF_NAMESPACE_ID::Struct* context_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ResourceMetadata

// string resource_id = 1;
inline void ResourceMetadata::clear_resource_id() {
  _impl_.resource_id_.ClearToEmpty();
}
inline const std::string& ResourceMetadata::resource_id() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.ResourceMetadata.resource_id)
  return _internal_resource_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResourceMetadata::set_resource_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.resource_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.common.v1.ResourceMetadata.resource_id)
}
inline std::string* ResourceMetadata::mutable_resource_id() {
  std::string* _s = _internal_mutable_resource_id();
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.ResourceMetadata.resource_id)
  return _s;
}
inline const std::string& ResourceMetadata::_internal_resource_id() const {
  return _impl_.resource_id_.Get();
}
inline void ResourceMetadata::_internal_set_resource_id(const std::string& value) {
  
  _impl_.resource_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ResourceMetadata::_internal_mutable_resource_id() {
  
  return _impl_.resource_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ResourceMetadata::release_resource_id() {
  // @@protoc_insertion_point(field_release:unhinged.common.v1.ResourceMetadata.resource_id)
  return _impl_.resource_id_.Release();
}
inline void ResourceMetadata::set_allocated_resource_id(std::string* resource_id) {
  if (resource_id != nullptr) {
    
  } else {
    
  }
  _impl_.resource_id_.SetAllocated(resource_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.resource_id_.IsDefault()) {
    _impl_.resource_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.common.v1.ResourceMetadata.resource_id)
}

// string team_id = 2;
inline void ResourceMetadata::clear_team_id() {
  _impl_.team_id_.ClearToEmpty();
}
inline const std::string& ResourceMetadata::team_id() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.ResourceMetadata.team_id)
  return _internal_team_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResourceMetadata::set_team_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.team_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.common.v1.ResourceMetadata.team_id)
}
inline std::string* ResourceMetadata::mutable_team_id() {
  std::string* _s = _internal_mutable_team_id();
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.ResourceMetadata.team_id)
  return _s;
}
inline const std::string& ResourceMetadata::_internal_team_id() const {
  return _impl_.team_id_.Get();
}
inline void ResourceMetadata::_internal_set_team_id(const std::string& value) {
  
  _impl_.team_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ResourceMetadata::_internal_mutable_team_id() {
  
  return _impl_.team_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ResourceMetadata::release_team_id() {
  // @@protoc_insertion_point(field_release:unhinged.common.v1.ResourceMetadata.team_id)
  return _impl_.team_id_.Release();
}
inline void ResourceMetadata::set_allocated_team_id(std::string* team_id) {
  if (team_id != nullptr) {
    
  } else {
    
  }
  _impl_.team_id_.SetAllocated(team_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.team_id_.IsDefault()) {
    _impl_.team_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.common.v1.ResourceMetadata.team_id)
}

// string namespace_id = 3;
inline void ResourceMetadata::clear_namespace_id() {
  _impl_.namespace_id_.ClearToEmpty();
}
inline const std::string& ResourceMetadata::namespace_id() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.ResourceMetadata.namespace_id)
  return _internal_namespace_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResourceMetadata::set_namespace_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.namespace_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.common.v1.ResourceMetadata.namespace_id)
}
inline std::string* ResourceMetadata::mutable_namespace_id() {
  std::string* _s = _internal_mutable_namespace_id();
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.ResourceMetadata.namespace_id)
  return _s;
}
inline const std::string& ResourceMetadata::_internal_namespace_id() const {
  return _impl_.namespace_id_.Get();
}
inline void ResourceMetadata::_internal_set_namespace_id(const std::string& value) {
  
  _impl_.namespace_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ResourceMetadata::_internal_mutable_namespace_id() {
  
  return _impl_.namespace_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ResourceMetadata::release_namespace_id() {
  // @@protoc_insertion_point(field_release:unhinged.common.v1.ResourceMetadata.namespace_id)
  return _impl_.namespace_id_.Release();
}
inline void ResourceMetadata::set_allocated_namespace_id(std::string* namespace_id) {
  if (namespace_id != nullptr) {
    
  } else {
    
  }
  _impl_.namespace_id_.SetAllocated(namespace_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.namespace_id_.IsDefault()) {
    _impl_.namespace_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.common.v1.ResourceMetadata.namespace_id)
}

// string created_by = 4;
inline void ResourceMetadata::clear_created_by() {
  _impl_.created_by_.ClearToEmpty();
}
inline const std::string& ResourceMetadata::created_by() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.ResourceMetadata.created_by)
  return _internal_created_by();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResourceMetadata::set_created_by(ArgT0&& arg0, ArgT... args) {
 
 _impl_.created_by_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.common.v1.ResourceMetadata.created_by)
}
inline std::string* ResourceMetadata::mutable_created_by() {
  std::string* _s = _internal_mutable_created_by();
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.ResourceMetadata.created_by)
  return _s;
}
inline const std::string& ResourceMetadata::_internal_created_by() const {
  return _impl_.created_by_.Get();
}
inline void ResourceMetadata::_internal_set_created_by(const std::string& value) {
  
  _impl_.created_by_.Set(value, GetArenaForAllocation());
}
inline std::string* ResourceMetadata::_internal_mutable_created_by() {
  
  return _impl_.created_by_.Mutable(GetArenaForAllocation());
}
inline std::string* ResourceMetadata::release_created_by() {
  // @@protoc_insertion_point(field_release:unhinged.common.v1.ResourceMetadata.created_by)
  return _impl_.created_by_.Release();
}
inline void ResourceMetadata::set_allocated_created_by(std::string* created_by) {
  if (created_by != nullptr) {
    
  } else {
    
  }
  _impl_.created_by_.SetAllocated(created_by, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.created_by_.IsDefault()) {
    _impl_.created_by_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.common.v1.ResourceMetadata.created_by)
}

// .google.protobuf.Timestamp created_at = 5;
inline bool ResourceMetadata::_internal_has_created_at() const {
  return this != internal_default_instance() && _impl_.created_at_ != nullptr;
}
inline bool ResourceMetadata::has_created_at() const {
  return _internal_has_created_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ResourceMetadata::_internal_created_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ResourceMetadata::created_at() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.ResourceMetadata.created_at)
  return _internal_created_at();
}
inline void ResourceMetadata::unsafe_arena_set_allocated_created_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = created_at;
  if (created_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.common.v1.ResourceMetadata.created_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ResourceMetadata::release_created_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ResourceMetadata::unsafe_arena_release_created_at() {
  // @@protoc_insertion_point(field_release:unhinged.common.v1.ResourceMetadata.created_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ResourceMetadata::_internal_mutable_created_at() {
  
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.created_at_ = p;
  }
  return _impl_.created_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ResourceMetadata::mutable_created_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.ResourceMetadata.created_at)
  return _msg;
}
inline void ResourceMetadata::set_allocated_created_at(::PROTOBUF_NAMESPACE_ID::Timestamp* created_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_at_);
  }
  if (created_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_at));
    if (message_arena != submessage_arena) {
      created_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.created_at_ = created_at;
  // @@protoc_insertion_point(field_set_allocated:unhinged.common.v1.ResourceMetadata.created_at)
}

// .google.protobuf.Timestamp updated_at = 6;
inline bool ResourceMetadata::_internal_has_updated_at() const {
  return this != internal_default_instance() && _impl_.updated_at_ != nullptr;
}
inline bool ResourceMetadata::has_updated_at() const {
  return _internal_has_updated_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ResourceMetadata::_internal_updated_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.updated_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ResourceMetadata::updated_at() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.ResourceMetadata.updated_at)
  return _internal_updated_at();
}
inline void ResourceMetadata::unsafe_arena_set_allocated_updated_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.updated_at_);
  }
  _impl_.updated_at_ = updated_at;
  if (updated_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.common.v1.ResourceMetadata.updated_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ResourceMetadata::release_updated_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.updated_at_;
  _impl_.updated_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ResourceMetadata::unsafe_arena_release_updated_at() {
  // @@protoc_insertion_point(field_release:unhinged.common.v1.ResourceMetadata.updated_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.updated_at_;
  _impl_.updated_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ResourceMetadata::_internal_mutable_updated_at() {
  
  if (_impl_.updated_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.updated_at_ = p;
  }
  return _impl_.updated_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ResourceMetadata::mutable_updated_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_updated_at();
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.ResourceMetadata.updated_at)
  return _msg;
}
inline void ResourceMetadata::set_allocated_updated_at(::PROTOBUF_NAMESPACE_ID::Timestamp* updated_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.updated_at_);
  }
  if (updated_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(updated_at));
    if (message_arena != submessage_arena) {
      updated_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, updated_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.updated_at_ = updated_at;
  // @@protoc_insertion_point(field_set_allocated:unhinged.common.v1.ResourceMetadata.updated_at)
}

// .google.protobuf.Struct custom_metadata = 7;
inline bool ResourceMetadata::_internal_has_custom_metadata() const {
  return this != internal_default_instance() && _impl_.custom_metadata_ != nullptr;
}
inline bool ResourceMetadata::has_custom_metadata() const {
  return _internal_has_custom_metadata();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& ResourceMetadata::_internal_custom_metadata() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.custom_metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& ResourceMetadata::custom_metadata() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.ResourceMetadata.custom_metadata)
  return _internal_custom_metadata();
}
inline void ResourceMetadata::unsafe_arena_set_allocated_custom_metadata(
    ::PROTOBUF_NAMESPACE_ID::Struct* custom_metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.custom_metadata_);
  }
  _impl_.custom_metadata_ = custom_metadata;
  if (custom_metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.common.v1.ResourceMetadata.custom_metadata)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ResourceMetadata::release_custom_metadata() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.custom_metadata_;
  _impl_.custom_metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ResourceMetadata::unsafe_arena_release_custom_metadata() {
  // @@protoc_insertion_point(field_release:unhinged.common.v1.ResourceMetadata.custom_metadata)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.custom_metadata_;
  _impl_.custom_metadata_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ResourceMetadata::_internal_mutable_custom_metadata() {
  
  if (_impl_.custom_metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.custom_metadata_ = p;
  }
  return _impl_.custom_metadata_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ResourceMetadata::mutable_custom_metadata() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_custom_metadata();
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.ResourceMetadata.custom_metadata)
  return _msg;
}
inline void ResourceMetadata::set_allocated_custom_metadata(::PROTOBUF_NAMESPACE_ID::Struct* custom_metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.custom_metadata_);
  }
  if (custom_metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(custom_metadata));
    if (message_arena != submessage_arena) {
      custom_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, custom_metadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.custom_metadata_ = custom_metadata;
  // @@protoc_insertion_point(field_set_allocated:unhinged.common.v1.ResourceMetadata.custom_metadata)
}

// int32 version = 8;
inline void ResourceMetadata::clear_version() {
  _impl_.version_ = 0;
}
inline int32_t ResourceMetadata::_internal_version() const {
  return _impl_.version_;
}
inline int32_t ResourceMetadata::version() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.ResourceMetadata.version)
  return _internal_version();
}
inline void ResourceMetadata::_internal_set_version(int32_t value) {
  
  _impl_.version_ = value;
}
inline void ResourceMetadata::set_version(int32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:unhinged.common.v1.ResourceMetadata.version)
}

// repeated string tags = 9;
inline int ResourceMetadata::_internal_tags_size() const {
  return _impl_.tags_.size();
}
inline int ResourceMetadata::tags_size() const {
  return _internal_tags_size();
}
inline void ResourceMetadata::clear_tags() {
  _impl_.tags_.Clear();
}
inline std::string* ResourceMetadata::add_tags() {
  std::string* _s = _internal_add_tags();
  // @@protoc_insertion_point(field_add_mutable:unhinged.common.v1.ResourceMetadata.tags)
  return _s;
}
inline const std::string& ResourceMetadata::_internal_tags(int index) const {
  return _impl_.tags_.Get(index);
}
inline const std::string& ResourceMetadata::tags(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.ResourceMetadata.tags)
  return _internal_tags(index);
}
inline std::string* ResourceMetadata::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.ResourceMetadata.tags)
  return _impl_.tags_.Mutable(index);
}
inline void ResourceMetadata::set_tags(int index, const std::string& value) {
  _impl_.tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.common.v1.ResourceMetadata.tags)
}
inline void ResourceMetadata::set_tags(int index, std::string&& value) {
  _impl_.tags_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.common.v1.ResourceMetadata.tags)
}
inline void ResourceMetadata::set_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.common.v1.ResourceMetadata.tags)
}
inline void ResourceMetadata::set_tags(int index, const char* value, size_t size) {
  _impl_.tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.common.v1.ResourceMetadata.tags)
}
inline std::string* ResourceMetadata::_internal_add_tags() {
  return _impl_.tags_.Add();
}
inline void ResourceMetadata::add_tags(const std::string& value) {
  _impl_.tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.common.v1.ResourceMetadata.tags)
}
inline void ResourceMetadata::add_tags(std::string&& value) {
  _impl_.tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.common.v1.ResourceMetadata.tags)
}
inline void ResourceMetadata::add_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.common.v1.ResourceMetadata.tags)
}
inline void ResourceMetadata::add_tags(const char* value, size_t size) {
  _impl_.tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.common.v1.ResourceMetadata.tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ResourceMetadata::tags() const {
  // @@protoc_insertion_point(field_list:unhinged.common.v1.ResourceMetadata.tags)
  return _impl_.tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ResourceMetadata::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.common.v1.ResourceMetadata.tags)
  return &_impl_.tags_;
}

// -------------------------------------------------------------------

// ResourceReference

// string resource_type = 1;
inline void ResourceReference::clear_resource_type() {
  _impl_.resource_type_.ClearToEmpty();
}
inline const std::string& ResourceReference::resource_type() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.ResourceReference.resource_type)
  return _internal_resource_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResourceReference::set_resource_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.resource_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.common.v1.ResourceReference.resource_type)
}
inline std::string* ResourceReference::mutable_resource_type() {
  std::string* _s = _internal_mutable_resource_type();
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.ResourceReference.resource_type)
  return _s;
}
inline const std::string& ResourceReference::_internal_resource_type() const {
  return _impl_.resource_type_.Get();
}
inline void ResourceReference::_internal_set_resource_type(const std::string& value) {
  
  _impl_.resource_type_.Set(value, GetArenaForAllocation());
}
inline std::string* ResourceReference::_internal_mutable_resource_type() {
  
  return _impl_.resource_type_.Mutable(GetArenaForAllocation());
}
inline std::string* ResourceReference::release_resource_type() {
  // @@protoc_insertion_point(field_release:unhinged.common.v1.ResourceReference.resource_type)
  return _impl_.resource_type_.Release();
}
inline void ResourceReference::set_allocated_resource_type(std::string* resource_type) {
  if (resource_type != nullptr) {
    
  } else {
    
  }
  _impl_.resource_type_.SetAllocated(resource_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.resource_type_.IsDefault()) {
    _impl_.resource_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.common.v1.ResourceReference.resource_type)
}

// string resource_id = 2;
inline void ResourceReference::clear_resource_id() {
  _impl_.resource_id_.ClearToEmpty();
}
inline const std::string& ResourceReference::resource_id() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.ResourceReference.resource_id)
  return _internal_resource_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResourceReference::set_resource_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.resource_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.common.v1.ResourceReference.resource_id)
}
inline std::string* ResourceReference::mutable_resource_id() {
  std::string* _s = _internal_mutable_resource_id();
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.ResourceReference.resource_id)
  return _s;
}
inline const std::string& ResourceReference::_internal_resource_id() const {
  return _impl_.resource_id_.Get();
}
inline void ResourceReference::_internal_set_resource_id(const std::string& value) {
  
  _impl_.resource_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ResourceReference::_internal_mutable_resource_id() {
  
  return _impl_.resource_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ResourceReference::release_resource_id() {
  // @@protoc_insertion_point(field_release:unhinged.common.v1.ResourceReference.resource_id)
  return _impl_.resource_id_.Release();
}
inline void ResourceReference::set_allocated_resource_id(std::string* resource_id) {
  if (resource_id != nullptr) {
    
  } else {
    
  }
  _impl_.resource_id_.SetAllocated(resource_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.resource_id_.IsDefault()) {
    _impl_.resource_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.common.v1.ResourceReference.resource_id)
}

// string display_name = 3;
inline void ResourceReference::clear_display_name() {
  _impl_.display_name_.ClearToEmpty();
}
inline const std::string& ResourceReference::display_name() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.ResourceReference.display_name)
  return _internal_display_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResourceReference::set_display_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.display_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.common.v1.ResourceReference.display_name)
}
inline std::string* ResourceReference::mutable_display_name() {
  std::string* _s = _internal_mutable_display_name();
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.ResourceReference.display_name)
  return _s;
}
inline const std::string& ResourceReference::_internal_display_name() const {
  return _impl_.display_name_.Get();
}
inline void ResourceReference::_internal_set_display_name(const std::string& value) {
  
  _impl_.display_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ResourceReference::_internal_mutable_display_name() {
  
  return _impl_.display_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ResourceReference::release_display_name() {
  // @@protoc_insertion_point(field_release:unhinged.common.v1.ResourceReference.display_name)
  return _impl_.display_name_.Release();
}
inline void ResourceReference::set_allocated_display_name(std::string* display_name) {
  if (display_name != nullptr) {
    
  } else {
    
  }
  _impl_.display_name_.SetAllocated(display_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.display_name_.IsDefault()) {
    _impl_.display_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.common.v1.ResourceReference.display_name)
}

// string url = 4;
inline void ResourceReference::clear_url() {
  _impl_.url_.ClearToEmpty();
}
inline const std::string& ResourceReference::url() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.ResourceReference.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResourceReference::set_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.common.v1.ResourceReference.url)
}
inline std::string* ResourceReference::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.ResourceReference.url)
  return _s;
}
inline const std::string& ResourceReference::_internal_url() const {
  return _impl_.url_.Get();
}
inline void ResourceReference::_internal_set_url(const std::string& value) {
  
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* ResourceReference::_internal_mutable_url() {
  
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* ResourceReference::release_url() {
  // @@protoc_insertion_point(field_release:unhinged.common.v1.ResourceReference.url)
  return _impl_.url_.Release();
}
inline void ResourceReference::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.common.v1.ResourceReference.url)
}

// -------------------------------------------------------------------

// PaginationRequest

// int32 page_size = 1;
inline void PaginationRequest::clear_page_size() {
  _impl_.page_size_ = 0;
}
inline int32_t PaginationRequest::_internal_page_size() const {
  return _impl_.page_size_;
}
inline int32_t PaginationRequest::page_size() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.PaginationRequest.page_size)
  return _internal_page_size();
}
inline void PaginationRequest::_internal_set_page_size(int32_t value) {
  
  _impl_.page_size_ = value;
}
inline void PaginationRequest::set_page_size(int32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:unhinged.common.v1.PaginationRequest.page_size)
}

// string page_token = 2;
inline void PaginationRequest::clear_page_token() {
  _impl_.page_token_.ClearToEmpty();
}
inline const std::string& PaginationRequest::page_token() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.PaginationRequest.page_token)
  return _internal_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PaginationRequest::set_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.common.v1.PaginationRequest.page_token)
}
inline std::string* PaginationRequest::mutable_page_token() {
  std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.PaginationRequest.page_token)
  return _s;
}
inline const std::string& PaginationRequest::_internal_page_token() const {
  return _impl_.page_token_.Get();
}
inline void PaginationRequest::_internal_set_page_token(const std::string& value) {
  
  _impl_.page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* PaginationRequest::_internal_mutable_page_token() {
  
  return _impl_.page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* PaginationRequest::release_page_token() {
  // @@protoc_insertion_point(field_release:unhinged.common.v1.PaginationRequest.page_token)
  return _impl_.page_token_.Release();
}
inline void PaginationRequest::set_allocated_page_token(std::string* page_token) {
  if (page_token != nullptr) {
    
  } else {
    
  }
  _impl_.page_token_.SetAllocated(page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.page_token_.IsDefault()) {
    _impl_.page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.common.v1.PaginationRequest.page_token)
}

// string order_by = 3;
inline void PaginationRequest::clear_order_by() {
  _impl_.order_by_.ClearToEmpty();
}
inline const std::string& PaginationRequest::order_by() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.PaginationRequest.order_by)
  return _internal_order_by();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PaginationRequest::set_order_by(ArgT0&& arg0, ArgT... args) {
 
 _impl_.order_by_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.common.v1.PaginationRequest.order_by)
}
inline std::string* PaginationRequest::mutable_order_by() {
  std::string* _s = _internal_mutable_order_by();
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.PaginationRequest.order_by)
  return _s;
}
inline const std::string& PaginationRequest::_internal_order_by() const {
  return _impl_.order_by_.Get();
}
inline void PaginationRequest::_internal_set_order_by(const std::string& value) {
  
  _impl_.order_by_.Set(value, GetArenaForAllocation());
}
inline std::string* PaginationRequest::_internal_mutable_order_by() {
  
  return _impl_.order_by_.Mutable(GetArenaForAllocation());
}
inline std::string* PaginationRequest::release_order_by() {
  // @@protoc_insertion_point(field_release:unhinged.common.v1.PaginationRequest.order_by)
  return _impl_.order_by_.Release();
}
inline void PaginationRequest::set_allocated_order_by(std::string* order_by) {
  if (order_by != nullptr) {
    
  } else {
    
  }
  _impl_.order_by_.SetAllocated(order_by, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.order_by_.IsDefault()) {
    _impl_.order_by_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.common.v1.PaginationRequest.order_by)
}

// -------------------------------------------------------------------

// PaginationResponse

// string next_page_token = 1;
inline void PaginationResponse::clear_next_page_token() {
  _impl_.next_page_token_.ClearToEmpty();
}
inline const std::string& PaginationResponse::next_page_token() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.PaginationResponse.next_page_token)
  return _internal_next_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PaginationResponse::set_next_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.next_page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.common.v1.PaginationResponse.next_page_token)
}
inline std::string* PaginationResponse::mutable_next_page_token() {
  std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.PaginationResponse.next_page_token)
  return _s;
}
inline const std::string& PaginationResponse::_internal_next_page_token() const {
  return _impl_.next_page_token_.Get();
}
inline void PaginationResponse::_internal_set_next_page_token(const std::string& value) {
  
  _impl_.next_page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* PaginationResponse::_internal_mutable_next_page_token() {
  
  return _impl_.next_page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* PaginationResponse::release_next_page_token() {
  // @@protoc_insertion_point(field_release:unhinged.common.v1.PaginationResponse.next_page_token)
  return _impl_.next_page_token_.Release();
}
inline void PaginationResponse::set_allocated_next_page_token(std::string* next_page_token) {
  if (next_page_token != nullptr) {
    
  } else {
    
  }
  _impl_.next_page_token_.SetAllocated(next_page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.next_page_token_.IsDefault()) {
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.common.v1.PaginationResponse.next_page_token)
}

// int32 total_count = 2;
inline void PaginationResponse::clear_total_count() {
  _impl_.total_count_ = 0;
}
inline int32_t PaginationResponse::_internal_total_count() const {
  return _impl_.total_count_;
}
inline int32_t PaginationResponse::total_count() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.PaginationResponse.total_count)
  return _internal_total_count();
}
inline void PaginationResponse::_internal_set_total_count(int32_t value) {
  
  _impl_.total_count_ = value;
}
inline void PaginationResponse::set_total_count(int32_t value) {
  _internal_set_total_count(value);
  // @@protoc_insertion_point(field_set:unhinged.common.v1.PaginationResponse.total_count)
}

// bool has_more = 3;
inline void PaginationResponse::clear_has_more() {
  _impl_.has_more_ = false;
}
inline bool PaginationResponse::_internal_has_more() const {
  return _impl_.has_more_;
}
inline bool PaginationResponse::has_more() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.PaginationResponse.has_more)
  return _internal_has_more();
}
inline void PaginationResponse::_internal_set_has_more(bool value) {
  
  _impl_.has_more_ = value;
}
inline void PaginationResponse::set_has_more(bool value) {
  _internal_set_has_more(value);
  // @@protoc_insertion_point(field_set:unhinged.common.v1.PaginationResponse.has_more)
}

// int32 page_size = 4;
inline void PaginationResponse::clear_page_size() {
  _impl_.page_size_ = 0;
}
inline int32_t PaginationResponse::_internal_page_size() const {
  return _impl_.page_size_;
}
inline int32_t PaginationResponse::page_size() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.PaginationResponse.page_size)
  return _internal_page_size();
}
inline void PaginationResponse::_internal_set_page_size(int32_t value) {
  
  _impl_.page_size_ = value;
}
inline void PaginationResponse::set_page_size(int32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:unhinged.common.v1.PaginationResponse.page_size)
}

// -------------------------------------------------------------------

// StreamChunk

// string stream_id = 1;
inline void StreamChunk::clear_stream_id() {
  _impl_.stream_id_.ClearToEmpty();
}
inline const std::string& StreamChunk::stream_id() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.StreamChunk.stream_id)
  return _internal_stream_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamChunk::set_stream_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.stream_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.common.v1.StreamChunk.stream_id)
}
inline std::string* StreamChunk::mutable_stream_id() {
  std::string* _s = _internal_mutable_stream_id();
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.StreamChunk.stream_id)
  return _s;
}
inline const std::string& StreamChunk::_internal_stream_id() const {
  return _impl_.stream_id_.Get();
}
inline void StreamChunk::_internal_set_stream_id(const std::string& value) {
  
  _impl_.stream_id_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamChunk::_internal_mutable_stream_id() {
  
  return _impl_.stream_id_.Mutable(GetArenaForAllocation());
}
inline std::string* StreamChunk::release_stream_id() {
  // @@protoc_insertion_point(field_release:unhinged.common.v1.StreamChunk.stream_id)
  return _impl_.stream_id_.Release();
}
inline void StreamChunk::set_allocated_stream_id(std::string* stream_id) {
  if (stream_id != nullptr) {
    
  } else {
    
  }
  _impl_.stream_id_.SetAllocated(stream_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stream_id_.IsDefault()) {
    _impl_.stream_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.common.v1.StreamChunk.stream_id)
}

// int32 sequence_number = 2;
inline void StreamChunk::clear_sequence_number() {
  _impl_.sequence_number_ = 0;
}
inline int32_t StreamChunk::_internal_sequence_number() const {
  return _impl_.sequence_number_;
}
inline int32_t StreamChunk::sequence_number() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.StreamChunk.sequence_number)
  return _internal_sequence_number();
}
inline void StreamChunk::_internal_set_sequence_number(int32_t value) {
  
  _impl_.sequence_number_ = value;
}
inline void StreamChunk::set_sequence_number(int32_t value) {
  _internal_set_sequence_number(value);
  // @@protoc_insertion_point(field_set:unhinged.common.v1.StreamChunk.sequence_number)
}

// .unhinged.common.v1.ChunkType type = 3;
inline void StreamChunk::clear_type() {
  _impl_.type_ = 0;
}
inline ::unhinged::common::v1::ChunkType StreamChunk::_internal_type() const {
  return static_cast< ::unhinged::common::v1::ChunkType >(_impl_.type_);
}
inline ::unhinged::common::v1::ChunkType StreamChunk::type() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.StreamChunk.type)
  return _internal_type();
}
inline void StreamChunk::_internal_set_type(::unhinged::common::v1::ChunkType value) {
  
  _impl_.type_ = value;
}
inline void StreamChunk::set_type(::unhinged::common::v1::ChunkType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:unhinged.common.v1.StreamChunk.type)
}

// bytes data = 4;
inline void StreamChunk::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& StreamChunk::data() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.StreamChunk.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamChunk::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.common.v1.StreamChunk.data)
}
inline std::string* StreamChunk::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.StreamChunk.data)
  return _s;
}
inline const std::string& StreamChunk::_internal_data() const {
  return _impl_.data_.Get();
}
inline void StreamChunk::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamChunk::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* StreamChunk::release_data() {
  // @@protoc_insertion_point(field_release:unhinged.common.v1.StreamChunk.data)
  return _impl_.data_.Release();
}
inline void StreamChunk::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.common.v1.StreamChunk.data)
}

// string text = 5;
inline void StreamChunk::clear_text() {
  _impl_.text_.ClearToEmpty();
}
inline const std::string& StreamChunk::text() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.StreamChunk.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamChunk::set_text(ArgT0&& arg0, ArgT... args) {
 
 _impl_.text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.common.v1.StreamChunk.text)
}
inline std::string* StreamChunk::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.StreamChunk.text)
  return _s;
}
inline const std::string& StreamChunk::_internal_text() const {
  return _impl_.text_.Get();
}
inline void StreamChunk::_internal_set_text(const std::string& value) {
  
  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamChunk::_internal_mutable_text() {
  
  return _impl_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* StreamChunk::release_text() {
  // @@protoc_insertion_point(field_release:unhinged.common.v1.StreamChunk.text)
  return _impl_.text_.Release();
}
inline void StreamChunk::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  _impl_.text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.common.v1.StreamChunk.text)
}

// .google.protobuf.Struct structured = 6;
inline bool StreamChunk::_internal_has_structured() const {
  return this != internal_default_instance() && _impl_.structured_ != nullptr;
}
inline bool StreamChunk::has_structured() const {
  return _internal_has_structured();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& StreamChunk::_internal_structured() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.structured_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& StreamChunk::structured() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.StreamChunk.structured)
  return _internal_structured();
}
inline void StreamChunk::unsafe_arena_set_allocated_structured(
    ::PROTOBUF_NAMESPACE_ID::Struct* structured) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.structured_);
  }
  _impl_.structured_ = structured;
  if (structured) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.common.v1.StreamChunk.structured)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* StreamChunk::release_structured() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.structured_;
  _impl_.structured_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* StreamChunk::unsafe_arena_release_structured() {
  // @@protoc_insertion_point(field_release:unhinged.common.v1.StreamChunk.structured)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.structured_;
  _impl_.structured_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* StreamChunk::_internal_mutable_structured() {
  
  if (_impl_.structured_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.structured_ = p;
  }
  return _impl_.structured_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* StreamChunk::mutable_structured() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_structured();
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.StreamChunk.structured)
  return _msg;
}
inline void StreamChunk::set_allocated_structured(::PROTOBUF_NAMESPACE_ID::Struct* structured) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.structured_);
  }
  if (structured) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(structured));
    if (message_arena != submessage_arena) {
      structured = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, structured, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.structured_ = structured;
  // @@protoc_insertion_point(field_set_allocated:unhinged.common.v1.StreamChunk.structured)
}

// .google.protobuf.Struct metadata = 7;
inline bool StreamChunk::_internal_has_metadata() const {
  return this != internal_default_instance() && _impl_.metadata_ != nullptr;
}
inline bool StreamChunk::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& StreamChunk::_internal_metadata() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& StreamChunk::metadata() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.StreamChunk.metadata)
  return _internal_metadata();
}
inline void StreamChunk::unsafe_arena_set_allocated_metadata(
    ::PROTOBUF_NAMESPACE_ID::Struct* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.common.v1.StreamChunk.metadata)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* StreamChunk::release_metadata() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* StreamChunk::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:unhinged.common.v1.StreamChunk.metadata)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* StreamChunk::_internal_mutable_metadata() {
  
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* StreamChunk::mutable_metadata() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.StreamChunk.metadata)
  return _msg;
}
inline void StreamChunk::set_allocated_metadata(::PROTOBUF_NAMESPACE_ID::Struct* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:unhinged.common.v1.StreamChunk.metadata)
}

// bool is_final = 8;
inline void StreamChunk::clear_is_final() {
  _impl_.is_final_ = false;
}
inline bool StreamChunk::_internal_is_final() const {
  return _impl_.is_final_;
}
inline bool StreamChunk::is_final() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.StreamChunk.is_final)
  return _internal_is_final();
}
inline void StreamChunk::_internal_set_is_final(bool value) {
  
  _impl_.is_final_ = value;
}
inline void StreamChunk::set_is_final(bool value) {
  _internal_set_is_final(value);
  // @@protoc_insertion_point(field_set:unhinged.common.v1.StreamChunk.is_final)
}

// .unhinged.common.v1.ChunkStatus status = 9;
inline void StreamChunk::clear_status() {
  _impl_.status_ = 0;
}
inline ::unhinged::common::v1::ChunkStatus StreamChunk::_internal_status() const {
  return static_cast< ::unhinged::common::v1::ChunkStatus >(_impl_.status_);
}
inline ::unhinged::common::v1::ChunkStatus StreamChunk::status() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.StreamChunk.status)
  return _internal_status();
}
inline void StreamChunk::_internal_set_status(::unhinged::common::v1::ChunkStatus value) {
  
  _impl_.status_ = value;
}
inline void StreamChunk::set_status(::unhinged::common::v1::ChunkStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:unhinged.common.v1.StreamChunk.status)
}

// .google.protobuf.Timestamp timestamp = 10;
inline bool StreamChunk::_internal_has_timestamp() const {
  return this != internal_default_instance() && _impl_.timestamp_ != nullptr;
}
inline bool StreamChunk::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& StreamChunk::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& StreamChunk::timestamp() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.StreamChunk.timestamp)
  return _internal_timestamp();
}
inline void StreamChunk::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.common.v1.StreamChunk.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* StreamChunk::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* StreamChunk::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:unhinged.common.v1.StreamChunk.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* StreamChunk::_internal_mutable_timestamp() {
  
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* StreamChunk::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.StreamChunk.timestamp)
  return _msg;
}
inline void StreamChunk::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:unhinged.common.v1.StreamChunk.timestamp)
}

// -------------------------------------------------------------------

// UsageMetrics

// .unhinged.common.v1.TokenUsage tokens = 1;
inline bool UsageMetrics::_internal_has_tokens() const {
  return metric_case() == kTokens;
}
inline bool UsageMetrics::has_tokens() const {
  return _internal_has_tokens();
}
inline void UsageMetrics::set_has_tokens() {
  _impl_._oneof_case_[0] = kTokens;
}
inline void UsageMetrics::clear_tokens() {
  if (_internal_has_tokens()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.metric_.tokens_;
    }
    clear_has_metric();
  }
}
inline ::unhinged::common::v1::TokenUsage* UsageMetrics::release_tokens() {
  // @@protoc_insertion_point(field_release:unhinged.common.v1.UsageMetrics.tokens)
  if (_internal_has_tokens()) {
    clear_has_metric();
    ::unhinged::common::v1::TokenUsage* temp = _impl_.metric_.tokens_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.metric_.tokens_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::common::v1::TokenUsage& UsageMetrics::_internal_tokens() const {
  return _internal_has_tokens()
      ? *_impl_.metric_.tokens_
      : reinterpret_cast< ::unhinged::common::v1::TokenUsage&>(::unhinged::common::v1::_TokenUsage_default_instance_);
}
inline const ::unhinged::common::v1::TokenUsage& UsageMetrics::tokens() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.UsageMetrics.tokens)
  return _internal_tokens();
}
inline ::unhinged::common::v1::TokenUsage* UsageMetrics::unsafe_arena_release_tokens() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.common.v1.UsageMetrics.tokens)
  if (_internal_has_tokens()) {
    clear_has_metric();
    ::unhinged::common::v1::TokenUsage* temp = _impl_.metric_.tokens_;
    _impl_.metric_.tokens_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UsageMetrics::unsafe_arena_set_allocated_tokens(::unhinged::common::v1::TokenUsage* tokens) {
  clear_metric();
  if (tokens) {
    set_has_tokens();
    _impl_.metric_.tokens_ = tokens;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.common.v1.UsageMetrics.tokens)
}
inline ::unhinged::common::v1::TokenUsage* UsageMetrics::_internal_mutable_tokens() {
  if (!_internal_has_tokens()) {
    clear_metric();
    set_has_tokens();
    _impl_.metric_.tokens_ = CreateMaybeMessage< ::unhinged::common::v1::TokenUsage >(GetArenaForAllocation());
  }
  return _impl_.metric_.tokens_;
}
inline ::unhinged::common::v1::TokenUsage* UsageMetrics::mutable_tokens() {
  ::unhinged::common::v1::TokenUsage* _msg = _internal_mutable_tokens();
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.UsageMetrics.tokens)
  return _msg;
}

// .unhinged.common.v1.AudioUsage audio = 2;
inline bool UsageMetrics::_internal_has_audio() const {
  return metric_case() == kAudio;
}
inline bool UsageMetrics::has_audio() const {
  return _internal_has_audio();
}
inline void UsageMetrics::set_has_audio() {
  _impl_._oneof_case_[0] = kAudio;
}
inline void UsageMetrics::clear_audio() {
  if (_internal_has_audio()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.metric_.audio_;
    }
    clear_has_metric();
  }
}
inline ::unhinged::common::v1::AudioUsage* UsageMetrics::release_audio() {
  // @@protoc_insertion_point(field_release:unhinged.common.v1.UsageMetrics.audio)
  if (_internal_has_audio()) {
    clear_has_metric();
    ::unhinged::common::v1::AudioUsage* temp = _impl_.metric_.audio_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.metric_.audio_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::common::v1::AudioUsage& UsageMetrics::_internal_audio() const {
  return _internal_has_audio()
      ? *_impl_.metric_.audio_
      : reinterpret_cast< ::unhinged::common::v1::AudioUsage&>(::unhinged::common::v1::_AudioUsage_default_instance_);
}
inline const ::unhinged::common::v1::AudioUsage& UsageMetrics::audio() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.UsageMetrics.audio)
  return _internal_audio();
}
inline ::unhinged::common::v1::AudioUsage* UsageMetrics::unsafe_arena_release_audio() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.common.v1.UsageMetrics.audio)
  if (_internal_has_audio()) {
    clear_has_metric();
    ::unhinged::common::v1::AudioUsage* temp = _impl_.metric_.audio_;
    _impl_.metric_.audio_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UsageMetrics::unsafe_arena_set_allocated_audio(::unhinged::common::v1::AudioUsage* audio) {
  clear_metric();
  if (audio) {
    set_has_audio();
    _impl_.metric_.audio_ = audio;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.common.v1.UsageMetrics.audio)
}
inline ::unhinged::common::v1::AudioUsage* UsageMetrics::_internal_mutable_audio() {
  if (!_internal_has_audio()) {
    clear_metric();
    set_has_audio();
    _impl_.metric_.audio_ = CreateMaybeMessage< ::unhinged::common::v1::AudioUsage >(GetArenaForAllocation());
  }
  return _impl_.metric_.audio_;
}
inline ::unhinged::common::v1::AudioUsage* UsageMetrics::mutable_audio() {
  ::unhinged::common::v1::AudioUsage* _msg = _internal_mutable_audio();
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.UsageMetrics.audio)
  return _msg;
}

// .unhinged.common.v1.DataUsage data = 3;
inline bool UsageMetrics::_internal_has_data() const {
  return metric_case() == kData;
}
inline bool UsageMetrics::has_data() const {
  return _internal_has_data();
}
inline void UsageMetrics::set_has_data() {
  _impl_._oneof_case_[0] = kData;
}
inline void UsageMetrics::clear_data() {
  if (_internal_has_data()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.metric_.data_;
    }
    clear_has_metric();
  }
}
inline ::unhinged::common::v1::DataUsage* UsageMetrics::release_data() {
  // @@protoc_insertion_point(field_release:unhinged.common.v1.UsageMetrics.data)
  if (_internal_has_data()) {
    clear_has_metric();
    ::unhinged::common::v1::DataUsage* temp = _impl_.metric_.data_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.metric_.data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::common::v1::DataUsage& UsageMetrics::_internal_data() const {
  return _internal_has_data()
      ? *_impl_.metric_.data_
      : reinterpret_cast< ::unhinged::common::v1::DataUsage&>(::unhinged::common::v1::_DataUsage_default_instance_);
}
inline const ::unhinged::common::v1::DataUsage& UsageMetrics::data() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.UsageMetrics.data)
  return _internal_data();
}
inline ::unhinged::common::v1::DataUsage* UsageMetrics::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.common.v1.UsageMetrics.data)
  if (_internal_has_data()) {
    clear_has_metric();
    ::unhinged::common::v1::DataUsage* temp = _impl_.metric_.data_;
    _impl_.metric_.data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UsageMetrics::unsafe_arena_set_allocated_data(::unhinged::common::v1::DataUsage* data) {
  clear_metric();
  if (data) {
    set_has_data();
    _impl_.metric_.data_ = data;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.common.v1.UsageMetrics.data)
}
inline ::unhinged::common::v1::DataUsage* UsageMetrics::_internal_mutable_data() {
  if (!_internal_has_data()) {
    clear_metric();
    set_has_data();
    _impl_.metric_.data_ = CreateMaybeMessage< ::unhinged::common::v1::DataUsage >(GetArenaForAllocation());
  }
  return _impl_.metric_.data_;
}
inline ::unhinged::common::v1::DataUsage* UsageMetrics::mutable_data() {
  ::unhinged::common::v1::DataUsage* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.UsageMetrics.data)
  return _msg;
}

// .unhinged.common.v1.ComputeUsage compute = 4;
inline bool UsageMetrics::_internal_has_compute() const {
  return metric_case() == kCompute;
}
inline bool UsageMetrics::has_compute() const {
  return _internal_has_compute();
}
inline void UsageMetrics::set_has_compute() {
  _impl_._oneof_case_[0] = kCompute;
}
inline void UsageMetrics::clear_compute() {
  if (_internal_has_compute()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.metric_.compute_;
    }
    clear_has_metric();
  }
}
inline ::unhinged::common::v1::ComputeUsage* UsageMetrics::release_compute() {
  // @@protoc_insertion_point(field_release:unhinged.common.v1.UsageMetrics.compute)
  if (_internal_has_compute()) {
    clear_has_metric();
    ::unhinged::common::v1::ComputeUsage* temp = _impl_.metric_.compute_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.metric_.compute_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::unhinged::common::v1::ComputeUsage& UsageMetrics::_internal_compute() const {
  return _internal_has_compute()
      ? *_impl_.metric_.compute_
      : reinterpret_cast< ::unhinged::common::v1::ComputeUsage&>(::unhinged::common::v1::_ComputeUsage_default_instance_);
}
inline const ::unhinged::common::v1::ComputeUsage& UsageMetrics::compute() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.UsageMetrics.compute)
  return _internal_compute();
}
inline ::unhinged::common::v1::ComputeUsage* UsageMetrics::unsafe_arena_release_compute() {
  // @@protoc_insertion_point(field_unsafe_arena_release:unhinged.common.v1.UsageMetrics.compute)
  if (_internal_has_compute()) {
    clear_has_metric();
    ::unhinged::common::v1::ComputeUsage* temp = _impl_.metric_.compute_;
    _impl_.metric_.compute_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UsageMetrics::unsafe_arena_set_allocated_compute(::unhinged::common::v1::ComputeUsage* compute) {
  clear_metric();
  if (compute) {
    set_has_compute();
    _impl_.metric_.compute_ = compute;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.common.v1.UsageMetrics.compute)
}
inline ::unhinged::common::v1::ComputeUsage* UsageMetrics::_internal_mutable_compute() {
  if (!_internal_has_compute()) {
    clear_metric();
    set_has_compute();
    _impl_.metric_.compute_ = CreateMaybeMessage< ::unhinged::common::v1::ComputeUsage >(GetArenaForAllocation());
  }
  return _impl_.metric_.compute_;
}
inline ::unhinged::common::v1::ComputeUsage* UsageMetrics::mutable_compute() {
  ::unhinged::common::v1::ComputeUsage* _msg = _internal_mutable_compute();
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.UsageMetrics.compute)
  return _msg;
}

// .google.protobuf.Duration processing_time = 5;
inline bool UsageMetrics::_internal_has_processing_time() const {
  return this != internal_default_instance() && _impl_.processing_time_ != nullptr;
}
inline bool UsageMetrics::has_processing_time() const {
  return _internal_has_processing_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& UsageMetrics::_internal_processing_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = _impl_.processing_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& UsageMetrics::processing_time() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.UsageMetrics.processing_time)
  return _internal_processing_time();
}
inline void UsageMetrics::unsafe_arena_set_allocated_processing_time(
    ::PROTOBUF_NAMESPACE_ID::Duration* processing_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.processing_time_);
  }
  _impl_.processing_time_ = processing_time;
  if (processing_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.common.v1.UsageMetrics.processing_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* UsageMetrics::release_processing_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.processing_time_;
  _impl_.processing_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* UsageMetrics::unsafe_arena_release_processing_time() {
  // @@protoc_insertion_point(field_release:unhinged.common.v1.UsageMetrics.processing_time)
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.processing_time_;
  _impl_.processing_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* UsageMetrics::_internal_mutable_processing_time() {
  
  if (_impl_.processing_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    _impl_.processing_time_ = p;
  }
  return _impl_.processing_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* UsageMetrics::mutable_processing_time() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_processing_time();
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.UsageMetrics.processing_time)
  return _msg;
}
inline void UsageMetrics::set_allocated_processing_time(::PROTOBUF_NAMESPACE_ID::Duration* processing_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.processing_time_);
  }
  if (processing_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(processing_time));
    if (message_arena != submessage_arena) {
      processing_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, processing_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.processing_time_ = processing_time;
  // @@protoc_insertion_point(field_set_allocated:unhinged.common.v1.UsageMetrics.processing_time)
}

// .google.protobuf.Timestamp recorded_at = 6;
inline bool UsageMetrics::_internal_has_recorded_at() const {
  return this != internal_default_instance() && _impl_.recorded_at_ != nullptr;
}
inline bool UsageMetrics::has_recorded_at() const {
  return _internal_has_recorded_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& UsageMetrics::_internal_recorded_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.recorded_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& UsageMetrics::recorded_at() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.UsageMetrics.recorded_at)
  return _internal_recorded_at();
}
inline void UsageMetrics::unsafe_arena_set_allocated_recorded_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* recorded_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.recorded_at_);
  }
  _impl_.recorded_at_ = recorded_at;
  if (recorded_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.common.v1.UsageMetrics.recorded_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UsageMetrics::release_recorded_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.recorded_at_;
  _impl_.recorded_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UsageMetrics::unsafe_arena_release_recorded_at() {
  // @@protoc_insertion_point(field_release:unhinged.common.v1.UsageMetrics.recorded_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.recorded_at_;
  _impl_.recorded_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UsageMetrics::_internal_mutable_recorded_at() {
  
  if (_impl_.recorded_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.recorded_at_ = p;
  }
  return _impl_.recorded_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* UsageMetrics::mutable_recorded_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_recorded_at();
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.UsageMetrics.recorded_at)
  return _msg;
}
inline void UsageMetrics::set_allocated_recorded_at(::PROTOBUF_NAMESPACE_ID::Timestamp* recorded_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.recorded_at_);
  }
  if (recorded_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(recorded_at));
    if (message_arena != submessage_arena) {
      recorded_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, recorded_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.recorded_at_ = recorded_at;
  // @@protoc_insertion_point(field_set_allocated:unhinged.common.v1.UsageMetrics.recorded_at)
}

// float cost_usd = 7;
inline void UsageMetrics::clear_cost_usd() {
  _impl_.cost_usd_ = 0;
}
inline float UsageMetrics::_internal_cost_usd() const {
  return _impl_.cost_usd_;
}
inline float UsageMetrics::cost_usd() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.UsageMetrics.cost_usd)
  return _internal_cost_usd();
}
inline void UsageMetrics::_internal_set_cost_usd(float value) {
  
  _impl_.cost_usd_ = value;
}
inline void UsageMetrics::set_cost_usd(float value) {
  _internal_set_cost_usd(value);
  // @@protoc_insertion_point(field_set:unhinged.common.v1.UsageMetrics.cost_usd)
}

inline bool UsageMetrics::has_metric() const {
  return metric_case() != METRIC_NOT_SET;
}
inline void UsageMetrics::clear_has_metric() {
  _impl_._oneof_case_[0] = METRIC_NOT_SET;
}
inline UsageMetrics::MetricCase UsageMetrics::metric_case() const {
  return UsageMetrics::MetricCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// TokenUsage

// int32 prompt_tokens = 1;
inline void TokenUsage::clear_prompt_tokens() {
  _impl_.prompt_tokens_ = 0;
}
inline int32_t TokenUsage::_internal_prompt_tokens() const {
  return _impl_.prompt_tokens_;
}
inline int32_t TokenUsage::prompt_tokens() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.TokenUsage.prompt_tokens)
  return _internal_prompt_tokens();
}
inline void TokenUsage::_internal_set_prompt_tokens(int32_t value) {
  
  _impl_.prompt_tokens_ = value;
}
inline void TokenUsage::set_prompt_tokens(int32_t value) {
  _internal_set_prompt_tokens(value);
  // @@protoc_insertion_point(field_set:unhinged.common.v1.TokenUsage.prompt_tokens)
}

// int32 completion_tokens = 2;
inline void TokenUsage::clear_completion_tokens() {
  _impl_.completion_tokens_ = 0;
}
inline int32_t TokenUsage::_internal_completion_tokens() const {
  return _impl_.completion_tokens_;
}
inline int32_t TokenUsage::completion_tokens() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.TokenUsage.completion_tokens)
  return _internal_completion_tokens();
}
inline void TokenUsage::_internal_set_completion_tokens(int32_t value) {
  
  _impl_.completion_tokens_ = value;
}
inline void TokenUsage::set_completion_tokens(int32_t value) {
  _internal_set_completion_tokens(value);
  // @@protoc_insertion_point(field_set:unhinged.common.v1.TokenUsage.completion_tokens)
}

// int32 total_tokens = 3;
inline void TokenUsage::clear_total_tokens() {
  _impl_.total_tokens_ = 0;
}
inline int32_t TokenUsage::_internal_total_tokens() const {
  return _impl_.total_tokens_;
}
inline int32_t TokenUsage::total_tokens() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.TokenUsage.total_tokens)
  return _internal_total_tokens();
}
inline void TokenUsage::_internal_set_total_tokens(int32_t value) {
  
  _impl_.total_tokens_ = value;
}
inline void TokenUsage::set_total_tokens(int32_t value) {
  _internal_set_total_tokens(value);
  // @@protoc_insertion_point(field_set:unhinged.common.v1.TokenUsage.total_tokens)
}

// int32 cached_tokens = 4;
inline void TokenUsage::clear_cached_tokens() {
  _impl_.cached_tokens_ = 0;
}
inline int32_t TokenUsage::_internal_cached_tokens() const {
  return _impl_.cached_tokens_;
}
inline int32_t TokenUsage::cached_tokens() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.TokenUsage.cached_tokens)
  return _internal_cached_tokens();
}
inline void TokenUsage::_internal_set_cached_tokens(int32_t value) {
  
  _impl_.cached_tokens_ = value;
}
inline void TokenUsage::set_cached_tokens(int32_t value) {
  _internal_set_cached_tokens(value);
  // @@protoc_insertion_point(field_set:unhinged.common.v1.TokenUsage.cached_tokens)
}

// string model = 5;
inline void TokenUsage::clear_model() {
  _impl_.model_.ClearToEmpty();
}
inline const std::string& TokenUsage::model() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.TokenUsage.model)
  return _internal_model();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TokenUsage::set_model(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.common.v1.TokenUsage.model)
}
inline std::string* TokenUsage::mutable_model() {
  std::string* _s = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.TokenUsage.model)
  return _s;
}
inline const std::string& TokenUsage::_internal_model() const {
  return _impl_.model_.Get();
}
inline void TokenUsage::_internal_set_model(const std::string& value) {
  
  _impl_.model_.Set(value, GetArenaForAllocation());
}
inline std::string* TokenUsage::_internal_mutable_model() {
  
  return _impl_.model_.Mutable(GetArenaForAllocation());
}
inline std::string* TokenUsage::release_model() {
  // @@protoc_insertion_point(field_release:unhinged.common.v1.TokenUsage.model)
  return _impl_.model_.Release();
}
inline void TokenUsage::set_allocated_model(std::string* model) {
  if (model != nullptr) {
    
  } else {
    
  }
  _impl_.model_.SetAllocated(model, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_.IsDefault()) {
    _impl_.model_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.common.v1.TokenUsage.model)
}

// -------------------------------------------------------------------

// AudioUsage

// .google.protobuf.Duration duration = 1;
inline bool AudioUsage::_internal_has_duration() const {
  return this != internal_default_instance() && _impl_.duration_ != nullptr;
}
inline bool AudioUsage::has_duration() const {
  return _internal_has_duration();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& AudioUsage::_internal_duration() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = _impl_.duration_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& AudioUsage::duration() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.AudioUsage.duration)
  return _internal_duration();
}
inline void AudioUsage::unsafe_arena_set_allocated_duration(
    ::PROTOBUF_NAMESPACE_ID::Duration* duration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.duration_);
  }
  _impl_.duration_ = duration;
  if (duration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.common.v1.AudioUsage.duration)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* AudioUsage::release_duration() {
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.duration_;
  _impl_.duration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* AudioUsage::unsafe_arena_release_duration() {
  // @@protoc_insertion_point(field_release:unhinged.common.v1.AudioUsage.duration)
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.duration_;
  _impl_.duration_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* AudioUsage::_internal_mutable_duration() {
  
  if (_impl_.duration_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    _impl_.duration_ = p;
  }
  return _impl_.duration_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* AudioUsage::mutable_duration() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_duration();
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.AudioUsage.duration)
  return _msg;
}
inline void AudioUsage::set_allocated_duration(::PROTOBUF_NAMESPACE_ID::Duration* duration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.duration_);
  }
  if (duration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(duration));
    if (message_arena != submessage_arena) {
      duration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, duration, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.duration_ = duration;
  // @@protoc_insertion_point(field_set_allocated:unhinged.common.v1.AudioUsage.duration)
}

// int64 bytes_processed = 2;
inline void AudioUsage::clear_bytes_processed() {
  _impl_.bytes_processed_ = int64_t{0};
}
inline int64_t AudioUsage::_internal_bytes_processed() const {
  return _impl_.bytes_processed_;
}
inline int64_t AudioUsage::bytes_processed() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.AudioUsage.bytes_processed)
  return _internal_bytes_processed();
}
inline void AudioUsage::_internal_set_bytes_processed(int64_t value) {
  
  _impl_.bytes_processed_ = value;
}
inline void AudioUsage::set_bytes_processed(int64_t value) {
  _internal_set_bytes_processed(value);
  // @@protoc_insertion_point(field_set:unhinged.common.v1.AudioUsage.bytes_processed)
}

// int32 sample_rate = 3;
inline void AudioUsage::clear_sample_rate() {
  _impl_.sample_rate_ = 0;
}
inline int32_t AudioUsage::_internal_sample_rate() const {
  return _impl_.sample_rate_;
}
inline int32_t AudioUsage::sample_rate() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.AudioUsage.sample_rate)
  return _internal_sample_rate();
}
inline void AudioUsage::_internal_set_sample_rate(int32_t value) {
  
  _impl_.sample_rate_ = value;
}
inline void AudioUsage::set_sample_rate(int32_t value) {
  _internal_set_sample_rate(value);
  // @@protoc_insertion_point(field_set:unhinged.common.v1.AudioUsage.sample_rate)
}

// int32 channels = 4;
inline void AudioUsage::clear_channels() {
  _impl_.channels_ = 0;
}
inline int32_t AudioUsage::_internal_channels() const {
  return _impl_.channels_;
}
inline int32_t AudioUsage::channels() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.AudioUsage.channels)
  return _internal_channels();
}
inline void AudioUsage::_internal_set_channels(int32_t value) {
  
  _impl_.channels_ = value;
}
inline void AudioUsage::set_channels(int32_t value) {
  _internal_set_channels(value);
  // @@protoc_insertion_point(field_set:unhinged.common.v1.AudioUsage.channels)
}

// string format = 5;
inline void AudioUsage::clear_format() {
  _impl_.format_.ClearToEmpty();
}
inline const std::string& AudioUsage::format() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.AudioUsage.format)
  return _internal_format();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AudioUsage::set_format(ArgT0&& arg0, ArgT... args) {
 
 _impl_.format_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.common.v1.AudioUsage.format)
}
inline std::string* AudioUsage::mutable_format() {
  std::string* _s = _internal_mutable_format();
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.AudioUsage.format)
  return _s;
}
inline const std::string& AudioUsage::_internal_format() const {
  return _impl_.format_.Get();
}
inline void AudioUsage::_internal_set_format(const std::string& value) {
  
  _impl_.format_.Set(value, GetArenaForAllocation());
}
inline std::string* AudioUsage::_internal_mutable_format() {
  
  return _impl_.format_.Mutable(GetArenaForAllocation());
}
inline std::string* AudioUsage::release_format() {
  // @@protoc_insertion_point(field_release:unhinged.common.v1.AudioUsage.format)
  return _impl_.format_.Release();
}
inline void AudioUsage::set_allocated_format(std::string* format) {
  if (format != nullptr) {
    
  } else {
    
  }
  _impl_.format_.SetAllocated(format, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.format_.IsDefault()) {
    _impl_.format_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.common.v1.AudioUsage.format)
}

// -------------------------------------------------------------------

// DataUsage

// int64 bytes_read = 1;
inline void DataUsage::clear_bytes_read() {
  _impl_.bytes_read_ = int64_t{0};
}
inline int64_t DataUsage::_internal_bytes_read() const {
  return _impl_.bytes_read_;
}
inline int64_t DataUsage::bytes_read() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.DataUsage.bytes_read)
  return _internal_bytes_read();
}
inline void DataUsage::_internal_set_bytes_read(int64_t value) {
  
  _impl_.bytes_read_ = value;
}
inline void DataUsage::set_bytes_read(int64_t value) {
  _internal_set_bytes_read(value);
  // @@protoc_insertion_point(field_set:unhinged.common.v1.DataUsage.bytes_read)
}

// int64 bytes_written = 2;
inline void DataUsage::clear_bytes_written() {
  _impl_.bytes_written_ = int64_t{0};
}
inline int64_t DataUsage::_internal_bytes_written() const {
  return _impl_.bytes_written_;
}
inline int64_t DataUsage::bytes_written() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.DataUsage.bytes_written)
  return _internal_bytes_written();
}
inline void DataUsage::_internal_set_bytes_written(int64_t value) {
  
  _impl_.bytes_written_ = value;
}
inline void DataUsage::set_bytes_written(int64_t value) {
  _internal_set_bytes_written(value);
  // @@protoc_insertion_point(field_set:unhinged.common.v1.DataUsage.bytes_written)
}

// int32 records_processed = 3;
inline void DataUsage::clear_records_processed() {
  _impl_.records_processed_ = 0;
}
inline int32_t DataUsage::_internal_records_processed() const {
  return _impl_.records_processed_;
}
inline int32_t DataUsage::records_processed() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.DataUsage.records_processed)
  return _internal_records_processed();
}
inline void DataUsage::_internal_set_records_processed(int32_t value) {
  
  _impl_.records_processed_ = value;
}
inline void DataUsage::set_records_processed(int32_t value) {
  _internal_set_records_processed(value);
  // @@protoc_insertion_point(field_set:unhinged.common.v1.DataUsage.records_processed)
}

// int32 api_calls = 4;
inline void DataUsage::clear_api_calls() {
  _impl_.api_calls_ = 0;
}
inline int32_t DataUsage::_internal_api_calls() const {
  return _impl_.api_calls_;
}
inline int32_t DataUsage::api_calls() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.DataUsage.api_calls)
  return _internal_api_calls();
}
inline void DataUsage::_internal_set_api_calls(int32_t value) {
  
  _impl_.api_calls_ = value;
}
inline void DataUsage::set_api_calls(int32_t value) {
  _internal_set_api_calls(value);
  // @@protoc_insertion_point(field_set:unhinged.common.v1.DataUsage.api_calls)
}

// -------------------------------------------------------------------

// ComputeUsage

// .google.protobuf.Duration cpu_time = 1;
inline bool ComputeUsage::_internal_has_cpu_time() const {
  return this != internal_default_instance() && _impl_.cpu_time_ != nullptr;
}
inline bool ComputeUsage::has_cpu_time() const {
  return _internal_has_cpu_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& ComputeUsage::_internal_cpu_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = _impl_.cpu_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& ComputeUsage::cpu_time() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.ComputeUsage.cpu_time)
  return _internal_cpu_time();
}
inline void ComputeUsage::unsafe_arena_set_allocated_cpu_time(
    ::PROTOBUF_NAMESPACE_ID::Duration* cpu_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cpu_time_);
  }
  _impl_.cpu_time_ = cpu_time;
  if (cpu_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.common.v1.ComputeUsage.cpu_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* ComputeUsage::release_cpu_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.cpu_time_;
  _impl_.cpu_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* ComputeUsage::unsafe_arena_release_cpu_time() {
  // @@protoc_insertion_point(field_release:unhinged.common.v1.ComputeUsage.cpu_time)
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.cpu_time_;
  _impl_.cpu_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* ComputeUsage::_internal_mutable_cpu_time() {
  
  if (_impl_.cpu_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    _impl_.cpu_time_ = p;
  }
  return _impl_.cpu_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* ComputeUsage::mutable_cpu_time() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_cpu_time();
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.ComputeUsage.cpu_time)
  return _msg;
}
inline void ComputeUsage::set_allocated_cpu_time(::PROTOBUF_NAMESPACE_ID::Duration* cpu_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cpu_time_);
  }
  if (cpu_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cpu_time));
    if (message_arena != submessage_arena) {
      cpu_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cpu_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.cpu_time_ = cpu_time;
  // @@protoc_insertion_point(field_set_allocated:unhinged.common.v1.ComputeUsage.cpu_time)
}

// int64 memory_bytes = 2;
inline void ComputeUsage::clear_memory_bytes() {
  _impl_.memory_bytes_ = int64_t{0};
}
inline int64_t ComputeUsage::_internal_memory_bytes() const {
  return _impl_.memory_bytes_;
}
inline int64_t ComputeUsage::memory_bytes() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.ComputeUsage.memory_bytes)
  return _internal_memory_bytes();
}
inline void ComputeUsage::_internal_set_memory_bytes(int64_t value) {
  
  _impl_.memory_bytes_ = value;
}
inline void ComputeUsage::set_memory_bytes(int64_t value) {
  _internal_set_memory_bytes(value);
  // @@protoc_insertion_point(field_set:unhinged.common.v1.ComputeUsage.memory_bytes)
}

// int64 storage_bytes = 3;
inline void ComputeUsage::clear_storage_bytes() {
  _impl_.storage_bytes_ = int64_t{0};
}
inline int64_t ComputeUsage::_internal_storage_bytes() const {
  return _impl_.storage_bytes_;
}
inline int64_t ComputeUsage::storage_bytes() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.ComputeUsage.storage_bytes)
  return _internal_storage_bytes();
}
inline void ComputeUsage::_internal_set_storage_bytes(int64_t value) {
  
  _impl_.storage_bytes_ = value;
}
inline void ComputeUsage::set_storage_bytes(int64_t value) {
  _internal_set_storage_bytes(value);
  // @@protoc_insertion_point(field_set:unhinged.common.v1.ComputeUsage.storage_bytes)
}

// int32 gpu_seconds = 4;
inline void ComputeUsage::clear_gpu_seconds() {
  _impl_.gpu_seconds_ = 0;
}
inline int32_t ComputeUsage::_internal_gpu_seconds() const {
  return _impl_.gpu_seconds_;
}
inline int32_t ComputeUsage::gpu_seconds() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.ComputeUsage.gpu_seconds)
  return _internal_gpu_seconds();
}
inline void ComputeUsage::_internal_set_gpu_seconds(int32_t value) {
  
  _impl_.gpu_seconds_ = value;
}
inline void ComputeUsage::set_gpu_seconds(int32_t value) {
  _internal_set_gpu_seconds(value);
  // @@protoc_insertion_point(field_set:unhinged.common.v1.ComputeUsage.gpu_seconds)
}

// -------------------------------------------------------------------

// Attachment

// string attachment_id = 1;
inline void Attachment::clear_attachment_id() {
  _impl_.attachment_id_.ClearToEmpty();
}
inline const std::string& Attachment::attachment_id() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.Attachment.attachment_id)
  return _internal_attachment_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Attachment::set_attachment_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.attachment_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.common.v1.Attachment.attachment_id)
}
inline std::string* Attachment::mutable_attachment_id() {
  std::string* _s = _internal_mutable_attachment_id();
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.Attachment.attachment_id)
  return _s;
}
inline const std::string& Attachment::_internal_attachment_id() const {
  return _impl_.attachment_id_.Get();
}
inline void Attachment::_internal_set_attachment_id(const std::string& value) {
  
  _impl_.attachment_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Attachment::_internal_mutable_attachment_id() {
  
  return _impl_.attachment_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Attachment::release_attachment_id() {
  // @@protoc_insertion_point(field_release:unhinged.common.v1.Attachment.attachment_id)
  return _impl_.attachment_id_.Release();
}
inline void Attachment::set_allocated_attachment_id(std::string* attachment_id) {
  if (attachment_id != nullptr) {
    
  } else {
    
  }
  _impl_.attachment_id_.SetAllocated(attachment_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attachment_id_.IsDefault()) {
    _impl_.attachment_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.common.v1.Attachment.attachment_id)
}

// .unhinged.common.v1.AttachmentType type = 2;
inline void Attachment::clear_type() {
  _impl_.type_ = 0;
}
inline ::unhinged::common::v1::AttachmentType Attachment::_internal_type() const {
  return static_cast< ::unhinged::common::v1::AttachmentType >(_impl_.type_);
}
inline ::unhinged::common::v1::AttachmentType Attachment::type() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.Attachment.type)
  return _internal_type();
}
inline void Attachment::_internal_set_type(::unhinged::common::v1::AttachmentType value) {
  
  _impl_.type_ = value;
}
inline void Attachment::set_type(::unhinged::common::v1::AttachmentType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:unhinged.common.v1.Attachment.type)
}

// string url = 3;
inline void Attachment::clear_url() {
  _impl_.url_.ClearToEmpty();
}
inline const std::string& Attachment::url() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.Attachment.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Attachment::set_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.common.v1.Attachment.url)
}
inline std::string* Attachment::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.Attachment.url)
  return _s;
}
inline const std::string& Attachment::_internal_url() const {
  return _impl_.url_.Get();
}
inline void Attachment::_internal_set_url(const std::string& value) {
  
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* Attachment::_internal_mutable_url() {
  
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* Attachment::release_url() {
  // @@protoc_insertion_point(field_release:unhinged.common.v1.Attachment.url)
  return _impl_.url_.Release();
}
inline void Attachment::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.common.v1.Attachment.url)
}

// string filename = 4;
inline void Attachment::clear_filename() {
  _impl_.filename_.ClearToEmpty();
}
inline const std::string& Attachment::filename() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.Attachment.filename)
  return _internal_filename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Attachment::set_filename(ArgT0&& arg0, ArgT... args) {
 
 _impl_.filename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.common.v1.Attachment.filename)
}
inline std::string* Attachment::mutable_filename() {
  std::string* _s = _internal_mutable_filename();
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.Attachment.filename)
  return _s;
}
inline const std::string& Attachment::_internal_filename() const {
  return _impl_.filename_.Get();
}
inline void Attachment::_internal_set_filename(const std::string& value) {
  
  _impl_.filename_.Set(value, GetArenaForAllocation());
}
inline std::string* Attachment::_internal_mutable_filename() {
  
  return _impl_.filename_.Mutable(GetArenaForAllocation());
}
inline std::string* Attachment::release_filename() {
  // @@protoc_insertion_point(field_release:unhinged.common.v1.Attachment.filename)
  return _impl_.filename_.Release();
}
inline void Attachment::set_allocated_filename(std::string* filename) {
  if (filename != nullptr) {
    
  } else {
    
  }
  _impl_.filename_.SetAllocated(filename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filename_.IsDefault()) {
    _impl_.filename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.common.v1.Attachment.filename)
}

// int64 size_bytes = 5;
inline void Attachment::clear_size_bytes() {
  _impl_.size_bytes_ = int64_t{0};
}
inline int64_t Attachment::_internal_size_bytes() const {
  return _impl_.size_bytes_;
}
inline int64_t Attachment::size_bytes() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.Attachment.size_bytes)
  return _internal_size_bytes();
}
inline void Attachment::_internal_set_size_bytes(int64_t value) {
  
  _impl_.size_bytes_ = value;
}
inline void Attachment::set_size_bytes(int64_t value) {
  _internal_set_size_bytes(value);
  // @@protoc_insertion_point(field_set:unhinged.common.v1.Attachment.size_bytes)
}

// string mime_type = 6;
inline void Attachment::clear_mime_type() {
  _impl_.mime_type_.ClearToEmpty();
}
inline const std::string& Attachment::mime_type() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.Attachment.mime_type)
  return _internal_mime_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Attachment::set_mime_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mime_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.common.v1.Attachment.mime_type)
}
inline std::string* Attachment::mutable_mime_type() {
  std::string* _s = _internal_mutable_mime_type();
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.Attachment.mime_type)
  return _s;
}
inline const std::string& Attachment::_internal_mime_type() const {
  return _impl_.mime_type_.Get();
}
inline void Attachment::_internal_set_mime_type(const std::string& value) {
  
  _impl_.mime_type_.Set(value, GetArenaForAllocation());
}
inline std::string* Attachment::_internal_mutable_mime_type() {
  
  return _impl_.mime_type_.Mutable(GetArenaForAllocation());
}
inline std::string* Attachment::release_mime_type() {
  // @@protoc_insertion_point(field_release:unhinged.common.v1.Attachment.mime_type)
  return _impl_.mime_type_.Release();
}
inline void Attachment::set_allocated_mime_type(std::string* mime_type) {
  if (mime_type != nullptr) {
    
  } else {
    
  }
  _impl_.mime_type_.SetAllocated(mime_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mime_type_.IsDefault()) {
    _impl_.mime_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.common.v1.Attachment.mime_type)
}

// string thumbnail_url = 7;
inline void Attachment::clear_thumbnail_url() {
  _impl_.thumbnail_url_.ClearToEmpty();
}
inline const std::string& Attachment::thumbnail_url() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.Attachment.thumbnail_url)
  return _internal_thumbnail_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Attachment::set_thumbnail_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.thumbnail_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.common.v1.Attachment.thumbnail_url)
}
inline std::string* Attachment::mutable_thumbnail_url() {
  std::string* _s = _internal_mutable_thumbnail_url();
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.Attachment.thumbnail_url)
  return _s;
}
inline const std::string& Attachment::_internal_thumbnail_url() const {
  return _impl_.thumbnail_url_.Get();
}
inline void Attachment::_internal_set_thumbnail_url(const std::string& value) {
  
  _impl_.thumbnail_url_.Set(value, GetArenaForAllocation());
}
inline std::string* Attachment::_internal_mutable_thumbnail_url() {
  
  return _impl_.thumbnail_url_.Mutable(GetArenaForAllocation());
}
inline std::string* Attachment::release_thumbnail_url() {
  // @@protoc_insertion_point(field_release:unhinged.common.v1.Attachment.thumbnail_url)
  return _impl_.thumbnail_url_.Release();
}
inline void Attachment::set_allocated_thumbnail_url(std::string* thumbnail_url) {
  if (thumbnail_url != nullptr) {
    
  } else {
    
  }
  _impl_.thumbnail_url_.SetAllocated(thumbnail_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.thumbnail_url_.IsDefault()) {
    _impl_.thumbnail_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.common.v1.Attachment.thumbnail_url)
}

// .google.protobuf.Struct metadata = 8;
inline bool Attachment::_internal_has_metadata() const {
  return this != internal_default_instance() && _impl_.metadata_ != nullptr;
}
inline bool Attachment::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& Attachment::_internal_metadata() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& Attachment::metadata() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.Attachment.metadata)
  return _internal_metadata();
}
inline void Attachment::unsafe_arena_set_allocated_metadata(
    ::PROTOBUF_NAMESPACE_ID::Struct* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.common.v1.Attachment.metadata)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Attachment::release_metadata() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Attachment::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:unhinged.common.v1.Attachment.metadata)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Attachment::_internal_mutable_metadata() {
  
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Attachment::mutable_metadata() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.Attachment.metadata)
  return _msg;
}
inline void Attachment::set_allocated_metadata(::PROTOBUF_NAMESPACE_ID::Struct* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:unhinged.common.v1.Attachment.metadata)
}

// .google.protobuf.Timestamp uploaded_at = 9;
inline bool Attachment::_internal_has_uploaded_at() const {
  return this != internal_default_instance() && _impl_.uploaded_at_ != nullptr;
}
inline bool Attachment::has_uploaded_at() const {
  return _internal_has_uploaded_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Attachment::_internal_uploaded_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.uploaded_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Attachment::uploaded_at() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.Attachment.uploaded_at)
  return _internal_uploaded_at();
}
inline void Attachment::unsafe_arena_set_allocated_uploaded_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* uploaded_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.uploaded_at_);
  }
  _impl_.uploaded_at_ = uploaded_at;
  if (uploaded_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.common.v1.Attachment.uploaded_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Attachment::release_uploaded_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.uploaded_at_;
  _impl_.uploaded_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Attachment::unsafe_arena_release_uploaded_at() {
  // @@protoc_insertion_point(field_release:unhinged.common.v1.Attachment.uploaded_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.uploaded_at_;
  _impl_.uploaded_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Attachment::_internal_mutable_uploaded_at() {
  
  if (_impl_.uploaded_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.uploaded_at_ = p;
  }
  return _impl_.uploaded_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Attachment::mutable_uploaded_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_uploaded_at();
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.Attachment.uploaded_at)
  return _msg;
}
inline void Attachment::set_allocated_uploaded_at(::PROTOBUF_NAMESPACE_ID::Timestamp* uploaded_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.uploaded_at_);
  }
  if (uploaded_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(uploaded_at));
    if (message_arena != submessage_arena) {
      uploaded_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, uploaded_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.uploaded_at_ = uploaded_at;
  // @@protoc_insertion_point(field_set_allocated:unhinged.common.v1.Attachment.uploaded_at)
}

// string uploaded_by = 10;
inline void Attachment::clear_uploaded_by() {
  _impl_.uploaded_by_.ClearToEmpty();
}
inline const std::string& Attachment::uploaded_by() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.Attachment.uploaded_by)
  return _internal_uploaded_by();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Attachment::set_uploaded_by(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uploaded_by_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.common.v1.Attachment.uploaded_by)
}
inline std::string* Attachment::mutable_uploaded_by() {
  std::string* _s = _internal_mutable_uploaded_by();
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.Attachment.uploaded_by)
  return _s;
}
inline const std::string& Attachment::_internal_uploaded_by() const {
  return _impl_.uploaded_by_.Get();
}
inline void Attachment::_internal_set_uploaded_by(const std::string& value) {
  
  _impl_.uploaded_by_.Set(value, GetArenaForAllocation());
}
inline std::string* Attachment::_internal_mutable_uploaded_by() {
  
  return _impl_.uploaded_by_.Mutable(GetArenaForAllocation());
}
inline std::string* Attachment::release_uploaded_by() {
  // @@protoc_insertion_point(field_release:unhinged.common.v1.Attachment.uploaded_by)
  return _impl_.uploaded_by_.Release();
}
inline void Attachment::set_allocated_uploaded_by(std::string* uploaded_by) {
  if (uploaded_by != nullptr) {
    
  } else {
    
  }
  _impl_.uploaded_by_.SetAllocated(uploaded_by, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uploaded_by_.IsDefault()) {
    _impl_.uploaded_by_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.common.v1.Attachment.uploaded_by)
}

// -------------------------------------------------------------------

// Error

// .unhinged.common.v1.ErrorCode code = 1;
inline void Error::clear_code() {
  _impl_.code_ = 0;
}
inline ::unhinged::common::v1::ErrorCode Error::_internal_code() const {
  return static_cast< ::unhinged::common::v1::ErrorCode >(_impl_.code_);
}
inline ::unhinged::common::v1::ErrorCode Error::code() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.Error.code)
  return _internal_code();
}
inline void Error::_internal_set_code(::unhinged::common::v1::ErrorCode value) {
  
  _impl_.code_ = value;
}
inline void Error::set_code(::unhinged::common::v1::ErrorCode value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:unhinged.common.v1.Error.code)
}

// string message = 2;
inline void Error::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& Error::message() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.Error.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Error::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.common.v1.Error.message)
}
inline std::string* Error::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.Error.message)
  return _s;
}
inline const std::string& Error::_internal_message() const {
  return _impl_.message_.Get();
}
inline void Error::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* Error::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* Error::release_message() {
  // @@protoc_insertion_point(field_release:unhinged.common.v1.Error.message)
  return _impl_.message_.Release();
}
inline void Error::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.common.v1.Error.message)
}

// string details = 3;
inline void Error::clear_details() {
  _impl_.details_.ClearToEmpty();
}
inline const std::string& Error::details() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.Error.details)
  return _internal_details();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Error::set_details(ArgT0&& arg0, ArgT... args) {
 
 _impl_.details_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.common.v1.Error.details)
}
inline std::string* Error::mutable_details() {
  std::string* _s = _internal_mutable_details();
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.Error.details)
  return _s;
}
inline const std::string& Error::_internal_details() const {
  return _impl_.details_.Get();
}
inline void Error::_internal_set_details(const std::string& value) {
  
  _impl_.details_.Set(value, GetArenaForAllocation());
}
inline std::string* Error::_internal_mutable_details() {
  
  return _impl_.details_.Mutable(GetArenaForAllocation());
}
inline std::string* Error::release_details() {
  // @@protoc_insertion_point(field_release:unhinged.common.v1.Error.details)
  return _impl_.details_.Release();
}
inline void Error::set_allocated_details(std::string* details) {
  if (details != nullptr) {
    
  } else {
    
  }
  _impl_.details_.SetAllocated(details, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.details_.IsDefault()) {
    _impl_.details_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.common.v1.Error.details)
}

// repeated .unhinged.common.v1.ErrorField field_errors = 4;
inline int Error::_internal_field_errors_size() const {
  return _impl_.field_errors_.size();
}
inline int Error::field_errors_size() const {
  return _internal_field_errors_size();
}
inline void Error::clear_field_errors() {
  _impl_.field_errors_.Clear();
}
inline ::unhinged::common::v1::ErrorField* Error::mutable_field_errors(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.Error.field_errors)
  return _impl_.field_errors_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::common::v1::ErrorField >*
Error::mutable_field_errors() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.common.v1.Error.field_errors)
  return &_impl_.field_errors_;
}
inline const ::unhinged::common::v1::ErrorField& Error::_internal_field_errors(int index) const {
  return _impl_.field_errors_.Get(index);
}
inline const ::unhinged::common::v1::ErrorField& Error::field_errors(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.Error.field_errors)
  return _internal_field_errors(index);
}
inline ::unhinged::common::v1::ErrorField* Error::_internal_add_field_errors() {
  return _impl_.field_errors_.Add();
}
inline ::unhinged::common::v1::ErrorField* Error::add_field_errors() {
  ::unhinged::common::v1::ErrorField* _add = _internal_add_field_errors();
  // @@protoc_insertion_point(field_add:unhinged.common.v1.Error.field_errors)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::unhinged::common::v1::ErrorField >&
Error::field_errors() const {
  // @@protoc_insertion_point(field_list:unhinged.common.v1.Error.field_errors)
  return _impl_.field_errors_;
}

// .google.protobuf.Struct debug_info = 5;
inline bool Error::_internal_has_debug_info() const {
  return this != internal_default_instance() && _impl_.debug_info_ != nullptr;
}
inline bool Error::has_debug_info() const {
  return _internal_has_debug_info();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& Error::_internal_debug_info() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.debug_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& Error::debug_info() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.Error.debug_info)
  return _internal_debug_info();
}
inline void Error::unsafe_arena_set_allocated_debug_info(
    ::PROTOBUF_NAMESPACE_ID::Struct* debug_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.debug_info_);
  }
  _impl_.debug_info_ = debug_info;
  if (debug_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.common.v1.Error.debug_info)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Error::release_debug_info() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.debug_info_;
  _impl_.debug_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Error::unsafe_arena_release_debug_info() {
  // @@protoc_insertion_point(field_release:unhinged.common.v1.Error.debug_info)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.debug_info_;
  _impl_.debug_info_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Error::_internal_mutable_debug_info() {
  
  if (_impl_.debug_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.debug_info_ = p;
  }
  return _impl_.debug_info_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Error::mutable_debug_info() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_debug_info();
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.Error.debug_info)
  return _msg;
}
inline void Error::set_allocated_debug_info(::PROTOBUF_NAMESPACE_ID::Struct* debug_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.debug_info_);
  }
  if (debug_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(debug_info));
    if (message_arena != submessage_arena) {
      debug_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, debug_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.debug_info_ = debug_info;
  // @@protoc_insertion_point(field_set_allocated:unhinged.common.v1.Error.debug_info)
}

// string request_id = 6;
inline void Error::clear_request_id() {
  _impl_.request_id_.ClearToEmpty();
}
inline const std::string& Error::request_id() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.Error.request_id)
  return _internal_request_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Error::set_request_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.request_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.common.v1.Error.request_id)
}
inline std::string* Error::mutable_request_id() {
  std::string* _s = _internal_mutable_request_id();
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.Error.request_id)
  return _s;
}
inline const std::string& Error::_internal_request_id() const {
  return _impl_.request_id_.Get();
}
inline void Error::_internal_set_request_id(const std::string& value) {
  
  _impl_.request_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Error::_internal_mutable_request_id() {
  
  return _impl_.request_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Error::release_request_id() {
  // @@protoc_insertion_point(field_release:unhinged.common.v1.Error.request_id)
  return _impl_.request_id_.Release();
}
inline void Error::set_allocated_request_id(std::string* request_id) {
  if (request_id != nullptr) {
    
  } else {
    
  }
  _impl_.request_id_.SetAllocated(request_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.request_id_.IsDefault()) {
    _impl_.request_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.common.v1.Error.request_id)
}

// -------------------------------------------------------------------

// ErrorField

// string field = 1;
inline void ErrorField::clear_field() {
  _impl_.field_.ClearToEmpty();
}
inline const std::string& ErrorField::field() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.ErrorField.field)
  return _internal_field();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ErrorField::set_field(ArgT0&& arg0, ArgT... args) {
 
 _impl_.field_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.common.v1.ErrorField.field)
}
inline std::string* ErrorField::mutable_field() {
  std::string* _s = _internal_mutable_field();
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.ErrorField.field)
  return _s;
}
inline const std::string& ErrorField::_internal_field() const {
  return _impl_.field_.Get();
}
inline void ErrorField::_internal_set_field(const std::string& value) {
  
  _impl_.field_.Set(value, GetArenaForAllocation());
}
inline std::string* ErrorField::_internal_mutable_field() {
  
  return _impl_.field_.Mutable(GetArenaForAllocation());
}
inline std::string* ErrorField::release_field() {
  // @@protoc_insertion_point(field_release:unhinged.common.v1.ErrorField.field)
  return _impl_.field_.Release();
}
inline void ErrorField::set_allocated_field(std::string* field) {
  if (field != nullptr) {
    
  } else {
    
  }
  _impl_.field_.SetAllocated(field, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field_.IsDefault()) {
    _impl_.field_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.common.v1.ErrorField.field)
}

// string message = 2;
inline void ErrorField::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& ErrorField::message() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.ErrorField.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ErrorField::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.common.v1.ErrorField.message)
}
inline std::string* ErrorField::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.ErrorField.message)
  return _s;
}
inline const std::string& ErrorField::_internal_message() const {
  return _impl_.message_.Get();
}
inline void ErrorField::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* ErrorField::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* ErrorField::release_message() {
  // @@protoc_insertion_point(field_release:unhinged.common.v1.ErrorField.message)
  return _impl_.message_.Release();
}
inline void ErrorField::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.common.v1.ErrorField.message)
}

// string code = 3;
inline void ErrorField::clear_code() {
  _impl_.code_.ClearToEmpty();
}
inline const std::string& ErrorField::code() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.ErrorField.code)
  return _internal_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ErrorField::set_code(ArgT0&& arg0, ArgT... args) {
 
 _impl_.code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.common.v1.ErrorField.code)
}
inline std::string* ErrorField::mutable_code() {
  std::string* _s = _internal_mutable_code();
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.ErrorField.code)
  return _s;
}
inline const std::string& ErrorField::_internal_code() const {
  return _impl_.code_.Get();
}
inline void ErrorField::_internal_set_code(const std::string& value) {
  
  _impl_.code_.Set(value, GetArenaForAllocation());
}
inline std::string* ErrorField::_internal_mutable_code() {
  
  return _impl_.code_.Mutable(GetArenaForAllocation());
}
inline std::string* ErrorField::release_code() {
  // @@protoc_insertion_point(field_release:unhinged.common.v1.ErrorField.code)
  return _impl_.code_.Release();
}
inline void ErrorField::set_allocated_code(std::string* code) {
  if (code != nullptr) {
    
  } else {
    
  }
  _impl_.code_.SetAllocated(code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.code_.IsDefault()) {
    _impl_.code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.common.v1.ErrorField.code)
}

// -------------------------------------------------------------------

// Filter

// string field = 1;
inline void Filter::clear_field() {
  _impl_.field_.ClearToEmpty();
}
inline const std::string& Filter::field() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.Filter.field)
  return _internal_field();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Filter::set_field(ArgT0&& arg0, ArgT... args) {
 
 _impl_.field_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.common.v1.Filter.field)
}
inline std::string* Filter::mutable_field() {
  std::string* _s = _internal_mutable_field();
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.Filter.field)
  return _s;
}
inline const std::string& Filter::_internal_field() const {
  return _impl_.field_.Get();
}
inline void Filter::_internal_set_field(const std::string& value) {
  
  _impl_.field_.Set(value, GetArenaForAllocation());
}
inline std::string* Filter::_internal_mutable_field() {
  
  return _impl_.field_.Mutable(GetArenaForAllocation());
}
inline std::string* Filter::release_field() {
  // @@protoc_insertion_point(field_release:unhinged.common.v1.Filter.field)
  return _impl_.field_.Release();
}
inline void Filter::set_allocated_field(std::string* field) {
  if (field != nullptr) {
    
  } else {
    
  }
  _impl_.field_.SetAllocated(field, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.field_.IsDefault()) {
    _impl_.field_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.common.v1.Filter.field)
}

// .unhinged.common.v1.FilterOperator operator = 2;
inline void Filter::clear_operator_() {
  _impl_.operator__ = 0;
}
inline ::unhinged::common::v1::FilterOperator Filter::_internal_operator_() const {
  return static_cast< ::unhinged::common::v1::FilterOperator >(_impl_.operator__);
}
inline ::unhinged::common::v1::FilterOperator Filter::operator_() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.Filter.operator)
  return _internal_operator_();
}
inline void Filter::_internal_set_operator_(::unhinged::common::v1::FilterOperator value) {
  
  _impl_.operator__ = value;
}
inline void Filter::set_operator_(::unhinged::common::v1::FilterOperator value) {
  _internal_set_operator_(value);
  // @@protoc_insertion_point(field_set:unhinged.common.v1.Filter.operator)
}

// string value = 3;
inline void Filter::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& Filter::value() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.Filter.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Filter::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.common.v1.Filter.value)
}
inline std::string* Filter::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.Filter.value)
  return _s;
}
inline const std::string& Filter::_internal_value() const {
  return _impl_.value_.Get();
}
inline void Filter::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* Filter::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* Filter::release_value() {
  // @@protoc_insertion_point(field_release:unhinged.common.v1.Filter.value)
  return _impl_.value_.Release();
}
inline void Filter::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.common.v1.Filter.value)
}

// repeated string values = 4;
inline int Filter::_internal_values_size() const {
  return _impl_.values_.size();
}
inline int Filter::values_size() const {
  return _internal_values_size();
}
inline void Filter::clear_values() {
  _impl_.values_.Clear();
}
inline std::string* Filter::add_values() {
  std::string* _s = _internal_add_values();
  // @@protoc_insertion_point(field_add_mutable:unhinged.common.v1.Filter.values)
  return _s;
}
inline const std::string& Filter::_internal_values(int index) const {
  return _impl_.values_.Get(index);
}
inline const std::string& Filter::values(int index) const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.Filter.values)
  return _internal_values(index);
}
inline std::string* Filter::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.Filter.values)
  return _impl_.values_.Mutable(index);
}
inline void Filter::set_values(int index, const std::string& value) {
  _impl_.values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:unhinged.common.v1.Filter.values)
}
inline void Filter::set_values(int index, std::string&& value) {
  _impl_.values_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:unhinged.common.v1.Filter.values)
}
inline void Filter::set_values(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:unhinged.common.v1.Filter.values)
}
inline void Filter::set_values(int index, const char* value, size_t size) {
  _impl_.values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:unhinged.common.v1.Filter.values)
}
inline std::string* Filter::_internal_add_values() {
  return _impl_.values_.Add();
}
inline void Filter::add_values(const std::string& value) {
  _impl_.values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:unhinged.common.v1.Filter.values)
}
inline void Filter::add_values(std::string&& value) {
  _impl_.values_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:unhinged.common.v1.Filter.values)
}
inline void Filter::add_values(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:unhinged.common.v1.Filter.values)
}
inline void Filter::add_values(const char* value, size_t size) {
  _impl_.values_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:unhinged.common.v1.Filter.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Filter::values() const {
  // @@protoc_insertion_point(field_list:unhinged.common.v1.Filter.values)
  return _impl_.values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Filter::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:unhinged.common.v1.Filter.values)
  return &_impl_.values_;
}

// -------------------------------------------------------------------

// HealthCheckRequest

// string service = 1;
inline void HealthCheckRequest::clear_service() {
  _impl_.service_.ClearToEmpty();
}
inline const std::string& HealthCheckRequest::service() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.HealthCheckRequest.service)
  return _internal_service();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HealthCheckRequest::set_service(ArgT0&& arg0, ArgT... args) {
 
 _impl_.service_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.common.v1.HealthCheckRequest.service)
}
inline std::string* HealthCheckRequest::mutable_service() {
  std::string* _s = _internal_mutable_service();
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.HealthCheckRequest.service)
  return _s;
}
inline const std::string& HealthCheckRequest::_internal_service() const {
  return _impl_.service_.Get();
}
inline void HealthCheckRequest::_internal_set_service(const std::string& value) {
  
  _impl_.service_.Set(value, GetArenaForAllocation());
}
inline std::string* HealthCheckRequest::_internal_mutable_service() {
  
  return _impl_.service_.Mutable(GetArenaForAllocation());
}
inline std::string* HealthCheckRequest::release_service() {
  // @@protoc_insertion_point(field_release:unhinged.common.v1.HealthCheckRequest.service)
  return _impl_.service_.Release();
}
inline void HealthCheckRequest::set_allocated_service(std::string* service) {
  if (service != nullptr) {
    
  } else {
    
  }
  _impl_.service_.SetAllocated(service, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.service_.IsDefault()) {
    _impl_.service_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.common.v1.HealthCheckRequest.service)
}

// bool include_dependencies = 2;
inline void HealthCheckRequest::clear_include_dependencies() {
  _impl_.include_dependencies_ = false;
}
inline bool HealthCheckRequest::_internal_include_dependencies() const {
  return _impl_.include_dependencies_;
}
inline bool HealthCheckRequest::include_dependencies() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.HealthCheckRequest.include_dependencies)
  return _internal_include_dependencies();
}
inline void HealthCheckRequest::_internal_set_include_dependencies(bool value) {
  
  _impl_.include_dependencies_ = value;
}
inline void HealthCheckRequest::set_include_dependencies(bool value) {
  _internal_set_include_dependencies(value);
  // @@protoc_insertion_point(field_set:unhinged.common.v1.HealthCheckRequest.include_dependencies)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// HealthCheckResponse

// .unhinged.common.v1.HealthStatus status = 1;
inline void HealthCheckResponse::clear_status() {
  _impl_.status_ = 0;
}
inline ::unhinged::common::v1::HealthStatus HealthCheckResponse::_internal_status() const {
  return static_cast< ::unhinged::common::v1::HealthStatus >(_impl_.status_);
}
inline ::unhinged::common::v1::HealthStatus HealthCheckResponse::status() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.HealthCheckResponse.status)
  return _internal_status();
}
inline void HealthCheckResponse::_internal_set_status(::unhinged::common::v1::HealthStatus value) {
  
  _impl_.status_ = value;
}
inline void HealthCheckResponse::set_status(::unhinged::common::v1::HealthStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:unhinged.common.v1.HealthCheckResponse.status)
}

// string message = 2;
inline void HealthCheckResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& HealthCheckResponse::message() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.HealthCheckResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HealthCheckResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.common.v1.HealthCheckResponse.message)
}
inline std::string* HealthCheckResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.HealthCheckResponse.message)
  return _s;
}
inline const std::string& HealthCheckResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void HealthCheckResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* HealthCheckResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* HealthCheckResponse::release_message() {
  // @@protoc_insertion_point(field_release:unhinged.common.v1.HealthCheckResponse.message)
  return _impl_.message_.Release();
}
inline void HealthCheckResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.common.v1.HealthCheckResponse.message)
}

// map<string, string> details = 3;
inline int HealthCheckResponse::_internal_details_size() const {
  return _impl_.details_.size();
}
inline int HealthCheckResponse::details_size() const {
  return _internal_details_size();
}
inline void HealthCheckResponse::clear_details() {
  _impl_.details_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
HealthCheckResponse::_internal_details() const {
  return _impl_.details_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
HealthCheckResponse::details() const {
  // @@protoc_insertion_point(field_map:unhinged.common.v1.HealthCheckResponse.details)
  return _internal_details();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
HealthCheckResponse::_internal_mutable_details() {
  return _impl_.details_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
HealthCheckResponse::mutable_details() {
  // @@protoc_insertion_point(field_mutable_map:unhinged.common.v1.HealthCheckResponse.details)
  return _internal_mutable_details();
}

// .google.protobuf.Timestamp checked_at = 4;
inline bool HealthCheckResponse::_internal_has_checked_at() const {
  return this != internal_default_instance() && _impl_.checked_at_ != nullptr;
}
inline bool HealthCheckResponse::has_checked_at() const {
  return _internal_has_checked_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& HealthCheckResponse::_internal_checked_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.checked_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& HealthCheckResponse::checked_at() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.HealthCheckResponse.checked_at)
  return _internal_checked_at();
}
inline void HealthCheckResponse::unsafe_arena_set_allocated_checked_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* checked_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.checked_at_);
  }
  _impl_.checked_at_ = checked_at;
  if (checked_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.common.v1.HealthCheckResponse.checked_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* HealthCheckResponse::release_checked_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.checked_at_;
  _impl_.checked_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* HealthCheckResponse::unsafe_arena_release_checked_at() {
  // @@protoc_insertion_point(field_release:unhinged.common.v1.HealthCheckResponse.checked_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.checked_at_;
  _impl_.checked_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* HealthCheckResponse::_internal_mutable_checked_at() {
  
  if (_impl_.checked_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.checked_at_ = p;
  }
  return _impl_.checked_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* HealthCheckResponse::mutable_checked_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_checked_at();
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.HealthCheckResponse.checked_at)
  return _msg;
}
inline void HealthCheckResponse::set_allocated_checked_at(::PROTOBUF_NAMESPACE_ID::Timestamp* checked_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.checked_at_);
  }
  if (checked_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(checked_at));
    if (message_arena != submessage_arena) {
      checked_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, checked_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.checked_at_ = checked_at;
  // @@protoc_insertion_point(field_set_allocated:unhinged.common.v1.HealthCheckResponse.checked_at)
}

// .google.protobuf.Duration response_time = 5;
inline bool HealthCheckResponse::_internal_has_response_time() const {
  return this != internal_default_instance() && _impl_.response_time_ != nullptr;
}
inline bool HealthCheckResponse::has_response_time() const {
  return _internal_has_response_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& HealthCheckResponse::_internal_response_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = _impl_.response_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& HealthCheckResponse::response_time() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.HealthCheckResponse.response_time)
  return _internal_response_time();
}
inline void HealthCheckResponse::unsafe_arena_set_allocated_response_time(
    ::PROTOBUF_NAMESPACE_ID::Duration* response_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_time_);
  }
  _impl_.response_time_ = response_time;
  if (response_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.common.v1.HealthCheckResponse.response_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* HealthCheckResponse::release_response_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.response_time_;
  _impl_.response_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* HealthCheckResponse::unsafe_arena_release_response_time() {
  // @@protoc_insertion_point(field_release:unhinged.common.v1.HealthCheckResponse.response_time)
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = _impl_.response_time_;
  _impl_.response_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* HealthCheckResponse::_internal_mutable_response_time() {
  
  if (_impl_.response_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    _impl_.response_time_ = p;
  }
  return _impl_.response_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* HealthCheckResponse::mutable_response_time() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_response_time();
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.HealthCheckResponse.response_time)
  return _msg;
}
inline void HealthCheckResponse::set_allocated_response_time(::PROTOBUF_NAMESPACE_ID::Duration* response_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.response_time_);
  }
  if (response_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response_time));
    if (message_arena != submessage_arena) {
      response_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.response_time_ = response_time;
  // @@protoc_insertion_point(field_set_allocated:unhinged.common.v1.HealthCheckResponse.response_time)
}

// -------------------------------------------------------------------

// StandardResponse

// bool success = 1;
inline void StandardResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool StandardResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool StandardResponse::success() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.StandardResponse.success)
  return _internal_success();
}
inline void StandardResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void StandardResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:unhinged.common.v1.StandardResponse.success)
}

// string message = 2;
inline void StandardResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& StandardResponse::message() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.StandardResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StandardResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.common.v1.StandardResponse.message)
}
inline std::string* StandardResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.StandardResponse.message)
  return _s;
}
inline const std::string& StandardResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void StandardResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* StandardResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* StandardResponse::release_message() {
  // @@protoc_insertion_point(field_release:unhinged.common.v1.StandardResponse.message)
  return _impl_.message_.Release();
}
inline void StandardResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.common.v1.StandardResponse.message)
}

// .unhinged.common.v1.Error error = 3;
inline bool StandardResponse::_internal_has_error() const {
  return this != internal_default_instance() && _impl_.error_ != nullptr;
}
inline bool StandardResponse::has_error() const {
  return _internal_has_error();
}
inline void StandardResponse::clear_error() {
  if (GetArenaForAllocation() == nullptr && _impl_.error_ != nullptr) {
    delete _impl_.error_;
  }
  _impl_.error_ = nullptr;
}
inline const ::unhinged::common::v1::Error& StandardResponse::_internal_error() const {
  const ::unhinged::common::v1::Error* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::unhinged::common::v1::Error&>(
      ::unhinged::common::v1::_Error_default_instance_);
}
inline const ::unhinged::common::v1::Error& StandardResponse::error() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.StandardResponse.error)
  return _internal_error();
}
inline void StandardResponse::unsafe_arena_set_allocated_error(
    ::unhinged::common::v1::Error* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.common.v1.StandardResponse.error)
}
inline ::unhinged::common::v1::Error* StandardResponse::release_error() {
  
  ::unhinged::common::v1::Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::unhinged::common::v1::Error* StandardResponse::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:unhinged.common.v1.StandardResponse.error)
  
  ::unhinged::common::v1::Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::unhinged::common::v1::Error* StandardResponse::_internal_mutable_error() {
  
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::unhinged::common::v1::Error>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::unhinged::common::v1::Error* StandardResponse::mutable_error() {
  ::unhinged::common::v1::Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.StandardResponse.error)
  return _msg;
}
inline void StandardResponse::set_allocated_error(::unhinged::common::v1::Error* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:unhinged.common.v1.StandardResponse.error)
}

// .google.protobuf.Struct metadata = 4;
inline bool StandardResponse::_internal_has_metadata() const {
  return this != internal_default_instance() && _impl_.metadata_ != nullptr;
}
inline bool StandardResponse::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& StandardResponse::_internal_metadata() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& StandardResponse::metadata() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.StandardResponse.metadata)
  return _internal_metadata();
}
inline void StandardResponse::unsafe_arena_set_allocated_metadata(
    ::PROTOBUF_NAMESPACE_ID::Struct* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.common.v1.StandardResponse.metadata)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* StandardResponse::release_metadata() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* StandardResponse::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:unhinged.common.v1.StandardResponse.metadata)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* StandardResponse::_internal_mutable_metadata() {
  
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* StandardResponse::mutable_metadata() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.StandardResponse.metadata)
  return _msg;
}
inline void StandardResponse::set_allocated_metadata(::PROTOBUF_NAMESPACE_ID::Struct* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:unhinged.common.v1.StandardResponse.metadata)
}

// string request_id = 5;
inline void StandardResponse::clear_request_id() {
  _impl_.request_id_.ClearToEmpty();
}
inline const std::string& StandardResponse::request_id() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.StandardResponse.request_id)
  return _internal_request_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StandardResponse::set_request_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.request_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.common.v1.StandardResponse.request_id)
}
inline std::string* StandardResponse::mutable_request_id() {
  std::string* _s = _internal_mutable_request_id();
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.StandardResponse.request_id)
  return _s;
}
inline const std::string& StandardResponse::_internal_request_id() const {
  return _impl_.request_id_.Get();
}
inline void StandardResponse::_internal_set_request_id(const std::string& value) {
  
  _impl_.request_id_.Set(value, GetArenaForAllocation());
}
inline std::string* StandardResponse::_internal_mutable_request_id() {
  
  return _impl_.request_id_.Mutable(GetArenaForAllocation());
}
inline std::string* StandardResponse::release_request_id() {
  // @@protoc_insertion_point(field_release:unhinged.common.v1.StandardResponse.request_id)
  return _impl_.request_id_.Release();
}
inline void StandardResponse::set_allocated_request_id(std::string* request_id) {
  if (request_id != nullptr) {
    
  } else {
    
  }
  _impl_.request_id_.SetAllocated(request_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.request_id_.IsDefault()) {
    _impl_.request_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.common.v1.StandardResponse.request_id)
}

// -------------------------------------------------------------------

// AuditInfo

// string user_id = 1;
inline void AuditInfo::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& AuditInfo::user_id() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.AuditInfo.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuditInfo::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.common.v1.AuditInfo.user_id)
}
inline std::string* AuditInfo::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.AuditInfo.user_id)
  return _s;
}
inline const std::string& AuditInfo::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void AuditInfo::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AuditInfo::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AuditInfo::release_user_id() {
  // @@protoc_insertion_point(field_release:unhinged.common.v1.AuditInfo.user_id)
  return _impl_.user_id_.Release();
}
inline void AuditInfo::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.common.v1.AuditInfo.user_id)
}

// string session_id = 2;
inline void AuditInfo::clear_session_id() {
  _impl_.session_id_.ClearToEmpty();
}
inline const std::string& AuditInfo::session_id() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.AuditInfo.session_id)
  return _internal_session_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuditInfo::set_session_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.session_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.common.v1.AuditInfo.session_id)
}
inline std::string* AuditInfo::mutable_session_id() {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.AuditInfo.session_id)
  return _s;
}
inline const std::string& AuditInfo::_internal_session_id() const {
  return _impl_.session_id_.Get();
}
inline void AuditInfo::_internal_set_session_id(const std::string& value) {
  
  _impl_.session_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AuditInfo::_internal_mutable_session_id() {
  
  return _impl_.session_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AuditInfo::release_session_id() {
  // @@protoc_insertion_point(field_release:unhinged.common.v1.AuditInfo.session_id)
  return _impl_.session_id_.Release();
}
inline void AuditInfo::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  _impl_.session_id_.SetAllocated(session_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.session_id_.IsDefault()) {
    _impl_.session_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.common.v1.AuditInfo.session_id)
}

// string ip_address = 3;
inline void AuditInfo::clear_ip_address() {
  _impl_.ip_address_.ClearToEmpty();
}
inline const std::string& AuditInfo::ip_address() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.AuditInfo.ip_address)
  return _internal_ip_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuditInfo::set_ip_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ip_address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.common.v1.AuditInfo.ip_address)
}
inline std::string* AuditInfo::mutable_ip_address() {
  std::string* _s = _internal_mutable_ip_address();
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.AuditInfo.ip_address)
  return _s;
}
inline const std::string& AuditInfo::_internal_ip_address() const {
  return _impl_.ip_address_.Get();
}
inline void AuditInfo::_internal_set_ip_address(const std::string& value) {
  
  _impl_.ip_address_.Set(value, GetArenaForAllocation());
}
inline std::string* AuditInfo::_internal_mutable_ip_address() {
  
  return _impl_.ip_address_.Mutable(GetArenaForAllocation());
}
inline std::string* AuditInfo::release_ip_address() {
  // @@protoc_insertion_point(field_release:unhinged.common.v1.AuditInfo.ip_address)
  return _impl_.ip_address_.Release();
}
inline void AuditInfo::set_allocated_ip_address(std::string* ip_address) {
  if (ip_address != nullptr) {
    
  } else {
    
  }
  _impl_.ip_address_.SetAllocated(ip_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ip_address_.IsDefault()) {
    _impl_.ip_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.common.v1.AuditInfo.ip_address)
}

// string user_agent = 4;
inline void AuditInfo::clear_user_agent() {
  _impl_.user_agent_.ClearToEmpty();
}
inline const std::string& AuditInfo::user_agent() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.AuditInfo.user_agent)
  return _internal_user_agent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuditInfo::set_user_agent(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_agent_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.common.v1.AuditInfo.user_agent)
}
inline std::string* AuditInfo::mutable_user_agent() {
  std::string* _s = _internal_mutable_user_agent();
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.AuditInfo.user_agent)
  return _s;
}
inline const std::string& AuditInfo::_internal_user_agent() const {
  return _impl_.user_agent_.Get();
}
inline void AuditInfo::_internal_set_user_agent(const std::string& value) {
  
  _impl_.user_agent_.Set(value, GetArenaForAllocation());
}
inline std::string* AuditInfo::_internal_mutable_user_agent() {
  
  return _impl_.user_agent_.Mutable(GetArenaForAllocation());
}
inline std::string* AuditInfo::release_user_agent() {
  // @@protoc_insertion_point(field_release:unhinged.common.v1.AuditInfo.user_agent)
  return _impl_.user_agent_.Release();
}
inline void AuditInfo::set_allocated_user_agent(std::string* user_agent) {
  if (user_agent != nullptr) {
    
  } else {
    
  }
  _impl_.user_agent_.SetAllocated(user_agent, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_agent_.IsDefault()) {
    _impl_.user_agent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.common.v1.AuditInfo.user_agent)
}

// .google.protobuf.Timestamp timestamp = 5;
inline bool AuditInfo::_internal_has_timestamp() const {
  return this != internal_default_instance() && _impl_.timestamp_ != nullptr;
}
inline bool AuditInfo::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& AuditInfo::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& AuditInfo::timestamp() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.AuditInfo.timestamp)
  return _internal_timestamp();
}
inline void AuditInfo::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.common.v1.AuditInfo.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* AuditInfo::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* AuditInfo::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:unhinged.common.v1.AuditInfo.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* AuditInfo::_internal_mutable_timestamp() {
  
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* AuditInfo::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.AuditInfo.timestamp)
  return _msg;
}
inline void AuditInfo::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:unhinged.common.v1.AuditInfo.timestamp)
}

// string action = 6;
inline void AuditInfo::clear_action() {
  _impl_.action_.ClearToEmpty();
}
inline const std::string& AuditInfo::action() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.AuditInfo.action)
  return _internal_action();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuditInfo::set_action(ArgT0&& arg0, ArgT... args) {
 
 _impl_.action_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:unhinged.common.v1.AuditInfo.action)
}
inline std::string* AuditInfo::mutable_action() {
  std::string* _s = _internal_mutable_action();
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.AuditInfo.action)
  return _s;
}
inline const std::string& AuditInfo::_internal_action() const {
  return _impl_.action_.Get();
}
inline void AuditInfo::_internal_set_action(const std::string& value) {
  
  _impl_.action_.Set(value, GetArenaForAllocation());
}
inline std::string* AuditInfo::_internal_mutable_action() {
  
  return _impl_.action_.Mutable(GetArenaForAllocation());
}
inline std::string* AuditInfo::release_action() {
  // @@protoc_insertion_point(field_release:unhinged.common.v1.AuditInfo.action)
  return _impl_.action_.Release();
}
inline void AuditInfo::set_allocated_action(std::string* action) {
  if (action != nullptr) {
    
  } else {
    
  }
  _impl_.action_.SetAllocated(action, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.action_.IsDefault()) {
    _impl_.action_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:unhinged.common.v1.AuditInfo.action)
}

// .google.protobuf.Struct context = 7;
inline bool AuditInfo::_internal_has_context() const {
  return this != internal_default_instance() && _impl_.context_ != nullptr;
}
inline bool AuditInfo::has_context() const {
  return _internal_has_context();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& AuditInfo::_internal_context() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.context_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& AuditInfo::context() const {
  // @@protoc_insertion_point(field_get:unhinged.common.v1.AuditInfo.context)
  return _internal_context();
}
inline void AuditInfo::unsafe_arena_set_allocated_context(
    ::PROTOBUF_NAMESPACE_ID::Struct* context) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.context_);
  }
  _impl_.context_ = context;
  if (context) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:unhinged.common.v1.AuditInfo.context)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AuditInfo::release_context() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.context_;
  _impl_.context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AuditInfo::unsafe_arena_release_context() {
  // @@protoc_insertion_point(field_release:unhinged.common.v1.AuditInfo.context)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.context_;
  _impl_.context_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AuditInfo::_internal_mutable_context() {
  
  if (_impl_.context_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.context_ = p;
  }
  return _impl_.context_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* AuditInfo::mutable_context() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_context();
  // @@protoc_insertion_point(field_mutable:unhinged.common.v1.AuditInfo.context)
  return _msg;
}
inline void AuditInfo::set_allocated_context(::PROTOBUF_NAMESPACE_ID::Struct* context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.context_);
  }
  if (context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(context));
    if (message_arena != submessage_arena) {
      context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, context, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.context_ = context;
  // @@protoc_insertion_point(field_set_allocated:unhinged.common.v1.AuditInfo.context)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace common
}  // namespace unhinged

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::unhinged::common::v1::ChunkType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::unhinged::common::v1::ChunkType>() {
  return ::unhinged::common::v1::ChunkType_descriptor();
}
template <> struct is_proto_enum< ::unhinged::common::v1::ChunkStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::unhinged::common::v1::ChunkStatus>() {
  return ::unhinged::common::v1::ChunkStatus_descriptor();
}
template <> struct is_proto_enum< ::unhinged::common::v1::AttachmentType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::unhinged::common::v1::AttachmentType>() {
  return ::unhinged::common::v1::AttachmentType_descriptor();
}
template <> struct is_proto_enum< ::unhinged::common::v1::ErrorCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::unhinged::common::v1::ErrorCode>() {
  return ::unhinged::common::v1::ErrorCode_descriptor();
}
template <> struct is_proto_enum< ::unhinged::common::v1::FilterOperator> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::unhinged::common::v1::FilterOperator>() {
  return ::unhinged::common::v1::FilterOperator_descriptor();
}
template <> struct is_proto_enum< ::unhinged::common::v1::HealthStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::unhinged::common::v1::HealthStatus>() {
  return ::unhinged::common::v1::HealthStatus_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_common_2eproto
